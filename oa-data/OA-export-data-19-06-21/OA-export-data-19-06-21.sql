--------------------------------------------------------
--  File created - Saturday-June-19-2021   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Type RC_LBRECSETIMPL_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."RC_LBRECSETIMPL_T" authid current_user as object 
  (
  curval                number,   -- current rownum
  done                  number,   -- done with the query
  needobsolete          number,   -- user interested in obsolete col
 
  static function ODCITableStart(sctx   IN OUT rc_lbRecSetImpl_t)
    return number,
 
  member function ODCITableFetch(self   IN OUT rc_lbRecSetImpl_t, 
                                 nrows  IN     number, 
                                 objSet OUT    rc_lbRecSet_t) 
    return number,
 
  member function ODCITableClose(self   IN     rc_lbRecSetImpl_t) 
    return number
  )
/
CREATE OR REPLACE EDITIONABLE TYPE BODY "OPENACCESS"."RC_LBRECSETIMPL_T" is
 
--
--
--
 
  static function ODCITableStart(sctx IN OUT rc_lbRecSetImpl_t) 
    return number is
  begin
--
    sctx:=rc_lbRecSetImpl_t(0, 0, 1);
    return SYS.ODCIConst.Success;
  end ODCITableStart;
 
--
--
--
--
  member function ODCITableFetch(self   IN OUT rc_lbRecSetImpl_t, 
                                 nrows  IN     number, 
                                 objSet OUT    rc_lbRecSet_t) 
    return number is
    n number := 0;
    firstCall       boolean := TRUE;
    ret             boolean := TRUE;
    redundancy      number;
    recovery_window number;
    untilTime       date;
    lbRec           dbms_rcvman.lbrec_t;
    lbCursor        dbms_rcvman.lbCursor_t;
    lbState         dbms_rcvman.lbState_t;
  begin
    objSet:=rc_lbRecSet_t();
 
--
    dbms_rcvman.resetAll;
 
    redundancy := 1;
    recovery_window := 0;
 
--
--
--
    dbms_rcvman.getRetentionPolicy(recovery_window, redundancy);
 
--
    dbms_rcvman.setAllIncarnations(TRUE);
 
--
    if (recovery_window > 0) then
      SELECT (sysdate-recovery_window) INTO untilTime from dual;
      dbms_rcvman.setUntilTime(untilTime);
    end if;
 
    dbms_rcvman.setDeviceTypeAny;
 
    if (recovery_window = 0 and redundancy = 0) then
--
       dbms_rcvman.setNeedObsoleteData(false);
    else
       if self.needobsolete = 1 then
          dbms_rcvman.setNeedObsoleteData(true);
       else
          dbms_rcvman.setNeedObsoleteData(false);
       end if;
    end if;
 
    while ret and self.done = 0 loop
      ret := dbms_rcvman.listBackup(lbRec, firstCall, FALSE, 
                                    redundancy, TRUE, lbCursor, lbState, null);
      if (lbRec.pkey is not null) then
        objSet.extend;
        n := n + 1;
        objSet(n):= rc_lbRec_t(
                            to_number(null),   -- list_order1
                            to_number(null),   -- list_order2
                            to_number(null),   -- pkey
                            to_char(null),     -- backup_type
                            to_char(null),     -- file_type
                            to_char(null),     -- keep
                            to_date(null),     -- keep_until
                            to_char(null),     -- keep_options
                            to_char(null),     -- status
                            to_char(null),     -- fname
                            to_char(null),     -- tag
                            to_char(null),     -- media
                            to_number(null),   -- recid
                            to_number(null),   -- stamp
                            to_char(null),     -- device_type
                            to_number(null),   -- block_size
                            to_date(null),     -- completion_time
                            to_char(null),     -- is_rdf
                            to_char(null),     -- compressed
                            to_char(null),     -- obsolete
                            to_number(null),   -- bytes
                            to_number(null),   -- bs_key
                            to_number(null),   -- bs_count
                            to_number(null),   -- bs_stamp
                            to_char(null),     -- bs_type
                            to_char(null),     -- bs_incr_type
                            to_number(null),   -- bs_pieces
                            to_number(null),   -- bs_copies
                            to_date(null),     -- bs_completion_time
                            to_char(null),     -- bs_status
                            to_number(null),   -- bs_bytes
                            to_char(null),     -- bs_compressed
                            to_char(null),     -- bs_tag
                            to_char(null),     -- bs_device_type
                            to_number(null),   -- bp_piece#
                            to_number(null),   -- bp_copy#
                            to_number(null),   -- df_file#
                            to_number(null),   -- df_ts#
                            to_number(null),   -- df_plugin_change#
                            to_number(null),   -- df_foreign_dbid
                            to_char(null),     -- df_tablespace
                            to_number(null),   -- df_resetlogs_change#
                            to_number(null),   -- df_creation_change#
                            to_number(null),   -- df_checkpoint_change#
                            to_date(null),     -- df_ckp_mod_time
                            to_number(null),   -- df_incremental_change#
                            to_number(null),   -- rl_thread#
                            to_number(null),   -- rl_sequence#
                            to_number(null),   -- rl_resetlogs_change#
                            to_number(null),   -- rl_first_change#
                            to_date(null),     -- rl_first_time
                            to_number(null),   -- rl_next_change#
                            to_date(null));    -- rl_next_time
        objSet(n).list_order1            := lbRec.list_order1;
        objSet(n).list_order2            := lbRec.list_order2;
        objSet(n).pkey                   := lbRec.pkey;
        objSet(n).backup_type            := lbRec.backup_type;
        objSet(n).file_type              := lbRec.file_type;
        objSet(n).keep                   := lbRec.keep;
        objSet(n).keep_until             := lbRec.keep_until;
        objSet(n).keep_options           := lbRec.keep_options;
        objSet(n).status                 := lbRec.status;
        objSet(n).fname                  := lbRec.fname;
        objSet(n).tag                    := lbRec.tag;
        objSet(n).media                  := lbRec.media;
        objSet(n).recid                  := lbRec.stamp;
        objSet(n).stamp                  := lbRec.stamp;
        objSet(n).device_type            := lbRec.device_type;
        objSet(n).block_size             := lbRec.block_size;
        objSet(n).completion_time        := lbRec.completion_time;
        objSet(n).is_rdf                 := lbRec.is_rdf;
        objSet(n).compressed             := lbRec.compressed;
        objSet(n).obsolete               := lbRec.obsolete;
        objSet(n).bytes                  := lbRec.bytes;
        objSet(n).bs_key                 := lbRec.bs_key;
        objSet(n).bs_count               := lbRec.bs_count;
        objSet(n).bs_stamp               := lbRec.bs_stamp;
        objSet(n).bs_type                := lbRec.bs_type;
        objSet(n).bs_incr_type           := lbRec.bs_incr_type;
        objSet(n).bs_pieces              := lbRec.bs_pieces;
        objSet(n).bs_copies              := lbRec.bs_copies;
        objSet(n).bs_completion_time     := lbRec.bs_completion_time;
        objSet(n).bs_status              := lbRec.bs_status;
        objSet(n).bs_bytes               := lbRec.bs_bytes;
        objSet(n).bs_compressed          := lbRec.bs_compressed;
        objSet(n).bs_tag                 := lbRec.bs_tag;
        objSet(n).bs_device_type         := lbRec.bs_device_type;
        objSet(n).bp_piece#              := lbRec.bp_piece#;
        objSet(n).bp_copy#               := lbRec.bp_copy#;
        objSet(n).df_file#               := lbRec.df_file#;
        objSet(n).df_ts#                 := lbRec.df_ts#;
        objSet(n).df_plugin_change#      := lbRec.df_plugin_change#;
        objSet(n).df_foreign_dbid        := lbRec.df_foreign_dbid;
        objSet(n).df_tablespace          := lbRec.df_tablespace;
        objSet(n).df_resetlogs_change#   := lbRec.df_resetlogs_change#;
        objSet(n).df_creation_change#    := lbRec.df_creation_change#;
        objSet(n).df_checkpoint_change#  := lbRec.df_checkpoint_change#;
        objSet(n).df_ckp_mod_time        := lbRec.df_ckp_mod_time;
        objSet(n).df_incremental_change# := lbRec.df_incremental_change#;
        objSet(n).rl_thread#             := lbRec.rl_thread#;
        objSet(n).rl_sequence#           := lbRec.rl_sequence#;
        objSet(n).rl_resetlogs_change#   := lbRec.rl_resetlogs_change#;
        objSet(n).rl_first_change#       := lbRec.rl_first_change#;
        objSet(n).rl_first_time          := lbRec.rl_first_time;
        objSet(n).rl_next_change#        := lbRec.rl_next_change#;
        objSet(n).rl_next_time           := lbRec.rl_next_time;
      end if;
      firstCall := false;
      self.curval:=self.curval+1;
      if not ret then
        self.done := 1;
      end if;
    end loop;
    return SYS.ODCIConst.Success;
  end ODCITableFetch;
 
  member function ODCITableClose(self IN rc_lbRecSetImpl_t) 
    return number is
  begin
    return SYS.ODCIConst.Success;
  end ODCITableClose;
end;

/
--------------------------------------------------------
--  DDL for Type RC_LBRECSET_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."RC_LBRECSET_T" as table of rc_lbRec_t

/
--------------------------------------------------------
--  DDL for Type RC_LBREC_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."RC_LBREC_T" authid current_user as object
   (
      list_order1               NUMBER,
      list_order2               NUMBER,
      pkey                      NUMBER,
      backup_type               VARCHAR2(32),
      file_type                 VARCHAR2(32),
      keep                      VARCHAR2(3),
      keep_until                DATE,
      keep_options              VARCHAR2(13),
      status                    VARCHAR2(16),
      fname                     VARCHAR2(1024),
      tag                       VARCHAR2(32),
      media                     VARCHAR2(80),
      recid                     NUMBER,
      stamp                     NUMBER,
      device_type               VARCHAR2(255),
      block_size                NUMBER,
      completion_time           DATE,
      is_rdf                    VARCHAR2(3),
      compressed                VARCHAR2(3),
      obsolete                  VARCHAR2(3),
      bytes                     NUMBER,
 
      bs_key                    NUMBER,
      bs_count                  NUMBER,
      bs_stamp                  NUMBER,
      bs_type                   VARCHAR2(32),
      bs_incr_type              VARCHAR2(32),
      bs_pieces                 NUMBER,
      bs_copies                 NUMBER,
      bs_completion_time        DATE,
      bs_status                 VARCHAR2(16),
      bs_bytes                  NUMBER,
      bs_compressed             VARCHAR2(3),
      bs_tag                    VARCHAR2(1024),
      bs_device_type            VARCHAR2(255),
 
      bp_piece#                 NUMBER,
      bp_copy#                  NUMBER,
 
      df_file#                  NUMBER,
      df_ts#                    NUMBER,
      df_plugin_change#         NUMBER,
      df_foreign_dbid           NUMBER,
      df_tablespace             VARCHAR2(30),
      df_resetlogs_change#      NUMBER,
      df_creation_change#       NUMBER,
      df_checkpoint_change#     NUMBER,
      df_ckp_mod_time           DATE,
      df_incremental_change#    NUMBER,
 
      rl_thread#                NUMBER,
      rl_sequence#              NUMBER,
      rl_resetlogs_change#      NUMBER,
      rl_first_change#          NUMBER,
      rl_first_time             DATE,
      rl_next_change#           NUMBER,
      rl_next_time              DATE
   )

/
--------------------------------------------------------
--  DDL for Type RC_RANGERECSETIMPL_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."RC_RANGERECSETIMPL_T" authid current_user as object
  (
  curval                number,        -- current rownum
  done                  number,        -- done with the query
  opCode                varchar2(20),  -- backup/log location
 
  static function ODCITableStart(sctx   IN OUT rc_RangeRecSetImpl_t,
                                 opCode IN     varchar2)
    return number,
 
  member function ODCITableFetch(self   IN OUT rc_RangeRecSetImpl_t,
                                 nrows  IN     number,
                                 objSet OUT    rc_RangeRecSet_t)
    return number,
 
  member function ODCITableClose(self   IN     rc_RangeRecSetImpl_t)
    return number
   )
/
CREATE OR REPLACE EDITIONABLE TYPE BODY "OPENACCESS"."RC_RANGERECSETIMPL_T" is
  
  static function ODCITableStart(sctx   IN OUT rc_RangeRecSetImpl_t,
                                 opCode IN varchar2)
    return number is
    PRAGMA AUTONOMOUS_TRANSACTION;
  begin
--
    sctx:=rc_RangeRecSetImpl_t(0, 0, opCode);   
    return SYS.ODCIConst.Success;
  end ODCITableStart;
  
  member function ODCITableFetch(self   IN OUT rc_RangeRecSetImpl_t,
                                 nrows  IN     number,
                                 objSet OUT    rc_RangeRecSet_t)
    return number is
    PRAGMA AUTONOMOUS_TRANSACTION;
 
    n                number := 0;
    i                number;
    indx             number := 0;
    ret              boolean;
    isOrs            number := 0;
    site_aware       boolean;
    dbid             number := 0;
    dbkey            number := 0;
    sitekey          number := 0;
    single_site      boolean := false;  -- true means we are interested in
--
    hashval_old      number;
    hashval_new      number;
    high_bp_key_new  number := 0;
    last_do_key_new  number := 0;
    valfound         boolean;
    no_of_entries    number := 0;
    no_of_db         number := 0;
    dev_type       varchar(32);
    high_bp_key_old  number;
    last_do_key_old  number;
    max_range_scn    number;
    maxScnExist      boolean;
    maxScn           number;
    maxTime          date;
    maxDbIncKey      number;
    maxRlgScn        number;
    maxRlgTime       date;
    logMissing       boolean;
    logBreakPointScn number;
    logBreakPointTime date;
    logBreakDbIncKey  number;
    logBreakRlgScn    number;
    logBreakRlgTime   date;
    restoreRangeTab  dbms_rcvman.restoreRangeTab_t;
 
    CURSOR getAllDb_c IS SELECT db_key, db_id FROM db;
    CURSOR getAllSite_c IS SELECT site_key, db.db_key, db_unique_name, db_id  
           FROM node, db WHERE node.db_key = db.db_key order by db_key;
    CURSOR restore_range_c ( dbkey_p IN number, dev_type_p IN varchar2)
           IS SELECT * FROM rrcache
             WHERE db_key = dbkey_p AND range_type=dev_type_p; 
 
    dbDetail         getAllDb_c%rowtype;
    siteDetail       getAllSite_c%rowtype;
    restore_range_r  restore_range_c%rowtype;
 
  begin
    dbkey := dbms_rcvman.getDbKey;
 
--
    if dbkey is null then
       single_site := false;
       open getAllDb_c;
       open getAllSite_c;
    else  -- user is interested for a particular db
       SELECT db_id INTO dbid from db where db_key = dbkey; 
       single_site := true;
    end if;
    
    objSet := rc_RangeRecSet_t();
 
    if (single_site = false) then
       dbms_rcvman.resetAll;
    end if;
 
    dbms_rcvman.setAllIncarnations(TRUE);
 
--
    if (substr(opCode,  1, 2) = 'RA') then
       isOrs := 1;
    else
       isOrs := 0;
    end if;
 
--
    dbms_rcvman.resetDeviceType;
 
--
    if (isOrs = 1) then
       dbms_rcvman.setDeviceType('SBT_TAPE');
       if (substr(opCode,  4, 3) = 'ANY') then
          dev_type := 'RA$ANY';
       elsif (substr(opCode,  4, 4) = 'DISK') then
          dev_type := 'RA$DISK';
       elsif (substr(opCode,  4, 3) = 'SBT') then
          dev_type := 'RA$SBT';
       end if;
    else
       if (substr(opCode,  4, 3) = 'ANY') then
          dbms_rcvman.setDeviceTypeAny;
          dev_type := 'RC$ANY';
       elsif (substr(opCode,  4, 4) = 'DISK') then
          dbms_rcvman.setDeviceType('DISK');
          dev_type := 'RC$DISK';
       elsif (substr(opCode,  4, 3) = 'SBT') then
          dbms_rcvman.setDeviceType('SBT_TAPE');
          dev_type := 'RC$SBT';
       end if;
    end if;
 
    if ((substr(opCode,  8, 10) = 'SITE_AWARE') or
        (substr(opCode,  9, 10) = 'SITE_AWARE')) then
       site_aware := TRUE;
    else
       site_aware := FALSE;
    end if;
 
--
    WHILE self.done = 0 LOOP
      n := n + 1;
 
      exit when n = 2 and single_site = true;
 
      IF (isOrs = 1) THEN
        if (single_site = false) then
           fetch getAllDb_c into dbDetail;
           exit when getAllDb_c%NOTFOUND;
           dbkey := dbDetail.db_key;
           dbid := dbDetail.db_id;
        end if;
      ELSE
        if (single_site = false) then
           fetch getAllSite_c into siteDetail;
           exit when getAllSite_c%NOTFOUND;
           dbkey := siteDetail.db_key;
           dbid := siteDetail.db_id;
           sitekey := siteDetail.site_key;
        end if;
      END IF;
 
--
      select max(max_bp_key) into high_bp_key_old from rrcache
         where db_key = dbkey and range_type = dev_type;
      select max(last_do_key) into last_do_key_old from rrcache
         where db_key = dbkey and range_type = dev_type;
 
--
      IF (isOrs = 1) THEN
        SELECT NVL(MAX(bp_key), 0) INTO  high_bp_key_new FROM 
          (SELECT bp_key FROM bp  
             WHERE db_key = dbkey
               ORDER BY 1 DESC)
          WHERE ROWNUM = 1;
      ELSE
        high_bp_key_new := 0;
      END IF;
  
      SELECT NVL(MAX(curr_value), 0) INTO last_do_key_new
        FROM do_seq
        WHERE db_key = dbkey;
 
      valfound := FALSE;
 
--
--
--
--
      IF (isOrs = 0) THEN
         valfound := FALSE;
--
--
--
      ELSIF (high_bp_key_old < high_bp_key_new 
          and last_do_key_new = last_do_key_old)
      THEN
         dbms_rcvman.setRestoreRangeDevTyp(dev_type);
         ret := dbms_rcvman.setLocalOrsSiteKey(dbid);
 
--
--
--
         IF ret = TRUE THEN 
            maxScnExist  := dbms_rcvman.getMaxRedoSCN(maxScn, maxTime, 
                                                      maxDbIncKey, maxRlgScn, 
                                                      maxRlgTime, isOrs);
            IF (maxScnExist) THEN
               SELECT nvl(max(high_scn), 0) INTO max_range_scn  
                 FROM rrcache
                 WHERE db_key = dbkey AND range_type = dev_type AND
                    high_scn < maxScn;
--
--
               logMissing := dbms_rcvman.findLogBreakPoint(logBreakPointScn,
                                                           logBreakPointTime,
                                                           logBreakDbIncKey, 
                                                           logBreakRlgScn,
                                                           logBreakRlgTime, 
                                                           max_range_scn, 
                                                           maxScn, isOrs); 
               IF (logMissing = FALSE and max_range_scn > 0) THEN
                  UPDATE rrcache SET high_scn = maxScn,
                      high_time = maxTime, high_dbinc_key = maxDbIncKey,
                      last_updated = sysdate 
                    WHERE db_key = dbkey and range_type = dev_type and 
                          high_scn = max_range_scn;
                  commit;
                  valfound := TRUE;
               END IF;
            END IF;
         END IF;
 
         dbms_rcvman.resetLocalOrsSiteKey;
         dbms_rcvman.resetRestoreRangeDevTyp;  
      ELSIF (high_bp_key_old = high_bp_key_new 
             and last_do_key_new = last_do_key_old) 
      THEN
         valfound := true;
      END IF;
 
      if valfound = false then
        if single_site = false then
           if (isOrs = 1) then
               dbms_rcvman.setdatabase(NULL, NULL, NULL, dbDetail.db_id);
           else
               dbms_rcvman.setdatabase(db_name        => NULL,
                                      reset_scn      => NULL,
                                      reset_time     => NULL,
                                      db_id          => siteDetail.db_id,
                                      db_unique_name =>
                                                    siteDetail.db_unique_name,
                                     site_aware     => site_aware,
                                     dummy_instance => FALSE,
                                     ors_instance   => FALSE);
 
           end if;
        end if;
 
        ret := dbms_rcvman.getRestoreRangeSet(restoreRangeTab,
                                              opCode,
                                              dbid);
      end if;
 
--
--
      IF (valfound = true) then
        OPEN restore_range_c(dbkey, dev_type);
        loop
          FETCH restore_range_c INTO restore_range_r;
          EXIT WHEN restore_range_c%NOTFOUND;
          objSet.extend;
          indx := indx + 1;
          objSet(indx) := rc_RangeRec_t(
                                  to_number(null),
                                  to_number(null),
                                  to_date(null),
                                  to_date(null),
                                  to_number(null),
                                  to_number(null),
                                  to_number(null),
                                  to_number(null));
          objSet(indx).db_key         := dbkey;
          objSet(indx).site_key       := sitekey;
          objSet(indx).low_time         := restore_range_r.low_time;
          objSet(indx).high_time        := restore_range_r.high_time;
          objSet(indx).low_scn          := restore_range_r.low_scn;
          objSet(indx).high_scn         := restore_range_r.high_scn;
          objSet(indx).low_dbinc_key    := restore_range_r.low_dbinc_key;
          objSet(indx).high_dbinc_key   := restore_range_r.high_dbInc_key;
        end loop;
        CLOSE restore_range_c;
 
--
--
      ELSE
        no_of_entries := 0;
        i := null;
--
        DELETE FROM rrcache where db_key = dbkey and
          range_type = dev_type;
        commit;
        loop
          if (i is null) then
             i := restoreRangeTab.first;
          else
             i := restoreRangeTab.next(i);
          end if;
          exit when i is NULL;
     
          if (restoreRangeTab(i).isValidRange = TRUE) then
            objSet.extend;
            indx := indx + 1;
            objSet(indx) := rc_RangeRec_t(
                                  to_number(null),
                                  to_number(null),
                                  to_date(null),
                                  to_date(null),
                                  to_number(null),
                                  to_number(null),
                                  to_number(null),
                                  to_number(null));
            if (ret = TRUE) then
              no_of_entries := no_of_entries + 1;
              objSet(indx).db_key         := dbkey;
              objSet(indx).site_key       := sitekey;
 
              objSet(indx).low_time         := restoreRangeTab(i).lowTime;
              objSet(indx).high_time        := restoreRangeTab(i).highTime;
              objSet(indx).low_scn          := restoreRangeTab(i).lowScn;
              objSet(indx).high_scn         := restoreRangeTab(i).highScn;
              objSet(indx).low_dbinc_key    := restoreRangeTab(i).lowDbIncKey;
              objSet(indx).high_dbinc_key   := restoreRangeTab(i).highDbIncKey;
            end if;
          end if;
 
--
          if restoreRangeTab(i).isValidRange = TRUE and ret = TRUE then
            INSERT INTO rrcache(
                          db_key,
                          low_time,
                          high_time,
                          low_scn,
                          high_scn,
                          low_dbinc_key,
                          high_dbinc_key,
                          range_type,
                          max_bp_key,
                          last_do_key,
                          last_updated) values
              (dbkey, restoreRangeTab(i).lowTime,
               restoreRangeTab(i).highTime, restoreRangeTab(i).lowScn,  
               restoreRangeTab(i).highScn, restoreRangeTab(i).lowDbIncKey,  
               restoreRangeTab(i).highDbIncKey, dev_type, high_bp_key_new,
               last_do_key_new, sysdate);
            commit;
          end if;
        end loop;  -- loop ends for each restore range of a database
 
      END IF;  -- end of if (valfound = true)
 
--
      if (single_site = false) then
         dbms_rcvman.resetdbkey;
      end if;
      self.curval := self.curval + 1;
    END LOOP;   -- loop ends for each database
 
--
    if (single_site = false) then
       dbms_rcvman.resetdbkey;
    end if;
    self.done := 1;
    if (single_site = false) then
      close getAllDb_c;
      close getAllSite_c;
    end if;
 
    return SYS.ODCIConst.Success;
 
    EXCEPTION
      WHEN others THEN
      dbms_rcvman.resetDeviceType;
      if getAllDb_c%ISOPEN then
         close getAllDb_c;
      end if;
      if getAllSite_c%ISOPEN then
         close getAllSite_c;
      end if;
      return SYS.ODCIConst.Error;
  end ODCITableFetch;
 
  member function ODCITableClose(self IN rc_RangeRecSetImpl_t)
    return number is
  begin
    return SYS.ODCIConst.Success;
  end ODCITableClose;
end;

/
--------------------------------------------------------
--  DDL for Type RC_RANGERECSET_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."RC_RANGERECSET_T" as table of rc_RangeRec_t

/
--------------------------------------------------------
--  DDL for Type RC_RANGEREC_T
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."RC_RANGEREC_T" authid current_user as object
   (
      db_key            NUMBER,
      site_key          NUMBER,
      high_time         DATE,
      low_time          DATE,
      low_scn           NUMBER,
      high_scn          NUMBER,
      low_dbinc_key     NUMBER,
      high_dbinc_key    NUMBER
   )

/
--------------------------------------------------------
--  DDL for Type UD_EXCESS_BAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."UD_EXCESS_BAL" AS OBJECT 
(
    EXCESS_UNIT_TYPE VARCHAR2(25 BYTE), 
    V_ID VARCHAR2(75 BYTE), 
    ID VARCHAR2(50 BYTE), 
	READING_MONTH VARCHAR2(50 BYTE) , 
	READING_YEAR VARCHAR2(50 BYTE) , 
	M_COMPANY_ID VARCHAR2(50 BYTE), 
	M_COMPANY_NAME VARCHAR2(500 BYTE), 
	M_COMPANY_SERVICE_ID VARCHAR2(50 BYTE), 
	M_COMPANY_SERVICE_NUM VARCHAR2(50 BYTE), 
	BANKING_SERVICE_ID VARCHAR2(50 BYTE), 
	BANKING_SERVICE_NUM VARCHAR2(50 BYTE), 
	OPEN_C1 number(20,5) , 	
	OPEN_C2 number(20,5) , 	
	OPEN_C3 number(20,5) , 	
	OPEN_C4 number(20,5) , 	
	OPEN_C5 number(20,5) , 	
	OPEN_TOTAL_UNITS number(20,5) , 
	OPEN_REMARKS VARCHAR2(500 BYTE),  
	OPEN_UPDATE_DT DATE, 
	INCR_EA1_C1 number(20,5) , 	
    INCR_EA1_C2 number(20,5) , 	
    INCR_EA1_C3 number(20,5) , 	
    INCR_EA1_C4 number(20,5) , 	
    INCR_EA1_C5 number(20,5) , 	
    INCR_EA1_TOTAL_UNITS number(20,5) , 
	INCR_EA1_REMARKS VARCHAR2(500 BYTE),  
	INCR_EA1_SRC_ID VARCHAR2(50 BYTE), 
	INCR_EA1_UPDATE_DT DATE, 
	DECR_EA1_C1 number(20,5) , 	
	DECR_EA1_C2 number(20,5) , 	
	DECR_EA1_C3 number(20,5) , 	
	DECR_EA1_C4 number(20,5) , 	
	DECR_EA1_C5 number(20,5) , 	
	DECR_EA1_TOTAL_UNITS number(20,5) , 
	DECR_EA1_REMARKS VARCHAR2(500 BYTE),  
	DECR_EA1_SRC_ID VARCHAR2(50 BYTE), 
	DECR_EA1_UPDATE_DT DATE, 
	INCR_HT_C1 number(20,5) , 	
	INCR_HT_C2 number(20,5) , 	
	INCR_HT_C3 number(20,5) , 	
	INCR_HT_C4 number(20,5) , 	
	INCR_HT_C5 number(20,5) , 	
	INCR_HT_TOTAL_UNITS number(20,5) , 
	INCR_HT_REMARKS VARCHAR2(500 BYTE),  
	INCR_HT_SRC_ID VARCHAR2(50 BYTE), 
	INCR_HT_UPDATE_DT DATE, 
	CURR_C1 number(20,5) , 	
	CURR_C2 number(20,5) , 	
	CURR_C3 number(20,5) , 	
	CURR_C4 number(20,5) , 	
	CURR_C5 number(20,5) , 	
	CURR_TOTAL_UNITS number(20,5) , 
	CURR_REMARKS VARCHAR2(500 BYTE),  
	CURR_UPDATE_DT DATE, 
	REMARKS VARCHAR2(500 BYTE),  
 	CREATED_BY VARCHAR2(100 BYTE) , 
	CREATED_DT DATE , 
	MODIFIED_BY VARCHAR2(100 BYTE), 
	MODIFIED_DT DATE, 
	ENABLED CHAR(1 BYTE),
	FUEL_TYPE_CODE VARCHAR2(50 BYTE)
);


/
--------------------------------------------------------
--  DDL for Type UD_EXCESS_UNIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "OPENACCESS"."UD_EXCESS_UNIT" AS OBJECT 
(
	C1 number(15,5) , 	
	C2 number(15,5) , 	
	C3 number(15,5) , 	
	C4 number(15,5) , 	
	C5 number(15,5) , 	
	TOTAL_UNITS number(15,5) , 
    SRC_ID  VARCHAR2(50 BYTE),
	REMARKS VARCHAR2(500 BYTE),  
	UPDATE_DT DATE
);


/
--------------------------------------------------------
--  DDL for Sequence AUTH_USER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."AUTH_USER_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence AUTH_USER_TYPE_MAP_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."AUTH_USER_TYPE_MAP_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 88363 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence DELETE_TXN_LOG_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."DELETE_TXN_LOG_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 65022 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence EMPLOYEE_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."EMPLOYEE_ID_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence FINANCIAL_UNUTILIZED_BANKING_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."FINANCIAL_UNUTILIZED_BANKING_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 999341 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_AGREEMENT_LINE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_AGREEMENT_LINE_SEQ"  MINVALUE 10000 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 6036642 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_AGREEMENT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_AGREEMENT_SEQ"  MINVALUE 10000 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 574040 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ENERGY_ADJUSTED_CHARGE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ENERGY_ADJUSTED_CHARGE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 5971183 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ENERGY_ADJUTMENT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ENERGY_ADJUTMENT_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 2364064 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ENERGY_CHARGES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ENERGY_CHARGES_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 18689314 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ENERGY_LEDGER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ENERGY_LEDGER_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 6828395 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ENERGY_SALE_ORDER_LINE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ENERGY_SALE_ORDER_LINE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 2166320 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ENERGY_SALE_ORDER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ENERGY_SALE_ORDER_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 337159 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence F_ES_PAYMENTS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."F_ES_PAYMENTS_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 140 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence IMP_MR_HEADER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."IMP_MR_HEADER_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 54712 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence IMP_MR_LINES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."IMP_MR_LINES_SEQ"  MINVALUE 100 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 134630 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence INT_ADJUSTED_UNIT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."INT_ADJUSTED_UNIT_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 657716 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence MYINCSEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."MYINCSEQ"  MINVALUE 1 MAXVALUE 10000 INCREMENT BY 1 START WITH 5301 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_COMPANY_EMPLOYEE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_COMPANY_EMPLOYEE_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_COMPANY_LOCATION_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_COMPANY_LOCATION_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_COMPANY_METER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_COMPANY_METER_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 88912 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_COMPANY_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_COMPANY_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 436785 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_COMPANY_SERV_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_COMPANY_SERV_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 88892 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_COMPANY_SHAREHOLDERS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_COMPANY_SHAREHOLDERS_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_FEEDER_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_FEEDER_ID_SEQ"  MINVALUE 10000 MAXVALUE 99999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_FEEDER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_FEEDER_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_GENERATOR_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_GENERATOR_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 51798 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_GENERATOR_UNIT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_GENERATOR_UNIT_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_LOV_DETAIL_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_LOV_DETAIL_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_LOV_HEADER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_LOV_HEADER_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_ORG_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_ORG_ID_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_ORG_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_ORG_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_POWERPLANT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_POWERPLANT_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 58803 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_SECTION_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_SECTION_ID_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_SERVICE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_SERVICE_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10040 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_SIGNUP_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_SIGNUP_SEQ"  MINVALUE 10000 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 106236 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_SUBSTATION_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_SUBSTATION_ID_SEQ"  MINVALUE 10000 MAXVALUE 99999999 INCREMENT BY 1 START WITH 10040 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_SUBSTATION_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_SUBSTATION_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_TARIFF_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_TARIFF_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_TRADE_RELATIONSHIP_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_TRADE_RELATIONSHIP_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 474400 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence M_USER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."M_USER_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence PROGRESS_REPORT_RR_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."PROGRESS_REPORT_RR_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 441181 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence RMAN_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."RMAN_SEQ"  MINVALUE 1 MAXVALUE 18446744073709551615 INCREMENT BY 1 START WITH 7729 CACHE 100 ORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence R_GEN_SUMMARY_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."R_GEN_SUMMARY_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 1021 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SECTION_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."SECTION_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 641 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence TARIFF_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."TARIFF_ID_SEQ"  MINVALUE 10001 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 10061 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ACTIVITY_LOG_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ACTIVITY_LOG_SEQ"  MINVALUE 0 MAXVALUE 9999999999999 INCREMENT BY 1 START WITH 60526597 NOCACHE  ORDER  CYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_AGREEMENT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_AGREEMENT_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10200 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_AMENDMENT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_AMENDMENT_SEQ"  MINVALUE 10000 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 10000 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_BANKING_BALANCE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_BANKING_BALANCE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 283541 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_CMC_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_CMC_SEQ"  MINVALUE 100 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 160 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_CNC_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_CNC_SEQ"  MINVALUE 100 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 200 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_CONSENT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_CONSENT_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10400 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_CS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_CS_SEQ"  MINVALUE 100 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 240 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ENERGY_SALE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ENERGY_SALE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 304882 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EPA_LINE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EPA_LINE_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 23227 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EPA_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EPA_SEQ"  MINVALUE 100 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 16841 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ES_CHARGE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ES_CHARGE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 18135520 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ES_INTENT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ES_INTENT_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10820 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ES_MULTIADD_HEADER_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ES_MULTIADD_HEADER_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 102491 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ES_MULTIADD_LINE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ES_MULTIADD_LINE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 26060 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_ES_USAGE_SUMMARY_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_ES_USAGE_SUMMARY_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 1980271 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EWA_LINE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EWA_LINE_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 470048 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EWA_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EWA_SEQ"  MINVALUE 0 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 52512 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EXS_BANKING_BALANCE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EXS_BANKING_BALANCE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 25441370 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EXS_LAPSED_BALANCE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EXS_LAPSED_BALANCE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 50449478 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_EXS_SURPLUS_STB_BALANCE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 50449079 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_GEN_OTHER_CHARGES_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_GEN_OTHER_CHARGES_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 41 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_GEN_STMT_CHARGE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_GEN_STMT_CHARGE_SEQ"  MINVALUE 0 MAXVALUE 100000000000 INCREMENT BY 1 START WITH 4843715 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_GEN_STMT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_GEN_STMT_SEQ"  MINVALUE 0 MAXVALUE 1000000000 INCREMENT BY 1 START WITH 733383 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_GEN_STMT_SLOT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_GEN_STMT_SLOT_SEQ"  MINVALUE 0 MAXVALUE 1000000000000 INCREMENT BY 1 START WITH 3662221 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_GRID_CONN_APPLN_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_GRID_CONN_APPLN_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10020 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_INPRINCIPLE_APPLN_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_INPRINCIPLE_APPLN_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10460 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_METER_READING_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_METER_READING_SEQ"  MINVALUE 1 MAXVALUE 1000000000 INCREMENT BY 1 START WITH 675799 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_METER_READING_SLOT_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_METER_READING_SLOT_SEQ"  MINVALUE 0 MAXVALUE 100000000000 INCREMENT BY 1 START WITH 3352102 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_NEW_SERVICE_EXCESS_BANKING_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_NEW_SERVICE_EXCESS_BANKING_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 19511 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_NOC_GENERATOR_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_NOC_GENERATOR_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10320 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_NOC_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_NOC_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 11840 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_OAA_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_OAA_SEQ"  MINVALUE 10000 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 506159 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_PPA_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_PPA_SEQ"  MINVALUE 100 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10260 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_PROCESS_GS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_PROCESS_GS_SEQ"  MINVALUE 0 MAXVALUE 1000000 INCREMENT BY 1 START WITH 50380 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_PROCESS_LOG_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_PROCESS_LOG_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 361 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_SAMPLE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_SAMPLE_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 10000 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_STANDING_CLEARENCE_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_STANDING_CLEARENCE_SEQ"  MINVALUE 10000 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 10160 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence T_SUBSTATION_LOSS_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."T_SUBSTATION_LOSS_SEQ"  MINVALUE 1 MAXVALUE 99999999999 INCREMENT BY 1 START WITH 46771 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence USER_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "OPENACCESS"."USER_ID_SEQ"  MINVALUE 10001 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 50904 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Table AGRM_EXP_L14_11MAY2021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AGRM_EXP_L14_11MAY2021" 
   (	"WEG_GEN_EDC" VARCHAR2(100 BYTE), 
	"WEG_GEN_SCNO" VARCHAR2(50 BYTE), 
	"GENERATOR_NAME" VARCHAR2(100 BYTE), 
	"NO_OF_UNITS" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_REC" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_NAME" VARCHAR2(50 BYTE), 
	"VOLTAGE_NAME" VARCHAR2(50 BYTE), 
	"RATE" VARCHAR2(50 BYTE), 
	"CT_RATIO" VARCHAR2(50 BYTE), 
	"PT_RATIO" VARCHAR2(50 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"METER_NUMBER" VARCHAR2(50 BYTE), 
	"METER_MAKE" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(100 BYTE), 
	"TYPE_OF_SS" VARCHAR2(50 BYTE), 
	"APRIL_2020_TO_MARCH_2021_GEN_KWH" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"SL_NO" VARCHAR2(10 BYTE), 
	"DOC" DATE, 
	"DOC_MONTH_YEAR" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ALLOTMENT_09092020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ALLOTMENT_09092020" 
   (	"CNAME" VARCHAR2(100 BYTE), 
	"CNT" NUMBER, 
	"CAP" NUMBER, 
	"EDC" VARCHAR2(50 BYTE), 
	"WEG" VARCHAR2(100 BYTE), 
	"CC" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AMRLIST_25022020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AMRLIST_25022020" 
   (	"METERNO" VARCHAR2(26 BYTE), 
	"SYSTEMRTC" VARCHAR2(10 BYTE), 
	"METERRTC" VARCHAR2(10 BYTE), 
	"CIRCLENAME" VARCHAR2(16 BYTE), 
	"SECTIONNAME" VARCHAR2(18 BYTE), 
	"SUBSTATIONNAME" VARCHAR2(30 BYTE), 
	"SERVICENO" VARCHAR2(26 BYTE), 
	"SERVICECODE" VARCHAR2(14 BYTE), 
	"METERMAKENAME" VARCHAR2(6 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AMR_260820
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AMR_260820" 
   (	"SECTIONNAME" VARCHAR2(26 BYTE), 
	"SECTIONTYPE" VARCHAR2(8 BYTE), 
	"METERNO" VARCHAR2(9 BYTE), 
	"MF" NUMBER(7,0), 
	"SERVICENO" VARCHAR2(25 BYTE), 
	"CIRCLENAME" VARCHAR2(16 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AMR_METER_LIST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AMR_METER_LIST" 
   (	"CIRCLECODE" VARCHAR2(3 BYTE), 
	"SERVICENO_OLD" VARCHAR2(20 BYTE), 
	"SERVICENO_NEW" VARCHAR2(12 BYTE), 
	"METERNO" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_FEATURE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_FEATURE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FUNCTIONALITY_CODE" VARCHAR2(50 BYTE), 
	"FEATURE_CODE" VARCHAR2(50 BYTE), 
	"DESCRIPTION" VARCHAR2(50 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"ORG_TYPE_CODE" VARCHAR2(50 BYTE), 
	"AUTH_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_FEATURE_01092020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_FEATURE_01092020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FUNCTIONALITY_CODE" VARCHAR2(50 BYTE), 
	"FEATURE_CODE" VARCHAR2(50 BYTE), 
	"DESCRIPTION" VARCHAR2(50 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"ORG_TYPE_CODE" VARCHAR2(50 BYTE), 
	"AUTH_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_FEATURE_211020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_FEATURE_211020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FUNCTIONALITY_CODE" VARCHAR2(50 BYTE), 
	"FEATURE_CODE" VARCHAR2(50 BYTE), 
	"DESCRIPTION" VARCHAR2(50 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"ORG_TYPE_CODE" VARCHAR2(50 BYTE), 
	"AUTH_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_FEATURE_221020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_FEATURE_221020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FUNCTIONALITY_CODE" VARCHAR2(50 BYTE), 
	"FEATURE_CODE" VARCHAR2(50 BYTE), 
	"DESCRIPTION" VARCHAR2(50 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"ORG_TYPE_CODE" VARCHAR2(50 BYTE), 
	"AUTH_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_TOKEN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_TOKEN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"AUTH_USER_ID" VARCHAR2(50 BYTE), 
	"USER_TOKEN" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FIRST_NAME" VARCHAR2(100 BYTE), 
	"LAST_NAME" VARCHAR2(100 BYTE), 
	"USER_NAME" VARCHAR2(100 BYTE), 
	"PASSWORD" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_SUPER_USER" VARCHAR2(1 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"SYSTEM_REF_KEY" VARCHAR2(50 BYTE), 
	"EDC_CODE" VARCHAR2(50 BYTE), 
	"COMPANY_ID" VARCHAR2(50 BYTE), 
	"CONTACT_NUMBER" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"ORG_ID" VARCHAR2(100 BYTE), 
	"COMPANY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"TOKEN_VALIDITY_DT" TIMESTAMP (6), 
	"LAST_LOGGED_DT" TIMESTAMP (6), 
	"DURATION" VARCHAR2(100 BYTE), 
	"TOKEN" VARCHAR2(100 BYTE), 
	"MASTER_CONFIRMED" CHAR(1 BYTE), 
	"CONFIRMED_DATE" TIMESTAMP (6), 
	"LOGIN_STOP_MESSAGE" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_019104041981
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_019104041981" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FIRST_NAME" VARCHAR2(100 BYTE), 
	"LAST_NAME" VARCHAR2(100 BYTE), 
	"USER_NAME" VARCHAR2(100 BYTE), 
	"PASSWORD" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_SUPER_USER" VARCHAR2(1 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"SYSTEM_REF_KEY" VARCHAR2(50 BYTE), 
	"EDC_CODE" VARCHAR2(50 BYTE), 
	"COMPANY_ID" VARCHAR2(50 BYTE), 
	"CONTACT_NUMBER" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"ORG_ID" VARCHAR2(100 BYTE), 
	"COMPANY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"TOKEN_VALIDITY_DT" TIMESTAMP (6), 
	"LAST_LOGGED_DT" TIMESTAMP (6), 
	"DURATION" VARCHAR2(100 BYTE), 
	"TOKEN" VARCHAR2(100 BYTE), 
	"MASTER_CONFIRMED" CHAR(1 BYTE), 
	"CONFIRMED_DATE" TIMESTAMP (6), 
	"LOGIN_STOP_MESSAGE" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_10062021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_10062021" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FIRST_NAME" VARCHAR2(100 BYTE), 
	"LAST_NAME" VARCHAR2(100 BYTE), 
	"USER_NAME" VARCHAR2(100 BYTE), 
	"PASSWORD" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_SUPER_USER" VARCHAR2(1 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"SYSTEM_REF_KEY" VARCHAR2(50 BYTE), 
	"EDC_CODE" VARCHAR2(50 BYTE), 
	"COMPANY_ID" VARCHAR2(50 BYTE), 
	"CONTACT_NUMBER" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"ORG_ID" VARCHAR2(100 BYTE), 
	"COMPANY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"TOKEN_VALIDITY_DT" TIMESTAMP (6), 
	"LAST_LOGGED_DT" TIMESTAMP (6), 
	"DURATION" VARCHAR2(100 BYTE), 
	"TOKEN" VARCHAR2(100 BYTE), 
	"MASTER_CONFIRMED" CHAR(1 BYTE), 
	"CONFIRMED_DATE" TIMESTAMP (6), 
	"LOGIN_STOP_MESSAGE" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_ARKAY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_ARKAY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FIRST_NAME" VARCHAR2(100 BYTE), 
	"LAST_NAME" VARCHAR2(100 BYTE), 
	"USER_NAME" VARCHAR2(100 BYTE), 
	"PASSWORD" VARCHAR2(50 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_SUPER_USER" VARCHAR2(1 BYTE), 
	"SYSTEM_KEY_CODE" VARCHAR2(50 BYTE), 
	"SYSTEM_REF_KEY" VARCHAR2(50 BYTE), 
	"EDC_CODE" VARCHAR2(50 BYTE), 
	"COMPANY_ID" VARCHAR2(50 BYTE), 
	"CONTACT_NUMBER" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"ORG_ID" VARCHAR2(100 BYTE), 
	"COMPANY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"TOKEN_VALIDITY_DT" TIMESTAMP (6), 
	"LAST_LOGGED_DT" TIMESTAMP (6), 
	"DURATION" VARCHAR2(100 BYTE), 
	"TOKEN" VARCHAR2(100 BYTE), 
	"MASTER_CONFIRMED" CHAR(1 BYTE), 
	"CONFIRMED_DATE" TIMESTAMP (6), 
	"LOGIN_STOP_MESSAGE" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_FEATURE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_FEATURE" 
   (	"AUTH_ID" VARCHAR2(50 BYTE), 
	"AUTH_FEATURE_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_TYPE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_TYPE" 
   (	"ID" VARCHAR2(100 BYTE), 
	"USER_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IS_ENABLED" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" TIMESTAMP (6) WITH LOCAL TIME ZONE, 
	"MODIFIED_DT" TIMESTAMP (6) WITH LOCAL TIME ZONE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_TYPE_ACCESS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_TYPE_ACCESS" 
   (	"TRANSACTION_TYPE_CODE" VARCHAR2(100 BYTE), 
	"USER_TYPE_CODE" VARCHAR2(100 BYTE), 
	"FUEL_GROUP_NAME" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_TYPE_MAP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_TYPE_MAP" 
   (	"AUTH_USER_TYPE_CODE" VARCHAR2(100 BYTE), 
	"AUTH_FEATURE_ID" VARCHAR2(100 BYTE), 
	"ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_TYPE_MAP_01092020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_TYPE_MAP_01092020" 
   (	"AUTH_USER_TYPE_CODE" VARCHAR2(100 BYTE), 
	"AUTH_FEATURE_ID" VARCHAR2(100 BYTE), 
	"ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table AUTH_USER_TYPE_MAP_211020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."AUTH_USER_TYPE_MAP_211020" 
   (	"AUTH_USER_TYPE_CODE" VARCHAR2(100 BYTE), 
	"AUTH_FEATURE_ID" VARCHAR2(100 BYTE), 
	"ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BACKUP_F_ENERGY_ADJUSTMET_082020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BACKUP_F_ENERGY_ADJUSTMET_082020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BACKUP_T_EXS_BANKING_BALANCE_082020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_082020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BANKING_CHK_011020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BANKING_CHK_011020" 
   (	"BUYERSERVICENO" VARCHAR2(15 BYTE), 
	"SELLERSERVICENO" VARCHAR2(15 BYTE), 
	"SELLERTYPE" VARCHAR2(20 BYTE), 
	"SELLERNAME" VARCHAR2(100 BYTE), 
	"READINGMNTH" VARCHAR2(2 BYTE), 
	"READINGYR" VARCHAR2(4 BYTE), 
	"ADJUSTEDC1" VARCHAR2(15 BYTE), 
	"ADJUSTEDC2" VARCHAR2(15 BYTE), 
	"ADJUSTEDC3" VARCHAR2(15 BYTE), 
	"ADJUSTEDC4" VARCHAR2(15 BYTE), 
	"ADJUSTEDC5" VARCHAR2(15 BYTE), 
	"ADJUSTEDC24" VARCHAR2(15 BYTE), 
	"SURPLUS1" VARCHAR2(20 BYTE), 
	"SURPLUS2" VARCHAR2(20 BYTE), 
	"SURPLUS3" VARCHAR2(20 BYTE), 
	"SURPLUS4" VARCHAR2(20 BYTE), 
	"SURPLUS5" VARCHAR2(20 BYTE), 
	"SURPLUS24" VARCHAR2(20 BYTE), 
	"READINGDT" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BANKING_DUMMY_2802020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BANKING_DUMMY_2802020" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BANKING_DUMMY_2802020_OLD
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BANKING_DUMMY_2802020_OLD" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_08THMAY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_08THMAY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_BALANCE_02SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_BALANCE_02SEP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_BALANCE_APR01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_BALANCE_APR01" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_BALANCE_AUG_01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_BALANCE_AUG_01" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_CALL_ADJ_ES_APR01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_CALL_ADJ_ES_APR01" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_CLOSING
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_CLOSING" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_CLOSING_1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_CLOSING_1" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_SAME_C1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_SAME_C1" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_UPDATE_BB_APR01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_UPDATE_BB_APR01" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BANKING_UPDATE_SAME_APR01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BANKING_UPDATE_SAME_APR01" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BB_04062019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BB_04062019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BB_SS_LOSS_04062019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BB_SS_LOSS_04062019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BB_SS_LOSS_04062019_1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BB_SS_LOSS_04062019_1" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_BETA_WIND_FARM_POWERPLANT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_BETA_WIND_FARM_POWERPLANT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"IS_PRIMARY" CHAR(1 BYTE), 
	"VERSION" NUMBER(2,0), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"PLANT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"M_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"T_GRID_CONN_APPLN_ID" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(25 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"INTERFACE_VOLTAGE_PHASE" VARCHAR2(25 BYTE), 
	"INTERFACE_VOLTAGE_FREQUENCY" VARCHAR2(25 BYTE), 
	"COMMISSION_DATE" DATE, 
	"PURPOSE" VARCHAR2(500 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"STATUS" VARCHAR2(25 BYTE), 
	"LINE1" VARCHAR2(500 BYTE), 
	"CITY" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"PINCODE" VARCHAR2(50 BYTE), 
	"VILLAGE" VARCHAR2(200 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"PLS_SF_NO" VARCHAR2(50 BYTE), 
	"PL_VILLAGE" VARCHAR2(200 BYTE), 
	"PL_TOWN" VARCHAR2(50 BYTE), 
	"PL_TALUK_CODE" VARCHAR2(50 BYTE), 
	"PL_DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"WIND_ZONE_AREA_CODE" VARCHAR2(50 BYTE), 
	"APPLICATION_DT" DATE, 
	"APPROVAL_DT" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_ENERGY_SALE_APR01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_ENERGY_SALE_APR01" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"NET_ALLOCATION" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(100 BYTE), 
	"TOTAL_BANK_UNITS_USED" VARCHAR2(100 BYTE), 
	"BC1" VARCHAR2(100 BYTE), 
	"BC2" VARCHAR2(100 BYTE), 
	"BC3" VARCHAR2(100 BYTE), 
	"BC4" VARCHAR2(100 BYTE), 
	"BC5" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"IS_STB" CHAR(1 BYTE), 
	"AVAIL_C1" VARCHAR2(100 BYTE), 
	"AVAIL_C2" VARCHAR2(100 BYTE), 
	"AVAIL_C3" VARCHAR2(100 BYTE), 
	"AVAIL_C4" VARCHAR2(100 BYTE), 
	"AVAIL_C5" VARCHAR2(100 BYTE), 
	"AVAIL_GC1" VARCHAR2(100 BYTE), 
	"AVAIL_GC2" VARCHAR2(100 BYTE), 
	"AVAIL_GC3" VARCHAR2(100 BYTE), 
	"AVAIL_GC4" VARCHAR2(100 BYTE), 
	"AVAIL_GC5" VARCHAR2(100 BYTE), 
	"AVAIL_BC1" VARCHAR2(100 BYTE), 
	"AVAIL_BC2" VARCHAR2(100 BYTE), 
	"AVAIL_BC3" VARCHAR2(100 BYTE), 
	"AVAIL_BC4" VARCHAR2(100 BYTE), 
	"AVAIL_BC5" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"NET_CHARGES_ALLOCATED" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE), 
	"PROCESS_REMARKS" VARCHAR2(500 BYTE), 
	"SAVED_ONCE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_F_ENERGY_ADJUSTMET02SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET02SEP" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_F_ENERGY_ADJUSTMET_09SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET_09SEP" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_GEN_STMT_21AUG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_GEN_STMT_21AUG" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"IS_METER_CHANGE" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_IMPORT_METER_READING
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_IMPORT_METER_READING" 
   (	"REMARKS" VARCHAR2(500 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"METER_NO" VARCHAR2(100 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"INIT_READING_DT_STR" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT_STR" VARCHAR2(50 BYTE), 
	"READING_DT_STR" VARCHAR2(50 BYTE), 
	"IMP_SLOT1" VARCHAR2(10 BYTE), 
	"IMP_SLOT2" VARCHAR2(10 BYTE), 
	"IMP_SLOT3" VARCHAR2(10 BYTE), 
	"IMP_SLOT4" VARCHAR2(10 BYTE), 
	"IMP_SLOT5" VARCHAR2(10 BYTE), 
	"EXP_SLOT1" VARCHAR2(10 BYTE), 
	"EXP_SLOT2" VARCHAR2(10 BYTE), 
	"EXP_SLOT3" VARCHAR2(10 BYTE), 
	"EXP_SLOT4" VARCHAR2(10 BYTE), 
	"EXP_SLOT5" VARCHAR2(10 BYTE), 
	"IMP_RKVAH" VARCHAR2(10 BYTE), 
	"EXP_RKVAH" VARCHAR2(10 BYTE), 
	"IMP_KVAH" VARCHAR2(10 BYTE), 
	"EXP_KVAH" VARCHAR2(10 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"IMP_MR_HEADER_ID" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE, 
	"INIT_READING_DT" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"REF_NO" VARCHAR2(100 BYTE), 
	"READING_DT" DATE, 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"CLEAN_REC" CHAR(1 BYTE), 
	"IMPORTED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_IMPORT_METER_READING_02AUG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" 
   (	"REMARKS" VARCHAR2(500 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"METER_NO" VARCHAR2(100 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"INIT_READING_DT_STR" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT_STR" VARCHAR2(50 BYTE), 
	"READING_DT_STR" VARCHAR2(50 BYTE), 
	"IMP_SLOT1" VARCHAR2(10 BYTE), 
	"IMP_SLOT2" VARCHAR2(10 BYTE), 
	"IMP_SLOT3" VARCHAR2(10 BYTE), 
	"IMP_SLOT4" VARCHAR2(10 BYTE), 
	"IMP_SLOT5" VARCHAR2(10 BYTE), 
	"EXP_SLOT1" VARCHAR2(10 BYTE), 
	"EXP_SLOT2" VARCHAR2(10 BYTE), 
	"EXP_SLOT3" VARCHAR2(10 BYTE), 
	"EXP_SLOT4" VARCHAR2(10 BYTE), 
	"EXP_SLOT5" VARCHAR2(10 BYTE), 
	"IMP_RKVAH" VARCHAR2(10 BYTE), 
	"EXP_RKVAH" VARCHAR2(10 BYTE), 
	"IMP_KVAH" VARCHAR2(10 BYTE), 
	"EXP_KVAH" VARCHAR2(10 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"IMP_MR_HEADER_ID" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE, 
	"INIT_READING_DT" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"REF_NO" VARCHAR2(100 BYTE), 
	"READING_DT" DATE, 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"CLEAN_REC" CHAR(1 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"IMPORT_ASIS" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_IMP_SUBSTATION_LOSS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_IMP_SUBSTATION_LOSS" 
   (	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ID" VARCHAR2(50 BYTE), 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"IS_IMPORTED" CHAR(1 BYTE), 
	"RESULT_DESC" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_IMP_SUBSTATION_LOSS_06AUG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_IMP_SUBSTATION_LOSS_06AUG" 
   (	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ID" VARCHAR2(50 BYTE), 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"IS_IMPORTED" CHAR(1 BYTE), 
	"RESULT_DESC" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_INT_ADJUSTED_UNIT_09SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_INT_ADJUSTED_UNIT_09SEP" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_INT_ADJ_UNIT_02SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_INT_ADJ_UNIT_02SEP" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_INT_SURPLUS_APR01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" DATE, 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_MISSING_INT_ADJ_UNITS_09SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_MISSING_INT_ADJ_UNITS_09SEP" 
   (	"SERVICE_NO" VARCHAR2(20 BYTE), 
	"READING_MNTH" NUMBER, 
	"READING_YR" NUMBER, 
	"C1_TOT" NUMBER, 
	"C2_TOT" NUMBER, 
	"C3_TOT" NUMBER, 
	"C4_TOT" NUMBER, 
	"C5_TOT" NUMBER, 
	"C24_TOT" NUMBER, 
	"SUPLR_CODE" VARCHAR2(20 BYTE), 
	"SUPLR_TYPE" VARCHAR2(20 BYTE), 
	"SUR1_TOT" NUMBER, 
	"SUR2_TOT" NUMBER, 
	"SUR3_TOT" NUMBER, 
	"SUR4_TOT" NUMBER, 
	"SUR5_TOT" NUMBER, 
	"SUR24_TOT" NUMBER, 
	"READINGDT" VARCHAR2(100 BYTE), 
	"ES_STATUS" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_M_COMPANY_29JUL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_M_COMPANY_29JUL" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"COMPANY_TYPE_CODE" VARCHAR2(50 BYTE), 
	"REGISTRATION_NO" VARCHAR2(50 BYTE), 
	"REGISTRATION_DATE" DATE, 
	"COB_DATE" DATE, 
	"INCORP_PLACE" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" VARCHAR2(25 BYTE), 
	"CAPTIVE_PURPOSE" VARCHAR2(100 BYTE), 
	"PAN" VARCHAR2(50 BYTE), 
	"TAN" VARCHAR2(50 BYTE), 
	"CST" VARCHAR2(50 BYTE), 
	"GST" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"TYPE" VARCHAR2(100 BYTE), 
	"IS_INTERNAL" CHAR(1 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IS_BUYER" CHAR(1 BYTE), 
	"IS_SELLER" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_M_COMPANY_METER_01AUG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_M_COMPANY_METER_01AUG" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"ACCURACY_CLASS_CODE" VARCHAR2(50 BYTE), 
	"IS_ABTMETER" CHAR(1 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"MODEM_NUMBER" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"METER_CT1" VARCHAR2(50 BYTE), 
	"METER_CT2" VARCHAR2(50 BYTE), 
	"METER_CT3" VARCHAR2(50 BYTE), 
	"METER_PT1" VARCHAR2(50 BYTE), 
	"METER_PT2" VARCHAR2(50 BYTE), 
	"METER_PT3" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_M_COMPANY_SERVICE_29JUL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_M_COMPANY_SERVICE_29JUL" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"TYPE_OF_SHARE" VARCHAR2(50 BYTE), 
	"INSTALLED_BY" VARCHAR2(50 BYTE), 
	"M_SECTION_ID" VARCHAR2(100 BYTE), 
	"M_SECTION_NAME" VARCHAR2(2 BYTE), 
	"M_SECTION_CODE" VARCHAR2(2 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_ACTIVITY_LOG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_ACTIVITY_LOG" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_ACTIVITY_LOG_02AUG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_ACTIVITY_LOG_02AUG" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_01032019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_01032019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_020319
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_020319" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_02FEB2020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_02FEB2020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_030719
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_030719" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_07SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_07SEP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_09SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_09SEP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_150219
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_150219" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BALANCE_B4_DOWNLOAD_0207
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BALANCE_B4_DOWNLOAD_0207" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BANKING_BANKING_03_06_19
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BANKING_BANKING_03_06_19" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BB_03_06_19_AF_APR_CL_UP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BB_03_06_19_AF_APR_CL_UP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BB_05032019_02
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BB_05032019_02" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BB_05032019_before_cleaning
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BB_05032019_before_cleaning" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_BB_06032019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_BB_06032019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_ENERGY_SALE_09SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_ENERGY_SALE_09SEP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"NET_ALLOCATION" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(100 BYTE), 
	"TOTAL_BANK_UNITS_USED" VARCHAR2(100 BYTE), 
	"BC1" VARCHAR2(100 BYTE), 
	"BC2" VARCHAR2(100 BYTE), 
	"BC3" VARCHAR2(100 BYTE), 
	"BC4" VARCHAR2(100 BYTE), 
	"BC5" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"IS_STB" CHAR(1 BYTE), 
	"AVAIL_C1" VARCHAR2(100 BYTE), 
	"AVAIL_C2" VARCHAR2(100 BYTE), 
	"AVAIL_C3" VARCHAR2(100 BYTE), 
	"AVAIL_C4" VARCHAR2(100 BYTE), 
	"AVAIL_C5" VARCHAR2(100 BYTE), 
	"AVAIL_GC1" VARCHAR2(100 BYTE), 
	"AVAIL_GC2" VARCHAR2(100 BYTE), 
	"AVAIL_GC3" VARCHAR2(100 BYTE), 
	"AVAIL_GC4" VARCHAR2(100 BYTE), 
	"AVAIL_GC5" VARCHAR2(100 BYTE), 
	"AVAIL_BC1" VARCHAR2(100 BYTE), 
	"AVAIL_BC2" VARCHAR2(100 BYTE), 
	"AVAIL_BC3" VARCHAR2(100 BYTE), 
	"AVAIL_BC4" VARCHAR2(100 BYTE), 
	"AVAIL_BC5" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"NET_CHARGES_ALLOCATED" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE), 
	"PROCESS_REMARKS" VARCHAR2(500 BYTE), 
	"SAVED_ONCE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_GEN_STMT_240619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_GEN_STMT_240619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"IS_METER_CHANGE" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_GEN_STMT_SLOT_09SEP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_GEN_STMT_SLOT_09SEP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"BANKED_BALANCE" VARCHAR2(50 BYTE), 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_SUBSTATION_LOSS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS" 
   (	"ID" VARCHAR2(100 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_T_SUBSTATION_LOSS_06AUG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS_06AUG" 
   (	"ID" VARCHAR2(100 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UPDATE_LIST_BB_02FEB2020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UPDATE_LIST_BB_02FEB2020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UPD_CURVALUES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UPD_CURVALUES" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UPD_CURVALUES_022019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UPD_CURVALUES_022019" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UPD_CURVALUES_310NUM
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UPD_CURVALUES_310NUM" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UPD_CURVALUES_APR_01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UPD_CURVALUES_APR_01" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UPD_CURVALUE_ADD_020419
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UPD_CURVALUE_ADD_020419" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table BK_UV_TBL_HISTORY_SLOT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."BK_UV_TBL_HISTORY_SLOT" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table CAPACITYUPDATE_200820
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."CAPACITYUPDATE_200820" 
   (	"ID" VARCHAR2(50 BYTE), 
	"ORG_ID" VARCHAR2(50 BYTE), 
	"ORG_NAME" VARCHAR2(50 BYTE), 
	"SPG_HT_SERVICE_NO" VARCHAR2(50 BYTE), 
	"GENERATOR_NAME" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"NO_OF_UNITS" VARCHAR2(25 BYTE), 
	"CAPACITY" VARCHAR2(25 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FUEL_TYPE_NAME" VARCHAR2(200 BYTE), 
	"VOLTAGE_NAME" VARCHAR2(200 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"RATE" VARCHAR2(20 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER_MAKE" VARCHAR2(200 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"TYPE_OF_SS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table CBS_110920
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."CBS_110920" 
   (	"NAMEOFTHEGENERATOR" VARCHAR2(128 BYTE), 
	"CAPACITYINKW" VARCHAR2(4 BYTE), 
	"HTSERVICENO" VARCHAR2(12 BYTE), 
	"DATEOFCOMMISSIONING" VARCHAR2(10 BYTE), 
	"DATEOFAGREEMENT" VARCHAR2(10 BYTE), 
	"AGREEMENTPERIOD" VARCHAR2(10 BYTE), 
	"DATEOFEXPIRYOFPPA_EWA" VARCHAR2(10 BYTE), 
	"NON_RECREC" VARCHAR2(7 BYTE), 
	"CAPSTBTHIRDPARTY" VARCHAR2(13 BYTE), 
	"WIND_SOLAR" VARCHAR2(4 BYTE), 
	"TARIFFRATE" VARCHAR2(4 BYTE), 
	"REMARKSIFANY" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table CONS_ENERGY_ADJUSTED_CHARGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."CONS_ENERGY_ADJUSTED_CHARGE" 
   (	"ID" VARCHAR2(100 BYTE), 
	"SELLER_SERVICE_NO" VARCHAR2(100 BYTE), 
	"READING_MNTH" VARCHAR2(100 BYTE), 
	"READING_YR" VARCHAR2(100 BYTE), 
	"METER_READING_CHARGES" VARCHAR2(100 BYTE), 
	"O_M_CHARGES" VARCHAR2(100 BYTE), 
	"TRANSMISSION_CHARGES" VARCHAR2(100 BYTE), 
	"SYSTEM_OPERATION_CHARGES" VARCHAR2(100 BYTE), 
	"RKVAH_PENALTY" VARCHAR2(100 BYTE), 
	"NEGATIVE_ENERGY_CHARGES" VARCHAR2(100 BYTE), 
	"SCHEDULING_CHARGES" VARCHAR2(100 BYTE), 
	"OTHER_CHARGES" VARCHAR2(100 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table CONS_ENERGY_ADJUSTED_ORDER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."CONS_ENERGY_ADJUSTED_ORDER" 
   (	"ID" VARCHAR2(200 BYTE), 
	"SELLER_SERVICE_NO" VARCHAR2(100 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"ALLOTED_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ALLOTED_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ALLOTED_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ALLOTED_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ALLOTED_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"LD_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"LD_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"LD_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"LD_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"LD_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"HT_BB_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"HT_BB_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"HT_BB_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"HT_BB_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"HT_BB_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C1_WITHLOSS" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2_WITHLOSS" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3_WITHLOSS" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4_WITHLOSS" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5_WITHLOSS" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT 'admin', 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"SELLER_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SELLER_TYPE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DB
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DB" 
   (	"DB_KEY" NUMBER, 
	"DB_ID" NUMBER, 
	"REG_DB_UNIQUE_NAME" VARCHAR2(30 BYTE), 
	"CURR_DBINC_KEY" NUMBER, 
	"STORAGE_PROV" VARCHAR2(1 BYTE) DEFAULT 'N'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DBINC
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DBINC" 
   (	"DBINC_KEY" NUMBER, 
	"DB_KEY" NUMBER, 
	"DB_NAME" VARCHAR2(8 BYTE), 
	"RESET_SCN" NUMBER, 
	"RESET_TIME" DATE, 
	"PARENT_DBINC_KEY" NUMBER, 
	"DBINC_STATUS" VARCHAR2(8 BYTE) DEFAULT 'ORPHAN', 
	"DBINC_TIMEZONE" VARCHAR2(64 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DELETE_TXN_LOG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DELETE_TXN_LOG" 
   (	"ID" VARCHAR2(20 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"READING" VARCHAR2(20 BYTE), 
	"STATEMENT" VARCHAR2(20 BYTE), 
	"ALLOTMENT" VARCHAR2(20 BYTE), 
	"LEDGER" VARCHAR2(20 BYTE), 
	"CREATED_DATE" DATE, 
	"CREATED_BY" VARCHAR2(20 BYTE), 
	"RESULT" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DOC_INFO
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DOC_INFO" 
   (	"ID" VARCHAR2(50 BYTE), 
	"DOC_NAME" VARCHAR2(100 BYTE), 
	"FILTER_CRITERIA" VARCHAR2(50 BYTE), 
	"DOC_PATH" VARCHAR2(100 BYTE), 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"FILE_NAME_TO_USER" VARCHAR2(50 BYTE), 
	"FILE_EXTENSION" VARCHAR2(50 BYTE), 
	"TABLE_ID" VARCHAR2(50 BYTE), 
	"BATCH_KEY" VARCHAR2(50 BYTE), 
	"IS_ENABLED" VARCHAR2(20 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_BY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DOWNLOAD_03072020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DOWNLOAD_03072020" 
   (	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"IMP_BATCH_ID" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE, 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"INIT_READING_DT" DATE, 
	"FINAL_READING_DT" DATE, 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"RKVAH_DIFF" VARCHAR2(100 BYTE), 
	"RKVAH_UNITS" VARCHAR2(100 BYTE), 
	"KVAH_DIFF" VARCHAR2(100 BYTE), 
	"KVAH_UNITS" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"NET_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GS_BATCH_ID" VARCHAR2(100 BYTE), 
	"M_GEN_STMT_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"IMPORTED_ASIS" CHAR(1 BYTE), 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DUMMY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DUMMY" 
   (	"SERVICE_NO" VARCHAR2(200 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"CAPTIVE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DUMMY1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DUMMY1" 
   (	"V_GS_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DUMMY_123
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DUMMY_123" 
   (	"COUN" NUMBER, 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"DAT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DUMMY_18062020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DUMMY_18062020" 
   (	"ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DUMMY_BANKING
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DUMMY_BANKING" 
   (	"M_COMPANY_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table DUMMY_INT_ADJUSTED_UNIT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."DUMMY_INT_ADJUSTED_UNIT" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table D_EXS_BANKING_BALANCE_02NOV2020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."D_EXS_BANKING_BALANCE_02NOV2020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ECN_MASTER_DATA_15082020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ECN_MASTER_DATA_15082020" 
   (	"METER_NUMBER" VARCHAR2(12 BYTE), 
	"CT_RATIO" VARCHAR2(12 BYTE), 
	"PT_RATIO" VARCHAR2(12 BYTE), 
	"MF" VARCHAR2(12 BYTE), 
	"FEEDER_NAME" VARCHAR2(100 BYTE), 
	"WEG_SC_NO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ECN_OWN_CAPTIVE_19092020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ECN_OWN_CAPTIVE_19092020" 
   (	"EDCNAME" VARCHAR2(20 BYTE), 
	"WEGSERVICENO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ECN_WEG_OWN_CAPTIVE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ECN_WEG_OWN_CAPTIVE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GN_SERVICENO" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(150 BYTE), 
	"HT_SERVICENO" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"NAME_1" VARCHAR2(150 BYTE), 
	"FROM_DATE" VARCHAR2(50 BYTE), 
	"TO_DATE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ENERGY_ADJ_REP_18062020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ENERGY_ADJ_REP_18062020" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ENERGY_ADJ_REP_19062020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ENERGY_ADJ_REP_19062020_MY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020_MY" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table ERROR_TABLE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."ERROR_TABLE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SOURCE" VARCHAR2(50 BYTE), 
	"ERROR_DETAIL" VARCHAR2(1000 BYTE), 
	"ATRRIB1" VARCHAR2(500 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CREATED_DATE" DATE DEFAULT sysdate
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table EXCEL2
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."EXCEL2" 
   (	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"READINGDATE" DATE, 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table EXPIREDWEG_200421
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."EXPIREDWEG_200421" 
   (	"EXPIREDSCNO" VARCHAR2(50 BYTE), 
	"OA_CUSTOMERNAME" VARCHAR2(100 BYTE), 
	"FROMDATE" DATE, 
	"TODATE" DATE, 
	"EXACT20YRS" DATE, 
	"VCSID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table EXP_TECHNICAL_DATA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."EXP_TECHNICAL_DATA" 
   (	"REMARKS" VARCHAR2(200 BYTE), 
	"M_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(100 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(1 BYTE), 
	"IS_REC" VARCHAR2(1 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE), 
	"M_COMPANY_ID" VARCHAR2(100 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"M_POWERPLANT_ID" VARCHAR2(100 BYTE), 
	"M_METER_ID_1" VARCHAR2(100 BYTE), 
	"METER1_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER1_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER1_MF" VARCHAR2(100 BYTE), 
	"METER1_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER1_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER1_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER1_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER1_IS_ABT" VARCHAR2(1 BYTE), 
	"METER1_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_2" VARCHAR2(100 BYTE), 
	"METER2_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER2_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER2_MF" VARCHAR2(100 BYTE), 
	"METER2_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER2_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER2_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER2_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER2_IS_ABT" VARCHAR2(1 BYTE), 
	"METER2_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_3" VARCHAR2(100 BYTE), 
	"METER3_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER3_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER3_MF" VARCHAR2(100 BYTE), 
	"METER3_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER3_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER3_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER3_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER3_IS_ABT" VARCHAR2(1 BYTE), 
	"METER3_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_4" VARCHAR2(100 BYTE), 
	"METER4_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER4_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER4_MF" VARCHAR2(100 BYTE), 
	"METER4_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER4_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER4_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER4_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER4_IS_ABT" VARCHAR2(1 BYTE), 
	"METER4_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_5" VARCHAR2(100 BYTE), 
	"METER5_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER5_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER5_MF" VARCHAR2(100 BYTE), 
	"METER5_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER5_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER5_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER5_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER5_IS_ABT" VARCHAR2(1 BYTE), 
	"METER5_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_6" VARCHAR2(100 BYTE), 
	"METER6_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER6_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER6_MF" VARCHAR2(100 BYTE), 
	"METER6_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER6_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER6_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER6_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER6_IS_ABT" VARCHAR2(1 BYTE), 
	"METER6_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_1" VARCHAR2(100 BYTE), 
	"GEN1_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN1_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN1_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN1_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN1_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN1_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN1_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN1_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN1_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_2" VARCHAR2(100 BYTE), 
	"GEN2_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN2_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN2_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN2_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN2_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN2_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN2_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN2_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN2_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_3" VARCHAR2(100 BYTE), 
	"GEN3_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN3_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN3_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN3_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN3_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN3_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN3_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN3_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN3_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_4" VARCHAR2(100 BYTE), 
	"GEN4_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN4_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN4_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN4_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN4_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN4_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN4_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN4_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN4_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_5" VARCHAR2(100 BYTE), 
	"GEN5_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN5_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN5_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN5_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN5_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN5_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN5_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN5_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN5_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_6" VARCHAR2(100 BYTE), 
	"GEN6_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN6_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN6_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN6_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN6_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN6_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN6_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN6_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN6_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table FINANCIAL_UNUTILIZED_BANKING
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."FINANCIAL_UNUTILIZED_BANKING" 
   (	"ID" VARCHAR2(22 BYTE), 
	"SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(100 BYTE), 
	"C2" VARCHAR2(100 BYTE), 
	"C3" VARCHAR2(100 BYTE), 
	"C4" VARCHAR2(100 BYTE), 
	"C5" VARCHAR2(100 BYTE), 
	"ST_MONTH" VARCHAR2(100 BYTE), 
	"ST_YEAR" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"RATE" VARCHAR2(100 BYTE), 
	"SERVICE_NAME" VARCHAR2(100 BYTE), 
	"AMOUNT" VARCHAR2(100 BYTE), 
	"ST_TOTAL" VARCHAR2(100 BYTE), 
	"UNUTILISED_ENERGY" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_DESC" VARCHAR2(100 BYTE), 
	"SNO" VARCHAR2(100 BYTE), 
	"EDC_NO" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 98304 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_AGREEMENT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_AGREEMENT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"AGMT_VERSION" VARCHAR2(50 BYTE), 
	"SELLER_EDC_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_DATE" DATE, 
	"IS_ACTIVE" CHAR(1 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"TOTAL_UNITS" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"SIGNATORY_PARTY1" VARCHAR2(1500 BYTE), 
	"SIGNATORY_PARTY2" VARCHAR2(1500 BYTE), 
	"SIGNATORY_PARTY3" VARCHAR2(1500 BYTE), 
	"HAS_LINES" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FROM_MONTH" VARCHAR2(50 BYTE), 
	"TO_YEAR" VARCHAR2(50 BYTE), 
	"FROM_YEAR" VARCHAR2(50 BYTE), 
	"TO_MONTH" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"MODIFIDED_BY" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"VERSION_CHANGE_REASON_CODE" VARCHAR2(50 BYTE), 
	"BUYER_EDC_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_ID" VARCHAR2(50 BYTE), 
	"SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"FEEDER_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE" VARCHAR2(50 BYTE), 
	"IS_LATEST" CHAR(1 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"SHARE_PERCENTAGE" FLOAT(126), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"T_EWA_ID" VARCHAR2(50 BYTE), 
	"T_OAA_ID" VARCHAR2(50 BYTE), 
	"T_NOC_GENERATOR_ID" VARCHAR2(50 BYTE), 
	"T_INPRINCIPLE_APPLN_ID" VARCHAR2(50 BYTE), 
	"T_EPA_ID" VARCHAR2(50 BYTE), 
	"T_CS_ID" VARCHAR2(50 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_AGREEMENT_LINE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_AGREEMENT_LINE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"F_AGREEMENT_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_ORG_ID" VARCHAR2(50 BYTE), 
	"BUYER_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"BUYER_FEEDER_ID" VARCHAR2(50 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"APPROVED_CAPACITY" VARCHAR2(50 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"FROM_MONTH" VARCHAR2(50 BYTE), 
	"TO_YEAR" VARCHAR2(50 BYTE), 
	"FROM_YEAR" VARCHAR2(50 BYTE), 
	"TO_MONTH" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"AGREEMENT_DT" DATE, 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"SHARE_PERCENTAGE" VARCHAR2(50 BYTE), 
	"PAYMENT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"PAYMENT_BANK_DETAILS" VARCHAR2(50 BYTE), 
	"PAYMENT_TXN_NO" VARCHAR2(50 BYTE), 
	"PAYMENT_DATE" DATE, 
	"PAYMENT_AMOUNT" VARCHAR2(50 BYTE), 
	"LICENSEE" VARCHAR2(50 BYTE), 
	"STATE_TRANS_LOSS" VARCHAR2(50 BYTE), 
	"STATE_TRANS_LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"STATE_TRANS_CHARGES" VARCHAR2(50 BYTE), 
	"STATE_TRANS_CHARGES_PERCENT" VARCHAR2(50 BYTE), 
	"SCHEDULING_CHARGES" VARCHAR2(50 BYTE), 
	"SCHEDULING_CHARGES_PERCENT" VARCHAR2(50 BYTE), 
	"SYSTEM_OPR_CHARGES" VARCHAR2(50 BYTE), 
	"SYSTEM_OPR_CHARGES_PERCENT" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_LINE_ID" VARCHAR2(50 BYTE), 
	"T_NOC_ID" VARCHAR2(50 BYTE), 
	"T_CONSENT_ID" VARCHAR2(50 BYTE), 
	"T_EWA_LINE_ID" VARCHAR2(50 BYTE), 
	"T_INPRINCIPLE_APPLN_LINE_ID" VARCHAR2(50 BYTE), 
	"T_NOC_GENERATOR_LINE_ID" VARCHAR2(50 BYTE), 
	"T_STANDING_CLEARENCE_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"MODIFIED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTED_CHARGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTED_CHARGE" 
   (	"ID" VARCHAR2(100 BYTE), 
	"F_ENERGY_ADJUSTED_ID" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(50 BYTE), 
	"CHARGE_AMOUNT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_01032021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01032021" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_01052020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01052020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_031220
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_031220" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_05042021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_05042021" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_18062020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_18062020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_19052021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_19052021" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_220620
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_220620" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_29022020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_29022020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_30042020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_30042020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_BKB4FIX_280619" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_COPY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_JANFEB2020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_JANFEB2020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_ADJUSTMET_MAR262020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_MAR262020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(50 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_CHARGES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_CHARGES" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_CHARGES_070619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_CHARGES_070619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_CHARGES_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_CHARGES_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_LEDGER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_LEDGER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SERVICE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"LEDGER_DATE" DATE, 
	"ENERGY_IN" VARCHAR2(50 BYTE), 
	"ENERGY_OUT" VARCHAR2(50 BYTE), 
	"NULLIFY" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"D_COMP_NAME" VARCHAR2(100 BYTE), 
	"D_COMP_CODE" VARCHAR2(50 BYTE), 
	"D_COMP_SERV_NUMBER" VARCHAR2(100 BYTE), 
	"D_ORG_NAME" VARCHAR2(100 BYTE), 
	"D_ORG_CODE" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINES_ID" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"D_COMMISSION_DATE" DATE, 
	"D_IS_REC" CHAR(1 BYTE), 
	"D_ADJUSTMENT_PRIORITY" VARCHAR2(20 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_LEDGER_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_LEDGER_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SERVICE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"LEDGER_DATE" DATE, 
	"ENERGY_IN" VARCHAR2(50 BYTE), 
	"ENERGY_OUT" VARCHAR2(50 BYTE), 
	"NULLIFY" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"D_COMP_NAME" VARCHAR2(100 BYTE), 
	"D_COMP_CODE" VARCHAR2(50 BYTE), 
	"D_COMP_SERV_NUMBER" VARCHAR2(100 BYTE), 
	"D_ORG_NAME" VARCHAR2(100 BYTE), 
	"D_ORG_CODE" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINES_ID" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"D_COMMISSION_DATE" DATE, 
	"D_IS_REC" CHAR(1 BYTE), 
	"D_ADJUSTMENT_PRIORITY" VARCHAR2(20 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_SALE_ORDER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"TOTAL_C1" VARCHAR2(50 BYTE), 
	"TOTAL_C2" VARCHAR2(50 BYTE), 
	"TOTAL_C3" VARCHAR2(50 BYTE), 
	"TOTAL_C4" VARCHAR2(50 BYTE), 
	"TOTAL_C5" VARCHAR2(50 BYTE), 
	"TOTAL_GEN_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"TOTAL_BC1" VARCHAR2(50 BYTE), 
	"TOTAL_BC2" VARCHAR2(50 BYTE), 
	"TOTAL_BC3" VARCHAR2(50 BYTE), 
	"TOTAL_BC4" VARCHAR2(50 BYTE), 
	"TOTAL_BC5" VARCHAR2(50 BYTE), 
	"TOTAL_BANKING_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"TOTAL_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"D_SELL_COMP_NAME" VARCHAR2(100 BYTE), 
	"D_SELL_COMP_CODE" VARCHAR2(50 BYTE), 
	"D_SELL_COMP_SERV_NUMBER" VARCHAR2(100 BYTE), 
	"D_SELL_ORG_NAME" VARCHAR2(100 BYTE), 
	"D_SELL_ORG_CODE" VARCHAR2(50 BYTE), 
	"TOTAL_GC1" VARCHAR2(50 BYTE), 
	"TOTAL_GC2" VARCHAR2(50 BYTE), 
	"TOTAL_GC3" VARCHAR2(50 BYTE), 
	"TOTAL_GC4" VARCHAR2(50 BYTE), 
	"TOTAL_GC5" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"SELLER_COMP_ID" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_SALE_ORDER_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"TOTAL_C1" VARCHAR2(50 BYTE), 
	"TOTAL_C2" VARCHAR2(50 BYTE), 
	"TOTAL_C3" VARCHAR2(50 BYTE), 
	"TOTAL_C4" VARCHAR2(50 BYTE), 
	"TOTAL_C5" VARCHAR2(50 BYTE), 
	"TOTAL_GEN_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"TOTAL_BC1" VARCHAR2(50 BYTE), 
	"TOTAL_BC2" VARCHAR2(50 BYTE), 
	"TOTAL_BC3" VARCHAR2(50 BYTE), 
	"TOTAL_BC4" VARCHAR2(50 BYTE), 
	"TOTAL_BC5" VARCHAR2(50 BYTE), 
	"TOTAL_BANKING_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"TOTAL_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"D_SELL_COMP_NAME" VARCHAR2(100 BYTE), 
	"D_SELL_COMP_CODE" VARCHAR2(50 BYTE), 
	"D_SELL_COMP_SERV_NUMBER" VARCHAR2(100 BYTE), 
	"D_SELL_ORG_NAME" VARCHAR2(100 BYTE), 
	"D_SELL_ORG_CODE" VARCHAR2(50 BYTE), 
	"TOTAL_GC1" VARCHAR2(50 BYTE), 
	"TOTAL_GC2" VARCHAR2(50 BYTE), 
	"TOTAL_GC3" VARCHAR2(50 BYTE), 
	"TOTAL_GC4" VARCHAR2(50 BYTE), 
	"TOTAL_GC5" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"SELLER_COMP_ID" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_SALE_ORDER_LINES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" 
   (	"ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_SS_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"GEN_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"BC1" VARCHAR2(50 BYTE), 
	"BC2" VARCHAR2(50 BYTE), 
	"BC3" VARCHAR2(50 BYTE), 
	"BC4" VARCHAR2(50 BYTE), 
	"BC5" VARCHAR2(50 BYTE), 
	"BANKING_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"TOTAL_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"D_BUYER_COMP_NAME" VARCHAR2(100 BYTE), 
	"D_BUYER_COMP_CODE" VARCHAR2(50 BYTE), 
	"D_BUYER_COMP_SERV_NAME" VARCHAR2(100 BYTE), 
	"D_BUYER_ORG_NAME" VARCHAR2(100 BYTE), 
	"D_BUYER_ORG_CODE" VARCHAR2(50 BYTE), 
	"D_BUYER_SS_NAME" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"BUYER_COMP_ID" VARCHAR2(100 BYTE), 
	"D_DRAWAL_VOLTAGE_CODE" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"UNIT_COST" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_CHARGABLE" VARCHAR2(100 BYTE), 
	"NET_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table F_ENERGY_SALE_ORDER_LINES_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_SS_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"GEN_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"BC1" VARCHAR2(50 BYTE), 
	"BC2" VARCHAR2(50 BYTE), 
	"BC3" VARCHAR2(50 BYTE), 
	"BC4" VARCHAR2(50 BYTE), 
	"BC5" VARCHAR2(50 BYTE), 
	"BANKING_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"TOTAL_UNITS_SOLD" VARCHAR2(50 BYTE), 
	"D_BUYER_COMP_NAME" VARCHAR2(100 BYTE), 
	"D_BUYER_COMP_CODE" VARCHAR2(50 BYTE), 
	"D_BUYER_COMP_SERV_NAME" VARCHAR2(100 BYTE), 
	"D_BUYER_ORG_NAME" VARCHAR2(100 BYTE), 
	"D_BUYER_ORG_CODE" VARCHAR2(50 BYTE), 
	"D_BUYER_SS_NAME" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"BUYER_COMP_ID" VARCHAR2(100 BYTE), 
	"D_DRAWAL_VOLTAGE_CODE" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"UNIT_COST" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_CHARGABLE" VARCHAR2(100 BYTE), 
	"NET_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table GENERATION_BASED_INCENTIVE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."GENERATION_BASED_INCENTIVE" 
   (	"SERVICE_NO" VARCHAR2(30 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"REMARKS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HTSURPLUS_022020_200620
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HTSURPLUS_022020_200620" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(128 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,2), 
	"ADJUSTEDC2" NUMBER(38,2), 
	"ADJUSTEDC3" NUMBER(38,2), 
	"ADJUSTEDC4" NUMBER(38,2), 
	"ADJUSTEDC5" NUMBER(38,2), 
	"ADJUSTEDC24" NUMBER(38,2), 
	"SURPLUSC1" NUMBER(38,2), 
	"SURPLUSC2" NUMBER(38,2), 
	"SURPLUSC3" NUMBER(38,2), 
	"SURPLUSC4" NUMBER(38,2), 
	"SURPLUSC5" NUMBER(38,2), 
	"SURPLUSC24" NUMBER(38,2), 
	"READINGDT" VARCHAR2(26 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HTSURPLUS_042020_220620
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HTSURPLUS_042020_220620" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(128 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,2), 
	"ADJUSTEDC2" NUMBER(38,2), 
	"ADJUSTEDC3" NUMBER(38,2), 
	"ADJUSTEDC4" NUMBER(38,2), 
	"ADJUSTEDC5" NUMBER(38,2), 
	"ADJUSTEDC24" NUMBER(38,2), 
	"SURPLUSC1" NUMBER(38,2), 
	"SURPLUSC2" NUMBER(38,2), 
	"SURPLUSC3" NUMBER(38,2), 
	"SURPLUSC4" NUMBER(38,2), 
	"SURPLUSC5" NUMBER(38,2), 
	"SURPLUSC24" NUMBER(38,2), 
	"READINGDT" VARCHAR2(26 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HTSURPLUS_23042021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HTSURPLUS_23042021" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(128 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,0), 
	"ADJUSTEDC2" NUMBER(38,0), 
	"ADJUSTEDC3" NUMBER(38,0), 
	"ADJUSTEDC4" NUMBER(38,0), 
	"ADJUSTEDC5" NUMBER(38,0), 
	"ADJUSTEDC24" NUMBER(38,0), 
	"SURPLUSC1" NUMBER(38,0), 
	"SURPLUSC2" NUMBER(38,0), 
	"SURPLUSC3" NUMBER(38,0), 
	"SURPLUSC4" NUMBER(38,0), 
	"SURPLUSC5" NUMBER(38,0), 
	"SURPLUSC24" NUMBER(38,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HTSURPLUS_230421
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HTSURPLUS_230421" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(128 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,0), 
	"ADJUSTEDC2" NUMBER(38,0), 
	"ADJUSTEDC3" NUMBER(38,0), 
	"ADJUSTEDC4" NUMBER(38,0), 
	"ADJUSTEDC5" NUMBER(38,0), 
	"ADJUSTEDC24" NUMBER(38,0), 
	"SURPLUSC1" NUMBER(38,0), 
	"SURPLUSC2" NUMBER(38,0), 
	"SURPLUSC3" NUMBER(38,0), 
	"SURPLUSC4" NUMBER(38,0), 
	"SURPLUSC5" NUMBER(38,0), 
	"SURPLUSC24" NUMBER(38,0), 
	"READINGDT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HT_0420_NETSURP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HT_0420_NETSURP" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(128 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,2), 
	"ADJUSTEDC2" NUMBER(38,2), 
	"ADJUSTEDC3" NUMBER(38,2), 
	"ADJUSTEDC4" NUMBER(38,2), 
	"ADJUSTEDC5" NUMBER(38,2), 
	"ADJUSTEDC24" NUMBER(38,2), 
	"SURPLUSC1" NUMBER(38,2), 
	"SURPLUSC2" NUMBER(38,2), 
	"SURPLUSC3" NUMBER(38,2), 
	"SURPLUSC4" NUMBER(38,2), 
	"SURPLUSC5" NUMBER(38,2), 
	"SURPLUSC24" NUMBER(38,2), 
	"READINGDT" VARCHAR2(26 BYTE), 
	"C1NET" NUMBER(38,0), 
	"C2NET" NUMBER(38,0), 
	"C3NET" NUMBER(38,0), 
	"C4NET" NUMBER(38,0), 
	"C5NET" NUMBER(38,0), 
	"C24NET" NUMBER(38,0), 
	"ID" NUMBER(10,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HT_079204740038_050421
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HT_079204740038_050421" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(26 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,0), 
	"ADJUSTEDC2" NUMBER(38,0), 
	"ADJUSTEDC3" NUMBER(38,2), 
	"ADJUSTEDC4" NUMBER(38,2), 
	"ADJUSTEDC5" NUMBER(38,2), 
	"MY" NUMBER(38,0), 
	"SURPLUSC1" NUMBER(38,0), 
	"SURPLUSC2" NUMBER(38,0), 
	"SURPLUSC3" NUMBER(38,0), 
	"SURPLUSC4" NUMBER(38,0), 
	"SURPLUSC5" NUMBER(38,0), 
	"SURPLUSC24" NUMBER(38,0), 
	"READINGDT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HT_ADJ_012020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HT_ADJ_012020" 
   (	"BUYERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERSERVICENO" VARCHAR2(26 BYTE), 
	"SELLERTYPE" VARCHAR2(26 BYTE), 
	"SELLERNAME" VARCHAR2(128 BYTE), 
	"READINGMNTH" NUMBER(38,0), 
	"READINGYR" NUMBER(38,0), 
	"ADJUSTEDC1" NUMBER(38,0), 
	"ADJUSTEDC2" NUMBER(38,0), 
	"ADJUSTEDC3" NUMBER(38,2), 
	"ADJUSTEDC4" NUMBER(38,0), 
	"ADJUSTEDC5" NUMBER(38,2), 
	"ADJUSTEDC24" NUMBER(38,0), 
	"SURPLUSC1" NUMBER(38,0), 
	"SURPLUSC2" NUMBER(38,0), 
	"SURPLUSC3" NUMBER(38,0), 
	"SURPLUSC4" NUMBER(38,0), 
	"SURPLUSC5" NUMBER(38,0), 
	"SURPLUSC24" NUMBER(38,0), 
	"READINGDT" VARCHAR2(26 BYTE), 
	"READINGMONTH" VARCHAR2(26 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HT_BANKING_032020_1012
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HT_BANKING_032020_1012" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HT_BANKING_UNITS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HT_BANKING_UNITS" 
   (	"BUYERSERVICENO" VARCHAR2(15 BYTE), 
	"SELLERSERVICENO" VARCHAR2(15 BYTE), 
	"SELLERTYPE" VARCHAR2(20 BYTE), 
	"SELLERNAME" VARCHAR2(100 BYTE), 
	"READINGMNTH" VARCHAR2(2 BYTE), 
	"READINGYR" VARCHAR2(4 BYTE), 
	"ADJUSTEDC1" VARCHAR2(15 BYTE), 
	"ADJUSTEDC2" VARCHAR2(15 BYTE), 
	"ADJUSTEDC3" VARCHAR2(15 BYTE), 
	"ADJUSTEDC4" VARCHAR2(15 BYTE), 
	"ADJUSTEDC5" VARCHAR2(15 BYTE), 
	"ADJUSTEDC24" VARCHAR2(15 BYTE), 
	"SURPLUS1" VARCHAR2(20 BYTE), 
	"SURPLUS2" VARCHAR2(20 BYTE), 
	"SURPLUS3" VARCHAR2(20 BYTE), 
	"SURPLUS4" VARCHAR2(20 BYTE), 
	"SURPLUS5" VARCHAR2(20 BYTE), 
	"SURPLUS24" VARCHAR2(20 BYTE), 
	"READINGDT" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table HT_SERVICE_MAS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."HT_SERVICE_MAS" 
   (	"SERVICE_NO" VARCHAR2(15 BYTE), 
	"SERVICE_DATE" DATE, 
	"REGION_CODE" VARCHAR2(4 BYTE), 
	"CIRCLE_CODE" VARCHAR2(4 BYTE), 
	"DISTRICT_CODE" VARCHAR2(4 BYTE), 
	"SECTION_CODE" VARCHAR2(4 BYTE), 
	"DIVISION_CODE" VARCHAR2(4 BYTE), 
	"SALUTE" VARCHAR2(5 BYTE), 
	"APPLICANT_NAME" VARCHAR2(100 BYTE), 
	"HT_TARIFF_TYPE" VARCHAR2(5 BYTE), 
	"APPLICANT_CATEGORY" VARCHAR2(5 BYTE), 
	"SERVICE_TYPE_CODE" VARCHAR2(5 BYTE), 
	"SERVICE_CATEGORY" VARCHAR2(3 BYTE), 
	"INDUSTRY_CODE" VARCHAR2(3 BYTE), 
	"CONCESS_TYPE" VARCHAR2(3 BYTE), 
	"LTORHTSIDE" VARCHAR2(3 BYTE), 
	"LT_TRANS_CAP" VARCHAR2(4 BYTE), 
	"DEMAND_SANC" NUMBER(10,2), 
	"DEMAND_SANC_ON" DATE, 
	"LOAD" NUMBER(10,2), 
	"AADHAR_CARD_NO" VARCHAR2(15 BYTE), 
	"PAN_CARD_NO" VARCHAR2(15 BYTE), 
	"GST_NO" VARCHAR2(20 BYTE), 
	"SD_ADDRESS" VARCHAR2(150 BYTE), 
	"SD_DISTRICT" VARCHAR2(3 BYTE), 
	"SD_VILLAGE" VARCHAR2(3 BYTE), 
	"SD_TALUK" VARCHAR2(3 BYTE), 
	"SD_PINCODE" VARCHAR2(6 BYTE), 
	"SD_LANDLINE_NO" VARCHAR2(15 BYTE), 
	"SD_FAX_NO" VARCHAR2(15 BYTE), 
	"BD_ADDRESS" VARCHAR2(150 BYTE), 
	"BD_DISTRICT" VARCHAR2(3 BYTE), 
	"BD_VILLAGE" VARCHAR2(3 BYTE), 
	"BD_TALUK" VARCHAR2(3 BYTE), 
	"BD_PINCODE" VARCHAR2(6 BYTE), 
	"BD_LANDLINE_NO" VARCHAR2(15 BYTE), 
	"BD_FAX_NO" VARCHAR2(15 BYTE), 
	"E_MAIL" VARCHAR2(75 BYTE), 
	"MOBILE_NO" VARCHAR2(12 BYTE), 
	"METER_RENT" NUMBER(6,0), 
	"SUPPLY_VOLTAGE" VARCHAR2(3 BYTE), 
	"ETAX_APPLICABLE" VARCHAR2(3 BYTE), 
	"IT_EXEMPTED" VARCHAR2(3 BYTE), 
	"LEASE" VARCHAR2(3 BYTE), 
	"INDUSTRIAL_LOAD" VARCHAR2(15 BYTE), 
	"NON_INDUSTRIAL_LOAD" VARCHAR2(15 BYTE), 
	"NON_RESIDENTIAL_LOAD" VARCHAR2(15 BYTE), 
	"LT_BILLED" VARCHAR2(3 BYTE), 
	"LT_TARIFF_TYPE" VARCHAR2(5 BYTE), 
	"MF" VARCHAR2(10 BYTE), 
	"READ_DATE" NUMBER, 
	"F_BILL_DATE" DATE, 
	"ACK_NO" VARCHAR2(30 BYTE), 
	"ACK_DATE" DATE, 
	"IS_TRANSFER" VARCHAR2(3 BYTE), 
	"TRANSFER_CIRCLE" VARCHAR2(4 BYTE), 
	"TRANSFER_SCNO" VARCHAR2(15 BYTE), 
	"TRANSFER_MONTH" VARCHAR2(6 BYTE), 
	"PARENT_CODE" VARCHAR2(4 BYTE), 
	"CANCELLED_ON" DATE, 
	"REMARKS" VARCHAR2(75 BYTE), 
	"MET_REG_NO" VARCHAR2(20 BYTE), 
	"APPLICANT_TYPE" VARCHAR2(20 BYTE), 
	"CREATED_BY" VARCHAR2(20 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(20 BYTE), 
	"MODIFIED_DT" DATE, 
	"STATUS" VARCHAR2(20 BYTE), 
	"REVISION_EXEMPTED" VARCHAR2(20 BYTE), 
	"LT_ETAX_APPLICABLE" VARCHAR2(2 BYTE), 
	"GST_EXEMPTED" VARCHAR2(2 BYTE), 
	"POWER_START_UP" VARCHAR2(2 BYTE), 
	"VAS_ACC_NO" VARCHAR2(20 BYTE), 
	"GST_NO_I" VARCHAR2(255 CHAR), 
	"GST_DEPARTMENT_NAME" VARCHAR2(255 CHAR), 
	"GST_OFFICER_NAME_DESIGNATION" VARCHAR2(255 CHAR), 
	"GST_DECLARATION_DATE" DATE, 
	"SERVICE_PURPOSE_CODE" VARCHAR2(5 CHAR), 
	"USER_CODE" VARCHAR2(10 BYTE), 
	"SCHEDULE_CODE" VARCHAR2(5 BYTE), 
	"IPDS_SCHEME" VARCHAR2(20 BYTE), 
	"TOWN_CODE" VARCHAR2(6 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table H_DELETE_TXN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."H_DELETE_TXN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"AUTH_USER_ID" VARCHAR2(50 BYTE), 
	"AUTH_USER_NAME" VARCHAR2(100 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"DEL_TXN_PURPOSE_CODE" VARCHAR2(20 BYTE), 
	"STATUS" VARCHAR2(50 BYTE), 
	"DATE_TIME_STAMP" VARCHAR2(20 BYTE), 
	"RESULT_DESC" VARCHAR2(2000 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"COLUMN1" VARCHAR2(50 BYTE), 
	"COLUMN2" VARCHAR2(50 BYTE), 
	"COLUMN3" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IEX_070820
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IEX_070820" 
   (	"CIRCLE_NAME" VARCHAR2(26 BYTE), 
	"SERVICE_NO" VARCHAR2(15 BYTE), 
	"READING_MNTH" NUMBER(1,0), 
	"READING_YR" NUMBER(4,0), 
	"NAMEOFCONS" VARCHAR2(56 BYTE), 
	"DMND" NUMBER(5,0), 
	"YRLYCONS" NUMBER(7,0), 
	"IEX" NUMBER(9,2), 
	"TP" NUMBER(1,0), 
	"WIND" NUMBER(9,2), 
	"CPP" NUMBER(1,0), 
	"ADJ" NUMBER(9,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_BUYERS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_BUYERS" 
   (	"HT_REF_NO" VARCHAR2(100 BYTE), 
	"SERVICENO" VARCHAR2(100 BYTE), 
	"SERVICEDATE" VARCHAR2(100 BYTE), 
	"REGNNUM" VARCHAR2(100 BYTE), 
	"REGNDATE" VARCHAR2(100 BYTE), 
	"CIRCLECODE" VARCHAR2(100 BYTE), 
	"DIVISIONCODE" VARCHAR2(100 BYTE), 
	"SALUTE" VARCHAR2(100 BYTE), 
	"CONSUMERNAME" VARCHAR2(100 BYTE), 
	"SERVICETYPE" VARCHAR2(100 BYTE), 
	"HTTARIFFTYPE" VARCHAR2(100 BYTE), 
	"CATEGORY" VARCHAR2(100 BYTE), 
	"INDUSTRYCODE" VARCHAR2(100 BYTE), 
	"CONCESSTYPE" VARCHAR2(100 BYTE), 
	"CONCDATE" VARCHAR2(100 BYTE), 
	"LTORHTSIDE" VARCHAR2(100 BYTE), 
	"LTTRANSCAP" VARCHAR2(100 BYTE), 
	"PMDEFFDATE" VARCHAR2(100 BYTE), 
	"DEMANDSANC" VARCHAR2(100 BYTE), 
	"DEMANDSANCON" VARCHAR2(100 BYTE), 
	"LOAD" VARCHAR2(100 BYTE), 
	"METERRENT" VARCHAR2(100 BYTE), 
	"AVAILEDVOLT" VARCHAR2(100 BYTE), 
	"ETAX" VARCHAR2(100 BYTE), 
	"ITEXEMPTED" VARCHAR2(100 BYTE), 
	"WINDMILL" VARCHAR2(100 BYTE), 
	"WLINELOSS" VARCHAR2(100 BYTE), 
	"CGP" VARCHAR2(100 BYTE), 
	"CPP" VARCHAR2(100 BYTE), 
	"LTBILLED" VARCHAR2(100 BYTE), 
	"NONAVAIL" VARCHAR2(100 BYTE), 
	"ESSENTIAL" VARCHAR2(100 BYTE), 
	"POWERCUT" VARCHAR2(100 BYTE), 
	"CANCELLEDON" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CGPWHEELCHRG" VARCHAR2(100 BYTE), 
	"CPPLINELOSS" VARCHAR2(100 BYTE), 
	"METERAT" VARCHAR2(100 BYTE), 
	"ADDRESS1" VARCHAR2(100 BYTE), 
	"ADDRESS2" VARCHAR2(100 BYTE), 
	"ADDRESS3" VARCHAR2(100 BYTE), 
	"ADDRESS4" VARCHAR2(100 BYTE), 
	"CITY" VARCHAR2(100 BYTE), 
	"PINCODE" VARCHAR2(100 BYTE), 
	"PHONE" VARCHAR2(100 BYTE), 
	"FAX" VARCHAR2(100 BYTE), 
	"EMAIL" VARCHAR2(100 BYTE), 
	"DISTRICTCODE" VARCHAR2(100 BYTE), 
	"OADDRESS1" VARCHAR2(100 BYTE), 
	"OADDRESS2" VARCHAR2(100 BYTE), 
	"OADDRESS3" VARCHAR2(100 BYTE), 
	"OADDRESS4" VARCHAR2(100 BYTE), 
	"OCITY" VARCHAR2(100 BYTE), 
	"OPINCODE" VARCHAR2(100 BYTE), 
	"OPHONE" VARCHAR2(100 BYTE), 
	"OFAX" VARCHAR2(100 BYTE), 
	"OEMAIL" VARCHAR2(100 BYTE), 
	"OFFDISTCODE" VARCHAR2(100 BYTE), 
	"SERVICETYPEON" VARCHAR2(100 BYTE), 
	"WMMETERRENT" VARCHAR2(100 BYTE), 
	"COLDINDKW" VARCHAR2(100 BYTE), 
	"COLDNIRKW" VARCHAR2(100 BYTE), 
	"COLDNINRKW" VARCHAR2(100 BYTE), 
	"LTTARIFFTYPE" VARCHAR2(100 BYTE), 
	"LT2PART" VARCHAR2(100 BYTE), 
	"LTCTMETER" VARCHAR2(100 BYTE), 
	"READDATE" VARCHAR2(100 BYTE), 
	"FBILLDATE" VARCHAR2(100 BYTE), 
	"LTBILLFP" VARCHAR2(100 BYTE), 
	"LEASE" VARCHAR2(100 BYTE), 
	"ENERGYAUDIT" VARCHAR2(100 BYTE), 
	"APPLNNUM" VARCHAR2(100 BYTE), 
	"APPLNDATE" VARCHAR2(100 BYTE), 
	"INJECTIONVOLT" VARCHAR2(100 BYTE), 
	"ARCFURNACE" VARCHAR2(100 BYTE), 
	"CPPGROUP" VARCHAR2(100 BYTE), 
	"WEGGROUP" VARCHAR2(100 BYTE), 
	"PANNO" VARCHAR2(100 BYTE), 
	"QTAEGY" VARCHAR2(100 BYTE), 
	"QTADEM" VARCHAR2(100 BYTE), 
	"RQTA" VARCHAR2(100 BYTE), 
	"RQTADAYS" VARCHAR2(100 BYTE), 
	"RPUPEAK" VARCHAR2(100 BYTE), 
	"RPUNONPEAK" VARCHAR2(100 BYTE), 
	"THIRDPARTY" VARCHAR2(100 BYTE), 
	"WINDMILLGRP1" VARCHAR2(100 BYTE), 
	"WINDMILLGRP2" VARCHAR2(100 BYTE), 
	"BASEENERGY" VARCHAR2(100 BYTE), 
	"BASEDEMAND" VARCHAR2(100 BYTE), 
	"TRANSCAP" VARCHAR2(100 BYTE), 
	"TPINJECTIONVOLT" VARCHAR2(100 BYTE), 
	"IEX" VARCHAR2(100 BYTE), 
	"NIGHTQTA" VARCHAR2(100 BYTE), 
	"POWERHOLIDAY" VARCHAR2(100 BYTE), 
	"LTLOAD" VARCHAR2(100 BYTE), 
	"TPNCES" VARCHAR2(100 BYTE), 
	"TPCES" VARCHAR2(100 BYTE), 
	"SEZ" VARCHAR2(100 BYTE), 
	"RAPDRP" VARCHAR2(100 BYTE), 
	"TRANSFER" VARCHAR2(100 BYTE), 
	"TRANSFERCIRCLE" VARCHAR2(100 BYTE), 
	"TRANSFERSCNO" VARCHAR2(100 BYTE), 
	"TRANSFERMONTH" VARCHAR2(100 BYTE), 
	"RNC" VARCHAR2(100 BYTE), 
	"PARENT_CODE" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_BUYERS_COPY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_BUYERS_COPY" 
   (	"HT_REF_NO" VARCHAR2(100 BYTE), 
	"SERVICENO" VARCHAR2(100 BYTE), 
	"SERVICEDATE" VARCHAR2(100 BYTE), 
	"REGNNUM" VARCHAR2(100 BYTE), 
	"REGNDATE" VARCHAR2(100 BYTE), 
	"CIRCLECODE" VARCHAR2(100 BYTE), 
	"DIVISIONCODE" VARCHAR2(100 BYTE), 
	"SALUTE" VARCHAR2(100 BYTE), 
	"CONSUMERNAME" VARCHAR2(100 BYTE), 
	"SERVICETYPE" VARCHAR2(100 BYTE), 
	"HTTARIFFTYPE" VARCHAR2(100 BYTE), 
	"CATEGORY" VARCHAR2(100 BYTE), 
	"INDUSTRYCODE" VARCHAR2(100 BYTE), 
	"CONCESSTYPE" VARCHAR2(100 BYTE), 
	"CONCDATE" VARCHAR2(100 BYTE), 
	"LTORHTSIDE" VARCHAR2(100 BYTE), 
	"LTTRANSCAP" VARCHAR2(100 BYTE), 
	"PMDEFFDATE" VARCHAR2(100 BYTE), 
	"DEMANDSANC" VARCHAR2(100 BYTE), 
	"DEMANDSANCON" VARCHAR2(100 BYTE), 
	"LOAD" VARCHAR2(100 BYTE), 
	"METERRENT" VARCHAR2(100 BYTE), 
	"AVAILEDVOLT" VARCHAR2(100 BYTE), 
	"ETAX" VARCHAR2(100 BYTE), 
	"ITEXEMPTED" VARCHAR2(100 BYTE), 
	"WINDMILL" VARCHAR2(100 BYTE), 
	"WLINELOSS" VARCHAR2(100 BYTE), 
	"CGP" VARCHAR2(100 BYTE), 
	"CPP" VARCHAR2(100 BYTE), 
	"LTBILLED" VARCHAR2(100 BYTE), 
	"NONAVAIL" VARCHAR2(100 BYTE), 
	"ESSENTIAL" VARCHAR2(100 BYTE), 
	"POWERCUT" VARCHAR2(100 BYTE), 
	"CANCELLEDON" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CGPWHEELCHRG" VARCHAR2(100 BYTE), 
	"CPPLINELOSS" VARCHAR2(100 BYTE), 
	"METERAT" VARCHAR2(100 BYTE), 
	"ADDRESS1" VARCHAR2(200 BYTE), 
	"ADDRESS2" VARCHAR2(200 BYTE), 
	"ADDRESS3" VARCHAR2(100 BYTE), 
	"ADDRESS4" VARCHAR2(100 BYTE), 
	"CITY" VARCHAR2(100 BYTE), 
	"PINCODE" VARCHAR2(100 BYTE), 
	"PHONE" VARCHAR2(100 BYTE), 
	"FAX" VARCHAR2(100 BYTE), 
	"EMAIL" VARCHAR2(100 BYTE), 
	"DISTRICTCODE" VARCHAR2(100 BYTE), 
	"OADDRESS1" VARCHAR2(100 BYTE), 
	"OADDRESS2" VARCHAR2(100 BYTE), 
	"OADDRESS3" VARCHAR2(100 BYTE), 
	"OADDRESS4" VARCHAR2(100 BYTE), 
	"OCITY" VARCHAR2(100 BYTE), 
	"OPINCODE" VARCHAR2(100 BYTE), 
	"OPHONE" VARCHAR2(100 BYTE), 
	"OFAX" VARCHAR2(100 BYTE), 
	"OEMAIL" VARCHAR2(100 BYTE), 
	"OFFDISTCODE" VARCHAR2(100 BYTE), 
	"SERVICETYPEON" VARCHAR2(100 BYTE), 
	"WMMETERRENT" VARCHAR2(100 BYTE), 
	"COLDINDKW" VARCHAR2(100 BYTE), 
	"COLDNIRKW" VARCHAR2(100 BYTE), 
	"COLDNINRKW" VARCHAR2(100 BYTE), 
	"LTTARIFFTYPE" VARCHAR2(100 BYTE), 
	"LT2PART" VARCHAR2(100 BYTE), 
	"LTCTMETER" VARCHAR2(100 BYTE), 
	"READDATE" VARCHAR2(100 BYTE), 
	"FBILLDATE" VARCHAR2(100 BYTE), 
	"LTBILLFP" VARCHAR2(100 BYTE), 
	"LEASE" VARCHAR2(100 BYTE), 
	"ENERGYAUDIT" VARCHAR2(100 BYTE), 
	"APPLNNUM" VARCHAR2(100 BYTE), 
	"APPLNDATE" VARCHAR2(100 BYTE), 
	"INJECTIONVOLT" VARCHAR2(100 BYTE), 
	"ARCFURNACE" VARCHAR2(100 BYTE), 
	"CPPGROUP" VARCHAR2(100 BYTE), 
	"WEGGROUP" VARCHAR2(100 BYTE), 
	"PANNO" VARCHAR2(100 BYTE), 
	"QTAEGY" VARCHAR2(100 BYTE), 
	"QTADEM" VARCHAR2(100 BYTE), 
	"RQTA" VARCHAR2(100 BYTE), 
	"RQTADAYS" VARCHAR2(100 BYTE), 
	"RPUPEAK" VARCHAR2(100 BYTE), 
	"RPUNONPEAK" VARCHAR2(100 BYTE), 
	"THIRDPARTY" VARCHAR2(100 BYTE), 
	"WINDMILLGRP1" VARCHAR2(100 BYTE), 
	"WINDMILLGRP2" VARCHAR2(100 BYTE), 
	"BASEENERGY" VARCHAR2(100 BYTE), 
	"BASEDEMAND" VARCHAR2(100 BYTE), 
	"TRANSCAP" VARCHAR2(100 BYTE), 
	"TPINJECTIONVOLT" VARCHAR2(100 BYTE), 
	"IEX" VARCHAR2(100 BYTE), 
	"NIGHTQTA" VARCHAR2(100 BYTE), 
	"POWERHOLIDAY" VARCHAR2(100 BYTE), 
	"LTLOAD" VARCHAR2(100 BYTE), 
	"TPNCES" VARCHAR2(100 BYTE), 
	"TPCES" VARCHAR2(100 BYTE), 
	"SEZ" VARCHAR2(100 BYTE), 
	"RAPDRP" VARCHAR2(100 BYTE), 
	"TRANSFER" VARCHAR2(100 BYTE), 
	"TRANSFERCIRCLE" VARCHAR2(100 BYTE), 
	"TRANSFERSCNO" VARCHAR2(100 BYTE), 
	"TRANSFERMONTH" VARCHAR2(100 BYTE), 
	"RNC" VARCHAR2(100 BYTE), 
	"PARENT_CODE" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_CONTACT_INFO
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_CONTACT_INFO" 
   (	"number" VARCHAR2(100 BYTE), 
	"CONTACT_FULL_NAME" VARCHAR2(200 BYTE), 
	"CONTACT_DESIGNATION" VARCHAR2(200 BYTE), 
	"CONTACT_EMAIL" VARCHAR2(200 BYTE), 
	"CONTACT_PHONE_NO" VARCHAR2(20 BYTE), 
	"REG_OFFICE_ADDR" VARCHAR2(1000 BYTE), 
	"PLANT_ADDR" VARCHAR2(1000 BYTE), 
	"IS_CONTACT_VERIFIED" VARCHAR2(10 BYTE), 
	"CONTACT_LAST_VERIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_METER_READING
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_METER_READING" 
   (	"REMARKS" VARCHAR2(500 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"METER_NO" VARCHAR2(100 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"INIT_READING_DT_STR" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT_STR" VARCHAR2(50 BYTE), 
	"READING_DT_STR" VARCHAR2(50 BYTE), 
	"IMP_SLOT1" VARCHAR2(10 BYTE), 
	"IMP_SLOT2" VARCHAR2(10 BYTE), 
	"IMP_SLOT3" VARCHAR2(10 BYTE), 
	"IMP_SLOT4" VARCHAR2(10 BYTE), 
	"IMP_SLOT5" VARCHAR2(10 BYTE), 
	"EXP_SLOT1" VARCHAR2(10 BYTE), 
	"EXP_SLOT2" VARCHAR2(10 BYTE), 
	"EXP_SLOT3" VARCHAR2(10 BYTE), 
	"EXP_SLOT4" VARCHAR2(10 BYTE), 
	"EXP_SLOT5" VARCHAR2(10 BYTE), 
	"IMP_RKVAH" VARCHAR2(10 BYTE), 
	"EXP_RKVAH" VARCHAR2(10 BYTE), 
	"IMP_KVAH" VARCHAR2(10 BYTE), 
	"EXP_KVAH" VARCHAR2(10 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"IMP_MR_HEADER_ID" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE DEFAULT sysdate, 
	"INIT_READING_DT" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"REF_NO" VARCHAR2(100 BYTE), 
	"READING_DT" DATE, 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"CLEAN_REC" CHAR(1 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"IMPORT_ASIS" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_SELLERS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_SELLERS" 
   (	"GENERATOR_SERVICE_NO_OLD" VARCHAR2(100 BYTE), 
	"GENERATOR_SERVICE_NO_NEW" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(400 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"METER_MAKE" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(100 BYTE), 
	"IS_ABT" VARCHAR2(100 BYTE), 
	"IS_REC" VARCHAR2(100 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"ACCURACY_CLASS" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(1000 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_SELLERS_PART2
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_SELLERS_PART2" 
   (	"GENERATOR_SERVICE_NO_OLD" VARCHAR2(100 BYTE), 
	"GENERATOR_SERVICE_NO_NEW" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(400 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"METER_MAKE" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(100 BYTE), 
	"IS_ABT" VARCHAR2(100 BYTE), 
	"IS_REC" VARCHAR2(100 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"ACCURACY_CLASS" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_SELLERS_RECONCILIATION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_SELLERS_RECONCILIATION" 
   (	"GENERATOR_SERVICE_NO_OLD" VARCHAR2(100 BYTE), 
	"GENERATOR_SERVICE_NO_NEW" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(400 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"METER_MAKE" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(100 BYTE), 
	"IS_ABT" VARCHAR2(100 BYTE), 
	"IS_REC" VARCHAR2(100 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"ACCURACY_CLASS" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE), 
	"s_in_signup" VARCHAR2(100 BYTE), 
	"signup_id" VARCHAR2(100 BYTE), 
	"s_in_comp_serv" VARCHAR2(100 BYTE), 
	"m_comp_serv_id" VARCHAR2(100 BYTE), 
	"s_in_t_mr" VARCHAR2(100 BYTE), 
	"t_mr_id" VARCHAR2(100 BYTE), 
	"s_in_imp_mr" VARCHAR2(100 BYTE), 
	"s_in_amr" VARCHAR2(100 BYTE), 
	"sm_in_signup" VARCHAR2(100 BYTE), 
	"sm_in_comp_meter" VARCHAR2(100 BYTE), 
	"sm_in_t_mr" VARCHAR2(100 BYTE), 
	"sm_in_imp_mr" VARCHAR2(100 BYTE), 
	"sm_in_amr" VARCHAR2(100 BYTE), 
	"id" VARCHAR2(100 BYTE), 
	"S_IN_T_GS" VARCHAR2(100 BYTE), 
	"T_GS_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMPORT_TRADE_REL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMPORT_TRADE_REL" 
   (	"ID" VARCHAR2(200 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"SELLER_END_EDC" VARCHAR2(200 BYTE), 
	"SELLER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE_STR" VARCHAR2(25 BYTE), 
	"TO_DATE_STR" VARCHAR2(25 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"BUYER_END_EDC" VARCHAR2(200 BYTE), 
	"BUYER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(1000 BYTE), 
	"RESULT" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_BANKING_BALANCE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_BANKING_BALANCE" 
   (	"REMARKS" VARCHAR2(500 BYTE), 
	"GEN_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"CLEAN_REC" CHAR(1 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_MC_MR_HEADER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_MC_MR_HEADER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"IMPORT_DT" DATE, 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"STATUS" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"ERROR" VARCHAR2(500 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"TOTAL_COUNT" NUMBER, 
	"SUCCESS_COUNT" NUMBER, 
	"ERROR_COUNT" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_MC_MR_LINES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_MC_MR_LINES" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"IMP_MC_MR_HEADER_ID" VARCHAR2(50 BYTE), 
	"METER_NO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"SYS_DT" VARCHAR2(50 BYTE), 
	"INIT_READING_DT" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT" VARCHAR2(50 BYTE), 
	"IMP_INIT_S1" VARCHAR2(50 BYTE), 
	"IMP_INIT_S2" VARCHAR2(50 BYTE), 
	"IMP_INIT_S3" VARCHAR2(50 BYTE), 
	"IMP_INIT_S4" VARCHAR2(50 BYTE), 
	"IMP_INIT_S5" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(50 BYTE), 
	"EXP_INIT_S1" VARCHAR2(50 BYTE), 
	"EXP_INIT_S2" VARCHAR2(50 BYTE), 
	"EXP_INIT_S3" VARCHAR2(50 BYTE), 
	"EXP_INIT_S4" VARCHAR2(50 BYTE), 
	"EXP_INIT_S5" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"IMP_RKVAH_INIT" VARCHAR2(50 BYTE), 
	"IMP_RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"EXP_RKVAH_INIT" VARCHAR2(50 BYTE), 
	"EXP_RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(50 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(50 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(50 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(50 BYTE), 
	"REF_NO" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"IS_FIRST_ENTRY" VARCHAR2(20 BYTE) DEFAULT 'Y', 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"IMPORT_ASIS" CHAR(1 BYTE), 
	"IS_NEW_METER" CHAR(1 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_MR_HEADER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_MR_HEADER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"IMPORT_DT" DATE, 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"STATUS" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"ERROR" VARCHAR2(500 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"TOTAL_COUNT" NUMBER, 
	"SUCCESS_COUNT" NUMBER, 
	"ERROR_COUNT" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_MR_LINES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_MR_LINES" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"IMP_MR_HEADER_ID" VARCHAR2(50 BYTE), 
	"METER_NO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"SYS_DT" VARCHAR2(50 BYTE), 
	"INIT_READING_DT" VARCHAR2(50 BYTE), 
	"FINAL_READING_DT" VARCHAR2(50 BYTE), 
	"IMP_INIT_S1" VARCHAR2(50 BYTE), 
	"IMP_INIT_S2" VARCHAR2(50 BYTE), 
	"IMP_INIT_S3" VARCHAR2(50 BYTE), 
	"IMP_INIT_S4" VARCHAR2(50 BYTE), 
	"IMP_INIT_S5" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(50 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(50 BYTE), 
	"EXP_INIT_S1" VARCHAR2(50 BYTE), 
	"EXP_INIT_S2" VARCHAR2(50 BYTE), 
	"EXP_INIT_S3" VARCHAR2(50 BYTE), 
	"EXP_INIT_S4" VARCHAR2(50 BYTE), 
	"EXP_INIT_S5" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(50 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"IMP_RKVAH_INIT" VARCHAR2(50 BYTE), 
	"IMP_RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"EXP_RKVAH_INIT" VARCHAR2(50 BYTE), 
	"EXP_RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(50 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(50 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(50 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(50 BYTE), 
	"REF_NO" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"IS_FIRST_ENTRY" VARCHAR2(20 BYTE) DEFAULT 'Y', 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"IMPORT_ASIS" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_SUBSTATION_LOSS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_SUBSTATION_LOSS" 
   (	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ID" VARCHAR2(50 BYTE), 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"IS_IMPORTED" CHAR(1 BYTE), 
	"RESULT_DESC" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_TECHNICAL_DATA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_TECHNICAL_DATA" 
   (	"REMARKS" VARCHAR2(200 BYTE), 
	"M_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(100 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(1 BYTE), 
	"IS_REC" VARCHAR2(1 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE), 
	"M_COMPANY_ID" VARCHAR2(100 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"M_POWERPLANT_ID" VARCHAR2(100 BYTE), 
	"M_METER_ID_1" VARCHAR2(100 BYTE), 
	"METER1_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER1_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER1_MF" VARCHAR2(100 BYTE), 
	"METER1_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER1_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER1_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER1_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER1_IS_ABT" VARCHAR2(1 BYTE), 
	"METER1_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_2" VARCHAR2(100 BYTE), 
	"METER2_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER2_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER2_MF" VARCHAR2(100 BYTE), 
	"METER2_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER2_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER2_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER2_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER2_IS_ABT" VARCHAR2(1 BYTE), 
	"METER2_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_3" VARCHAR2(100 BYTE), 
	"METER3_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER3_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER3_MF" VARCHAR2(100 BYTE), 
	"METER3_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER3_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER3_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER3_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER3_IS_ABT" VARCHAR2(1 BYTE), 
	"METER3_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_4" VARCHAR2(100 BYTE), 
	"METER4_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER4_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER4_MF" VARCHAR2(100 BYTE), 
	"METER4_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER4_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER4_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER4_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER4_IS_ABT" VARCHAR2(1 BYTE), 
	"METER4_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_5" VARCHAR2(100 BYTE), 
	"METER5_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER5_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER5_MF" VARCHAR2(100 BYTE), 
	"METER5_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER5_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER5_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER5_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER5_IS_ABT" VARCHAR2(1 BYTE), 
	"METER5_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_METER_ID_6" VARCHAR2(100 BYTE), 
	"METER6_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER6_CT_RATIO" VARCHAR2(100 BYTE), 
	"METER6_MF" VARCHAR2(100 BYTE), 
	"METER6_METER_MAKE" VARCHAR2(100 BYTE), 
	"METER6_METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER6_METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER6_MODEM_NO" VARCHAR2(100 BYTE), 
	"METER6_IS_ABT" VARCHAR2(1 BYTE), 
	"METER6_ACCURACY_CLASS_CODE" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_1" VARCHAR2(100 BYTE), 
	"GEN1_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN1_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN1_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN1_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN1_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN1_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN1_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN1_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN1_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_2" VARCHAR2(100 BYTE), 
	"GEN2_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN2_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN2_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN2_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN2_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN2_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN2_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN2_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN2_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_3" VARCHAR2(100 BYTE), 
	"GEN3_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN3_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN3_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN3_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN3_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN3_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN3_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN3_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN3_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_4" VARCHAR2(100 BYTE), 
	"GEN4_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN4_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN4_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN4_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN4_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN4_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN4_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN4_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN4_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_5" VARCHAR2(100 BYTE), 
	"GEN5_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN5_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN5_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN5_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN5_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN5_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN5_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN5_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN5_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"M_GENERATOR_ID_6" VARCHAR2(100 BYTE), 
	"GEN6_GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN6_GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"GEN6_NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN6_GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"GEN6_INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"GEN6_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"GEN6_TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"GEN6_TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"GEN6_TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_TEMP1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_TEMP1" 
   (	"GENERATOR_SERVICE_NO_OLD" VARCHAR2(100 BYTE), 
	"GENERATOR_SERVICE_NO_NEW" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(400 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"METER_MAKE" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(100 BYTE), 
	"IS_ABT" VARCHAR2(100 BYTE), 
	"IS_REC" VARCHAR2(100 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"ACCURACY_CLASS" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_TEMP11
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_TEMP11" 
   (	"GENERATOR_SERVICE_NO_OLD" VARCHAR2(100 BYTE), 
	"GENERATOR_SERVICE_NO_NEW" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"EDC_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"GEN_MAKE_NAME_OA" VARCHAR2(100 BYTE), 
	"GEN_MAKE_CODE" VARCHAR2(100 BYTE), 
	"NO_OF_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY_KW" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(100 BYTE), 
	"SF_NO" VARCHAR2(400 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"SS_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FEEDER_NAME_IN_OA" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"METER_MAKE" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(100 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"IS_DLMS" VARCHAR2(100 BYTE), 
	"IS_ABT" VARCHAR2(100 BYTE), 
	"IS_REC" VARCHAR2(100 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE_STR" VARCHAR2(100 BYTE), 
	"ACCURACY_CLASS" VARCHAR2(100 BYTE), 
	"WIND_PASS_NAME" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"IMPORTED" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"WEG_GROUP_CODE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(200 BYTE), 
	"CLEAN_REC" VARCHAR2(1 BYTE), 
	"FUEL" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(20 BYTE), 
	"SURPLUS_ENERGY" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_TEMP2
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_TEMP2" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"SELLER_END_EDC" VARCHAR2(200 BYTE), 
	"SELLER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE_STR" VARCHAR2(25 BYTE), 
	"TO_DATE_STR" VARCHAR2(25 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"BUYER_END_EDC" VARCHAR2(200 BYTE), 
	"BUYER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_TEMP21
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_TEMP21" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"SELLER_END_EDC" VARCHAR2(200 BYTE), 
	"SELLER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE_STR" VARCHAR2(25 BYTE), 
	"TO_DATE_STR" VARCHAR2(25 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"BUYER_END_EDC" VARCHAR2(200 BYTE), 
	"BUYER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 6291456 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table IMP_WEG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."IMP_WEG" 
   (	"SNO" VARCHAR2(100 BYTE), 
	"ORG_NAME" VARCHAR2(100 BYTE), 
	"ORG_ID" VARCHAR2(100 BYTE), 
	"SS_NAME" VARCHAR2(100 BYTE), 
	"SS_ID" VARCHAR2(100 BYTE), 
	"SS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"WIND_PASS_DESC" VARCHAR2(100 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(100 BYTE), 
	"FEEDER_NAME" VARCHAR2(100 BYTE), 
	"FEEDER_ID" VARCHAR2(100 BYTE), 
	"FEEDER_TYPE_DESC" VARCHAR2(100 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"COD" VARCHAR2(100 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"IS_SINGLE" VARCHAR2(100 BYTE), 
	"NO_OF_UNITS" VARCHAR2(100 BYTE), 
	"GEN_UNIT_MAKE_DESC" VARCHAR2(100 BYTE), 
	"GEN_UNIT_CAPACITY" VARCHAR2(100 BYTE), 
	"DLMS" VARCHAR2(100 BYTE), 
	"METER_NO" VARCHAR2(100 BYTE), 
	"ACCURACY_CLASS_DESC" VARCHAR2(100 BYTE), 
	"ACCURACY_CODE" VARCHAR2(100 BYTE), 
	"FEEDER_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"FEEDER_VOLTAGE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" VARCHAR2(100 BYTE), 
	"TALUK_NAME" VARCHAR2(100 BYTE), 
	"TALUK_CODE" VARCHAR2(100 BYTE), 
	"DISTRICT_NAME" VARCHAR2(100 BYTE), 
	"DISTRICT_CODE" VARCHAR2(100 BYTE), 
	"STB_WHEELING" VARCHAR2(100 BYTE), 
	"OWN_CAPTIVE" VARCHAR2(100 BYTE), 
	"ORDER_NO" VARCHAR2(100 BYTE), 
	"SURPLUS_CODE_DESC" VARCHAR2(100 BYTE), 
	"SURPLUS_CODE" VARCHAR2(100 BYTE), 
	"AGREEMENT_TYPE" VARCHAR2(100 BYTE), 
	"AGREEMENT_DATE" VARCHAR2(100 BYTE), 
	"RATE" VARCHAR2(100 BYTE), 
	"SC_CODE" VARCHAR2(100 BYTE), 
	"SC_NO" VARCHAR2(100 BYTE), 
	"ACTUAL_DSC" VARCHAR2(100 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(100 BYTE), 
	"MISC" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_CHARGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_CHARGE" 
   (	"ID" VARCHAR2(100 BYTE), 
	"ENERGY_ADJUSTED_DATA_ID" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(20 BYTE), 
	"CHARGE_DESC" VARCHAR2(50 BYTE), 
	"CHARGE_AMOUNT" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_UNIT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_UNIT" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"ADJUSTED_C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_UNIT_01032021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01032021" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_UNIT_01052020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01052020" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_UNIT_031220
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_031220" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_UNIT_050421
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_050421" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_ADJUSTED_UNIT_220620
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_220620" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" VARCHAR2(300 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"ADJUSTED_C1" VARCHAR2(50 BYTE), 
	"ADJUSTED_C2" VARCHAR2(50 BYTE), 
	"ADJUSTED_C3" VARCHAR2(50 BYTE), 
	"ADJUSTED_C4" VARCHAR2(50 BYTE), 
	"ADJUSTED_C5" VARCHAR2(50 BYTE), 
	"IS_CLEAN" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_ID" VARCHAR2(50 BYTE), 
	"F_ENERGY_SALE_ORDER_LINE_ID" VARCHAR2(50 BYTE), 
	"RESULT_CODE" VARCHAR2(100 BYTE), 
	"RESULT_NAME" VARCHAR2(100 BYTE), 
	"SELLER_ORG_ID" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_DELETE_TXN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_DELETE_TXN" 
   (	"REMARKS" VARCHAR2(500 BYTE), 
	"GEN_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"DELETED_LEDGER" CHAR(1 BYTE), 
	"DELETED_ES" CHAR(1 BYTE), 
	"DELETED_GS" CHAR(1 BYTE), 
	"DELETED_MR" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE) DEFAULT 'admin', 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"DELETE_REMARKS" VARCHAR2(500 BYTE), 
	"PROCESSED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_METER_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_METER_CHANGE" 
   (	"ID" VARCHAR2(20 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"OLD_METER_NO" VARCHAR2(50 BYTE), 
	"NEW_METER_NO" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_UNITS" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_NET_UNITS" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IMP_C1_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C2_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C3_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C4_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C5_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C1_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C2_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C3_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C4_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C5_UNITS" VARCHAR2(50 BYTE), 
	"NET_C1_UNITS" VARCHAR2(50 BYTE), 
	"NET_C2_UNITS" VARCHAR2(50 BYTE), 
	"NET_C3_UNITS" VARCHAR2(50 BYTE), 
	"NET_C4_UNITS" VARCHAR2(50 BYTE), 
	"NET_C5_UNITS" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_SURPLUS_UNIT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_SURPLUS_UNIT" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"READING_DT" DATE, 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 13631488 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table INT_SURPLUS_UNIT_2
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" 
   (	"ID" VARCHAR2(200 BYTE), 
	"BATCH_KEY" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"SUPLR_TYPE" VARCHAR2(50 BYTE), 
	"READING_DT" DATE, 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"C24" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"SOURCE" VARCHAR2(100 BYTE) DEFAULT 'HT', 
	"IMPORTED" CHAR(1 BYTE), 
	"SUPLR_NAME" VARCHAR2(200 BYTE), 
	"DELETE_FLAG" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table JUST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."JUST" 
   (	"COLUMN1" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table KKI_12092020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."KKI_12092020" 
   (	"NAME_OF_THE_DEVELOPER" VARCHAR2(128 BYTE), 
	"CAPACITY" NUMBER(3,0), 
	"HT_SERVICE_NO" NUMBER(11,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table LOGGING_ERRORS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."LOGGING_ERRORS" 
   (	"COLUMN1" VARCHAR2(1000 BYTE), 
	"COLUMN2" DATE DEFAULT sysdate
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table MANUAL_GS_101SS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."MANUAL_GS_101SS" 
   (	"REMARKS" VARCHAR2(500 BYTE), 
	"GEN_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"SUBSTATION_ID" VARCHAR2(20 BYTE), 
	"ORG_ID" VARCHAR2(20 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"UPDATE_REMARKS" VARCHAR2(500 BYTE), 
	"PROCESSED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table MC_02_21
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."MC_02_21" 
   (	"SERVICENO" VARCHAR2(100 BYTE), 
	"OLDMETERNO" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table METER_CHANGE_LIST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."METER_CHANGE_LIST" 
   (	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"NEWMETER_NO" VARCHAR2(20 BYTE), 
	"MONTH" NUMBER, 
	"YEAR" NUMBER, 
	"OLDMETER_NO" VARCHAR2(50 BYTE), 
	"FLOW_TYPE" VARCHAR2(50 BYTE), 
	"FUEL" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table METER_NUMBER_UPDATION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."METER_NUMBER_UPDATION" 
   (	"CIRCLENAME" VARCHAR2(100 BYTE), 
	"CIRCLECODE" VARCHAR2(100 BYTE), 
	"SERVICENO" VARCHAR2(25 BYTE), 
	"METERNO" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table METER_NUMBER_UPDATION_1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."METER_NUMBER_UPDATION_1" 
   (	"METERNO" VARCHAR2(50 BYTE), 
	"SERVICENO" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table MISSING_INT_ADJ_UNITS_0306
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."MISSING_INT_ADJ_UNITS_0306" 
   (	"SERVICE_NO" VARCHAR2(20 BYTE), 
	"READING_MNTH" NUMBER, 
	"READING_YR" NUMBER, 
	"C1_TOT" NUMBER, 
	"C2_TOT" NUMBER, 
	"C3_TOT" NUMBER, 
	"C4_TOT" NUMBER, 
	"C5_TOT" NUMBER, 
	"C24_TOT" NUMBER, 
	"SUPLR_CODE" VARCHAR2(20 BYTE), 
	"SUPLR_TYPE" VARCHAR2(20 BYTE), 
	"SUR1_TOT" NUMBER, 
	"SUR2_TOT" NUMBER, 
	"SUR3_TOT" NUMBER, 
	"SUR4_TOT" NUMBER, 
	"SUR5_TOT" NUMBER, 
	"SUR24_TOT" NUMBER, 
	"READINGDT" VARCHAR2(100 BYTE), 
	"ES_STATUS" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_BANK
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_BANK" 
   (	"BANK_ID" VARCHAR2(20 BYTE), 
	"BANK_NAME" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(10 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(20 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IS_ENABLED" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_CHARGES_MAP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_CHARGES_MAP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CONTEXT" VARCHAR2(100 BYTE), 
	"M_CHARGE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FF" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_CHARGE_DEFN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_CHARGE_DEFN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"FORMULA" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"COMPANY_TYPE_CODE" VARCHAR2(50 BYTE), 
	"REGISTRATION_NO" VARCHAR2(50 BYTE), 
	"REGISTRATION_DATE" DATE, 
	"COB_DATE" DATE, 
	"INCORP_PLACE" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" VARCHAR2(25 BYTE), 
	"CAPTIVE_PURPOSE" VARCHAR2(100 BYTE), 
	"PAN" VARCHAR2(50 BYTE), 
	"TAN" VARCHAR2(50 BYTE), 
	"CST" VARCHAR2(50 BYTE), 
	"GST" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"TYPE" VARCHAR2(100 BYTE), 
	"IS_INTERNAL" CHAR(1 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IS_BUYER" CHAR(1 BYTE), 
	"IS_SELLER" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(200 BYTE), 
	"CIN" VARCHAR2(50 BYTE), 
	"LLPIN" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_EMPLOYEE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_EMPLOYEE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"PURPOSE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"EMPLOYEE_NO" VARCHAR2(50 BYTE), 
	"DESIGNATIONCODE" VARCHAR2(50 BYTE), 
	"LANDLINE" VARCHAR2(50 BYTE), 
	"MOBILE" VARCHAR2(50 BYTE), 
	"FAX" VARCHAR2(50 BYTE), 
	"EMAIL" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_LOCATION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_LOCATION" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"TYPE" VARCHAR2(50 BYTE), 
	"LINE1" VARCHAR2(100 BYTE), 
	"CITY" VARCHAR2(50 BYTE), 
	"DISTRICTCODE" VARCHAR2(50 BYTE), 
	"STATECODE" VARCHAR2(50 BYTE), 
	"PINCODE" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_METER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_METER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"ACCURACY_CLASS_CODE" VARCHAR2(50 BYTE), 
	"IS_ABTMETER" CHAR(1 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"MODEM_NUMBER" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"METER_CT1" VARCHAR2(50 BYTE), 
	"METER_CT2" VARCHAR2(50 BYTE), 
	"METER_CT3" VARCHAR2(50 BYTE), 
	"METER_PT1" VARCHAR2(50 BYTE), 
	"METER_PT2" VARCHAR2(50 BYTE), 
	"METER_PT3" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"CT_RATIO" VARCHAR2(100 BYTE), 
	"PT_RATIO" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_SERVICE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_SERVICE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"TYPE_OF_SHARE" VARCHAR2(50 BYTE), 
	"INSTALLED_BY" VARCHAR2(50 BYTE), 
	"M_SECTION_ID" VARCHAR2(50 BYTE), 
	"M_SECTION_NAME" VARCHAR2(100 BYTE), 
	"M_SECTION_CODE" VARCHAR2(100 BYTE), 
	"SOLAR_CHARGES" VARCHAR2(20 BYTE), 
	"CONTACT_FULL_NAME" VARCHAR2(200 BYTE), 
	"CONTACT_DESIGNATION" VARCHAR2(200 BYTE), 
	"CONTACT_EMAIL" VARCHAR2(200 BYTE), 
	"CONTACT_PHONE_NO" VARCHAR2(20 BYTE), 
	"REG_OFFICE_ADDR" VARCHAR2(1000 BYTE), 
	"PLANT_ADDR" VARCHAR2(1000 BYTE), 
	"IS_CONTACT_VERIFIED" VARCHAR2(10 BYTE), 
	"CONTACT_LAST_VERIFIED_DATE" DATE, 
	"BANK_IFSC_CODE" VARCHAR2(100 BYTE), 
	"BANK_NAME" VARCHAR2(200 BYTE), 
	"BANK_ACCOUNT_NO" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_SERVICE2708
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_SERVICE2708" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 327680 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_SERVICE_02JAN2020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_SERVICE_02JAN2020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"TYPE_OF_SHARE" VARCHAR2(50 BYTE), 
	"INSTALLED_BY" VARCHAR2(50 BYTE), 
	"M_SECTION_ID" VARCHAR2(100 BYTE), 
	"M_SECTION_NAME" VARCHAR2(2 BYTE), 
	"M_SECTION_CODE" VARCHAR2(2 BYTE), 
	"SOLAR_CHARGES" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_SERVICE_1219
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_SERVICE_1219" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"TYPE_OF_SHARE" VARCHAR2(50 BYTE), 
	"INSTALLED_BY" VARCHAR2(50 BYTE), 
	"M_SECTION_ID" VARCHAR2(100 BYTE), 
	"M_SECTION_NAME" VARCHAR2(2 BYTE), 
	"M_SECTION_CODE" VARCHAR2(2 BYTE), 
	"SOLAR_CHARGES" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_SERVICE_THERMALDELETED
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_SERVICE_THERMALDELETED" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"TYPE_OF_SHARE" VARCHAR2(50 BYTE), 
	"INSTALLED_BY" VARCHAR2(50 BYTE), 
	"M_SECTION_ID" VARCHAR2(50 BYTE), 
	"M_SECTION_NAME" VARCHAR2(100 BYTE), 
	"M_SECTION_CODE" VARCHAR2(100 BYTE), 
	"SOLAR_CHARGES" VARCHAR2(20 BYTE), 
	"CONTACT_FULL_NAME" VARCHAR2(200 BYTE), 
	"CONTACT_DESIGNATION" VARCHAR2(200 BYTE), 
	"CONTACT_EMAIL" VARCHAR2(200 BYTE), 
	"CONTACT_PHONE_NO" VARCHAR2(20 BYTE), 
	"REG_OFFICE_ADDR" VARCHAR2(1000 BYTE), 
	"PLANT_ADDR" VARCHAR2(1000 BYTE), 
	"IS_CONTACT_VERIFIED" VARCHAR2(10 BYTE), 
	"CONTACT_LAST_VERIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_COMPANY_SHAREHOLDER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_COMPANY_SHAREHOLDER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SHAREHOLDER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"share" VARCHAR2(25 BYTE), 
	"MEASURE" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"QUANTUM" VARCHAR2(100 BYTE), 
	"M_SHAREHOLDER_COMP_SERV_ID" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_CORR_SS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_CORR_SS" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_EXCESS_UNIT_TYPE_OVERRIDE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_EXCESS_UNIT_TYPE_OVERRIDE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"EXCESS_UNIT_TYPE" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(500 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"REMARKS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_FEEDER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_FEEDER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"VOLTAGE" VARCHAR2(25 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"SS_NAME" VARCHAR2(200 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"VOLTAGE_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_FUEL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_FUEL" 
   (	"ID" VARCHAR2(20 BYTE), 
	"FUEL_CODE" VARCHAR2(150 BYTE), 
	"FUEL_NAME" VARCHAR2(150 BYTE), 
	"FUEL_GROUP" VARCHAR2(150 BYTE), 
	"CREATED_BY" VARCHAR2(150 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(150 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IS_ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_GENERATOR
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_GENERATOR" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_POWERPLANT_ID" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"MAKE_CODE" VARCHAR2(50 BYTE), 
	"SERIAL_NO" VARCHAR2(1000 BYTE), 
	"ROTOR_DIA" VARCHAR2(25 BYTE), 
	"HUB_HEIGHT" VARCHAR2(25 BYTE), 
	"CAPACITY" VARCHAR2(25 BYTE), 
	"REFERENCE_ID" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(25 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"NO_OF_UNITS" VARCHAR2(25 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_LOSS_CALC_CHART
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_LOSS_CALC_CHART" 
   (	"ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE_CODE" VARCHAR2(100 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(100 BYTE), 
	"TRANS_LOSS_PERCENT" VARCHAR2(100 BYTE), 
	"DIST_LOSS_PERCENT" VARCHAR2(100 BYTE), 
	"TOTAL_LOSS_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_LOV_DETAIL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_LOV_DETAIL" 
   (	"M_LOV_CODE" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"VALUE_DESC" VARCHAR2(200 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"ATTRIB1" VARCHAR2(25 BYTE), 
	"ATTRIB2" VARCHAR2(25 BYTE), 
	"ATTRIB3" VARCHAR2(25 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_LOV_HEADER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_LOV_HEADER" 
   (	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_ORG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_ORG" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"TYPE_CODE" VARCHAR2(50 BYTE), 
	"PARENT_CODE" VARCHAR2(50 BYTE), 
	"ADDRESS" VARCHAR2(200 BYTE), 
	"LANDLINE" VARCHAR2(25 BYTE), 
	"MOBILE" VARCHAR2(25 BYTE), 
	"EMAIL" VARCHAR2(25 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"NCES_DIVISION_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_POWERPLANT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_POWERPLANT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"IS_PRIMARY" CHAR(1 BYTE), 
	"VERSION" NUMBER(2,0), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"PLANT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"M_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"T_GRID_CONN_APPLN_ID" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(25 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"INTERFACE_VOLTAGE_PHASE" VARCHAR2(25 BYTE), 
	"INTERFACE_VOLTAGE_FREQUENCY" VARCHAR2(25 BYTE), 
	"COMMISSION_DATE" DATE, 
	"PURPOSE" VARCHAR2(500 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"STATUS" VARCHAR2(25 BYTE), 
	"LINE1" VARCHAR2(500 BYTE), 
	"CITY" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"PINCODE" VARCHAR2(50 BYTE), 
	"VILLAGE" VARCHAR2(200 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"PLS_SF_NO" VARCHAR2(50 BYTE), 
	"PL_VILLAGE" VARCHAR2(200 BYTE), 
	"PL_TOWN" VARCHAR2(50 BYTE), 
	"PL_TALUK_CODE" VARCHAR2(50 BYTE), 
	"PL_DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"WIND_ZONE_AREA_CODE" VARCHAR2(50 BYTE), 
	"APPLICATION_DT" DATE, 
	"APPROVAL_DT" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"AD_BENEFITS" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_POWERPLANT_181120
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_POWERPLANT_181120" 
   (	"ID" VARCHAR2(50 BYTE), 
	"IS_PRIMARY" CHAR(1 BYTE), 
	"VERSION" NUMBER(2,0), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"PLANT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"M_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"T_GRID_CONN_APPLN_ID" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(25 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"INTERFACE_VOLTAGE_PHASE" VARCHAR2(25 BYTE), 
	"INTERFACE_VOLTAGE_FREQUENCY" VARCHAR2(25 BYTE), 
	"COMMISSION_DATE" DATE, 
	"PURPOSE" VARCHAR2(500 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"STATUS" VARCHAR2(25 BYTE), 
	"LINE1" VARCHAR2(500 BYTE), 
	"CITY" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"PINCODE" VARCHAR2(50 BYTE), 
	"VILLAGE" VARCHAR2(200 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"PLS_SF_NO" VARCHAR2(50 BYTE), 
	"PL_VILLAGE" VARCHAR2(200 BYTE), 
	"PL_TOWN" VARCHAR2(50 BYTE), 
	"PL_TALUK_CODE" VARCHAR2(50 BYTE), 
	"PL_DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"WIND_ZONE_AREA_CODE" VARCHAR2(50 BYTE), 
	"APPLICATION_DT" DATE, 
	"APPROVAL_DT" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"AD_BENEFITS" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SECTION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SECTION" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SECTION_NAME" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"PARENT_CODE" VARCHAR2(100 BYTE), 
	"ENABLED" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_DATE" DATE, 
	"SECTION_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SIGNUP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SIGNUP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(50 BYTE), 
	"REGISTRATION_NO" VARCHAR2(50 BYTE), 
	"REGISTRATION_DATE" DATE, 
	"COMMISSION_DATE" DATE, 
	"VOLTAGE" VARCHAR2(50 BYTE), 
	"HTSC_NUMBER_OLD" VARCHAR2(100 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"SANCTIONED_QUANTUM" VARCHAR2(25 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(25 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"USER_NAME" VARCHAR2(100 BYTE), 
	"USER_ID" VARCHAR2(100 BYTE), 
	"PASSWORD" VARCHAR2(100 BYTE), 
	"POWERPLANT_TYPE" VARCHAR2(50 BYTE), 
	"POWERPLANT_NAME" VARCHAR2(100 BYTE), 
	"FUEL" VARCHAR2(50 BYTE), 
	"NO_OF_GENERATOR" NUMBER(2,0), 
	"GENERATOR_TYPE" VARCHAR2(50 BYTE), 
	"GENERATOR_MODEL" VARCHAR2(50 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"LOCATION" VARCHAR2(500 BYTE), 
	"ADDRESS_LINE" VARCHAR2(500 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"CITY" VARCHAR2(100 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"IS_COMPLETE" CHAR(1 BYTE), 
	"COMPANY_ADDRESS" VARCHAR2(1000 BYTE), 
	"APPROVAL_DT" DATE, 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(50 BYTE), 
	"BUYER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"GENERATOR_CAPACITY" VARCHAR2(20 BYTE), 
	"METER_NUMBER" VARCHAR2(50 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"ACCURACY_CLASS_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_ABT_METER" CHAR(1 BYTE), 
	"MULTIPLICATION_FACTOR" VARCHAR2(20 BYTE), 
	"APPLICATION_DT" DATE, 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CONSUMER_HT_NUMBER" VARCHAR2(50 BYTE), 
	"TRADE_START_DATE" DATE, 
	"TRADE_END_DATE" DATE, 
	"TRADER_SERVICE_ID" VARCHAR2(50 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"GU_MODEL1" VARCHAR2(100 BYTE), 
	"GU_CAPACITY1" VARCHAR2(100 BYTE), 
	"NO_OF_GU1" VARCHAR2(100 BYTE), 
	"GU_MODEL2" VARCHAR2(100 BYTE), 
	"GU_CAPACITY2" VARCHAR2(100 BYTE), 
	"NO_OF_GU2" VARCHAR2(100 BYTE), 
	"GU_MODEL3" VARCHAR2(100 BYTE), 
	"GU_CAPACITY3" VARCHAR2(100 BYTE), 
	"NO_OF_GU3" VARCHAR2(100 BYTE), 
	"GU_MODEL4" VARCHAR2(100 BYTE), 
	"GU_CAPACITY4" VARCHAR2(100 BYTE), 
	"NO_OF_GU4" VARCHAR2(100 BYTE), 
	"GU_MODEL5" VARCHAR2(100 BYTE), 
	"GU_CAPACITY5" VARCHAR2(100 BYTE), 
	"NO_OF_GU5" VARCHAR2(100 BYTE), 
	"GU_MODEL6" VARCHAR2(100 BYTE), 
	"GU_CAPACITY6" VARCHAR2(100 BYTE), 
	"NO_OF_GU6" VARCHAR2(100 BYTE), 
	"METER_CT_1" VARCHAR2(100 BYTE), 
	"METER_CT_2" VARCHAR2(100 BYTE), 
	"METER_CT_3" VARCHAR2(100 BYTE), 
	"METER_BT_1" VARCHAR2(100 BYTE), 
	"METER_BT_2" VARCHAR2(100 BYTE), 
	"METER_BT_3" VARCHAR2(100 BYTE), 
	"SURPLUS_ENERGY_CODE" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"TOTAL_GENERATOR_UNIT" VARCHAR2(50 BYTE), 
	"METER_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER_CT_RATIO" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"IS_DLMS_METER" VARCHAR2(50 BYTE), 
	"HTSC_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" CHAR(1 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SIGNUP_ARKAYENERGY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SIGNUP_ARKAYENERGY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"PURPOSE" VARCHAR2(50 BYTE), 
	"REGISTRATION_NO" VARCHAR2(50 BYTE), 
	"REGISTRATION_DATE" DATE, 
	"COMMISSION_DATE" DATE, 
	"VOLTAGE" VARCHAR2(50 BYTE), 
	"HTSC_NUMBER_OLD" VARCHAR2(100 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"SANCTIONED_QUANTUM" VARCHAR2(25 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(25 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"USER_NAME" VARCHAR2(100 BYTE), 
	"USER_ID" VARCHAR2(100 BYTE), 
	"PASSWORD" VARCHAR2(100 BYTE), 
	"POWERPLANT_TYPE" VARCHAR2(50 BYTE), 
	"POWERPLANT_NAME" VARCHAR2(100 BYTE), 
	"FUEL" VARCHAR2(50 BYTE), 
	"NO_OF_GENERATOR" NUMBER(2,0), 
	"GENERATOR_TYPE" VARCHAR2(50 BYTE), 
	"GENERATOR_MODEL" VARCHAR2(50 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"LOCATION" VARCHAR2(500 BYTE), 
	"ADDRESS_LINE" VARCHAR2(500 BYTE), 
	"VILLAGE" VARCHAR2(100 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"CITY" VARCHAR2(100 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"IS_COMPLETE" CHAR(1 BYTE), 
	"COMPANY_ADDRESS" VARCHAR2(1000 BYTE), 
	"APPROVAL_DT" DATE, 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(50 BYTE), 
	"BUYER_TYPE_CODE" VARCHAR2(50 BYTE), 
	"GENERATOR_CAPACITY" VARCHAR2(20 BYTE), 
	"METER_NUMBER" VARCHAR2(50 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"ACCURACY_CLASS_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IS_ABT_METER" CHAR(1 BYTE), 
	"MULTIPLICATION_FACTOR" VARCHAR2(20 BYTE), 
	"APPLICATION_DT" DATE, 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CONSUMER_HT_NUMBER" VARCHAR2(50 BYTE), 
	"TRADE_START_DATE" DATE, 
	"TRADE_END_DATE" DATE, 
	"TRADER_SERVICE_ID" VARCHAR2(50 BYTE), 
	"MODEM_NO" VARCHAR2(100 BYTE), 
	"GU_MODEL1" VARCHAR2(100 BYTE), 
	"GU_CAPACITY1" VARCHAR2(100 BYTE), 
	"NO_OF_GU1" VARCHAR2(100 BYTE), 
	"GU_MODEL2" VARCHAR2(100 BYTE), 
	"GU_CAPACITY2" VARCHAR2(100 BYTE), 
	"NO_OF_GU2" VARCHAR2(100 BYTE), 
	"GU_MODEL3" VARCHAR2(100 BYTE), 
	"GU_CAPACITY3" VARCHAR2(100 BYTE), 
	"NO_OF_GU3" VARCHAR2(100 BYTE), 
	"GU_MODEL4" VARCHAR2(100 BYTE), 
	"GU_CAPACITY4" VARCHAR2(100 BYTE), 
	"NO_OF_GU4" VARCHAR2(100 BYTE), 
	"GU_MODEL5" VARCHAR2(100 BYTE), 
	"GU_CAPACITY5" VARCHAR2(100 BYTE), 
	"NO_OF_GU5" VARCHAR2(100 BYTE), 
	"GU_MODEL6" VARCHAR2(100 BYTE), 
	"GU_CAPACITY6" VARCHAR2(100 BYTE), 
	"NO_OF_GU6" VARCHAR2(100 BYTE), 
	"METER_CT_1" VARCHAR2(100 BYTE), 
	"METER_CT_2" VARCHAR2(100 BYTE), 
	"METER_CT_3" VARCHAR2(100 BYTE), 
	"METER_BT_1" VARCHAR2(100 BYTE), 
	"METER_BT_2" VARCHAR2(100 BYTE), 
	"METER_BT_3" VARCHAR2(100 BYTE), 
	"SURPLUS_ENERGY_CODE" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"TOTAL_GENERATOR_UNIT" VARCHAR2(50 BYTE), 
	"METER_PT_RATIO" VARCHAR2(100 BYTE), 
	"METER_CT_RATIO" VARCHAR2(100 BYTE), 
	"TURBINE_SL_NO" VARCHAR2(100 BYTE), 
	"TURBINE_ROTOR_DIA" VARCHAR2(100 BYTE), 
	"TURBINE_HUB_HEIGHT" VARCHAR2(100 BYTE), 
	"IS_DLMS_METER" VARCHAR2(50 BYTE), 
	"HTSC_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ACCELERATED_DEPRECIATION" CHAR(1 BYTE), 
	"NATURE_OF_BOARD" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SIGNUP_TRADE_REL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SIGNUP_TRADE_REL" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SUBSTATION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SUBSTATION" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"TYPE_OF_SS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SUBS_A
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SUBS_A" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_SUBS_COPY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_SUBS_COPY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TARIFF
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TARIFF" 
   (	"ID" VARCHAR2(50 BYTE), 
	"TYPE" VARCHAR2(20 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"WEG_GROUP_CODE" VARCHAR2(20 BYTE), 
	"RATE" VARCHAR2(20 BYTE), 
	"REFERENCE" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TARIFF_BKP02042019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TARIFF_BKP02042019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"TYPE" VARCHAR2(20 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"WEG_GROUP_CODE" VARCHAR2(20 BYTE), 
	"RATE" VARCHAR2(20 BYTE), 
	"REFERENCE" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TARIFF_REPORT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TARIFF_REPORT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"TYPE" VARCHAR2(20 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"WEG_GROUP_CODE" VARCHAR2(20 BYTE), 
	"RATE" VARCHAR2(20 BYTE), 
	"REFERENCE" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"WEG_GROUP_NAME" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TRADE_RELATIONSHIP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SELLER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REFERENCENUMBER" VARCHAR2(200 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"TRADE_RELATIONSHIP_SOURCE_CODE" VARCHAR2(50 BYTE) DEFAULT 'OAA', 
	"AGREEMENT_TYPE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TRADE_RELATIONSHIP_05102020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_05102020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SELLER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REFERENCENUMBER" VARCHAR2(200 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"TRADE_RELATIONSHIP_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_TYPE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TRADE_RELATIONSHIP_1686_062020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_1686_062020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SELLER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REFERENCENUMBER" VARCHAR2(200 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"TRADE_RELATIONSHIP_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_TYPE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TRADE_RELATIONSHIP_OPG110UNIT1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_OPG110UNIT1" 
   (	"ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SELLER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REFERENCENUMBER" VARCHAR2(200 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"TRADE_RELATIONSHIP_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_TYPE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_TRADE_RELATIOSHIP_28022021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_TRADE_RELATIOSHIP_28022021" 
   (	"ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SELLER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REFERENCENUMBER" VARCHAR2(200 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"TRADE_RELATIONSHIP_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_TYPE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table M_USER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."M_USER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"FIRST_NAME" VARCHAR2(50 BYTE), 
	"LAST_NAME" VARCHAR2(50 BYTE), 
	"TYPE" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"IS_SUPER_USER" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table NAME_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."NAME_CHANGE" 
   (	"SERVICENO" VARCHAR2(20 BYTE), 
	"EXISITING_NAME" VARCHAR2(100 BYTE), 
	"NEW_NAME" VARCHAR2(100 BYTE), 
	"PR_NO" VARCHAR2(20 BYTE), 
	"PR_NO_DATE" DATE, 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table NEW_TEST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."NEW_TEST" 
   (	"SERVICE_NO" VARCHAR2(20 CHAR), 
	"READING_MNTH" NUMBER, 
	"READING_YR" NUMBER, 
	"C1_TOT" NUMBER, 
	"C2_TOT" NUMBER, 
	"C3_TOT" NUMBER, 
	"C4_TOT" NUMBER, 
	"C5_TOT" NUMBER, 
	"C24_TOT" NUMBER, 
	"SUPLR_CODE" VARCHAR2(20 CHAR), 
	"SUPLR_TYPE" VARCHAR2(20 CHAR), 
	"SUR1_TOT" NUMBER, 
	"SUR2_TOT" NUMBER, 
	"SUR3_TOT" NUMBER, 
	"SUR4_TOT" NUMBER, 
	"SUR5_TOT" NUMBER, 
	"SUR24_TOT" NUMBER, 
	"READINGDT" VARCHAR2(100 CHAR)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table OALIST_25022020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."OALIST_25022020" 
   (	"CIRCLECODE" NUMBER(5,0), 
	"SERVICENO" VARCHAR2(26 BYTE), 
	"METERNO" VARCHAR2(26 BYTE), 
	"IN_AMR" VARCHAR2(1 BYTE), 
	"REMARKS" VARCHAR2(25 BYTE), 
	"READING_MONTH" NUMBER(1,0), 
	"READING_YEAR" NUMBER(4,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table OA_HT_CHARGES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."OA_HT_CHARGES" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SELLER_SERV_NUM" VARCHAR2(50 BYTE), 
	"SELLER_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_SERV_NUM" VARCHAR2(50 BYTE), 
	"BUYER_SERV_ID" VARCHAR2(50 BYTE), 
	"C001" VARCHAR2(50 BYTE), 
	"HT_C001" VARCHAR2(50 BYTE), 
	"C002" VARCHAR2(50 BYTE), 
	"HT_C002" VARCHAR2(50 BYTE), 
	"C003" VARCHAR2(50 BYTE), 
	"HT_C003" VARCHAR2(50 BYTE), 
	"C004" VARCHAR2(50 BYTE), 
	"HT_C004" VARCHAR2(50 BYTE), 
	"C005" VARCHAR2(50 BYTE), 
	"HT_C005" VARCHAR2(50 BYTE), 
	"C006" VARCHAR2(50 BYTE), 
	"HT_C006" VARCHAR2(50 BYTE), 
	"C007" VARCHAR2(50 BYTE), 
	"HT_C007" VARCHAR2(50 BYTE), 
	"SUM" VARCHAR2(50 BYTE), 
	"HT_SUM" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table OA_MANUAL_26022020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."OA_MANUAL_26022020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(150 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"TYPE_OF_SHARE" VARCHAR2(50 BYTE), 
	"INSTALLED_BY" VARCHAR2(50 BYTE), 
	"M_SECTION_ID" VARCHAR2(100 BYTE), 
	"M_SECTION_NAME" VARCHAR2(2 BYTE), 
	"M_SECTION_CODE" VARCHAR2(2 BYTE), 
	"SOLAR_CHARGES" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table OA_NOTKNOWN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."OA_NOTKNOWN" 
   (	"METERNO" VARCHAR2(26 BYTE), 
	"SYSTEMRTC" VARCHAR2(10 BYTE), 
	"METERRTC" VARCHAR2(10 BYTE), 
	"CIRCLENAME" VARCHAR2(16 BYTE), 
	"SECTIONNAME" VARCHAR2(18 BYTE), 
	"SUBSTATIONNAME" VARCHAR2(30 BYTE), 
	"SERVICENO" VARCHAR2(26 BYTE), 
	"SERVICECODE" VARCHAR2(14 BYTE), 
	"METERMAKENAME" VARCHAR2(6 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table OLYMPIC_MEDAL_WINNERS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."OLYMPIC_MEDAL_WINNERS" 
   (	"OLYMPIC_YEAR" NUMBER(*,0), 
	"SPORT" VARCHAR2(30 BYTE), 
	"GENDER" VARCHAR2(1 BYTE), 
	"EVENT" VARCHAR2(128 BYTE), 
	"MEDAL" VARCHAR2(10 BYTE), 
	"NOC" VARCHAR2(3 BYTE), 
	"ATHLETE" VARCHAR2(128 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table PROGRESS_REPORT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."PROGRESS_REPORT" 
   (	"ID" VARCHAR2(20 BYTE), 
	"TOTAL_SERVICES" NUMBER, 
	"VALID_CAPTIVE_SERVICES" NUMBER, 
	"VALID_STB_SERVICES" NUMBER, 
	"VALID_WEG_THIRD_PARTY_SERVICES" NUMBER, 
	"TOTAL_INVALID_SERVICES" NUMBER, 
	"INVALID_CAPTIVE_SERVICES" NUMBER, 
	"INVALID_STB_SERVICES" NUMBER, 
	"INVALID_WEG_THIRD_PARTY_SERVICES" NUMBER, 
	"TOTAL_STATEMENTS" NUMBER, 
	"CAPTIVE_STATEMENTS" NUMBER, 
	"STB_STATEMENTS" NUMBER, 
	"WEG_THIRD_PARTY_STATEMENTS" NUMBER, 
	"ALLOTMENTS_CREATED" NUMBER, 
	"ALLOTMENTS_COMPLETED" NUMBER, 
	"METER_READINGS_DOWNLOADED" NUMBER, 
	"MANUAL_MR_READING" NUMBER, 
	"CREATED_DATE" DATE, 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"MODIFIED_DATE" DATE, 
	"TYPE" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_IS_CAPTIVE" NUMBER, 
	"TOTAL_EXPORT_IS_CAPTIVE" NUMBER, 
	"NET_GENERATION_IS_CAPTIVE" NUMBER, 
	"TOTAL_IMPORT_STB" NUMBER, 
	"TOTAL_EXPORT_STB" NUMBER, 
	"NET_GENERATION_STB" NUMBER, 
	"TOTAL_IMPORT_THIRD_PARTY" NUMBER, 
	"TOTAL_EXPORT_THIRD_PARTY" NUMBER, 
	"NET_GENERATION_THIRD_PARTY" NUMBER, 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_NAME" VARCHAR2(50 BYTE), 
	"BANKED_UNITS" NUMBER, 
	"TOTAL_VALID_SERVICES" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table REMC_VIEW
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."REMC_VIEW" 
   (	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"COMPANY_NAME" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"GENERATOR_CAPACITY" VARCHAR2(50 BYTE), 
	"IMPORT_GENERATION" VARCHAR2(50 BYTE), 
	"EXPORT_GENERATION" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"FUEL_TYPE" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table RESOURCE_TIMESHEET
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."RESOURCE_TIMESHEET" 
   (	"SOURCE_NAME" VARCHAR2(50 BYTE), 
	"TIMESHEET_DATE" DATE, 
	"WEEK" NUMBER, 
	"DAY" VARCHAR2(10 BYTE), 
	"CUSTOMERS" VARCHAR2(50 BYTE), 
	"ACTIVITY" VARCHAR2(30 BYTE), 
	"SERVICE_CODE" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_DISC_F_ENERGY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_DISC_F_ENERGY" 
   (	"READING_DT" DATE, 
	"CREATED_DT" DATE, 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"SUPLR_CODE" VARCHAR2(50 BYTE), 
	"OA_C1" VARCHAR2(50 BYTE), 
	"OA_C2" VARCHAR2(50 BYTE), 
	"OA_C3" VARCHAR2(50 BYTE), 
	"OA_C4" VARCHAR2(50 BYTE), 
	"OA_C5" VARCHAR2(50 BYTE), 
	"HT_C1" VARCHAR2(50 BYTE), 
	"HT_C2" VARCHAR2(50 BYTE), 
	"HT_C3" VARCHAR2(50 BYTE), 
	"HT_C4" VARCHAR2(50 BYTE), 
	"HT_C5" VARCHAR2(50 BYTE), 
	"D_C1" NUMBER, 
	"D_C2" NUMBER, 
	"D_C3" NUMBER, 
	"D_C4" NUMBER, 
	"D_C5" NUMBER, 
	"TOT_D_SURP" NUMBER, 
	"TOT_D_ADJ" NUMBER, 
	"D_ADJ_C1" NUMBER, 
	"D_ADJ_C2" NUMBER, 
	"D_ADJ_C3" NUMBER, 
	"D_ADJ_C4" NUMBER, 
	"D_ADJ_C5" NUMBER, 
	"VALIDL" VARCHAR2(2 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_DISC_INT_ADJ
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_DISC_INT_ADJ" 
   (	"READING_DT" DATE, 
	"CREATED_DT" DATE, 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"SUPLR_CODE" VARCHAR2(50 BYTE), 
	"OA_C1" VARCHAR2(50 BYTE), 
	"OA_C2" VARCHAR2(50 BYTE), 
	"OA_C3" VARCHAR2(50 BYTE), 
	"OA_C4" VARCHAR2(50 BYTE), 
	"OA_C5" VARCHAR2(50 BYTE), 
	"HT_C1" VARCHAR2(50 BYTE), 
	"HT_C2" VARCHAR2(50 BYTE), 
	"HT_C3" VARCHAR2(50 BYTE), 
	"HT_C4" VARCHAR2(50 BYTE), 
	"HT_C5" VARCHAR2(50 BYTE), 
	"D_C1" NUMBER, 
	"D_C2" NUMBER, 
	"D_C3" NUMBER, 
	"D_C4" NUMBER, 
	"D_C5" NUMBER, 
	"TOT_D_SURP" NUMBER, 
	"TOT_D_ADJ" NUMBER, 
	"D_ADJ_C1" NUMBER, 
	"D_ADJ_C2" NUMBER, 
	"D_ADJ_C3" NUMBER, 
	"D_ADJ_C4" NUMBER, 
	"D_ADJ_C5" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_ENERGY_ADJUSTMENT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_ENERGY_ADJUSTMENT" 
   (	"ID" VARCHAR2(200 BYTE), 
	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER, 
	"REMARKS" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_F_ENERGY_042020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_F_ENERGY_042020" 
   (	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"C1_WITHLOSS" NUMBER, 
	"C2_WITHLOSS" NUMBER, 
	"C3_WITHLOSS" NUMBER, 
	"C4_WITHLOSS" NUMBER, 
	"C5_WITHLOSS" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_GEN_SUMMARY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_GEN_SUMMARY" 
   (	"ID" VARCHAR2(20 BYTE), 
	"REP_TYPE" VARCHAR2(50 BYTE), 
	"ORG_NAME" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"TOTAL_SELLER_COUNT" VARCHAR2(20 BYTE), 
	"BILLED_SELLER_COUNT" VARCHAR2(20 BYTE), 
	"CAPTIVE_TPP_COUNT" VARCHAR2(20 BYTE), 
	"TOTAL_COUNT" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_INT_MC_HIS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_INT_MC_HIS" 
   (	"ID" VARCHAR2(20 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"OLD_METER_NO" VARCHAR2(50 BYTE), 
	"NEW_METER_NO" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_UNITS" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_NET_UNITS" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IMP_C1_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C2_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C3_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C4_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C5_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C1_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C2_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C3_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C4_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C5_UNITS" VARCHAR2(50 BYTE), 
	"NET_C1_UNITS" VARCHAR2(50 BYTE), 
	"NET_C2_UNITS" VARCHAR2(50 BYTE), 
	"NET_C3_UNITS" VARCHAR2(50 BYTE), 
	"NET_C4_UNITS" VARCHAR2(50 BYTE), 
	"NET_C5_UNITS" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_INT_METER_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_INT_METER_CHANGE" 
   (	"ID" VARCHAR2(20 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"OLD_METER_NO" VARCHAR2(50 BYTE), 
	"NEW_METER_NO" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_UNITS" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_NET_UNITS" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IMP_C1_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C2_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C3_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C4_UNITS" VARCHAR2(50 BYTE), 
	"IMP_C5_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C1_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C2_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C3_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C4_UNITS" VARCHAR2(50 BYTE), 
	"EXP_C5_UNITS" VARCHAR2(50 BYTE), 
	"NET_C1_UNITS" VARCHAR2(50 BYTE), 
	"NET_C2_UNITS" VARCHAR2(50 BYTE), 
	"NET_C3_UNITS" VARCHAR2(50 BYTE), 
	"NET_C4_UNITS" VARCHAR2(50 BYTE), 
	"NET_C5_UNITS" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_MC_HIS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_MC_HIS" 
   (	"READING_DATE" DATE, 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"IKWHC1" VARCHAR2(50 BYTE), 
	"IKWHC2" VARCHAR2(50 BYTE), 
	"IKWHC3" VARCHAR2(50 BYTE), 
	"IKWHC4" VARCHAR2(50 BYTE), 
	"IKWHC5" VARCHAR2(50 BYTE), 
	"EKWHC1" VARCHAR2(50 BYTE), 
	"EKWHC2" VARCHAR2(50 BYTE), 
	"EKWHC3" VARCHAR2(50 BYTE), 
	"EKWHC4" VARCHAR2(50 BYTE), 
	"EKWHC5" VARCHAR2(50 BYTE), 
	"KVAH" VARCHAR2(100 BYTE), 
	"KVARH" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SC_NO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_MC_INT_HIS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_MC_INT_HIS" 
   (	"READING_DATE" DATE, 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"IKWHC1" VARCHAR2(50 BYTE), 
	"IKWHC2" VARCHAR2(50 BYTE), 
	"IKWHC3" VARCHAR2(50 BYTE), 
	"IKWHC4" VARCHAR2(50 BYTE), 
	"IKWHC5" VARCHAR2(50 BYTE), 
	"EKWHC1" VARCHAR2(50 BYTE), 
	"EKWHC2" VARCHAR2(50 BYTE), 
	"EKWHC3" VARCHAR2(50 BYTE), 
	"EKWHC4" VARCHAR2(50 BYTE), 
	"EKWHC5" VARCHAR2(50 BYTE), 
	"KVAH" VARCHAR2(100 BYTE), 
	"KVARH" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SC_NO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_METER_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_METER_CHANGE" 
   (	"READING_DATE" DATE, 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"IKWHC1" VARCHAR2(50 BYTE), 
	"IKWHC2" VARCHAR2(50 BYTE), 
	"IKWHC3" VARCHAR2(50 BYTE), 
	"IKWHC4" VARCHAR2(50 BYTE), 
	"IKWHC5" VARCHAR2(50 BYTE), 
	"EKWHC1" VARCHAR2(50 BYTE), 
	"EKWHC2" VARCHAR2(50 BYTE), 
	"EKWHC3" VARCHAR2(50 BYTE), 
	"EKWHC4" VARCHAR2(50 BYTE), 
	"EKWHC5" VARCHAR2(50 BYTE), 
	"KVAH" VARCHAR2(100 BYTE), 
	"KVARH" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SC_NO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_METER_CHANGE_FROM_AMR
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_METER_CHANGE_FROM_AMR" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SSWEGID" VARCHAR2(50 BYTE), 
	"OLDMETERNO" VARCHAR2(50 BYTE), 
	"NEWMETERNO" VARCHAR2(50 BYTE), 
	"STATUS" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD1" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD2" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD3" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD4" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD5" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD1" VARCHAR2(50 BYTE), 
	"OLETKWHTOD2" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD3" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD4" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD5" VARCHAR2(50 BYTE), 
	"OLDIKVAH" VARCHAR2(100 BYTE), 
	"OLDEKVAH" VARCHAR2(100 BYTE), 
	"OLDQ1KVARH" VARCHAR2(100 BYTE), 
	"OLDQ2KVARH" VARCHAR2(100 BYTE), 
	"OLDQ3KVARH" VARCHAR2(100 BYTE), 
	"OLDQ4KVARH" VARCHAR2(100 BYTE), 
	"OLDMF" VARCHAR2(50 BYTE), 
	"NEWIKWHTOD1" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD2" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD3" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD4" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD5" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD1" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD2" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD3" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD4" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD5" VARCHAR2(100 BYTE), 
	"NEWIKVAH" VARCHAR2(100 BYTE), 
	"NEWEKVAH" VARCHAR2(100 BYTE), 
	"NEWQ1KVARH" VARCHAR2(100 BYTE), 
	"NEWQ2KVARH" VARCHAR2(100 BYTE), 
	"NEWQ3KVARH" VARCHAR2(100 BYTE), 
	"NEWQ4KVARH" VARCHAR2(100 BYTE), 
	"NEWMF" VARCHAR2(50 BYTE), 
	"MODIFYDATE" DATE, 
	"SERVICENO" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_METER_CHANGE_FROM_AMR_HIS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_METER_CHANGE_FROM_AMR_HIS" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SSWEGID" VARCHAR2(50 BYTE), 
	"OLDMETERNO" VARCHAR2(50 BYTE), 
	"NEWMETERNO" VARCHAR2(50 BYTE), 
	"STATUS" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD1" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD2" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD3" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD4" VARCHAR2(50 BYTE), 
	"OLDIKWHTOD5" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD1" VARCHAR2(50 BYTE), 
	"OLETKWHTOD2" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD3" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD4" VARCHAR2(50 BYTE), 
	"OLDEKWHTOD5" VARCHAR2(50 BYTE), 
	"OLDIKVAH" VARCHAR2(100 BYTE), 
	"OLDEKVAH" VARCHAR2(100 BYTE), 
	"OLDQ1KVARH" VARCHAR2(100 BYTE), 
	"OLDQ2KVARH" VARCHAR2(100 BYTE), 
	"OLDQ3KVARH" VARCHAR2(100 BYTE), 
	"OLDQ4KVARH" VARCHAR2(100 BYTE), 
	"OLDMF" VARCHAR2(50 BYTE), 
	"NEWIKWHTOD1" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD2" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD3" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD4" VARCHAR2(100 BYTE), 
	"NEWIKWHTOD5" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD1" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD2" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD3" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD4" VARCHAR2(100 BYTE), 
	"NEWEKWHTOD5" VARCHAR2(100 BYTE), 
	"NEWIKVAH" VARCHAR2(100 BYTE), 
	"NEWEKVAH" VARCHAR2(100 BYTE), 
	"NEWQ1KVARH" VARCHAR2(100 BYTE), 
	"NEWQ2KVARH" VARCHAR2(100 BYTE), 
	"NEWQ3KVARH" VARCHAR2(100 BYTE), 
	"NEWQ4KVARH" VARCHAR2(100 BYTE), 
	"NEWMF" VARCHAR2(50 BYTE), 
	"MODIFYDATE" DATE, 
	"SERVICENO" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_METER_CHANGE_INT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_METER_CHANGE_INT" 
   (	"READING_DATE" DATE, 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"IKWHC1" VARCHAR2(50 BYTE), 
	"IKWHC2" VARCHAR2(50 BYTE), 
	"IKWHC3" VARCHAR2(50 BYTE), 
	"IKWHC4" VARCHAR2(50 BYTE), 
	"IKWHC5" VARCHAR2(50 BYTE), 
	"EKWHC1" VARCHAR2(50 BYTE), 
	"EKWHC2" VARCHAR2(50 BYTE), 
	"EKWHC3" VARCHAR2(50 BYTE), 
	"EKWHC4" VARCHAR2(50 BYTE), 
	"EKWHC5" VARCHAR2(50 BYTE), 
	"KVAH" VARCHAR2(100 BYTE), 
	"KVARH" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SC_NO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_METER_CHG_LIST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_METER_CHG_LIST" 
   (	"GENERATOR_NO" VARCHAR2(20 BYTE), 
	"NEW_METER_NO" VARCHAR2(20 BYTE), 
	"DONE" VARCHAR2(1 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"FLOW_TYPE" VARCHAR2(15 BYTE), 
	"TYPE_OF_SS" VARCHAR2(30 BYTE), 
	"MONTH" VARCHAR2(2 BYTE), 
	"YEAR" VARCHAR2(4 BYTE), 
	"OLD_METER_NO" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_METER_CHG_LIST_HIS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_METER_CHG_LIST_HIS" 
   (	"GENERATOR_NO" VARCHAR2(20 BYTE), 
	"METER_NO" VARCHAR2(20 BYTE), 
	"DONE" VARCHAR2(1 BYTE), 
	"REMARKS" VARCHAR2(200 BYTE), 
	"FLOW_TYPE" VARCHAR2(15 BYTE), 
	"TYPE_OF_SS" VARCHAR2(30 BYTE), 
	"MON" VARCHAR2(2 BYTE), 
	"YR" VARCHAR2(4 BYTE), 
	"OLD_METER_NO" VARCHAR2(10 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_POWERPLANT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_POWERPLANT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"IS_PRIMARY" CHAR(1 BYTE), 
	"VERSION" NUMBER(2,0), 
	"CODE" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"PLANT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"M_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"T_GRID_CONN_APPLN_ID" VARCHAR2(50 BYTE), 
	"TOTAL_CAPACITY" VARCHAR2(25 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"INTERFACE_VOLTAGE_PHASE" VARCHAR2(25 BYTE), 
	"INTERFACE_VOLTAGE_FREQUENCY" VARCHAR2(25 BYTE), 
	"COMMISSION_DATE" DATE, 
	"PURPOSE" VARCHAR2(500 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"STATUS" VARCHAR2(25 BYTE), 
	"LINE1" VARCHAR2(500 BYTE), 
	"CITY" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"PINCODE" VARCHAR2(50 BYTE), 
	"VILLAGE" VARCHAR2(200 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"PLS_SF_NO" VARCHAR2(50 BYTE), 
	"PL_VILLAGE" VARCHAR2(200 BYTE), 
	"PL_TOWN" VARCHAR2(50 BYTE), 
	"PL_TALUK_CODE" VARCHAR2(50 BYTE), 
	"PL_DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"WIND_ZONE_AREA_CODE" VARCHAR2(50 BYTE), 
	"APPLICATION_DT" DATE, 
	"APPROVAL_DT" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"EMAIL_ID" VARCHAR2(100 BYTE), 
	"AD_BENEFITS" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_SURPLUS_CASES_FROM_HT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" 
   (	"BUYER_SERVICE_NO" VARCHAR2(50 BYTE), 
	"SELLER_SERVICE_NO" VARCHAR2(50 BYTE), 
	"SELLER_TYPE" VARCHAR2(50 BYTE), 
	"SELLER_NAME" VARCHAR2(100 BYTE), 
	"READING_MNTH" VARCHAR2(50 BYTE), 
	"READING_YR" VARCHAR2(50 BYTE), 
	"ADJ_C1" VARCHAR2(50 BYTE), 
	"ADJ_C2" VARCHAR2(50 BYTE), 
	"ADJ_C3" VARCHAR2(50 BYTE), 
	"ADJ_C4" VARCHAR2(50 BYTE), 
	"ADJ_C5" VARCHAR2(50 BYTE), 
	"ADJ_C24" VARCHAR2(50 BYTE), 
	"SURP_C1" VARCHAR2(50 BYTE), 
	"SURP_C2" VARCHAR2(50 BYTE), 
	"SURP_C3" VARCHAR2(50 BYTE), 
	"SURP_C4" VARCHAR2(50 BYTE), 
	"SURP_C5" VARCHAR2(50 BYTE), 
	"SURP_C24" VARCHAR2(50 BYTE), 
	"READING_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_SURPLUS_SER_DET
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_SURPLUS_SER_DET" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"DUP_COUNT" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_TARIFF_WIND
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_TARIFF_WIND" 
   (	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"WEG_GROUP_CODE" VARCHAR2(20 BYTE), 
	"RATE" VARCHAR2(5 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_TO_UPD_MNS_LIST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_TO_UPD_MNS_LIST" 
   (	"GEN_NO" VARCHAR2(20 BYTE), 
	"OLD_STATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_TO_UPD_MNS_LIST_05
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_TO_UPD_MNS_LIST_05" 
   (	"GEN_NO" VARCHAR2(20 BYTE), 
	"OLD_STATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_TO_UPD_MNS_LIST_BK
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_TO_UPD_MNS_LIST_BK" 
   (	"GEN_NO" VARCHAR2(20 BYTE), 
	"OLD_STATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_TO_UPD_SEC
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_TO_UPD_SEC" 
   (	"GEN_NO" VARCHAR2(20 BYTE), 
	"SECTION" VARCHAR2(60 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table R_WEG_CODE_UPDATE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."R_WEG_CODE_UPDATE" 
   (	"SERVICE_ID" VARCHAR2(20 BYTE), 
	"COMM_DATE" VARCHAR2(20 BYTE), 
	"WEG_CODE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table SERVICEMASVIEW
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SERVICEMASVIEW" 
   (	"SERVICE_NO" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"VOLTAGE" VARCHAR2(50 BYTE), 
	"CONSUMER_NAME" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table SE_METTUR_16052021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SE_METTUR_16052021" 
   (	"HT_CONSUMER" VARCHAR2(128 BYTE), 
	"WEG_NO" VARCHAR2(12 BYTE), 
	"GEN_EDC" VARCHAR2(12 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table SUPLR_CODE_120720
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SUPLR_CODE_120720" 
   (	"SUPPLIER_TYPE_CODE" VARCHAR2(26 BYTE), 
	"SUPPLIER_TYPE_NAME" VARCHAR2(128 BYTE), 
	"SUPPLY_TYPE" VARCHAR2(26 BYTE), 
	"FUEL_TYPE" VARCHAR2(26 BYTE), 
	"INJ_VOLT" VARCHAR2(26 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table SUPLR_CODE_CHK_120720
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SUPLR_CODE_CHK_120720" 
   (	"SUPPLIER_TYPE_CODE" VARCHAR2(26 BYTE), 
	"SUPPLIER_TYPE_NAME" VARCHAR2(128 BYTE), 
	"SUPPLY_TYPE" VARCHAR2(26 BYTE), 
	"FUEL_TYPE" VARCHAR2(26 BYTE), 
	"INJ_VOLT" VARCHAR2(26 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table SURPLUS_01052020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SURPLUS_01052020" 
   (	"SELLERSERVICENO" VARCHAR2(15 BYTE), 
	"BUYERSERVICENO" VARCHAR2(15 BYTE), 
	"SURPLUS1" VARCHAR2(10 BYTE), 
	"SURPLUS2" VARCHAR2(10 BYTE), 
	"SURPLUS3" VARCHAR2(10 BYTE), 
	"SURPLUS4" VARCHAR2(10 BYTE), 
	"SURPLUS5" VARCHAR2(10 BYTE), 
	"HT_BB_C1" VARCHAR2(50 BYTE), 
	"HT_BB_C2" VARCHAR2(50 BYTE), 
	"HT_BB_C3" VARCHAR2(50 BYTE), 
	"HT_BB_C4" VARCHAR2(50 BYTE), 
	"HT_BB_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_01
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_01" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_01"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_02
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_02" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_02"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_03
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_03" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_03"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_04
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_04" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_04"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_05
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_05" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_05"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_06
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_06" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_06"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_07
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_07" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_07"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_08
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_08" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_08"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_09
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_09" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_09"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_10
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_10" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_10"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_11
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_11" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_11"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_12
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_12" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_12"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_13
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_13" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_13"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_14
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_14" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_14"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_15
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_15" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_15"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_16
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_16" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_16"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_17
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_17" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_17"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_18
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_18" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_18"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_19
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_19" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_19"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_20
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_20" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_20"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_21
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_21" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_21"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table SYS_EXPORT_SCHEMA_22
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_22" 
   (	"ABORT_STEP" NUMBER, 
	"ACCESS_METHOD" VARCHAR2(16 BYTE), 
	"ANCESTOR_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ANCESTOR_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"ANCESTOR_PROCESS_ORDER" NUMBER, 
	"BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"BASE_OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"BASE_PROCESS_ORDER" NUMBER, 
	"BLOCK_SIZE" NUMBER, 
	"CLUSTER_OK" NUMBER, 
	"COMPLETED_BYTES" NUMBER, 
	"COMPLETED_ROWS" NUMBER, 
	"COMPLETION_TIME" DATE, 
	"CONTROL_QUEUE" VARCHAR2(128 BYTE), 
	"CREATION_LEVEL" NUMBER, 
	"CREATION_TIME" DATE, 
	"CUMULATIVE_TIME" NUMBER, 
	"DATA_BUFFER_SIZE" NUMBER, 
	"DATA_IO" NUMBER, 
	"DATAOBJ_NUM" NUMBER, 
	"DB_VERSION" VARCHAR2(60 BYTE), 
	"DEGREE" NUMBER, 
	"DOMAIN_PROCESS_ORDER" NUMBER, 
	"DUMP_ALLOCATION" NUMBER, 
	"DUMP_FILEID" NUMBER, 
	"DUMP_LENGTH" NUMBER, 
	"DUMP_ORIG_LENGTH" NUMBER, 
	"DUMP_POSITION" NUMBER, 
	"DUPLICATE" NUMBER, 
	"ELAPSED_TIME" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"EXTEND_SIZE" NUMBER, 
	"FILE_MAX_SIZE" NUMBER, 
	"FILE_NAME" VARCHAR2(4000 BYTE), 
	"FILE_TYPE" NUMBER, 
	"FLAGS" NUMBER, 
	"GRANTOR" VARCHAR2(128 BYTE), 
	"GRANULES" NUMBER, 
	"GUID" RAW(16), 
	"IN_PROGRESS" CHAR(1 BYTE), 
	"INSTANCE" VARCHAR2(60 BYTE), 
	"INSTANCE_ID" NUMBER, 
	"IS_DEFAULT" NUMBER, 
	"JOB_MODE" VARCHAR2(21 BYTE), 
	"JOB_VERSION" VARCHAR2(60 BYTE), 
	"LAST_FILE" NUMBER, 
	"LAST_UPDATE" DATE, 
	"LOAD_METHOD" NUMBER, 
	"METADATA_BUFFER_SIZE" NUMBER, 
	"METADATA_IO" NUMBER, 
	"NAME" VARCHAR2(128 BYTE), 
	"OBJECT_INT_OID" VARCHAR2(130 BYTE), 
	"OBJECT_LONG_NAME" VARCHAR2(4000 BYTE), 
	"OBJECT_NAME" VARCHAR2(200 BYTE), 
	"OBJECT_NUMBER" NUMBER, 
	"OBJECT_PATH_SEQNO" NUMBER, 
	"OBJECT_ROW" NUMBER, 
	"OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"OBJECT_TABLESPACE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE" VARCHAR2(128 BYTE), 
	"OBJECT_TYPE_PATH" VARCHAR2(200 BYTE), 
	"OBJNUM" NUMBER, 
	"OLD_VALUE" VARCHAR2(4000 BYTE), 
	"OPERATION" VARCHAR2(8 BYTE), 
	"OPTION_TAG" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIG_BASE_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"ORIGINAL_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PACKET_NUMBER" NUMBER, 
	"PARALLELIZATION" NUMBER, 
	"PARENT_OBJECT_NAME" VARCHAR2(128 BYTE), 
	"PARENT_OBJECT_SCHEMA" VARCHAR2(128 BYTE), 
	"PARENT_PROCESS_ORDER" NUMBER, 
	"PARTITION_NAME" VARCHAR2(128 BYTE), 
	"PHASE" NUMBER, 
	"PLATFORM" VARCHAR2(101 BYTE), 
	"PROCESS_NAME" VARCHAR2(128 BYTE), 
	"PROCESS_ORDER" NUMBER, 
	"PROCESSING_STATE" CHAR(1 BYTE), 
	"PROCESSING_STATUS" CHAR(1 BYTE), 
	"PROPERTY" NUMBER, 
	"PROXY_SCHEMA" VARCHAR2(128 BYTE), 
	"PROXY_VIEW" VARCHAR2(128 BYTE), 
	"QUEUE_TABNUM" NUMBER, 
	"REMOTE_LINK" VARCHAR2(128 BYTE), 
	"SCN" NUMBER, 
	"SEED" NUMBER, 
	"SERVICE_NAME" VARCHAR2(64 BYTE), 
	"SIZE_ESTIMATE" NUMBER, 
	"SRC_COMPAT" VARCHAR2(60 BYTE), 
	"START_TIME" DATE, 
	"STATE" VARCHAR2(12 BYTE), 
	"STATUS_QUEUE" VARCHAR2(128 BYTE), 
	"SUBPARTITION_NAME" VARCHAR2(128 BYTE), 
	"TARGET_XML_CLOB" CLOB, 
	"TDE_REWRAPPED_KEY" RAW(2000), 
	"TEMPLATE_TABLE" VARCHAR2(128 BYTE), 
	"TIMEZONE" VARCHAR2(64 BYTE), 
	"TOTAL_BYTES" NUMBER, 
	"TRIGFLAG" NUMBER, 
	"UNLOAD_METHOD" NUMBER, 
	"USER_DIRECTORY" VARCHAR2(4000 BYTE), 
	"USER_FILE_NAME" VARCHAR2(4000 BYTE), 
	"USER_NAME" VARCHAR2(128 BYTE), 
	"VALUE_N" NUMBER, 
	"VALUE_T" VARCHAR2(4000 BYTE), 
	"VERSION" NUMBER, 
	"WORK_ITEM" VARCHAR2(21 BYTE), 
	"XML_CLOB" CLOB, 
	"XML_PROCESS_ORDER" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 100 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"   NO INMEMORY 
 LOB ("TARGET_XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("XML_CLOB") STORE AS BASICFILE (
  TABLESPACE "SYSTEM" ENABLE STORAGE IN ROW CHUNK 8192 RETENTION 
  NOCACHE LOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) ;

   COMMENT ON TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_22"  IS 'Data Pump Master Table EXPORT                         SCHEMA                        ';
--------------------------------------------------------
--  DDL for Table TBL_MASTER_MODEM_27_08_20
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TBL_MASTER_MODEM_27_08_20" 
   (	"METERNO" VARCHAR2(12 BYTE), 
	"DEVICENO" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_BANKING_SOLUTION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_BANKING_SOLUTION" 
   (	"REMARKS" VARCHAR2(200 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE), 
	"SERVICE_NO" VARCHAR2(20 BYTE), 
	"M_COMPANY_ID" VARCHAR2(20 BYTE), 
	"C1" VARCHAR2(20 BYTE), 
	"C2" VARCHAR2(20 BYTE), 
	"C3" VARCHAR2(20 BYTE), 
	"C4" VARCHAR2(20 BYTE), 
	"C5" VARCHAR2(20 BYTE), 
	"NEW_C1" VARCHAR2(20 BYTE), 
	"NEW_C2" VARCHAR2(20 BYTE), 
	"NEW_C3" VARCHAR2(20 BYTE), 
	"NEW_C4" VARCHAR2(20 BYTE), 
	"NEW_C5" VARCHAR2(20 BYTE), 
	"C1_REMARKS" VARCHAR2(100 BYTE), 
	"C2_REMARKS" VARCHAR2(100 BYTE), 
	"C3_REMARKS" VARCHAR2(100 BYTE), 
	"C4_REMARKS" VARCHAR2(100 BYTE), 
	"C5_REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"CREATED_BY" VARCHAR2(20 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_BUYER_UPDATE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_BUYER_UPDATE" 
   (	"BUYERNUMBER" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_COMMERCIAL_MASTER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_COMMERCIAL_MASTER" 
   (	"WG_CIRCLE" VARCHAR2(100 BYTE), 
	"WG_HTSCNO" VARCHAR2(100 BYTE), 
	"WG_HTNAME" VARCHAR2(100 BYTE), 
	"WG_DOA" VARCHAR2(100 BYTE), 
	"WG_CLASS" VARCHAR2(100 BYTE), 
	"WG_CATEGORY" VARCHAR2(100 BYTE), 
	"WG_RATE" VARCHAR2(100 BYTE), 
	"WG_WHEELSCNO" VARCHAR2(100 BYTE), 
	"WG_WHEELCIRCLE" VARCHAR2(100 BYTE), 
	"WG_USER" VARCHAR2(100 BYTE), 
	"WG_ENTDATE" VARCHAR2(100 BYTE), 
	"WG_SSNAME" VARCHAR2(100 BYTE), 
	"WG_FEEDNAME" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"M_COMPANY_ID" VARCHAR2(100 BYTE), 
	"M_SERVICE_ID" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"M_SERVICE_ID1" VARCHAR2(50 BYTE), 
	"STATUS" VARCHAR2(50 BYTE), 
	"IS_ENABLED" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_HT_ADJUSTMENT_MASTER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_HT_ADJUSTMENT_MASTER" 
   (	"WFWIND_GENCIRCLE" VARCHAR2(100 BYTE), 
	"WFWIND_GENSERVICE" VARCHAR2(100 BYTE), 
	"WFWIND_EDCCIRCLE" VARCHAR2(100 BYTE), 
	"WFWIND_EDCSERVICE" VARCHAR2(100 BYTE), 
	"SELL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"SELL_ORG_ID" VARCHAR2(100 BYTE), 
	"BUY_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BUY_ORG_ID" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"IS_ENABLED" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_INCR
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_INCR" 
   (	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_MISSING_MR_SERVICES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_MISSING_MR_SERVICES" 
   (	"CIRCLECODE" VARCHAR2(10 BYTE), 
	"SERVICENO" VARCHAR2(20 BYTE), 
	"METERNO" VARCHAR2(20 BYTE), 
	"IN_AMR" VARCHAR2(20 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"READING_MONTH" VARCHAR2(20 BYTE), 
	"READING_YEAR" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_RESULTS_PLS_FLUSH
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_RESULTS_PLS_FLUSH" 
   (	"COLUMN1" VARCHAR2(1000 BYTE), 
	"COLUMN2" VARCHAR2(1000 BYTE), 
	"COLUMN3" VARCHAR2(1000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_TECHNICAL_MASTER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_TECHNICAL_MASTER" 
   (	"WG_SSNAME" VARCHAR2(100 BYTE), 
	"WG_NATURE" VARCHAR2(100 BYTE), 
	"WG_PASS" VARCHAR2(100 BYTE), 
	"WG_FEEDNAME" VARCHAR2(100 BYTE), 
	"WG_WINDMIXED" VARCHAR2(100 BYTE), 
	"WG_HTSCNO" VARCHAR2(100 BYTE), 
	"WG_COD" VARCHAR2(100 BYTE), 
	"WG_NAMETIEUP" VARCHAR2(100 BYTE), 
	"WG_SINGLEFARM" VARCHAR2(100 BYTE), 
	"WG_NOUNITS" VARCHAR2(100 BYTE), 
	"WG_MAKE" VARCHAR2(100 BYTE), 
	"WG_CAP" VARCHAR2(100 BYTE), 
	"WG_ABTYN" VARCHAR2(100 BYTE), 
	"WG_METERNO" VARCHAR2(100 BYTE), 
	"WG_ACCLASS" VARCHAR2(100 BYTE), 
	"WG_INCVOL" VARCHAR2(100 BYTE), 
	"WG_REC" VARCHAR2(100 BYTE), 
	"WG_TALUK" VARCHAR2(100 BYTE), 
	"WG_USER" VARCHAR2(100 BYTE), 
	"WG_ENTDATE" VARCHAR2(100 BYTE), 
	"CIRCLECODE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"M_COMPANY_ID" VARCHAR2(100 BYTE), 
	"M_SERVICE_ID" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"IS_ENABLED" CHAR(1 BYTE), 
	"M_POWERPLANT_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_V_COMP_REFRESH
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_V_COMP_REFRESH" 
   (	"ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"COMMISSION_DATE" DATE, 
	"COMPANY_IS_INTERNAL" CHAR(1 BYTE), 
	"COMP_SER_TYPE_CODE" VARCHAR2(25 BYTE), 
	"COMP_SER_TYPE_NAME" VARCHAR2(200 BYTE), 
	"DL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"DL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_NAME" VARCHAR2(200 BYTE), 
	"ACCURACY_CLASS_CODE" VARCHAR2(50 BYTE), 
	"IS_ABTMETER" CHAR(1 BYTE), 
	"IS_BUYER" CHAR(1 BYTE), 
	"IS_CAPTIVE" VARCHAR2(25 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"IS_SELLER" CHAR(1 BYTE), 
	"METER_CT1" VARCHAR2(50 BYTE), 
	"METER_CT2" VARCHAR2(50 BYTE), 
	"METER_CT3" VARCHAR2(50 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"METER_NUMBER" VARCHAR2(100 BYTE), 
	"METER_PT1" VARCHAR2(50 BYTE), 
	"METER_PT2" VARCHAR2(50 BYTE), 
	"METER_PT3" VARCHAR2(50 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MODEM_NUMBER" VARCHAR2(100 BYTE), 
	"M_COMPANY_CODE" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"M_COMP_SERV_NUMBER" VARCHAR2(50 BYTE), 
	"M_FEEDER_CODE" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(50 BYTE), 
	"M_ORG_CODE" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SECTION_CODE" VARCHAR2(6 BYTE), 
	"M_SECTION_ID" VARCHAR2(50 BYTE), 
	"M_SECTION_NAME" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_CODE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(50 BYTE), 
	"TARIFF" VARCHAR2(50 BYTE), 
	"TL_SERVICE_ID" VARCHAR2(100 BYTE), 
	"TL_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"TYPE_OF_SS" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_ID" VARCHAR2(100 BYTE), 
	"UNADJUSTED_SERVICE_NUMBER" VARCHAR2(100 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"VOLTAGE_NAME" VARCHAR2(200 BYTE), 
	"number" VARCHAR2(50 BYTE), 
	"IS_STB" VARCHAR2(50 BYTE), 
	"IS_THIRD_PARTY" VARCHAR2(50 BYTE), 
	"TR_FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_GROUP_NAME" VARCHAR2(50 BYTE), 
	"EXCESS_UNIT_TYPE" VARCHAR2(50 BYTE), 
	"EXCESS_UNIT_TYPE_REASON" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TEMP_WEG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TEMP_WEG" 
   (	"WG_SSNAME" VARCHAR2(150 BYTE), 
	"WG_NATURE" VARCHAR2(150 BYTE), 
	"WG_PASS" VARCHAR2(150 BYTE), 
	"WG_FEEDNAME" VARCHAR2(150 BYTE), 
	"WG_WINDMIXED" VARCHAR2(150 BYTE), 
	"WG_HTSCNO" VARCHAR2(150 BYTE), 
	"WG_COD" VARCHAR2(150 BYTE), 
	"WG_NAMETIEUP" VARCHAR2(150 BYTE), 
	"WG_SINGLEFARM" VARCHAR2(150 BYTE), 
	"WG_NOUNITS" VARCHAR2(150 BYTE), 
	"WG_MAKE" VARCHAR2(150 BYTE), 
	"WG_CAP" VARCHAR2(150 BYTE), 
	"WG_ABTYN" VARCHAR2(150 BYTE), 
	"WG_METERNO" VARCHAR2(150 BYTE), 
	"WG_ACCLASS" VARCHAR2(150 BYTE), 
	"WG_INCVOL" VARCHAR2(150 BYTE), 
	"WG_REC" VARCHAR2(150 BYTE), 
	"WG_TALUK" VARCHAR2(150 BYTE), 
	"WG_USER" VARCHAR2(150 BYTE), 
	"WG_ENTDATE" VARCHAR2(150 BYTE), 
	"CIRCLECODE" VARCHAR2(150 BYTE), 
	"ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"M_FEEDER_ID" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table THERMALAMRCHECK_07092020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."THERMALAMRCHECK_07092020" 
   (	"SECTIONID" NUMBER(4,0), 
	"SECTIONNAME" VARCHAR2(12 BYTE), 
	"SECTIONCODE" VARCHAR2(7 BYTE), 
	"SUBSTATIONID" NUMBER(3,0), 
	"SUBSTATIONNAME" VARCHAR2(23 BYTE), 
	"SUBSTATIONCODE" VARCHAR2(5 BYTE), 
	"CAPACITYNAME" VARCHAR2(12 BYTE), 
	"CAPACITYCODE" NUMBER(1,0), 
	"WEGID" NUMBER(4,0), 
	"WEGNAME" VARCHAR2(28 BYTE), 
	"WEGCODE" VARCHAR2(25 BYTE), 
	"WEGCAPACITY" VARCHAR2(5 BYTE), 
	"WEGCAPACITYCODE" VARCHAR2(5 BYTE), 
	"SERVICEID" NUMBER(5,0), 
	"SERVICENO" VARCHAR2(14 BYTE), 
	"SERVICECODE" VARCHAR2(12 BYTE), 
	"METERID" NUMBER(5,0), 
	"SSWEGID" NUMBER(5,0), 
	"METERNO" VARCHAR2(9 BYTE), 
	"METERMAKENAME" VARCHAR2(6 BYTE), 
	"CTRATIO" VARCHAR2(6 BYTE), 
	"PTRATIO" VARCHAR2(10 BYTE), 
	"MF" NUMBER(9,2), 
	"MACID" NUMBER(1,0), 
	"MODEMID" NUMBER(4,0), 
	"INSTALLEDDATE" VARCHAR2(10 BYTE), 
	"DEVICENO" VARCHAR2(10 BYTE), 
	"LATITUDE" NUMBER(1,0), 
	"LONGITUDE" NUMBER(1,0), 
	"SIMIP" VARCHAR2(13 BYTE), 
	"SIMNO" NUMBER(13,0), 
	"SIMIMEINO" VARCHAR2(20 BYTE), 
	"PROVIDERNAME" VARCHAR2(8 BYTE), 
	"SERVERIP" VARCHAR2(10 BYTE), 
	"SERVERPORTNO" NUMBER(4,0), 
	"VERIFIEDSTATUS" NUMBER(1,0), 
	"OWNERNAME" VARCHAR2(31 BYTE), 
	"SUBSTATIONTYPEID" NUMBER(1,0), 
	"SUBSTATIONTYPENAME" VARCHAR2(28 BYTE), 
	"WEGCAPACITYID" NUMBER(1,0), 
	"OWNERID" NUMBER(4,0), 
	"PROVIDERID" NUMBER(1,0), 
	"PRIMARYCURRENT" NUMBER(3,0), 
	"SECONDARYCURRENT" NUMBER(1,0), 
	"PRIMARYVOLTAGE" NUMBER(6,0), 
	"SECONDARYVOLTAGE" NUMBER(3,0)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_GEN_SS_LOSS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_GEN_SS_LOSS" 
   (	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"M_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_GEN_STMT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_GEN_STMT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"AMENDMENT_TYPE" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"BATCH_KEY" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_GEN_STMT_CHARGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_GEN_STMT_CHARGE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"TMP_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_GEN_STMT_SLOT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_GEN_STMT_SLOT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"TMP_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"BANKED_BALANCE" VARCHAR2(50 BYTE), 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_IMPORT_TRADE_REL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_IMPORT_TRADE_REL" 
   (	"ID" VARCHAR2(200 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"SELLER_END_EDC" VARCHAR2(200 BYTE), 
	"SELLER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE_STR" VARCHAR2(25 BYTE), 
	"TO_DATE_STR" VARCHAR2(25 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"BUYER_END_EDC" VARCHAR2(200 BYTE), 
	"BUYER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(1000 BYTE), 
	"RESULT" VARCHAR2(50 BYTE), 
	"RESULT_DESC" VARCHAR2(1000 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_M_SECTION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_M_SECTION" 
   (	"S_NO" VARCHAR2(50 BYTE), 
	"SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"SECTION_NAME" VARCHAR2(50 BYTE), 
	"SECTION_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 221184 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TMP_M_TRADE_REALTIONSHIP
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TMP_M_TRADE_REALTIONSHIP" 
   (	"ID" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_SELLER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REFERENCENUMBER" VARCHAR2(200 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"TRADE_RELATIONSHIP_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_TYPE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"AGMT_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TO_UPDATE_LIST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TO_UPDATE_LIST" 
   (	"GEN_NUM" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table TP_WIND_SOLAR_140920
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."TP_WIND_SOLAR_140920" 
   (	"ORG_ID" VARCHAR2(50 BYTE), 
	"ORG_NAME" VARCHAR2(50 BYTE), 
	"SPG_HT_SERVICE_NO" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"TYPE_OF_SS" VARCHAR2(100 BYTE), 
	"GENERATOR_NAME" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"FUEL_TYPE_NAME" VARCHAR2(200 BYTE), 
	"MF" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(500 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(500 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(500 BYTE), 
	"ATT2" VARCHAR2(500 BYTE), 
	"ATT3" VARCHAR2(500 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"ATT4" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_02072020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_02072020" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(500 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(500 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(500 BYTE), 
	"ATT2" VARCHAR2(500 BYTE), 
	"ATT3" VARCHAR2(500 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"ATT4" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_050719
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_050719" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_050719_2
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_050719_2" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_05_04_2021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_05_04_2021" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(500 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(500 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(500 BYTE), 
	"ATT2" VARCHAR2(500 BYTE), 
	"ATT3" VARCHAR2(500 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"ATT4" VARCHAR2(500 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_100719
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_100719" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_110719
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_110719" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ACTIVITY_LOG_28012020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ACTIVITY_LOG_28012020" 
   (	"ID" VARCHAR2(100 BYTE), 
	"PROCESS_TYPE" VARCHAR2(100 BYTE), 
	"PROCESS_NAME" VARCHAR2(100 BYTE), 
	"ACTIVITY_NAME" VARCHAR2(200 BYTE), 
	"MESSAGE" VARCHAR2(500 BYTE), 
	"result" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(200 BYTE), 
	"CREATED_DT" DATE, 
	"ATT1" VARCHAR2(200 BYTE), 
	"ATT2" VARCHAR2(200 BYTE), 
	"ATT3" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_AMENDMENT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_AMENDMENT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"AMENDMENT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"OLD_AGMT_ID" VARCHAR2(50 BYTE), 
	"OLD_AGMT_VERSION" VARCHAR2(50 BYTE), 
	"NEW_AGMT_VERSION" VARCHAR2(50 BYTE), 
	"NEW_AGMT_ID" VARCHAR2(50 BYTE), 
	"AMENDMENT_DATE" DATE, 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"NEW_FROM_DATE" DATE, 
	"NEW_TO_DATE" DATE, 
	"NEW_TOTAL_UNITS" VARCHAR2(50 BYTE), 
	"NEW_C1" VARCHAR2(50 BYTE), 
	"NEW_C2" VARCHAR2(50 BYTE), 
	"NEW_C3" VARCHAR2(50 BYTE), 
	"NEW_C4" VARCHAR2(50 BYTE), 
	"NEW_C5" VARCHAR2(50 BYTE), 
	"NEW_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"NEW_OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"SIGNATORY_PARTY1" VARCHAR2(1500 BYTE), 
	"SIGNATORY_PARTY2" VARCHAR2(1500 BYTE), 
	"SIGNATORY_PARTY3" VARCHAR2(1500 BYTE), 
	"HAS_LINES" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"NEW_FROM_MONTH" DATE, 
	"NEW_TO_YEAR" DATE, 
	"NEW_FROM_YEAR" DATE, 
	"NEW_TO_MONTH" DATE, 
	"MODIFIED_DATE" DATE, 
	"MODIFIDED_BY" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(100 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(100 BYTE), 
	"CODE" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_ACTIVITY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_ACTIVITY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_BANKING_BAL_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y'
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALALCE_AUG06
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALALCE_AUG06" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_03_06_19
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_03_06_19" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"CREATED_TIMESTAMP" TIMESTAMP (2) WITH TIME ZONE, 
	"ACTION" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_042020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_042020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_042020_WITHSURPLUS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_042020_WITHSURPLUS" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_042020_WITHSURPLUS_SEG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_042020_WITHSURPLUS_SEG" 
   (	"SUPLR_CODE" VARCHAR2(100 BYTE), 
	"FE_C1_LOSS" NUMBER, 
	"FEA_C2_LOSS" NUMBER, 
	"FEA_C3_LOSS" NUMBER, 
	"FEA_C4_LOSS" NUMBER, 
	"FEA_C5_LOSS" NUMBER, 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_290519
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_290519" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_31032020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_31032020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_BACKUP31OCT2019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_BACKUP31OCT2019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_BFDOWNLOADMARCH2019
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_BFDOWNLOADMARCH2019" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_HISTORY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_HISTORY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"CREATED_TIMESTAMP" TIMESTAMP (2) WITH TIME ZONE, 
	"ACTION" VARCHAR2(20 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_MAR_20
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_MAR_20" 
   (	"number" VARCHAR2(50 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_MAR_20_1
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_MAR_20_1" 
   (	"number" VARCHAR2(50 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_MAY_20
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_MAY_20" 
   (	"number" VARCHAR2(50 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANKING_BALANCE_ONE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANKING_BALANCE_ONE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANK_SOLAR310320
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANK_SOLAR310320" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BANK_THIRDPARTY310320
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BANK_THIRDPARTY310320" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BB_0420
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BB_0420" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BB_0420_ALL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BB_0420_ALL" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BB_0520
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BB_0520" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"SERVICE_NO" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_BNK_WTSRPLS_27032020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_BNK_WTSRPLS_27032020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_COMPANY_METER_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_COMPANY_METER_CHANGE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"TYPE_OF_METER_CHANGE" VARCHAR2(50 BYTE), 
	"M_EDC_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"METER_CHANGE_DATE" DATE, 
	"OLD_METER_NUMBER" VARCHAR2(100 BYTE), 
	"NEW_METER_NUMBER" VARCHAR2(100 BYTE), 
	"OLD_METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"NEW_METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"OLD_ACCURACY_CLASS_CODE" VARCHAR2(50 BYTE), 
	"NEW_ACCURACY_CLASS_CODE" VARCHAR2(50 BYTE), 
	"OLD_IS_ABTMETER" CHAR(1 BYTE), 
	"NEW_IS_ABTMETER" CHAR(1 BYTE), 
	"OLD_MF" VARCHAR2(50 BYTE), 
	"NEW_MF" VARCHAR2(50 BYTE), 
	"OLD_MODEM_NUMBER" VARCHAR2(100 BYTE), 
	"NEW_MODEM_NUMBER" VARCHAR2(100 BYTE), 
	"OLD_METER_CT1" VARCHAR2(50 BYTE), 
	"OLD_METER_CT2" VARCHAR2(50 BYTE), 
	"OLD_METER_CT3" VARCHAR2(50 BYTE), 
	"OLD_METER_PT1" VARCHAR2(50 BYTE), 
	"OLD_METER_PT2" VARCHAR2(50 BYTE), 
	"OLD_METER_PT3" VARCHAR2(50 BYTE), 
	"NEW_METER_CT1" VARCHAR2(50 BYTE), 
	"NEW_METER_CT2" VARCHAR2(50 BYTE), 
	"NEW_METER_CT3" VARCHAR2(50 BYTE), 
	"NEW_METER_PT1" VARCHAR2(50 BYTE), 
	"NEW_METER_PT2" VARCHAR2(50 BYTE), 
	"NEW_METER_PT3" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IS_METER_NUMBER_CHANGE" CHAR(1 BYTE), 
	"IS_METER_SET_CHANGE" CHAR(1 BYTE), 
	"IS_MODEM_NUMBER_CHANGE" CHAR(1 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_COMPANY_NAME_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_COMPANY_NAME_CHANGE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"M_EDC_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"COMPANY_NAME_CHANGE_DATE" DATE, 
	"OLD_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"NEW_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_CONSENT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_CONSENT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"DRAWAL_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"DRAWAL_FEEDER_ID" VARCHAR2(50 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"T_NOC_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"APPROVED_CAPACITY" VARCHAR2(50 BYTE), 
	"IS_ABT_INSTALLED" CHAR(1 BYTE), 
	"NO_ABT_REASON" VARCHAR2(500 BYTE), 
	"HAS_REAL_TIME_CON" CHAR(1 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"INJECTION_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"INJECTION_FEEDER_ID" VARCHAR2(50 BYTE), 
	"INJECTION_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_DT" DATE, 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"EXEMPT_RC" CHAR(1 BYTE), 
	"HAS_DUES" CHAR(1 BYTE), 
	"DUE_DETAILS" VARCHAR2(50 BYTE), 
	"PENDING_CASE_DETAILS" VARCHAR2(50 BYTE), 
	"TECHNICAL_FEASIBILITY_DETAILS" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_CS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_CS" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_EDC_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_DATE" DATE, 
	"EFFECTIVE_DATE" DATE, 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FROM_MONTH" VARCHAR2(50 BYTE), 
	"TO_YEAR" VARCHAR2(50 BYTE), 
	"FROM_YEAR" VARCHAR2(50 BYTE), 
	"TO_MONTH" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"MODIFIDED_BY" VARCHAR2(50 BYTE), 
	"AGREEMENT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"ID_TOTAL_COST" VARCHAR2(50 BYTE), 
	"ID_TOTAL_CURRENCY" VARCHAR2(50 BYTE), 
	"ID_TOTAL_EXCHANGE_RATE" VARCHAR2(50 BYTE), 
	"APPROVED_CAPACITY" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_CS_ID_TABLEA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_CS_ID_TABLEA" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_CS_ID" VARCHAR2(50 BYTE), 
	"CLASS_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"NUMBER_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"VALUE_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"AMOUNT_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"NUMBER_OF_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_WITH_EQUITY" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_CS_ID_TABLEB
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_CS_ID_TABLEB" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_CS_ID" VARCHAR2(50 BYTE), 
	"CLASS_OF_SHAREHOLDER" VARCHAR2(50 BYTE), 
	"NUMBER_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"VALUE_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"AMOUNT_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"NUMBER_OF_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_WITH_EQUITY" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_CS_LOAN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_CS_LOAN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_CS_ID" VARCHAR2(50 BYTE), 
	"LOAN_ORIGIN" VARCHAR2(100 BYTE), 
	"SOURCE_NAME" VARCHAR2(50 BYTE), 
	"SOURCE_ADDRESS" VARCHAR2(50 BYTE), 
	"LOAN_AMOUNT" VARCHAR2(50 BYTE), 
	"CURRENCY" VARCHAR2(50 BYTE), 
	"EXCHANGE_RATE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_CS_QUANTUM_ALLOCATION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_CS_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPTIVE_COMPANY_NAME" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ENERGY_SALE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ENERGY_SALE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"NET_ALLOCATION" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(100 BYTE), 
	"TOTAL_BANK_UNITS_USED" VARCHAR2(100 BYTE), 
	"BC1" VARCHAR2(100 BYTE), 
	"BC2" VARCHAR2(100 BYTE), 
	"BC3" VARCHAR2(100 BYTE), 
	"BC4" VARCHAR2(100 BYTE), 
	"BC5" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"IS_STB" CHAR(1 BYTE), 
	"AVAIL_C1" VARCHAR2(100 BYTE), 
	"AVAIL_C2" VARCHAR2(100 BYTE), 
	"AVAIL_C3" VARCHAR2(100 BYTE), 
	"AVAIL_C4" VARCHAR2(100 BYTE), 
	"AVAIL_C5" VARCHAR2(100 BYTE), 
	"AVAIL_GC1" VARCHAR2(100 BYTE), 
	"AVAIL_GC2" VARCHAR2(100 BYTE), 
	"AVAIL_GC3" VARCHAR2(100 BYTE), 
	"AVAIL_GC4" VARCHAR2(100 BYTE), 
	"AVAIL_GC5" VARCHAR2(100 BYTE), 
	"AVAIL_BC1" VARCHAR2(100 BYTE), 
	"AVAIL_BC2" VARCHAR2(100 BYTE), 
	"AVAIL_BC3" VARCHAR2(100 BYTE), 
	"AVAIL_BC4" VARCHAR2(100 BYTE), 
	"AVAIL_BC5" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"NET_CHARGES_ALLOCATED" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE), 
	"PROCESS_REMARKS" VARCHAR2(500 BYTE), 
	"SAVED_ONCE" VARCHAR2(20 BYTE), 
	"FUEL_GROUPE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ENERGY_SALE_040619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ENERGY_SALE_040619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"NET_ALLOCATION" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(100 BYTE), 
	"TOTAL_BANK_UNITS_USED" VARCHAR2(100 BYTE), 
	"BC1" VARCHAR2(100 BYTE), 
	"BC2" VARCHAR2(100 BYTE), 
	"BC3" VARCHAR2(100 BYTE), 
	"BC4" VARCHAR2(100 BYTE), 
	"BC5" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"IS_STB" CHAR(1 BYTE), 
	"AVAIL_C1" VARCHAR2(100 BYTE), 
	"AVAIL_C2" VARCHAR2(100 BYTE), 
	"AVAIL_C3" VARCHAR2(100 BYTE), 
	"AVAIL_C4" VARCHAR2(100 BYTE), 
	"AVAIL_C5" VARCHAR2(100 BYTE), 
	"AVAIL_GC1" VARCHAR2(100 BYTE), 
	"AVAIL_GC2" VARCHAR2(100 BYTE), 
	"AVAIL_GC3" VARCHAR2(100 BYTE), 
	"AVAIL_GC4" VARCHAR2(100 BYTE), 
	"AVAIL_GC5" VARCHAR2(100 BYTE), 
	"AVAIL_BC1" VARCHAR2(100 BYTE), 
	"AVAIL_BC2" VARCHAR2(100 BYTE), 
	"AVAIL_BC3" VARCHAR2(100 BYTE), 
	"AVAIL_BC4" VARCHAR2(100 BYTE), 
	"AVAIL_BC5" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"NET_CHARGES_ALLOCATED" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE), 
	"PROCESS_REMARKS" VARCHAR2(500 BYTE), 
	"SAVED_ONCE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ENERGY_SALE_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ENERGY_SALE_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"LOSS" VARCHAR2(50 BYTE), 
	"MULTIPLE_BUYERS" CHAR(1 BYTE), 
	"USAGE_DETAIL_AVAIL" CHAR(1 BYTE), 
	"SIMPLE_ENERGY_SALE" CHAR(1 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"NET_ALLOCATION" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(100 BYTE), 
	"TOTAL_BANK_UNITS_USED" VARCHAR2(100 BYTE), 
	"BC1" VARCHAR2(100 BYTE), 
	"BC2" VARCHAR2(100 BYTE), 
	"BC3" VARCHAR2(100 BYTE), 
	"BC4" VARCHAR2(100 BYTE), 
	"BC5" VARCHAR2(100 BYTE), 
	"GC1" VARCHAR2(50 BYTE), 
	"GC2" VARCHAR2(50 BYTE), 
	"GC3" VARCHAR2(50 BYTE), 
	"GC4" VARCHAR2(50 BYTE), 
	"GC5" VARCHAR2(50 BYTE), 
	"IS_STB" CHAR(1 BYTE), 
	"AVAIL_C1" VARCHAR2(100 BYTE), 
	"AVAIL_C2" VARCHAR2(100 BYTE), 
	"AVAIL_C3" VARCHAR2(100 BYTE), 
	"AVAIL_C4" VARCHAR2(100 BYTE), 
	"AVAIL_C5" VARCHAR2(100 BYTE), 
	"AVAIL_GC1" VARCHAR2(100 BYTE), 
	"AVAIL_GC2" VARCHAR2(100 BYTE), 
	"AVAIL_GC3" VARCHAR2(100 BYTE), 
	"AVAIL_GC4" VARCHAR2(100 BYTE), 
	"AVAIL_GC5" VARCHAR2(100 BYTE), 
	"AVAIL_BC1" VARCHAR2(100 BYTE), 
	"AVAIL_BC2" VARCHAR2(100 BYTE), 
	"AVAIL_BC3" VARCHAR2(100 BYTE), 
	"AVAIL_BC4" VARCHAR2(100 BYTE), 
	"AVAIL_BC5" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"M_SUBSTATION_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"NET_CHARGES_ALLOCATED" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"ALLOW_LOWER_SLOT_ADMT" VARCHAR2(100 BYTE), 
	"PROCESS_REMARKS" VARCHAR2(500 BYTE), 
	"SAVED_ONCE" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EPA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EPA" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_NUMBER" VARCHAR2(50 BYTE), 
	"EPA_APPROVAL_NUMBER" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"SELLER_IS_CAPTIVE" CHAR(1 BYTE), 
	"AGREEMENT_DT" DATE, 
	"PROPOSED_TOTAL_UNITS" VARCHAR2(100 BYTE), 
	"APPROVED_TOTAL_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"FROM_MONTH" VARCHAR2(50 BYTE), 
	"TO_YEAR" VARCHAR2(50 BYTE), 
	"FROM_YEAR" VARCHAR2(50 BYTE), 
	"TO_MONTH" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"SHARE_PERCENTAGE" FLOAT(126), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EPA_LINES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EPA_LINES" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_EPA_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"M_GENERATOR_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_TOTAL_UNITS" VARCHAR2(50 BYTE), 
	"APPROVED_TOTAL_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_CHARGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_CHARGE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"M_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGE" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_CHARGE_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_CHARGE_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"M_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGE" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_INTENT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_INTENT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"FROM_MONTH" VARCHAR2(100 BYTE), 
	"FROM_YEAR" VARCHAR2(100 BYTE), 
	"TO_MONTH" VARCHAR2(100 BYTE), 
	"TO_YEAR" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"T_EWA_ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"T_INPRINCIPLE_APPLN_ID" VARCHAR2(50 BYTE), 
	"T_NOC_GENERATOR_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"APPLIED_DT" DATE, 
	"SLDC_AWAITED_DT" DATE, 
	"SLDC_APPROVAL_DT" DATE, 
	"SLDC_REJECTED_DT" DATE, 
	"SLDC_APPROVED" CHAR(1 BYTE) DEFAULT 'Y', 
	"SLDC_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_INTENT_LINE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_INTENT_LINE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_EST_INTENT_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"T_NOC_ID" VARCHAR2(50 BYTE), 
	"T_CONSENT_ID" VARCHAR2(50 BYTE), 
	"T_OA_AGMT_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_QUANTUM" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"T_EPA_ID" VARCHAR2(50 BYTE), 
	"M_TRADE_RELATIONSHIP_ID" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"T_STANDING_CLEARENCE_ID" VARCHAR2(50 BYTE), 
	"SHARED_PERCENTAGE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_MULTIADD_HEADER
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_MULTIADD_HEADER" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ES_ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"BATCH_ID" VARCHAR2(50 BYTE), 
	"TOTAL_COUNT" NUMBER, 
	"SUCCESS_COUNT" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"TOTAL_C1" VARCHAR2(50 BYTE), 
	"TOTAL_C2" VARCHAR2(50 BYTE), 
	"TOTAL_C3" VARCHAR2(50 BYTE), 
	"TOTAL_C4" VARCHAR2(50 BYTE), 
	"TOTAL_C5" VARCHAR2(50 BYTE), 
	"TOTAL_C001" VARCHAR2(50 BYTE), 
	"TOTAL_C002" VARCHAR2(50 BYTE), 
	"TOTAL_C003" VARCHAR2(50 BYTE), 
	"TOTAL_C004" VARCHAR2(50 BYTE), 
	"TOTAL_C005" VARCHAR2(50 BYTE), 
	"TOTAL_C006" VARCHAR2(50 BYTE), 
	"TOTAL_C007" VARCHAR2(50 BYTE), 
	"TOTAL_C008" VARCHAR2(50 BYTE), 
	"ERROR_MESSAGE" VARCHAR2(200 BYTE), 
	"IS_COMPLETED" VARCHAR2(1 BYTE), 
	"TOTAL_C009" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_MULTIADD_HEADER_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_MULTIADD_HEADER_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ES_ID" VARCHAR2(50 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"BATCH_ID" VARCHAR2(50 BYTE), 
	"TOTAL_COUNT" NUMBER, 
	"SUCCESS_COUNT" NUMBER, 
	"ERROR_COUNT" NUMBER, 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"TOTAL_C1" VARCHAR2(50 BYTE), 
	"TOTAL_C2" VARCHAR2(50 BYTE), 
	"TOTAL_C3" VARCHAR2(50 BYTE), 
	"TOTAL_C4" VARCHAR2(50 BYTE), 
	"TOTAL_C5" VARCHAR2(50 BYTE), 
	"TOTAL_C001" VARCHAR2(50 BYTE), 
	"TOTAL_C002" VARCHAR2(50 BYTE), 
	"TOTAL_C003" VARCHAR2(50 BYTE), 
	"TOTAL_C004" VARCHAR2(50 BYTE), 
	"TOTAL_C005" VARCHAR2(50 BYTE), 
	"TOTAL_C006" VARCHAR2(50 BYTE), 
	"TOTAL_C007" VARCHAR2(50 BYTE), 
	"TOTAL_C008" VARCHAR2(50 BYTE), 
	"ERROR_MESSAGE" VARCHAR2(200 BYTE), 
	"IS_COMPLETED" VARCHAR2(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_MULTIADD_LINE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_MULTIADD_LINE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ES_MULTIADD_HEADER_ID" VARCHAR2(50 BYTE), 
	"M_TRADEREL_ID" VARCHAR2(50 BYTE), 
	"M_COMP_SERV_NUMBER" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"C001" VARCHAR2(50 BYTE), 
	"C002" VARCHAR2(50 BYTE), 
	"C003" VARCHAR2(50 BYTE), 
	"C004" VARCHAR2(50 BYTE), 
	"C005" VARCHAR2(50 BYTE), 
	"C006" VARCHAR2(50 BYTE), 
	"C007" VARCHAR2(50 BYTE), 
	"C008" VARCHAR2(50 BYTE), 
	"IS_CLEAN" CHAR(1 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"M_TRADE_RELATIONSHIP_ID" VARCHAR2(50 BYTE), 
	"M_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"T_ES_USAGE_SUMMARY_ID" VARCHAR2(50 BYTE), 
	"C009" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_MULTIADD_LINE_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_MULTIADD_LINE_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ES_MULTIADD_HEADER_ID" VARCHAR2(50 BYTE), 
	"M_TRADEREL_ID" VARCHAR2(50 BYTE), 
	"M_COMP_SERV_NUMBER" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"C001" VARCHAR2(50 BYTE), 
	"C002" VARCHAR2(50 BYTE), 
	"C003" VARCHAR2(50 BYTE), 
	"C004" VARCHAR2(50 BYTE), 
	"C005" VARCHAR2(50 BYTE), 
	"C006" VARCHAR2(50 BYTE), 
	"C007" VARCHAR2(50 BYTE), 
	"C008" VARCHAR2(50 BYTE), 
	"IS_CLEAN" CHAR(1 BYTE), 
	"IMPORTED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(500 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"M_TRADE_RELATIONSHIP_ID" VARCHAR2(50 BYTE), 
	"M_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"T_ES_USAGE_SUMMARY_ID" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_USAGE_DETAIL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_USAGE_DETAIL" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"USAGE_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"TOTAL" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_USAGE_SUMMARY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_SS_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"TOTAL" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"M_TRADE_RELATIONSHIP_ID" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"REMARKS" VARCHAR2(100 BYTE), 
	"UNIT_COST" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_CHARGABLE" VARCHAR2(100 BYTE), 
	"NET_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_ES_USAGE_SUMMARY_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_SS_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"TOTAL" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"M_TRADE_RELATIONSHIP_ID" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"UNIT_COST" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"TOTAL_AMOUNT_CHARGABLE" VARCHAR2(100 BYTE), 
	"NET_AMOUNT_PAYABLE" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EWA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EWA" 
   (	"ID" VARCHAR2(50 BYTE), 
	"VERSION" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"INJECTION_VOLTAGE_CODE" VARCHAR2(100 BYTE), 
	"TOTAL_PROPOSED_UNITS" VARCHAR2(50 BYTE), 
	"TOAL_APPROVED_UNITS" VARCHAR2(50 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"TOTAL_INJECTION_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_INJECTION_OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"EWA_APPROVAL_NUMBER" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"TOTAL_DRAWAL_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"TOTAL_DRAWAL_OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"SELLER_IS_CAPTIVE" CHAR(1 BYTE), 
	"AGREEMENT_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EWA_LINE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EWA_LINE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_EWA_ID" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"INJECTION_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INJECTION_OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"DRAWAL_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"DRAWAL_OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"EWA_LINE_CHANGE_CODE" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PROPOSED_UNITS" VARCHAR2(50 BYTE), 
	"APPROVED_UNITS" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"SHARE_PERCENTAGE" FLOAT(126), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE) DEFAULT '01', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C2" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C3" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C4" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C5" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C2" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C3" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C4" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C5" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C2" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C3" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C4" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C5" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C2" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C3" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C4" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C5" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C2" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C3" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C4" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C5" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE079224723396
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE079224723396" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_01062021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_01062021" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_011220
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_011220" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_02022021
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_02022021" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_021120
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_021120" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_030920
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_030920" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_039204390196
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_039204390196" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_079204740038
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_079204740038" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_081220
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_081220" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_30072020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_30072020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5), 
	"OPEN_C2" NUMBER(20,5), 
	"OPEN_C3" NUMBER(20,5), 
	"OPEN_C4" NUMBER(20,5), 
	"OPEN_C5" NUMBER(20,5), 
	"OPEN_TOTAL_UNITS" NUMBER(20,5), 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5), 
	"INCR_EA1_C2" NUMBER(20,5), 
	"INCR_EA1_C3" NUMBER(20,5), 
	"INCR_EA1_C4" NUMBER(20,5), 
	"INCR_EA1_C5" NUMBER(20,5), 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5), 
	"DECR_EA1_C2" NUMBER(20,5), 
	"DECR_EA1_C3" NUMBER(20,5), 
	"DECR_EA1_C4" NUMBER(20,5), 
	"DECR_EA1_C5" NUMBER(20,5), 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5), 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5), 
	"INCR_HT_C2" NUMBER(20,5), 
	"INCR_HT_C3" NUMBER(20,5), 
	"INCR_HT_C4" NUMBER(20,5), 
	"INCR_HT_C5" NUMBER(20,5), 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5), 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5), 
	"CURR_C2" NUMBER(20,5), 
	"CURR_C3" NUMBER(20,5), 
	"CURR_C4" NUMBER(20,5), 
	"CURR_C5" NUMBER(20,5), 
	"CURR_TOTAL_UNITS" NUMBER(20,5), 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_BANKING_BALANCE_SRC_29_JUN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_SRC_29_JUN" 
   (	"IMPORT_RESULT" VARCHAR2(200 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(100 BYTE), 
	"OPEN_C1" NUMBER, 
	"OPEN_C2" NUMBER, 
	"OPEN_C3" NUMBER, 
	"OPEN_C4" NUMBER, 
	"OPEN_C5" NUMBER, 
	"OPEN_TOTAL_UNITS" NUMBER, 
	"INCR_EA1_C1" NUMBER, 
	"INCR_EA1_C2" NUMBER, 
	"INCR_EA1_C3" NUMBER, 
	"INCR_EA1_C4" NUMBER, 
	"INCR_EA1_C5" NUMBER, 
	"INCR_EA1_TOTAL_UNITS" CHAR(1 BYTE), 
	"DECR_EA1_C1" NUMBER, 
	"DECR_EA1_C2" NUMBER, 
	"DECR_EA1_C3" NUMBER, 
	"DECR_EA1_C4" NUMBER, 
	"DECR_EA1_C5" NUMBER, 
	"DECR_EA1_TOTAL_UNITS" CHAR(1 BYTE), 
	"INCR_HT_C1" NUMBER, 
	"INCR_HT_C2" NUMBER, 
	"INCR_HT_C3" NUMBER, 
	"INCR_HT_C4" NUMBER, 
	"INCR_HT_C5" NUMBER, 
	"INCR_HT_TOTAL_UNITS" CHAR(1 BYTE), 
	"CURR_C1" NUMBER, 
	"CURR_C2" NUMBER, 
	"CURR_C3" NUMBER, 
	"CURR_C4" NUMBER, 
	"CURR_C5" NUMBER, 
	"CURR_TOTAL_UNITS" NUMBER, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_LAPSED_BALANCE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C2" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C3" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C4" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C5" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C2" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C3" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C4" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C5" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C2" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C3" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C4" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C5" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C2" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C3" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C4" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C5" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C2" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C3" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C4" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C5" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_SURPLUS_STB_BALANCE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(500 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"OPEN_C1" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C2" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C3" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C4" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_C5" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"OPEN_REMARKS" VARCHAR2(500 BYTE), 
	"OPEN_UPDATE_BY" VARCHAR2(100 BYTE), 
	"OPEN_UPDATE_DT" DATE, 
	"INCR_EA1_C1" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C2" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C3" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C4" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_C5" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_EA1_UPDATE_DT" DATE, 
	"DECR_EA1_C1" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C2" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C3" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C4" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_C5" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"DECR_EA1_REMARKS" VARCHAR2(500 BYTE), 
	"DECR_EA1_SRC_ID" VARCHAR2(50 BYTE), 
	"DECR_EA1_UPDATE_BY" VARCHAR2(100 BYTE), 
	"DECR_EA1_UPDATE_DT" DATE, 
	"INCR_HT_C1" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C2" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C3" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C4" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_C5" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"INCR_HT_REMARKS" VARCHAR2(500 BYTE), 
	"INCR_HT_SRC_ID" VARCHAR2(50 BYTE), 
	"INCR_HT_UPDATE_BY" VARCHAR2(100 BYTE), 
	"INCR_HT_UPDATE_DT" DATE, 
	"CURR_C1" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C2" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C3" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C4" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_C5" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_TOTAL_UNITS" NUMBER(20,5) DEFAULT 0.0, 
	"CURR_REMARKS" VARCHAR2(500 BYTE), 
	"CURR_UPDATE_DT" DATE, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_EXS_SURPLUS_STB_SRC_29_JUN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_SRC_29_JUN" 
   (	"IMPORT_RESULT" VARCHAR2(200 BYTE), 
	"ID" VARCHAR2(50 BYTE), 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_NUM" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(100 BYTE), 
	"BANKING_SERVICE_NUM" VARCHAR2(100 BYTE), 
	"OPEN_C1" NUMBER, 
	"OPEN_C2" NUMBER, 
	"OPEN_C3" NUMBER, 
	"OPEN_C4" NUMBER, 
	"OPEN_C5" NUMBER, 
	"OPEN_TOTAL_UNITS" NUMBER, 
	"INCR_EA1_C1" NUMBER, 
	"INCR_EA1_C2" NUMBER, 
	"INCR_EA1_C3" NUMBER, 
	"INCR_EA1_C4" NUMBER, 
	"INCR_EA1_C5" NUMBER, 
	"INCR_EA1_TOTAL_UNITS" CHAR(1 BYTE), 
	"DECR_EA1_C1" NUMBER, 
	"DECR_EA1_C2" NUMBER, 
	"DECR_EA1_C3" NUMBER, 
	"DECR_EA1_C4" NUMBER, 
	"DECR_EA1_C5" NUMBER, 
	"DECR_EA1_TOTAL_UNITS" CHAR(1 BYTE), 
	"INCR_HT_C1" NUMBER, 
	"INCR_HT_C2" NUMBER, 
	"INCR_HT_C3" NUMBER, 
	"INCR_HT_C4" NUMBER, 
	"INCR_HT_C5" NUMBER, 
	"INCR_HT_TOTAL_UNITS" CHAR(1 BYTE), 
	"CURR_C1" NUMBER, 
	"CURR_C2" NUMBER, 
	"CURR_C3" NUMBER, 
	"CURR_C4" NUMBER, 
	"CURR_C5" NUMBER, 
	"CURR_TOTAL_UNITS" NUMBER, 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"ENABLED" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_APPLICATION_STATUS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_APPLICATION_STATUS" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"GC_STATUS_TYPE_CODE" VARCHAR2(50 BYTE), 
	"GC_STATUS_UPDATE_DATE" VARCHAR2(50 BYTE), 
	"GC_STATUS_UPDATE_BY" VARCHAR2(50 BYTE), 
	"GC_STATUS_REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_CHECKLIST
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_CHECKLIST" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"CHECKLIST_CODE" VARCHAR2(50 BYTE), 
	"IS_COMPLETE" CHAR(1 BYTE), 
	"COMPLETED_DT" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IS_SUBMITTED" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_GEN_UNIT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_GEN_UNIT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"CAPACITY" VARCHAR2(25 BYTE), 
	"MAKE_CODE" VARCHAR2(50 BYTE), 
	"MW_RATING" VARCHAR2(50 BYTE), 
	"MV_RATING" VARCHAR2(50 BYTE), 
	"KV_RATING" VARCHAR2(50 BYTE), 
	"DAMPING_FACTOR" VARCHAR2(50 BYTE), 
	"AMATEUR_RESISTANCE" VARCHAR2(50 BYTE), 
	"DIRECT_ASSISTANCE_REACTANCE" VARCHAR2(50 BYTE), 
	"NEGATIVE_SEQUENCE_REACTANCE" VARCHAR2(50 BYTE), 
	"ZERO_SEQUENCE_REACTANCE" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"WINDING_CONNECTION" VARCHAR2(50 BYTE), 
	"MASS_NUMBER" VARCHAR2(50 BYTE), 
	"STIFFNESS_COEFFICIENT" VARCHAR2(50 BYTE), 
	"SERIAL_NO" VARCHAR2(1000 BYTE), 
	"ROTOR_DIA" VARCHAR2(25 BYTE), 
	"HUB_HEIGHT" VARCHAR2(25 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_ID_TABLEA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_ID_TABLEA" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"CLASS_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"NUMBER_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"VALUE_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"AMOUNT_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"NUMBER_OF_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_WITH_EQUITY" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_ID_TABLEB
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_ID_TABLEB" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"CLASS_OF_SHAREHOLDER" VARCHAR2(50 BYTE), 
	"NUMBER_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"VALUE_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"AMOUNT_OF_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"NUMBER_OF_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_EQUTIY_SHARES" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_RIGHTS" VARCHAR2(50 BYTE), 
	"PERCT_IN_VOTING_WITH_EQUITY" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_LOAN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_LOAN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"LOAN_ORIGIN" VARCHAR2(100 BYTE), 
	"SOURCE_NAME" VARCHAR2(50 BYTE), 
	"SOURCE_ADDRESS" VARCHAR2(50 BYTE), 
	"LOAN_AMOUNT" VARCHAR2(50 BYTE), 
	"CURRENCY" VARCHAR2(50 BYTE), 
	"EXCHANGE_RATE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_QUANTUM_ALLOCATION
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_ORG_ID" VARCHAR2(50 BYTE), 
	"CAPTIVE_COMPANY_NAME" VARCHAR2(50 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"SHARED_PERCENTAGE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GC_TRANSFORMERS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GC_TRANSFORMERS" 
   (	"ID" VARCHAR2(50 BYTE), 
	"GC_ID" VARCHAR2(50 BYTE), 
	"NAME" VARCHAR2(100 BYTE), 
	"MVA_RATING" VARCHAR2(50 BYTE), 
	"PRIMARY_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"SECONDARY_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"COOLING_TYPE" VARCHAR2(50 BYTE), 
	"WINDING_CONFIGURATION" VARCHAR2(50 BYTE), 
	"BREAKER_RATING" VARCHAR2(50 BYTE), 
	"TAP_SETTING" VARCHAR2(50 BYTE), 
	"TAP_NUMBER_MAX" VARCHAR2(50 BYTE), 
	"TAP_NUMBER_MIN" VARCHAR2(50 BYTE), 
	"TAP_RATIO" VARCHAR2(50 BYTE), 
	"TAP_STEP" VARCHAR2(50 BYTE), 
	"TAP_VOLTAGE_MAX" VARCHAR2(50 BYTE), 
	"TAP_VOLTAGE_MIN" VARCHAR2(50 BYTE), 
	"PHASE_DISPLACEMENT" VARCHAR2(50 BYTE), 
	"IMPEDENCE_PERCENTAGE" VARCHAR2(50 BYTE), 
	"LEAK_REACTANCE" VARCHAR2(50 BYTE), 
	"RESISTANCE" VARCHAR2(50 BYTE), 
	"REACTANCE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_OTHER_CHARGES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_OTHER_CHARGES" 
   (	"ID" VARCHAR2(100 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"ENABLED" VARCHAR2(1 BYTE) DEFAULT 'Y', 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_OTHER_SUB_CHARGES
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_OTHER_SUB_CHARGES" 
   (	"ID" VARCHAR2(100 BYTE), 
	"T_GEN_OTHER_CHARGE_ID" VARCHAR2(100 BYTE), 
	"CHARGE_CODE" VARCHAR2(100 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(100 BYTE), 
	"UNIT_CHARGE" VARCHAR2(100 BYTE), 
	"TOTAL_CHARGE" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"ENABLED" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"DISP_FUEL_TYPE_GROUP" VARCHAR2(50 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"DOC_ID" VARCHAR2(50 BYTE), 
	"EXCESS_UNIT_TYPE" VARCHAR2(50 BYTE), 
	"DISP_PP_OP_STATUS" VARCHAR2(50 BYTE), 
	"DISP_CAPACITY" VARCHAR2(50 BYTE), 
	"DISP_TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"DISP_METER_NUMBER" VARCHAR2(50 BYTE), 
	"STMT_REMARKS" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_0029_0716
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_0029_0716" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"DISP_FUEL_TYPE_GROUP" VARCHAR2(50 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"DOC_ID" VARCHAR2(50 BYTE), 
	"EXCESS_UNIT_TYPE" VARCHAR2(50 BYTE), 
	"DISP_PP_OP_STATUS" VARCHAR2(50 BYTE), 
	"DISP_CAPACITY" VARCHAR2(50 BYTE), 
	"DISP_TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"DISP_METER_NUMBER" VARCHAR2(50 BYTE), 
	"STMT_REMARKS" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_059414600129
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_059414600129" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"DISP_FUEL_TYPE_GROUP" VARCHAR2(50 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE), 
	"DOC_ID" VARCHAR2(50 BYTE), 
	"EXCESS_UNIT_TYPE" VARCHAR2(50 BYTE), 
	"DISP_PP_OP_STATUS" VARCHAR2(50 BYTE), 
	"DISP_CAPACITY" VARCHAR2(50 BYTE), 
	"DISP_TOTAL_CAPACITY" VARCHAR2(50 BYTE), 
	"DISP_METER_NUMBER" VARCHAR2(50 BYTE), 
	"STMT_REMARKS" VARCHAR2(2000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_MR_IDS" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MACHINE_CAPACITY" VARCHAR2(50 BYTE), 
	"STMT_GEN_DATE" DATE, 
	"STMT_MONTH" VARCHAR2(50 BYTE), 
	"STMT_YEAR" VARCHAR2(50 BYTE), 
	"INIT_STMT_DT" DATE, 
	"FINAL_STMT_DT" DATE, 
	"RKVAH_INIT" VARCHAR2(50 BYTE), 
	"RKVAH_FINAL" VARCHAR2(50 BYTE), 
	"RKVAH_DIFF" VARCHAR2(50 BYTE), 
	"RKVAH_UNITS" VARCHAR2(50 BYTE), 
	"KVAH_INIT" VARCHAR2(50 BYTE), 
	"KVAH_FINAL" VARCHAR2(50 BYTE), 
	"KVAH_DIFF" VARCHAR2(50 BYTE), 
	"KVAH_UNITS" VARCHAR2(50 BYTE), 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_SERVICE_ID" VARCHAR2(50 BYTE), 
	"DISP_COMPANY_NAME" VARCHAR2(100 BYTE), 
	"DISP_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"INJECTING_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DISP_ORG_NAME" VARCHAR2(100 BYTE), 
	"POWER_FACTOR" VARCHAR2(50 BYTE), 
	"NET_GENERATION" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGED_AMOUNT" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"PENALTY_RATE" VARCHAR2(100 BYTE), 
	"COMMISSION_DATE" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"FILE_NAME" VARCHAR2(50 BYTE), 
	"DISP_FUEL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"DISP_FUEL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"NET_PAYABLE" VARCHAR2(100 BYTE), 
	"TARIFF_RATE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_CODE" VARCHAR2(100 BYTE), 
	"PLANT_CLASS_TYPE_DESC" VARCHAR2(100 BYTE), 
	"TARIFF_NET_AMOUNT" VARCHAR2(100 BYTE), 
	"IS_STB" VARCHAR2(100 BYTE), 
	"INJECTING_VOLTAGE_DESC" VARCHAR2(100 BYTE), 
	"DISP_ORG_CODE" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" VARCHAR2(100 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(150 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(150 BYTE), 
	"M_FEEDER_ID" VARCHAR2(150 BYTE), 
	"M_FEEDER_NAME" VARCHAR2(150 BYTE), 
	"TYPE_OF_SS" VARCHAR2(150 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(100 BYTE), 
	"IS_REC" CHAR(1 BYTE), 
	"TOTAL_SS_LOSS" NUMBER, 
	"SS_LOSS_PERCENT" NUMBER, 
	"IS_METER_CHANGE" CHAR(1 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_CHARGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_CHARGE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_CHARGE_0029_0716
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_CHARGE_0029_0716" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_CHARGE_059414600129
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_CHARGE_059414600129" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_CHARGE_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_CHARGE_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"CHARGE_CODE" VARCHAR2(50 BYTE), 
	"CHARGE_DESC" VARCHAR2(100 BYTE), 
	"CHARGE_TYPE_CODE" VARCHAR2(50 BYTE), 
	"UNIT_CHARGE" VARCHAR2(50 BYTE), 
	"TOTAL_CHARGES" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_SLOT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_SLOT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"BANKED_BALANCE" VARCHAR2(50 BYTE), 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_SLOT_0029_0716
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_SLOT_0029_0716" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"BANKED_BALANCE" VARCHAR2(50 BYTE), 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_SLOT_040619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_SLOT_040619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"BANKED_BALANCE" VARCHAR2(50 BYTE), 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GEN_STMT_SLOT_BKB4FIX_280619
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GEN_STMT_SLOT_BKB4FIX_280619" 
   (	"ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"T_GEN_STMT_ID" VARCHAR2(50 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"BANKED_BALANCE" VARCHAR2(50 BYTE), 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"CREATED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GRID_CONNECTIVITY
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GRID_CONNECTIVITY" 
   (	"ID" VARCHAR2(50 BYTE), 
	"APPLICATION_NUMBER" VARCHAR2(50 BYTE), 
	"GENERATING_TYPE_NAME" VARCHAR2(50 BYTE), 
	"PLANT_NAME" VARCHAR2(50 BYTE), 
	"COMPANY_NAME" VARCHAR2(50 BYTE), 
	"TEMP_HT_SUPPLY_NUMBER" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_COMMISSION_DT" DATE, 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"CLASS_VOLTAGE_PHASE" VARCHAR2(50 BYTE), 
	"CLASS_VOLTAGE_FREQUENCY" VARCHAR2(50 BYTE), 
	"AVAILED_HT_SUPPLY" VARCHAR2(50 BYTE), 
	"AVAILED_SANCTIONED_DEMAND" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"FUEL_LINKAGE_ARRANGED" VARCHAR2(50 BYTE), 
	"FUEL_LINKAGE_DETAILS" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"LINE1" VARCHAR2(100 BYTE), 
	"CITY" VARCHAR2(50 BYTE), 
	"TOWN" VARCHAR2(50 BYTE), 
	"STATE_CODE" VARCHAR2(50 BYTE), 
	"PINCODE" VARCHAR2(50 BYTE), 
	"VILLAGE" VARCHAR2(50 BYTE), 
	"TALUK_CODE" VARCHAR2(50 BYTE), 
	"DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"PLS_SF_NO" VARCHAR2(50 BYTE), 
	"PL_VILLAGE" VARCHAR2(50 BYTE), 
	"PL_TOWN" VARCHAR2(50 BYTE), 
	"PL_TALUK_CODE" VARCHAR2(50 BYTE), 
	"PL_DISTRICT_CODE" VARCHAR2(50 BYTE), 
	"WIND_PASS_CODE" VARCHAR2(50 BYTE), 
	"WIND_ZONE_AREA_CODE" VARCHAR2(50 BYTE), 
	"SCO_TAMILNADU" VARCHAR2(50 BYTE), 
	"SCO_MINISTRY" VARCHAR2(50 BYTE), 
	"SCO_CIVIL" VARCHAR2(50 BYTE), 
	"CG_INDUSTRY_TYPE" VARCHAR2(50 BYTE), 
	"CG_SUPPORT_FUEL" VARCHAR2(50 BYTE), 
	"CG_IS_PARALLEL_RUN" VARCHAR2(50 BYTE), 
	"CG_IS_STANDBY" VARCHAR2(50 BYTE), 
	"CG_CYCLE" VARCHAR2(50 BYTE), 
	"CG_HAS_PROOF" VARCHAR2(50 BYTE), 
	"PLANT_CAPACITY" VARCHAR2(50 BYTE), 
	"ANNUAL_EXPECTED_QUANTUM" VARCHAR2(50 BYTE), 
	"EXPECTED_CUF" VARCHAR2(50 BYTE), 
	"AUXILIARY_CONSUMPTION" VARCHAR2(50 BYTE), 
	"INDUSTRIAL_CONSUMPTION" VARCHAR2(50 BYTE), 
	"PER_UNIT_COST" VARCHAR2(50 BYTE), 
	"FIRM_POWER" VARCHAR2(50 BYTE), 
	"INFIRM_POWER" VARCHAR2(50 BYTE), 
	"PROPOSED_POWER_STB" VARCHAR2(50 BYTE), 
	"PROPOSED_POWER_CAPTIVE" VARCHAR2(50 BYTE), 
	"PROPOSED_POWER_3PTY" VARCHAR2(50 BYTE), 
	"ID_TOTAL_COST" VARCHAR2(50 BYTE), 
	"ID_TOTAL_CURRENCY" VARCHAR2(50 BYTE), 
	"ID_TOTAL_EXCHANGE_RATE" VARCHAR2(50 BYTE), 
	"ID_PROPOSED_DEBT_EQUITY_RATIO" VARCHAR2(50 BYTE), 
	"FINAL_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"FINAL_FEEDER_ID" VARCHAR2(50 BYTE), 
	"FINAL_SS_TYPE_NAME" VARCHAR2(50 BYTE), 
	"FINAL_FEEDER_TYPE_NAME" VARCHAR2(50 BYTE), 
	"GEN_SERVICE_NUMBER" VARCHAR2(50 BYTE), 
	"GEN_SERVICE_APPROVAL_NUMBER" VARCHAR2(50 BYTE), 
	"GEN_SERVICE_DATE" DATE, 
	"FINAL_COD" DATE, 
	"FINAL_COPD" DATE, 
	"FINAL_IS_STB" CHAR(1 BYTE), 
	"FINAL_IS_WHEELING" CHAR(1 BYTE), 
	"FINAL_PP_RATE" VARCHAR2(50 BYTE), 
	"FINAL_STB_TARIFF_ORDER" VARCHAR2(50 BYTE), 
	"FINAL_STB_TENDER_NUMBER" VARCHAR2(50 BYTE), 
	"FINAL_STB_TENDER_DATE" DATE, 
	"FINAL_WHEELING_FROM_DATE" DATE, 
	"FINAL_WHEELING_TO_DATE" DATE, 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"M_ORG_ID" VARCHAR2(100 BYTE), 
	"GENERATING_TYPE_ISCAPTIVE" VARCHAR2(50 BYTE), 
	"METER_CT1" VARCHAR2(50 BYTE), 
	"METER_CT2" VARCHAR2(50 BYTE), 
	"METER_CT3" VARCHAR2(50 BYTE), 
	"METER_PT1" VARCHAR2(50 BYTE), 
	"METER_PT2" VARCHAR2(50 BYTE), 
	"METER_PT3" VARCHAR2(50 BYTE), 
	"METER_NUMBER" VARCHAR2(50 BYTE), 
	"METER_MAKE_CODE" VARCHAR2(50 BYTE), 
	"ACCURACY_CLASS_CODE" VARCHAR2(50 BYTE), 
	"IS_ABTMETER" CHAR(1 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"MODEM_NUMBER" VARCHAR2(50 BYTE), 
	"PL_PINCODE" VARCHAR2(50 BYTE), 
	"AVAILED_HT_SUPPLY_NO" VARCHAR2(50 BYTE), 
	"FINAL_ORG_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"PARALLEL_OPERATION" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_GRID_CONN_APPLN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_GRID_CONN_APPLN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"APPLN_NO" VARCHAR2(50 BYTE), 
	"APPLIED_DATE" DATE, 
	"APPROVAL_DATE" DATE, 
	"ACTIVATED_DATE" DATE, 
	"STATUS" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(300 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_IEX_NOC
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_IEX_NOC" 
   (	"ID" VARCHAR2(50 BYTE), 
	"TYPE_CODE" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"EXEMPT_RC" CHAR(1 BYTE), 
	"HAS_DUES" CHAR(1 BYTE), 
	"DUE_DETAILS" VARCHAR2(500 BYTE), 
	"PENDING_CASE_DETAILS" VARCHAR2(500 BYTE), 
	"TECHNICAL_FEASIBILITY_DETAILS" VARCHAR2(500 BYTE), 
	"APPROVED_CAPACITY" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"APPLIED_DT" DATE, 
	"MODIFIED_DATE" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_INPRINCIPLE_APPLN
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"IS_CAPTIVE" CHAR(1 BYTE) DEFAULT 'N', 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"FROM_MONTH" VARCHAR2(100 BYTE), 
	"FROM_YEAR" VARCHAR2(100 BYTE), 
	"TO_MONTH" VARCHAR2(100 BYTE), 
	"TO_YEAR" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"APPLIED_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_INPRINCIPLE_APPLN_LINE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_INPRINCIPLE_APPLN_ID" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"INJECTION_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INJECTION_OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"DRAWAL_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"DRAWAL_OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PROPOSED_UNITS" VARCHAR2(50 BYTE), 
	"APPROVED_UNITS" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_IPA_STANDING_CLEARACE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_IPA_STANDING_CLEARACE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_IPA_ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"T_IEX_NOC_ID" VARCHAR2(100 BYTE), 
	"T_SC_ID" VARCHAR2(50 BYTE), 
	"NOC_IEX_STATUS" VARCHAR2(50 BYTE), 
	"SC_STATUS" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"QUANTUM" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_JOB_HDR
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_JOB_HDR" 
   (	"ID" VARCHAR2(50 BYTE), 
	"JOB_STATUS_CODE" VARCHAR2(100 BYTE), 
	"JOB_CODE" VARCHAR2(100 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(50 BYTE), 
	"O_RESULT_CODE" VARCHAR2(50 BYTE), 
	"O_RESULT_DESC" VARCHAR2(200 BYTE), 
	"CREATED_DATE" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" VARCHAR2(50 BYTE), 
	"CREATED_NAME" VARCHAR2(50 BYTE), 
	"MODIFIED_NAME" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_HDRSLOT_DWNLD_03072020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_HDRSLOT_DWNLD_03072020" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_METER_READING_HDR_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_HDR
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_HDR" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"IMP_BATCH_ID" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE, 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"INIT_READING_DT" DATE, 
	"FINAL_READING_DT" DATE, 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"RKVAH_DIFF" VARCHAR2(100 BYTE), 
	"RKVAH_UNITS" VARCHAR2(100 BYTE), 
	"KVAH_DIFF" VARCHAR2(100 BYTE), 
	"KVAH_UNITS" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"NET_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GS_BATCH_ID" VARCHAR2(100 BYTE), 
	"M_GEN_STMT_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"IMPORTED_ASIS" CHAR(1 BYTE), 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_HDR_0029_0716
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_HDR_0029_0716" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"IMP_BATCH_ID" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE, 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"INIT_READING_DT" DATE, 
	"FINAL_READING_DT" DATE, 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"RKVAH_DIFF" VARCHAR2(100 BYTE), 
	"RKVAH_UNITS" VARCHAR2(100 BYTE), 
	"KVAH_DIFF" VARCHAR2(100 BYTE), 
	"KVAH_UNITS" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"NET_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GS_BATCH_ID" VARCHAR2(100 BYTE), 
	"M_GEN_STMT_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"IMPORTED_ASIS" CHAR(1 BYTE), 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_HDR_019104041686
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_HDR_019104041686" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_METER_ID" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"IMP_BATCH_ID" VARCHAR2(100 BYTE), 
	"MF" VARCHAR2(50 BYTE), 
	"SYS_DT" DATE, 
	"READING_MONTH" VARCHAR2(50 BYTE), 
	"READING_YEAR" VARCHAR2(50 BYTE), 
	"INIT_READING_DT" DATE, 
	"FINAL_READING_DT" DATE, 
	"TOTAL_IMPORT_GEN" VARCHAR2(50 BYTE), 
	"TOTAL_EXPORT_GEN" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"RKVAH_DIFF" VARCHAR2(100 BYTE), 
	"RKVAH_UNITS" VARCHAR2(100 BYTE), 
	"KVAH_DIFF" VARCHAR2(100 BYTE), 
	"KVAH_UNITS" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_RKVAH_FINAL" VARCHAR2(100 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(100 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(100 BYTE), 
	"NET_GEN_UNITS" VARCHAR2(100 BYTE), 
	"GS_BATCH_ID" VARCHAR2(100 BYTE), 
	"M_GEN_STMT_ID" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"MERGE_WITH_NEXT_BILLING" CHAR(1 BYTE), 
	"IMPORTED_ASIS" CHAR(1 BYTE), 
	"IS_METER_CHANGE" CHAR(1 BYTE), 
	"MR_SOURCE_CODE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_SLOT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_SLOT" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_METER_READING_HDR_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_SLOT_019104041686
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_SLOT_019104041686" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_METER_READING_HDR_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_SLOT_059414600125
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_SLOT_059414600125" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_METER_READING_HDR_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_METER_READING_SLOT_059414600132
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_METER_READING_SLOT_059414600132" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_METER_READING_HDR_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(500 BYTE), 
	"REF_NUMBER" VARCHAR2(100 BYTE), 
	"SLOT_CODE" VARCHAR2(50 BYTE), 
	"IMP_INIT" VARCHAR2(50 BYTE), 
	"IMP_FINAL" VARCHAR2(50 BYTE), 
	"IMP_DIFF" VARCHAR2(50 BYTE), 
	"IMP_UNITS" VARCHAR2(50 BYTE), 
	"EXP_INIT" VARCHAR2(50 BYTE), 
	"EXP_FINAL" VARCHAR2(50 BYTE), 
	"EXP_DIFF" VARCHAR2(50 BYTE), 
	"EXP_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"NET_UNITS" VARCHAR2(100 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_NEW_SERVICE_EXCESS_BANKING
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_NEW_SERVICE_EXCESS_BANKING" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_COMPANY_ID" VARCHAR2(50 BYTE), 
	"BANKING_SERVICE_ID" VARCHAR2(50 BYTE), 
	"C1" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C2" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C3" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C4" VARCHAR2(50 BYTE) DEFAULT 0, 
	"C5" VARCHAR2(50 BYTE) DEFAULT 0, 
	"REMARKS" VARCHAR2(500 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"CURR_C1" VARCHAR2(50 BYTE), 
	"CURR_C2" VARCHAR2(50 BYTE), 
	"CURR_C3" VARCHAR2(50 BYTE), 
	"CURR_C4" VARCHAR2(50 BYTE), 
	"CURR_C5" VARCHAR2(50 BYTE), 
	"CALCULATED" VARCHAR2(1 BYTE), 
	"SURPLUS_C1" VARCHAR2(50 BYTE), 
	"SURPLUS_C2" VARCHAR2(50 BYTE), 
	"SURPLUS_C3" VARCHAR2(50 BYTE), 
	"SURPLUS_C4" VARCHAR2(50 BYTE), 
	"SURPLUS_C5" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_NOC
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_NOC" 
   (	"ID" VARCHAR2(50 BYTE), 
	"TYPE_CODE" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"EXEMPT_RC" CHAR(1 BYTE), 
	"HAS_DUES" CHAR(1 BYTE), 
	"DUE_DETAILS" VARCHAR2(500 BYTE), 
	"PENDING_CASE_DETAILS" VARCHAR2(500 BYTE), 
	"TECHNICAL_FEASIBILITY_DETAILS" VARCHAR2(500 BYTE), 
	"APPROVED_CAPACITY" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"AGREEMENT_DT" DATE, 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"APPLIED_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_NOC_GENERATOR
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_NOC_GENERATOR" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"T_INPRINCIPLE_APPLN_ID" VARCHAR2(50 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"CAPACITY" VARCHAR2(50 BYTE), 
	"AUXILIARY_CONSUMPTION" VARCHAR2(50 BYTE), 
	"IN_HOUSE_CONSUMPTION" VARCHAR2(50 BYTE), 
	"EX_BUS" VARCHAR2(50 BYTE), 
	"APPROVED_POWER_CAPACITY" VARCHAR2(50 BYTE), 
	"T_INPRIN_APPLN_QUANTUM" VARCHAR2(50 BYTE), 
	"T_INPRIN_APPLN_APPRV_DATE" VARCHAR2(50 BYTE), 
	"IS_ONLINE_DATA_MONITORING" CHAR(1 BYTE), 
	"IS_TANGEDCO" CHAR(1 BYTE), 
	"TANGEDCO_REF_NUMBER" VARCHAR2(50 BYTE), 
	"TANGEDCO_APPROVED_QUANTUM" VARCHAR2(50 BYTE), 
	"TANGEDCO_DATED" DATE, 
	"TANGEDCO_TILL_DATE" DATE, 
	"CAPTIVE_QUANTUM" VARCHAR2(50 BYTE), 
	"THIRD_PARTY_QUANTUM" VARCHAR2(50 BYTE), 
	"TRADER_QUANTUM" VARCHAR2(50 BYTE), 
	"OTHER_QUANTUM" VARCHAR2(50 BYTE), 
	"TOTAL_POWER_SALE_COMMITMENTS" VARCHAR2(50 BYTE), 
	"MAXIMUM_SURPLUS_QUANTUM" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"APPLIED_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_NOC_GENERATOR_LINE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_NOC_GENERATOR_LINE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"T_NOC_GENERATOR_ID" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"DRAWAL_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"INJECTION_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INJECTION_OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"DRAWAL_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"DRAWAL_OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PROPOSED_UNITS" VARCHAR2(50 BYTE), 
	"APPROVED_UNITS" VARCHAR2(50 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_OAA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_OAA" 
   (	"ID" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"BUYER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"BUYER_END_UTILITY" VARCHAR2(100 BYTE), 
	"DRAWAL_TRANS_SS_ID" VARCHAR2(50 BYTE), 
	"DRAWAL_TRANS_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"DRAWAL_TRANS_FEEDER_ID" VARCHAR2(50 BYTE), 
	"DRAWAL_DIST_SS_ID" VARCHAR2(50 BYTE), 
	"DRAWAL_DIST_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"AGMT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FROM_DT" DATE, 
	"TO_DT" DATE, 
	"PROPOSED_TOTAL_UNITS" VARCHAR2(50 BYTE), 
	"APPROVED_TOTAL_UNITS" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"SELLER_END_ORG_ID" VARCHAR2(100 BYTE), 
	"SELLER_END_UTILITY" VARCHAR2(100 BYTE), 
	"INJECTION_TRANS_SS_ID" VARCHAR2(50 BYTE), 
	"INJECTION_TRANS_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"INJECTION_TRANS_FEEDER_ID" VARCHAR2(50 BYTE), 
	"INJECTION_DIST_SS_ID" VARCHAR2(50 BYTE), 
	"INJECTION_DIST_VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"PAYMENT_TYPE_CODE" VARCHAR2(50 BYTE), 
	"PAYMENT_BANK_DETAILS" VARCHAR2(200 BYTE), 
	"PAYMENT_TXN_NO" VARCHAR2(50 BYTE), 
	"PAYMENT_DATE" VARCHAR2(50 BYTE), 
	"PAYMENT_AMOUNT" VARCHAR2(50 BYTE), 
	"LICENSEE" VARCHAR2(50 BYTE), 
	"C1_UNITS" VARCHAR2(50 BYTE), 
	"C2_UNITS" VARCHAR2(50 BYTE), 
	"C3_UNITS" VARCHAR2(50 BYTE), 
	"C4_UNITS" VARCHAR2(50 BYTE), 
	"C5_UNITS" VARCHAR2(50 BYTE), 
	"APPLIED_DT" DATE, 
	"APPROVED_DT" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"OAA_APPROVAL_NUMBER" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DT" DATE, 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DT" DATE, 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_DT" DATE, 
	"SELLER_IS_CAPTIVE" CHAR(1 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"PEAK_UNITS" VARCHAR2(100 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(100 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"SHARE_PERCENT" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_PAYMENT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_PAYMENT" 
   (	"ID" VARCHAR2(100 BYTE), 
	"CODE" VARCHAR2(100 BYTE), 
	"FROM_COMPANY_ID" VARCHAR2(100 BYTE), 
	"INVOICE_NUMBER" VARCHAR2(100 BYTE), 
	"INVOICE_DATE" DATE, 
	"BANK_NAME" VARCHAR2(100 BYTE), 
	"BRANCH_NAME" VARCHAR2(100 BYTE), 
	"MODE_OF_PAYMENT" VARCHAR2(100 BYTE), 
	"INSTRUMENT_NUMBER" VARCHAR2(100 BYTE), 
	"PAYMENT_DATE" DATE, 
	"AMOUNT" VARCHAR2(100 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"MODIFIED_BY" VARCHAR2(100 BYTE), 
	"MODIFIED_DATE" DATE, 
	"ENABLED" VARCHAR2(20 BYTE) DEFAULT 'Y', 
	"PAYMENT_CONTEXT_CODE" VARCHAR2(50 BYTE), 
	"CONTEXT_REF_NUMBER" VARCHAR2(150 BYTE), 
	"FROM_COMP_SERVICE_ID" VARCHAR2(150 BYTE), 
	"TO_COMPANY_ID" VARCHAR2(150 BYTE), 
	"TO_COMP_SERVICE_ID" VARCHAR2(150 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_PPA
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_PPA" 
   (	"ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"SELLER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_DATE" DATE, 
	"PROPOSED_CAPACITY" VARCHAR2(50 BYTE), 
	"APPROVED_CAPACITY" VARCHAR2(50 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FROM_MONTH" VARCHAR2(50 BYTE), 
	"TO_YEAR" VARCHAR2(50 BYTE), 
	"FROM_YEAR" VARCHAR2(50 BYTE), 
	"TO_MONTH" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"MODIFIDED_BY" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"AGREEMENT_PERIOD_CODE" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(100 BYTE), 
	"SHARE_PERCENTAGE" FLOAT(126), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"VOLTAGE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_PROCESS_GS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_PROCESS_GS" 
   (	"ID" VARCHAR2(100 BYTE), 
	"SYS_DT" DATE, 
	"STATUS" VARCHAR2(100 BYTE), 
	"START_DT" DATE, 
	"END_DT" DATE, 
	"REMARKS" VARCHAR2(200 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_PROCESS_LOG
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_PROCESS_LOG" 
   (	"ID" NUMBER(*,0), 
	"PROCESS_NAME" VARCHAR2(50 BYTE), 
	"LOG_DT" DATE, 
	"PROCESS_STATUS" VARCHAR2(50 BYTE), 
	"USER_ID" VARCHAR2(100 BYTE), 
	"T_ENERGY_SALE_ID" VARCHAR2(100 BYTE), 
	"GEN_COMP_ID" VARCHAR2(100 BYTE), 
	"GEN_SERVICE_ID" VARCHAR2(100 BYTE), 
	"GEN_EDC_ID" VARCHAR2(100 BYTE), 
	"PROCESS_ID" VARCHAR2(100 BYTE), 
	"ATTR1" VARCHAR2(20 BYTE), 
	"ATTR2" VARCHAR2(20 BYTE), 
	"ATTR3" VARCHAR2(20 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" TIMESTAMP (6), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" TIMESTAMP (6)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_STANDING_CLEARENCE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_STANDING_CLEARENCE" 
   (	"ID" VARCHAR2(50 BYTE), 
	"SLDC_NAME" VARCHAR2(50 BYTE), 
	"REGION" VARCHAR2(50 BYTE), 
	"BUYER_COMP_SERV_ID" VARCHAR2(50 BYTE), 
	"T_ES_INTENT_ID" VARCHAR2(50 BYTE), 
	"MAX_DRAWAL_CEILING" VARCHAR2(50 BYTE), 
	"CREATED_BY" VARCHAR2(50 BYTE), 
	"CREATED_DATE" DATE DEFAULT sysdate, 
	"APPROVAL_DATE" DATE, 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"FROM_MONTH" VARCHAR2(50 BYTE), 
	"TO_YEAR" VARCHAR2(50 BYTE), 
	"FROM_YEAR" VARCHAR2(50 BYTE), 
	"TO_MONTH" VARCHAR2(50 BYTE), 
	"STATE_TRANS_LOSS" VARCHAR2(50 BYTE), 
	"STATE_TRANS_LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"STATE_TRANS_CHARGES" VARCHAR2(50 BYTE), 
	"STATE_TRANS_CHARGES_PERCENT" VARCHAR2(50 BYTE), 
	"SCHEDULING_CHARGES" VARCHAR2(50 BYTE), 
	"SCHEDULING_CHARGES_PERCENT" VARCHAR2(50 BYTE), 
	"SYSTEM_OPR_CHARGES" VARCHAR2(50 BYTE), 
	"SYSTEM_OPR_CHARGES_PERCENT" VARCHAR2(50 BYTE), 
	"MODIFIED_BY" VARCHAR2(50 BYTE), 
	"MODIFIED_DATE" DATE, 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"CODE" VARCHAR2(50 BYTE), 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"M_FEEDER_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(50 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE), 
	"APPLIED_DT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_SUBSTATION_LOSS
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_SUBSTATION_LOSS" 
   (	"ID" VARCHAR2(100 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE) DEFAULT 'Y', 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE DEFAULT sysdate, 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE), 
	"FUEL_TYPE" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table T_SUBSTATION_LOSS_210121
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."T_SUBSTATION_LOSS_210121" 
   (	"ID" VARCHAR2(100 BYTE), 
	"BATCH_KEY" VARCHAR2(100 BYTE), 
	"M_ORG_ID" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_ID" VARCHAR2(50 BYTE), 
	"MONTH" VARCHAR2(50 BYTE), 
	"YEAR" VARCHAR2(50 BYTE), 
	"LOSS_PERCENT" VARCHAR2(50 BYTE), 
	"BULK_METER_READING" VARCHAR2(50 BYTE), 
	"TOTAL_ALL_WEGS" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DT" DATE, 
	"M_ORG_NAME" VARCHAR2(50 BYTE), 
	"M_SUBSTATION_NAME" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UDML_CML_DEL
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UDML_CML_DEL" 
   (	"ID" VARCHAR2(50 BYTE), 
	"M_SIGNUP_ID" VARCHAR2(50 BYTE), 
	"SELLER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"SELLER_END_EDC" VARCHAR2(200 BYTE), 
	"SELLER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"QUANTUM" VARCHAR2(50 BYTE), 
	"FROM_DATE_STR" VARCHAR2(25 BYTE), 
	"TO_DATE_STR" VARCHAR2(25 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"STATUS_CODE" VARCHAR2(50 BYTE), 
	"BUYER_COMPANY_NAME" VARCHAR2(200 BYTE), 
	"BUYER_END_EDC" VARCHAR2(200 BYTE), 
	"BUYER_COMPANY_SERVICE_NO" VARCHAR2(200 BYTE), 
	"M_BUYER_COMPANY_ID" VARCHAR2(50 BYTE), 
	"M_BUYER_COMP_SERVICE_ID" VARCHAR2(50 BYTE), 
	"REMARKS" VARCHAR2(100 BYTE), 
	"IS_CAPTIVE" CHAR(1 BYTE), 
	"SHARE_PERCENT" VARCHAR2(100 BYTE), 
	"CREATED_BY" VARCHAR2(100 BYTE), 
	"CREATED_DATE" DATE, 
	"C1" VARCHAR2(50 BYTE), 
	"C2" VARCHAR2(50 BYTE), 
	"C3" VARCHAR2(50 BYTE), 
	"C4" VARCHAR2(50 BYTE), 
	"C5" VARCHAR2(50 BYTE), 
	"ENABLED" CHAR(1 BYTE), 
	"PEAK_UNITS" VARCHAR2(50 BYTE), 
	"OFF_PEAK_UNITS" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_CODE" VARCHAR2(50 BYTE), 
	"INTERVAL_TYPE_NAME" VARCHAR2(100 BYTE), 
	"IMPORT_REMARKS" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UTILITY_CHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UTILITY_CHANGE" 
   (	"SERVICENO" VARCHAR2(20 BYTE), 
	"FUEL_TYPE_CODE" VARCHAR2(20 BYTE), 
	"FLOW_TYPE_CODE" VARCHAR2(20 BYTE), 
	"FROM_DATE" DATE, 
	"TO_DATE" DATE, 
	"REMARKS" VARCHAR2(100 BYTE), 
	"MONTH" VARCHAR2(20 BYTE), 
	"YEAR" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_03032020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_03032020" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_27022020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_27022020" 
   (	"EXPMDTOD4" VARCHAR2(15 BYTE), 
	"EXPMDDTTOD4" VARCHAR2(30 BYTE), 
	"EXPMDTOD5" VARCHAR2(15 BYTE), 
	"EXPMDDTTOD5" VARCHAR2(30 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(12 BYTE), 
	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER, 
	"SERVICENO" VARCHAR2(25 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(40 BYTE), 
	"IMP_INIT_S2" VARCHAR2(40 BYTE), 
	"IMP_INIT_S3" VARCHAR2(40 BYTE), 
	"IMP_INIT_S4" VARCHAR2(40 BYTE), 
	"IMP_INIT_S5" VARCHAR2(40 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(40 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(40 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(40 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(40 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(40 BYTE), 
	"EXP_INIT_S1" VARCHAR2(40 BYTE), 
	"EXP_INIT_S2" VARCHAR2(40 BYTE), 
	"EXP_INIT_S3" VARCHAR2(40 BYTE), 
	"EXP_INIT_S4" VARCHAR2(40 BYTE), 
	"EXP_INIT_S5" VARCHAR2(40 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(40 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(40 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(40 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(40 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(40 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(40 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(40 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(40 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(40 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(40 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(40 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(40 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(40 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(40 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(40 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(40 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(40 BYTE), 
	"IMPMD" VARCHAR2(15 BYTE), 
	"IMPMDDT" VARCHAR2(30 BYTE), 
	"IMPMDTOD1" VARCHAR2(15 BYTE), 
	"IMPMDDTTOD1" VARCHAR2(30 BYTE), 
	"IMPMDTOD2" VARCHAR2(15 BYTE), 
	"IMPMDDTTOD2" VARCHAR2(30 BYTE), 
	"IMPMDTOD3" VARCHAR2(15 BYTE), 
	"IMPMDDTTOD3" VARCHAR2(30 BYTE), 
	"IMPMDTOD4" VARCHAR2(15 BYTE), 
	"IMPMDDTTOD4" VARCHAR2(30 BYTE), 
	"IMPMDTOD5" VARCHAR2(15 BYTE), 
	"IMPMDDTTOD5" VARCHAR2(30 BYTE), 
	"EXPMD" VARCHAR2(15 BYTE), 
	"EXPMDDT" VARCHAR2(30 BYTE), 
	"EXPMDTOD1" VARCHAR2(15 BYTE), 
	"EXPMDDTTOD1" VARCHAR2(30 BYTE), 
	"EXPMDTOD2" VARCHAR2(15 BYTE), 
	"EXPMDDTTOD2" VARCHAR2(30 BYTE), 
	"EXPMDTOD3" VARCHAR2(15 BYTE), 
	"EXPMDDTTOD3" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_HISTORY_SLOT
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_HISTORY_SLOT_03FEB19
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_03FEB19" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"DOWNLOADSTATUS" CHAR(3 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_HISTORY_SLOT_BKP1118
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_BKP1118" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 30408704 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_HISTORY_SLOT_MAR19
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_MAR19" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_HISTORY_SLOT_MCHANGE
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_MCHANGE" 
   (	"METERNO" VARCHAR2(20 BYTE), 
	"MF" NUMBER, 
	"SERVICENO" VARCHAR2(20 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(20 BYTE), 
	"IMP_INIT_S2" VARCHAR2(20 BYTE), 
	"IMP_INIT_S3" VARCHAR2(20 BYTE), 
	"IMP_INIT_S4" VARCHAR2(20 BYTE), 
	"IMP_INIT_S5" VARCHAR2(20 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(20 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(20 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(20 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(20 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(20 BYTE), 
	"EXP_INIT_S1" VARCHAR2(20 BYTE), 
	"EXP_INIT_S2" VARCHAR2(20 BYTE), 
	"EXP_INIT_S3" VARCHAR2(20 BYTE), 
	"EXP_INIT_S4" VARCHAR2(20 BYTE), 
	"EXP_INIT_S5" VARCHAR2(20 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(20 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(20 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(20 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(20 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(20 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(20 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(20 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(20 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(20 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(20 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(20 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(20 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(20 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(20 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(20 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(20 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(20 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table UV_TBL_HISTORY_SLOT_READG_FEB2020
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_READG_FEB2020" 
   (	"METERNO" VARCHAR2(15 BYTE), 
	"MF" NUMBER(10,3), 
	"SERVICENO" VARCHAR2(15 BYTE), 
	"SYS_DT" DATE, 
	"INITIAL_READING_DATE" DATE, 
	"FINAL_READING_DATE" DATE, 
	"IMP_INIT_S1" VARCHAR2(15 BYTE), 
	"IMP_INIT_S2" VARCHAR2(15 BYTE), 
	"IMP_INIT_S3" VARCHAR2(15 BYTE), 
	"IMP_INIT_S4" VARCHAR2(15 BYTE), 
	"IMP_INIT_S5" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S1" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S2" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S3" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S4" VARCHAR2(15 BYTE), 
	"IMP_FINAL_S5" VARCHAR2(15 BYTE), 
	"EXP_INIT_S1" VARCHAR2(15 BYTE), 
	"EXP_INIT_S2" VARCHAR2(15 BYTE), 
	"EXP_INIT_S3" VARCHAR2(15 BYTE), 
	"EXP_INIT_S4" VARCHAR2(15 BYTE), 
	"EXP_INIT_S5" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S1" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S2" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S3" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S4" VARCHAR2(15 BYTE), 
	"EXP_FINAL_S5" VARCHAR2(15 BYTE), 
	"IMP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"EXP_KVAH_INIT" VARCHAR2(15 BYTE), 
	"IMP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"EXP_KVAH_FINAL" VARCHAR2(15 BYTE), 
	"Q1_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q2_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q3_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q4_KVARH_INIT" VARCHAR2(15 BYTE), 
	"Q1_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q2_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q3_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"Q4_KVARH_FINAL" VARCHAR2(15 BYTE), 
	"DOWNLOADSTATUS" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Table WRONG_SUPPLIERN_140920
--------------------------------------------------------

  CREATE TABLE "OPENACCESS"."WRONG_SUPPLIERN_140920" 
   (	"SUPPLIER_TYPE_CODE" VARCHAR2(26 BYTE), 
	"SUPPLY_TYPE" VARCHAR2(26 BYTE), 
	"FUEL_TYPE" VARCHAR2(26 BYTE), 
	"HT_SERVICE_NO" VARCHAR2(26 BYTE), 
	"LOSS_PERC" VARCHAR2(26 BYTE), 
	"INJ_VOLT" VARCHAR2(26 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for View CEE_SHARE_REPORT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."CEE_SHARE_REPORT" ("ROW_NO", "TOTAL_CAPACITY_SUM", "TYPE_OF_SHARE", "INSTALLED_BY", "NET_GENERATION_SUM", "MONTH", "STMT_YEAR", "FUEL_TYPE_CODE", "FUEL_TYPE_NAME") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY GS.STMT_MONTH)       AS ROW_NO,
  TO_CHAR(ROUND(SUM(CAST (MS.TOTAL_CAPACITY AS NUMBER)/1000),2)) AS TOTAL_CAPACITY_SUM,
  MS.TYPE_OF_SHARE,
  MS.INSTALLED_BY,
  TO_CHAR(round(sum(cast (GS.NET_GENERATION as number)/1000000),2)) as NET_GENERATION_SUM,
  GS.STMT_MONTH  AS MONTH,
  GS.STMT_YEAR,
  MS.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,
  VS.FUEL_TYPE_NAME AS FUEL_TYPE_NAME
FROM M_COMPANY_SERVICE MS
LEFT JOIN M_COMPANY CO ON CO.ID=MS.M_COMPANY_ID
LEFT JOIN T_GEN_STMT GS ON GS.M_COMPANY_SERVICE_ID=MS.ID
LEFT JOIN M_FUEL fuel on ms.fuel_type_code = Fuel.Fuel_Code 
LEFT JOIN V_COMPANY_SERVICE VS on VS.ID=MS.ID
--LEFT JOIN V_CODES CODE ON ms.fuel_type_code  =CODE.VALUE_CODE AND CODE.LIST_cODE   ='FUEL_TYPE_CODE'
WHERE MS.COMP_SER_TYPE_CODE='03'
AND CO.NAME!               ='IEX'
AND MS.M_ORG_ID!           ='404'
AND GS.STMT_MONTH         IS NOT NULL
GROUP BY MS.TYPE_OF_SHARE,
  MS.INSTALLED_BY,
  GS.STMT_MONTH,
  GS.STMT_YEAR,
  MS.FUEL_TYPE_CODE  ,
  VS.FUEL_TYPE_NAME
;
--------------------------------------------------------
--  DDL for View ENERGY_ADJUSTED_ORDER
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."ENERGY_ADJUSTED_ORDER" ("ID", "D_BUYER_ORG_NAME", "BUYER_SERVICE_NUMBER", "D_BUYER_COMP_NAME", "D_SELL_ORG_NAME", "SELLER_SERVICE_NUMBER", "D_SELL_COMP_NAME", "FUEL_TYPE_CODE", "FUEL_NAME", "F_ENERGY_SALE_ORDER_ID", "F_ENERGY_SALE_ORDER_LINE_ID", "TOTAL_UNITS_SOLD", "TOTAL_IMPORT_GEN", "TOTAL_EXPORT_GEN", "BUYER_COMP_SERV_ID", "SELLER_COMP_SERV_ID", "CLEAN_STATUS", "RD_MONTH", "RD_YEAR", "RD_DATE", "ADJC1", "ADJC2", "ADJC3", "ADJC4", "ADJC5", "HT_BB_C1", "HT_BB_C2", "HT_BB_C3", "HT_BB_C4", "HT_BB_C5", "C1_WITHLOSS", "C2_WITHLOSS", "C3_WITHLOSS", "C4_WITHLOSS", "C5_WITHLOSS", "ALLOTED_C1", "ALLOTED_C2", "ALLOTED_C3", "ALLOTED_C4", "ALLOTED_C5", "LD_C1", "LD_C2", "LD_C3", "LD_C4", "LD_C5", "LOSS_PERCENT") AS 
  SELECT nvl(eneAdj.ID,orderline.ID) as id,ORDERLINE.D_BUYER_ORG_NAME ,orderline.d_buyer_comp_serv_name AS BUYER_SERVICE_NUMBER,ORDERLINE.D_BUYER_COMP_NAME , eso.D_SELL_ORG_NAME, eso.d_sell_comp_serv_number AS SELLER_SERVICE_NUMBER, eso.D_SELL_COMP_NAME, eneAdj.FUEL_TYPE_CODE,fu.FUEL_NAME,
 eso.ID AS F_ENERGY_SALE_ORDER_ID,orderline.id AS F_ENERGY_SALE_ORDER_LINE_ID, eso.TOTAL_UNITS_SOLD, gs.total_import_gen, gs.total_export_gen,
 eneAdj.BUYER_COMPANY_SERVICE_ID AS BUYER_COMP_SERV_ID,eneAdj.SELLER_COMPANY_SERVICE_ID AS SELLER_COMP_SERV_ID,
 eneAdj.IS_CLEAN AS CLEAN_STATUS,eso.month AS RD_MONTH,eso.year AS RD_YEAR,eneAdj.READING_DT AS RD_DATE,
 eneAdj.ADJUSTED_C1 AS ADJC1,eneAdj.ADJUSTED_C2 AS ADJC2,eneAdj.ADJUSTED_C3 AS ADJC3,eneAdj.ADJUSTED_C4 AS ADJC4,eneAdj.ADJUSTED_C5 AS ADJC5,
 eneAdj.C1 AS HT_BB_C1,eneAdj.C2 AS HT_BB_C2,eneAdj.C3 AS HT_BB_C3,eneAdj.C4 AS HT_BB_C4,eneAdj.C5 AS HT_BB_C5,
 eneAdj.C1_WITHLOSS,eneAdj.C2_WITHLOSS,eneAdj.C3_WITHLOSS,eneAdj.C4_WITHLOSS,eneAdj.C5_WITHLOSS,
 orderline.C1 AS ALLOTED_C1,orderline.C2 AS ALLOTED_C2,orderline.C3 AS ALLOTED_C3,orderline.C4 AS ALLOTED_C4,orderline.C5 AS ALLOTED_C5,
 enerLed.C1 AS LD_C1,enerLed.C2 AS LD_C2,enerLed.C3 AS LD_C3,enerLed.C4 AS LD_C4,enerLed.C5 AS LD_C5,eneAdj.LOSS_PERCENT
 FROM f_energy_Sale_order eso 
 left join t_gen_stmt gs on eso.d_sell_comp_serv_number = gs.disp_service_number and eso.month = gs.stmt_month and eso.year = gs.stmt_year
 LEFT JOIN F_ENERGY_SALE_ORDER_LINES orderline ON eso.id = orderline.F_ENERGY_SALE_ORDER_ID
 LEFT JOIN F_ENERGY_ADJUSTMET eneAdj on eso.id= eneAdj.F_ENERGY_SALE_ORDER_ID and  orderline.d_buyer_comp_serv_name = eneAdj.service_no
 LEFT JOIN F_ENERGY_LEDGER enerLed ON orderline.id =enerLed.F_ENERGY_SALE_ORDER_LINES_ID AND enerLed.SERVICE_TYPE_CODE='02'
 LEFT JOIN M_FUEL fu on eneAdj.FUEL_TYPE_CODE=fu.FUEL_CODE
;
--------------------------------------------------------
--  DDL for View ENERGY_ADJ_ORDER_CHARGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "OPENACCESS"."ENERGY_ADJ_ORDER_CHARGE" ("SUPLR_CODE", "SERVICE_NO", "READING_MNTH", "READING_YR", "ROW_NO", "ES_ORDER_ID", "METER_READING_CHARGES", "O_M_CHARGES", "TRANSMISSION_CHARGES", "SYSTEM_OPERATION_CHARGES", "RKVAH_PENALTY", "NEGATIVE_ENERGY_CHARGES", "SCHEDULING_CHARGES") AS 
  select fep.SUPLR_CODE, fep.SERVICE_NO, fep.READING_MNTH, fep.READING_YR,ROW_NUMBER() OVER (ORDER BY fep.SERVICE_NO) as ROW_NO,fep.f_energy_sale_order_id as es_order_id,
C001.charge_amount Meter_Reading_Charges,
C002.charge_amount O_M_Charges,
C003.charge_amount Transmission_Charges,
C004.charge_amount System_Operation_Charges,
C005.charge_amount RKvah_Penalty,
C006.charge_amount Negative_Energy_Charges,
C007.charge_amount Scheduling_Charges
from f_energy_adjustmet fep 
LEFT JOIN f_energy_adjusted_charge C001 ON C001.f_energy_adjusted_id = fep.id AND C001.CHARGE_CODE = 'C001' 
LEFT JOIN f_energy_adjusted_charge C002 ON C002.f_energy_adjusted_id = fep.id AND C002.CHARGE_CODE = 'C002' 
LEFT JOIN f_energy_adjusted_charge C003 ON C003.f_energy_adjusted_id = fep.id AND C003.CHARGE_CODE = 'C003' 
LEFT JOIN f_energy_adjusted_charge C004 ON C004.f_energy_adjusted_id = fep.id AND C004.CHARGE_CODE = 'C004' 
LEFT JOIN f_energy_adjusted_charge C005 ON C005.f_energy_adjusted_id = fep.id AND C005.CHARGE_CODE = 'C005' 
LEFT JOIN f_energy_adjusted_charge C006 ON C006.f_energy_adjusted_id = fep.id AND C006.CHARGE_CODE = 'C006' 
LEFT JOIN f_energy_adjusted_charge C007 ON C007.f_energy_adjusted_id = fep.id AND C007.CHARGE_CODE = 'C007'
ORDER BY fep.SUPLR_CODE
;
--------------------------------------------------------
--  DDL for View ENERGY_ORDER_CHARGE_REPORT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "OPENACCESS"."ENERGY_ORDER_CHARGE_REPORT" ("ROW_NO", "SELLER_SERVICE_NUMBER", "BUYER_SERVICE_NUMBER", "MONTH", "YEAR", "METER_READING_CHARGES", "O_M_CHARGES", "TRANSMISSION_CHARGES", "SYSTEM_OPERATION_CHARGES", "RKVAH_PENALTY", "NEGATIVE_ENERGY_CHARGES", "SCHEDULING_CHARGES") AS 
  select ROW_NUMBER() OVER (ORDER BY buyer."number") as ROW_NO,orders.d_sell_comp_serv_number as seller_Service_number,buyer."number" as buyer_Service_number,orders.month,orders.year,
C001.total_charges Meter_Reading_Charges,
C002.total_charges O_M_Charges,
C003.total_charges Transmission_Charges,
C004.total_charges System_Operation_Charges,
C005.total_charges RKvah_Penalty,
C006.total_charges Negative_Energy_Charges,
C007.total_charges Scheduling_Charges
from f_energy_sale_order orders 
left join f_energy_sale_order_lines lines on lines.f_energy_sale_order_id=orders.id
left join f_energy_charges C001 on C001.f_energy_sale_order_id=orders.id and lines.buyer_comp_serv_id=c001.m_company_service_id and C001.charge_code='C001'
left join f_energy_charges C002 on C002.f_energy_sale_order_id=orders.id and lines.buyer_comp_serv_id=c002.m_company_service_id and C002.charge_code='C002'
left join f_energy_charges C003 on orders.id=C003.f_energy_sale_order_id and lines.buyer_comp_serv_id=c003.m_company_service_id and C003.charge_code='C003'
left join f_energy_charges C004 on orders.id=C004.f_energy_sale_order_id and lines.buyer_comp_serv_id=c004.m_company_service_id and C004.charge_code='C004'
left join f_energy_charges C005 on orders.id=C005.f_energy_sale_order_id and lines.buyer_comp_serv_id=c005.m_company_service_id and C005.charge_code='C005'
left join f_energy_charges C006 on orders.id=C006.f_energy_sale_order_id and lines.buyer_comp_serv_id=c006.m_company_service_id and C006.charge_code='C006'
left join f_energy_charges C007 on orders.id=C007.f_energy_sale_order_id and lines.buyer_comp_serv_id=c007.m_company_service_id and C007.charge_code='C007'
left join m_company_service buyer on lines.buyer_comp_serv_id=buyer.id
;
--------------------------------------------------------
--  DDL for View HT_GENERATOR_DATA
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."HT_GENERATOR_DATA" ("COMPANY_CODE", "COMPANY_NAME", "COMPANY_SERVICE_NUMBER", "M_ORG_CODE", "M_ORG_NAME", "CAPACITY", "M_SUBSTATION_CODE", "M_SUBSTATION_NAME", "M_FEEDER_CODE", "M_FEEDER_NAME", "VOLTAGE_CODE", "VOLTAGE_NAME", "MODEM_NUMBER", "METER_NUMBER", "FUEL_TYPE_CODE", "FUEL_TYPE_NAME", "BUYER_COMPANY_CODE", "BUYER_COMPANY_NAME", "BUYER_COMPANY_SERVICE_NUMBER", "TR_TYPE", "FROM_DATE", "TO_DATE", "QUANTUM", "C1", "C2", "C3", "C4", "C5", "ENABLED", "PEAK_UNITS", "OFF_PEAK_UNITS", "INTERVAL_TYPE_CODE", "INTERVAL_TYPE", "SHARE_PERCENT", "REMARKS") AS 
  SELECT
company.code as COMPANY_CODE,company.name AS COMPANY_NAME, companyservice."number" COMPANY_SERVICE_NUMBER,org.code as M_ORG_CODE, org.name as M_ORG_NAME,
companyservice.capacity, substation.code as M_SUBSTATION_CODE,substation.name as M_SUBSTATION_NAME,feeder.code as M_FEEDER_CODE,feeder.name as M_FEEDER_NAME,
companyservice.voltage_code,voltagecodes.VALUE_DESC as VOLTAGE_NAME,companymeter.MODEM_NUMBER, companymeter.METER_NUMBER, powerplant.FUEL_TYPE_CODE,fueltypecodes.fuel_name as FUEL_TYPE_NAME,
BCOMP.CODE BUYER_COMPANY_CODE,BCOMP.NAME BUYER_COMPANY_NAME, BSERV."number" BUYER_COMPANY_SERVICE_NUMBER ,
CASE
WHEN m_buyer_company_id = 'IEX'   THEN 'IEX'
WHEN tr.flow_type_code = 'STB'   THEN 'STB'
WHEN tr.FLOW_TYPE_CODE ='THIRD-PARTY' THEN 'THIRD-PARTY'
WHEN nvl(TR.IS_CAPTIVE,'N') = 'Y'   THEN 'WEG-CAPTIVE'
END TR_TYPE,
  to_char(TR.FROM_DATE,'YYYY-DD-MM HH24:MI:SS') FROM_DATE,  to_char(TR.TO_DATE,'YYYY-DD-MM HH24:MI:SS') TO_DATE,
 TR.QUANTUM,TR.C1, TR.C2, TR.C3, TR.C4, TR.C5, TR.ENABLED, TR.PEAK_UNITS, TR.OFF_PEAK_UNITS, TR.INTERVAL_TYPE_CODE ,CODES.VALUE_DESC INTERVAL_TYPE, TR.SHARE_PERCENT,
TR.REMARKS
FROM m_company_service companyservice
left join m_company company on company.id =companyservice.M_COMPANY_ID
left join M_COMPANY_METER companymeter on companymeter.M_COMPANY_SERVICE_ID =companyservice.id
left join m_org org on org.id=companyservice.M_ORG_ID
left join m_substation substation on substation.id = companyservice.M_SUBSTATION_ID
left join m_feeder feeder on feeder.id = companyservice.M_FEEDER_ID
left join v_codes voltagecodes on companyservice.VOLTAGE_Code= voltagecodes.Value_Code AND  voltagecodes.list_code = 'VOLTAGE_CODE'
left join v_codes typecodes on companyservice.COMP_SER_TYPE_CODE = typecodes.value_code and typecodes.list_code='SERVICE_TYPE_CODE'
left join M_POWERPLANT powerplant on  powerplant.M_SERVICE_ID=companyservice.id
left join m_fuel fueltypecodes on powerplant.FUEL_TYPE_CODE= fueltypecodes.fuel_code 
left join M_TRADE_RELATIONSHIP TR ON TR.M_SELLER_COMP_SERVICE_ID = companyservice.ID
LEFT JOIN M_COMPANY BCOMP ON BCOMP.id = TR.M_BUYER_COMPANY_ID
LEFT JOIN M_COMPANY_SERVICE BSERV ON BSERV.id = TR.M_BUYER_COMP_SERVICE_ID
LEFT JOIN V_CODES CODES ON CODES.VALUE_CODE = TR.INTERVAL_TYPE_CODE AND CODES.LIST_CODE = 'INTERVAL_TYPE_CODE'
WHERE companyservice.COMP_SER_TYPE_CODE = '03' AND COMPANY.IS_INTERNAL = 'N'
;
--------------------------------------------------------
--  DDL for View MONTHLY_GENERATION_RETURN
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."MONTHLY_GENERATION_RETURN" ("M_ORG_NAME", "GEN_SERVICE_NUMBER", "M_COMPANY_NAME", "IS_CAPTIVE", "FLOW_TYPE_CODE", "READING_MONTH", "READING_YEAR", "IMP_RKVAH_INIT", "IMP_RKVAH_FINAL", "INIT_READING_DT", "FINAL_READING_DT", "C1_IMP_FINAL_UNITS", "C1_EXP_FINAL_UNITS", "C2_IMP_FINAL_UNITS", "C2_EXP_FINAL_UNITS", "C3_IMP_FINAL_UNITS", "C3_EXP_FINAL_UNITS", "C4_IMP_FINAL_UNITS", "C4_EXP_FINAL_UNITS", "C5_IMP_FINAL_UNITS", "C5_EXP_FINAL_UNITS", "NET_GEN_UNITS") AS 
  SELECT SER.M_ORG_NAME,SER."number" AS GEN_SERVICE_NUMBER,SER.M_COMPANY_NAME,SER.IS_CAPTIVE,SER.FLOW_TYPE_CODE,
MRH.READING_MONTH,MRH.READING_YEAR,MRH.IMP_RKVAH_INIT,MRH.IMP_RKVAH_FINAL,
MRH.INIT_READING_DT,MRH.FINAL_READING_DT,
SLOT1.IMP_UNITS AS C1_IMP_FINAL_UNITS,SLOT1.EXP_UNITS AS C1_EXP_FINAL_UNITS,
SLOT2.IMP_UNITS AS C2_IMP_FINAL_UNITS,SLOT2.EXP_UNITS AS C2_EXP_FINAL_UNITS,
SLOT3.IMP_UNITS AS C3_IMP_FINAL_UNITS,SLOT3.EXP_UNITS AS C3_EXP_FINAL_UNITS,
SLOT4.IMP_UNITS AS C4_IMP_FINAL_UNITS,SLOT4.EXP_UNITS AS C4_EXP_FINAL_UNITS,
SLOT5.IMP_UNITS AS C5_IMP_FINAL_UNITS,SLOT5.EXP_UNITS AS C5_EXP_FINAL_UNITS,
MRH.NET_GEN_UNITS
FROM T_METER_READING_HDR MRH
LEFT JOIN V_COMPANY_SERVICE SER ON MRH.M_COMPANY_METER_ID=SER.M_COMPANY_METER_ID AND SER.IS_SELLER='Y'
LEFT JOIN T_METER_READING_SLOT SLOT1 ON SLOT1.T_METER_READING_HDR_ID=MRH.ID AND SLOT1.SLOT_CODE='C1'
LEFT JOIN T_METER_READING_SLOT SLOT2 ON SLOT2.T_METER_READING_HDR_ID=MRH.ID AND SLOT2.SLOT_CODE='C2' 
LEFT JOIN T_METER_READING_SLOT SLOT3 ON SLOT3.T_METER_READING_HDR_ID=MRH.ID AND SLOT3.SLOT_CODE='C3' 
LEFT JOIN T_METER_READING_SLOT SLOT4 ON SLOT4.T_METER_READING_HDR_ID=MRH.ID AND SLOT4.SLOT_CODE='C4' 
LEFT JOIN T_METER_READING_SLOT SLOT5 ON SLOT5.T_METER_READING_HDR_ID=MRH.ID AND SLOT5.SLOT_CODE='C5' 
ORDER BY SER."number" ASC
;
--------------------------------------------------------
--  DDL for View OLD_CEE_SHARE_REPORT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."OLD_CEE_SHARE_REPORT" ("ROW_NO", "TOTAL_CAPACITY_SUM", "TYPE_OF_SHARE", "INSTALLED_BY", "NET_GENERATION_SUM", "MONTH", "STMT_YEAR", "FUEL_TYPE_CODE", "FUEL_TYPE_NAME") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY GS.STMT_MONTH)       AS ROW_NO,
  TO_CHAR(ROUND(SUM(CAST (MS.TOTAL_CAPACITY AS NUMBER)/1000),2)) AS TOTAL_CAPACITY_SUM,
  MS.TYPE_OF_SHARE,
  MS.INSTALLED_BY,
  TO_CHAR(round(sum(cast (GS.NET_GENERATION as number)/1000000),2)) as NET_GENERATION_SUM,
  GS.STMT_MONTH                           AS MONTH,
  GS.STMT_YEAR,
  MS.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,
  code.value_desc   AS FUEL_TYPE_NAME
FROM M_COMPANY_SERVICE MS
LEFT JOIN M_COMPANY CO
ON CO.ID=MS.M_COMPANY_ID
LEFT JOIN T_GEN_STMT GS
ON GS.M_COMPANY_SERVICE_ID=MS.ID
LEFT JOIN V_CODES CODE
ON ms.fuel_type_code       =CODE.VALUE_CODE
AND CODE.LIST_cODE         ='FUEL_TYPE_CODE'
WHERE MS.COMP_SER_TYPE_CODE='03'
AND CO.NAME!               ='IEX'
AND MS.M_ORG_ID!           ='404'
AND GS.STMT_MONTH         IS NOT NULL
GROUP BY MS.TYPE_OF_SHARE,
  MS.INSTALLED_BY,
  GS.STMT_MONTH,
  GS.STMT_YEAR,
  MS.FUEL_TYPE_CODE,
  code.value_desc
;
--------------------------------------------------------
--  DDL for View PROGRESS_REPORT_CAPTIVE_ALLOTMENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."PROGRESS_REPORT_CAPTIVE_ALLOTMENT" ("ROW_NO", "EDC", "MONTH", "YEAR", "DISPLAY_FUEL_TYPE", "CAPTIVE_ALLOTMENT") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY es.MONTH) AS ROW_NO,es.SELLER_END_ORG_ID AS EDC,
es.MONTH as MONTH,es.YEAR as YEAR,gs.disp_fuel_type_code AS DISPLAY_FUEL_TYPE, COUNT(*) as CAPTIVE_ALLOTMENT FROM T_ENERGY_SALE es
left join t_gen_stmt gs on es.t_gen_stmt_id=gs.id
where es.status_code='APPROVED' and es.is_stb='N' and gs.flow_type_code IN ('IS-CAPTIVE')
GROUP BY es.SELLER_END_ORG_ID, es.MONTH, es.YEAR,gs.disp_fuel_type_code ORDER BY SELLER_END_ORG_ID
;
--------------------------------------------------------
--  DDL for View PROGRESS_REPORT_MANUAL_READING
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."PROGRESS_REPORT_MANUAL_READING" ("ROW_NO", "M_ORG_ID", "COUNT", "READING_MONTH", "READING_YEAR", "FUEL_TYPE_CODE") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY hdr.READING_MONTH) AS ROW_NO, ser.M_ORG_ID AS M_ORG_ID,COUNT( hdr.M_COMPANY_METER_ID) AS COUNT,
hdr.READING_MONTH AS READING_MONTH,hdr.reading_year AS READING_YEAR,ser.FUEL_TYPE_CODE AS FUEL_TYPE_CODE
FROM T_METER_READING_HDR hdr
LEFT JOIN v_company_service ser ON hdr.M_COMPANY_METER_ID=ser.M_COMPANY_METER_ID 
where hdr.MR_SOURCE_CODE in ('02')
group by ser.M_ORG_ID, hdr.READING_MONTH, hdr.reading_year, ser.FUEL_TYPE_CODE
;
--------------------------------------------------------
--  DDL for View PROGRESS_REPORT_METER_READING
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."PROGRESS_REPORT_METER_READING" ("ROW_NO", "M_ORG_ID", "M_ORG_NAME", "METER_READING_COUNT", "READING_MONTH", "READING_YEAR", "FUEL_TYPE_CODE") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY hdr.READING_MONTH) AS ROW_NO,ser.M_ORG_ID as M_ORG_ID, ser.m_org_name as M_ORG_NAME,
  COUNT( hdr.M_COMPANY_METER_ID) AS METER_READING_COUNT,hdr.READING_MONTH as READING_MONTH,hdr.READING_YEAR as READING_YEAR,ser.fuel_type_code as FUEL_TYPE_CODE
  FROM T_METER_READING_HDR hdr
LEFT JOIN v_company_service ser ON hdr.M_COMPANY_METER_ID=ser.M_COMPANY_METER_ID 
group by ser.M_ORG_ID, ser.m_org_name, hdr.READING_MONTH, hdr.READING_YEAR, ser.fuel_type_code
ORDER BY ser.M_ORG_ID
;
--------------------------------------------------------
--  DDL for View PROGRESS_REPORT_THIRD_ALLOTMENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."PROGRESS_REPORT_THIRD_ALLOTMENT" ("ROW_NO", "EDC", "MONTH", "YEAR", "DISPLAY_FUEL_TYPE", "THIRDPARTY_ALLOTMENT") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY es.MONTH) AS ROW_NO,es.SELLER_END_ORG_ID AS EDC,
es.MONTH as MONTH,es.YEAR as YEAR,gs.disp_fuel_type_code AS DISPLAY_FUEL_TYPE, COUNT(*) as THIRDPARTY_ALLOTMENT FROM T_ENERGY_SALE es
left join t_gen_stmt gs on es.t_gen_stmt_id=gs.id
where es.status_code='APPROVED' and es.is_stb='N' and gs.flow_type_code IN ('THIRD-PARTY')
GROUP BY es.SELLER_END_ORG_ID, es.MONTH, es.YEAR,gs.disp_fuel_type_code ORDER BY SELLER_END_ORG_ID
;
--------------------------------------------------------
--  DDL for View PROGRESS_REPORT_TOTAL_ALLOTMENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."PROGRESS_REPORT_TOTAL_ALLOTMENT" ("ROW_NO", "EDC", "MONTH", "YEAR", "DISPLAY_FUEL_TYPE", "TOTAL_ALLOTMENT") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY es.MONTH) AS ROW_NO,es.SELLER_END_ORG_ID AS EDC,
es.MONTH as MONTH,es.YEAR as YEAR,gs.disp_fuel_type_code AS DISPLAY_FUEL_TYPE, COUNT(*) as TOTAL_ALLOTMENT FROM T_ENERGY_SALE es
left join t_gen_stmt gs on es.t_gen_stmt_id=gs.id
where es.status_code='APPROVED' and es.is_stb='N' and gs.flow_type_code IN ('THIRD-PARTY','IS-CAPTIVE')
GROUP BY es.SELLER_END_ORG_ID, es.MONTH, es.YEAR,gs.disp_fuel_type_code ORDER BY SELLER_END_ORG_ID
;
--------------------------------------------------------
--  DDL for View PROGRESS_REPORT_VIEW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."PROGRESS_REPORT_VIEW" ("ROW_NO", "ORG_ID", "EDC", "METER_READING", "READING_MONTH", "READING_YEAR", "FUEL_TYPE", "THIRD_PARTY", "CAPTIVE_ALLOTMENT", "TOTAL_ALLOTMENT", "MALUAL_READING") AS 
  SELECT 
    ROW_NO,org_id,edc,Meter_reading,reading_month,reading_year,fuel_type,third_party,
    captive_allotment,total_allotment,malual_reading
FROM 
    (select ROW_NUMBER() OVER (ORDER BY a.READING_MONTH)AS ROW_NO,a.M_ORG_ID as org_id,a.m_org_name as edc,a.Meter_reading as Meter_reading,a.READING_MONTH as reading_month,a.READING_YEAR as reading_year,a.fuel_type_code as fuel_type,(c.total_allotment-b.captive_allotment) as third_party,b.captive_allotment as captive_allotment,c.total_allotment as total_allotment,(a.Meter_reading-d.count) as malual_reading from
(SELECT ser.M_ORG_ID, ser.m_org_name,COUNT( hdr.M_COMPANY_METER_ID) AS 
Meter_reading,READING_MONTH,READING_YEAR,ser.fuel_type_code FROM T_METER_READING_HDR hdr
LEFT JOIN v_company_service ser ON hdr.M_COMPANY_METER_ID=ser.M_COMPANY_METER_ID group by ser.M_ORG_ID, ser.m_org_name, READING_MONTH, READING_YEAR, ser.fuel_type_code
ORDER BY ser.M_ORG_ID )a,
(SELECT es.SELLER_END_ORG_ID AS EDC,es.MONTH,es.YEAR,gs.disp_fuel_type_code, COUNT(*) as captive_allotment FROM T_ENERGY_SALE es
left join t_gen_stmt gs on es.t_gen_stmt_id=gs.id
where es.status_code='APPROVED' and es.is_stb='N' and gs.flow_type_code IN ('IS-CAPTIVE')
GROUP BY es.SELLER_END_ORG_ID, es.MONTH, es.YEAR,gs.disp_fuel_type_code ORDER BY SELLER_END_ORG_ID)b,
(SELECT es.SELLER_END_ORG_ID AS EDC, es.MONTH,es.YEAR,gs.disp_fuel_type_code,
COUNT(*) as total_allotment FROM T_ENERGY_SALE es
left join t_gen_stmt gs on es.t_gen_stmt_id=gs.id
where es.status_code='APPROVED' and
es.is_stb='N' and gs.flow_type_code IN ('THIRD-PARTY','IS-CAPTIVE')
GROUP BY es.SELLER_END_ORG_ID, es.MONTH, es.YEAR, 
gs.disp_fuel_type_code ORDER BY SELLER_END_ORG_ID)c,
(SELECT ser.M_ORG_ID,COUNT( hdr.M_COMPANY_METER_ID) AS count,hdr.READING_MONTH,hdr.reading_year,ser.FUEL_TYPE_CODE
FROM T_METER_READING_HDR hdr
LEFT JOIN v_company_service ser ON hdr.M_COMPANY_METER_ID=ser.M_COMPANY_METER_ID 
where hdr.MR_SOURCE_CODE in ('01','03')
group by ser.M_ORG_ID, hdr.READING_MONTH, hdr.reading_year, ser.FUEL_TYPE_CODE)d
where a.M_ORG_ID=b.edc and a.M_ORG_ID=c.edc  and a.m_org_id=d.M_ORG_ID
and b.month=a.READING_MONTH and b.year=a.READING_YEAR and b.disp_fuel_type_code=a.fuel_type_code
and c.month=a.READING_MONTH and c.year=a.READING_YEAR and c.disp_fuel_type_code=a.fuel_type_code 
and d.READING_MONTH =a.READING_MONTH and d.reading_year=a.READING_YEAR and d.FUEL_TYPE_CODE=a.fuel_type_code)
;
--------------------------------------------------------
--  DDL for View RCI_BACKUP_CONTROLFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_BACKUP_CONTROLFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "BCF_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "CREATION_TIME", "BLOCK_SIZE", "OLDEST_OFFLINE_RANGE", "STATUS", "BS_RECID", "BS_STAMP", "BS_LEVEL", "COMPLETION_TIME", "CONTROLFILE_TYPE", "BLOCKS", "AUTOBACKUP_DATE", "AUTOBACKUP_SEQUENCE", "GUID", "PDB_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       bcf.bcf_key,
       bcf.bcf_recid recid,
       bcf.bcf_stamp stamp,
       bs.bs_key,
       bs.set_stamp,
       bs.set_count,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       bcf.ckp_scn checkpoint_change#,
       bcf.ckp_time checkpoint_time,
       bcf.create_time creation_time,
       bcf.block_size,
       bcf.min_offr_recid oldest_offline_range,
       bs.status,
       bs_recid,
       bs_stamp,
       bs.incr_level bs_level,
       bs.completion_time,
       bcf.controlfile_type,
       bcf.blocks,
       bcf.autobackup_date,
       bcf.autobackup_sequence,
       pdb.guid,
       pdb.pdb_key
from dbinc, bs, bcf, pdb
where dbinc.dbinc_key = bcf.dbinc_key
and   bs.bs_key = bcf.bs_key
and   bs.bck_type != 'L'
and   bcf.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RCI_BACKUP_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_BACKUP_DATAFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "BDF_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "BS_RECID", "BS_STAMP", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "COMPLETION_TIME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "INCREMENTAL_CHANGE#", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "ABSOLUTE_FUZZY_CHANGE#", "DATAFILE_BLOCKS", "BLOCKS", "BLOCK_SIZE", "STATUS", "BS_LEVEL", "PIECES", "BLOCKS_READ", "MARKED_CORRUPT", "USED_CHANGE_TRACKING", "USED_OPTIMIZATION", "PCT_NOTREAD", "FOREIGN_DBID", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "SECTION_SIZE", "GUID", "SPARSE_BACKUP", "PDB_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       bdf.bdf_key,
       bdf.bdf_recid recid,
       bdf.bdf_stamp stamp,
       bs.bs_key,
       bs.set_stamp,
       bs.set_count,
       bs.bs_recid,
       bs.bs_stamp,
       bs.bck_type backup_type,
       bdf.incr_level incremental_level,
       bdf.completion_time,
       bdf.file#,
       bdf.create_scn creation_change#,
       bdf.create_time creation_time,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       bdf.incr_scn incremental_change#,
       bdf.ckp_scn checkpoint_change#,
       bdf.ckp_time checkpoint_time,
       bdf.abs_fuzzy_scn absolute_fuzzy_change#,
       bdf.datafile_blocks,
       bdf.blocks,
       bdf.block_size,
       bs.status,
       bs.incr_level bs_level,
       bs.pieces,
       bdf.blocks_read,
       bdf.marked_corrupt,
       decode(bdf.used_chg_track, 'Y', 'YES', 'NO')  used_change_tracking,
       decode(bdf.used_optim, 'Y', 'YES', 'NO') used_optimization,
       decode(bdf.used_optim, 
              'Y',round((100 *(bdf.datafile_blocks - bdf.blocks_read)) / 
                        bdf.datafile_blocks),
              NULL) pct_notread,
       bdf.foreign_dbid,
       bdf.plugged_readonly,
       bdf.plugin_scn plugin_change#,
       bdf.plugin_reset_scn plugin_resetlogs_change#,
       bdf.plugin_reset_time plugin_resetlogs_time,
       bdf.section_size,
       pdb.guid,
       bdf.sparse_backup,
       pdb.pdb_key
from dbinc, bs, bdf, pdb
where dbinc.dbinc_key = bdf.dbinc_key
and   bs.bs_key = bdf.bs_key
and   bs.bck_type != 'L'
and   bdf.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RCI_BACKUP_PIECE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_BACKUP_PIECE" ("DB_KEY", "DB_ID", "BP_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "PIECE#", "COPY#", "DEVICE_TYPE", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "CONCUR", "TAG", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "BYTES", "IS_RECOVERY_DEST_FILE", "RSR_KEY", "COMPRESSED", "SITE_KEY", "ENCRYPTED", "BACKED_BY_OSB", "BA_ACCESS", "VB_KEY", "VIRTUAL", "LIB_KEY", "GUID", "PDB_KEY") AS 
  select db.db_key,
       db.db_id,
       bp.bp_key,
       bp.bp_recid recid,
       bp.bp_stamp stamp,
       bs.bs_key,
       bs.set_stamp,
       bs.set_count,
       bs.bck_type backup_type,
       bs.incr_level incremental_level,
       bp.piece#,
       bp.copy#,
       bp.device_type,
       bp.handle,
       bp.comments,
       bp.media,
       bp.media_pool,
       decode(bp.concur, 'N', 'NO', 'Y', 'YES', '?') concur,
       bp.tag,
       bp.start_time,
       bp.completion_time,
       abs((bp.completion_time - bp.start_time) * 86400) elapsed_seconds,
       bp.status,
       bp.bytes,
       bp.is_recovery_dest_file,
       bp.rsr_key,
       bp.compressed,
       bp.site_key,
       decode(bp.encrypted, 'N', 'NO', 'Y', 'YES', '?') encrypted,
       decode(bp.backed_by_osb, 'N', 'NO', 'Y', 'YES', '?') backed_by_osb,
       decode(bp.ba_access,
             'U', 'Unknown', 'T', 'Tape', 'L', 'Local', 'D', 'Disk',
             'R', 'Replication') ba_access,    -- any changes to this list
--
       bp.vb_key,
       decode(bp.vb_key, NULL, 'NO', 'YES') virtual,
       bp.lib_key,
       pdb.guid,
       pdb.pdb_key
from db, bs, bp, pdb
where db.db_key = bs.db_key
and   bs.bs_key = bp.bs_key
and   bp.status != 'D'
and   bp.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RCI_BACKUP_SET
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_BACKUP_SET" ("DB_KEY", "DB_ID", "BS_KEY", "RECID", "STAMP", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "PIECES", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "CONTROLFILE_INCLUDED", "INPUT_FILE_SCAN_ONLY", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "BLOCK_SIZE", "SITE_KEY", "MULTI_SECTION", "GUID", "PDB_KEY") AS 
  select db.db_key,
       db.db_id,
       bs.bs_key,
       bs.bs_recid recid,
       bs.bs_stamp stamp,
       bs.set_stamp,
       bs.set_count,
       bs.bck_type backup_type,
       bs.incr_level incremental_level,
       bs.pieces,
       bs.start_time,
       bs.completion_time,
       abs((bs.completion_time - bs.start_time) * 86400) elapsed_seconds,
       bs.status,
       bs.controlfile_included,
       bs.input_file_scan_only,
       decode(keep_options, 0, 'NO',
                               'YES') keep,
       keep_until,
       decode(keep_options, 256,  'LOGS',
                            512,  'NOLOGS',
                            1024, 'BACKUP_LOGS',
                                  NULL) keep_options,
       bs.block_size,
       bs.site_key,
       decode(bs.multi_section, 'Y', 'YES', 'NO') multi_section,
       pdb.guid,
       pdb.pdb_key
from db, bs, pdb
where db.db_key = bs.db_key
  and pdb.pdb_key = bs.pdb_key

;
--------------------------------------------------------
--  DDL for View RCI_BACKUP_SPFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_BACKUP_SPFILE" ("DB_KEY", "BSF_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "MODIFICATION_TIME", "STATUS", "BS_RECID", "BS_STAMP", "COMPLETION_TIME", "BYTES", "DB_UNIQUE_NAME", "GUID") AS 
  select db.db_key,
       bsf.bsf_key,
       bsf.bsf_recid recid,
       bsf.bsf_stamp stamp,
       bs.bs_key,
       bs.set_stamp,
       bs.set_count,
       bsf.modification_time,
       bs.status,
       bs_recid,
       bs_stamp,
       bs.completion_time,
       bsf.bytes,
       bsf.db_unique_name,
       pdb.guid
from db, bs, bsf, pdb
where db.db_key = bsf.db_key
and   bs.bs_key = bsf.bs_key
and   bs.bck_type != 'L'
and   bsf.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RCI_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_DATAFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "PDB_CLOSED", "PDBINC_KEY", "TS#", "TABLESPACE_NAME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "BYTES", "BLOCKS", "BLOCK_SIZE", "NAME", "STOP_CHANGE#", "STOP_TIME", "READ_ONLY", "RFILE#", "INCLUDED_IN_DATABASE_BACKUP", "AUX_NAME", "ENCRYPT_IN_BACKUP", "SITE_KEY", "DB_UNIQUE_NAME", "FOREIGN_DBID", "FOREIGN_CREATION_CHANGE#", "FOREIGN_CREATION_TIME", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "CREATION_THREAD", "CREATION_SIZE", "PDB_FOREIGN_DBID", "PDB_NOBACKUP") AS 
  select a.db_key,
       a.dbinc_key,
       a.db_name,
       a.con_id,
       a.pdb_name,
       a.pdb_key,
       a.pdb_closed,
       a.pdbinc_key,
       a.ts#,
       a.tablespace_name,
       a.file#,
       a.creation_change#,
       a.creation_time,
       a.drop_change#,
       a.drop_time,
       a.bytes,
       a.blocks,
       a.block_size,
       site_dfatt.fname name,
       a.stop_change#,
       a.stop_time,
       a.read_only,
       a.rfile#,
       a.included_in_database_backup,
       a.aux_name,
       a.encrypt_in_backup,
       a.site_key,
       a.db_unique_name,
       a.foreign_dbid,
       a.foreign_create_scn foreign_creation_change#,
       a.foreign_create_time foreign_creation_time,
       a.plugged_readonly,
       a.plugin_scn plugin_change#,
       a.plugin_reset_scn plugin_resetlogs_change#,
       a.plugin_reset_time plugin_resetlogs_time,
       a.creation_thread,
       a.creation_size,
       a.pdb_foreign_dbid,
       a.pdb_nobackup
  from 
    (select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       pdb.con_id con_id,
       pdb.name pdb_name,
       pdb.pdb_key pdb_key,
       df.pdbinc_key,
       df.pdb_closed,
       ts.ts#,
       ts.ts_name tablespace_name,
       df.file#,
       df.create_scn creation_change#,
       df.create_time creation_time,
       df.drop_scn drop_change#,
       df.drop_time,
       df.blocks*df.block_size bytes,
       df.blocks,
       df.block_size,
       df.stop_scn stop_change#,
       df.stop_time,
       df.read_only read_only,
       df.rfile#,
       ts.included_in_database_backup,
       df.clone_fname aux_name,
       ts.encrypt_in_backup,
       df.df_key,
       node.site_key,
       node.db_unique_name,
       df.foreign_dbid,
       df.foreign_create_scn,
       df.foreign_create_time,
       df.plugged_readonly,
       df.plugin_scn,
       df.plugin_reset_scn,
       df.plugin_reset_time,
       df.create_thread creation_thread,
       df.create_size creation_size,
       df.pdb_foreign_dbid,
       pdb.nobackup pdb_nobackup
    from dbinc, ts, df, node, pdbinc, pdb
    where dbinc.dbinc_key = ts.dbinc_key
    and   ts.dbinc_key = df.dbinc_key
    and   ts.ts# = df.ts#
    and   ts.create_scn = df.ts_create_scn
    and   ts.pdbinc_key = df.ts_pdbinc_key
    and   node.db_key = dbinc.db_key
    and   df.pdbinc_key = pdbinc.pdbinc_key
    and   pdb.pdb_key = pdbinc.pdb_key) a, site_dfatt
where a.site_key = site_dfatt.site_key(+)
  and a.df_key = site_dfatt.df_key(+)

;
--------------------------------------------------------
--  DDL for View RCI_DATAFILE_THIS_DBINC
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_DATAFILE_THIS_DBINC" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "PDB_CLOSED", "PDBINC_KEY", "TS#", "TABLESPACE_NAME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "BYTES", "BLOCKS", "BLOCK_SIZE", "NAME", "STOP_CHANGE#", "STOP_TIME", "READ_ONLY", "RFILE#", "INCLUDED_IN_DATABASE_BACKUP", "AUX_NAME", "ENCRYPT_IN_BACKUP", "SITE_KEY", "DB_UNIQUE_NAME", "FOREIGN_DBID", "FOREIGN_CREATION_CHANGE#", "FOREIGN_CREATION_TIME", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "CREATION_THREAD", "CREATION_SIZE", "PDB_FOREIGN_DBID", "PDB_NOBACKUP") AS 
  select a.db_key,
       a.dbinc_key,
       a.db_name,
       a.con_id,
       a.pdb_name,
       a.pdb_key,
       a.pdb_closed,
       a.pdbinc_key,
       a.ts#,
       a.tablespace_name,
       a.file#,
       a.creation_change#,
       a.creation_time,
       a.drop_change#,
       a.drop_time,
       a.bytes,
       a.blocks,
       a.block_size,
       site_dfatt.fname name,
       a.stop_change#,
       a.stop_time,
       a.read_only,
       a.rfile#,
       a.included_in_database_backup,
       a.aux_name,
       a.encrypt_in_backup,
       a.site_key,
       a.db_unique_name,
       a.foreign_dbid,
       a.foreign_create_scn foreign_creation_change#,
       a.foreign_create_time foreign_creation_time,
       a.plugged_readonly,
       a.plugin_scn plugin_change#,
       a.plugin_reset_scn plugin_resetlogs_change#,
       a.plugin_reset_time plugin_resetlogs_time,
       a.creation_thread,
       a.creation_size,
       a.pdb_foreign_dbid,
       a.pdb_nobackup
  from 
    (select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       pdbinc.con_id con_id,
       pdbinc.name pdb_name,
       pdbinc.pdb_key pdb_key,
       df.pdbinc_key,
       df.pdb_closed,
       ts.ts#,
       ts.ts_name tablespace_name,
       df.file#,
       df.create_scn creation_change#,
       df.create_time creation_time,
       df.drop_scn drop_change#,
       df.drop_time,
       df.blocks*df.block_size bytes,
       df.blocks,
       df.block_size,
       df.stop_scn stop_change#,
       df.stop_time,
       df.read_only read_only,
       df.rfile#,
       ts.included_in_database_backup,
       df.clone_fname aux_name,
       ts.encrypt_in_backup,
       df.df_key,
       node.site_key,
       node.db_unique_name,
       df.foreign_dbid,
       df.foreign_create_scn,
       df.foreign_create_time,
       df.plugged_readonly,
       df.plugin_scn,
       df.plugin_reset_scn,
       df.plugin_reset_time,
       df.create_thread creation_thread,
       df.create_size creation_size,
       df.pdb_foreign_dbid,
       pdbinc.nobackup pdb_nobackup
    from dbinc, ts, df, node, rci_pdbinc_this_dbinc pdbinc
    where dbinc.dbinc_key = ts.dbinc_key
    and   ts.dbinc_key = df.dbinc_key
    and   ts.ts# = df.ts#
    and   ts.create_scn = df.ts_create_scn
    and   ts.pdbinc_key = df.ts_pdbinc_key
    and   node.db_key = dbinc.db_key
    and   df.pdbinc_key = pdbinc.pdbinc_key
    and   df.dbinc_key = pdbinc.dbinc_key
    and   df.create_scn < pdbinc.next_inc_scn
    and   df.plugin_scn < pdbinc.next_inc_scn) a, site_dfatt
where a.site_key = site_dfatt.site_key(+)
  and a.df_key = site_dfatt.df_key(+)

;
--------------------------------------------------------
--  DDL for View RCI_PDBINC_THIS_DBINC
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_PDBINC_THIS_DBINC" ("PDBINC_KEY", "PDB_KEY", "BORN_DBINC_KEY", "INC_SCN", "BEGIN_RESET_SCN", "BEGIN_RESET_TIME", "END_RESET_SCN", "PARENT_PDBINC_KEY", "PDBINC_STATUS", "NEXT_INC_SCN", "NEXT_END_RESET_SCN", "DB_KEY", "DBINC_KEY", "NAME", "CON_ID", "DB_ID", "CREATE_SCN", "DROP_SCN", "CURR_PDBINC_KEY", "NOBACKUP") AS 
  select par."PDBINC_KEY",par."PDB_KEY",par."BORN_DBINC_KEY",par."INC_SCN",par."BEGIN_RESET_SCN",par."BEGIN_RESET_TIME",par."END_RESET_SCN",par."PARENT_PDBINC_KEY",par."PDBINC_STATUS",
       cur.inc_scn next_inc_scn,
       cur.end_reset_scn next_end_reset_scn,
       pdb.db_key,
       pdb_dbinc.dbinc_key,
       pdb.name,
       pdb.con_id,
       pdb.db_id,
       pdb.create_scn,
       pdb_dbinc.drop_scn,
       pdb_dbinc.curr_pdbinc_key,
       pdb.nobackup
  from pdbinc cur, pdbinc par, pdb, pdb_dbinc
 where cur.parent_pdbinc_key = par.pdbinc_key
   and cur.pdbinc_status != 'ORPHAN'
   and cur.pdb_key = pdb.pdb_key
   and pdb.pdb_key = pdb_dbinc.pdb_key
union all
select pdbinc."PDBINC_KEY",pdbinc."PDB_KEY",pdbinc."BORN_DBINC_KEY",pdbinc."INC_SCN",pdbinc."BEGIN_RESET_SCN",pdbinc."BEGIN_RESET_TIME",pdbinc."END_RESET_SCN",pdbinc."PARENT_PDBINC_KEY",pdbinc."PDBINC_STATUS",
       18446744073709551615 next_inc_scn,
       18446744073709551615 next_end_reset_scn,
       pdb.db_key,
       pdb_dbinc.dbinc_key,
       pdb.name,
       pdb.con_id,
       pdb.db_id,
       pdb.create_scn,
       pdb_dbinc.drop_scn,
       pdb_dbinc.curr_pdbinc_key,
       pdb.nobackup
  from pdbinc, pdb, pdb_dbinc
 where pdb_dbinc.curr_pdbinc_key = pdbinc.pdbinc_key
   and pdbinc.pdbinc_status = 'CURRENT'
   and pdbinc.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RCI_PDBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_PDBS" ("PDB_KEY", "DB_KEY", "NAME", "CON_ID", "DBID", "CREATION_CHANGE#", "GUID", "NOBACKUP") AS 
  select pdb.pdb_key,
       pdb.db_key,
       pdb.name,
       pdb.con_id,
       pdb.db_id dbid,
       pdb.create_scn creation_change#,
       pdb.guid guid,
       pdb.nobackup
  from pdb

;
--------------------------------------------------------
--  DDL for View RCI_RA_UPSTREAM_DATABASE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_RA_UPSTREAM_DATABASE" ("DBID", "NAME") AS 
  select to_number(null) dbid, 'NOT_RA_SCHEMA' name from dual

;
--------------------------------------------------------
--  DDL for View RCI_SITE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_SITE" ("SITE_KEY", "DB_KEY", "DATABASE_ROLE", "CF_CREATE_TIME", "DB_UNIQUE_NAME", "HIGH_CONF_RECID", "FORCE_RESYNC2CF", "HIGH_ROUT_STAMP", "INST_STARTUP_STAMP", "LAST_KCCDIVTS", "HIGH_IC_RECID", "DBINC_KEY", "CKP_SCN", "FULL_CKP_CF_SEQ", "JOB_CKP_CF_SEQ", "HIGH_TS_RECID", "HIGH_DF_RECID", "HIGH_RT_RECID", "HIGH_ORL_RECID", "HIGH_OFFR_RECID", "HIGH_RLH_RECID", "HIGH_AL_RECID", "HIGH_BS_RECID", "HIGH_BP_RECID", "HIGH_BDF_RECID", "HIGH_CDF_RECID", "HIGH_BRL_RECID", "HIGH_BCB_RECID", "HIGH_CCB_RECID", "HIGH_DO_RECID", "HIGH_PC_RECID", "HIGH_BSF_RECID", "HIGH_RSR_RECID", "HIGH_TF_RECID", "HIGH_GRSP_RECID", "HIGH_NRSP_RECID", "HIGH_BCR_RECID", "LOW_BCR_RECID", "BCR_IN_USE", "HIGH_PDB_RECID", "HIGH_PIC_RECID") AS 
  select site_key,
          db_key,
          database_role,
          cf_create_time,
          substr(db_unique_name, 1, 30) db_unique_name,
          high_conf_recid,
          force_resync2cf,
          high_rout_stamp,
          inst_startup_stamp,
          last_kccdivts,
          high_ic_recid,
          dbinc_key,
          ckp_scn,
          full_ckp_cf_seq,
          job_ckp_cf_seq,
          high_ts_recid,
          high_df_recid,
          high_rt_recid,
          high_orl_recid,
          high_offr_recid,
          high_rlh_recid,
          high_al_recid,
          high_bs_recid,
          high_bp_recid,
          high_bdf_recid,
          high_cdf_recid,
          high_brl_recid,
          high_bcb_recid,
          high_ccb_recid,
          high_do_recid,
          high_pc_recid,
          high_bsf_recid,
          high_rsr_recid,
          high_tf_recid,
          high_grsp_recid,
          high_nrsp_recid,
          high_bcr_recid,
          low_bcr_recid,
          bcr_in_use,
          high_pdb_recid,
          high_pic_recid
   from node

;
--------------------------------------------------------
--  DDL for View RCI_TABLESPACE_THIS_DBINC
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_TABLESPACE_THIS_DBINC" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "PDBINC_KEY", "TS#", "NAME", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "INCLUDED_IN_DATABASE_BACKUP", "BIGFILE", "TEMPORARY", "ENCRYPT_IN_BACKUP", "PLUGIN_CHANGE#") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       pdbinc.con_id,
       pdbinc.name pdb_name,
       pdbinc.pdb_key pdb_key,
       ts.pdbinc_key,
       ts.ts#,
       ts.ts_name name,
       ts.create_scn creation_change#,
       ts.create_time creation_time,
       ts.drop_scn drop_change#,
       ts.drop_time,
       ts.included_in_database_backup,
       ts.bigfile,
       ts.temporary,
       ts.encrypt_in_backup,
       ts.plugin_scn plugin_change#
from ts, dbinc, rci_pdbinc_this_dbinc pdbinc
where dbinc.dbinc_key = ts.dbinc_key
  and ts.pdbinc_key   = pdbinc.pdbinc_key
  and ts.dbinc_key    = pdbinc.dbinc_key
  and ts.create_scn   < pdbinc.next_inc_scn
  and ts.plugin_scn   < pdbinc.next_inc_scn

;
--------------------------------------------------------
--  DDL for View RCI_TEMPFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RCI_TEMPFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "TS#", "TABLESPACE_NAME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "BYTES", "BLOCKS", "BLOCK_SIZE", "NAME", "RFILE#", "AUTOEXTEND", "MAXSIZE", "NEXTSIZE", "BIGFILE", "SITE_KEY", "DB_UNIQUE_NAME", "TABLESPACE_CREATION_CHANGE#", "TABLESPACE_CREATION_TIME", "TABLESPACE_DROP_CHANGE#", "TABLESPACE_DROP_TIME") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       pdb.con_id con_id,
       decode(pdb.con_id, 0, NULL, pdb.name) pdb_name,
       pdb.pdb_key pdb_key,
       ts.ts#,
       ts.ts_name tablespace_name,
       tf.file#,
       tf.create_scn creation_change#,
       tf.create_time creation_time,
       site_tfatt.drop_scn drop_change#,
       site_tfatt.drop_time,
       site_tfatt.blocks * tf.block_size bytes,
       site_tfatt.blocks,
       tf.block_size,
       site_tfatt.fname name,
       tf.rfile#,
       site_tfatt.autoextend,
       site_tfatt.max_size maxsize,
       site_tfatt.next_size nextsize,
       ts.bigfile,
       node.site_key,
       node.db_unique_name,
       ts.create_scn tablespace_creation_change#,
       ts.create_time tablespace_creation_time,
       ts.drop_scn tablespace_drop_change#,
       ts.drop_time tablespace_drop_time
from dbinc, ts, tf, node, site_tfatt, pdb
where dbinc.dbinc_key = ts.dbinc_key
and   ts.dbinc_key = tf.dbinc_key
and   ts.ts# = tf.ts#
and   ts.create_scn = tf.ts_create_scn
and   ts.pdbinc_key = tf.ts_pdbinc_key
and   node.db_key = dbinc.db_key
and   tf.tf_key = site_tfatt.tf_key
and   node.site_key = site_tfatt.site_key
and   tf.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RC_ARCHIVED_LOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_ARCHIVED_LOG" ("DB_KEY", "DBINC_KEY", "DB_NAME", "AL_KEY", "RECID", "STAMP", "NAME", "THREAD#", "SEQUENCE#", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "FIRST_CHANGE#", "FIRST_TIME", "NEXT_CHANGE#", "NEXT_TIME", "BLOCKS", "BLOCK_SIZE", "COMPLETION_TIME", "ARCHIVED", "STATUS", "IS_STANDBY", "DICTIONARY_BEGIN", "DICTIONARY_END", "IS_RECOVERY_DEST_FILE", "COMPRESSED", "CREATOR", "TERMINAL", "SITE_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       al.al_key,
       al.al_recid recid,
       al.al_stamp stamp,
       al.fname name,
       al.thread#,
       al.sequence#,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       al.low_scn first_change#,
       al.low_time first_time,
       al.next_scn next_change#,
       al.next_time,
       al.blocks,
       al.block_size,
       al.completion_time,
       decode(al.archived, 'N', 'NO', 'Y', 'YES', '?') archived,
       al.status,
       decode(al.is_standby, 'Y', 'YES', 'NO') is_standby,
       al.dictionary_begin,
       al.dictionary_end,
       al.is_recovery_dest_file,
       al.compressed,
       al.creator,
       al.terminal,
       al.site_key
from dbinc, al
where dbinc.dbinc_key = al.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_ARCHIVELOG_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_ARCHIVELOG_DETAILS" ("BTYPE", "BTYPE_KEY", "SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "ID1", "ID2", "THREAD#", "SEQUENCE#", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "FIRST_CHANGE#", "FIRST_TIME", "NEXT_CHANGE#", "NEXT_TIME", "FILESIZE", "COMPRESSION_RATIO", "FILESIZE_DISPLAY") AS 
  select a."BTYPE",a."BTYPE_KEY",a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."DB_KEY",a."DB_NAME",a."ID1",a."ID2",a."THREAD#",a."SEQUENCE#",a."RESETLOGS_CHANGE#",a."RESETLOGS_TIME",a."FIRST_CHANGE#",a."FIRST_TIME",a."NEXT_CHANGE#",a."NEXT_TIME",a."FILESIZE",a."COMPRESSION_RATIO",
   dbms_rcvman.Num2DisplaySize(filesize) filesize_display
from
(select unique 'BACKUPSET' btype, b.bs_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       a.db_key, a.db_name,
       a.set_stamp id1, b.set_count id2, 
       thread#, sequence#, resetlogs_change#, resetlogs_time,
       first_change#, 
       first_time,
       next_change#, 
       next_time,
       (blocks+1)*a.block_size filesize,
       b.compression_ratio
   from rc_backup_redolog a, rc_backup_set_details b where
        a.bs_key = b.bs_key
union
select unique 'PROXYCOPY', a.xal_key btype_key, 
       session_key,
       session_recid,
       session_stamp,
       a.db_key, a.db_name,
       a.recid, a.stamp, 
       thread#, sequence#, resetlogs_change#, resetlogs_time,
       first_change#, first_time,
       next_change#, next_time,
       (blocks+1)*block_size filesize,
       1
   from rc_proxy_archivedlog a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time))a

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_ARCHIVELOG_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_ARCHIVELOG_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_FILES_BACKED", "NUM_DISTINCT_FILES_BACKED", "MIN_FIRST_CHANGE#", "MAX_NEXT_CHANGE#", "MIN_FIRST_TIME", "MAX_NEXT_TIME", "INPUT_BYTES", "OUTPUT_BYTES", "COMPRESSION_RATIO", "INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_FILES_BACKED",a."NUM_DISTINCT_FILES_BACKED",a."MIN_FIRST_CHANGE#",a."MAX_NEXT_CHANGE#",a."MIN_FIRST_TIME",a."MAX_NEXT_TIME",a."INPUT_BYTES",a."OUTPUT_BYTES",
       case when 
         input_bytes/decode(output_bytes, 0, null, output_bytes) > 1
       then 
         input_bytes/decode(output_bytes, 0, null, output_bytes)
       else 1 end compression_ratio,
       dbms_rcvman.Num2DisplaySize(input_bytes) input_bytes_display,
       dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display 
from
  (select db_key,
       sum(num_files_backed) num_files_backed,
       sum(distinct_files_backed) num_distinct_files_backed,
       min(min_first_change#) min_first_change#,
       max(max_next_change#) max_next_change#,
       min(min_first_time) min_first_time,
       max(max_next_time) max_next_time,
       sum(original_input_bytes) input_bytes,
       sum(output_bytes) output_bytes
  from
    ((select a.db_key,
       num_files_backed,
       distinct_files_backed,
       min_first_change#,
       max_next_change#,
       min_first_time,
       max_next_time,
       original_input_bytes,
       output_bytes
     from
       (select a.db_key, count(*) num_files_backed,
         min(first_change#)min_first_change#,
         max(next_change#) max_next_change#,
         min(first_time)min_first_time,
         max(next_time) max_next_time
       from rc_backup_redolog a, rc_backup_set_details b
       where a.bs_key = b.bs_key and a.db_key = b.db_key group by a.db_key)a,
       (select db_key, count(*) distinct_files_backed
         from (select unique a.db_key,
                thread#, sequence#, resetlogs_change#, resetlogs_time
                from rc_backup_redolog a, rc_backup_set_details b
               where a.bs_key = b.bs_key and a.db_key = b.db_key) 
        group by db_key)b,
       (select db_key, nvl(sum(original_input_bytes),0) original_input_bytes,
         nvl(sum(output_bytes), 0) output_bytes
       from (select unique db_key, bs_key, original_input_bytes,
                      output_bytes from
             rc_backup_set_details where backup_type='L') 
       group by db_key)c
    where
       a.db_key = b.db_key and
       b.db_key = c.db_key)
    union
    (select a.db_key,
       num_files_backed,
       distinct_files_backed,
       min_first_change#,
       max_next_change#,
       min_first_time,
       max_next_time,
       original_input_bytes,
       output_bytes
     from
       (select a.db_key, 
         count(*) num_files_backed,
         min(first_change#)min_first_change#,
         max(next_change#) max_next_change#,
         min(first_time)min_first_time,
         max(next_time) max_next_time,
         nvl(sum((blocks+1)*block_size),0) original_input_bytes,
         nvl(sum((blocks+1)*block_size),0) output_bytes
         from rc_proxy_archivedlog a, rc_rman_status b,
       (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
       (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
       (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
        where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key group by a.db_key) a,
           (select db_key, count(*) distinct_files_backed
             from (select unique a.db_key,
             thread#, sequence#, resetlogs_change#, resetlogs_time
             from rc_proxy_archivedlog a, rc_rman_status b,
      (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
      (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
      (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
         where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key) group by db_key)b 
   where a.db_key=b.db_key))
   group by db_key)a, 
   rc_database db where a.db_key=db.db_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_CONTROLFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_CONTROLFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "BCF_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "CREATION_TIME", "BLOCK_SIZE", "OLDEST_OFFLINE_RANGE", "STATUS", "BS_RECID", "BS_STAMP", "BS_LEVEL", "COMPLETION_TIME", "CONTROLFILE_TYPE", "BLOCKS", "AUTOBACKUP_DATE", "AUTOBACKUP_SEQUENCE") AS 
  select db_key,
       dbinc_key,
       db_name,
       bcf_key,
       recid,
       stamp,
       bs_key,
       set_stamp,
       set_count,
       resetlogs_change#,
       resetlogs_time,
       checkpoint_change#,
       checkpoint_time,
       creation_time,
       block_size,
       oldest_offline_range,
       status,
       bs_recid,
       bs_stamp,
       bs_level,
       completion_time,
       controlfile_type,
       blocks,
       autobackup_date,
       autobackup_sequence
from rci_backup_controlfile

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_CONTROLFILE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_CONTROLFILE_DETAILS" ("BTYPE", "BTYPE_KEY", "SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "ID1", "ID2", "CREATION_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "FILESIZE", "COMPRESSION_RATIO", "FILESIZE_DISPLAY") AS 
  select a."BTYPE",a."BTYPE_KEY",a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."DB_KEY",a."DB_NAME",a."ID1",a."ID2",a."CREATION_TIME",a."RESETLOGS_CHANGE#",a."RESETLOGS_TIME",a."CHECKPOINT_CHANGE#",a."CHECKPOINT_TIME",a."FILESIZE",a."COMPRESSION_RATIO",
      dbms_rcvman.Num2DisplaySize(filesize) filesize_display 
from 
(select unique 'BACKUPSET' btype, b.bs_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       a.db_key, a.db_name,
       a.set_stamp id1, 
       b.set_count id2,
       creation_time,
       resetlogs_change#, resetlogs_time, checkpoint_change#, checkpoint_time,
       (a.blocks+1)*a.block_size filesize,
       1 compression_ratio
   from rc_backup_controlfile a, rc_backup_set_details b where
        a.bs_key = b.bs_key
union
select unique 'IMAGECOPY' btype, a.ccf_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       a.db_key, a.db_name,
       a.recid, a.stamp,
       creation_time,
       resetlogs_change#, resetlogs_time, checkpoint_change#, checkpoint_time,
       (blocks+1)*block_size filesize,
       1 compression_ratio
   from rc_controlfile_copy a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time)
union
select unique 'PROXYCOPY' btype, a.xcf_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       a.db_key, a.db_name,
       a.recid, a.stamp,
       creation_time,
       resetlogs_change#, resetlogs_time, checkpoint_change#, checkpoint_time,
       (blocks+1)*block_size filesize,
       1 compression_ratio
   from rc_proxy_controlfile a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and
           (c.skey is null or c.skey = b.session_recid) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time))a

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_CONTROLFILE_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_CONTROLFILE_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_FILES_BACKED", "NUM_DISTINCT_FILES_BACKED", "MIN_CHECKPOINT_CHANGE#", "MAX_CHECKPOINT_CHANGE#", "MIN_CHECKPOINT_TIME", "MAX_CHECKPOINT_TIME", "INPUT_BYTES", "OUTPUT_BYTES", "COMPRESSION_RATIO", "INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY") AS 
  select b.name db_name, a."DB_KEY",a."NUM_FILES_BACKED",a."NUM_DISTINCT_FILES_BACKED",a."MIN_CHECKPOINT_CHANGE#",a."MAX_CHECKPOINT_CHANGE#",a."MIN_CHECKPOINT_TIME",a."MAX_CHECKPOINT_TIME",a."INPUT_BYTES",a."OUTPUT_BYTES", 
       case when 
         input_bytes/decode(output_bytes, 0, null, output_bytes) > 1
       then 
         input_bytes/decode(output_bytes, 0, null, output_bytes) 
       else 1 end compression_ratio,
       dbms_rcvman.Num2DisplaySize(input_bytes) input_bytes_display,
       dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display 
from
(select db_key, 
       sum(num_times_backed) num_files_backed, 
       1 num_distinct_files_backed,
       min(min_checkpoint_change#) min_checkpoint_change#,
       max(max_checkpoint_change#) max_checkpoint_change#,
       min(min_checkpoint_time) min_checkpoint_time,
       max(max_checkpoint_time) max_checkpoint_time,
       sum(input_bytes) input_bytes,
       sum(output_bytes) output_bytes
   from
    ((select a.db_key,
       count(*) over (partition by creation_time) 
            num_times_backed,
       min(checkpoint_change#) over (partition by creation_time) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by creation_time) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by creation_time) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by creation_time) 
                 max_checkpoint_time,
       sum((blocks+1)*a.block_size)
                 over (partition by creation_time) input_bytes,
       sum((blocks+1)*a.block_size) over (partition by creation_time)
                 output_bytes,
       creation_time
    from rc_backup_controlfile a, 
         (select unique db_key, bs_key from
          rc_backup_set_details) b
    where a.bs_key = b.bs_key and
          a.db_key = b.db_key
    )
    union
    (select a.db_key,
       count(*) over (partition by creation_time)
              num_times_backed,
       min(checkpoint_change#) over (partition by creation_time) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by creation_time) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by creation_time) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by creation_time) 
                 max_checkpoint_time,
       sum((blocks+1)*block_size) over (partition by creation_time)
                 input_bytes,
       sum((blocks+1)*block_size) over (partition by creation_time)
                 output_bytes,
       creation_time
    from rc_controlfile_copy a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key
    )
    union
    (select a.db_key, 
       count(*) over (partition by creation_time)
              num_times_backed,
       min(checkpoint_change#) over (partition by creation_time) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by creation_time) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by creation_time) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by creation_time) 
                 max_checkpoint_time,
       sum((blocks+1)*block_size) over (partition by creation_time)
                 input_bytes,
       sum((blocks+1)*block_size) over (partition by creation_time)
                 output_bytes,
       creation_time
    from rc_proxy_controlfile a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key
    ))group by db_key)a, rc_database b where a.db_key=b.db_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_COPY_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_COPY_DETAILS" ("SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "RSR_KEY", "COPY_KEY", "FILE#", "NAME", "TAG", "CREATION_CHANGE#", "CREATION_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "MARKED_CORRUPT", "OUTPUT_BYTES", "COMPLETION_TIME", "CONTROLFILE_TYPE", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "IS_RECOVERY_DEST_FILE", "SPARSE_BACKUP", "OUTPUT_BYTES_DISPLAY") AS 
  select a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."DB_KEY",a."DB_NAME",a."RSR_KEY",a."COPY_KEY",a."FILE#",a."NAME",a."TAG",a."CREATION_CHANGE#",a."CREATION_TIME",a."CHECKPOINT_CHANGE#",a."CHECKPOINT_TIME",a."MARKED_CORRUPT",a."OUTPUT_BYTES",a."COMPLETION_TIME",a."CONTROLFILE_TYPE",a."KEEP",a."KEEP_UNTIL",a."KEEP_OPTIONS",a."IS_RECOVERY_DEST_FILE",a."SPARSE_BACKUP",
   dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display from
(select b.session_key, b.session_recid, b.session_stamp, 
        a.*
  from
   ((select db_key, db_name, rsr_key, cdf_key copy_key, file#, name, tag,
       creation_change#, 
       creation_time, checkpoint_change#, checkpoint_time,
       marked_corrupt, (blocks+1)*block_size output_bytes,
       completion_time, null controlfile_type, keep, keep_until,
       keep_options, is_recovery_dest_file, sparse_backup
  from rc_datafile_copy where status='A')
  union
   (select db_key, db_name, rsr_key, ccf_key copy_key, 0, name, tag,
       null creation_change#, 
       creation_time, checkpoint_change#, checkpoint_time, 
       null, (blocks +1)*block_size output_bytes,
       completion_time, controlfile_type, keep, keep_until,
       keep_options, is_recovery_dest_file, 'NO' sparse_backup
  from rc_controlfile_copy where status='A')) a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time))a

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_COPY_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_COPY_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_COPIES", "NUM_DISTINCT_COPIES", "MIN_CHECKPOINT_CHANGE#", "MAX_CHECKPOINT_CHANGE#", "MIN_CHECKPOINT_TIME", "MAX_CHECKPOINT_TIME", "OUTPUT_BYTES", "OUTPUT_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_COPIES",a."NUM_DISTINCT_COPIES",a."MIN_CHECKPOINT_CHANGE#",a."MAX_CHECKPOINT_CHANGE#",a."MIN_CHECKPOINT_TIME",a."MAX_CHECKPOINT_TIME",a."OUTPUT_BYTES",
       dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display
from
(select db_key, nvl(sum(num_times_backed),0) num_copies,
       sum(distinct_copies)  num_distinct_copies,
       min(min_checkpoint_change#) min_checkpoint_change#,
       max(max_checkpoint_change#) max_checkpoint_change#,
       min(min_checkpoint_time) min_checkpoint_time,
       max(max_checkpoint_time) max_checkpoint_time,
       sum(output_bytes) output_bytes
   from
    (select unique a.db_key,
       file#, count(*) over (partition by file#, creation_change#)
              num_times_backed,
       count(distinct file#) 
               over (partition by file#, creation_change#, checkpoint_change#)
                distinct_copies,
       min(checkpoint_change#) over (partition by file#, creation_change#) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by file#, creation_change#) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by file#, creation_change#) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by file#, creation_change#) 
                 max_checkpoint_time,
       sum((blocks+1)*block_size) over (partition by file#, creation_change#)
                 output_bytes
    from rc_datafile_copy a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key=b.db_key
   union
     select unique a.db_key, 
       0 file#, count(*) over (partition by creation_time)
              num_times_backed,
       1      distinct_copies,
       min(checkpoint_change#) over (partition by creation_time) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by creation_time) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by creation_time) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by creation_time) 
                 max_checkpoint_time,
       sum((blocks+1)*block_size) over (partition by creation_time)
                 output_bytes
    from rc_controlfile_copy a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key=b.db_key) group by db_key)a, rc_database db 
where a.db_key=db.db_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_CORRUPTION
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_CORRUPTION" ("DB_KEY", "DBINC_KEY", "DB_NAME", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "PIECE#", "BDF_KEY", "BDF_RECID", "BDF_STAMP", "FILE#", "CREATION_CHANGE#", "BLOCK#", "BLOCKS", "CORRUPTION_CHANGE#", "MARKED_CORRUPT", "CORRUPTION_TYPE") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       bcb.bcb_recid recid,
       bcb.bcb_stamp stamp,
       bs.bs_key,
       bs.set_stamp,
       bs.set_count,
       bcb.piece#,
       bdf.bdf_key,
       bdf.bdf_recid,
       bdf.bdf_stamp,
       bdf.file#,
       bdf.create_scn creation_change#,
       bcb.block#,
       bcb.blocks,
       bcb.corrupt_scn corruption_change#,
       decode(bcb.marked_corrupt,'N', 'NO', 'Y', 'YES', '?') marked_corrupt,
       bcb.corruption_type
from dbinc, bs, bdf, bcb
where dbinc.dbinc_key = bdf.dbinc_key
and   bs.bs_key = bdf.bs_key
and   bdf.bdf_key = bcb.bdf_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_DATAFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "PDB_KEY", "BDF_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "BS_RECID", "BS_STAMP", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "COMPLETION_TIME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "INCREMENTAL_CHANGE#", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "ABSOLUTE_FUZZY_CHANGE#", "DATAFILE_BLOCKS", "BLOCKS", "BLOCK_SIZE", "STATUS", "BS_LEVEL", "PIECES", "BLOCKS_READ", "MARKED_CORRUPT", "USED_CHANGE_TRACKING", "USED_OPTIMIZATION", "PCT_NOTREAD", "FOREIGN_DBID", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "SECTION_SIZE", "SPARSE_BACKUP") AS 
  select db_key,
       dbinc_key,
       db_name,
       pdb_key,
       bdf_key,
       recid,
       stamp,
       bs_key,
       set_stamp,
       set_count,
       bs_recid,
       bs_stamp,
       backup_type,
       incremental_level,
       completion_time,
       file#,
       creation_change#,
       creation_time,
       resetlogs_change#,
       resetlogs_time,
       incremental_change#,
       checkpoint_change#,
       checkpoint_time,
       absolute_fuzzy_change#,
       datafile_blocks,
       blocks,
       block_size,
       status,
       bs_level,
       pieces,
       blocks_read,
       marked_corrupt,
       used_change_tracking,
       used_optimization,
       pct_notread,
       foreign_dbid,
       plugged_readonly,
       plugin_change#,
       plugin_resetlogs_change#,
       plugin_resetlogs_time,
       section_size,
       sparse_backup
from rci_backup_datafile

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_DATAFILE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_DATAFILE_DETAILS" ("BTYPE", "BTYPE_KEY", "SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "ID1", "ID2", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "INCREMENTAL_LEVEL", "INCREMENTAL_CHANGE#", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "MARKED_CORRUPT", "FILESIZE", "COMPRESSION_RATIO", "SPARSE_BACKUP", "CON_ID", "PDB_NAME", "PDB_KEY", "TS#", "TSNAME", "FILESIZE_DISPLAY") AS 
  select a."BTYPE",a."BTYPE_KEY",a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."DB_KEY",a."DB_NAME",a."ID1",a."ID2",a."FILE#",a."CREATION_CHANGE#",a."CREATION_TIME",a."RESETLOGS_CHANGE#",a."RESETLOGS_TIME",a."INCREMENTAL_LEVEL",a."INCREMENTAL_CHANGE#",a."CHECKPOINT_CHANGE#",a."CHECKPOINT_TIME",a."MARKED_CORRUPT",a."FILESIZE",a."COMPRESSION_RATIO",a."SPARSE_BACKUP", b.con_id, b.pdb_name, b.pdb_key, b.ts#, b.name tsname,
   dbms_rcvman.Num2DisplaySize(filesize) filesize_display from
(select unique 'BACKUPSET' btype, b.bs_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       b.db_key, b.db_name,
       a.set_stamp id1, 
       b.set_count id2, file#, 
       creation_change#, creation_time,
       resetlogs_change#, resetlogs_time, a.incremental_level, 
       incremental_change#, checkpoint_change#, checkpoint_time,
       marked_corrupt,
       (datafile_blocks+1)*a.block_size filesize,
       (datafile_blocks+1)/(blocks+1) compression_ratio,
       a.sparse_backup
   from rc_backup_datafile a, rc_backup_set_details b where
        a.bs_key = b.bs_key
union
select unique 'IMAGECOPY' btype, a.cdf_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       a.db_key, a.db_name,
       a.recid, a.stamp, file#, 
       creation_change#, creation_time,
       resetlogs_change#, resetlogs_time, incremental_level, 
       0 incremental_change#, checkpoint_change#, checkpoint_time,
       marked_corrupt,
       (blocks+1)*block_size filesize,
       1 compression_ratio,
       a.sparse_backup
   from rc_datafile_copy a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time)
union
select unique 'PROXYCOPY' btype, a.xdf_key btype_key, 
       b.session_key,
       b.session_recid,
       b.session_stamp,
       a.db_key, a.db_name,
       a.recid, a.stamp, file#,
       creation_change#, creation_time,
       resetlogs_change#, resetlogs_time, incremental_level, 
       0 incremental_change#, checkpoint_change#, checkpoint_time,
       null marked_corrupt, 
       (blocks+1)*block_size filesize,
       1 compression_ratio,
       'NO' sparse_backup
   from rc_proxy_datafile a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time)) a,
(select distinct df.db_key, df.file#, df.ts#, df.con_id, df.pdb_name,
                 df.pdb_key, ts.name
   from rci_datafile df, rc_tablespace ts
 where ts.ts# = df.ts# and ts.pdb_key = df.pdb_key and df.db_key=ts.db_key) b
where a.file# = b.file#(+) and a.db_key=b.db_key(+)

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_DATAFILE_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_DATAFILE_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_FILES_BACKED", "NUM_DISTINCT_FILES_BACKED", "NUM_DISTINCT_TS_BACKED", "MIN_CHECKPOINT_CHANGE#", "MAX_CHECKPOINT_CHANGE#", "MIN_CHECKPOINT_TIME", "MAX_CHECKPOINT_TIME", "INPUT_BYTES", "OUTPUT_BYTES", "COMPRESSION_RATIO", "INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_FILES_BACKED",a."NUM_DISTINCT_FILES_BACKED",a."NUM_DISTINCT_TS_BACKED",a."MIN_CHECKPOINT_CHANGE#",a."MAX_CHECKPOINT_CHANGE#",a."MIN_CHECKPOINT_TIME",a."MAX_CHECKPOINT_TIME",a."INPUT_BYTES",a."OUTPUT_BYTES",
    case when 
      input_bytes/decode(output_bytes, 0, null, output_bytes) > 1
    then 
      input_bytes/decode(output_bytes, 0, null, output_bytes)
    else 1 end compression_ratio,
       dbms_rcvman.Num2DisplaySize(input_bytes) input_bytes_display,
       dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display 
from
(select db_key, sum(num_times_backed) num_files_backed, 
       sum(distinct_files_backed) num_distinct_files_backed,
       count(distinct ts# || '.' || pdb_key)  num_distinct_ts_backed,
       min(min_checkpoint_change#) min_checkpoint_change#,
       max(max_checkpoint_change#) max_checkpoint_change#,
       min(min_checkpoint_time) min_checkpoint_time,
       max(max_checkpoint_time) max_checkpoint_time, 
       sum(input_bytes) input_bytes,
       sum(output_bytes) output_bytes
   from
   ( select a.*, b.ts#, b.pdb_key, count(distinct a.file#) 
         over (partition by a.file#, a.creation_change#) distinct_files_backed
   from 
   (select unique a.db_key,
           a.file#, sum(a.num_times_backed) num_times_backed,
           min(min_checkpoint_change#) min_checkpoint_change#,
           max(max_checkpoint_change#) max_checkpoint_change#,
           min(min_checkpoint_time) min_checkpoint_time,
           max(max_checkpoint_time) max_checkpoint_time,
           sum(input_bytes) input_bytes,
           sum(output_bytes) output_bytes,
           creation_change#
    from
    ((select a.db_key,
            file#,count(*) over (partition by a.db_key,file#, creation_change#) 
            num_times_backed,
            min(checkpoint_change#) over
                          (partition by a.db_key,file#, creation_change#) 
                 min_checkpoint_change#,
            max(checkpoint_change#) over
                          (partition by a.db_key,file#, creation_change#) 
            max_checkpoint_change#,
            min(checkpoint_time) over 
                          (partition by a.db_key,file#, creation_change#) 
            min_checkpoint_time,
            max(checkpoint_time) over 
                          (partition by a.db_key,file#, creation_change#) 
            max_checkpoint_time,
            sum((datafile_blocks+1)*a.block_size) over
                  (partition by a.db_key,file#, creation_change#) input_bytes,
            sum((a.blocks+1)*a.block_size) over
                  (partition by a.db_key,file#, creation_change#) output_bytes,
       creation_change#
    from rc_backup_datafile a, 
         (select unique db_key, bs_key from rc_backup_set_details) b
    where a.bs_key = b.bs_key and
          a.db_key = b.db_key
    )
    union
    (select unique  a.db_key,
           file#, count(*) over (partition by a.db_key, file#, creation_change#)
           num_times_backed,
           min(checkpoint_change#) over
              (partition by a.db_key, file#, creation_change#) 
              min_checkpoint_change#,
           max(checkpoint_change#) over 
               (partition by a.db_key, file#, creation_change#) 
               max_checkpoint_change#,
           min(checkpoint_time) over
               (partition by a.db_key, file#, creation_change#) 
               min_checkpoint_time,
           max(checkpoint_time) over
                (partition by a.db_key,file#, creation_change#) 
                max_checkpoint_time,
           sum((blocks+1)*block_size) over
                (partition by a.db_key,file#, creation_change#)
                input_bytes,
           sum((blocks+1)*block_size) over
                 (partition by a.db_key,file#, creation_change#)
                 output_bytes,
           creation_change#
    from rc_datafile_copy a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key
    )
    union
    (select unique  a.db_key,
           file#, 
           count(*) over 
             (partition by a.db_key, file#, creation_change#) num_times_backed,
           min(checkpoint_change#) over 
               (partition by a.db_key, file#, creation_change#) 
               min_checkpoint_change#,
           max(checkpoint_change#) over
               (partition by a.db_key, file#, creation_change#) 
               max_checkpoint_change#,
           min(checkpoint_time) over
               (partition by a.db_key, file#, creation_change#) 
               min_checkpoint_time,
           max(checkpoint_time) over
               (partition by a.db_key, file#, creation_change#) 
               max_checkpoint_time,
           sum((blocks+1)*block_size) over
               (partition by a.db_key, file#, creation_change#)
               input_bytes,
           sum((blocks+1)*block_size) over
               (partition by a.db_key, file#, creation_change#)
               output_bytes,
           creation_change#
    from rc_proxy_datafile a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key
    )) a group by a.db_key, a.file#, creation_change#) a,
    (select  distinct df.db_key, df.file#, df.ts#, df.pdb_key, ts.name 
          from rci_datafile df, rc_tablespace ts 
      where ts.ts# = df.ts# and
            ts.pdb_key = df.pdb_key and
            ts.db_key = df.db_key) b
where a.db_key = b.db_key and a.file# = b.file#(+)) 
  group by db_key)a, rc_database db where a.db_key = db.db_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_FILES
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_FILES" ("PKEY", "BACKUP_TYPE", "FILE_TYPE", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "STATUS", "FNAME", "TAG", "MEDIA", "RECID", "STAMP", "DEVICE_TYPE", "BLOCK_SIZE", "COMPLETION_TIME", "COMPRESSED", "OBSOLETE", "BYTES", "BS_KEY", "BS_COUNT", "BS_STAMP", "BS_TYPE", "BS_INCR_TYPE", "BS_PIECES", "BS_COPIES", "BS_COMPLETION_TIME", "BS_STATUS", "BS_BYTES", "BS_COMPRESSED", "BS_TAG", "BS_DEVICE_TYPE", "BP_PIECE#", "BP_COPY#", "DF_FILE#", "DF_TABLESPACE", "DF_RESETLOGS_CHANGE#", "DF_CREATION_CHANGE#", "DF_CHECKPOINT_CHANGE#", "DF_CKP_MOD_TIME", "RL_THREAD#", "RL_SEQUENCE#", "RL_RESETLOGS_CHANGE#", "RL_FIRST_CHANGE#", "RL_FIRST_TIME", "RL_NEXT_CHANGE#", "RL_NEXT_TIME") AS 
  select pkey,
                 backup_type,
                 file_type,
                 keep,
                 keep_until,
                 keep_options,
                 status,
                 fname,
                 tag,
                 media,
                 recid,
                 stamp,
                 device_type,
                 block_size,
                 completion_time,
                 compressed,
                 obsolete,
                 bytes,
                 bs_key,
                 bs_count,
                 bs_stamp,
                 bs_type,
                 bs_incr_type,
                 bs_pieces,
                 bs_copies,
                 bs_completion_time,
                 bs_status,
                 bs_bytes,
                 bs_compressed,
                 bs_tag,
                 bs_device_type,
                 bp_piece#,
                 bp_copy#,
                 df_file#,
                 df_tablespace,
                 df_resetlogs_change#,
                 df_creation_change#,
                 df_checkpoint_change#,
                 df_ckp_mod_time,
                 rl_thread#,
                 rl_sequence#,
                 rl_resetlogs_change#,
                 rl_first_change#,
                 rl_first_time,
                 rl_next_change#,
                 rl_next_time
                 from TABLE(rc_listBackupPipe)

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_PIECE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_PIECE" ("DB_KEY", "DB_ID", "PDB_KEY", "BP_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "PIECE#", "COPY#", "DEVICE_TYPE", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "CONCUR", "TAG", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "BYTES", "IS_RECOVERY_DEST_FILE", "RSR_KEY", "COMPRESSED", "SITE_KEY", "ENCRYPTED", "BACKED_BY_OSB", "BA_ACCESS", "VB_KEY", "VIRTUAL", "LIB_KEY") AS 
  select db_key,
       db_id,
       pdb_key,
       bp_key,
       recid,
       stamp,
       bs_key,
       set_stamp,
       set_count,
       backup_type,
       incremental_level,
       piece#,
       copy#,
       device_type,
       handle,
       comments,
       media,
       media_pool,
       concur,
       tag,
       start_time,
       completion_time,
       elapsed_seconds,
       status,
       bytes,
       is_recovery_dest_file,
       rsr_key,
       compressed,
       site_key,
       encrypted,
       backed_by_osb,
       ba_access,
       vb_key,
       virtual,
       lib_key
from rci_backup_piece

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_PIECE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_PIECE_DETAILS" ("SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_NAME", "DB_KEY", "DB_ID", "PDB_KEY", "BP_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "PIECE#", "COPY#", "DEVICE_TYPE", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "CONCUR", "TAG", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "BYTES", "IS_RECOVERY_DEST_FILE", "RSR_KEY", "COMPRESSED", "SITE_KEY", "ENCRYPTED", "BACKED_BY_OSB", "BA_ACCESS", "VB_KEY", "VIRTUAL", "LIB_KEY", "PIECES_PER_SET", "SIZE_BYTES_DISPLAY") AS 
  select unique b.session_key,b.session_recid,b.session_stamp,
              a."DB_NAME",a."DB_KEY",a."DB_ID",a."PDB_KEY",a."BP_KEY",a."RECID",a."STAMP",a."BS_KEY",a."SET_STAMP",a."SET_COUNT",a."BACKUP_TYPE",a."INCREMENTAL_LEVEL",a."PIECE#",a."COPY#",a."DEVICE_TYPE",a."HANDLE",a."COMMENTS",a."MEDIA",a."MEDIA_POOL",a."CONCUR",a."TAG",a."START_TIME",a."COMPLETION_TIME",a."ELAPSED_SECONDS",a."STATUS",a."BYTES",a."IS_RECOVERY_DEST_FILE",a."RSR_KEY",a."COMPRESSED",a."SITE_KEY",a."ENCRYPTED",a."BACKED_BY_OSB",a."BA_ACCESS",a."VB_KEY",a."VIRTUAL",a."LIB_KEY",a."PIECES_PER_SET",
   dbms_rcvman.Num2DisplaySize(bytes) size_bytes_display
   from 
   (select f.db_name, c.*
   from rc_backup_set a, 
   (select rc_backup_piece.*,
        count(piece#) over 
            (partition by bs_key, copy#) pieces_per_set
    from rc_backup_piece
    where status = 'A') c,
    (select db_key, name "DB_NAME" from rc_database) f
    where a.bs_key = c.bs_key and
          a.db_key = f.db_key and
          a.pieces = c.pieces_per_set) a, 
   (select session_key, session_recid, session_stamp, recid, stamp, rsr_key,
           start_time, end_time, db_key, db_name
    from rc_rman_status) b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time)

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_REDOLOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_REDOLOG" ("DB_KEY", "DBINC_KEY", "DB_NAME", "BRL_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "COMPLETION_TIME", "THREAD#", "SEQUENCE#", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "FIRST_CHANGE#", "FIRST_TIME", "NEXT_CHANGE#", "NEXT_TIME", "BLOCKS", "BLOCK_SIZE", "STATUS", "BS_RECID", "BS_STAMP", "PIECES", "TERMINAL", "PARTIAL") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       brl.brl_key,
       brl.brl_recid recid,
       brl.brl_stamp stamp,
       bs.bs_key,
       bs.set_stamp,
       bs.set_count,
       bs.bck_type backup_type,
       bs.completion_time,
       brl.thread#,
       brl.sequence#,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       brl.low_scn first_change#,
       brl.low_time first_time,
       brl.next_scn next_change#,
       brl.next_time,
       brl.blocks,
       brl.block_size,
       bs.status,
       bs_recid,
       bs_stamp,
       bs.pieces,
       brl.terminal,
       decode(activation,'Y','YES','NO') partial 
from dbinc, bs, brl
where dbinc.dbinc_key = brl.dbinc_key
and   bs.bs_key = brl.bs_key
and   bs.bck_type = 'L'

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_SET
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_SET" ("DB_KEY", "DB_ID", "PDB_KEY", "BS_KEY", "RECID", "STAMP", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "INCREMENTAL_LEVEL", "PIECES", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "CONTROLFILE_INCLUDED", "INPUT_FILE_SCAN_ONLY", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "BLOCK_SIZE", "SITE_KEY", "MULTI_SECTION") AS 
  select db_key,
       db_id,
       pdb_key,
       bs_key,
       recid,
       stamp,
       set_stamp,
       set_count,
       backup_type,
       incremental_level,
       pieces,
       start_time,
       completion_time,
       elapsed_seconds,
       status,
       controlfile_included,
       input_file_scan_only,
       keep,
       keep_until,
       keep_options,
       block_size,
       site_key,
       multi_section
from rci_backup_set

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_SET_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_SET_DETAILS" ("SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "BS_KEY", "RECID", "STAMP", "SET_STAMP", "SET_COUNT", "BACKUP_TYPE", "CONTROLFILE_INCLUDED", "INCREMENTAL_LEVEL", "PIECES", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "BLOCK_SIZE", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "DEVICE_TYPE", "COMPRESSED", "NUM_COPIES", "OUTPUT_BYTES", "ORIGINAL_INPUT_BYTES", "COMPRESSION_RATIO", "STATUS", "ORIGINAL_INPRATE_BYTES", "OUTPUT_RATE_BYTES", "ORIGINAL_INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY", "ORIGINAL_INPRATE_BYTES_DISPLAY", "OUTPUT_RATE_BYTES_DISPLAY", "TIME_TAKEN_DISPLAY", "ENCRYPTED", "BACKED_BY_OSB") AS 
  select unique b.session_key,  b.session_recid, b.session_stamp, 
              a.db_key, f.db_name,
              a.bs_key, a.RECID, a.stamp,
              a.set_stamp, a.set_count, a.backup_type, a.controlfile_included,
              a.incremental_level, a.pieces, a.start_time, a.completion_time,
              a.elapsed_seconds, a.block_size, a.keep, a.keep_until,
              a.keep_options, a.device_type, a.compressed,
              a.num_copies, a.output_bytes,
              a.original_input_bytes, 
              case when a.compression_ratio>1 then
                a.compression_ratio else 1 end compression_ratio, 'A' status,
              a.original_inprate_bytes, a.output_rate_bytes,
   dbms_rcvman.Num2DisplaySize(original_input_bytes) 
      original_input_bytes_display,
   dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display,
   dbms_rcvman.Num2DisplaySize(original_inprate_bytes) 
      original_inprate_bytes_display,
   dbms_rcvman.Num2DisplaySize(output_rate_bytes) output_rate_bytes_display,
   dbms_rcvman.Sec2DisplayTime(elapsed_seconds) time_taken_display,
   a.encrypted, a.backed_by_osb
   from 
   (
   select unique a.*,
       b.rsr_key,
       decode(b.devcnt, 1, first_value(b.device_type) over 
                                      (partition by b.bs_key), 
                            '*') device_type, b.compressed,
        count(distinct copy#)
             over (partition by b.bs_key) num_copies,
        b.output_bytes output_bytes, 
        c.original_input_bytes,
        c.original_input_bytes /
          (decode(b.output_bytes,0,c.original_input_bytes,
                  b.output_bytes)) compression_ratio,
        c.original_input_bytes/
                (decode(a.elapsed_seconds, 0, 1, a.elapsed_seconds))
                original_inprate_bytes,
        b.output_bytes/
                (decode(a.elapsed_seconds, 0, 1, a.elapsed_seconds))
                output_rate_bytes,
        b.encrypted, b.backed_by_osb
   from rc_backup_set a,
   (select bs_key, device_type, status,
    count(distinct device_type) over (partition by bs_key)devcnt,
    compressed,
    sum(bytes) over (partition by bs_key, copy#) output_bytes, 
    copy#, rsr_key, 
    count(piece#) over (partition by bs_key, copy#) npieces,
    encrypted, backed_by_osb
    from rc_backup_piece where status = 'A') b,
   (
    select bs_key,
      sum(original_input_bytes)  original_input_bytes
    from
    (
      select bs_key,
        sum((datafile_blocks+1)*block_size) 
           over (partition by bs_key) original_input_bytes
      from rc_backup_datafile
      union
      select bs_key,
        sum((blocks+1)*block_size) 
          over (partition by bs_key) original_input_bytes
      from rc_backup_controlfile
      union
      select bs_key,
        sum(bytes) over (partition by bs_key) original_input_bytes
      from rc_backup_spfile
    ) group by bs_key
    union
    select bs_key,
      sum((blocks+1)*block_size)
       over (partition by bs_key) original_input_bytes
    from rc_backup_redolog
    ) c
   where a.bs_key=b.bs_key and
         a.bs_key=c.bs_key and
         a.pieces=b.npieces
   ) a,
   (select session_key, session_recid, session_stamp, recid, stamp, rsr_key,
    start_time, end_time, db_key, db_name
    from rc_rman_status) b,
   (select db_key, name "DB_NAME" from rc_database) f,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.rsr_key = b.rsr_key (+) and 
           a.db_key = f.db_key and
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time)

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_SET_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_SET_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_BACKUPSETS", "OLDEST_BACKUP_TIME", "NEWEST_BACKUP_TIME", "OUTPUT_BYTES", "ORIGINAL_INPUT_BYTES", "ORIGINAL_INPRATE_BYTES", "OUTPUT_RATE_BYTES", "COMPRESSION_RATIO", "ORIGINAL_INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY", "ORIGINAL_INPRATE_BYTES_DISPLAY", "OUTPUT_RATE_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_BACKUPSETS",a."OLDEST_BACKUP_TIME",a."NEWEST_BACKUP_TIME",a."OUTPUT_BYTES",a."ORIGINAL_INPUT_BYTES",a."ORIGINAL_INPRATE_BYTES",a."OUTPUT_RATE_BYTES",
    case when 
      original_input_bytes/decode(output_bytes, 0, null, output_bytes) > 1
    then 
      original_input_bytes/decode(output_bytes, 0, null, output_bytes)
    else 1 end compression_ratio,
    dbms_rcvman.Num2DisplaySize(original_input_bytes) 
              original_input_bytes_display,
    dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display ,
    dbms_rcvman.Num2DisplaySize(original_inprate_bytes) 
              original_inprate_bytes_display,
    dbms_rcvman.Num2DisplaySize(output_rate_bytes) output_rate_bytes_display
from 
(select db_key, count(*) num_backupsets,
       min(start_time) oldest_backup_time,
       max(start_time) newest_backup_time,
       sum(output_bytes) output_bytes,
       sum(original_input_bytes) original_input_bytes,
       avg(original_inprate_bytes) original_inprate_bytes,
       avg(output_rate_bytes) output_rate_bytes
from 
  (select unique db_key,
     set_stamp, set_count,
     start_time,
     output_bytes,
     original_input_bytes,
     original_inprate_bytes,
     output_rate_bytes,
     compression_ratio
   from
     rc_backup_set_details) group by db_key)a, rc_database db 
   where db.db_key = a.db_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_SPFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_SPFILE" ("DB_KEY", "BSF_KEY", "RECID", "STAMP", "BS_KEY", "SET_STAMP", "SET_COUNT", "MODIFICATION_TIME", "STATUS", "BS_RECID", "BS_STAMP", "COMPLETION_TIME", "BYTES", "DB_UNIQUE_NAME") AS 
  select db_key,
       bsf_key,
       recid,
       stamp,
       bs_key,
       set_stamp,
       set_count,
       modification_time,
       status,
       bs_recid,
       bs_stamp,
       completion_time,
       bytes,
       db_unique_name
from rci_backup_spfile

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_SPFILE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_SPFILE_DETAILS" ("SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "BS_KEY", "SET_STAMP", "SET_COUNT", "MODIFICATION_TIME", "FILESIZE", "FILESIZE_DISPLAY") AS 
  select unique b.session_recid session_key, b.session_recid,
       b.session_stamp, b.db_key, b.db_name,
       b.recid bs_key, a.set_stamp, b.set_count, 
       modification_time,
       a.bytes filesize,
       dbms_rcvman.Num2DisplaySize(a.bytes) filesize_display
   from rc_backup_spfile a, rc_backup_set_details b where
        a.bs_key = b.bs_key

;
--------------------------------------------------------
--  DDL for View RC_BACKUP_SPFILE_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_BACKUP_SPFILE_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_FILES_BACKED", "NUM_DISTINCT_FILES_BACKED", "MIN_MODIFICATION_TIME", "MAX_MODIFICATION_TIME", "INPUT_BYTES", "INPUT_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_FILES_BACKED",a."NUM_DISTINCT_FILES_BACKED",a."MIN_MODIFICATION_TIME",a."MAX_MODIFICATION_TIME",a."INPUT_BYTES",
       dbms_rcvman.Num2DisplaySize(input_bytes) input_bytes_display
from
(select a.db_key, num_files_backed,
       num_distinct_files_backed,
       min_modification_time,
       max_modification_time,
       input_bytes
  from
  (select a.db_key, count(*) num_files_backed,
       min(modification_time)min_modification_time,
       max(modification_time) max_modification_time,
       sum(bytes) input_bytes
    from rc_backup_spfile a, rc_backup_set_details b
    where a.bs_key = b.bs_key and a.db_key=b.db_key
    group by a.db_key)a,
  (select db_key, count(*) num_distinct_files_backed
    from (select unique a.db_key, modification_time
          from rc_backup_spfile a, rc_backup_set_details b
          where a.bs_key = b.bs_key and a.db_key=b.db_key) group by db_key)b
   where a.db_key=b.db_key)a, rc_database db where a.db_key=db.db_key

;
--------------------------------------------------------
--  DDL for View RC_CHECKPOINT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_CHECKPOINT" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CKP_KEY", "CKP_SCN", "CKP_CF_SEQ", "CKP_TIME", "CKP_TYPE", "CKP_DB_STATUS", "SITE_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       ckp.ckp_key,
       ckp.ckp_scn,
       ckp.ckp_cf_seq,
       ckp.ckp_time,
       ckp.ckp_type,
       ckp.ckp_db_status,
       ckp.site_key
from ckp, dbinc
where ckp.dbinc_key = dbinc.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_CONTROLFILE_COPY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_CONTROLFILE_COPY" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CCF_KEY", "RECID", "STAMP", "NAME", "TAG", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "CREATION_TIME", "BLOCKS", "BLOCK_SIZE", "MIN_OFFR_RECID", "OLDEST_OFFLINE_RANGE", "COMPLETION_TIME", "STATUS", "CONTROLFILE_TYPE", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "IS_RECOVERY_DEST_FILE", "RSR_KEY", "SITE_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       ccf.ccf_key,
       ccf.ccf_recid recid,
       ccf.ccf_stamp stamp,
       ccf.fname name,
       ccf.tag,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       ccf.ckp_scn checkpoint_change#,
       ccf.ckp_time checkpoint_time,
       ccf.create_time creation_time,
--
       ccf.blocks,
       ccf.block_size,
       ccf.min_offr_recid,
       ccf.min_offr_recid oldest_offline_range,
       ccf.completion_time,
       ccf.status,
       ccf.controlfile_type,
       decode(keep_options, 0, 'NO',
                               'YES') keep,
       keep_until,
       decode(keep_options, 256,  'LOGS',
                            512,  'NOLOGS',
                            1024, 'BACKUP_LOGS',
                                  NULL) keep_options,
       ccf.is_recovery_dest_file,
       ccf.rsr_key,
       ccf.site_key
from dbinc, ccf
where dbinc.dbinc_key = ccf.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_COPY_CORRUPTION
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_COPY_CORRUPTION" ("DB_KEY", "DBINC_KEY", "DB_NAME", "RECID", "STAMP", "CDF_KEY", "COPY_RECID", "COPY_STAMP", "FILE#", "CREATION_CHANGE#", "BLOCK#", "BLOCKS", "CORRUPTION_CHANGE#", "MARKED_CORRUPT", "CORRUPTION_TYPE") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       ccb.ccb_recid recid,
       ccb.ccb_stamp stamp,
       cdf.cdf_key,
       cdf.cdf_recid copy_recid,
       cdf.cdf_stamp copy_stamp,
       cdf.file#,
       cdf.create_scn creation_change#,
       ccb.block#,
       ccb.blocks,
       ccb.corrupt_scn corruption_change#,
       decode(ccb.marked_corrupt,'N', 'NO', 'Y', 'YES', '?') marked_corrupt,
       ccb.corruption_type
from  dbinc, cdf, ccb
where dbinc.dbinc_key = cdf.dbinc_key
and   cdf.cdf_key = ccb.cdf_key
and   cdf.status = 'A'

;
--------------------------------------------------------
--  DDL for View RC_CURRENT_XMLFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_CURRENT_XMLFILE" ("NAME", "NAME_TAG", "VERSION_NUM", "SCHEMA_VER", "XML_COMMENT", "CREATION_TIME", "MODIFIED_TIME") AS 
  select name, name_tag, version_num, schema_ver, xml_comment,
             creation_time, modified_time  from
   (select name, name_tag, version_num,
    max(version_num) over (partition by name, name_tag) curr_version_num,
    creation_time,  
    last_value(modified_time) over (partition by name, name_tag, version_num) 
      modified_time,
    doctype,
    last_value(schema_ver) over (partition by name, name_tag, version_num) 
      schema_ver,
    last_value(xml_comment) over (partition by name, name_tag, version_num) 
      xml_comment
   from xmlstore) where version_num = curr_version_num

;
--------------------------------------------------------
--  DDL for View RC_DATABASE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DATABASE" ("DB_KEY", "DBINC_KEY", "DBID", "NAME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "FINAL_CHANGE#") AS 
  select db.db_key,
       db.curr_dbinc_key dbinc_key,
       db.db_id dbid,
       dbinc.db_name name,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       (CAST(NULL AS NUMBER)) final_change#
from db, dbinc
where db.curr_dbinc_key = dbinc.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_DATABASE_BLOCK_CORRUPTION
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DATABASE_BLOCK_CORRUPTION" ("DB_KEY", "DBINC_KEY", "FILE#", "BLOCK#", "BLOCKS", "CORRUPTION_CHANGE#", "CORRUPTION_TYPE") AS 
  select node.db_key                 db_key,
       df.dbinc_key                dbinc_key,
       df.file#                    file#,
       bcr.block#                  block#,
       bcr.blocks                  blocks,
       bcr.corrupt_scn             corruption_change#,
       bcr.corruption_type         corruption_type
  from bcr, df,
       (select dbinc_key from dbinc where dbinc_status = 'CURRENT') dbinc,
       (select distinct db_key, site_key
          from node where bcr_in_use = 'YES') node
 where bcr.df_key = df.df_key
   and node.site_key = bcr.site_key
   and df.drop_scn is null
   and df.dbinc_key = dbinc.dbinc_key
 
union all
 
select distinct
       outer.db_key                db_key,
       outer.dbinc_key             dbinc_key,
       outer.file#                 file#,
       outer.block#                block#,
       outer.blocks                blocks,
       outer.corruption_change#    corruption_change#,
       outer.corruption_type       corruption_type
  from (select db_key, dbinc_key, file#, block#, blocks,
               corruption_change#, copy_stamp stamp, corruption_type
          from rc_copy_corruption
         union
        select bs.db_key, dbinc_key, file#, block#, blocks,
               corruption_change#, bs.stamp, corruption_type
          from rc_backup_corruption bc, rc_backup_set bs
         where bc.bs_key = bs.bs_key) outer, 
               (select distinct db_key from node where bcr_in_use = 'NO') node
       where outer.db_key = node.db_key
         and not exists (select 1
                           from rc_datafile_copy
                          where outer.db_key = db_key and
                                outer.dbinc_key = dbinc_key and
                                scanned = 'YES' and
                                outer.file# = file# and
                                outer.stamp < stamp
                          union
                         select 1
                           from rc_backup_datafile bdf, rc_backup_set bs
                          where bdf.bs_key = bs.bs_key and
                                outer.db_key = bdf.db_key and
                                outer.dbinc_key = bdf.dbinc_key and
                                outer.file# = file# and
                                outer.stamp < bs.stamp and
                                (datafile_blocks = blocks_read or 
                                 (nvl(bdf.incremental_level,0) = 0 and
                                 used_optimization='YES')))

;
--------------------------------------------------------
--  DDL for View RC_DATABASE_INCARNATION
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DATABASE_INCARNATION" ("DB_KEY", "DBID", "DBINC_KEY", "NAME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "CURRENT_INCARNATION", "PARENT_DBINC_KEY", "PRIOR_RESETLOGS_CHANGE#", "PRIOR_RESETLOGS_TIME", "STATUS", "REG_DB_UNIQUE_NAME", "CON_ID", "GUID") AS 
  select db.db_key,
       db.db_id dbid,
       cur.dbinc_key,
       cur.db_name name,
       cur.reset_scn resetlogs_change#,
       cur.reset_time resetlogs_time,
       decode(cur.dbinc_key, db.curr_dbinc_key, 'YES', 'NO')
         current_incarnation, 
       cur.parent_dbinc_key,
       par.reset_scn prior_resetlogs_change#,
       par.reset_time prior_resetlogs_time,
       cur.dbinc_status  status,
       db.reg_db_unique_name,
       pdb.con_id,
       pdb.guid
from db, dbinc cur, dbinc par, pdb
where db.db_key = cur.db_key
  and (cur.parent_dbinc_key = par.dbinc_key)
  and db.db_key = pdb.db_key
  and pdb.con_id in (1, 0)
union all
select db.db_key,
       db.db_id dbid,
       dbinc.dbinc_key,
       dbinc.db_name name,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       decode(dbinc.dbinc_key, db.curr_dbinc_key, 'YES', 'NO')
         current_incarnation, 
       to_number(null),
       to_number(null),
       to_date(null),
       dbinc.dbinc_status status,
       db.reg_db_unique_name,
       pdb.con_id,
       pdb.guid
from db, dbinc, pdb
where db.db_key=dbinc.db_key
  and dbinc.parent_dbinc_key IS NULL          -- get last incarnation
  and db.db_key = pdb.db_key
  and pdb.con_id in (1, 0)

;
--------------------------------------------------------
--  DDL for View RC_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DATAFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "PDBINC_KEY", "TS#", "TABLESPACE_NAME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "BYTES", "BLOCKS", "BLOCK_SIZE", "NAME", "STOP_CHANGE#", "STOP_TIME", "READ_ONLY", "RFILE#", "INCLUDED_IN_DATABASE_BACKUP", "AUX_NAME", "ENCRYPT_IN_BACKUP", "SITE_KEY", "DB_UNIQUE_NAME", "FOREIGN_DBID", "FOREIGN_CREATION_CHANGE#", "FOREIGN_CREATION_TIME", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "CREATION_THREAD", "CREATION_SIZE") AS 
  select db_key,
       dbinc_key,
       db_name,
       con_id,
       decode(con_id, 0, NULL, pdb_name) pdb_name,
       pdb_key,
       pdbinc_key,
       ts#,
       tablespace_name,
       file#,
       creation_change#,
       creation_time,
       drop_change#,
       drop_time,
       bytes,
       blocks,
       block_size,
       name,
       stop_change#,
       stop_time,
       read_only,
       rfile#,
       included_in_database_backup,
       aux_name,
       encrypt_in_backup,
       site_key,
       db_unique_name,
       foreign_dbid,
       foreign_creation_change#,
       foreign_creation_time,
       plugged_readonly,
       plugin_change#,
       plugin_resetlogs_change#,
       plugin_resetlogs_time,
       creation_thread,
       creation_size
  from rci_datafile
       where substr(nvl(db_unique_name, 'A'),1,1) <> '$'
   

;
--------------------------------------------------------
--  DDL for View RC_DATAFILE_COPY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DATAFILE_COPY" ("DB_KEY", "DBINC_KEY", "DB_NAME", "PDB_KEY", "CDF_KEY", "RECID", "STAMP", "NAME", "TAG", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "INCREMENTAL_LEVEL", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "ABSOLUTE_FUZZY_CHANGE#", "RECOVERY_FUZZY_CHANGE#", "RECOVERY_FUZZY_TIME", "ONLINE_FUZZY", "BACKUP_FUZZY", "BLOCKS", "BLOCK_SIZE", "COMPLETION_TIME", "STATUS", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "SCANNED", "IS_RECOVERY_DEST_FILE", "RSR_KEY", "MARKED_CORRUPT", "SITE_KEY", "FOREIGN_DBID", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "SPARSE_BACKUP") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       cdf.pdb_key,
       cdf.cdf_key,
       cdf.cdf_recid recid,
       cdf.cdf_stamp stamp,
       cdf.fname name,
       cdf.tag,
       cdf.file#,
       cdf.create_scn creation_change#,
       cdf.create_time creation_time,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       cdf.incr_level incremental_level,
       cdf.ckp_scn checkpoint_change#,
       cdf.ckp_time checkpoint_time,
       cdf.abs_fuzzy_scn absolute_fuzzy_change#,
       cdf.rcv_fuzzy_scn recovery_fuzzy_change#,
       cdf.rcv_fuzzy_time recovery_fuzzy_time,
       decode(cdf.onl_fuzzy,'N', 'NO', 'Y', 'YES', '?') online_fuzzy,
       decode(cdf.bck_fuzzy,'N', 'NO', 'Y', 'YES', '?') backup_fuzzy,
       cdf.blocks,
       cdf.block_size,
       cdf.completion_time,
       cdf.status,
       decode(keep_options, 0, 'NO',
                               'YES') keep,
       keep_until,
       decode(keep_options, 256,  'LOGS',
                            512,  'NOLOGS',
                            1024, 'BACKUP_LOGS',
                                  NULL) keep_options,
       decode(cdf.scanned,'N', 'NO', 'Y', 'YES', '?') scanned,
       cdf.is_recovery_dest_file,
       cdf.rsr_key,
       cdf.marked_corrupt,
       cdf.site_key,
       cdf.foreign_dbid,
       cdf.plugged_readonly,
       cdf.plugin_scn plugin_change#,
       cdf.plugin_reset_scn plugin_resetlogs_change#,
       cdf.plugin_reset_time plugin_resetlogs_time,
       cdf.sparse_backup
from dbinc, cdf
where dbinc.dbinc_key = cdf.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_DELETED_OBJECT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DELETED_OBJECT" ("DB_KEY", "DO_KEY", "OBJECT_TYPE", "OBJECT_KEY", "OBJECT_STAMP", "OBJECT_DATA", "SET_STAMP", "SET_COUNT", "HANDLE", "DEVICE_TYPE") AS 
  select deleted_object.db_key   db_key,
       deleted_object.do_key   do_key,
       deleted_object.obj_typ  object_type,
       deleted_object.obj_key  object_key,
       deleted_object.obj_stamp object_stamp,
       deleted_object.obj_data  object_data,
       deleted_object.set_stamp set_stamp,
       deleted_object.set_count set_count,
       deleted_object.handle    handle,
       deleted_object.device_type device_type
 from deleted_object

;
--------------------------------------------------------
--  DDL for View RC_DISK_RESTORE_RANGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_DISK_RESTORE_RANGE" ("DB_KEY", "SITE_KEY", "LOW_TIME", "HIGH_TIME", "LOW_SCN", "HIGH_SCN", "LOW_DBINC_KEY", "HIGH_DBINC_KEY") AS 
  select db_key,
                 site_key,
                 low_time,
                 high_time,
                 low_scn,
                 high_scn,
                 low_dbinc_key,
                 high_dbinc_key
                 from TABLE(rc_listRsRangePipe('RC$DISK$SITE_AWARE'))

;
--------------------------------------------------------
--  DDL for View RC_LOG_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_LOG_HISTORY" ("DB_KEY", "DBINC_KEY", "DB_NAME", "RECID", "STAMP", "THREAD#", "SEQUENCE#", "FIRST_CHANGE#", "FIRST_TIME", "NEXT_CHANGE#", "CLEARED") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       rlh.rlh_recid recid,
       rlh.rlh_stamp stamp,
       rlh.thread#,
       rlh.sequence#,
       rlh.low_scn first_change#,
       rlh.low_time first_time,
       rlh.next_scn next_change#,
       decode(rlh.status, 'N', 'NO', 'Y', 'YES', NULL,  NULL, '?') cleared
--       rlh.next_time,
--       rlh.blocks
from dbinc, rlh
where dbinc.dbinc_key = rlh.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_OFFLINE_RANGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_OFFLINE_RANGE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "RECID", "STAMP", "FILE#", "CREATION_CHANGE#", "OFFLINE_CHANGE#", "ONLINE_CHANGE#", "ONLINE_TIME", "CF_CREATE_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "OFFR_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       offr.offr_recid recid,
       offr.offr_stamp stamp,
       offr.file#,
       offr.create_scn creation_change#,
       offr.offline_scn offline_change#,
       offr.online_scn online_change#,
       offr.online_time,
       offr.cf_create_time,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       offr.offr_key
from dbinc, offr
where dbinc.dbinc_key = offr.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_PDBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PDBS" ("PDB_KEY", "DB_KEY", "NAME", "CON_ID", "DBID", "CREATION_CHANGE#", "GUID") AS 
  select pdb_key,
       db_key,
       name,
       con_id,
       dbid,
       creation_change#,
       guid
  from rci_pdbs
 where con_id > 1

;
--------------------------------------------------------
--  DDL for View RC_PLUGGABLE_DATABASE_INC
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PLUGGABLE_DATABASE_INC" ("PDB_KEY", "NAME", "CON_ID", "DBID", "GUID", "CREATE_SCN", "PDBINC_KEY", "DB_KEY", "CURRENT_INCARNATION", "INCARNATION_SCN", "BEGIN_RESETLOGS_SCN", "BEGIN_RESETLOGS_TIME", "END_RESETLOGS_SCN", "DBINC_KEY", "DB_RESETLOGS_SCN", "DB_RESETLOGS_TIME", "PRIOR_PDBINC_KEY", "PRIOR_INCARNATION_SCN", "PRIOR_BEGIN_RESETLOGS_SCN", "PRIOR_BEGIN_RESETLOGS_TIME", "PRIOR_END_RESETLOGS_SCN", "PRIOR_DBINC_KEY", "PRIOR_DB_RESETLOGS_SCN", "PRIOR_DB_RESETLOGS_TIME", "STATUS") AS 
  select rci_pdbs.pdb_key,
       rci_pdbs.name,
       rci_pdbs.con_id,
       rci_pdbs.dbid,
       rci_pdbs.guid,
       rci_pdbs.creation_change# create_scn,
       cur.pdbinc_key,
       rci_pdbs.db_key db_key,
       decode(cur.pdbinc_status, 'CURRENT', 'YES', 'NO') current_incarnation,
       cur.inc_scn incarnation_scn,
       cur.begin_reset_scn begin_resetlogs_scn,
       cur.begin_reset_time begin_resetlogs_time,
       cur.end_reset_scn end_resetlogs_scn,
       cur.born_dbinc_key dbinc_key,
       cur_dbinc.reset_scn db_resetlogs_scn,
       cur_dbinc.reset_time db_resetlogs_time,
       cur.parent_pdbinc_key prior_pdbinc_key,
       par.inc_scn prior_incarnation_scn,
       par.begin_reset_scn prior_begin_resetlogs_scn,
       par.begin_reset_time prior_begin_resetlogs_time,
       par.end_reset_scn prior_end_resetlogs_scn,
       par.born_dbinc_key prior_dbinc_key,
       par_dbinc.reset_scn prior_db_resetlogs_scn,
       par_dbinc.reset_time prior_db_resetlogs_time,
       cur.pdbinc_status status
from rci_pdbs, pdbinc cur, pdbinc par, dbinc cur_dbinc, dbinc par_dbinc
where rci_pdbs.pdb_key = cur.pdb_key and
      rci_pdbs.con_id > 1 and
      cur.parent_pdbinc_key = par.pdbinc_key(+) and
      cur_dbinc.dbinc_key = cur.born_dbinc_key and
      cur_dbinc.parent_dbinc_key = par_dbinc.dbinc_key 

;
--------------------------------------------------------
--  DDL for View RC_PROXY_ARCHIVEDLOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_ARCHIVEDLOG" ("DB_KEY", "DBINC_KEY", "DB_NAME", "XAL_KEY", "RECID", "STAMP", "TAG", "DEVICE_TYPE", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "STATUS", "THREAD#", "SEQUENCE#", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "FIRST_CHANGE#", "FIRST_TIME", "NEXT_CHANGE#", "NEXT_TIME", "BLOCKS", "BLOCK_SIZE", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "RSR_KEY", "TERMINAL", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "SITE_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       xal.xal_key,
       xal.xal_recid recid,
       xal.xal_stamp stamp,
       xal.tag,
       xal.device_type,
       xal.handle,
       xal.comments,
       xal.media,
       xal.media_pool,
       xal.status,
       xal.thread#,
       xal.sequence#,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       xal.low_scn first_change#,
       xal.low_time first_time,
       xal.next_scn next_change#,
       xal.next_time,
       xal.blocks,
       xal.block_size,
       xal.start_time,
       xal.completion_time,
       abs((xal.completion_time - xal.start_time) * 86400) elapsed_seconds,
       xal.rsr_key,
       xal.terminal,
       decode(keep_options, 0, 'NO',
                               'YES') keep,
       keep_until,
       decode(keep_options, 256,  'LOGS',
                            512,  'NOLOGS',
                            1024, 'BACKUP_LOGS',
                                  NULL) keep_options,
       xal.site_key
from dbinc, xal
where dbinc.dbinc_key = xal.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_PROXY_ARCHIVELOG_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_ARCHIVELOG_DETAILS" ("SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "COPY_KEY", "THREAD#", "SEQUENCE#", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "HANDLE", "MEDIA", "MEDIA_POOL", "TAG", "FIRST_CHANGE#", "NEXT_CHANGE#", "FIRST_TIME", "NEXT_TIME", "OUTPUT_BYTES", "COMPLETION_TIME", "OUTPUT_BYTES_DISPLAY") AS 
  select a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."DB_KEY",a."DB_NAME",a."COPY_KEY",a."THREAD#",a."SEQUENCE#",a."RESETLOGS_CHANGE#",a."RESETLOGS_TIME",a."HANDLE",a."MEDIA",a."MEDIA_POOL",a."TAG",a."FIRST_CHANGE#",a."NEXT_CHANGE#",a."FIRST_TIME",a."NEXT_TIME",a."OUTPUT_BYTES",a."COMPLETION_TIME",
   dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display from
(select b.rsr_key session_key, b.session_recid, b.session_stamp, 
        a.db_key, a.db_name,
       a.recid copy_key, a.thread#, a.sequence#, a.resetlogs_change#,
       a.resetlogs_time, a.handle, a.media, a.media_pool,
       a.tag, a.first_change#, a.next_change#, a.first_time, a.next_time,
       (a.blocks+1)*a.block_size output_bytes, a.completion_time
  from rc_proxy_archivedlog a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time))a

;
--------------------------------------------------------
--  DDL for View RC_PROXY_ARCHIVELOG_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_ARCHIVELOG_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_FILES_BACKED", "NUM_DISTINCT_FILES_BACKED", "MIN_FIRST_CHANGE#", "MAX_NEXT_CHANGE#", "MIN_FIRST_TIME", "MAX_NEXT_TIME", "OUTPUT_BYTES", "OUTPUT_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_FILES_BACKED",a."NUM_DISTINCT_FILES_BACKED",a."MIN_FIRST_CHANGE#",a."MAX_NEXT_CHANGE#",a."MIN_FIRST_TIME",a."MAX_NEXT_TIME",a."OUTPUT_BYTES",
       dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display
from
(select a.db_key,
       nvl(num_files_backed, 0) num_files_backed,
       num_distinct_files_backed,
       min_first_change#,
       max_next_change#,
       min_first_time,
       max_next_time,
       output_bytes
from
(select a.db_key, count(*) num_files_backed,
       min(first_change#)min_first_change#,
       max(next_change#) max_next_change#,
       min(first_time)min_first_time,
       max(next_time) max_next_time,
       sum((blocks+1)*block_size) output_bytes
    from rc_proxy_archivedlog a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key=b.db_key group by a.db_key)a,
(select db_key, count(*) num_distinct_files_backed
    from (select unique a.db_key, 
            thread#, sequence#, resetlogs_change#, resetlogs_time
          from rc_proxy_archivedlog a, rc_rman_status b,
          (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey
              from dual) c,
          (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
              from dual) d,
          (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
              from dual) e
          where  a.status = 'A' and
             a.rsr_key = b.rsr_key (+) and 
             (c.skey is null or c.skey = b.session_key) and
             (d.fTime is null or d.fTime <= b.start_time) and
             (e.uTime is null or e.uTime >= b.end_time) and
             a.db_key=b.db_key) group by db_key)b where a.db_key=b.db_key)a,
 rc_database db where a.db_key=db.db_key

;
--------------------------------------------------------
--  DDL for View RC_PROXY_CONTROLFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_CONTROLFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "XCF_KEY", "RECID", "STAMP", "TAG", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "CREATION_TIME", "BLOCK_SIZE", "BLOCKS", "MIN_OFFR_RECID", "OLDEST_OFFLINE_RANGE", "DEVICE_TYPE", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "CONTROLFILE_TYPE", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "RSR_KEY", "SITE_KEY") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       xcf.xcf_key,
       xcf.xcf_recid recid,
       xcf.xcf_stamp stamp,
       xcf.tag,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       xcf.ckp_scn checkpoint_change#,
       xcf.ckp_time checkpoint_time,
       xcf.create_time creation_time,
       xcf.block_size,
       xcf.blocks,
       xcf.min_offr_recid,
       xcf.min_offr_recid oldest_offline_range,
       xcf.device_type,
       xcf.handle,
       xcf.comments,
       xcf.media,
       xcf.media_pool,
       xcf.start_time,
       xcf.completion_time,
       abs((xcf.completion_time - xcf.start_time) * 86400) elapsed_seconds,
       xcf.status,
       xcf.controlfile_type,
       decode(keep_options, 0, 'NO',
                               'YES') keep,
       keep_until,
       decode(keep_options, 256,  'LOGS',
                            512,  'NOLOGS',
                            1024, 'BACKUP_LOGS',
                                  NULL) keep_options,
       xcf.rsr_key,
       xcf.site_key
from dbinc, xcf
where dbinc.dbinc_key = xcf.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_PROXY_COPY_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_COPY_DETAILS" ("SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "DB_KEY", "DB_NAME", "RSR_KEY", "COPY_KEY", "FILE#", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "TAG", "CREATION_CHANGE#", "CREATION_TIME", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "OUTPUT_BYTES", "COMPLETION_TIME", "CONTROLFILE_TYPE", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "OUTPUT_BYTES_DISPLAY") AS 
  select a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."DB_KEY",a."DB_NAME",a."RSR_KEY",a."COPY_KEY",a."FILE#",a."HANDLE",a."COMMENTS",a."MEDIA",a."MEDIA_POOL",a."TAG",a."CREATION_CHANGE#",a."CREATION_TIME",a."CHECKPOINT_CHANGE#",a."CHECKPOINT_TIME",a."OUTPUT_BYTES",a."COMPLETION_TIME",a."CONTROLFILE_TYPE",a."KEEP",a."KEEP_UNTIL",a."KEEP_OPTIONS",
   dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display from
(select b.session_recid session_key, b.session_recid, b.session_stamp, 
        a.*
   from 
    (select db_key, db_name, rsr_key, xdf_key copy_key, file#, handle,comments, 
       media,media_pool,
       tag, creation_change#, 
       creation_time, checkpoint_change#, checkpoint_time,
       (blocks+1)*block_size output_bytes, 
       completion_time, null controlfile_type, keep, keep_until,
       keep_options
    from rc_proxy_datafile where status = 'A'
    union
    select db_key, db_name, rsr_key, xcf_key copy_key, 0, handle,comments, 
       media,media_pool,
       tag, null creation_change#, 
       creation_time, checkpoint_change#, checkpoint_time, 
       (blocks+1)*block_size output_bytes,
       completion_time, controlfile_type, keep, keep_until,
       keep_options
   from rc_proxy_controlfile where status='A') a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time))a

;
--------------------------------------------------------
--  DDL for View RC_PROXY_COPY_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_COPY_SUMMARY" ("DB_NAME", "DB_KEY", "NUM_COPIES", "NUM_DISTINCT_COPIES", "MIN_CHECKPOINT_CHANGE#", "MAX_CHECKPOINT_CHANGE#", "MIN_CHECKPOINT_TIME", "MAX_CHECKPOINT_TIME", "OUTPUT_BYTES", "OUTPUT_BYTES_DISPLAY") AS 
  select db.name db_name, a."DB_KEY",a."NUM_COPIES",a."NUM_DISTINCT_COPIES",a."MIN_CHECKPOINT_CHANGE#",a."MAX_CHECKPOINT_CHANGE#",a."MIN_CHECKPOINT_TIME",a."MAX_CHECKPOINT_TIME",a."OUTPUT_BYTES",
       dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display
from
(select db_key, 
       nvl(sum(num_times_backed),0) num_copies,
       sum(distinct_copies)  num_distinct_copies,
       min(min_checkpoint_change#) min_checkpoint_change#,
       max(max_checkpoint_change#) max_checkpoint_change#,
       min(min_checkpoint_time) min_checkpoint_time,
       max(max_checkpoint_time) max_checkpoint_time,
       sum(output_bytes) output_bytes
   from
    (select unique a.db_key,
       file#, count(*) over (partition by file#, creation_change#)
              num_times_backed,
       count(distinct file#) 
                over (partition by file#, creation_change#, checkpoint_change#)
                distinct_copies,
       min(checkpoint_change#) over (partition by file#, creation_change#) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by file#, creation_change#) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by file#, creation_change#) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by file#, creation_change#) 
                 max_checkpoint_time,
       sum((blocks+1)*block_size) over (partition by file#, creation_change#)
                 output_bytes
    from rc_proxy_datafile a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and 
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key
    union
    select unique a.db_key,
       0 file#, count(*) over (partition by creation_time)
              num_times_backed,
       1      distinct_copies,
       min(checkpoint_change#) over (partition by creation_time) 
                 min_checkpoint_change#,
       max(checkpoint_change#) over (partition by creation_time) 
                 max_checkpoint_change#,
       min(checkpoint_time) over (partition by creation_time) 
                 min_checkpoint_time,
       max(checkpoint_time) over (partition by creation_time) 
                 max_checkpoint_time,
       sum((blocks+1)*block_size) over (partition by creation_time)
                 output_bytes
    from rc_proxy_controlfile a, rc_rman_status b,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
        from dual) d,
   (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
        from dual) e
    where  a.status = 'A' and
           a.rsr_key = b.rsr_key (+) and
           (c.skey is null or c.skey = b.session_key) and
           (d.fTime is null or d.fTime <= b.start_time) and
           (e.uTime is null or e.uTime >= b.end_time) and
           a.db_key = b.db_key) group by db_key) a, rc_database db
 where a.db_key = db.db_key

;
--------------------------------------------------------
--  DDL for View RC_PROXY_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_PROXY_DATAFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "PDB_KEY", "XDF_KEY", "RECID", "STAMP", "TAG", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "INCREMENTAL_LEVEL", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "ABSOLUTE_FUZZY_CHANGE#", "RECOVERY_FUZZY_CHANGE#", "RECOVERY_FUZZY_TIME", "ONLINE_FUZZY", "BACKUP_FUZZY", "BLOCKS", "BLOCK_SIZE", "DEVICE_TYPE", "HANDLE", "COMMENTS", "MEDIA", "MEDIA_POOL", "START_TIME", "COMPLETION_TIME", "ELAPSED_SECONDS", "STATUS", "KEEP", "KEEP_UNTIL", "KEEP_OPTIONS", "RSR_KEY", "SITE_KEY", "FOREIGN_DBID", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       xdf.pdb_key,
       xdf.xdf_key,
       xdf.xdf_recid recid,
       xdf.xdf_stamp stamp,
       xdf.tag,
       xdf.file#,
       xdf.create_scn creation_change#,
       xdf.create_time creation_time,
       dbinc.reset_scn resetlogs_change#,
       dbinc.reset_time resetlogs_time,
       xdf.incr_level incremental_level,
       xdf.ckp_scn checkpoint_change#,
       xdf.ckp_time checkpoint_time,
       xdf.abs_fuzzy_scn absolute_fuzzy_change#,
       xdf.rcv_fuzzy_scn recovery_fuzzy_change#,
       xdf.rcv_fuzzy_time recovery_fuzzy_time,
       decode(xdf.onl_fuzzy,'N', 'NO', 'Y', 'YES', '?') online_fuzzy,
       decode(xdf.bck_fuzzy,'N', 'NO', 'Y', 'YES', '?') backup_fuzzy,
       xdf.blocks,
       xdf.block_size,
       xdf.device_type,
       xdf.handle,
       xdf.comments,
       xdf.media,
       xdf.media_pool,
       xdf.start_time,
       xdf.completion_time,
       abs((xdf.completion_time - xdf.start_time) * 86400) elapsed_seconds,
       xdf.status,
       decode(keep_options, 0, 'NO',
                               'YES') keep,
       keep_until,
       decode(keep_options, 256,  'LOGS',
                            512,  'NOLOGS',
                            1024, 'BACKUP_LOGS',
                                  NULL) keep_options,
       xdf.rsr_key,
       xdf.site_key,
       xdf.foreign_dbid,
       xdf.plugged_readonly,
       xdf.plugin_scn plugin_change#,
       xdf.plugin_reset_scn plugin_resetlogs_change#,
       xdf.plugin_reset_time plugin_resetlogs_time
from dbinc, xdf
where dbinc.dbinc_key = xdf.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_RCVER
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RCVER" ("VERSION") AS 
  select version from rcver

;
--------------------------------------------------------
--  DDL for View RC_REDO_LOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_REDO_LOG" ("DB_KEY", "DBINC_KEY", "DB_NAME", "THREAD#", "GROUP#", "NAME", "SITE_KEY", "BYTES", "TYPE") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       orl.thread#,
       orl.group#,
       orl.fname name,
       orl.site_key,
       orl.bytes bytes,
       orl.type type
from dbinc, orl
where dbinc.dbinc_key = orl.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_REDO_THREAD
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_REDO_THREAD" ("DB_KEY", "DBINC_KEY", "DB_NAME", "THREAD#", "STATUS", "SEQUENCE#", "ENABLE_CHANGE#", "ENABLE_TIME", "DISABLE_CHANGE#", "DISABLE_TIME") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       rt.thread#,
       rt.status,
       rt.sequence#,
       rt.enable_scn enable_change#,
       rt.enable_time,
       rt.disable_scn disable_change#,
       rt.disable_time
from dbinc, rt
where dbinc.dbinc_key = rt.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_RESTORE_POINT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RESTORE_POINT" ("DBINC_KEY", "RECID", "STAMP", "SITE_KEY", "NAME", "RESTORE_POINT_TIME", "CREATION_TIME", "SCN", "LONG_TERM", "PRESERVED", "GUARANTEE_FLASHBACK_DATABASE", "PDB_KEY", "CLEAN") AS 
  select dbinc_key,
          null recid,
          null stamp,
          site_key, 
          rspname name,
          rsptime restore_point_time,
          creation_time creation_time,
          to_scn scn,
          'NO' long_term,
          'YES' preserved,         /* All guaranteed are also preserved */
          guaranteed guarantee_flashback_database,
          pdb_key,
          clean
   from grsp
   union
   select dbinc_key,
          nrsp_recid recid,
          nrsp_stamp stamp,
          site_key, 
          rspname name,
          rsptime restore_point_time,
          creation_time creation_time,
          to_scn scn,
          long_term,
          'NO' preserved,
          'NO' guarantee_flashback_database,
          pdb_key,
          clean
   from nrsp

;
--------------------------------------------------------
--  DDL for View RC_RESTORE_RANGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RESTORE_RANGE" ("DB_KEY", "SITE_KEY", "LOW_TIME", "HIGH_TIME", "LOW_SCN", "HIGH_SCN", "LOW_DBINC_KEY", "HIGH_DBINC_KEY") AS 
  select db_key,
                 site_key,
                 low_time,
                 high_time,
                 low_scn,
                 high_scn,
                 low_dbinc_key,
                 high_dbinc_key
                 from TABLE(rc_listRsRangePipe('RC$ANY$SITE_AWARE'))

;
--------------------------------------------------------
--  DDL for View RC_RESYNC
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RESYNC" ("DB_KEY", "DBINC_KEY", "DB_NAME", "RESYNC_KEY", "CONTROLFILE_CHANGE#", "CONTROLFILE_TIME", "CONTROLFILE_SEQUENCE#", "CONTROLFILE_VERSION", "RESYNC_TYPE", "DB_STATUS", "RESYNC_TIME") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       ckp.ckp_key resync_key,
       ckp.ckp_scn controlfile_change#,
       ckp.ckp_time controlfile_time,
       ckp.ckp_cf_seq controlfile_sequence#,
       ckp.cf_create_time controlfile_version,
       ckp.ckp_type resync_type,
       ckp.ckp_db_status db_status,
       ckp.resync_time
from ckp, dbinc
where ckp.dbinc_key = dbinc.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_RMAN_BACKUP_JOB_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RMAN_BACKUP_JOB_DETAILS" ("DB_KEY", "DB_NAME", "SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "COMMAND_ID", "START_TIME", "END_TIME", "INPUT_BYTES", "OUTPUT_BYTES", "STATUS_WEIGHT", "OPTIMIZED_WEIGHT", "INPUT_TYPE_WEIGHT", "OUTPUT_DEVICE_TYPE", "AUTOBACKUP_COUNT", "BACKED_BY_OSB", "AUTOBACKUP_DONE", "STATUS", "INPUT_TYPE", "OPTIMIZED", "ELAPSED_SECONDS", "COMPRESSION_RATIO", "INPUT_BYTES_PER_SEC", "OUTPUT_BYTES_PER_SEC", "INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY", "INPUT_BYTES_PER_SEC_DISPLAY", "OUTPUT_BYTES_PER_SEC_DISPLAY", "TIME_TAKEN_DISPLAY") AS 
  select a."DB_KEY",a."DB_NAME",a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."COMMAND_ID",a."START_TIME",a."END_TIME",a."INPUT_BYTES",a."OUTPUT_BYTES",a."STATUS_WEIGHT",a."OPTIMIZED_WEIGHT",a."INPUT_TYPE_WEIGHT",a."OUTPUT_DEVICE_TYPE",a."AUTOBACKUP_COUNT",a."BACKED_BY_OSB",a."AUTOBACKUP_DONE",a."STATUS",a."INPUT_TYPE",a."OPTIMIZED",a."ELAPSED_SECONDS",a."COMPRESSION_RATIO",a."INPUT_BYTES_PER_SEC",a."OUTPUT_BYTES_PER_SEC",
   dbms_rcvman.Num2DisplaySize(input_bytes) input_bytes_display,
   dbms_rcvman.Num2DisplaySize(output_bytes) output_bytes_display,
   dbms_rcvman.Num2DisplaySize(input_bytes_per_sec) input_bytes_per_sec_display,
   dbms_rcvman.Num2DisplaySize(output_bytes_per_sec) output_bytes_per_sec_display,
   dbms_rcvman.Sec2DisplayTime(elapsed_seconds) time_taken_display
from
(select unique a.*,
   decode(autobackup_count, 0, 'NO', 'YES') autobackup_done,
   decode(status_weight, 2000, 'FAILED',
                         1900, 'RUNNING WITH ERRORS',
                         1500, 'RUNNING WITH WARNINGS',
                         1001, 'RUNNING',
                          900, 'COMPLETED WITH ERRORS',
                          500, 'COMPLETED WITH WARNINGS',
                          001, 'COMPLETED',
                          'FAILED') status,
   decode(input_type_weight,9, 'DB FULL',
                             8, 'RECVR AREA',
                             7, 'DB INCR',
                             6, 'DATAFILE FULL',
                             5, 'DATAFILE INCR',
                             4, 'ARCHIVELOG',
                             3, 'CONTROLFILE',
                             2, 'SPFILE', 
                             1, 'BACKUPSET', null) input_type,
   decode(optimized_weight, 1, 'YES', 'NO') optimized,
   abs(a.end_time-a.start_time)*86400 elapsed_seconds,
   case when 
     a.input_bytes/decode(a.output_bytes,0,null,a.output_bytes)>1
   then a.input_bytes/decode(a.output_bytes,0,null,a.output_bytes)
   else 1 end compression_ratio,
   a.input_bytes/(decode(a.end_time-a.start_time, 0, 1,
                     abs(a.end_time-a.start_time))*86400) input_bytes_per_sec,
   a.output_bytes/(decode(a.end_time-a.start_time, 0, 1,
                     abs(a.end_time-a.start_time))*86400) output_bytes_per_sec
       from
 (select db_key, db_name, session_key, session_recid, session_stamp, command_id,
       min(start_time) over
          (partition by session_key) start_time,
       max(end_time) over
           (partition by session_key) end_time,
       sum(input_bytes) over
           (partition by session_key) input_bytes,
       sum(output_bytes) over
           (partition by session_key) output_bytes,
       max(status_weight) over
           (partition by session_key)status_weight,
       max(optimized_weight) over
           (partition by session_key)
           optimized_weight,
       max(input_type_weight) over
           (partition by session_key)
           input_type_weight,
       decode(count(distinct output_device_type) over 
                  (partition by session_key),1,
             first_value(output_device_type) over 
                  (partition by session_key),0, 
             null, '*') output_device_type,
       sum(autobackup_count) over
           (partition by session_key) autobackup_count,
       backed_by_osb
  from RC_RMAN_BACKUP_SUBJOB_DETAILS) a) a

;
--------------------------------------------------------
--  DDL for View RC_RMAN_BACKUP_SUBJOB_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RMAN_BACKUP_SUBJOB_DETAILS" ("DB_KEY", "DB_NAME", "SESSION_KEY", "SESSION_RECID", "SESSION_STAMP", "OPERATION", "COMMAND_ID", "START_TIME", "END_TIME", "INPUT_BYTES", "OUTPUT_BYTES", "STATUS_WEIGHT", "OPTIMIZED_WEIGHT", "INPUT_TYPE_WEIGHT", "OUTPUT_DEVICE_TYPE", "BACKED_BY_OSB", "AUTOBACKUP_DONE", "STATUS", "INPUT_TYPE", "OPTIMIZED", "AUTOBACKUP_COUNT", "COMPRESSION_RATIO", "INPUT_BYTES_DISPLAY", "OUTPUT_BYTES_DISPLAY") AS 
  select a."DB_KEY",a."DB_NAME",a."SESSION_KEY",a."SESSION_RECID",a."SESSION_STAMP",a."OPERATION",a."COMMAND_ID",a."START_TIME",a."END_TIME",a."INPUT_BYTES",a."OUTPUT_BYTES",a."STATUS_WEIGHT",a."OPTIMIZED_WEIGHT",a."INPUT_TYPE_WEIGHT",a."OUTPUT_DEVICE_TYPE",a."BACKED_BY_OSB",
   decode(nvl(b.autocnt,0), 0, 'NO', 'YES') autobackup_done,
   decode(status_weight, 2000, 'FAILED',
                         1900, 'RUNNING WITH ERRORS',
                         1500, 'RUNNING WITH WARNINGS',
                         1001, 'RUNNING',
                          900, 'COMPLETED WITH ERRORS',
                          500, 'COMPLETED WITH WARNINGS',
                          001, 'COMPLETED',
                          'FAILED') status,
   decode(input_type_weight,9, 'DB FULL',
                             8, 'RECVR AREA',
                             7, 'DB INCR',
                             6, 'DATAFILE FULL',
                             5, 'DATAFILE INCR',
                             4, 'ARCHIVELOG',
                             3, 'CONTROLFILE',
                             2, 'SPFILE', 
                             1, 'BACKUPSET', null) input_type,
   decode(optimized_weight, 1, 'YES', 'NO') optimized,
   nvl(b.autocnt,0) autobackup_count,
   case when input_bytes/decode(output_bytes,0,null,output_bytes)>1
        then input_bytes/decode(output_bytes,0,null,output_bytes) else 1 end
        compression_ratio,   
   dbms_rcvman.Num2DisplaySize(input_bytes)  input_bytes_display,
   dbms_rcvman.Num2DisplaySize(output_bytes)  output_bytes_display 
from ( select unique db_key, db_name, session_key,
       session_recid, session_stamp, operation, command_id,
       min(start_time) over
          (partition by session_key, operation) start_time,
       max(end_time) over
           (partition by session_key, operation) end_time,
       sum(input_bytes) over
           (partition by session_key, operation) input_bytes,
       sum(output_bytes) over
           (partition by session_key, operation) output_bytes,
       max(status_weight) over
           (partition by session_key, operation)status_weight,
       max(optimized_weight) over
           (partition by session_key, operation)
           optimized_weight,
       max(input_type_weight) over
           (partition by session_key, operation)
           input_type_weight,
       decode(count(distinct output_device_type) over 
                  (partition by session_key, operation),1,
             first_value(output_device_type) over 
                  (partition by session_key, operation),0, 
             null, '*') output_device_type,
       decode(count(distinct osb_allocated) over 
                  (partition by session_key, operation),1,
             first_value(osb_allocated) over 
                  (partition by session_key, operation),0, 
             'NO', '*') backed_by_osb
    from (select  d.*,
                 decode(status, 'RUNNING', 1001,
                  'RUNNING WITH WARNINGS', 1500, 
                    'RUNNING WITH ERRORS', 1900, 
                              'COMPLETED', 0001, 
                'COMPLETED WITH WARNINGS', 500, 
                  'COMPLETED WITH ERRORS', 900, 
                                 'FAILED', 2000, 2000) status_weight,
             decode(optimized,'YES', 1, 0) optimized_weight,
             decode(object_type, 'DB FULL', 9,
                              'RECVR AREA', 8, 
                                 'DB INCR', 7, 
                           'DATAFILE FULL', 6, 
                           'DATAFILE INCR', 5, 
                              'ARCHIVELOG', 4, 
                             'CONTROLFILE', 3, 
                                  'SPFILE', 2, 
                               'BACKUPSET', 1, 0) input_type_weight
         from
         rc_rman_status d
         where operation like 'BACKUP%' and row_level=1)) a,
( select session_key, count(*) autocnt from rc_rman_status 
  where operation like '%AUTOBACKUP%' and row_level > 1 
  group by session_key ) b
where a.session_key=b.session_key (+)

;
--------------------------------------------------------
--  DDL for View RC_RMAN_BACKUP_TYPE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RMAN_BACKUP_TYPE" ("WEIGHT", "INPUT_TYPE") AS 
  select 9 weight, 'DB FULL' input_type  from dual union 
   select 8, 'RECVR AREA'    from dual union
   select 7, 'DB INCR'       from dual union
   select 6, 'DATAFILE FULL' from dual union
   select 5, 'DATAFILE INCR' from dual union
   select 4, 'ARCHIVELOG'    from dual union
   select 3, 'CONTROLFILE'   from dual union
   select 2, 'SPFILE'        from dual union
   select 1, 'BACKUPSET'     from dual

;
--------------------------------------------------------
--  DDL for View RC_RMAN_CONFIGURATION
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RMAN_CONFIGURATION" ("DB_KEY", "CONF#", "NAME", "VALUE", "DB_UNIQUE_NAME", "SITE_KEY") AS 
  select conf.db_key,
       conf.conf# conf#,
       conf.name name,
       conf.value value,
       conf.db_unique_name db_unique_name,
       conf.site_key
from db, conf
where db.db_key = conf.db_key

;
--------------------------------------------------------
--  DDL for View RC_RMAN_OUTPUT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RMAN_OUTPUT" ("DB_KEY", "RSR_KEY", "SITE_KEY", "SESSION_KEY", "RECID", "STAMP", "OUTPUT") AS 
  select db_key,
       rsr_key,
       site_key,
       rout_skey      session_key,
       rout_recid     recid,
       rout_stamp     stamp,
       rout_text      output
from rout

;
--------------------------------------------------------
--  DDL for View RC_RMAN_STATUS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_RMAN_STATUS" ("DB_KEY", "DBINC_KEY", "DB_NAME", "RECID", "STAMP", "RSR_KEY", "PARENT_KEY", "SESSION_KEY", "ROW_TYPE", "ROW_LEVEL", "OPERATION", "STATUS", "COMMAND_ID", "MBYTES_PROCESSED", "START_TIME", "END_TIME", "JOB_KEY", "INPUT_BYTES", "OUTPUT_BYTES", "OPTIMIZED", "OBJECT_TYPE", "SESSION_RECID", "SESSION_STAMP", "OUTPUT_DEVICE_TYPE", "SITE_KEY", "OSB_ALLOCATED") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       rsr.rsr_recid  recid,
       rsr.rsr_stamp  stamp,
       rsr.rsr_key    rsr_key,
       rsr.rsr_pkey   parent_key,
       nvl(rsr.rsr_l0key, rsr.rsr_key) session_key,
       rsr.rsr_type   row_type,
       rsr.rsr_level  row_level,
       rsr.rsr_oper   operation,
       rsr.rsr_status status,
       rsr.rsr_cmdid  command_id,
       rsr.rsr_mbytes mbytes_processed,
       rsr.rsr_start  start_time,
       rsr.rsr_end    end_time,
       nvl(rsr.rsr_l0key, rsr.rsr_key) job_key,
       rsr.rsr_ibytes input_bytes,
       rsr.rsr_obytes output_bytes,
       rsr.rsr_optimized optimized,
       rsr.rsr_otype   object_type,
       rsr.rsr_srecid  session_recid,
       rsr.rsr_sstamp  session_stamp,
       rsr.rsr_odevtype output_device_type,
       rsr.site_key     site_key,
       decode(rsr.rsr_osb_allocated, 'Y', 'YES', 'NO') osb_allocated
from dbinc, rsr
where dbinc.dbinc_key = rsr.dbinc_key

;
--------------------------------------------------------
--  DDL for View RC_SBT_RESTORE_RANGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_SBT_RESTORE_RANGE" ("DB_KEY", "SITE_KEY", "LOW_TIME", "HIGH_TIME", "LOW_SCN", "HIGH_SCN", "LOW_DBINC_KEY", "HIGH_DBINC_KEY") AS 
  select db_key,
                 site_key,
                 low_time,
                 high_time,
                 low_scn,
                 high_scn,
                 low_dbinc_key,
                 high_dbinc_key
                 from TABLE(rc_listRsRangePipe('RC$SBT$SITE_AWARE'))

;
--------------------------------------------------------
--  DDL for View RC_SITE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_SITE" ("SITE_KEY", "DB_KEY", "DATABASE_ROLE", "CF_CREATE_TIME", "DB_UNIQUE_NAME", "HIGH_CONF_RECID", "FORCE_RESYNC2CF", "HIGH_ROUT_STAMP", "INST_STARTUP_STAMP", "LAST_KCCDIVTS", "HIGH_IC_RECID", "DBINC_KEY", "CKP_SCN", "FULL_CKP_CF_SEQ", "JOB_CKP_CF_SEQ", "HIGH_TS_RECID", "HIGH_DF_RECID", "HIGH_RT_RECID", "HIGH_ORL_RECID", "HIGH_OFFR_RECID", "HIGH_RLH_RECID", "HIGH_AL_RECID", "HIGH_BS_RECID", "HIGH_BP_RECID", "HIGH_BDF_RECID", "HIGH_CDF_RECID", "HIGH_BRL_RECID", "HIGH_BCB_RECID", "HIGH_CCB_RECID", "HIGH_DO_RECID", "HIGH_PC_RECID", "HIGH_BSF_RECID", "HIGH_RSR_RECID", "HIGH_TF_RECID", "HIGH_GRSP_RECID", "HIGH_NRSP_RECID", "HIGH_BCR_RECID", "LOW_BCR_RECID", "BCR_IN_USE", "HIGH_PDB_RECID", "HIGH_PIC_RECID") AS 
  select "SITE_KEY","DB_KEY","DATABASE_ROLE","CF_CREATE_TIME","DB_UNIQUE_NAME","HIGH_CONF_RECID","FORCE_RESYNC2CF","HIGH_ROUT_STAMP","INST_STARTUP_STAMP","LAST_KCCDIVTS","HIGH_IC_RECID","DBINC_KEY","CKP_SCN","FULL_CKP_CF_SEQ","JOB_CKP_CF_SEQ","HIGH_TS_RECID","HIGH_DF_RECID","HIGH_RT_RECID","HIGH_ORL_RECID","HIGH_OFFR_RECID","HIGH_RLH_RECID","HIGH_AL_RECID","HIGH_BS_RECID","HIGH_BP_RECID","HIGH_BDF_RECID","HIGH_CDF_RECID","HIGH_BRL_RECID","HIGH_BCB_RECID","HIGH_CCB_RECID","HIGH_DO_RECID","HIGH_PC_RECID","HIGH_BSF_RECID","HIGH_RSR_RECID","HIGH_TF_RECID","HIGH_GRSP_RECID","HIGH_NRSP_RECID","HIGH_BCR_RECID","LOW_BCR_RECID","BCR_IN_USE","HIGH_PDB_RECID","HIGH_PIC_RECID" from
   rci_site
   where substr(nvl(db_unique_name, 'A'),1,1) <> '$'

;
--------------------------------------------------------
--  DDL for View RC_STORED_SCRIPT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_STORED_SCRIPT" ("DB_KEY", "DB_NAME", "SCRIPT_NAME", "SCRIPT_COMMENT") AS 
  select db.db_key,
       nvl(dbinc.db_name, 'GLOBAL') db_name,
       scr.scr_name script_name,
       scr.scr_comment script_comment
from db, dbinc, scr
where dbinc.dbinc_key(+) = db.curr_dbinc_key
and   db.db_key(+) = scr.db_key

;
--------------------------------------------------------
--  DDL for View RC_STORED_SCRIPT_LINE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_STORED_SCRIPT_LINE" ("DB_KEY", "SCRIPT_NAME", "LINE", "TEXT") AS 
  select db.db_key,
       scr.scr_name script_name,
       scrl.linenum line,
       scrl.text
from db, scr, scrl
where db.db_key(+) = scr.db_key
and   scr.scr_key = scrl.scr_key

;
--------------------------------------------------------
--  DDL for View RC_TABLESPACE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_TABLESPACE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "PDBINC_KEY", "TS#", "NAME", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "INCLUDED_IN_DATABASE_BACKUP", "BIGFILE", "TEMPORARY", "ENCRYPT_IN_BACKUP", "PLUGIN_CHANGE#") AS 
  select dbinc.db_key,
       dbinc.dbinc_key,
       dbinc.db_name,
       pdb.con_id,
       decode(pdb.con_id, 0, NULL, pdb.name) pdb_name,
       pdb.pdb_key pdb_key,
       ts.pdbinc_key,
       ts.ts#,
       ts.ts_name name,
       ts.create_scn creation_change#,
       ts.create_time creation_time,
       ts.drop_scn drop_change#,
       ts.drop_time,
       ts.included_in_database_backup,
       ts.bigfile,
       ts.temporary,
       ts.encrypt_in_backup,
       ts.plugin_scn plugin_change#
from ts, dbinc, pdbinc, pdb
where dbinc.dbinc_key = ts.dbinc_key
  and ts.pdbinc_key = pdbinc.pdbinc_key
  and pdbinc.pdb_key = pdb.pdb_key

;
--------------------------------------------------------
--  DDL for View RC_TEMPFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_TEMPFILE" ("DB_KEY", "DBINC_KEY", "DB_NAME", "CON_ID", "PDB_NAME", "PDB_KEY", "TS#", "TABLESPACE_NAME", "FILE#", "CREATION_CHANGE#", "CREATION_TIME", "DROP_CHANGE#", "DROP_TIME", "BYTES", "BLOCKS", "BLOCK_SIZE", "NAME", "RFILE#", "AUTOEXTEND", "MAXSIZE", "NEXTSIZE", "BIGFILE", "SITE_KEY", "DB_UNIQUE_NAME", "TABLESPACE_CREATION_CHANGE#", "TABLESPACE_CREATION_TIME", "TABLESPACE_DROP_CHANGE#", "TABLESPACE_DROP_TIME") AS 
  select "DB_KEY","DBINC_KEY","DB_NAME","CON_ID","PDB_NAME","PDB_KEY","TS#","TABLESPACE_NAME","FILE#","CREATION_CHANGE#","CREATION_TIME","DROP_CHANGE#","DROP_TIME","BYTES","BLOCKS","BLOCK_SIZE","NAME","RFILE#","AUTOEXTEND","MAXSIZE","NEXTSIZE","BIGFILE","SITE_KEY","DB_UNIQUE_NAME","TABLESPACE_CREATION_CHANGE#","TABLESPACE_CREATION_TIME","TABLESPACE_DROP_CHANGE#","TABLESPACE_DROP_TIME" from rci_tempfile
       where substr(nvl(db_unique_name, 'A'),1,1) <> '$'

;
--------------------------------------------------------
--  DDL for View RC_UNUSABLE_BACKUPFILE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_UNUSABLE_BACKUPFILE_DETAILS" ("SESSION_KEY", "DB_KEY", "DB_NAME", "RSR_KEY", "BTYPE", "BTYPE_KEY", "ID1", "ID2", "FILETYPE", "FILETYPE_KEY", "STATUS", "FILESIZE", "DEVICE_TYPE", "FILENAME", "MEDIA", "MEDIA_POOL") AS 
  select b.session_key, a."DB_KEY",a."DB_NAME",a."RSR_KEY",a."BTYPE",a."BTYPE_KEY",a."ID1",a."ID2",a."FILETYPE",a."FILETYPE_KEY",a."STATUS",a."FILESIZE",a."DEVICE_TYPE",a."FILENAME",a."MEDIA",a."MEDIA_POOL" from
  (select a.db_key, f.db_name, a.rsr_key,
       'BACKUPSET' btype, a.bs_key btype_key, a.set_stamp id1, a.set_count id2,
       'BACKUPPIECE' filetype, a.bp_key filetype_key, a.status, a.bytes filesize, 
        a.device_type, a.handle filename, a.media, a.media_pool 
     from rc_backup_piece a,
          (select db_key, name "DB_NAME" from rc_database) f
     where a.status <> 'A' and a.db_key = f.db_key
  union
  select db_key, db_name, rsr_key, 
        'IMAGECOPY', cdf_key, null, null, 'DATAFILECOPY', cdf_key, status,
        (blocks+1)*block_size, 'DISK', name, null, null 
     from rc_datafile_copy where status <> 'A'
  union
  select db_key, db_name, rsr_key, 
        'IMAGECOPY', ccf_key, null, null, 'CONTROLFILECOPY', ccf_key, status,
        (blocks+1)*block_size, 'DISK', name, null, null 
     from rc_controlfile_copy where status <> 'A'
  union
  select db_key, db_name, rsr_key, 
        'PROXYCOPY', xdf_key, null, null, 'DATAFILECOPY', xdf_key, status,
        (blocks+1)*block_size, device_type, handle, media, media_pool
     from rc_proxy_datafile where status <> 'A'
  union
  select db_key, db_name, rsr_key, 
        'PROXYCOPY', xcf_key, null, null, 'CONTROLFILECOPY', xcf_key, status,
        (blocks+1)*block_size, device_type, handle, media, media_pool
     from rc_proxy_controlfile where status <> 'A'
  union
  select db_key, db_name, rsr_key, 
        'PROXYCOPY', xal_key, null, null, 'ARCHIVELOGCOPY', xal_key, status,
        (blocks+1)*block_size, device_type, handle, media, media_pool
     from rc_proxy_archivedlog where status <> 'A') a, rc_rman_status b,
  (select /*+ no_merge */ dbms_rcvman.sv_getsessionkey skey from dual) c,
  (select /*+ no_merge */ dbms_rcvman.sv_getsessionfromTimeRange fTime
       from dual) d,
  (select /*+ no_merge */ dbms_rcvman.sv_getsessionuntilTimeRange uTime
       from dual) e
   where  a.rsr_key = b.rsr_key (+) and 
          (c.skey is null or c.skey = b.session_key) and
          (d.fTime is null or d.fTime <= b.start_time) and
          (e.uTime is null or e.uTime >= b.end_time)

;
--------------------------------------------------------
--  DDL for View RC_WATERMARKS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."RC_WATERMARKS" ("DB_KEY", "DB_UNIQUE_NAME", "RS_VERSION_STAMP", "HIGH_BP_RECID", "HIGH_DO_KEY", "CF_VERSION_STAMP", "HIGH_DF_RECID", "HIGH_TS_RECID", "HIGH_TF_RECID", "HIGH_OFFR_RECID") AS 
  select db_key, db_unique_name, rs_version_stamp, high_bp_recid, high_do_key,
       cf_version_stamp, high_df_recid, high_ts_recid, high_tf_recid,
       high_offr_recid from watermarks

;
--------------------------------------------------------
--  DDL for View SRCP_REPORT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."SRCP_REPORT" ("ROW_NO", "TOTAL_CAPACITY_SUM", "TOTAL_GENERATION_SUM", "NCES_DIVISION_CODE", "NO_OF_WEG", "MONTH", "YEAR", "INSTALLED_BY") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY GS.STMT_MONTH) as ROW_NO,SUM(MS.TOTAL_CAPACITY)/1000 AS TOTAL_CAPACITY_SUM, SUM(GS.NET_GENERATION)/1000000 AS TOTAL_GENERATION_SUM,OG.NCES_DIVISION_CODE,COUNT(GS.DISP_SERVICE_NUMBER) AS COUNT,GS.STMT_MONTH,GS.STMT_YEAR,MS.INSTALLED_BY 
FROM M_COMPANY_SERVICE MS
LEFT JOIN M_ORG OG ON OG.ID=MS.M_ORG_ID
LEFT JOIN T_GEN_STMT GS ON GS.M_COMPANY_SERVICE_ID=MS.ID
WHERE OG.NCES_DIVISION_CODE IN('NCESTRVL','NCESUDML') AND MS.COMP_SER_TYPE_CODE='03' AND GS.STMT_MONTH IS NOT NULL GROUP BY OG.NCES_DIVISION_CODE,GS.STMT_MONTH,GS.STMT_YEAR,MS.INSTALLED_BY
;
--------------------------------------------------------
--  DDL for View SRCP_REPORT_FOR_SOLAR
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "OPENACCESS"."SRCP_REPORT_FOR_SOLAR" ("ROW_NO", "TOTAL_CAPACITY_SUM", "TOTAL_GENERATION_SUM", "NCES_DIVISION_CODE", "NO_OF_WEG", "MONTH", "YEAR", "INSTALLED_BY", "FUEL_TYPE_NAME") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY GS.STMT_MONTH) as ROW_NO,SUM(MS.TOTAL_CAPACITY)/1000 AS TOTAL_CAPACITY_SUM, SUM(GS.NET_GENERATION)/1000000 AS TOTAL_GENERATION_SUM,OG.NCES_DIVISION_CODE,COUNT(GS.DISP_SERVICE_NUMBER) AS COUNT,
GS.STMT_MONTH,GS.STMT_YEAR,MS.INSTALLED_BY,GS.DISP_FUEL_TYPE_NAME FUEL_TYPE_NAME
FROM M_COMPANY_SERVICE MS
LEFT JOIN M_ORG OG ON OG.ID=MS.M_ORG_ID
LEFT JOIN T_GEN_STMT GS ON GS.M_COMPANY_SERVICE_ID=MS.ID
WHERE OG.NCES_DIVISION_CODE IN('NCESTRVL','NCESUDML') AND MS.COMP_SER_TYPE_CODE='03' AND MS.FUEL_TYPE_CODE='18' AND GS.STMT_MONTH IS NOT NULL GROUP BY OG.NCES_DIVISION_CODE,GS.STMT_MONTH,GS.STMT_YEAR,MS.INSTALLED_BY,GS.DISP_FUEL_TYPE_NAME
;
--------------------------------------------------------
--  DDL for View SRCP_REPORT_FOR_WIND
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "OPENACCESS"."SRCP_REPORT_FOR_WIND" ("ROW_NO", "TOTAL_CAPACITY_SUM", "TOTAL_GENERATION_SUM", "NCES_DIVISION_CODE", "NO_OF_WEG", "MONTH", "YEAR", "INSTALLED_BY", "FUEL_TYPE_NAME") AS 
  SELECT ROW_NUMBER() OVER (ORDER BY GS.STMT_MONTH) as ROW_NO,SUM(MS.TOTAL_CAPACITY)/1000 AS TOTAL_CAPACITY_SUM, SUM(GS.NET_GENERATION)/1000000 AS TOTAL_GENERATION_SUM,OG.NCES_DIVISION_CODE,COUNT(GS.DISP_SERVICE_NUMBER) AS COUNT,
GS.STMT_MONTH,GS.STMT_YEAR,MS.INSTALLED_BY,GS.DISP_FUEL_TYPE_NAME FUEL_TYPE_NAME
FROM M_COMPANY_SERVICE MS
LEFT JOIN M_ORG OG ON OG.ID=MS.M_ORG_ID
LEFT JOIN T_GEN_STMT GS ON GS.M_COMPANY_SERVICE_ID=MS.ID
WHERE OG.NCES_DIVISION_CODE IN('NCESTRVL','NCESUDML') AND MS.COMP_SER_TYPE_CODE='03' AND MS.FUEL_TYPE_CODE='02' AND GS.STMT_MONTH IS NOT NULL GROUP BY OG.NCES_DIVISION_CODE,GS.STMT_MONTH,GS.STMT_YEAR,MS.INSTALLED_BY,GS.DISP_FUEL_TYPE_NAME
;
--------------------------------------------------------
--  DDL for View UNALLOCATED_VIEW
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."UNALLOCATED_VIEW" ("ROW_NO", "disp_service_number", "stmt_month", "stmt_year", "disp_fuel_type_code", "flow_type_code", "disp_org_name", "gs_status_code", "es_status_code") AS 
  select ROW_NUMBER() OVER (ORDER BY stmt_month)AS ROW_NO,disp_service_number,stmt_month,stmt_year,disp_fuel_type_code,flow_type_code,disp_org_name,gs_status_code,es_status_code from
(select * from
(select tgs.disp_service_number,tgs.stmt_month,tgs.stmt_year,tgs.disp_fuel_type_code,tgs.flow_type_code,tgs.disp_org_name,tgs.status_code as gs_status_code,tes.status_code as es_status_code
from t_energy_sale tes
join t_gen_stmt tgs on tes.t_gen_stmt_id=tgs.id
where
tgs.IS_STB = 'N'
and tes.status_code='CREATED'
group by tgs.disp_service_number, tgs.stmt_month, tgs.stmt_year, tgs.disp_fuel_type_code, tes.id, 
tgs.disp_org_name, tgs.status_code, tes.status_code, tgs.flow_type_code)
union
(select tgs.disp_service_number,tgs.stmt_month,tgs.stmt_year,tgs.disp_fuel_type_code,tgs.flow_type_code,tgs.disp_org_name,tgs.status_code as gs_status_code,tgs.status_code as gs_status_code
from t_gen_stmt tgs
where
tgs.IS_STB = 'N'
and tgs.status_code='CREATED'
group by tgs.disp_service_number, tgs.stmt_month, tgs.stmt_year, tgs.disp_fuel_type_code, tgs.flow_type_code, 
tgs.disp_org_name, tgs.status_code, tgs.status_code, tgs.status_code, tgs.id))
;
--------------------------------------------------------
--  DDL for View V_APPLICATION
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_APPLICATION" ("ID", "PROCESS_TYPE_CODE", "SALE_TYPE_CODE", "FUEL_TYPE_CODE", "AGMT_PERIOD_CODE", "OAA_ID", "POWER_SALE_ID", "GEN_COMP_SERV_ID", "GEN_COMP_SERV_NUMBER", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE", "FROM_DT", "TO_DT", "GEN_CAPACITY", "PROPOSED_QUANTUM", "APPLN_DT", "CONSUMER_COMP_SERV_ID", "CONSUMER_END_ORG_ID", "CREATED_DATE", "MODIFIED_DATE", "STATUS_CODE") AS 
  (SELECT esi.ID AS ID, 'POWER-SALE' as PROCESS_TYPE_CODE,esi.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,esi.AGMT_PERIOD_CODE,'' AS OAA_ID,
esi.ID as POWER_SALE_ID,esi.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,esi.FROM_DT AS FROM_DT,esi.TO_DT AS TO_DT,'' AS GEN_CAPACITY,esi.PROPOSED_CAPACITY AS PROPOSED_QUANTUM,esi.CREATED_DATE AS APPLN_DT,
'' AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,esi.CREATED_DATE AS CREATED_DATE,TO_DATE('') AS MODIFIED_DATE,esi.STATUS_CODE AS STATUS_CODE
FROM T_ES_INTENT esi)
UNION
(SELECT ipa.ID AS ID, 'IPA' AS PROCESS_TYPE_CODE,ipa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,ipa.AGMT_PERIOD_CODE,'' AS OAA_ID,
ipa.T_ES_INTENT_ID as POWER_SALE_ID,ipa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,ipa.FROM_DT AS FROM_DT,ipa.TO_DT AS TO_DT,'' AS GEN_CAPACITY,ipa.PROPOSED_CAPACITY AS PROPOSED_QUANTUM,ipa.CREATED_DATE AS APPLN_DT,
'' AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,ipa.CREATED_DATE AS CREATED_DATE,TO_DATE('') AS MODIFIED_DATE,ipa.STATUS_CODE AS STATUS_CODE
FROM T_INPRINCIPLE_APPLN ipa)
UNION
(SELECT noc.ID AS ID, 'NOC' AS PROCESS_TYPE_CODE,noc.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,noc.AGMT_PERIOD_CODE,'' AS OAA_ID,
noc.T_ES_INTENT_ID as POWER_SALE_ID,'' AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,TO_DATE('') AS FROM_DT,TO_DATE('') AS TO_DT,'' AS GEN_CAPACITY,'' AS PROPOSED_QUANTUM,noc.CREATED_DATE AS APPLN_DT,
noc.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,noc.CREATED_DATE AS CREATED_DATE,TO_DATE('') AS MODIFIED_DATE,noc.STATUS_CODE AS STATUS_CODE
FROM T_NOC noc)
UNION
(SELECT nocgen.ID AS ID, 'NOC-GEN' AS PROCESS_TYPE_CODE,nocgen.FLOW_TYPE_CODE AS SALE_TYPE_CODE,nocgen.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,'' AS AGMT_PERIOD_CODE,'' AS OAA_ID,
nocgen.T_ES_INTENT_ID as POWER_SALE_ID,nocgen.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,TO_DATE('') AS FROM_DT,TO_DATE('') AS TO_DT,nocgen.CAPACITY AS GEN_CAPACITY,'' AS PROPOSED_QUANTUM,nocgen.CREATED_DATE AS APPLN_DT,
'' AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,nocgen.CREATED_DATE AS CREATED_DATE,TO_DATE('') AS MODIFIED_DATE,nocgen.STATUS_CODE AS STATUS_CODE
FROM T_NOC_GENERATOR nocgen)
UNION
(SELECT consent.ID AS ID, 'CONSENT' AS PROCESS_TYPE_CODE,consent.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,consent.AGMT_PERIOD_CODE,'' AS OAA_ID,
consent.T_ES_INTENT_ID as POWER_SALE_ID,consent.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,consent.FROM_DT AS FROM_DT,consent.TO_DT AS TO_DT,'' AS GEN_CAPACITY,consent.PROPOSED_CAPACITY AS PROPOSED_QUANTUM,consent.CREATED_DATE AS APPLN_DT,
consent.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,consent.CREATED_DATE AS CREATED_DATE,consent.MODIFIED_DT AS MODIFIED_DATE,consent.STATUS_CODE AS STATUS_CODE
FROM T_CONSENT consent)
UNION
(SELECT ewa.ID AS ID, 'EWA' AS PROCESS_TYPE_CODE,ewa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,ewa.AGMT_PERIOD_CODE,'' AS OAA_ID,
ewa.T_ES_INTENT_ID as POWER_SALE_ID,ewa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,ewa.FROM_DT AS FROM_DT,ewa.TO_DT AS TO_DT,'' AS GEN_CAPACITY,'' AS PROPOSED_QUANTUM,ewa.CREATED_DATE AS APPLN_DT,
'' AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,ewa.CREATED_DATE AS CREATED_DATE,ewa.MODIFIED_DT AS MODIFIED_DATE,ewa.STATUS_CODE AS STATUS_CODE
FROM T_EWA ewa)
UNION
(SELECT epa.ID AS ID, 'EPA' AS PROCESS_TYPE_CODE,epa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,epa.AGMT_PERIOD_CODE,'' AS OAA_ID,
epa.T_ES_INTENT_ID as POWER_SALE_ID,epa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, epa.SELLER_END_ORG_ID AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,epa.FROM_DT AS FROM_DT,epa.TO_DT AS TO_DT,'' AS GEN_CAPACITY,'' AS PROPOSED_QUANTUM,epa.CREATED_DATE AS APPLN_DT,
epa.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,'' AS CONSUMER_END_ORG_ID,epa.CREATED_DATE AS CREATED_DATE,epa.MODIFIED_DT AS MODIFIED_DATE,epa.STATUS_CODE AS STATUS_CODE
FROM T_EPA epa)
UNION
(SELECT sc.ID AS ID, 'SC' AS PROCESS_TYPE_CODE,sc.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,'' AS AGMT_PERIOD_CODE,'' AS OAA_ID,
sc.T_ES_INTENT_ID as POWER_SALE_ID,'' AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, '' AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,sc.FROM_DATE AS FROM_DT,sc.TO_DATE AS TO_DT,'' AS GEN_CAPACITY,'' AS PROPOSED_QUANTUM,sc.CREATED_DATE AS APPLN_DT,
sc.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,sc.M_ORG_ID AS CONSUMER_END_ORG_ID,sc.CREATED_DATE AS CREATED_DATE,sc.MODIFIED_DATE AS MODIFIED_DATE,sc.STATUS_CODE AS STATUS_CODE
FROM T_STANDING_CLEARENCE sc)
UNION
(SELECT oaa.ID AS ID, 'OAA' AS PROCESS_TYPE_CODE,oaa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,'' AS FUEL_TYPE_CODE,oaa.AGMT_PERIOD_CODE,'' AS OAA_ID,
oaa.T_ES_INTENT_ID as POWER_SALE_ID,oaa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,'' AS GEN_COMP_SERV_NUMBER, oaa.SELLER_END_ORG_ID AS GEN_END_ORG_ID,
'' AS GEN_VOLTAGE_CODE,oaa.FROM_DT AS FROM_DT,oaa.TO_DT AS TO_DT,'' AS GEN_CAPACITY,'' AS PROPOSED_QUANTUM,oaa.CREATED_DATE AS APPLN_DT,
oaa.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,oaa.BUYER_END_ORG_ID AS CONSUMER_END_ORG_ID,oaa.CREATED_DATE AS CREATED_DATE,oaa.MODIFIED_DT AS MODIFIED_DATE,oaa.STATUS_CODE AS STATUS_CODE
FROM T_OAA oaa)
;
--------------------------------------------------------
--  DDL for View V_BUYER_AGREEMENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_BUYER_AGREEMENT" ("ID", "SELLER_SERVICE_ID", "SELLER_COMPANY_ID", "BUYER_ORG_ID", "BUYER_ORG_CODE", "BUYER_ORG_NAME", "BUYER_COMPANY_ID", "BUYER_COMPANY_NAME", "BUYER_SERVICE_ID", "BUYER_SERVICE_NUMBER", "VOLTAGE_CODE", "VOLTAGE_NAME", "APPROVED_CAPACITY", "TOTAL_CAPACITY", "IS_CAPTIVE", "QUANTUM_AGREED", "C1", "C2", "C3", "C4", "C5", "PEAK_UNITS", "OFF_PEAK_UNITS", "INTERVAL_TYPE_CODE", "INTERVAL_TYPE_NAME", "SHARE_PERCENT") AS 
  SELECT tr.ID, tr.M_SELLER_COMP_SERVICE_ID SELLER_SERVICE_ID, tr.M_SELLER_COMPANY_ID SELLER_COMPANY_ID, buyerservice.M_ORG_ID BUYER_ORG_ID,org.ORG_CODE BUYER_ORG_CODE,org.ORG_NAME BUYER_ORG_NAME,buyercompany.ID AS BUYER_COMPANY_ID,buyercompany.NAME AS BUYER_COMPANY_NAME,buyerservice.id AS BUYER_SERVICE_ID,buyerservice."number" AS BUYER_SERVICE_NUMBER,
buyerservice.VOLTAGE_CODE,voltagecodes.VALUE_DESC AS VOLTAGE_NAME,buyerservice.CAPACITY AS APPROVED_CAPACITY, buyerservice.total_capacity,
tr.IS_CAPTIVE, tr.QUANTUM quantum_agreed, tr.c1, tr.c2,tr.c3,tr.c4,tr.c5, tr.PEAK_UNITS, tr.OFF_PEAK_UNITS, tr.INTERVAL_TYPE_CODE,intervalcodes.VALUE_DESC AS INTERVAL_TYPE_NAME, tr.SHARE_PERCENT
FROM M_TRADE_RELATIONSHIP tr
left join M_COMPANY_SERVICE buyerservice on tr.M_BUYER_COMP_SERVICE_ID = buyerservice.id
LEFT JOIN M_COMPANY buyercompany ON buyerservice.M_COMPANY_ID = buyercompany.ID
LEFT JOIN V_ORG org ON buyerservice.M_ORG_ID = org.ORG_ID
LEFT JOIN V_CODES voltagecodes ON buyerservice.VOLTAGE_CODE= voltagecodes.Value_Code AND voltagecodes.list_code = 'VOLTAGE_CODE'
LEFT JOIN V_CODES intervalcodes ON tr.INTERVAL_TYPE_CODE= intervalcodes.Value_Code AND intervalcodes.list_code = 'INTERVAL_TYPE_CODE'

;
--------------------------------------------------------
--  DDL for View V_CHARGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_CHARGE" ("CHARGE_CODE", "CHARGE_TYPE_CODE", "CHARGE_DESC", "UNIT_CHARGE", "FORMULA", "CHARGE_DEFN_REMARKS", "CONTEXT", "FF") AS 
  SELECT charge_code, charge_type_code,charge_desc, unit_charge, formula,d.remarks charge_defn_remarks, context,ff FROM  M_CHARGE_DEFN d, M_CHARGES_MAP m WHERE d.id = m.m_charge_id
;
--------------------------------------------------------
--  DDL for View V_CODES
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_CODES" ("LIST_CODE", "LIST_NAME", "VALUE_CODE", "VALUE_DESC", "ENABLED", "ATTRIB1", "ATTRIB2", "ATTRIB3") AS 
  SELECT m_lov_header.code    AS list_code,
  m_lov_header.name         AS list_name,
  m_lov_detail.code         AS value_code,
  m_lov_detail.value_desc AS value_desc,
  m_lov_detail.enabled,
  m_lov_detail.attrib1,
  m_lov_detail.attrib2,
  m_lov_detail.attrib3
FROM m_lov_header
INNER JOIN m_lov_detail
ON m_lov_header.code = m_lov_detail.m_lov_code
order by m_lov_header.code,m_lov_detail.code

;
--------------------------------------------------------
--  DDL for View V_COMPANY_SERVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_COMPANY_SERVICE" ("ID", "BANKING_SERVICE_ID", "BANKING_SERVICE_NUMBER", "CAPACITY", "COMMISSION_DATE", "COMPANY_IS_INTERNAL", "COMP_SER_TYPE_CODE", "COMP_SER_TYPE_NAME", "DL_SERVICE_ID", "DL_SERVICE_NUMBER", "ENABLED", "FLOW_TYPE_CODE", "FUEL_TYPE_CODE", "FUEL_TYPE_NAME", "FUEL_GROUP_NAME", "ACCURACY_CLASS_CODE", "IS_ABTMETER", "IS_BUYER", "IS_REC", "IS_SELLER", "METER_CT1", "METER_CT2", "METER_CT3", "METER_MAKE_CODE", "METER_NUMBER", "METER_PT1", "METER_PT2", "METER_PT3", "MF", "MODEM_NUMBER", "M_COMPANY_CODE", "M_COMPANY_ID", "M_COMPANY_METER_ID", "M_COMPANY_NAME", "M_COMP_SERV_NUMBER", "M_FEEDER_CODE", "M_FEEDER_ID", "M_FEEDER_NAME", "M_ORG_CODE", "M_ORG_ID", "M_ORG_NAME", "M_SECTION_CODE", "M_SECTION_ID", "M_SECTION_NAME", "M_SUBSTATION_CODE", "M_SUBSTATION_ID", "M_SUBSTATION_NAME", "REF_NUMBER", "TARIFF", "TL_SERVICE_ID", "TL_SERVICE_NUMBER", "TYPE_OF_SS", "UNADJUSTED_SERVICE_ID", "UNADJUSTED_SERVICE_NUMBER", "VOLTAGE_CODE", "VOLTAGE_NAME", "number", "IS_CAPTIVE", "IS_STB", "IS_THIRD_PARTY", "TR_FLOW_TYPE_CODE", "EXCESS_UNIT_TYPE", "EXCESS_UNIT_TYPE_REASON") AS 
  select temp.ID,temp.BANKING_SERVICE_ID,temp.BANKING_SERVICE_NUMBER,temp.CAPACITY,temp.COMMISSION_DATE,temp.COMPANY_IS_INTERNAL,temp.COMP_SER_TYPE_CODE,temp.COMP_SER_TYPE_NAME,
temp.DL_SERVICE_ID,temp.DL_SERVICE_NUMBER,temp.ENABLED,temp.FLOW_TYPE_CODE,temp.FUEL_TYPE_CODE,temp.FUEL_TYPE_NAME,temp.FUEL_GROUP_NAME,temp.ACCURACY_CLASS_CODE,temp.IS_ABTMETER,temp.IS_BUYER,
temp.IS_REC,temp.IS_SELLER,temp.METER_CT1,temp.METER_CT2,temp.METER_CT3,temp.METER_MAKE_CODE,temp.METER_NUMBER,temp.METER_PT1,temp.METER_PT2,temp.METER_PT3,
temp.MF,temp.MODEM_NUMBER,temp.M_COMPANY_CODE,temp.M_COMPANY_ID,temp.M_COMPANY_METER_ID,temp.M_COMPANY_NAME,temp.M_COMP_SERV_NUMBER,temp.M_FEEDER_CODE,temp.M_FEEDER_ID,
temp.M_FEEDER_NAME,temp.M_ORG_CODE,temp.M_ORG_ID,temp.M_ORG_NAME,temp.M_SECTION_CODE,temp.M_SECTION_ID,temp.M_SECTION_NAME,temp.M_SUBSTATION_CODE,temp.M_SUBSTATION_ID,
temp.M_SUBSTATION_NAME,temp.REF_NUMBER,temp.TARIFF,temp.TL_SERVICE_ID,temp.TL_SERVICE_NUMBER,temp.TYPE_OF_SS,temp.UNADJUSTED_SERVICE_ID,temp.UNADJUSTED_SERVICE_NUMBER,
temp.VOLTAGE_CODE,temp.VOLTAGE_NAME,temp."number",temp.IS_CAPTIVE,temp.IS_STB,temp.IS_THIRD_PARTY,temp.TR_FLOW_TYPE_CODE, temp.EXCESS_UNIT_TYPE, temp.EXCESS_UNIT_TYPE_REASON
from temp_v_comp_refresh temp
;
--------------------------------------------------------
--  DDL for View V_ES_CHARGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_ES_CHARGE" ("ID", "CHARGE_CODE", "CHARGE_DESC", "TOTAL_CHARGE", "T_ENERGY_SALE_ID", "M_COMP_SERV_ID") AS 
  select tec.id, TEC.CHARGE_CODE,MCD.CHARGE_DESC,TEC.TOTAL_CHARGE, tec.t_energy_sale_id, TEC.M_COMP_SERV_ID
from  T_ES_CHARGE TEC 
LEFT JOIN M_CHARGE_DEFN MCD ON TEC.CHARGE_CODE=MCD.CHARGE_CODE
;
--------------------------------------------------------
--  DDL for View V_EXS_BALANCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_EXS_BALANCE" ("V_ID", "EXCESS_UNIT_TYPE", "ID", "READING_MONTH", "READING_YEAR", "M_COMPANY_ID", "M_COMPANY_NAME", "M_COMPANY_SERVICE_ID", "M_COMPANY_SERVICE_NUM", "BANKING_SERVICE_ID", "BANKING_SERVICE_NUM", "OPEN_C1", "OPEN_C2", "OPEN_C3", "OPEN_C4", "OPEN_C5", "OPEN_TOTAL_UNITS", "OPEN_REMARKS", "OPEN_UPDATE_BY", "OPEN_UPDATE_DT", "INCR_EA1_C1", "INCR_EA1_C2", "INCR_EA1_C3", "INCR_EA1_C4", "INCR_EA1_C5", "INCR_EA1_TOTAL_UNITS", "INCR_EA1_REMARKS", "INCR_EA1_SRC_ID", "INCR_EA1_UPDATE_BY", "INCR_EA1_UPDATE_DT", "DECR_EA1_C1", "DECR_EA1_C2", "DECR_EA1_C3", "DECR_EA1_C4", "DECR_EA1_C5", "DECR_EA1_TOTAL_UNITS", "DECR_EA1_REMARKS", "DECR_EA1_SRC_ID", "DECR_EA1_UPDATE_BY", "DECR_EA1_UPDATE_DT", "INCR_HT_C1", "INCR_HT_C2", "INCR_HT_C3", "INCR_HT_C4", "INCR_HT_C5", "INCR_HT_TOTAL_UNITS", "INCR_HT_REMARKS", "INCR_HT_SRC_ID", "INCR_HT_UPDATE_BY", "INCR_HT_UPDATE_DT", "CURR_C1", "CURR_C2", "CURR_C3", "CURR_C4", "CURR_C5", "CURR_TOTAL_UNITS", "CURR_REMARKS", "CURR_UPDATE_DT", "REMARKS", "CREATED_BY", "CREATED_DT", "MODIFIED_BY", "MODIFIED_DT", "ENABLED", "FUEL_TYPE_CODE") AS 
  (select 'BANKING'||'-'||ID V_ID,'BANKING' EXCESS_UNIT_TYPE, ID,READING_MONTH,READING_YEAR,M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,OPEN_REMARKS,OPEN_UPDATE_BY,OPEN_UPDATE_DT,INCR_EA1_C1,INCR_EA1_C2,INCR_EA1_C3,INCR_EA1_C4,INCR_EA1_C5,INCR_EA1_TOTAL_UNITS,INCR_EA1_REMARKS,INCR_EA1_SRC_ID,INCR_EA1_UPDATE_BY,INCR_EA1_UPDATE_DT,DECR_EA1_C1,DECR_EA1_C2,DECR_EA1_C3,DECR_EA1_C4,DECR_EA1_C5,DECR_EA1_TOTAL_UNITS,DECR_EA1_REMARKS,DECR_EA1_SRC_ID,DECR_EA1_UPDATE_BY,DECR_EA1_UPDATE_DT,INCR_HT_C1,INCR_HT_C2,INCR_HT_C3,INCR_HT_C4,INCR_HT_C5,INCR_HT_TOTAL_UNITS,INCR_HT_REMARKS,INCR_HT_SRC_ID,INCR_HT_UPDATE_BY,INCR_HT_UPDATE_DT,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CURR_REMARKS,CURR_UPDATE_DT,REMARKS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED,FUEL_TYPE_CODE from T_EXS_BANKING_BALANCE )
UNION
(select 'SURPLUS-STB'||'-'||ID V_ID,'SURPLUS-STB' EXCESS_UNIT_TYPE, ID,READING_MONTH,READING_YEAR,M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,OPEN_REMARKS,OPEN_UPDATE_BY,OPEN_UPDATE_DT,INCR_EA1_C1,INCR_EA1_C2,INCR_EA1_C3,INCR_EA1_C4,INCR_EA1_C5,INCR_EA1_TOTAL_UNITS,INCR_EA1_REMARKS,INCR_EA1_SRC_ID,INCR_EA1_UPDATE_BY,INCR_EA1_UPDATE_DT,DECR_EA1_C1,DECR_EA1_C2,DECR_EA1_C3,DECR_EA1_C4,DECR_EA1_C5,DECR_EA1_TOTAL_UNITS,DECR_EA1_REMARKS,DECR_EA1_SRC_ID,DECR_EA1_UPDATE_BY,DECR_EA1_UPDATE_DT,INCR_HT_C1,INCR_HT_C2,INCR_HT_C3,INCR_HT_C4,INCR_HT_C5,INCR_HT_TOTAL_UNITS,INCR_HT_REMARKS,INCR_HT_SRC_ID,INCR_HT_UPDATE_BY,INCR_HT_UPDATE_DT,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CURR_REMARKS,CURR_UPDATE_DT,REMARKS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED,FUEL_TYPE_CODE from T_EXS_SURPLUS_STB_BALANCE )
UNION
(select 'LAPSED'||'-'||ID V_ID,'LAPSED' EXCESS_UNIT_TYPE, ID,READING_MONTH,READING_YEAR,M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,OPEN_REMARKS,OPEN_UPDATE_BY,OPEN_UPDATE_DT,INCR_EA1_C1,INCR_EA1_C2,INCR_EA1_C3,INCR_EA1_C4,INCR_EA1_C5,INCR_EA1_TOTAL_UNITS,INCR_EA1_REMARKS,INCR_EA1_SRC_ID,INCR_EA1_UPDATE_BY,INCR_EA1_UPDATE_DT,DECR_EA1_C1,DECR_EA1_C2,DECR_EA1_C3,DECR_EA1_C4,DECR_EA1_C5,DECR_EA1_TOTAL_UNITS,DECR_EA1_REMARKS,DECR_EA1_SRC_ID,DECR_EA1_UPDATE_BY,DECR_EA1_UPDATE_DT,INCR_HT_C1,INCR_HT_C2,INCR_HT_C3,INCR_HT_C4,INCR_HT_C5,INCR_HT_TOTAL_UNITS,INCR_HT_REMARKS,INCR_HT_SRC_ID,INCR_HT_UPDATE_BY,INCR_HT_UPDATE_DT,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CURR_REMARKS,CURR_UPDATE_DT,REMARKS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED,FUEL_TYPE_CODE from T_EXS_LAPSED_BALANCE)
;
--------------------------------------------------------
--  DDL for View V_GENERATOR
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_GENERATOR" ("ID", "IS_PRIMARY", "VERSION", "CODE", "NAME", "PLANT_TYPE_CODE", "PLANT_TYPE_NAME", "FUEL_TYPE_CODE", "FUEL_TYPE_NAME", "M_SERVICE_ID", "SERVICE_NUMBER", "M_COMPANY_ID", "COMPANY_CODE", "COMPANY_NAME", "M_ORG_ID", "ORG_CODE", "ORG_NAME", "T_GRID_CONN_APPLN_ID", "TOTAL_CAPACITY", "M_SUBSTATION_ID", "SUBSTATION_CODE", "SUBSTATION_NAME", "SUBSTATION_VOLTAGE", "INTERFACE_VOLTAGE_PHASE", "INTERFACE_VOLTAGE_FREQUENCY", "COMMISSION_DATE", "PURPOSE", "ENABLED", "STATUS", "LINE1", "CITY", "STATE_CODE", "STATE_DESC", "PINCODE", "VILLAGE", "TALUK_CODE", "TALUK_NAME", "DISTRICT_CODE", "DISTRICT_NAME", "PLS_SF_NO", "PL_VILLAGE", "PL_TOWN", "PL_TALUK_CODE", "PL_TALUK_NAME", "PL_DISTRICT_CODE", "PL_DISTRICT_NAME", "WIND_PASS_CODE", "WIND_PASS_DESC", "WIND_ZONE_AREA_CODE", "WIND_ZONE_AREA_DESC") AS 
  select id ID,'' IS_PRIMARY,'' VERSION,'' CODE,'' NAME,'' PLANT_TYPE_CODE,'' PLANT_TYPE_NAME,'' FUEL_TYPE_CODE, 'Wind' FUEL_TYPE_NAME,
'' M_SERVICE_ID,WG_HTSCNO SERVICE_NUMBER,'' M_COMPANY_ID,  '' COMPANY_CODE,WG_NAMETIEUP COMPANY_NAME,''  M_ORG_ID,CIRCLECODE ORG_CODE,'' ORG_NAME,''  T_GRID_CONN_APPLN_ID,WG_CAP TOTAL_CAPACITY,'' M_SUBSTATION_ID, '' SUBSTATION_CODE,WG_SSNAME SUBSTATION_NAME,  '' SUBSTATION_VOLTAGE ,'' INTERFACE_VOLTAGE_PHASE,'' INTERFACE_VOLTAGE_FREQUENCY,
WG_COD COMMISSION_DATE,'' PURPOSE,'' ENABLED,'' STATUS,'' LINE1,'' CITY,'' STATE_CODE,'' STATE_DESC,'' PINCODE,'' VILLAGE,'' TALUK_CODE,WG_TALUK TALUK_NAME,'' DISTRICT_CODE ,'' DISTRICT_NAME,'' PLS_SF_NO,'' PL_VILLAGE,'' PL_TOWN,'' PL_TALUK_CODE,'' PL_TALUK_NAME,'' PL_DISTRICT_CODE , '' PL_DISTRICT_NAME,'' WIND_PASS_CODE, WG_PASS WIND_PASS_DESC,'' WIND_ZONE_AREA_CODE, '' WIND_ZONE_AREA_DESC
from temp_weg

;
--------------------------------------------------------
--  DDL for View V_METER_CHANGE_FROM_AMR
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_METER_CHANGE_FROM_AMR" ("OLD_METER_NO", "NEW_METER_NO", "STATUS", "SERVICENO", "MODIFIED_DATE") AS 
  select oldmeterno,newmeterno,status,serviceno,modifydate from R_meter_change_from_amr_his
            union all
            select oldmeterno,newmeterno,status,serviceno,modifydate from R_meter_change_from_amr
;
--------------------------------------------------------
--  DDL for View V_ORG
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_ORG" ("ORG_ID", "ORG_CODE", "ORG_NAME", "ORG_TYPE_CODE", "ORG_PARENT_CODE", "ORG_ADDRESS", "ORG_LANDLINE", "ORG_MOBILE", "ORG_EMAIL", "PARENT_ORG_ID", "PARENT_ORG_CODE", "PARENT_ORG_NAME", "PARENT_ORG_TYPE_CODE", "PARENT_ORG_PARENT_CODE", "PARENT_ORG_ADDRESS", "PARENT_ORG_LANDLINE", "PARENT_ORG_MOBILE", "PARENT_ORG_EMAIL", "NCES_DIVISION_CODE", "NCES_DESC") AS 
  SELECT ORG.ID as ORG_ID,ORG.CODE as ORG_CODE,ORG.NAME as ORG_NAME,ORG.TYPE_CODE as ORG_TYPE_CODE,ORG.PARENT_CODE as ORG_PARENT_CODE,ORG.ADDRESS as ORG_ADDRESS,ORG.LANDLINE as ORG_LANDLINE,ORG.MOBILE as ORG_MOBILE,ORG.EMAIL as ORG_EMAIL,
PARENTORG.ID as PARENT_ORG_ID,PARENTORG.CODE as PARENT_ORG_CODE,PARENTORG.NAME as PARENT_ORG_NAME,PARENTORG.TYPE_CODE as PARENT_ORG_TYPE_CODE,
PARENTORG.PARENT_CODE as PARENT_ORG_PARENT_CODE,PARENTORG.ADDRESS as PARENT_ORG_ADDRESS,PARENTORG.LANDLINE as PARENT_ORG_LANDLINE,PARENTORG.MOBILE as PARENT_ORG_MOBILE,
PARENTORG.EMAIL as PARENT_ORG_EMAIL,ORG.NCES_DIVISION_CODE,NCESCODE.VALUE_DESC AS NCES_DESC
FROM M_ORG ORG
LEFT JOIN M_ORG PARENTORG ON ORG.PARENT_CODE =  PARENTORG.CODE
LEFT JOIN V_CODES NCESCODE ON ORG.NCES_DIVISION_CODE = NCESCODE.VALUE_CODE AND NCESCODE.LIST_CODE='NCES_CODE'

;
--------------------------------------------------------
--  DDL for View V_PP_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_PP_SUMMARY" ("ID", "POWERPLANT_NAME", "ORG_ID", "ORG_CODE", "ORG_NAME", "COMPANY_ID", "COMPANY_NAME", "SELLER_SERVICE_ID", "SELLER_SERVICE_NUMBER", "VOLTAGE_CODE", "VOLTAGE_NAME", "FUEL_CODE", "FUEL_NAME", "WIND_PASS_CODE", "WIND_PASS_NAME", "TOTAL_CAPACITY", "APPROVED_CAPACITY", "COMMISSION_DATE", "NCES_DIVISION_CODE", "NCES_DESC", "SUBSTATION_ID", "SUBSTATION_NAME", "FEEDER_ID", "FEEDER_NAME", "WEG_GROUP_CODE", "WEG_GROUP_DESC", "METER_NUMBER") AS 
  SELECT powerplant.ID,powerplant.NAME AS POWERPLANT_NAME,powerplant.M_ORG_ID AS ORG_ID ,org.ORG_CODE,org.ORG_NAME,company.ID AS COMPANY_ID,company.NAME AS COMPANY_NAME,powerplant.M_SERVICE_ID AS SELLER_SERVICE_ID,companyservice."number" AS SELLER_SERVICE_NUMBER,
companyservice.VOLTAGE_CODE,voltagecodes.VALUE_DESC AS VOLTAGE_NAME,powerplant.FUEL_TYPE_CODE AS FUEL_CODE,fuelcodes.fuel_name AS FUEL_NAME,powerplant.WIND_PASS_CODE,windpasscodes.VALUE_DESC AS WIND_PASS_NAME,powerplant.TOTAL_CAPACITY,companyservice.CAPACITY AS APPROVED_CAPACITY,
powerplant.COMMISSION_DATE,org.NCES_DIVISION_CODE,org.NCES_DESC,powerplant.M_SUBSTATION_ID AS SUBSTATION_ID,ss.NAME AS SUBSTATION_NAME,powerplant.M_FEEDER_ID AS FEEDER_ID,feeder.NAME AS FEEDER_NAME,powerplant.PLANT_CLASS_TYPE_CODE AS WEG_GROUP_CODE,weggroup.VALUE_DESC AS WEG_GROUP_DESC,meter.METER_NUMBER
FROM M_POWERPLANT powerplant
LEFT JOIN V_ORG org ON powerplant.M_ORG_ID = org.ORG_ID
LEFT JOIN M_COMPANY_SERVICE companyservice ON powerplant.M_SERVICE_ID = companyservice.ID
LEFT JOIN M_COMPANY_METER meter ON powerplant.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID
LEFT JOIN M_COMPANY company ON companyservice.M_COMPANY_ID = company.ID
LEFT JOIN V_CODES voltagecodes ON companyservice.VOLTAGE_CODE= voltagecodes.Value_Code AND voltagecodes.list_code = 'VOLTAGE_CODE'
LEFT JOIN m_fuel fuelcodes ON powerplant.FUEL_TYPE_CODE= fuelcodes.fuel_code    
LEFT JOIN v_codes windpasscodes ON powerplant.WIND_PASS_CODE = windpasscodes.Value_Code  AND  windpasscodes.list_code = 'WIND_PASS_CODE'
LEFT JOIN M_SUBSTATION ss ON powerplant.M_SUBSTATION_ID = ss.ID
LEFT JOIN M_FEEDER feeder ON powerplant.M_FEEDER_ID = feeder.ID
LEFT JOIN V_CODES weggroup ON powerplant.PLANT_CLASS_TYPE_CODE= weggroup.Value_Code AND weggroup.list_code = 'PLANT_CLASS_TYPE_CODE'
;
--------------------------------------------------------
--  DDL for View V_PS_CONSUMER_STATUS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_PS_CONSUMER_STATUS" ("ES_LINE_ID", "ESI_CODE", "T_ES_ID", "NOC_ID", "NOC_STATUS", "NOC_BUY_SERV_ID", "CONSENT_ID", "CONSENT_STATUS", "CONSENT_BUY_SERV_ID", "BUYER_COMP_NAME") AS 
  SELECT esline.ID AS ES_LINE_ID,es.CODE as ESI_CODE,es.ID AS T_ES_ID,esline.T_NOC_ID AS NOC_ID,noc.STATUS_CODE  AS NOC_STATUS,noc.BUYER_COMP_SERV_ID AS NOC_BUY_SERV_ID,
esline.T_CONSENT_ID AS CONSENT_ID,con.STATUS_CODE AS CONSENT_STATUS,con.BUYER_COMP_SERV_ID AS CONSENT_BUY_SERV_ID,
company.NAME AS BUYER_COMP_NAME
FROM T_ES_INTENT es
LEFT JOIN T_ES_INTENT_LINE esline ON es.ID=esline.T_EST_INTENT_ID
LEFT JOIN T_NOC noc ON esline.T_NOC_ID=noc.ID
LEFT JOIN T_CONSENT con ON esline.T_CONSENT_ID=con.ID
LEFT JOIN M_COMPANY_SERVICE service ON noc.BUYER_COMP_SERV_ID=service.ID
LEFT JOIN M_COMPANY company ON service.M_COMPANY_ID=company.ID
;
--------------------------------------------------------
--  DDL for View V_RP_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_RP_SUMMARY" ("DISP_FUEL_TYPE_CODE", "FLOW_TYPE_CODE", "STMT_MONTH", "STMT_YEAR", "SERVICE_COUNT", "TOTAL_UNITS_GENERATED", "TOTAL_UNITS_PENDING_ALLOCATION", "TOTAL_UNITS_SOLD", "TOTAL_GEN_UNITS_SOLD", "TOTAL_UNITS_ELIGIBLE_FOR_BANKING", "TOTAL_UNITS_BANKED", "TOTAL_UNITS_IN_SURPLUS_STB", "TOTAL_UNITS_LAPSED", "TOTAL_UNITS_UNACCOUNTED", "TOTAL_RETURNED_FROM_HT_BKG", "FINAL_UNITS_BANKED", "TOTAL_UNITS_CONSUMED_FROM_BKG", "FINAL_BANKING_BALANCE", "TOTAL_RETURNED_FROM_HT_STB", "TOTAL_RETURNED_FROM_HT_LAPSED") AS 
  SELECT DISP_FUEL_TYPE_CODE, FLOW_TYPE_CODE,STMT_MONTH,STMT_YEAR,service_count,total_units_generated,total_units_pending_allocation, 
total_units_sold, total_gen_units_sold,total_units_eligible_for_banking,total_units_banked,total_units_in_surplus_stb,total_units_lapsed,
a.total_units_generated - a.total_gen_units_sold + a.total_units_eligible_for_banking + a.total_units_in_surplus_stb + a.total_units_lapsed AS total_units_unaccounted,
total_returned_from_ht_bkg,total_units_banked+total_returned_from_ht_bkg final_units_banked,total_units_consumed_from_bkg, final_banking_balance, total_returned_from_ht_stb,total_returned_from_ht_lapsed 
FROM 
(
select gs.DISP_FUEL_TYPE_CODE, gs.flow_type_code,gs.STMT_MONTH,gs.STMT_YEAR,count(gs.DISP_SERVICE_NUMBER ) service_count, round(sum(nvl(gs.NET_GENERATION,'0'))/1000000,2) total_units_generated,
round(sum(CASE WHEN gs.STATUS_CODE IN ( 'ALLOCATED','PART_ALLOC') then '0' ELSE nvl(gs.NET_GENERATION,'0') end)/1000000,2) total_units_pending_allocation,
round(sum(nvl(feso.total_units_sold,'0') )/1000000,2) total_units_sold,
round(sum(nvl(feso.TOTAL_GEN_UNITS_SOLD,'0') )/1000000,2) total_gen_units_sold,
round(sum(nvl(tebb.INCR_EA1_TOTAL_UNITS/0.86,'0') )/1000000,2) total_units_eligible_for_banking, 
round(sum(nvl(tebb.INCR_EA1_TOTAL_UNITS,'0') )/1000000,2) total_units_banked, 
round(sum(nvl(tebb.INCR_HT_TOTAL_UNITS,'0') )/1000000,2) total_returned_from_ht_bkg, 
round(sum(nvl(tebb.curr_TOTAL_UNITS,'0') )/1000000,2) final_banking_balance,
round(sum(nvl(tessb.INCR_EA1_TOTAL_UNITS,'0') )/1000000,2) total_units_in_surplus_stb,
round(sum(nvl(telb.INCR_EA1_TOTAL_UNITS,'0') )/1000000,2) total_units_lapsed, 
round(sum(nvl(tessb.INCR_HT_TOTAL_UNITS,'0') )/1000000,2) total_returned_from_ht_stb,
round(sum(nvl(telb.INCR_HT_TOTAL_UNITS,'0') )/1000000,2) total_returned_from_ht_lapsed,
round(sum(nvl(tebb.DECR_EA1_TOTAL_UNITS,'0') )/1000000,2) total_units_consumed_from_bkg 
from t_gen_stmt gs
left join F_ENERGY_SALE_ORDER feso ON feso.SELLER_COMP_SERV_ID=gs.M_COMPANY_SERVICE_ID AND  feso.MONTH = gs.STMT_MONTH AND  feso.YEAR = gs.STMT_YEAR
left join T_EXS_BANKING_BALANCE tebb on tebb.M_COMPANY_SERVICE_ID =gs.M_COMPANY_SERVICE_ID and  tebb.READING_MONTH = gs.STMT_MONTH AND tebb.READING_year = gs.STMT_YEAR
left join T_EXS_SURPLUS_STB_BALANCE tessb on tessb.M_COMPANY_SERVICE_ID =gs.M_COMPANY_SERVICE_ID and  tessb.READING_MONTH = gs.STMT_MONTH AND tessb.READING_year = gs.STMT_YEAR
left join T_EXS_LAPSED_BALANCE telb on telb.M_COMPANY_SERVICE_ID =gs.M_COMPANY_SERVICE_ID and  telb.READING_MONTH =gs.STMT_MONTH AND telb.READING_year = gs.STMT_YEAR
group by gs.DISP_FUEL_TYPE_CODE, gs.flow_type_code, gs.STMT_YEAR , gs.STMT_MONTH 
ORDER BY gs.DISP_FUEL_TYPE_CODE, gs.flow_type_code, gs.STMT_YEAR desc , gs.STMT_MONTH asc ) a
;
--------------------------------------------------------
--  DDL for View V_SIGNUP
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_SIGNUP" ("ID", "COMPANY_NAME", "PURPOSE_CODE", "REGISTRATION_NO", "REGISTRATION_DATE", "COMMISSION_DATE", "VOLTAGE_CODE", "HTSC_NUMBER", "HTSC_NUMBER_OLD", "TARIFF", "TOTAL_CAPACITY", "IS_CAPTIVE", "USER_NAME", "USER_ID", "PASSWORD", "POWERPLANT_TYPE_CODE", "POWERPLANT_NAME", "FUEL_CODE", "NO_OF_GENERATOR", "GENERATOR_MODEL_CODE", "IS_REC", "WIND_PASS_CODE", "LOCATION", "ADDRESS_LINE", "VILLAGE", "TALUK_CODE", "CITY", "DISTRICT_CODE", "STATE_CODE", "M_ORG_ID", "M_SUBSTATION_ID", "M_FEEDER_ID", "IS_COMPLETE", "COMPANY_ADDRESS", "APPROVAL_DT", "PLANT_CLASS_TYPE_CODE", "BUYER_TYPE_CODE", "GENERATOR_CAPACITY", "METER_NUMBER", "METER_MAKE_CODE", "ACCURACY_CLASS_TYPE_CODE", "IS_ABT_METER", "MULTIPLICATION_FACTOR", "APPLICATION_DT", "REMARKS", "MODEM_NO", "GU_MODEL1", "GU_CAPACITY1", "NO_OF_GU1", "GU_MODEL2", "GU_CAPACITY2", "NO_OF_GU2", "GU_MODEL3", "GU_CAPACITY3", "NO_OF_GU3", "GU_MODEL4", "GU_CAPACITY4", "NO_OF_GU4", "GU_MODEL5", "GU_CAPACITY5", "NO_OF_GU5", "GU_MODEL6", "GU_CAPACITY6", "NO_OF_GU6", "METER_CT_1", "METER_CT_2", "METER_CT_3", "METER_BT_1", "METER_BT_2", "METER_BT_3", "SURPLUS_ENERGY_CODE", "TURBINE_SL_NO", "TURBINE_ROTOR_DIA", "TURBINE_HUB_HEIGHT", "IS_DLMS_METER", "METER_CT_RATIO", "METER_PT_RATIO", "TOTAL_GENERATOR_UNIT", "VOLTAGE_NAME", "POWERPLANT_TYPE_NAME", "FUEL_NAME", "GENERATOR_MODEL_NAME", "TALUK_NAME", "DISTRICT_NAME", "STATE_NAME", "M_ORG_NAME", "M_SUBSTATION_NAME", "M_FEEDER_NAME", "PLANT_CLASS_TYPE_NAME", "BUYER_TYPE_NAME", "METER_MAKE_NAME", "ACCURACY_CLASS_TYPE_NAME", "PURPOSE_NAME", "WIND_PASS_NAME", "CREATED_BY", "CREATED_DATE", "MODIFIED_BY", "MODIFIED_DATE", "ACCELERATED_DEPRECIATION") AS 
  select signup.ID, signup.COMPANY_NAME,signup.PURPOSE AS PURPOSE_CODE,signup.REGISTRATION_NO,signup.REGISTRATION_DATE,signup.COMMISSION_DATE,signup.VOLTAGE as VOLTAGE_CODE,
signup.HTSC_NUMBER,signup.HTSC_NUMBER_OLD,signup.TARIFF,signup.TOTAL_CAPACITY,signup.IS_CAPTIVE,signup.USER_NAME,signup.USER_ID,signup.PASSWORD,signup.POWERPLANT_TYPE AS POWERPLANT_TYPE_CODE,
signup.POWERPLANT_NAME,signup.FUEL AS FUEL_CODE,signup.NO_OF_GENERATOR,signup.GENERATOR_MODEL AS GENERATOR_MODEL_CODE,signup.IS_REC,signup.WIND_PASS_CODE,signup.LOCATION,
signup.ADDRESS_LINE,signup.VILLAGE,signup.TALUK_CODE ,signup.CITY,signup.DISTRICT_CODE,signup.STATE_CODE,signup.M_ORG_ID,signup.M_SUBSTATION_ID,
signup.M_FEEDER_ID,signup.IS_COMPLETE,signup.COMPANY_ADDRESS,signup.APPROVAL_DT,signup.PLANT_CLASS_TYPE_CODE,signup.BUYER_TYPE_CODE,signup.GENERATOR_CAPACITY,
signup.METER_NUMBER,signup.METER_MAKE_CODE,signup.ACCURACY_CLASS_TYPE_CODE,signup.IS_ABT_METER,signup.MULTIPLICATION_FACTOR,signup.APPLICATION_DT,signup.REMARKS,
signup.modem_no, signup.gu_model1, signup.gu_capacity1, signup.no_of_gu1, signup.gu_model2, signup.gu_capacity2, signup.no_of_gu2, signup.gu_model3, signup.gu_capacity3, signup.no_of_gu3,
signup.gu_model4, signup.gu_capacity4, signup.no_of_gu4, signup.gu_model5, signup.gu_capacity5, signup.no_of_gu5, signup.gu_model6, signup.gu_capacity6, signup.no_of_gu6,
signup.meter_ct_1, signup.meter_ct_2, signup.meter_ct_3, signup.meter_bt_1, signup.meter_bt_2, signup.meter_bt_3, signup.SURPLUS_ENERGY_CODE,signup.TURBINE_SL_NO,signup.TURBINE_ROTOR_DIA,signup.TURBINE_HUB_HEIGHT,
signup.IS_DLMS_METER,signup.METER_CT_RATIO,signup.METER_PT_RATIO,signup.TOTAL_GENERATOR_UNIT,
voltagecodes.Value_Desc as VOLTAGE_NAME, plantcodes.Value_Desc as POWERPLANT_TYPE_NAME,
fuelcodes.fuel_name as FUEL_NAME, decode(generatormodelcodes.VALUE_CODE, null,'',generatormodelcodes.VALUE_CODE || '-' || generatormodelcodes.Value_Desc) as GENERATOR_MODEL_NAME ,
talukcodes.Value_Desc as TALUK_NAME, districtcodes.VALUE_DESC as DISTRICT_NAME, statecodes.Value_Desc as STATE_NAME,
org.name as m_org_name, substation.name m_substation_name,feeder.name m_feeder_name,
plantclasstypecodes.Value_Desc as PLANT_CLASS_TYPE_NAME, buyertypecodes.Value_Desc as BUYER_TYPE_NAME,
metermakecodes.Value_Desc as METER_MAKE_NAME,accuracyclasstypecodes.Value_Desc as ACCURACY_CLASS_TYPE_NAME, purposecodes.Value_Desc as PURPOSE_NAME, windpasscodes.Value_Desc as WIND_PASS_NAME,signup.CREATED_BY,signup.CREATED_DATE,signup.MODIFIED_BY,signup.MODIFIED_DATE,
signup.ACCELERATED_DEPRECIATION from m_signup signup
left join m_fuel fuelcodes on Signup.Fuel= fuelcodes.fuel_code    
left join v_codes voltagecodes on signup.VOLTAGE= voltagecodes.Value_Code    AND  voltagecodes.list_code = 'VOLTAGE_CODE'
left join v_codes plantcodes on signup.POWERPLANT_TYPE= plantcodes.Value_Code    AND  plantcodes.list_code = 'PLANT_TYPE_CODE'
left join v_codes generatormodelcodes on signup.GENERATOR_MODEL= generatormodelcodes.Value_Code    AND  generatormodelcodes.list_code = 'GENERATOR_MAKE_CODE'
left join v_codes talukcodes on Signup.Taluk_Code = talukcodes.Value_Code AND  talukcodes.list_code = 'TALUK_CODE'
left join v_codes districtcodes on Signup.District_Code = districtcodes.Value_Code AND  districtcodes.list_code = 'DISTRICT_CODE'
left join v_codes statecodes on Signup.State_Code = statecodes.Value_Code AND  statecodes.list_code = 'STATE_CODE'
left join m_org org on signup.m_org_id=org.id
left join m_substation substation on signup.m_substation_id = substation.id
left join m_feeder feeder on signup.m_feeder_id=feeder.id
left join v_codes plantclasstypecodes on signup.plant_class_type_code = plantclasstypecodes.Value_Code  AND  plantclasstypecodes.list_code = 'PLANT_CLASS_TYPE_CODE'
left join v_codes buyertypecodes on signup.BUYER_TYPE_CODE = buyertypecodes.Value_Code  AND  buyertypecodes.list_code = 'BUYER_TYPE_CODE'
left join v_codes metermakecodes on signup.METER_MAKE_CODE = metermakecodes.Value_Code  AND  metermakecodes.list_code = 'METER_MAKE_CODE'
left join v_codes accuracyclasstypecodes on signup.ACCURACY_CLASS_TYPE_CODE = accuracyclasstypecodes.Value_Code  AND  accuracyclasstypecodes.list_code = 'ACCURACY_CLASS_TYPE_CODE'
left join v_codes purposecodes on signup.PURPOSE = purposecodes.Value_Code  AND  purposecodes.list_code = 'PURPOSE_CODE'
left join v_codes windpasscodes on signup.WIND_PASS_CODE = windpasscodes.Value_Code  AND  windpasscodes.list_code = 'WIND_PASS_CODE'
;
--------------------------------------------------------
--  DDL for View V_TRADERELATIONSHIP
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_TRADERELATIONSHIP" ("ID", "QUANTUM", "FROM_DATE", "FROM_MONTH", "FROM_YEAR", "TO_DATE", "STATUS_CODE", "STATUS_NAME", "M_SELLER_COMPANY_ID", "M_SELLER_COMPANY_NAME", "M_SELLER_COMPANY_CODE", "M_SELLER_COMP_SERVICE_ID", "M_SELLER_COMP_SERVICE_NUMBER", "SELLER_ORG_NAME", "M_BUYER_COMPANY_ID", "M_BUYER_COMPANY_NAME", "M_BUYER_COMPANY_CODE", "M_BUYER_COMP_SERVICE_ID", "M_BUYER_COMP_SERVICE_NUMBER", "REFERENCENUMBER", "REMARKS", "C1", "C2", "C3", "C4", "C5", "IS_CAPTIVE", "PEAK_UNITS", "OFF_PEAK_UNITS", "INTERVAL_TYPE_CODE", "SHARE_PERCENT", "INTERVAL_TYPE_NAME", "BUYER_ORG_ID", "SELLER_ORG_ID", "TRADE_RELATIONSHIP_SOURCE_CODE", "AGREEMENT_TYPE", "BUYER_ORG_NAME", "FLOW_TYPE_CODE", "FUEL_TYPE_CODE") AS 
  select trade.ID,trade.QUANTUM,trade.FROM_DATE,to_char(from_date,'mm') from_month,to_char(from_date,'yyyy') from_year,trade.TO_DATE,trade.STATUS_CODE,statuscode.value_desc as STATUS_Name,trade.M_SELLER_COMPANY_ID,sellercompany.name as M_SELLER_COMPANY_NAME, sellercompany.CODE as M_SELLER_COMPANY_CODE ,
    trade.M_SELLER_COMP_SERVICE_ID,sellerservice."number" as M_SELLER_COMP_SERVICE_NUMBER,sellerorg.name as seller_org_name, trade.M_BUYER_COMPANY_ID,buyercompany.name as M_BUYER_COMPANY_NAME, buyercompany.CODE as M_BUYER_COMPANY_CODE,trade.M_BUYER_COMP_SERVICE_ID,
	buyerservice."number" as M_BUYER_COMP_SERVICE_NUMBER,trade.REFERENCENUMBER,trade.REMARKS, trade.C1, trade.C2, trade.C3, trade.C4, trade.C5,
	trade.IS_CAPTIVE,trade.PEAK_UNITS,trade.OFF_PEAK_UNITS,trade.INTERVAL_TYPE_CODE,trade.SHARE_PERCENT,intervaltypecode.VALUE_DESC as INTERVAL_TYPE_NAME,buyerservice.M_ORG_ID AS BUYER_ORG_ID,sellerservice.M_ORG_ID AS SELLER_ORG_ID,trade.TRADE_RELATIONSHIP_SOURCE_CODE,trade.AGREEMENT_TYPE,
	buyerorg.NAME AS BUYER_ORG_NAME, trade.flow_type_code, sellerservice.fuel_type_code
	from m_trade_relationship trade
	left join m_company sellercompany on sellercompany.id=trade.M_SELLER_COMPANY_ID
	left join m_company buyercompany on buyercompany.id=trade.M_BUYER_COMPANY_ID
	left join m_company_service sellerservice on sellerservice.id = trade.M_SELLER_COMP_SERVICE_ID 
	left join m_company_service buyerservice on buyerservice.id = trade.M_BUYER_COMP_SERVICE_ID
	left join v_codes statuscode on trade.STATUS_CODE= statuscode.value_code and statuscode.list_code='TRADE_REL_STATUS_CODE'
    left join v_codes intervaltypecode on trade.INTERVAL_TYPE_CODE= intervaltypecode.value_code and intervaltypecode.list_code='INTERVAL_TYPE_CODE'
    LEFT JOIN M_ORG buyerorg ON buyerservice.M_ORG_ID=buyerorg.ID
    LEFT JOIN M_ORG sellerorg ON sellerservice.M_ORG_ID=sellerorg.ID
;
--------------------------------------------------------
--  DDL for View V_TRANSACTION_STATUS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_TRANSACTION_STATUS" ("SELLER_EDC", "SELLER_EDC_NAME", "SELLER_COMPANY_NAME", "SERVICE_NO", "FLOW_TYPE", "MASTER_CONFIRMED", "ALLOTMENT_MONTH", "ALLOTMENT_YEAR", "MR_STATUS", "GS_STATUS", "ES_STATUS") AS 
  select distinct ms.m_org_id as SELLER_EDC,gs.DISP_ORG_NAME as SELLER_EDC_NAME,
gs.DISP_COMPANY_NAME as SELLER_COMPANY_NAME,
ms."number" as SERVICE_NO,
 CASE 
   WHEN NVL(gs.IS_CAPTIVE,'NULL')='Y' THEN 'CAPTIVE'
   WHEN NVL(gs.IS_CAPTIVE,'NULL')='N' THEN 'STB'
   WHEN gs.FLOW_TYPE_CODE='WEG-THIRD-PARTY' THEN 'WEG-THIRD-PARTY'
   END AS FLOW_TYPE ,
au.master_confirmed,
so.month as ALLOTMENT_MONTH,so.year as ALLOTMENT_YEAR,
mr.STATUS_CODE as mr_status,gs.status_code as GS_STATUS,es.status_code as ES_STATUS
from m_company_service ms
left join m_company co on co.id=ms.m_company_id
left join M_COMPANY_METER meter on ms.id=meter.M_COMPANY_SERVICE_ID
left join T_METER_READING_HDR mr on meter.id=mr.M_COMPANY_METER_ID 
left join t_gen_stmt gs on gs.M_COMPANY_SERVICE_ID=ms.id
left join t_energy_sale es on es.SELLER_COMP_SERV_ID=ms.id and es.T_GEN_STMT_ID = gs.id
left join f_energy_sale_order so on so.SELLER_COMP_SERV_ID=ms.id and so.t_energy_sale_id=es.id
left join auth_user au on au.company_service_id=ms.id
where ms.COMP_SER_TYPE_CODE='03'   and es.status_code is not null  
order by ms."number"
;
--------------------------------------------------------
--  DDL for View V_T_CONSENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_CONSENT" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "APPLN_DT", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE", "CONSUMER_COMP_SERV_ID", "CONSUMER_COMP_ID", "CONSUMER_END_ORG_ID", "CONSUMER_VOLTAGE_CODE", "CREATED_DATE", "MODIFIED_DATE") AS 
  SELECT con.ID,con.T_ES_INTENT_ID AS POWER_SALE_ID,'CONSENT' as PROCESS_TYPE_CODE,con.CODE,con.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,con.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
con.APPLIED_DT AS APPLN_DT,con.STATUS_CODE,
ss.M_COMPANY_ID AS GEN_COMP_ID,ss."number" AS GEN_COMP_SERV_NUMBER,ss.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,
con.SELLER_END_ORG_ID AS GEN_END_ORG_ID,ss.VOLTAGE_CODE AS GEN_VOLTAGE_CODE,
con.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,bs.M_COMPANY_ID AS CONSUMER_COMP_ID,con.BUYER_END_ORG_ID AS CONSUMER_END_ORG_ID,bs.VOLTAGE_CODE AS CONSUMER_VOLTAGE_CODE,
con.CREATED_DATE AS CREATED_DATE,con.MODIFIED_DT AS MODIFIED_DATE
FROM T_CONSENT con
LEFT JOIN V_COMPANY_SERVICE ss ON con.SELLER_COMP_SERV_ID=ss.ID
LEFT JOIN V_COMPANY_SERVICE bs ON con.BUYER_COMP_SERV_ID=bs.ID
;
--------------------------------------------------------
--  DDL for View V_T_EPA
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_EPA" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "FROM_DT", "TO_DT", "APPLN_DT", "AGMT_PERIOD_CODE", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE", "CREATED_DATE", "MODIFIED_DATE", "CONSUMER_COMP_SERV_ID", "CONSUMER_COMP_SERV_NUMBER", "CONSUMER_COMP_ID", "CONSUMER_END_ORG_ID", "CONSUMER_VOLTAGE_CODE") AS 
  SELECT epa.ID,epa.T_ES_INTENT_ID AS POWER_SALE_ID,'EPA' as PROCESS_TYPE_CODE,epa.CODE,epa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,epa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
epa.FROM_DT,epa.TO_DT,epa.APPLIED_DT AS APPLN_DT,epa.AGMT_PERIOD_CODE,epa.STATUS_CODE,
ss.M_COMPANY_ID AS GEN_COMP_ID,ss."number" AS GEN_COMP_SERV_NUMBER,ss.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,
epa.SELLER_END_ORG_ID AS GEN_END_ORG_ID,epa.VOLTAGE_CODE AS GEN_VOLTAGE_CODE,epa.CREATED_DATE AS CREATED_DATE,epa.MODIFIED_DT AS MODIFIED_DATE,
epa.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,bs."number" AS CONSUMER_COMP_SERV_NUMBER,bs.M_COMPANY_ID AS CONSUMER_COMP_ID,bs.M_ORG_ID AS CONSUMER_END_ORG_ID,bs.VOLTAGE_CODE AS CONSUMER_VOLTAGE_CODE
FROM T_EPA epa
LEFT JOIN V_COMPANY_SERVICE ss ON epa.SELLER_COMP_SERV_ID=ss.ID
LEFT JOIN V_COMPANY_SERVICE bs ON epa.BUYER_COMP_SERV_ID=bs.ID
;
--------------------------------------------------------
--  DDL for View V_T_ES_INTENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_ES_INTENT" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "FROM_DT", "TO_DT", "APPLN_DT", "PROPOSED_QUANTUM", "AGMT_PERIOD_CODE", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE", "CREATED_DATE") AS 
  SELECT esi.ID,esi.ID AS POWER_SALE_ID,'POWER-SALE' as PROCESS_TYPE_CODE,esi.CODE,esi.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,esi.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
esi.FROM_DT,esi.TO_DT,esi.APPLIED_DT AS APPLN_DT,esi.PROPOSED_CAPACITY AS PROPOSED_QUANTUM,esi.AGMT_PERIOD_CODE,esi.STATUS_CODE,
service.M_COMPANY_ID AS GEN_COMP_ID,service."number" AS GEN_COMP_SERV_NUMBER,service.FUEL_TYPE_CODE,service.M_ORG_ID AS GEN_END_ORG_ID,
service.VOLTAGE_CODE AS GEN_VOLTAGE_CODE,esi.CREATED_DATE
FROM T_ES_INTENT esi
LEFT JOIN V_COMPANY_SERVICE service ON esi.SELLER_COMP_SERV_ID=service.ID
;
--------------------------------------------------------
--  DDL for View V_T_EWA
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_EWA" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "FROM_DT", "TO_DT", "APPLN_DT", "AGMT_PERIOD_CODE", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE", "CREATED_DATE", "MODIFIED_DATE") AS 
  SELECT ewa.ID,ewa.T_ES_INTENT_ID AS POWER_SALE_ID,'EWA' as PROCESS_TYPE_CODE,ewa.CODE,ewa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,ewa.FLOW_TYPE_CODE AS SALE_TYPE_CODE, 
ewa.FROM_DT,ewa.TO_DT,ewa.APPLIED_DT AS APPLN_DT,ewa.AGMT_PERIOD_CODE,ewa.STATUS_CODE,
ss.M_COMPANY_ID AS GEN_COMP_ID,ss."number" AS GEN_COMP_SERV_NUMBER,ss.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,
ewa.SELLER_END_ORG_ID AS GEN_END_ORG_ID,ss.VOLTAGE_CODE AS GEN_VOLTAGE_CODE,ewa.CREATED_DATE AS CREATED_DATE,ewa.MODIFIED_DT AS MODIFIED_DATE
FROM T_EWA ewa
LEFT JOIN V_COMPANY_SERVICE ss ON ewa.SELLER_COMP_SERV_ID=ss.ID
;
--------------------------------------------------------
--  DDL for View V_T_INPRINCIPLE_APPLN
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_INPRINCIPLE_APPLN" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "FROM_DT", "TO_DT", "APPLN_DT", "PROPOSED_QUANTUM", "AGMT_PERIOD_CODE", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE") AS 
  SELECT ipa.ID,ipa.T_ES_INTENT_ID AS POWER_SALE_ID,'IPA' as PROCESS_TYPE_CODE,ipa.CODE,ipa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,ipa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
ipa.FROM_DT,ipa.TO_DT,ipa.APPLIED_DT AS APPLN_DT,ipa.PROPOSED_CAPACITY AS PROPOSED_QUANTUM,ipa.AGMT_PERIOD_CODE,ipa.STATUS_CODE,
service.M_COMPANY_ID AS GEN_COMP_ID,service."number" AS GEN_COMP_SERV_NUMBER,service.FUEL_TYPE_CODE,service.M_ORG_ID AS GEN_END_ORG_ID,
service.VOLTAGE_CODE AS GEN_VOLTAGE_CODE
FROM T_INPRINCIPLE_APPLN ipa
LEFT JOIN V_COMPANY_SERVICE service ON ipa.SELLER_COMP_SERV_ID=service.ID
;
--------------------------------------------------------
--  DDL for View V_T_NOC
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_NOC" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "CONSUMER_COMP_SERV_ID", "SALE_TYPE_CODE", "APPLN_DT", "PROPOSED_QUANTUM", "AGMT_PERIOD_CODE", "STATUS_CODE", "CONSUMER_COMP_ID", "CONSUMER_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "CONSUMER_END_ORG_ID", "CONSUMER_VOLTAGE_CODE") AS 
  SELECT noc.ID,noc.T_ES_INTENT_ID AS POWER_SALE_ID,'NOC' as PROCESS_TYPE_CODE,noc.CODE,noc.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,noc.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
noc.APPLIED_DT AS APPLN_DT,noc.PROPOSED_CAPACITY AS PROPOSED_QUANTUM,noc.AGMT_PERIOD_CODE,noc.STATUS_CODE,
buyerservice.M_COMPANY_ID AS CONSUMER_COMP_ID,buyerservice."number" AS CONSUMER_COMP_SERV_NUMBER,buyerservice.FUEL_TYPE_CODE,buyerservice.M_ORG_ID AS CONSUMER_END_ORG_ID,
buyerservice.VOLTAGE_CODE AS CONSUMER_VOLTAGE_CODE
FROM T_NOC noc
LEFT JOIN V_COMPANY_SERVICE buyerservice ON noc.BUYER_COMP_SERV_ID=buyerservice.ID
;
--------------------------------------------------------
--  DDL for View V_T_NOC_GENERATOR
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_NOC_GENERATOR" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "APPLN_DT", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_END_ORG_ID", "GEN_VOLTAGE_CODE") AS 
  SELECT nocgen.ID,nocgen.T_ES_INTENT_ID AS POWER_SALE_ID,'NOC-GEN' as PROCESS_TYPE_CODE,nocgen.CODE,nocgen.SELLER_COMP_SERV_ID AS  GEN_COMP_SERV_ID,nocgen.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
nocgen.APPLIED_DT AS APPLN_DT,nocgen.STATUS_CODE,
sellerservice.M_COMPANY_ID AS GEN_COMP_ID,sellerservice."number" AS GEN_COMP_SERV_NUMBER,sellerservice.FUEL_TYPE_CODE AS FUEL_TYPE_CODE,
nocgen.M_ORG_ID AS GEN_END_ORG_ID,sellerservice.VOLTAGE_CODE AS GEN_VOLTAGE_CODE
FROM T_NOC_GENERATOR nocgen
LEFT JOIN V_COMPANY_SERVICE sellerservice ON nocgen.SELLER_COMP_SERV_ID=sellerservice.ID
;
--------------------------------------------------------
--  DDL for View V_T_OAA
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_OAA" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "GEN_COMP_SERV_ID", "SALE_TYPE_CODE", "FROM_DT", "TO_DT", "APPLN_DT", "STATUS_CODE", "GEN_COMP_ID", "GEN_COMP_SERV_NUMBER", "FUEL_TYPE_CODE", "GEN_VOLTAGE_CODE", "GEN_END_ORG_ID", "CONSUMER_COMP_SERV_ID", "CONSUMER_COMP_ID", "CONSUMER_COMP_SERV_NUMBER", "CONSUMER_END_ORG_ID", "CONSUMER_VOLTAGE_CODE") AS 
  SELECT oaa.ID,oaa.T_ES_INTENT_ID AS POWER_SALE_ID,'OAA' as PROCESS_TYPE_CODE,oaa.SELLER_COMP_SERV_ID AS GEN_COMP_SERV_ID,oaa.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
oaa.FROM_DT,oaa.TO_DT,oaa.APPLIED_DT AS APPLN_DT,oaa.STATUS_CODE,
ss.M_COMPANY_ID AS GEN_COMP_ID,ss."number" AS GEN_COMP_SERV_NUMBER,ss.FUEL_TYPE_CODE,ss.VOLTAGE_CODE AS GEN_VOLTAGE_CODE,ss.M_ORG_ID AS GEN_END_ORG_ID,
oaa.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,bs.M_COMPANY_ID AS CONSUMER_COMP_ID,bs."number" AS CONSUMER_COMP_SERV_NUMBER,bs.M_ORG_ID AS CONSUMER_END_ORG_ID,bs.VOLTAGE_CODE AS CONSUMER_VOLTAGE_CODE
FROM T_OAA oaa
LEFT JOIN V_COMPANY_SERVICE ss ON oaa.SELLER_COMP_SERV_ID=ss.ID
LEFT JOIN V_COMPANY_SERVICE bs ON oaa.BUYER_COMP_SERV_ID=bs.ID
;
--------------------------------------------------------
--  DDL for View V_T_STANDING_CLEARENCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_T_STANDING_CLEARENCE" ("ID", "POWER_SALE_ID", "PROCESS_TYPE_CODE", "CODE", "CONSUMER_COMP_SERV_ID", "SALE_TYPE_CODE", "FROM_DT", "TO_DT", "APPLN_DT", "STATUS_CODE", "CONSUMER_COMP_ID", "CONSUMER_COMP_SERV_NUMBER", "CONSUMER_END_ORG_ID", "CONSUMER_VOLTAGE_CODE", "CREATED_DATE", "MODIFIED_DATE") AS 
  SELECT sc.ID,sc.T_ES_INTENT_ID AS POWER_SALE_ID,'SC' as PROCESS_TYPE_CODE,sc.CODE,sc.BUYER_COMP_SERV_ID AS CONSUMER_COMP_SERV_ID,sc.FLOW_TYPE_CODE AS SALE_TYPE_CODE,
sc.FROM_DATE AS FROM_DT,sc.TO_DATE AS TO_DT,sc.APPLIED_DT AS APPLN_DT,sc.STATUS_CODE,
bs.M_COMPANY_ID AS CONSUMER_COMP_ID,bs."number" AS CONSUMER_COMP_SERV_NUMBER,bs.M_ORG_ID AS CONSUMER_END_ORG_ID,bs.VOLTAGE_CODE AS CONSUMER_VOLTAGE_CODE,
sc.CREATED_DATE, sc.MODIFIED_DATE
FROM T_STANDING_CLEARENCE sc
LEFT JOIN V_COMPANY_SERVICE bs ON sc.BUYER_COMP_SERV_ID=bs.ID
;
--------------------------------------------------------
--  DDL for View V_WEG_PP
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."V_WEG_PP" ("ID", "POWERPLANT_NAME", "ORG_ID", "ORG_CODE", "ORG_NAME", "COMPANY_ID", "COMPANY_NAME", "SERVICE_ID", "SERVICE_NUMBER", "VOLTAGE_CODE", "VOLTAGE_NAME", "WIND_PASS_CODE", "WIND_PASS_NAME", "TOTAL_CAPACITY", "APPROVED_CAPACITY", "COMMISSION_DATE", "MAKE_CODE", "MAKE_NAME", "CAPACITY", "NO_OF_UNITS", "RATE", "PLANT_CLASS_TYPE_CODE", "PLANT_CLASS_TYPE_NAME") AS 
  SELECT powerplant.ID,powerplant.NAME AS POWERPLANT_NAME,powerplant.M_ORG_ID AS ORG_ID ,org.ORG_CODE,org.ORG_NAME,company.ID AS COMPANY_ID,company.NAME AS COMPANY_NAME,powerplant.M_SERVICE_ID AS SERVICE_ID,companyservice."number" AS SERVICE_NUMBER,
companyservice.VOLTAGE_CODE,voltagecodes.VALUE_DESC AS VOLTAGE_NAME,powerplant.WIND_PASS_CODE,windpasscodes.VALUE_DESC AS WIND_PASS_NAME,powerplant.TOTAL_CAPACITY,companyservice.CAPACITY AS APPROVED_CAPACITY,
powerplant.COMMISSION_DATE commission_date, gen_unit.make_code, genmakecodes.VALUE_DESC as make_name,gen_unit.capacity, gen_unit.no_of_units,
tariff.RATE,powerplant.PLANT_CLASS_TYPE_CODE, weggrpcodes .VALUE_DESC as PLANT_CLASS_TYPE_NAME
FROM M_POWERPLANT powerplant
LEFT JOIN m_generator gen_unit ON powerplant.id = gen_unit.M_POWERPLANT_ID
LEFT JOIN V_ORG org ON powerplant.M_ORG_ID = org.ORG_ID
LEFT JOIN M_COMPANY_SERVICE companyservice ON powerplant.M_SERVICE_ID = companyservice.ID
LEFT JOIN M_COMPANY company ON companyservice.M_COMPANY_ID = company.ID
LEFT JOIN V_CODES voltagecodes ON companyservice.VOLTAGE_CODE= voltagecodes.Value_Code AND voltagecodes.list_code = 'VOLTAGE_CODE'
LEFT JOIN v_codes windpasscodes ON powerplant.WIND_PASS_CODE = windpasscodes.Value_Code  AND  windpasscodes.list_code = 'WIND_PASS_CODE'
LEFT JOIN V_CODES genmakecodes ON companyservice.VOLTAGE_CODE= genmakecodes.Value_Code AND genmakecodes.list_code = 'GENERATOR_MAKE_CODE'
LEFT JOIN M_TARIFF tariff ON powerplant.PLANT_CLASS_TYPE_CODE = tariff.WEG_GROUP_CODE
LEFT JOIN V_CODES weggrpcodes ON companyservice.VOLTAGE_CODE= weggrpcodes.Value_Code AND weggrpcodes.list_code = 'PLANT_CLASS_TYPE_CODE'
order by companyservice."number"
;
--------------------------------------------------------
--  DDL for View WEG_CAPTIVE_GROUP_WISE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."WEG_CAPTIVE_GROUP_WISE" ("rownum", "WEG_COUNT", "WEG_GROUP_NAME", "WEG_GROUP_CODE", "STMT_MONTH", "STMT_YEAR", "FUEL_TYPE_CODE", "FLOW_TYPE_CODE", "IMP", "EXPO", "NET_GEN", "ADJ") AS 
  SELECT 
    rownum,WEG_COUNT,WEG_GROUP_NAME,WEG_GROUP_CODE,STMT_MONTH,STMT_YEAR,FUEL_TYPE_CODE,FLOW_TYPE_CODE,
    IMP,EXP,NET_GEN,ADJ
FROM 
(select a.count WEG_COUNT,a.WEG_GROUP_NAME,a.WEG_GROUP_CODE,a.STMT_MONTH,a.stmt_year,a.IMP,a.EXP,a.NET_GEN,b.ADJ,a.flow_type_code,b.fuel_type_code from
(  select count(*) as count,
BB.STMT_MONTH,bb.STMT_YEAR,
mt.WEG_GROUP_NAME WEG_GROUP_NAME ,mt.WEG_GROUP_CODE WEG_GROUP_CODE,
SUM(BB.TOTAL_IMPORT_GEN)/1000000 IMP,SUM(BB.TOTAL_EXPORT_GEN)/1000000 EXP ,bb.DISP_FUEL_TYPE_CODE,BB.FLOW_TYPE_CODE,
sum(bb.NET_GENERATION)/1000000 AS NET_GEN
  from t_gen_stmt bb
  left join v_company_Service s on bb.m_Company_id=s.m_company_id
  left join m_powerplant pp on s.id=pp.m_service_id
  left join M_TARIFF mt on pp.PLANT_CLASS_TYPE_CODE = mt.WEG_GROUP_CODE 
 GROUP BY mt.WEG_GROUP_NAME, mt.WEG_GROUP_CODE, BB.STMT_MONTH, bb.STMT_YEAR, bb.DISP_FUEL_TYPE_CODE, BB.FLOW_TYPE_CODE)a,
( select count(mt.WEG_GROUP_CODE) as count,mt.WEG_GROUP_NAME WEG_GROUP_NAME ,mt.WEG_GROUP_CODE WEG_GROUP_CODE,(SUM(FEA.ADJUSTED_C1) +
SUM(FEA.ADJUSTED_C2)+SUM(FEA.ADJUSTED_C3)+SUM(FEA.ADJUSTED_C4)+SUM(FEA.ADJUSTED_C5) )/1000000  AS ADJ,vcs.FLOW_TYPE_CODE,vcs.FUEL_TYPE_CODE,
fea.reading_mnth,fea.reading_yr
from F_ENERGY_ADJUSTMET FEA
LEFT JOIN V_COMPANY_SERVICE VCS on FEA.suplr_code = VCS."number"
  left join m_powerplant pp on VCS.id=pp.m_service_id
    left join M_TARIFF mt on pp.PLANT_CLASS_TYPE_CODE = mt.WEG_GROUP_CODE
group by mt.WEG_GROUP_NAME, mt.WEG_GROUP_CODE, fea.reading_mnth, fea.reading_yr, vcs.FLOW_TYPE_CODE, 
vcs.FUEL_TYPE_CODE)b
where a.WEG_GROUP_CODE=b.WEG_GROUP_CODE and a.STMT_MONTH=b.reading_mnth and a.STMT_YEAR=b.reading_yr 
and a.DISP_FUEL_TYPE_CODE=b.FUEL_TYPE_CODE and 
b.FLOW_TYPE_CODE=a.FLOW_TYPE_CODE)
;
--------------------------------------------------------
--  DDL for View _RS_RCI_BACKUP_CONTROLFILE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_BACKUP_CONTROLFILE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "AUTOBACKUP_DATE", "AUTOBACKUP_SEQUENCE", "BCF_KEY", "BLOCKS", "BLOCK_SIZE", "BS_KEY", "BS_LEVEL", "BS_RECID", "BS_STAMP", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "COMPLETION_TIME", "CONTROLFILE_TYPE", "CREATION_TIME", "DBINC_KEY", "DB_KEY", "DB_NAME", "GUID", "OLDEST_OFFLINE_RANGE", "PDB_KEY", "RECID", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "SET_COUNT", "SET_STAMP", "STAMP", "STATUS") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."AUTOBACKUP_DATE",t."AUTOBACKUP_SEQUENCE",t."BCF_KEY",t."BLOCKS",t."BLOCK_SIZE",t."BS_KEY",t."BS_LEVEL",t."BS_RECID",t."BS_STAMP",t."CHECKPOINT_CHANGE#",t."CHECKPOINT_TIME",t."COMPLETION_TIME",t."CONTROLFILE_TYPE",t."CREATION_TIME",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."GUID",t."OLDEST_OFFLINE_RANGE",t."PDB_KEY",t."RECID",t."RESETLOGS_CHANGE#",t."RESETLOGS_TIME",t."SET_COUNT",t."SET_STAMP",t."STAMP",t."STATUS" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_BACKUP_CONTROLFILE/ROW' passing x.xmldoc columns "AUTOBACKUP_DATE" CHAR(24) path 'AUTOBACKUP_DATE',"AUTOBACKUP_SEQUENCE" NUMBER path 'AUTOBACKUP_SEQUENCE',"BCF_KEY" NUMBER path 'BCF_KEY',"BLOCKS" NUMBER path 'BLOCKS',"BLOCK_SIZE" NUMBER path 'BLOCK_SIZE',"BS_KEY" NUMBER path 'BS_KEY',"BS_LEVEL" NUMBER path 'BS_LEVEL',"BS_RECID" NUMBER path 'BS_RECID',"BS_STAMP" NUMBER path 'BS_STAMP',"CHECKPOINT_CHANGE#" NUMBER path 'CHECKPOINT_CHANGE_x0023_',"CHECKPOINT_TIME" CHAR(24) path 'CHECKPOINT_TIME',"COMPLETION_TIME" CHAR(24) path 'COMPLETION_TIME',"CONTROLFILE_TYPE" VARCHAR2(1) path 'CONTROLFILE_TYPE',"CREATION_TIME" CHAR(24) path 'CREATION_TIME',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"GUID" RAW(16) path 'GUID',"OLDEST_OFFLINE_RANGE" NUMBER path 'OLDEST_OFFLINE_RANGE',"PDB_KEY" NUMBER path 'PDB_KEY',"RECID" NUMBER path 'RECID',"RESETLOGS_CHANGE#" NUMBER path 'RESETLOGS_CHANGE_x0023_',"RESETLOGS_TIME" CHAR(24) path 'RESETLOGS_TIME',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP',"STAMP" NUMBER path 'STAMP',"STATUS" VARCHAR2(1) path 'STATUS') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_BACKUP_DATAFILE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_BACKUP_DATAFILE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "ABSOLUTE_FUZZY_CHANGE#", "BACKUP_TYPE", "BDF_KEY", "BLOCKS", "BLOCKS_READ", "BLOCK_SIZE", "BS_KEY", "BS_LEVEL", "BS_RECID", "BS_STAMP", "CHECKPOINT_CHANGE#", "CHECKPOINT_TIME", "COMPLETION_TIME", "CREATION_CHANGE#", "CREATION_TIME", "DATAFILE_BLOCKS", "DBINC_KEY", "DB_KEY", "DB_NAME", "FILE#", "FOREIGN_DBID", "GUID", "INCREMENTAL_CHANGE#", "INCREMENTAL_LEVEL", "MARKED_CORRUPT", "PCT_NOTREAD", "PDB_KEY", "PIECES", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "RECID", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "SECTION_SIZE", "SET_COUNT", "SET_STAMP", "SPARSE_BACKUP", "STAMP", "STATUS", "USED_CHANGE_TRACKING", "USED_OPTIMIZATION") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."ABSOLUTE_FUZZY_CHANGE#",t."BACKUP_TYPE",t."BDF_KEY",t."BLOCKS",t."BLOCKS_READ",t."BLOCK_SIZE",t."BS_KEY",t."BS_LEVEL",t."BS_RECID",t."BS_STAMP",t."CHECKPOINT_CHANGE#",t."CHECKPOINT_TIME",t."COMPLETION_TIME",t."CREATION_CHANGE#",t."CREATION_TIME",t."DATAFILE_BLOCKS",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."FILE#",t."FOREIGN_DBID",t."GUID",t."INCREMENTAL_CHANGE#",t."INCREMENTAL_LEVEL",t."MARKED_CORRUPT",t."PCT_NOTREAD",t."PDB_KEY",t."PIECES",t."PLUGGED_READONLY",t."PLUGIN_CHANGE#",t."PLUGIN_RESETLOGS_CHANGE#",t."PLUGIN_RESETLOGS_TIME",t."RECID",t."RESETLOGS_CHANGE#",t."RESETLOGS_TIME",t."SECTION_SIZE",t."SET_COUNT",t."SET_STAMP",t."SPARSE_BACKUP",t."STAMP",t."STATUS",t."USED_CHANGE_TRACKING",t."USED_OPTIMIZATION" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_BACKUP_DATAFILE/ROW' passing x.xmldoc columns "ABSOLUTE_FUZZY_CHANGE#" NUMBER path 'ABSOLUTE_FUZZY_CHANGE_x0023_',"BACKUP_TYPE" VARCHAR2(1) path 'BACKUP_TYPE',"BDF_KEY" NUMBER path 'BDF_KEY',"BLOCKS" NUMBER path 'BLOCKS',"BLOCKS_READ" NUMBER path 'BLOCKS_READ',"BLOCK_SIZE" NUMBER path 'BLOCK_SIZE',"BS_KEY" NUMBER path 'BS_KEY',"BS_LEVEL" NUMBER path 'BS_LEVEL',"BS_RECID" NUMBER path 'BS_RECID',"BS_STAMP" NUMBER path 'BS_STAMP',"CHECKPOINT_CHANGE#" NUMBER path 'CHECKPOINT_CHANGE_x0023_',"CHECKPOINT_TIME" CHAR(24) path 'CHECKPOINT_TIME',"COMPLETION_TIME" CHAR(24) path 'COMPLETION_TIME',"CREATION_CHANGE#" NUMBER path 'CREATION_CHANGE_x0023_',"CREATION_TIME" CHAR(24) path 'CREATION_TIME',"DATAFILE_BLOCKS" NUMBER path 'DATAFILE_BLOCKS',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"FILE#" NUMBER path 'FILE_x0023_',"FOREIGN_DBID" NUMBER path 'FOREIGN_DBID',"GUID" RAW(16) path 'GUID',"INCREMENTAL_CHANGE#" NUMBER path 'INCREMENTAL_CHANGE_x0023_',"INCREMENTAL_LEVEL" NUMBER path 'INCREMENTAL_LEVEL',"MARKED_CORRUPT" NUMBER path 'MARKED_CORRUPT',"PCT_NOTREAD" NUMBER path 'PCT_NOTREAD',"PDB_KEY" NUMBER path 'PDB_KEY',"PIECES" NUMBER path 'PIECES',"PLUGGED_READONLY" VARCHAR2(3) path 'PLUGGED_READONLY',"PLUGIN_CHANGE#" NUMBER path 'PLUGIN_CHANGE_x0023_',"PLUGIN_RESETLOGS_CHANGE#" NUMBER path 'PLUGIN_RESETLOGS_CHANGE_x0023_',"PLUGIN_RESETLOGS_TIME" CHAR(24) path 'PLUGIN_RESETLOGS_TIME',"RECID" NUMBER path 'RECID',"RESETLOGS_CHANGE#" NUMBER path 'RESETLOGS_CHANGE_x0023_',"RESETLOGS_TIME" CHAR(24) path 'RESETLOGS_TIME',"SECTION_SIZE" NUMBER path 'SECTION_SIZE',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP',"SPARSE_BACKUP" VARCHAR2(3) path 'SPARSE_BACKUP',"STAMP" NUMBER path 'STAMP',"STATUS" VARCHAR2(1) path 'STATUS',"USED_CHANGE_TRACKING" VARCHAR2(3) path 'USED_CHANGE_TRACKING',"USED_OPTIMIZATION" VARCHAR2(3) path 'USED_OPTIMIZATION') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_BACKUP_PIECE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_BACKUP_PIECE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BACKED_BY_OSB", "BACKUP_TYPE", "BA_ACCESS", "BP_KEY", "BS_KEY", "BYTES", "COMMENTS", "COMPLETION_TIME", "COMPRESSED", "CONCUR", "COPY#", "DB_ID", "DB_KEY", "DEVICE_TYPE", "ELAPSED_SECONDS", "ENCRYPTED", "GUID", "HANDLE", "INCREMENTAL_LEVEL", "IS_RECOVERY_DEST_FILE", "LIB_KEY", "MEDIA", "MEDIA_POOL", "PDB_KEY", "PIECE#", "RECID", "RSR_KEY", "SET_COUNT", "SET_STAMP", "SITE_KEY", "STAMP", "START_TIME", "STATUS", "TAG", "VB_KEY", "VIRTUAL") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BACKED_BY_OSB",t."BACKUP_TYPE",t."BA_ACCESS",t."BP_KEY",t."BS_KEY",t."BYTES",t."COMMENTS",t."COMPLETION_TIME",t."COMPRESSED",t."CONCUR",t."COPY#",t."DB_ID",t."DB_KEY",t."DEVICE_TYPE",t."ELAPSED_SECONDS",t."ENCRYPTED",t."GUID",t."HANDLE",t."INCREMENTAL_LEVEL",t."IS_RECOVERY_DEST_FILE",t."LIB_KEY",t."MEDIA",t."MEDIA_POOL",t."PDB_KEY",t."PIECE#",t."RECID",t."RSR_KEY",t."SET_COUNT",t."SET_STAMP",t."SITE_KEY",t."STAMP",t."START_TIME",t."STATUS",t."TAG",t."VB_KEY",t."VIRTUAL" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_BACKUP_PIECE/ROW' passing x.xmldoc columns "BACKED_BY_OSB" VARCHAR2(3) path 'BACKED_BY_OSB',"BACKUP_TYPE" VARCHAR2(1) path 'BACKUP_TYPE',"BA_ACCESS" VARCHAR2(11) path 'BA_ACCESS',"BP_KEY" NUMBER path 'BP_KEY',"BS_KEY" NUMBER path 'BS_KEY',"BYTES" NUMBER path 'BYTES',"COMMENTS" VARCHAR2(255) path 'COMMENTS',"COMPLETION_TIME" CHAR(24) path 'COMPLETION_TIME',"COMPRESSED" VARCHAR2(3) path 'COMPRESSED',"CONCUR" VARCHAR2(3) path 'CONCUR',"COPY#" NUMBER path 'COPY_x0023_',"DB_ID" NUMBER path 'DB_ID',"DB_KEY" NUMBER path 'DB_KEY',"DEVICE_TYPE" VARCHAR2(255) path 'DEVICE_TYPE',"ELAPSED_SECONDS" NUMBER path 'ELAPSED_SECONDS',"ENCRYPTED" VARCHAR2(3) path 'ENCRYPTED',"GUID" RAW(16) path 'GUID',"HANDLE" VARCHAR2(1024) path 'HANDLE',"INCREMENTAL_LEVEL" NUMBER path 'INCREMENTAL_LEVEL',"IS_RECOVERY_DEST_FILE" VARCHAR2(3) path 'IS_RECOVERY_DEST_FILE',"LIB_KEY" NUMBER path 'LIB_KEY',"MEDIA" VARCHAR2(80) path 'MEDIA',"MEDIA_POOL" NUMBER path 'MEDIA_POOL',"PDB_KEY" NUMBER path 'PDB_KEY',"PIECE#" NUMBER path 'PIECE_x0023_',"RECID" NUMBER path 'RECID',"RSR_KEY" NUMBER path 'RSR_KEY',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP',"SITE_KEY" NUMBER path 'SITE_KEY',"STAMP" NUMBER path 'STAMP',"START_TIME" CHAR(24) path 'START_TIME',"STATUS" VARCHAR2(1) path 'STATUS',"TAG" VARCHAR2(32) path 'TAG',"VB_KEY" NUMBER path 'VB_KEY',"VIRTUAL" VARCHAR2(3) path 'VIRTUAL') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_BACKUP_SET_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_BACKUP_SET_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BACKUP_TYPE", "BLOCK_SIZE", "BS_KEY", "COMPLETION_TIME", "CONTROLFILE_INCLUDED", "DB_ID", "DB_KEY", "ELAPSED_SECONDS", "GUID", "INCREMENTAL_LEVEL", "INPUT_FILE_SCAN_ONLY", "KEEP", "KEEP_OPTIONS", "KEEP_UNTIL", "MULTI_SECTION", "PDB_KEY", "PIECES", "RECID", "SET_COUNT", "SET_STAMP", "SITE_KEY", "STAMP", "START_TIME", "STATUS") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BACKUP_TYPE",t."BLOCK_SIZE",t."BS_KEY",t."COMPLETION_TIME",t."CONTROLFILE_INCLUDED",t."DB_ID",t."DB_KEY",t."ELAPSED_SECONDS",t."GUID",t."INCREMENTAL_LEVEL",t."INPUT_FILE_SCAN_ONLY",t."KEEP",t."KEEP_OPTIONS",t."KEEP_UNTIL",t."MULTI_SECTION",t."PDB_KEY",t."PIECES",t."RECID",t."SET_COUNT",t."SET_STAMP",t."SITE_KEY",t."STAMP",t."START_TIME",t."STATUS" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_BACKUP_SET/ROW' passing x.xmldoc columns "BACKUP_TYPE" VARCHAR2(1) path 'BACKUP_TYPE',"BLOCK_SIZE" NUMBER path 'BLOCK_SIZE',"BS_KEY" NUMBER path 'BS_KEY',"COMPLETION_TIME" CHAR(24) path 'COMPLETION_TIME',"CONTROLFILE_INCLUDED" VARCHAR2(7) path 'CONTROLFILE_INCLUDED',"DB_ID" NUMBER path 'DB_ID',"DB_KEY" NUMBER path 'DB_KEY',"ELAPSED_SECONDS" NUMBER path 'ELAPSED_SECONDS',"GUID" RAW(16) path 'GUID',"INCREMENTAL_LEVEL" NUMBER path 'INCREMENTAL_LEVEL',"INPUT_FILE_SCAN_ONLY" VARCHAR2(3) path 'INPUT_FILE_SCAN_ONLY',"KEEP" VARCHAR2(3) path 'KEEP',"KEEP_OPTIONS" VARCHAR2(11) path 'KEEP_OPTIONS',"KEEP_UNTIL" CHAR(24) path 'KEEP_UNTIL',"MULTI_SECTION" VARCHAR2(3) path 'MULTI_SECTION',"PDB_KEY" NUMBER path 'PDB_KEY',"PIECES" NUMBER path 'PIECES',"RECID" NUMBER path 'RECID',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP',"SITE_KEY" NUMBER path 'SITE_KEY',"STAMP" NUMBER path 'STAMP',"START_TIME" CHAR(24) path 'START_TIME',"STATUS" VARCHAR2(1) path 'STATUS') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_BACKUP_SPFILE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_BACKUP_SPFILE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BSF_KEY", "BS_KEY", "BS_RECID", "BS_STAMP", "BYTES", "COMPLETION_TIME", "DB_KEY", "DB_UNIQUE_NAME", "GUID", "MODIFICATION_TIME", "RECID", "SET_COUNT", "SET_STAMP", "STAMP", "STATUS") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BSF_KEY",t."BS_KEY",t."BS_RECID",t."BS_STAMP",t."BYTES",t."COMPLETION_TIME",t."DB_KEY",t."DB_UNIQUE_NAME",t."GUID",t."MODIFICATION_TIME",t."RECID",t."SET_COUNT",t."SET_STAMP",t."STAMP",t."STATUS" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_BACKUP_SPFILE/ROW' passing x.xmldoc columns "BSF_KEY" NUMBER path 'BSF_KEY',"BS_KEY" NUMBER path 'BS_KEY',"BS_RECID" NUMBER path 'BS_RECID',"BS_STAMP" NUMBER path 'BS_STAMP',"BYTES" NUMBER path 'BYTES',"COMPLETION_TIME" CHAR(24) path 'COMPLETION_TIME',"DB_KEY" NUMBER path 'DB_KEY',"DB_UNIQUE_NAME" VARCHAR2(30) path 'DB_UNIQUE_NAME',"GUID" RAW(16) path 'GUID',"MODIFICATION_TIME" CHAR(24) path 'MODIFICATION_TIME',"RECID" NUMBER path 'RECID',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP',"STAMP" NUMBER path 'STAMP',"STATUS" VARCHAR2(1) path 'STATUS') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_DATAFILE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_DATAFILE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "AUX_NAME", "BLOCKS", "BLOCK_SIZE", "BYTES", "CON_ID", "CREATION_CHANGE#", "CREATION_SIZE", "CREATION_THREAD", "CREATION_TIME", "DBINC_KEY", "DB_KEY", "DB_NAME", "DB_UNIQUE_NAME", "DROP_CHANGE#", "DROP_TIME", "ENCRYPT_IN_BACKUP", "FILE#", "FOREIGN_CREATION_CHANGE#", "FOREIGN_CREATION_TIME", "FOREIGN_DBID", "INCLUDED_IN_DATABASE_BACKUP", "NAME", "PDBINC_KEY", "PDB_CLOSED", "PDB_FOREIGN_DBID", "PDB_KEY", "PDB_NAME", "PDB_NOBACKUP", "PLUGGED_READONLY", "PLUGIN_CHANGE#", "PLUGIN_RESETLOGS_CHANGE#", "PLUGIN_RESETLOGS_TIME", "READ_ONLY", "RFILE#", "SITE_KEY", "STOP_CHANGE#", "STOP_TIME", "TABLESPACE_NAME", "TS#") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."AUX_NAME",t."BLOCKS",t."BLOCK_SIZE",t."BYTES",t."CON_ID",t."CREATION_CHANGE#",t."CREATION_SIZE",t."CREATION_THREAD",t."CREATION_TIME",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."DB_UNIQUE_NAME",t."DROP_CHANGE#",t."DROP_TIME",t."ENCRYPT_IN_BACKUP",t."FILE#",t."FOREIGN_CREATION_CHANGE#",t."FOREIGN_CREATION_TIME",t."FOREIGN_DBID",t."INCLUDED_IN_DATABASE_BACKUP",t."NAME",t."PDBINC_KEY",t."PDB_CLOSED",t."PDB_FOREIGN_DBID",t."PDB_KEY",t."PDB_NAME",t."PDB_NOBACKUP",t."PLUGGED_READONLY",t."PLUGIN_CHANGE#",t."PLUGIN_RESETLOGS_CHANGE#",t."PLUGIN_RESETLOGS_TIME",t."READ_ONLY",t."RFILE#",t."SITE_KEY",t."STOP_CHANGE#",t."STOP_TIME",t."TABLESPACE_NAME",t."TS#" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_DATAFILE/ROW' passing x.xmldoc columns "AUX_NAME" VARCHAR2(1024) path 'AUX_NAME',"BLOCKS" NUMBER path 'BLOCKS',"BLOCK_SIZE" NUMBER path 'BLOCK_SIZE',"BYTES" NUMBER path 'BYTES',"CON_ID" NUMBER path 'CON_ID',"CREATION_CHANGE#" NUMBER path 'CREATION_CHANGE_x0023_',"CREATION_SIZE" NUMBER path 'CREATION_SIZE',"CREATION_THREAD" NUMBER path 'CREATION_THREAD',"CREATION_TIME" CHAR(24) path 'CREATION_TIME',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"DB_UNIQUE_NAME" VARCHAR2(512) path 'DB_UNIQUE_NAME',"DROP_CHANGE#" NUMBER path 'DROP_CHANGE_x0023_',"DROP_TIME" CHAR(24) path 'DROP_TIME',"ENCRYPT_IN_BACKUP" VARCHAR2(3) path 'ENCRYPT_IN_BACKUP',"FILE#" NUMBER path 'FILE_x0023_',"FOREIGN_CREATION_CHANGE#" NUMBER path 'FOREIGN_CREATION_CHANGE_x0023_',"FOREIGN_CREATION_TIME" CHAR(24) path 'FOREIGN_CREATION_TIME',"FOREIGN_DBID" NUMBER path 'FOREIGN_DBID',"INCLUDED_IN_DATABASE_BACKUP" VARCHAR2(3) path 'INCLUDED_IN_DATABASE_BACKUP',"NAME" VARCHAR2(1024) path 'NAME',"PDBINC_KEY" NUMBER path 'PDBINC_KEY',"PDB_CLOSED" NUMBER path 'PDB_CLOSED',"PDB_FOREIGN_DBID" NUMBER path 'PDB_FOREIGN_DBID',"PDB_KEY" NUMBER path 'PDB_KEY',"PDB_NAME" VARCHAR2(128) path 'PDB_NAME',"PDB_NOBACKUP" VARCHAR2(1) path 'PDB_NOBACKUP',"PLUGGED_READONLY" VARCHAR2(3) path 'PLUGGED_READONLY',"PLUGIN_CHANGE#" NUMBER path 'PLUGIN_CHANGE_x0023_',"PLUGIN_RESETLOGS_CHANGE#" NUMBER path 'PLUGIN_RESETLOGS_CHANGE_x0023_',"PLUGIN_RESETLOGS_TIME" CHAR(24) path 'PLUGIN_RESETLOGS_TIME',"READ_ONLY" NUMBER path 'READ_ONLY',"RFILE#" NUMBER path 'RFILE_x0023_',"SITE_KEY" NUMBER path 'SITE_KEY',"STOP_CHANGE#" NUMBER path 'STOP_CHANGE_x0023_',"STOP_TIME" CHAR(24) path 'STOP_TIME',"TABLESPACE_NAME" VARCHAR2(30) path 'TABLESPACE_NAME',"TS#" NUMBER path 'TS_x0023_') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_PDBS_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_PDBS_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "CON_ID", "CREATION_CHANGE#", "DBID", "DB_KEY", "GUID", "NAME", "NOBACKUP", "PDB_KEY") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."CON_ID",t."CREATION_CHANGE#",t."DBID",t."DB_KEY",t."GUID",t."NAME",t."NOBACKUP",t."PDB_KEY" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_PDBS/ROW' passing x.xmldoc columns "CON_ID" NUMBER path 'CON_ID',"CREATION_CHANGE#" NUMBER path 'CREATION_CHANGE_x0023_',"DBID" NUMBER path 'DBID',"DB_KEY" NUMBER path 'DB_KEY',"GUID" RAW(16) path 'GUID',"NAME" VARCHAR2(128) path 'NAME',"NOBACKUP" VARCHAR2(1) path 'NOBACKUP',"PDB_KEY" NUMBER path 'PDB_KEY') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_RA_UPSTREAM_DATABASE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_RA_UPSTREAM_DATABASE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "DBID", "NAME") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."DBID",t."NAME" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_RA_UPSTREAM_DATABASE/ROW' passing x.xmldoc columns "DBID" NUMBER path 'DBID',"NAME" CHAR path 'NAME') t
;
--------------------------------------------------------
--  DDL for View _RS_RCI_TEMPFILE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RCI_TEMPFILE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "AUTOEXTEND", "BIGFILE", "BLOCKS", "BLOCK_SIZE", "BYTES", "CON_ID", "CREATION_CHANGE#", "CREATION_TIME", "DBINC_KEY", "DB_KEY", "DB_NAME", "DB_UNIQUE_NAME", "DROP_CHANGE#", "DROP_TIME", "FILE#", "MAXSIZE", "NAME", "NEXTSIZE", "PDB_KEY", "PDB_NAME", "RFILE#", "SITE_KEY", "TABLESPACE_CREATION_CHANGE#", "TABLESPACE_CREATION_TIME", "TABLESPACE_DROP_CHANGE#", "TABLESPACE_DROP_TIME", "TABLESPACE_NAME", "TS#") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."AUTOEXTEND",t."BIGFILE",t."BLOCKS",t."BLOCK_SIZE",t."BYTES",t."CON_ID",t."CREATION_CHANGE#",t."CREATION_TIME",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."DB_UNIQUE_NAME",t."DROP_CHANGE#",t."DROP_TIME",t."FILE#",t."MAXSIZE",t."NAME",t."NEXTSIZE",t."PDB_KEY",t."PDB_NAME",t."RFILE#",t."SITE_KEY",t."TABLESPACE_CREATION_CHANGE#",t."TABLESPACE_CREATION_TIME",t."TABLESPACE_DROP_CHANGE#",t."TABLESPACE_DROP_TIME",t."TABLESPACE_NAME",t."TS#" from rcfile x, xmltable('/ALL_TABLES/TABLE_RCI_TEMPFILE/ROW' passing x.xmldoc columns "AUTOEXTEND" VARCHAR2(3) path 'AUTOEXTEND',"BIGFILE" VARCHAR2(3) path 'BIGFILE',"BLOCKS" NUMBER path 'BLOCKS',"BLOCK_SIZE" NUMBER path 'BLOCK_SIZE',"BYTES" NUMBER path 'BYTES',"CON_ID" NUMBER path 'CON_ID',"CREATION_CHANGE#" NUMBER path 'CREATION_CHANGE_x0023_',"CREATION_TIME" CHAR(24) path 'CREATION_TIME',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"DB_UNIQUE_NAME" VARCHAR2(512) path 'DB_UNIQUE_NAME',"DROP_CHANGE#" NUMBER path 'DROP_CHANGE_x0023_',"DROP_TIME" CHAR(24) path 'DROP_TIME',"FILE#" NUMBER path 'FILE_x0023_',"MAXSIZE" NUMBER path 'MAXSIZE',"NAME" VARCHAR2(1024) path 'NAME',"NEXTSIZE" NUMBER path 'NEXTSIZE',"PDB_KEY" NUMBER path 'PDB_KEY',"PDB_NAME" VARCHAR2(128) path 'PDB_NAME',"RFILE#" NUMBER path 'RFILE_x0023_',"SITE_KEY" NUMBER path 'SITE_KEY',"TABLESPACE_CREATION_CHANGE#" NUMBER path 'TABLESPACE_CREATION_CHANGE_x0023_',"TABLESPACE_CREATION_TIME" CHAR(24) path 'TABLESPACE_CREATION_TIME',"TABLESPACE_DROP_CHANGE#" NUMBER path 'TABLESPACE_DROP_CHANGE_x0023_',"TABLESPACE_DROP_TIME" CHAR(24) path 'TABLESPACE_DROP_TIME',"TABLESPACE_NAME" VARCHAR2(30) path 'TABLESPACE_NAME',"TS#" NUMBER path 'TS_x0023_') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_BACKUP_REDOLOG_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_BACKUP_REDOLOG_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BACKUP_TYPE", "BLOCKS", "BLOCK_SIZE", "BRL_KEY", "BS_KEY", "BS_RECID", "BS_STAMP", "COMPLETION_TIME", "DBINC_KEY", "DB_KEY", "DB_NAME", "FIRST_CHANGE#", "FIRST_TIME", "NEXT_CHANGE#", "NEXT_TIME", "PARTIAL", "PIECES", "RECID", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "SEQUENCE#", "SET_COUNT", "SET_STAMP", "STAMP", "STATUS", "TERMINAL", "THREAD#") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BACKUP_TYPE",t."BLOCKS",t."BLOCK_SIZE",t."BRL_KEY",t."BS_KEY",t."BS_RECID",t."BS_STAMP",t."COMPLETION_TIME",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."FIRST_CHANGE#",t."FIRST_TIME",t."NEXT_CHANGE#",t."NEXT_TIME",t."PARTIAL",t."PIECES",t."RECID",t."RESETLOGS_CHANGE#",t."RESETLOGS_TIME",t."SEQUENCE#",t."SET_COUNT",t."SET_STAMP",t."STAMP",t."STATUS",t."TERMINAL",t."THREAD#" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_BACKUP_REDOLOG/ROW' passing x.xmldoc columns "BACKUP_TYPE" VARCHAR2(1) path 'BACKUP_TYPE',"BLOCKS" NUMBER path 'BLOCKS',"BLOCK_SIZE" NUMBER path 'BLOCK_SIZE',"BRL_KEY" NUMBER path 'BRL_KEY',"BS_KEY" NUMBER path 'BS_KEY',"BS_RECID" NUMBER path 'BS_RECID',"BS_STAMP" NUMBER path 'BS_STAMP',"COMPLETION_TIME" CHAR(24) path 'COMPLETION_TIME',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"FIRST_CHANGE#" NUMBER path 'FIRST_CHANGE_x0023_',"FIRST_TIME" CHAR(24) path 'FIRST_TIME',"NEXT_CHANGE#" NUMBER path 'NEXT_CHANGE_x0023_',"NEXT_TIME" CHAR(24) path 'NEXT_TIME',"PARTIAL" VARCHAR2(3) path 'PARTIAL',"PIECES" NUMBER path 'PIECES',"RECID" NUMBER path 'RECID',"RESETLOGS_CHANGE#" NUMBER path 'RESETLOGS_CHANGE_x0023_',"RESETLOGS_TIME" CHAR(24) path 'RESETLOGS_TIME',"SEQUENCE#" NUMBER path 'SEQUENCE_x0023_',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP',"STAMP" NUMBER path 'STAMP',"STATUS" VARCHAR2(1) path 'STATUS',"TERMINAL" VARCHAR2(3) path 'TERMINAL',"THREAD#" NUMBER path 'THREAD_x0023_') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_CHECKPOINT_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_CHECKPOINT_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "CKP_CF_SEQ", "CKP_DB_STATUS", "CKP_KEY", "CKP_SCN", "CKP_TIME", "CKP_TYPE", "DBINC_KEY", "DB_KEY", "DB_NAME", "SITE_KEY") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."CKP_CF_SEQ",t."CKP_DB_STATUS",t."CKP_KEY",t."CKP_SCN",t."CKP_TIME",t."CKP_TYPE",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."SITE_KEY" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_CHECKPOINT/ROW' passing x.xmldoc columns "CKP_CF_SEQ" NUMBER path 'CKP_CF_SEQ',"CKP_DB_STATUS" VARCHAR2(7) path 'CKP_DB_STATUS',"CKP_KEY" NUMBER path 'CKP_KEY',"CKP_SCN" NUMBER path 'CKP_SCN',"CKP_TIME" CHAR(24) path 'CKP_TIME',"CKP_TYPE" VARCHAR2(7) path 'CKP_TYPE',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"SITE_KEY" NUMBER path 'SITE_KEY') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_DATABASE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_DATABASE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "DBID", "DBINC_KEY", "DB_KEY", "FINAL_CHANGE#", "NAME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."DBID",t."DBINC_KEY",t."DB_KEY",t."FINAL_CHANGE#",t."NAME",t."RESETLOGS_CHANGE#",t."RESETLOGS_TIME" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_DATABASE/ROW' passing x.xmldoc columns "DBID" NUMBER path 'DBID',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"FINAL_CHANGE#" NUMBER path 'FINAL_CHANGE_x0023_',"NAME" VARCHAR2(8) path 'NAME',"RESETLOGS_CHANGE#" NUMBER path 'RESETLOGS_CHANGE_x0023_',"RESETLOGS_TIME" CHAR(24) path 'RESETLOGS_TIME') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_DATABASE_INCARNATION_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_DATABASE_INCARNATION_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "CON_ID", "CURRENT_INCARNATION", "DBID", "DBINC_KEY", "DB_KEY", "GUID", "NAME", "PARENT_DBINC_KEY", "PRIOR_RESETLOGS_CHANGE#", "PRIOR_RESETLOGS_TIME", "REG_DB_UNIQUE_NAME", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "STATUS") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."CON_ID",t."CURRENT_INCARNATION",t."DBID",t."DBINC_KEY",t."DB_KEY",t."GUID",t."NAME",t."PARENT_DBINC_KEY",t."PRIOR_RESETLOGS_CHANGE#",t."PRIOR_RESETLOGS_TIME",t."REG_DB_UNIQUE_NAME",t."RESETLOGS_CHANGE#",t."RESETLOGS_TIME",t."STATUS" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_DATABASE_INCARNATION/ROW' passing x.xmldoc columns "CON_ID" NUMBER path 'CON_ID',"CURRENT_INCARNATION" VARCHAR2(3) path 'CURRENT_INCARNATION',"DBID" NUMBER path 'DBID',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"GUID" RAW(16) path 'GUID',"NAME" VARCHAR2(8) path 'NAME',"PARENT_DBINC_KEY" NUMBER path 'PARENT_DBINC_KEY',"PRIOR_RESETLOGS_CHANGE#" NUMBER path 'PRIOR_RESETLOGS_CHANGE_x0023_',"PRIOR_RESETLOGS_TIME" CHAR(24) path 'PRIOR_RESETLOGS_TIME',"REG_DB_UNIQUE_NAME" VARCHAR2(30) path 'REG_DB_UNIQUE_NAME',"RESETLOGS_CHANGE#" NUMBER path 'RESETLOGS_CHANGE_x0023_',"RESETLOGS_TIME" CHAR(24) path 'RESETLOGS_TIME',"STATUS" VARCHAR2(8) path 'STATUS') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_DELETED_OBJECT_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_DELETED_OBJECT_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "DB_KEY", "DEVICE_TYPE", "DO_KEY", "HANDLE", "OBJECT_DATA", "OBJECT_KEY", "OBJECT_STAMP", "OBJECT_TYPE", "SET_COUNT", "SET_STAMP") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."DB_KEY",t."DEVICE_TYPE",t."DO_KEY",t."HANDLE",t."OBJECT_DATA",t."OBJECT_KEY",t."OBJECT_STAMP",t."OBJECT_TYPE",t."SET_COUNT",t."SET_STAMP" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_DELETED_OBJECT/ROW' passing x.xmldoc columns "DB_KEY" NUMBER path 'DB_KEY',"DEVICE_TYPE" VARCHAR2(255) path 'DEVICE_TYPE',"DO_KEY" NUMBER path 'DO_KEY',"HANDLE" VARCHAR2(1024) path 'HANDLE',"OBJECT_DATA" NUMBER path 'OBJECT_DATA',"OBJECT_KEY" NUMBER path 'OBJECT_KEY',"OBJECT_STAMP" NUMBER path 'OBJECT_STAMP',"OBJECT_TYPE" VARCHAR2(26) path 'OBJECT_TYPE',"SET_COUNT" NUMBER path 'SET_COUNT',"SET_STAMP" NUMBER path 'SET_STAMP') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_GET_OBJECT_LIST_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_GET_OBJECT_LIST_" ("RCFILE_KEY", "PREFIX", "ISTRUNCATED", "MARKER", "MAXKEYS", "RCFILE_NAME", "LASTMODIFIED", "BYTES") AS 
  select y.rcfile_key, y.prefix, y.istruncated, substr(y.marker, 8) marker,
          y.maxkeys,
          substr(z.rcfile_name, 8) rcfile_name, z.lastmodified, z.bytes from 
          (select x.rcfile_key, t.prefix, t.istruncated, t.xmldoc, t.marker,
                  t.maxkeys
             from rcfile x, 
                  xmltable('/ListBucketResult' passing x.xmldoc 
                    columns prefix      varchar2(1024) path 'Prefix', 
                            istruncated varchar2(10) path 'IsTruncated', 
                            xmldoc      xmltype path 'Contents',
                            marker      varchar2(1024) path 'Marker', 
                            MaxKeys     number path 'MaxKeys') t 
             where name like 'prefix=%') y, 
          xmltable('/Contents' passing y.xmldoc 
             columns rcfile_name varchar2(1024) path 'Key', 
                     lastmodified timestamp with time zone path 'LastModified',
                     bytes number path 'Size')z

;
--------------------------------------------------------
--  DDL for View _RS_RC_OFFLINE_RANGE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_OFFLINE_RANGE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "CF_CREATE_TIME", "CREATION_CHANGE#", "DBINC_KEY", "DB_KEY", "DB_NAME", "FILE#", "OFFLINE_CHANGE#", "OFFR_KEY", "ONLINE_CHANGE#", "ONLINE_TIME", "RECID", "RESETLOGS_CHANGE#", "RESETLOGS_TIME", "STAMP") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."CF_CREATE_TIME",t."CREATION_CHANGE#",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."FILE#",t."OFFLINE_CHANGE#",t."OFFR_KEY",t."ONLINE_CHANGE#",t."ONLINE_TIME",t."RECID",t."RESETLOGS_CHANGE#",t."RESETLOGS_TIME",t."STAMP" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_OFFLINE_RANGE/ROW' passing x.xmldoc columns "CF_CREATE_TIME" CHAR(24) path 'CF_CREATE_TIME',"CREATION_CHANGE#" NUMBER path 'CREATION_CHANGE_x0023_',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"FILE#" NUMBER path 'FILE_x0023_',"OFFLINE_CHANGE#" NUMBER path 'OFFLINE_CHANGE_x0023_',"OFFR_KEY" NUMBER path 'OFFR_KEY',"ONLINE_CHANGE#" NUMBER path 'ONLINE_CHANGE_x0023_',"ONLINE_TIME" CHAR(24) path 'ONLINE_TIME',"RECID" NUMBER path 'RECID',"RESETLOGS_CHANGE#" NUMBER path 'RESETLOGS_CHANGE_x0023_',"RESETLOGS_TIME" CHAR(24) path 'RESETLOGS_TIME',"STAMP" NUMBER path 'STAMP') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_PLUGGABLE_DATABASE_INC_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_PLUGGABLE_DATABASE_INC_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BEGIN_RESETLOGS_SCN", "BEGIN_RESETLOGS_TIME", "CON_ID", "CREATE_SCN", "CURRENT_INCARNATION", "DBID", "DBINC_KEY", "DB_KEY", "DB_RESETLOGS_SCN", "DB_RESETLOGS_TIME", "END_RESETLOGS_SCN", "GUID", "INCARNATION_SCN", "NAME", "PDBINC_KEY", "PDB_KEY", "PRIOR_BEGIN_RESETLOGS_SCN", "PRIOR_BEGIN_RESETLOGS_TIME", "PRIOR_DBINC_KEY", "PRIOR_DB_RESETLOGS_SCN", "PRIOR_DB_RESETLOGS_TIME", "PRIOR_END_RESETLOGS_SCN", "PRIOR_INCARNATION_SCN", "PRIOR_PDBINC_KEY", "STATUS") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BEGIN_RESETLOGS_SCN",t."BEGIN_RESETLOGS_TIME",t."CON_ID",t."CREATE_SCN",t."CURRENT_INCARNATION",t."DBID",t."DBINC_KEY",t."DB_KEY",t."DB_RESETLOGS_SCN",t."DB_RESETLOGS_TIME",t."END_RESETLOGS_SCN",t."GUID",t."INCARNATION_SCN",t."NAME",t."PDBINC_KEY",t."PDB_KEY",t."PRIOR_BEGIN_RESETLOGS_SCN",t."PRIOR_BEGIN_RESETLOGS_TIME",t."PRIOR_DBINC_KEY",t."PRIOR_DB_RESETLOGS_SCN",t."PRIOR_DB_RESETLOGS_TIME",t."PRIOR_END_RESETLOGS_SCN",t."PRIOR_INCARNATION_SCN",t."PRIOR_PDBINC_KEY",t."STATUS" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_PLUGGABLE_DATABASE_INC/ROW' passing x.xmldoc columns "BEGIN_RESETLOGS_SCN" NUMBER path 'BEGIN_RESETLOGS_SCN',"BEGIN_RESETLOGS_TIME" CHAR(24) path 'BEGIN_RESETLOGS_TIME',"CON_ID" NUMBER path 'CON_ID',"CREATE_SCN" NUMBER path 'CREATE_SCN',"CURRENT_INCARNATION" VARCHAR2(3) path 'CURRENT_INCARNATION',"DBID" NUMBER path 'DBID',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_RESETLOGS_SCN" NUMBER path 'DB_RESETLOGS_SCN',"DB_RESETLOGS_TIME" CHAR(24) path 'DB_RESETLOGS_TIME',"END_RESETLOGS_SCN" NUMBER path 'END_RESETLOGS_SCN',"GUID" RAW(16) path 'GUID',"INCARNATION_SCN" NUMBER path 'INCARNATION_SCN',"NAME" VARCHAR2(128) path 'NAME',"PDBINC_KEY" NUMBER path 'PDBINC_KEY',"PDB_KEY" NUMBER path 'PDB_KEY',"PRIOR_BEGIN_RESETLOGS_SCN" NUMBER path 'PRIOR_BEGIN_RESETLOGS_SCN',"PRIOR_BEGIN_RESETLOGS_TIME" CHAR(24) path 'PRIOR_BEGIN_RESETLOGS_TIME',"PRIOR_DBINC_KEY" NUMBER path 'PRIOR_DBINC_KEY',"PRIOR_DB_RESETLOGS_SCN" NUMBER path 'PRIOR_DB_RESETLOGS_SCN',"PRIOR_DB_RESETLOGS_TIME" CHAR(24) path 'PRIOR_DB_RESETLOGS_TIME',"PRIOR_END_RESETLOGS_SCN" NUMBER path 'PRIOR_END_RESETLOGS_SCN',"PRIOR_INCARNATION_SCN" NUMBER path 'PRIOR_INCARNATION_SCN',"PRIOR_PDBINC_KEY" NUMBER path 'PRIOR_PDBINC_KEY',"STATUS" VARCHAR2(8) path 'STATUS') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_RCVER_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_RCVER_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "VERSION") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."VERSION" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_RCVER/ROW' passing x.xmldoc columns "VERSION" VARCHAR2(12) path 'VERSION') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_REDO_LOG_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_REDO_LOG_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BYTES", "DBINC_KEY", "DB_KEY", "DB_NAME", "GROUP#", "NAME", "SITE_KEY", "THREAD#", "TYPE") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BYTES",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."GROUP#",t."NAME",t."SITE_KEY",t."THREAD#",t."TYPE" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_REDO_LOG/ROW' passing x.xmldoc columns "BYTES" NUMBER path 'BYTES',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"GROUP#" NUMBER path 'GROUP_x0023_',"NAME" VARCHAR2(1024) path 'NAME',"SITE_KEY" NUMBER path 'SITE_KEY',"THREAD#" NUMBER path 'THREAD_x0023_',"TYPE" VARCHAR2(7) path 'TYPE') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_REDO_THREAD_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_REDO_THREAD_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "DBINC_KEY", "DB_KEY", "DB_NAME", "DISABLE_CHANGE#", "DISABLE_TIME", "ENABLE_CHANGE#", "ENABLE_TIME", "SEQUENCE#", "STATUS", "THREAD#") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."DISABLE_CHANGE#",t."DISABLE_TIME",t."ENABLE_CHANGE#",t."ENABLE_TIME",t."SEQUENCE#",t."STATUS",t."THREAD#" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_REDO_THREAD/ROW' passing x.xmldoc columns "DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"DISABLE_CHANGE#" NUMBER path 'DISABLE_CHANGE_x0023_',"DISABLE_TIME" CHAR(24) path 'DISABLE_TIME',"ENABLE_CHANGE#" NUMBER path 'ENABLE_CHANGE_x0023_',"ENABLE_TIME" CHAR(24) path 'ENABLE_TIME',"SEQUENCE#" NUMBER path 'SEQUENCE_x0023_',"STATUS" VARCHAR2(1) path 'STATUS',"THREAD#" NUMBER path 'THREAD_x0023_') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_RMAN_CONFIGURATION_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_RMAN_CONFIGURATION_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "CONF#", "DB_KEY", "DB_UNIQUE_NAME", "NAME", "SITE_KEY", "VALUE") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."CONF#",t."DB_KEY",t."DB_UNIQUE_NAME",t."NAME",t."SITE_KEY",t."VALUE" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_RMAN_CONFIGURATION/ROW' passing x.xmldoc columns "CONF#" NUMBER path 'CONF_x0023_',"DB_KEY" NUMBER path 'DB_KEY',"DB_UNIQUE_NAME" VARCHAR2(512) path 'DB_UNIQUE_NAME',"NAME" VARCHAR2(65) path 'NAME',"SITE_KEY" NUMBER path 'SITE_KEY',"VALUE" VARCHAR2(1025) path 'VALUE') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_SITE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_SITE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BCR_IN_USE", "CF_CREATE_TIME", "CKP_SCN", "DATABASE_ROLE", "DBINC_KEY", "DB_KEY", "DB_UNIQUE_NAME", "FORCE_RESYNC2CF", "FULL_CKP_CF_SEQ", "HIGH_AL_RECID", "HIGH_BCB_RECID", "HIGH_BCR_RECID", "HIGH_BDF_RECID", "HIGH_BP_RECID", "HIGH_BRL_RECID", "HIGH_BSF_RECID", "HIGH_BS_RECID", "HIGH_CCB_RECID", "HIGH_CDF_RECID", "HIGH_CONF_RECID", "HIGH_DF_RECID", "HIGH_DO_RECID", "HIGH_GRSP_RECID", "HIGH_IC_RECID", "HIGH_NRSP_RECID", "HIGH_OFFR_RECID", "HIGH_ORL_RECID", "HIGH_PC_RECID", "HIGH_PDB_RECID", "HIGH_PIC_RECID", "HIGH_RLH_RECID", "HIGH_ROUT_STAMP", "HIGH_RSR_RECID", "HIGH_RT_RECID", "HIGH_TF_RECID", "HIGH_TS_RECID", "INST_STARTUP_STAMP", "JOB_CKP_CF_SEQ", "LAST_KCCDIVTS", "LOW_BCR_RECID", "SITE_KEY") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BCR_IN_USE",t."CF_CREATE_TIME",t."CKP_SCN",t."DATABASE_ROLE",t."DBINC_KEY",t."DB_KEY",t."DB_UNIQUE_NAME",t."FORCE_RESYNC2CF",t."FULL_CKP_CF_SEQ",t."HIGH_AL_RECID",t."HIGH_BCB_RECID",t."HIGH_BCR_RECID",t."HIGH_BDF_RECID",t."HIGH_BP_RECID",t."HIGH_BRL_RECID",t."HIGH_BSF_RECID",t."HIGH_BS_RECID",t."HIGH_CCB_RECID",t."HIGH_CDF_RECID",t."HIGH_CONF_RECID",t."HIGH_DF_RECID",t."HIGH_DO_RECID",t."HIGH_GRSP_RECID",t."HIGH_IC_RECID",t."HIGH_NRSP_RECID",t."HIGH_OFFR_RECID",t."HIGH_ORL_RECID",t."HIGH_PC_RECID",t."HIGH_PDB_RECID",t."HIGH_PIC_RECID",t."HIGH_RLH_RECID",t."HIGH_ROUT_STAMP",t."HIGH_RSR_RECID",t."HIGH_RT_RECID",t."HIGH_TF_RECID",t."HIGH_TS_RECID",t."INST_STARTUP_STAMP",t."JOB_CKP_CF_SEQ",t."LAST_KCCDIVTS",t."LOW_BCR_RECID",t."SITE_KEY" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_SITE/ROW' passing x.xmldoc columns "BCR_IN_USE" VARCHAR2(3) path 'BCR_IN_USE',"CF_CREATE_TIME" CHAR(24) path 'CF_CREATE_TIME',"CKP_SCN" NUMBER path 'CKP_SCN',"DATABASE_ROLE" VARCHAR2(7) path 'DATABASE_ROLE',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_UNIQUE_NAME" VARCHAR2(120) path 'DB_UNIQUE_NAME',"FORCE_RESYNC2CF" VARCHAR2(3) path 'FORCE_RESYNC2CF',"FULL_CKP_CF_SEQ" NUMBER path 'FULL_CKP_CF_SEQ',"HIGH_AL_RECID" NUMBER path 'HIGH_AL_RECID',"HIGH_BCB_RECID" NUMBER path 'HIGH_BCB_RECID',"HIGH_BCR_RECID" NUMBER path 'HIGH_BCR_RECID',"HIGH_BDF_RECID" NUMBER path 'HIGH_BDF_RECID',"HIGH_BP_RECID" NUMBER path 'HIGH_BP_RECID',"HIGH_BRL_RECID" NUMBER path 'HIGH_BRL_RECID',"HIGH_BSF_RECID" NUMBER path 'HIGH_BSF_RECID',"HIGH_BS_RECID" NUMBER path 'HIGH_BS_RECID',"HIGH_CCB_RECID" NUMBER path 'HIGH_CCB_RECID',"HIGH_CDF_RECID" NUMBER path 'HIGH_CDF_RECID',"HIGH_CONF_RECID" NUMBER path 'HIGH_CONF_RECID',"HIGH_DF_RECID" NUMBER path 'HIGH_DF_RECID',"HIGH_DO_RECID" NUMBER path 'HIGH_DO_RECID',"HIGH_GRSP_RECID" NUMBER path 'HIGH_GRSP_RECID',"HIGH_IC_RECID" NUMBER path 'HIGH_IC_RECID',"HIGH_NRSP_RECID" NUMBER path 'HIGH_NRSP_RECID',"HIGH_OFFR_RECID" NUMBER path 'HIGH_OFFR_RECID',"HIGH_ORL_RECID" NUMBER path 'HIGH_ORL_RECID',"HIGH_PC_RECID" NUMBER path 'HIGH_PC_RECID',"HIGH_PDB_RECID" NUMBER path 'HIGH_PDB_RECID',"HIGH_PIC_RECID" NUMBER path 'HIGH_PIC_RECID',"HIGH_RLH_RECID" NUMBER path 'HIGH_RLH_RECID',"HIGH_ROUT_STAMP" NUMBER path 'HIGH_ROUT_STAMP',"HIGH_RSR_RECID" NUMBER path 'HIGH_RSR_RECID',"HIGH_RT_RECID" NUMBER path 'HIGH_RT_RECID',"HIGH_TF_RECID" NUMBER path 'HIGH_TF_RECID',"HIGH_TS_RECID" NUMBER path 'HIGH_TS_RECID',"INST_STARTUP_STAMP" NUMBER path 'INST_STARTUP_STAMP',"JOB_CKP_CF_SEQ" NUMBER path 'JOB_CKP_CF_SEQ',"LAST_KCCDIVTS" NUMBER path 'LAST_KCCDIVTS',"LOW_BCR_RECID" NUMBER path 'LOW_BCR_RECID',"SITE_KEY" NUMBER path 'SITE_KEY') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_TABLESPACE_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_TABLESPACE_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "BIGFILE", "CON_ID", "CREATION_CHANGE#", "CREATION_TIME", "DBINC_KEY", "DB_KEY", "DB_NAME", "DROP_CHANGE#", "DROP_TIME", "ENCRYPT_IN_BACKUP", "INCLUDED_IN_DATABASE_BACKUP", "NAME", "PDBINC_KEY", "PDB_KEY", "PDB_NAME", "PLUGIN_CHANGE#", "TEMPORARY", "TS#") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."BIGFILE",t."CON_ID",t."CREATION_CHANGE#",t."CREATION_TIME",t."DBINC_KEY",t."DB_KEY",t."DB_NAME",t."DROP_CHANGE#",t."DROP_TIME",t."ENCRYPT_IN_BACKUP",t."INCLUDED_IN_DATABASE_BACKUP",t."NAME",t."PDBINC_KEY",t."PDB_KEY",t."PDB_NAME",t."PLUGIN_CHANGE#",t."TEMPORARY",t."TS#" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_TABLESPACE/ROW' passing x.xmldoc columns "BIGFILE" VARCHAR2(3) path 'BIGFILE',"CON_ID" NUMBER path 'CON_ID',"CREATION_CHANGE#" NUMBER path 'CREATION_CHANGE_x0023_',"CREATION_TIME" CHAR(24) path 'CREATION_TIME',"DBINC_KEY" NUMBER path 'DBINC_KEY',"DB_KEY" NUMBER path 'DB_KEY',"DB_NAME" VARCHAR2(8) path 'DB_NAME',"DROP_CHANGE#" NUMBER path 'DROP_CHANGE_x0023_',"DROP_TIME" CHAR(24) path 'DROP_TIME',"ENCRYPT_IN_BACKUP" VARCHAR2(3) path 'ENCRYPT_IN_BACKUP',"INCLUDED_IN_DATABASE_BACKUP" VARCHAR2(3) path 'INCLUDED_IN_DATABASE_BACKUP',"NAME" VARCHAR2(30) path 'NAME',"PDBINC_KEY" NUMBER path 'PDBINC_KEY',"PDB_KEY" NUMBER path 'PDB_KEY',"PDB_NAME" VARCHAR2(128) path 'PDB_NAME',"PLUGIN_CHANGE#" NUMBER path 'PLUGIN_CHANGE_x0023_',"TEMPORARY" VARCHAR2(3) path 'TEMPORARY',"TS#" NUMBER path 'TS_x0023_') t
;
--------------------------------------------------------
--  DDL for View _RS_RC_WATERMARKS_
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "OPENACCESS"."_RS_RC_WATERMARKS_" ("RS_RCFILE_KEY", "RS_RCFILE_CREATION_TIME", "RS_RCFILE_NAME", "CF_VERSION_STAMP", "DB_KEY", "DB_UNIQUE_NAME", "HIGH_BP_RECID", "HIGH_DF_RECID", "HIGH_DO_KEY", "HIGH_OFFR_RECID", "HIGH_TF_RECID", "HIGH_TS_RECID", "RS_VERSION_STAMP") AS 
  select x.rcfile_key rs_rcfile_key, x.creation_time  rs_rcfile_creation_time, x.name rs_rcfile_name,t."CF_VERSION_STAMP",t."DB_KEY",t."DB_UNIQUE_NAME",t."HIGH_BP_RECID",t."HIGH_DF_RECID",t."HIGH_DO_KEY",t."HIGH_OFFR_RECID",t."HIGH_TF_RECID",t."HIGH_TS_RECID",t."RS_VERSION_STAMP" from rcfile x, xmltable('/ALL_TABLES/TABLE_RC_WATERMARKS/ROW' passing x.xmldoc columns "CF_VERSION_STAMP" CHAR(24) path 'CF_VERSION_STAMP',"DB_KEY" NUMBER path 'DB_KEY',"DB_UNIQUE_NAME" VARCHAR2(32) path 'DB_UNIQUE_NAME',"HIGH_BP_RECID" NUMBER path 'HIGH_BP_RECID',"HIGH_DF_RECID" NUMBER path 'HIGH_DF_RECID',"HIGH_DO_KEY" NUMBER path 'HIGH_DO_KEY',"HIGH_OFFR_RECID" NUMBER path 'HIGH_OFFR_RECID',"HIGH_TF_RECID" NUMBER path 'HIGH_TF_RECID',"HIGH_TS_RECID" NUMBER path 'HIGH_TS_RECID',"RS_VERSION_STAMP" CHAR(24) path 'RS_VERSION_STAMP') t
;
--------------------------------------------------------
--  DDL for Index ENGR_LDGR_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_LDGR_IDX3" ON "OPENACCESS"."F_ENERGY_LEDGER" ("F_ENERGY_SALE_ORDER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002445A_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002445A_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_16" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_SERVICE_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_COMPANY_SERVICE_IDX" ON "OPENACCESS"."M_COMPANY_SERVICE" ("COMP_SER_TYPE_CODE", "M_ORG_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 458752 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023EE7_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023EE7_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_15" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_LAPSED_BALANCE_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_EXS_LAPSED_BALANCE_IDX2" ON "OPENACCESS"."T_EXS_LAPSED_BALANCE" ("READING_MONTH", "READING_YEAR", "M_COMPANY_SERVICE_NUM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FFA8_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FFA8_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_02" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002006D_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002006D_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_04" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGR_ADJ_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_ADJ_IDX2" ON "OPENACCESS"."F_ENERGY_ADJUSTED_CHARGE" ("CHARGE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B25C_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B25C_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_18" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B3C7_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B3C7_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_20" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_ID_TABLEA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_ID_TABLEA_PK" ON "OPENACCESS"."T_GC_ID_TABLEA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GEN_NO_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GEN_NO_PK" ON "OPENACCESS"."R_METER_CHG_LIST" ("GENERATOR_NO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_MULTIADD_HEADER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_MULTIADD_HEADER_PK" ON "OPENACCESS"."T_ES_MULTIADD_HEADER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SERVICENO_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."SERVICENO_PK" ON "OPENACCESS"."NAME_CHANGE" ("SERVICENO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_CHGS_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_CHGS_IDX3" ON "OPENACCESS"."F_ENERGY_CHARGES" ("F_ENERGY_SALE_ORDER_ID", "M_COMPANY_SERVICE_ID", "CHARGE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GEN_STMT_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_GEN_STMT_IDX" ON "OPENACCESS"."T_GEN_STMT" ("STMT_YEAR", "STMT_MONTH", "M_COMPANY_METER_ID", "M_ORG_ID", "M_COMPANY_ID", "M_COMPANY_SERVICE_ID", "DISP_SERVICE_NUMBER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MC_MR_LINES_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMP_MC_MR_LINES_IDX1" ON "OPENACCESS"."IMP_MC_MR_LINES" ("IMP_MC_MR_HEADER_ID", "SERVICE_NO", "METER_NO", "MF") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 48234496 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_ORG_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_ORG_PK" ON "OPENACCESS"."M_ORG" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_SECTION_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_SECTION_PK" ON "OPENACCESS"."M_SECTION" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020864_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020864_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_08" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_GENERATOR_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_GENERATOR_IDX" ON "OPENACCESS"."M_GENERATOR" ("M_POWERPLANT_ID", "ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000204D9_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000204D9_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_07" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000204D9_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000204D9_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_07" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_LOSS_CALC_CHART_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_LOSS_CALC_CHART_PK" ON "OPENACCESS"."M_LOSS_CALC_CHART" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EWA_LINE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EWA_LINE_PK" ON "OPENACCESS"."T_EWA_LINE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_ENERGY_SALE_ORDER_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."F_ENERGY_SALE_ORDER_IDX1" ON "OPENACCESS"."F_ENERGY_SALE_ORDER" ("MONTH", "YEAR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index TMP_GEN_STMT_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."TMP_GEN_STMT_IDX" ON "OPENACCESS"."TMP_GEN_STMT" ("STMT_YEAR", "STMT_MONTH", "M_COMPANY_METER_ID", "M_ORG_ID", "M_COMPANY_ID", "M_COMPANY_SERVICE_ID", "DISP_SERVICE_NUMBER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_TRADE_RELATIONSHIP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_TRADE_RELATIONSHIP_PK" ON "OPENACCESS"."M_TRADE_RELATIONSHIP" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_USER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_USER_PK" ON "OPENACCESS"."M_USER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_CHGS_IDX4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_CHGS_IDX4" ON "OPENACCESS"."F_ENERGY_CHARGES" ("CHARGE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GEN_CHGS_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."GEN_CHGS_IDX2" ON "OPENACCESS"."T_GEN_STMT_CHARGE" ("CHARGE_TYPE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003C5F8_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003C5F8_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_22" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000203C1_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000203C1_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_05" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MRL_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMP_MRL_IDX2" ON "OPENACCESS"."IMP_MR_LINES" ("SERVICE_NO", "FINAL_READING_DT") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index T_CS_QUANTUM_ALLOCATION_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_CS_QUANTUM_ALLOCATION_PK" ON "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ADJ_UNIT_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ADJ_UNIT_IDX3" ON "OPENACCESS"."INT_ADJUSTED_UNIT" ("READING_YR", "READING_MNTH", "SERVICE_NO", "SUPLR_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023DF6_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023DF6_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_13" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023405_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023405_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_10" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_SURPLUS_STB_SRC_29_JUN_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EXS_SURPLUS_STB_SRC_29_JUN_IDX" ON "OPENACCESS"."T_EXS_SURPLUS_STB_SRC_29_JUN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_EMPLOYEE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_COMPANY_EMPLOYEE_PK" ON "OPENACCESS"."M_COMPANY_EMPLOYEE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002041D_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002041D_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_06" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000030BAC_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000030BAC_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_17" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_BANKING_BALANCE_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_EXS_BANKING_BALANCE_IDX2" ON "OPENACCESS"."T_EXS_BANKING_BALANCE" ("READING_MONTH", "READING_YEAR", "M_COMPANY_SERVICE_NUM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_AGREEMENT_LINE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_AGREEMENT_LINE_PK" ON "OPENACCESS"."F_AGREEMENT_LINE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_ENERGY_LEDGER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_ENERGY_LEDGER_PK" ON "OPENACCESS"."F_ENERGY_LEDGER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023751_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023751_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_12" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020864_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020864_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_08" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MR_LINES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMP_MR_LINES_PK" ON "OPENACCESS"."IMP_MR_LINES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023E7D_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023E7D_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_14" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023751_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023751_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_12" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B3C7_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B3C7_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_20" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_PROCESS_GS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_PROCESS_GS_PK" ON "OPENACCESS"."T_PROCESS_GS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FFA8_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FFA8_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_02" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMPORT_SELLERS_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMPORT_SELLERS_IDX" ON "OPENACCESS"."IMPORT_SELLERS" ("GENERATOR_SERVICE_NO_NEW") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020916_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020916_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_09" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ERROR_TABLE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."ERROR_TABLE_PK" ON "OPENACCESS"."ERROR_TABLE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020916_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020916_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_09" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_GENERATOR_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_GENERATOR_PK" ON "OPENACCESS"."M_GENERATOR" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_ORG_CODE_UN
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_ORG_CODE_UN" ON "OPENACCESS"."M_ORG" ("CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_PPA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_PPA_PK" ON "OPENACCESS"."T_PPA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index TMP_GEN_STMT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."TMP_GEN_STMT_PK" ON "OPENACCESS"."TMP_GEN_STMT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 851968 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GEN_CHGS_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."GEN_CHGS_IDX1" ON "OPENACCESS"."T_GEN_STMT_CHARGE" ("T_GEN_STMT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023DF6_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023DF6_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_13" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_SERVICE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_SERVICE_PK" ON "OPENACCESS"."M_COMPANY_SERVICE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 458752 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023EE7_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023EE7_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_15" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020916_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020916_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_09" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_SIGNUP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_SIGNUP_PK" ON "OPENACCESS"."M_SIGNUP" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_FEATURE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_FEATURE_PK" ON "OPENACCESS"."AUTH_FEATURE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FF43_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FF43_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_01" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B25C_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B25C_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_18" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_NOC_GENERATOR_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_NOC_GENERATOR_PK" ON "OPENACCESS"."T_NOC_GENERATOR" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_POWERPLANT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_POWERPLANT_PK" ON "OPENACCESS"."M_POWERPLANT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023E7D_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023E7D_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_14" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_CHGS_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_CHGS_IDX2" ON "OPENACCESS"."F_ENERGY_CHARGES" ("F_ENERGY_SALE_ORDER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_BANK_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_BANK_PK" ON "OPENACCESS"."M_BANK" ("BANK_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023DF6_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023DF6_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_13" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_LOV_DETAIL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_LOV_DETAIL_PK" ON "OPENACCESS"."M_LOV_DETAIL" ("CODE", "M_LOV_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MR_LINES_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMP_MR_LINES_IDX" ON "OPENACCESS"."IMP_MR_LINES" ("IMP_MR_HEADER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_BANKING_ACTIVITY_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_BANKING_ACTIVITY_IDX" ON "OPENACCESS"."T_BANKING_ACTIVITY" ("T_ENERGY_SALE_ID", "T_BANKING_BAL_ID", "ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023751_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023751_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_12" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_COMPANY_NAME_CHANGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_COMPANY_NAME_CHANGE_PK" ON "OPENACCESS"."T_COMPANY_NAME_CHANGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_SURPLUS_STB_BALANCE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE_PK" ON "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EWA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EWA_PK" ON "OPENACCESS"."T_EWA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B3C7_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B3C7_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_20" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index DOCINFO_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."DOCINFO_IDX" ON "OPENACCESS"."DOC_INFO" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_GEN_UNIT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_GEN_UNIT_PK" ON "OPENACCESS"."T_GC_GEN_UNIT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FF43_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FF43_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_01" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_PROCESS_LOG_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_PROCESS_LOG_PK" ON "OPENACCESS"."T_PROCESS_LOG" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ENERGY_SALE_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_ENERGY_SALE_IDX" ON "OPENACCESS"."T_ENERGY_SALE" ("SELLER_END_ORG_ID", "MONTH", "YEAR", "SELLER_COMP_SERV_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ADJ_UNIT_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ADJ_UNIT_IDX1" ON "OPENACCESS"."INT_ADJUSTED_UNIT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GEN_STMT_SLOT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_GEN_STMT_SLOT_PK" ON "OPENACCESS"."T_GEN_STMT_SLOT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002006D_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002006D_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_04" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_APPLICATION_STATUS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_APPLICATION_STATUS_PK" ON "OPENACCESS"."T_GC_APPLICATION_STATUS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index DOC_BATCH_FORGS
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."DOC_BATCH_FORGS" ON "OPENACCESS"."DOC_INFO" ("BATCH_KEY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023EE7_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023EE7_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_15" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003BE3A_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003BE3A_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_21" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B35F_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B35F_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_19" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_BANKING_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_BANKING_PK" ON "OPENACCESS"."T_BANKING_BALANCE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_BANKING_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_BANKING_IDX2" ON "OPENACCESS"."T_BANKING_BALANCE" ("MONTH", "YEAR", "M_COMPANY_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003BE3A_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003BE3A_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_21" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B35F_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B35F_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_19" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ACTIVITY_LOG_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ACTIVITY_LOG_PK" ON "OPENACCESS"."T_ACTIVITY_LOG" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_TRADE_RELATIONSHIP_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_TRADE_RELATIONSHIP_IDX" ON "OPENACCESS"."M_TRADE_RELATIONSHIP" ("M_SELLER_COMPANY_ID", "M_SELLER_COMP_SERVICE_ID", "M_BUYER_COMPANY_ID", "M_BUYER_COMP_SERVICE_ID", "ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 3145728 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002000E_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002000E_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_03" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023EE7_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023EE7_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_15" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GEN_OTHER_CHARGES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_GEN_OTHER_CHARGES_PK" ON "OPENACCESS"."T_GEN_OTHER_CHARGES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B25C_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B25C_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_18" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GEN_STMT_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."GEN_STMT_IDX1" ON "OPENACCESS"."T_GEN_STMT_SLOT" ("SLOT_CODE", "T_GEN_STMT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGR_ADJ_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_ADJ_IDX3" ON "OPENACCESS"."F_ENERGY_ADJUSTED_CHARGE" ("F_ENERGY_ADJUSTED_ID", "CHARGE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_EXCESS_UNIT_TYPE_OVERRIDE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_EXCESS_UNIT_TYPE_OVERRIDE_PK" ON "OPENACCESS"."M_EXCESS_UNIT_TYPE_OVERRIDE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FFA8_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FFA8_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_02" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_PAYMENTS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_PAYMENTS_PK" ON "OPENACCESS"."T_PAYMENT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index DB_U1
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."DB_U1" ON "OPENACCESS"."DB" ("DB_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MC_MR_LINES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMP_MC_MR_LINES_PK" ON "OPENACCESS"."IMP_MC_MR_LINES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000030BAC_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000030BAC_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_17" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023751_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023751_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_12" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MC_MR_LINES_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMP_MC_MR_LINES_IDX" ON "OPENACCESS"."IMP_MC_MR_LINES" ("IMP_MC_MR_HEADER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 31457280 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000203C1_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000203C1_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_05" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_LOCATION_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_COMPANY_LOCATION_PK" ON "OPENACCESS"."M_COMPANY_LOCATION" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_CHANGE_FROM_AMR_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_METER_CHANGE_FROM_AMR_PK" ON "OPENACCESS"."R_METER_CHANGE_FROM_AMR" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B3C7_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B3C7_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_20" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GEN_STMT_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_GEN_STMT_IDX2" ON "OPENACCESS"."T_GEN_STMT" ("STMT_MONTH", "STMT_YEAR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_SUBSTATION_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_SUBSTATION_PK" ON "OPENACCESS"."M_SUBSTATION" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_POWERPLANT_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_POWERPLANT_IDX" ON "OPENACCESS"."M_POWERPLANT" ("FUEL_TYPE_CODE", "M_SERVICE_ID", "M_ORG_ID", "CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 327680 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000236E9_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000236E9_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_11" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002445A_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002445A_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_16" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_BANKING_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_BANKING_IDX" ON "OPENACCESS"."T_BANKING_BALANCE" ("BANKING_SERVICE_ID", "M_COMPANY_ID", "ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002041D_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002041D_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_06" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GRID_CONN_APPLN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_GRID_CONN_APPLN_PK" ON "OPENACCESS"."T_GRID_CONN_APPLN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_USER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_USER_PK" ON "OPENACCESS"."AUTH_USER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_AMENDMENT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_AMENDMENT_PK" ON "OPENACCESS"."T_AMENDMENT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_USAGE_SUMMARY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_USAGE_SUMMARY_PK" ON "OPENACCESS"."T_ES_USAGE_SUMMARY" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_TYPE_ACCESS
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_TYPE_ACCESS" ON "OPENACCESS"."AUTH_USER_TYPE_ACCESS" ("TRANSACTION_TYPE_CODE", "USER_TYPE_CODE", "FUEL_GROUP_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002445A_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002445A_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_16" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_SALE_ORD_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_SALE_ORD_IDX1" ON "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" ("F_ENERGY_SALE_ORDER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_CS_LOAN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_CS_LOAN_PK" ON "OPENACCESS"."T_CS_LOAN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023E7D_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023E7D_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_14" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_SERVICE_UN
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_COMPANY_SERVICE_UN" ON "OPENACCESS"."M_COMPANY_SERVICE" ("COMP_SER_TYPE_CODE", "number", "M_COMPANY_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 851968 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index DBINC_P
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."DBINC_P" ON "OPENACCESS"."DBINC" ("DBINC_KEY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ENERGY_SALE_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_ENERGY_SALE_IDX1" ON "OPENACCESS"."T_ENERGY_SALE" ("T_GEN_STMT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ES_MULTIADD_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ES_MULTIADD_IDX1" ON "OPENACCESS"."T_ES_MULTIADD_LINE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_INPRINCIPLE_APPLN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_INPRINCIPLE_APPLN_PK" ON "OPENACCESS"."T_INPRINCIPLE_APPLN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B25C_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B25C_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_18" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023E7D_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023E7D_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_14" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GEN_STMT_CHARGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_GEN_STMT_CHARGE_PK" ON "OPENACCESS"."T_GEN_STMT_CHARGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ADJ_CHARGE_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ADJ_CHARGE_IDX2" ON "OPENACCESS"."INT_ADJUSTED_CHARGE" ("ENERGY_ADJUSTED_DATA_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_ID_TABLEB_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_ID_TABLEB_PK" ON "OPENACCESS"."T_GC_ID_TABLEB" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B3C7_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B3C7_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_20" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_CHARGE_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_ES_CHARGE_IDX2" ON "OPENACCESS"."T_ES_CHARGE" ("M_COMP_SERV_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023E7D_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023E7D_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_14" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EPA_LINES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EPA_LINES_PK" ON "OPENACCESS"."T_EPA_LINES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002006D_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002006D_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_04" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_CHARGE_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_ES_CHARGE_IDX" ON "OPENACCESS"."T_ES_CHARGE" ("T_ENERGY_SALE_ID", "M_COMP_SERV_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_ADJ_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_ADJ_IDX1" ON "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000236E9_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000236E9_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_11" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MDMS_HEADER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMP_MDMS_HEADER_PK" ON "OPENACCESS"."IMP_MR_HEADER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002006D_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002006D_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_04" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."AUTH_IDX1" ON "OPENACCESS"."AUTH_USER" ("TOKEN") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index DB_P
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."DB_P" ON "OPENACCESS"."DB" ("DB_KEY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000204D9_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000204D9_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_07" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_READING_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_METER_READING_IDX" ON "OPENACCESS"."T_METER_READING_HDR" ("M_COMPANY_METER_ID", "READING_MONTH", "READING_YEAR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_CONSENT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_CONSENT_PK" ON "OPENACCESS"."T_CONSENT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index PK_GEN_NO
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."PK_GEN_NO" ON "OPENACCESS"."R_TO_UPD_SEC" ("GEN_NO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002000E_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002000E_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_03" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index TMP_GEN_STMT_CHARGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."TMP_GEN_STMT_CHARGE_PK" ON "OPENACCESS"."TMP_GEN_STMT_CHARGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 5242880 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FFA8_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FFA8_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_02" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_LOAN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_LOAN_PK" ON "OPENACCESS"."T_GC_LOAN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_NOC_GENERATOR_LINE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_NOC_GENERATOR_LINE_PK" ON "OPENACCESS"."T_NOC_GENERATOR_LINE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000236E9_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000236E9_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_11" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FF43_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FF43_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_01" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_LAPSED_BALANCE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EXS_LAPSED_BALANCE_PK" ON "OPENACCESS"."T_EXS_LAPSED_BALANCE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003C5F8_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003C5F8_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_22" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ADJ_UNIT_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ADJ_UNIT_IDX2" ON "OPENACCESS"."INT_ADJUSTED_UNIT" ("BATCH_KEY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_CHARGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_CHARGE_PK" ON "OPENACCESS"."T_ES_CHARGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_OAA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_OAA_PK" ON "OPENACCESS"."T_OAA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002000E_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002000E_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_03" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002041D_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002041D_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_06" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMPORT_SELLERS_RECONCILIATION_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMPORT_SELLERS_RECONCILIATION_IDX1" ON "OPENACCESS"."IMPORT_SELLERS_RECONCILIATION" ("GENERATOR_SERVICE_NO_NEW") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020864_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020864_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_08" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FF43_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FF43_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_01" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000030BAC_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000030BAC_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_17" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FFA8_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FFA8_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_02" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_COMPANY_METER_CHANGE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_COMPANY_METER_CHANGE_PK" ON "OPENACCESS"."T_COMPANY_METER_CHANGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023405_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023405_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_10" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_INTENT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_INTENT_PK" ON "OPENACCESS"."T_ES_INTENT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_QUANTUM_ALLOCATION_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_QUANTUM_ALLOCATION_PK" ON "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_USER_FEATURE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_USER_FEATURE_PK" ON "OPENACCESS"."AUTH_USER_FEATURE" ("AUTH_ID", "AUTH_FEATURE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_READING_SLOT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_METER_READING_SLOT_PK" ON "OPENACCESS"."T_METER_READING_SLOT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020864_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020864_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_08" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B35F_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B35F_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_19" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_AGREEMENT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_AGREEMENT_PK" ON "OPENACCESS"."F_AGREEMENT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002041D_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002041D_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_06" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000030BAC_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000030BAC_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_17" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_INTENT_LINE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_INTENT_LINE_PK" ON "OPENACCESS"."T_ES_INTENT_LINE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_PK" ON "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_CHARGE_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_ES_CHARGE_IDX3" ON "OPENACCESS"."T_ES_CHARGE" ("CHARGE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_NOC_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_NOC_PK" ON "OPENACCESS"."T_NOC" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000203C1_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000203C1_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_05" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_READING_SLOT_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_METER_READING_SLOT_IDX3" ON "OPENACCESS"."T_METER_READING_SLOT" ("T_METER_READING_HDR_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_ENERGY_CHARGES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_ENERGY_CHARGES_PK" ON "OPENACCESS"."F_ENERGY_CHARGES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000203C1_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000203C1_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_05" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002041D_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002041D_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_06" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_SALE_ORD_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_SALE_ORD_IDX2" ON "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" ("T_ENERGY_SALE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003BE3A_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003BE3A_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_21" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_USER_TYPE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_USER_TYPE_PK" ON "OPENACCESS"."AUTH_USER_TYPE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index TMP_GEN_STMT_SLOT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."TMP_GEN_STMT_SLOT_PK" ON "OPENACCESS"."TMP_GEN_STMT_SLOT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 4194304 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_IS_INTERNAL_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_COMPANY_IS_INTERNAL_IDX" ON "OPENACCESS"."M_COMPANY" ("IS_INTERNAL", "ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 720896 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_ENERGY_SALE_ORDER_LINES_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES_PK" ON "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002000E_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002000E_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_03" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002445A_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002445A_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_16" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003C5F8_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003C5F8_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_22" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_CS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_CS_PK" ON "OPENACCESS"."T_CS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_READING_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_METER_READING_PK" ON "OPENACCESS"."T_METER_READING_HDR" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B35F_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B35F_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_19" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ENERGY_SALE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ENERGY_SALE_PK" ON "OPENACCESS"."T_ENERGY_SALE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_USAGE_DETAIL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_ES_USAGE_DETAIL_PK" ON "OPENACCESS"."T_ES_USAGE_DETAIL" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000203C1_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000203C1_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_05" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MR_LINES_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."IMP_MR_LINES_IDX1" ON "OPENACCESS"."IMP_MR_LINES" ("IMP_MR_HEADER_ID", "SERVICE_NO", "METER_NO", "MF") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGR_LDGR_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_LDGR_IDX2" ON "OPENACCESS"."F_ENERGY_LEDGER" ("D_COMP_SERV_NUMBER", "MONTH", "YEAR", "SERVICE_TYPE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003BE3A_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003BE3A_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_21" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_TOKEN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_TOKEN_PK" ON "OPENACCESS"."AUTH_TOKEN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_SIGNUP_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_SIGNUP_IDX" ON "OPENACCESS"."M_SIGNUP" ("PURPOSE", "FUEL", "HTSC_NUMBER_OLD", "COMPANY_NAME", "M_ORG_ID", "M_SUBSTATION_ID", "M_FEEDER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 589824 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_CS_ID_TABLEB_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_CS_ID_TABLEB_PK" ON "OPENACCESS"."T_CS_ID_TABLEB" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_ADJ_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_ADJ_IDX2" ON "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" ("READING_MNTH", "READING_YR", "SUPLR_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGR_LDGR_IDX5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_LDGR_IDX5" ON "OPENACCESS"."F_ENERGY_LEDGER" ("MONTH", "YEAR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_SURPLUS_STB_BALANCE_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE_IDX2" ON "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" ("READING_MONTH", "READING_YEAR", "M_COMPANY_SERVICE_NUM") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_USER_TYPE_MAP_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."AUTH_USER_TYPE_MAP_IDX" ON "OPENACCESS"."AUTH_USER_TYPE_MAP" ("AUTH_USER_TYPE_CODE", "AUTH_FEATURE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_METER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_COMPANY_METER_PK" ON "OPENACCESS"."M_COMPANY_METER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_FEEDER_INDEX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_FEEDER_INDEX" ON "OPENACCESS"."M_FEEDER" ("NAME", "VOLTAGE", "M_SUBSTATION_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 393216 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_BANKING_BALANCE_SRC_29_JUN_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EXS_BANKING_BALANCE_SRC_29_JUN_IDX" ON "OPENACCESS"."T_EXS_BANKING_BALANCE_SRC_29_JUN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_CS_ID_TABLEA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_CS_ID_TABLEA_PK" ON "OPENACCESS"."T_CS_ID_TABLEA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_CHECKLIST_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_CHECKLIST_PK" ON "OPENACCESS"."T_GC_CHECKLIST" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002006D_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002006D_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_04" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023751_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023751_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_12" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_READING_SLOT_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_METER_READING_SLOT_IDX" ON "OPENACCESS"."T_METER_READING_SLOT" ("ID", "T_METER_READING_HDR_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B35F_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B35F_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_19" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_ES_USAGE_SUMMARY_IDX
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_ES_USAGE_SUMMARY_IDX" ON "OPENACCESS"."T_ES_USAGE_SUMMARY" ("T_ENERGY_SALE_ID", "BUYER_END_ORG_ID", "BUYER_COMP_SERV_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023DF6_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023DF6_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_13" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_CHGS_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_CHGS_IDX1" ON "OPENACCESS"."F_ENERGY_CHARGES" ("M_COMPANY_SERVICE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GEN_STMT_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."GEN_STMT_IDX2" ON "OPENACCESS"."T_GEN_STMT_SLOT" ("T_GEN_STMT_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_COMPANY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_COMPANY_PK" ON "OPENACCESS"."M_COMPANY" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 655360 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023405_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023405_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_10" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000030BAC_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000030BAC_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_17" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003B25C_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003B25C_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_18" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020916_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020916_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_09" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index GC_TRANSFORMERS_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."GC_TRANSFORMERS_PK" ON "OPENACCESS"."T_GC_TRANSFORMERS" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_TARIFF_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_TARIFF_PK" ON "OPENACCESS"."M_TARIFF" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023DF6_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023DF6_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_13" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MC_MR_HEADER_CODE_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMP_MC_MR_HEADER_CODE_IDX" ON "OPENACCESS"."IMP_MC_MR_HEADER" ("MR_SOURCE_CODE", "CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023405_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023405_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_10" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ADJ_CHARGE_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ADJ_CHARGE_IDX1" ON "OPENACCESS"."INT_ADJUSTED_CHARGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMPORT_CONTACT_INFO_UK1
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMPORT_CONTACT_INFO_UK1" ON "OPENACCESS"."IMPORT_CONTACT_INFO" ("number") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000236E9_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000236E9_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_11" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EPA_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EPA_PK" ON "OPENACCESS"."T_EPA" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000204D9_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000204D9_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_07" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000204D9_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000204D9_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_07" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_STANDING_CLEARENCE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_STANDING_CLEARENCE_PK" ON "OPENACCESS"."T_STANDING_CLEARENCE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index DBINC_U1
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."DBINC_U1" ON "OPENACCESS"."DBINC" ("DB_KEY", "RESET_SCN", "RESET_TIME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003C5F8_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003C5F8_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_22" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_SIGNUP_TRADE_REL_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_SIGNUP_TRADE_REL_PK" ON "OPENACCESS"."M_SIGNUP_TRADE_REL" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002445A_IND_2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002445A_IND_2" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_16" ("OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "PARTITION_NAME", "SUBPARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_NEW_SERVICE_EXCESS_BANKING_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_NEW_SERVICE_EXCESS_BANKING_PK" ON "OPENACCESS"."T_NEW_SERVICE_EXCESS_BANKING" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 720896 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_IEX_NOC_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_IEX_NOC_PK" ON "OPENACCESS"."T_IEX_NOC" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MR_HEADER_CODE_IDX
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMP_MR_HEADER_CODE_IDX" ON "OPENACCESS"."IMP_MR_HEADER" ("MR_SOURCE_CODE", "CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003BE3A_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003BE3A_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_21" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_CHARGE_DEFN_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_CHARGE_DEFN_PK" ON "OPENACCESS"."M_CHARGE_DEFN" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index TEMP_REFRESH_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."TEMP_REFRESH_IDX1" ON "OPENACCESS"."TEMP_V_COMP_REFRESH" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_0000236E9_IND_4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_0000236E9_IND_4" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_11" ("ORIGINAL_OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "PARTITION_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00002000E_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00002000E_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_03" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_GEN_STMT_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_GEN_STMT_PK" ON "OPENACCESS"."T_GEN_STMT" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_FEEDER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_FEEDER_PK" ON "OPENACCESS"."M_FEEDER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index IMP_MC_MR_HEADER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."IMP_MC_MR_HEADER_PK" ON "OPENACCESS"."IMP_MC_MR_HEADER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_ADJ_IDX4
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_ADJ_IDX4" ON "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" ("BATCH_KEY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS NOLOGGING 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index M_SIGNUP_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."M_SIGNUP_IDX1" ON "OPENACCESS"."M_SIGNUP" ("PURPOSE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index FINANCIAL_UNUTILIZED_BANKING_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."FINANCIAL_UNUTILIZED_BANKING_PK" ON "OPENACCESS"."FINANCIAL_UNUTILIZED_BANKING" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 40960 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023EE7_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023EE7_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_15" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_EXS_BANKING_BALANCE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_EXS_BANKING_BALANCE_PK" ON "OPENACCESS"."T_EXS_BANKING_BALANCE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_BANKING_ACTIVITY_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_BANKING_ACTIVITY_PK" ON "OPENACCESS"."T_BANKING_ACTIVITY" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGR_LDGR_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_LDGR_IDX1" ON "OPENACCESS"."F_ENERGY_LEDGER" ("SERVICE_TYPE_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00003C5F8_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00003C5F8_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_22" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGR_ADJ_IDX1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGR_ADJ_IDX1" ON "OPENACCESS"."F_ENERGY_ADJUSTED_CHARGE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_CHARGES_MAP_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_CHARGES_MAP_PK" ON "OPENACCESS"."M_CHARGES_MAP" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index M_LOV_HEADER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."M_LOV_HEADER_PK" ON "OPENACCESS"."M_LOV_HEADER" ("CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_IPA_STANDING_CLEARACE
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_IPA_STANDING_CLEARACE" ON "OPENACCESS"."T_IPA_STANDING_CLEARACE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000023405_IND_3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000023405_IND_3" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_10" ("BASE_PROCESS_ORDER") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_00001FF43_IND_1
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_00001FF43_IND_1" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_01" ("OBJECT_SCHEMA", "ORIGINAL_OBJECT_NAME", "OBJECT_TYPE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020864_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020864_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_08" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index AUTH_USR_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."AUTH_USR_UK" ON "OPENACCESS"."AUTH_USER" ("USER_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_ENERGY_SALE_ORDER_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_ENERGY_SALE_ORDER_PK" ON "OPENACCESS"."F_ENERGY_SALE_ORDER" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index ENGY_ADJ_IDX3
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."ENGY_ADJ_IDX3" ON "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" ("READING_YR", "SUPLR_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_INPRINCIPLE_APPLN_LINE_PK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE_PK" ON "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" ("ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index F_ENERGY_SALE_ORDER_UK
--------------------------------------------------------

  CREATE UNIQUE INDEX "OPENACCESS"."F_ENERGY_SALE_ORDER_UK" ON "OPENACCESS"."F_ENERGY_SALE_ORDER" ("T_ENERGY_SALE_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index T_METER_READING_SLOT_IDX2
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."T_METER_READING_SLOT_IDX2" ON "OPENACCESS"."T_METER_READING_SLOT" ("T_METER_READING_HDR_ID", "SLOT_CODE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Index SYS_MTABLE_000020916_IND_5
--------------------------------------------------------

  CREATE INDEX "OPENACCESS"."SYS_MTABLE_000020916_IND_5" ON "OPENACCESS"."SYS_EXPORT_SCHEMA_09" ("SEED") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" ;
--------------------------------------------------------
--  DDL for Trigger DB_INSERT_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."DB_INSERT_TRIGGER" before insert on db for each row
declare
  is_owner number;
  is_auth  number;
  can_add  number;
begin
 
--
--
--
--
 
  select count(*) into is_owner from user_users where username=user;
  if is_owner > 0 then return; end if;
 
  select count(*) into is_auth from vpc_databases
    where filter_uid = uid and db_id <> 0 and db_id = :new.db_id;
  if is_auth > 0 then return; end if;
 
  update vpc_databases set db_id = :new.db_id, reg_db_unique_name = null
    where filter_uid = uid 
      and db_id = 0
      and reg_db_unique_name = :new.reg_db_unique_name;
  if sql%rowcount = 1 then
    return; 
  end if;
 
  select count(*) into can_add from vpc_users
    where filter_uid = uid and add_new_db = 'Y';
 
  if can_add = 0 then
    raise_application_error(num => -20012,
                            msg => 'not authorized to add new database');
  end if;
 
--
--
--
--
--
 
  insert into vpc_databases(filter_user, filter_uid, db_id)
     values(user, uid, :new.db_id);
 
end;
/
ALTER TRIGGER "OPENACCESS"."DB_INSERT_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_BANKING_BALANCE_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."T_BANKING_BALANCE_TRIGGER" 
  after insert or update or delete on t_banking_balance
  
    for each row 
declare
      v_operation varchar2(20);
      v_id varchar2(100 byte);
      v_m_company_id varchar2(100 byte);
      v_banking_service_id varchar2(100 byte);
      v_c1  varchar2(100 byte);
      v_c2  varchar2(100 byte);
      v_c3  varchar2(100 byte);
      v_c4  varchar2(100 byte);
      v_c5  varchar2(100 byte);
      v_remarks  varchar2(100 byte);
      v_created_by  varchar2(100 byte);
      v_created_dt  date;
      v_modified_by  varchar2(100 byte);
      v_modified_dt  date;
      v_created_date  date;
      v_enabled  varchar2(100 byte);
      v_month  varchar2(100 byte);
      v_year  varchar2(100 byte);
      v_curr_c1  varchar2(100 byte);
      v_curr_c2  varchar2(100 byte);
      v_curr_c3  varchar2(100 byte);
      v_curr_c4  varchar2(100 byte);
      v_curr_c5  varchar2(100 byte);
      v_calculated  varchar2(100 byte);
      v_surplus_c1 varchar(100 byte);
      v_surplus_c2 varchar(100 byte);
      v_surplus_c3 varchar(100 byte);
      v_surplus_c4 varchar(100 byte);
      v_surplus_c5 varchar(100 byte);

      

      v_old_id varchar2(100 byte);
      v_old_m_company_id varchar2(100 byte);
      v_old_banking_service_id varchar2(100 byte);
      v_old_c1  varchar2(100 byte);
      v_old_c2  varchar2(100 byte);
      v_old_c3  varchar2(100 byte);
      v_old_c4  varchar2(100 byte);
      v_old_c5  varchar2(100 byte);
      v_old_remarks  varchar2(100 byte);
      v_old_created_by  varchar2(100 byte);
      v_old_created_dt  date;
      v_old_modified_by  varchar2(100 byte);
      v_old_modified_dt  date;
      v_old_created_date  date;
      v_old_enabled  varchar2(100 byte);
      v_old_month  varchar2(100 byte);
      v_old_year  varchar2(100 byte);
      v_old_curr_c1  varchar2(100 byte);
      v_old_curr_c2  varchar2(100 byte);
      v_old_curr_c3  varchar2(100 byte);
      v_old_curr_c4  varchar2(100 byte);
      v_old_curr_c5  varchar2(100 byte);
      v_old_calculated  varchar2(100 byte);
      v_old_surplus_c1 varchar2(100 byte);
      v_old_surplus_c2 varchar2(100 byte);
      v_old_surplus_c3 varchar2(100 byte);
      v_old_surplus_c4 varchar2(100 byte);
      v_old_surplus_c5 varchar2(100 byte);



begin
      v_id:= :new.id;
      v_m_company_id:= :new.m_company_id;
      v_banking_service_id:= :new.banking_service_id;
      v_c1  := :new.c1 ;
      v_c2  := :new.c2 ;
      v_c3  := :new.c3 ;
      v_c4  := :new.c4 ;
      v_c5  := :new.c5;
      v_remarks  := :new.remarks ;
      v_created_by  := :new.created_by;
      v_created_dt  := :new.created_dt;
      v_modified_by  := :new.modified_by ;
      v_modified_dt  := :new.modified_dt;
      v_created_date := :new.created_date;
      v_enabled  := :new.enabled ;
      v_month  := :new.month ;
      v_year  := :new.year ;
      v_curr_c1  := :new.curr_c1 ;
      v_curr_c2  := :new.curr_c2 ;
      v_curr_c3  := :new.curr_c3 ;
      v_curr_c4  := :new.curr_c4 ;
      v_curr_c5  := :new.curr_c5 ;
      v_calculated  := :new.calculated ;
      v_surplus_c1 := :new.surplus_c1 ;
      v_surplus_c2 := :new.surplus_c2 ;
      v_surplus_c3 := :new.surplus_c3 ;
      v_surplus_c4 := :new.surplus_c4 ;
      v_surplus_c5 := :new.surplus_c5 ;


        if inserting then 

          v_operation:='INSERT';

        end if;

        if updating then 

              v_old_id:= :old.id;
              v_old_m_company_id:= :old.m_company_id;
              v_old_banking_service_id:= :old.banking_service_id;
              v_old_c1  := :old.c1 ;
              v_old_c2  := :old.c2 ;
              v_old_c3  := :old.c3 ;
              v_old_c4  := :old.c4 ;
              v_old_c5  := :old.c5;
              v_old_remarks  := :old.remarks ;
              v_old_created_by  := :old.created_by;
              v_old_created_dt  := :old.created_dt;
              v_old_modified_by  := :old.modified_by ;
              v_old_modified_dt  := :old.modified_dt;
              v_old_created_date := :old.created_date;
              v_old_enabled  := :old.enabled ;
              v_old_month  := :old.month ;
              v_old_year  := :old.year ;
              v_old_curr_c1  := :old.curr_c1 ;
              v_old_curr_c2  := :old.curr_c2 ;
              v_old_curr_c3  := :old.curr_c3 ;
              v_old_curr_c4  := :old.curr_c4 ;
              v_old_curr_c5  := :old.curr_c5 ;
              v_old_calculated  := :old.calculated ;
              v_old_surplus_c1 := :old.surplus_c1 ;
              v_old_surplus_c2 := :old.surplus_c2 ;
              v_old_surplus_c3 := :old.surplus_c3 ;
              v_old_surplus_c4 := :old.surplus_c4 ;
              v_old_surplus_c5 := :old.surplus_c5 ;

              v_operation:='AFTER-UPDATE';

             insert into t_banking_balance_history(id,m_company_id,banking_service_id,c1,c2,c3,c4,c5,remarks,created_by,created_dt,modified_by,modified_dt,created_date,enabled,month,year,curr_c1,curr_c2,curr_c3,curr_c4,curr_c5,calculated,created_timestamp,action) values 
            (v_old_id,v_old_m_company_id,v_old_banking_service_id,v_old_c1,v_old_c2,v_old_c3,v_old_c4,v_old_c5,v_old_remarks,v_old_created_by,v_old_created_dt,v_old_modified_by,v_old_modified_dt,v_old_created_date,v_old_enabled,v_old_month,v_old_year,v_old_curr_c1,v_old_curr_c2,v_old_curr_c3,v_old_curr_c4,v_old_curr_c5,v_old_calculated,systimestamp at time zone 'asia/kolkata','BEFORE-UPDATE');


        end if; 

        if deleting then 
          v_id:= :old.id;
          v_m_company_id:= :old.m_company_id;
          v_banking_service_id:= :old.banking_service_id;
          v_c1  := :old.c1 ;
          v_c2  := :old.c2 ;
          v_c3  := :old.c3 ;
          v_c4  := :old.c4 ;
          v_c5  := :old.c5;
          v_remarks  := :old.remarks ;
          v_created_by  := :old.created_by;
          v_created_dt  := :old.created_dt;
          v_modified_by  := :old.modified_by ;
          v_modified_dt  := :old.modified_dt;
          v_created_date := :old.created_date;
          v_enabled  := :old.enabled ;
          v_month  := :old.month ;
          v_year  := :old.year ;
          v_curr_c1  := :old.curr_c1 ;
          v_curr_c2  := :old.curr_c2 ;
          v_curr_c3  := :old.curr_c3 ;
          v_curr_c4  := :old.curr_c4 ;
          v_curr_c5  := :old.curr_c5 ;
          v_calculated  := :old.calculated ;
          v_surplus_c1 := :old.surplus_c1 ;
          v_surplus_c2 := :old.surplus_c2 ;
          v_surplus_c3 := :old.surplus_c3 ;
          v_surplus_c4 := :old.surplus_c4 ;
          v_surplus_c5 := :old.surplus_c5 ;
          v_operation:='DELETE';
        end if;

        insert into t_banking_balance_history(id,m_company_id,banking_service_id,c1,c2,c3,c4,c5,remarks,created_by,created_dt,modified_by,modified_dt,created_date,enabled,month,year,curr_c1,curr_c2,curr_c3,curr_c4,curr_c5,calculated,created_timestamp,action) values 
        (v_id,v_m_company_id,v_banking_service_id,v_c1,v_c2,v_c3,v_c4,v_c5,v_remarks,v_created_by,v_created_dt,v_modified_by,v_modified_dt,v_created_date,v_enabled,v_month,v_year,v_curr_c1,v_curr_c2,v_curr_c3,v_curr_c4,v_curr_c5,v_calculated,systimestamp at time zone 'asia/kolkata',v_operation);


end;
/
ALTER TRIGGER "OPENACCESS"."T_BANKING_BALANCE_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_EXS_BANKING_BALANCE_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."T_EXS_BANKING_BALANCE_TRIGGER" 
BEFORE INSERT OR UPDATE ON T_EXS_BANKING_BALANCE 
for each row 
BEGIN 
    -- update all totals
    :new.OPEN_TOTAL_UNITS :=  ROUND(NVL(:new.OPEN_C1,0),5)+ROUND(NVL(:new.OPEN_C2,0),5)+ROUND(NVL(:new.OPEN_C3,0),5)+ROUND(NVL(:new.OPEN_C4,0),5)+ROUND(NVL(:new.OPEN_C5,0),5);
    :new.INCR_EA1_TOTAL_UNITS :=  ROUND(NVL(:new.INCR_EA1_C1,0),5)+ROUND(NVL(:new.INCR_EA1_C2,0),5)+ROUND(NVL(:new.INCR_EA1_C3,0),5)+ROUND(NVL(:new.INCR_EA1_C4,0),5)+ROUND(NVL(:new.INCR_EA1_C5,0),5);
    :new.DECR_EA1_TOTAL_UNITS :=  ROUND(NVL(:new.DECR_EA1_C1,0),5)+ROUND(NVL(:new.DECR_EA1_C2,0),5)+ROUND(NVL(:new.DECR_EA1_C3,0),5)+ROUND(NVL(:new.DECR_EA1_C4,0),5)+ROUND(NVL(:new.DECR_EA1_C5,0),5);
    :new.INCR_HT_TOTAL_UNITS :=  ROUND(NVL(:new.INCR_HT_C1,0),5)+ROUND(NVL(:new.INCR_HT_C2,0),5)+ROUND(NVL(:new.INCR_HT_C3,0),5)+ROUND(NVL(:new.INCR_HT_C4,0),5)+ROUND(NVL(:new.INCR_HT_C5,0),5);

    --update curr_balance
    -- curr = open+increment-decrement
    :new.CURR_C1 := ROUND(NVL(:new.OPEN_C1,0),5)+ROUND(NVL(:new.INCR_EA1_C1,0),5)+ROUND(NVL(:new.INCR_HT_C1,0),5)-ROUND(NVL(:new.DECR_EA1_C1,0),5);
    :new.CURR_C2 := ROUND(NVL(:new.OPEN_C2,0),5)+ROUND(NVL(:new.INCR_EA1_C2,0),5)+ROUND(NVL(:new.INCR_HT_C2,0),5)-ROUND(NVL(:new.DECR_EA1_C2,0),5);
    :new.CURR_C3 := ROUND(NVL(:new.OPEN_C3,0),5)+ROUND(NVL(:new.INCR_EA1_C3,0),5)+ROUND(NVL(:new.INCR_HT_C3,0),5)-ROUND(NVL(:new.DECR_EA1_C3,0),5);
    :new.CURR_C4 := ROUND(NVL(:new.OPEN_C4,0),5)+ROUND(NVL(:new.INCR_EA1_C4,0),5)+ROUND(NVL(:new.INCR_HT_C4,0),5)-ROUND(NVL(:new.DECR_EA1_C4,0),5);
    :new.CURR_C5 := ROUND(NVL(:new.OPEN_C5,0),5)+ROUND(NVL(:new.INCR_EA1_C5,0),5)+ROUND(NVL(:new.INCR_HT_C5,0),5)-ROUND(NVL(:new.DECR_EA1_C5,0),5);    
    :new.CURR_TOTAL_UNITS :=   :new.CURR_C1 + :new.CURR_C2 + :new.CURR_C3 + :new.CURR_C4 + :new.CURR_C5;
    :new.curr_update_dt := sysdate;

END;
/
ALTER TRIGGER "OPENACCESS"."T_EXS_BANKING_BALANCE_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_EXS_LAPSED_BALANCE_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."T_EXS_LAPSED_BALANCE_TRIGGER" 
BEFORE INSERT OR UPDATE ON T_EXS_LAPSED_BALANCE 
for each row 
BEGIN 
    -- update all totals
    :new.OPEN_TOTAL_UNITS :=  ROUND(NVL(:new.OPEN_C1,0),5)+ROUND(NVL(:new.OPEN_C2,0),5)+ROUND(NVL(:new.OPEN_C3,0),5)+ROUND(NVL(:new.OPEN_C4,0),5)+ROUND(NVL(:new.OPEN_C5,0),5);
    :new.INCR_EA1_TOTAL_UNITS :=  ROUND(NVL(:new.INCR_EA1_C1,0),5)+ROUND(NVL(:new.INCR_EA1_C2,0),5)+ROUND(NVL(:new.INCR_EA1_C3,0),5)+ROUND(NVL(:new.INCR_EA1_C4,0),5)+ROUND(NVL(:new.INCR_EA1_C5,0),5);
    :new.DECR_EA1_TOTAL_UNITS :=  ROUND(NVL(:new.DECR_EA1_C1,0),5)+ROUND(NVL(:new.DECR_EA1_C2,0),5)+ROUND(NVL(:new.DECR_EA1_C3,0),5)+ROUND(NVL(:new.DECR_EA1_C4,0),5)+ROUND(NVL(:new.DECR_EA1_C5,0),5);
    :new.INCR_HT_TOTAL_UNITS :=  ROUND(NVL(:new.INCR_HT_C1,0),5)+ROUND(NVL(:new.INCR_HT_C2,0),5)+ROUND(NVL(:new.INCR_HT_C3,0),5)+ROUND(NVL(:new.INCR_HT_C4,0),5)+ROUND(NVL(:new.INCR_HT_C5,0),5);

    --update curr_balance
    -- curr = open+increment-decrement
    :new.CURR_C1 := ROUND(NVL(:new.OPEN_C1,0),5)+ROUND(NVL(:new.INCR_EA1_C1,0),5)+ROUND(NVL(:new.INCR_HT_C1,0),5)-ROUND(NVL(:new.DECR_EA1_C1,0),5);
    :new.CURR_C2 := ROUND(NVL(:new.OPEN_C2,0),5)+ROUND(NVL(:new.INCR_EA1_C2,0),5)+ROUND(NVL(:new.INCR_HT_C2,0),5)-ROUND(NVL(:new.DECR_EA1_C2,0),5);
    :new.CURR_C3 := ROUND(NVL(:new.OPEN_C3,0),5)+ROUND(NVL(:new.INCR_EA1_C3,0),5)+ROUND(NVL(:new.INCR_HT_C3,0),5)-ROUND(NVL(:new.DECR_EA1_C3,0),5);
    :new.CURR_C4 := ROUND(NVL(:new.OPEN_C4,0),5)+ROUND(NVL(:new.INCR_EA1_C4,0),5)+ROUND(NVL(:new.INCR_HT_C4,0),5)-ROUND(NVL(:new.DECR_EA1_C4,0),5);
    :new.CURR_C5 := ROUND(NVL(:new.OPEN_C5,0),5)+ROUND(NVL(:new.INCR_EA1_C5,0),5)+ROUND(NVL(:new.INCR_HT_C5,0),5)-ROUND(NVL(:new.DECR_EA1_C5,0),5);    
    :new.CURR_TOTAL_UNITS :=   :new.CURR_C1 + :new.CURR_C2 + :new.CURR_C3 + :new.CURR_C4 + :new.CURR_C5;
    :new.curr_update_dt := sysdate;
END;
/
ALTER TRIGGER "OPENACCESS"."T_EXS_LAPSED_BALANCE_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_EXS_SURPLUS_STB_BALANCE_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE_TRIGGER" 
BEFORE INSERT OR UPDATE ON T_EXS_SURPLUS_STB_BALANCE 
for each row 
BEGIN 
    -- update all totals
    :new.OPEN_TOTAL_UNITS :=  ROUND(NVL(:new.OPEN_C1,0),5)+ROUND(NVL(:new.OPEN_C2,0),5)+ROUND(NVL(:new.OPEN_C3,0),5)+ROUND(NVL(:new.OPEN_C4,0),5)+ROUND(NVL(:new.OPEN_C5,0),5);
    :new.INCR_EA1_TOTAL_UNITS :=  ROUND(NVL(:new.INCR_EA1_C1,0),5)+ROUND(NVL(:new.INCR_EA1_C2,0),5)+ROUND(NVL(:new.INCR_EA1_C3,0),5)+ROUND(NVL(:new.INCR_EA1_C4,0),5)+ROUND(NVL(:new.INCR_EA1_C5,0),5);
    :new.DECR_EA1_TOTAL_UNITS :=  ROUND(NVL(:new.DECR_EA1_C1,0),5)+ROUND(NVL(:new.DECR_EA1_C2,0),5)+ROUND(NVL(:new.DECR_EA1_C3,0),5)+ROUND(NVL(:new.DECR_EA1_C4,0),5)+ROUND(NVL(:new.DECR_EA1_C5,0),5);
    :new.INCR_HT_TOTAL_UNITS :=  ROUND(NVL(:new.INCR_HT_C1,0),5)+ROUND(NVL(:new.INCR_HT_C2,0),5)+ROUND(NVL(:new.INCR_HT_C3,0),5)+ROUND(NVL(:new.INCR_HT_C4,0),5)+ROUND(NVL(:new.INCR_HT_C5,0),5);

    --update curr_balance
    -- curr = open+increment-decrement
    :new.CURR_C1 := ROUND(NVL(:new.OPEN_C1,0),5)+ROUND(NVL(:new.INCR_EA1_C1,0),5)+ROUND(NVL(:new.INCR_HT_C1,0),5)-ROUND(NVL(:new.DECR_EA1_C1,0),5);
    :new.CURR_C2 := ROUND(NVL(:new.OPEN_C2,0),5)+ROUND(NVL(:new.INCR_EA1_C2,0),5)+ROUND(NVL(:new.INCR_HT_C2,0),5)-ROUND(NVL(:new.DECR_EA1_C2,0),5);
    :new.CURR_C3 := ROUND(NVL(:new.OPEN_C3,0),5)+ROUND(NVL(:new.INCR_EA1_C3,0),5)+ROUND(NVL(:new.INCR_HT_C3,0),5)-ROUND(NVL(:new.DECR_EA1_C3,0),5);
    :new.CURR_C4 := ROUND(NVL(:new.OPEN_C4,0),5)+ROUND(NVL(:new.INCR_EA1_C4,0),5)+ROUND(NVL(:new.INCR_HT_C4,0),5)-ROUND(NVL(:new.DECR_EA1_C4,0),5);
    :new.CURR_C5 := ROUND(NVL(:new.OPEN_C5,0),5)+ROUND(NVL(:new.INCR_EA1_C5,0),5)+ROUND(NVL(:new.INCR_HT_C5,0),5)-ROUND(NVL(:new.DECR_EA1_C5,0),5);    
    :new.CURR_TOTAL_UNITS :=   :new.CURR_C1 + :new.CURR_C2 + :new.CURR_C3 + :new.CURR_C4 + :new.CURR_C5;
    :new.curr_update_dt := sysdate;

END;
/
ALTER TRIGGER "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Trigger T_GEN_OTHER_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."T_GEN_OTHER_TRIGGER" 
AFTER INSERT OR UPDATE ON T_GEN_OTHER_CHARGES FOR EACH ROW

   DECLARE
   pragma autonomous_transaction;
   
BEGIN

    IF INSERTING THEN
      UPDATE  T_GEN_OTHER_CHARGES SET MONTH='11' WHERE MONTH='12' AND YEAR='2019';
      COMMIT; 
    END IF;
  
END;
/
ALTER TRIGGER "OPENACCESS"."T_GEN_OTHER_TRIGGER" DISABLE;
--------------------------------------------------------
--  DDL for Trigger T_JOB_TRIGGER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "OPENACCESS"."T_JOB_TRIGGER" 
AFTER INSERT OR UPDATE ON T_JOB_HDR FOR EACH ROW
DECLARE
NEW_V_ID VARCHAR2(50);
NEW_V_JOB_STATUS_CODE VARCHAR2(100);
NEW_V_JOB_CODE VARCHAR2(100);
NEW_V_T_ENERGY_SALE_ID VARCHAR2(50);
V_RESULT VARCHAR2(200);
v_log_result  varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
PRAGMA AUTONOMOUS_TRANSACTION;    

BEGIN

    BEGIN

      NEW_V_ID:= :new.ID;
      NEW_V_JOB_STATUS_CODE:=:new.JOB_STATUS_CODE;
      NEW_V_JOB_CODE:=:new.job_code;
      NEW_V_T_ENERGY_SALE_ID:=:new.t_energy_sale_id;


    v_log_result := log_activity('TRIGGER','T_JOB_TRIGGER','START','ENERGY_SALE_ID-'||NEW_V_T_ENERGY_SALE_ID,'JOB-STATUS-'||NEW_V_JOB_STATUS_CODE,SYSDATE, sysdate,NEW_V_ID);

    IF INSERTING THEN

        IF NEW_V_JOB_CODE='CONFIRM-ENERGY-ALLOTMENT' THEN
        V_RESULT:=ENERGY_SALE_CONFIRMATION(NEW_V_T_ENERGY_SALE_ID); 
        END IF;

    END IF;


    EXCEPTION
      WHEN OTHERS THEN 
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        V_RESULT := v_exception_code || ' - ' || v_exception_msg;
      END;
   v_log_result := log_activity('TRIGGER','T_JOB_TRIGGER','END','ENERGY_SALE_ID-'||NEW_V_T_ENERGY_SALE_ID,'JOB-STATUS-'||NEW_V_JOB_STATUS_CODE,SYSDATE,SYSDATE,NEW_V_ID);
COMMIT;
END;
/
ALTER TRIGGER "OPENACCESS"."T_JOB_TRIGGER" ENABLE;
--------------------------------------------------------
--  DDL for Procedure ADD_BUYERS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."ADD_BUYERS" AS 
BEGIN
 INSERT INTO M_SIGNUP(ID, COMPANY_NAME, PURPOSE, VOLTAGE, HTSC_NUMBER, SANCTIONED_QUANTUM, TOTAL_CAPACITY, M_ORG_ID,IS_COMPLETE,
 COMPANY_ADDRESS,  CREATED_BY, REMARKS) SELECT m_signup_seq.nextval, CONSUMERNAME, '01', C.VALUE_CODE, HT_REF_NO, DEMANDSANC, LOAD,
 CIRCLECODE,'N', ADDRESS1||' '||ADDRESS2||' '||ADDRESS3||' '||ADDRESS4||' '||CITY||'-'||PINCODE, 'admin','newserv03082019'
 FROM IMPORT_BUYERS LEFT JOIN V_CODES C ON list_code = 'VOLTAGE_CODE' AND  AVAILEDVOLT = C.ATTRIB1  ;

DECLARE v_result varchar2(150);
BEGIN
v_result := IMPORT_FROM_SIGNUP('newserv03082019');
dbms_output.put_line('v_result - '||v_result);
END;

END ADD_BUYERS;

/
--------------------------------------------------------
--  DDL for Procedure CLEAN_IMPORT_SELLERS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."CLEAN_IMPORT_SELLERS" is
v_flow_type_code varchar2(50);
v_esi_status_code varchar2(50);
v_signup_count number:=0;
v_signup_tr_count number:=0;
--v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_signup_import_result varchar(300):='SUCCESS';
v_imported BOOLEAN;
v_signup M_SIGNUP%ROWTYPE;
v_conversion number:=0.001;

BEGIN
    update imp_temp1 set commission_date =  to_date(trim(commission_date_str),'dd/mm/yyyy')  where commission_date is  null and commission_date_str is not null  ;

  FOR i IN ( select distinct i.edc_name, o.org_id from imp_temp1 i inner join v_org o on o.org_name = i.edc_name )
  LOOP
    update imp_temp1 set m_org_id = i.org_id where trim(edc_name) = i.edc_name ;
  END LOOP;

  FOR j IN ( select distinct i.SS_NAME_IN_OA, s.id  from imp_temp1 i inner join m_substation s on i.SS_NAME_IN_OA = s.name )
  LOOP
    update imp_temp1 set m_substation_id = j.id where trim(SS_NAME_IN_OA) = j.SS_NAME_IN_OA ;
  END LOOP;

  --update feeder-id and voltage-code
  FOR k IN (select distinct i.FEEDER_NAME_IN_OA, f.id, f.voltage_code from imp_temp1 i inner join m_feeder f on i.FEEDER_NAME_IN_OA = f.name )
  LOOP
  --, voltage_code=k.voltage_code  -- not mapping voltage from feeder as instructed by aruna madam
    update imp_temp1 set m_feeder_id = k.id where trim(feeder_NAME_IN_OA) = k.feeder_NAME_IN_OA ;
  END LOOP;

  --update voltage code
  FOR l IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'VOLTAGE_CODE')
  LOOP
    UPDATE imp_temp1 SET  VOLTAGE_code = l.VALUE_code WHERE trim(INJECTION_VOLTAGE)= l.VALUE_DESC  and INJECTION_VOLTAGE is not null;
  END LOOP;

  --update generator make code
  FOR l IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'GENERATOR_MAKE_CODE')
  LOOP
    UPDATE imp_temp1 SET  gen_make_code = l.VALUE_code WHERE trim(gen_make_name_oa)= l.VALUE_DESC ;
  END LOOP;

  --update meter make code
  FOR m IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'METER_MAKE_CODE')
  LOOP
    UPDATE imp_temp1 SET  meter_make_code = m.VALUE_code WHERE trim(meter_make)= m.VALUE_DESC ;
  END LOOP;

  --update Wind pass  code
  FOR n IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'WIND_PASS_CODE')
  LOOP
    UPDATE imp_temp1 SET  wind_pass_code = n.VALUE_code WHERE trim(wind_pass_name)= n.VALUE_DESC ;
  END LOOP;


  --update WEG group code
  FOR p IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'PLANT_CLASS_TYPE_CODE')
  LOOP
    UPDATE imp_temp1 SET  weg_group_code = p.VALUE_code WHERE  trim(weg_group_name) = p.VALUE_DESC ;
  END LOOP;

        -- dbms_output.put_line('imp_temp1 completed') ;

commit;

  FOR s1 IN(select sig.HTSC_NUMBER  from M_SIGNUP sig join imp_temp1 sel on sig.HTSC_NUMBER = sel.GENERATOR_SERVICE_NO_NEW )
  loop
    update imp_temp1 set  IMPORT_REMARKS='Service Already exists in signup. to import clear that entry from signup' where CLEAN_REC <> 'N' and GENERATOR_SERVICE_NO_NEW  = s1.HTSC_NUMBER;
  end loop;

  FOR s2 IN(select  serv."number" gen_serv_no from v_company_Service serv join imp_temp1 sel on serv."number" = sel.GENERATOR_SERVICE_NO_NEW )
  loop
    update imp_temp1 set CLEAN_REC = 'N', IMPORT_REMARKS='Service Already exists in the system. cannot import this service' where CLEAN_REC <> 'N' and GENERATOR_SERVICE_NO_NEW = s2.gen_serv_no;
  end loop;

  --  code cleansing end
              -- dbms_output.put_line('code cleansing completed') ;


      -- updating the service_id, company id of the consumers in import-trade-rel
      UPDATE imp_temp2 t1
       SET (t1.M_BUYER_COMP_SERVICE_ID, t1.M_BUYER_COMPANY_ID) = (SELECT t2.id, t2.M_COMPANY_ID
                             FROM  v_company_service t2
                            WHERE t1.BUYER_COMPANY_SERVICE_NO = t2."number")
      WHERE EXISTS (
        SELECT 1
          FROM v_company_service t2
         WHERE t1.BUYER_COMPANY_SERVICE_NO = t2."number" );

      update imp_temp2 set from_date=to_date(from_date_str,'dd/mm/yyyy') , to_date=to_date(to_date_str,'dd/mm/yyyy') ;

commit;


END;


/
--------------------------------------------------------
--  DDL for Procedure CREATE_AUTH_USER_TYPE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."CREATE_AUTH_USER_TYPE" (user_type_in_table VARCHAR2) IS
v_id  VARCHAR2(50);
v_user_type_code  VARCHAR2(50);
v_rowcount NUMBER(28);

   TYPE cur_cur IS REF CURSOR;
   v_cur_cur cur_cur;
sql_txt VARCHAR2(299);
BEGIN

	FOR loop_user_type IN (SELECT id, user_type_code FROM AUTH_FEATURE)
	LOOP
		IF(loop_user_type.user_type_code IS NULL or loop_user_type.user_type_code=''OR loop_user_type.user_type_code='(null)')THEN
			CONTINUE;
		END IF;
		sql_txt:=
		'select regexp_substr('''||loop_user_type.user_type_code||''','''||'[^,]+'||''', 1, level) user_type_code from dual'
		||' connect by regexp_substr('''||loop_user_type.user_type_code||''','''||'[^,]+'||''', 1, level) is not NULL';

		OPEN v_cur_cur FOR sql_txt;
			LOOP
				EXIT WHEN v_cur_cur%NOTFOUND;
				v_rowcount := v_cur_cur%ROWCOUNT;
				FETCH v_cur_cur INTO v_user_type_code;

		INSERT INTO AUTH_USER_TYPE_MAP (AUTH_USER_TYPE_CODE, AUTH_FEATURE_ID, ID) VALUES(v_user_type_code, loop_user_type.id,AUTH_USER_TYPE_MAP_SEQ.NEXTVAL );

			END LOOP;
		CLOSE v_cur_cur;
	 END LOOP loop_user_type;

END CREATE_AUTH_USER_TYPE;

/
--------------------------------------------------------
--  DDL for Procedure CREATE_ENERGY_SALE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."CREATE_ENERGY_SALE" 
(
  v_gen_stmt_id IN VARCHAR2 ,
  v_es_id out varchar2
) IS 
v_created_By  varchar2(50):= 'CREATE_ENERGY_SALE';
v_status varchar2(50);
v_reason varchar2(200):='';
v_stmt_month varchar2(50):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_process_name varchar(50):= 'CREATE_ENERGY_SALE';
v_gs_count number:=0;
v_service_count number:=0;
v_trade_count number:=0;
v_es_stb_count number:=0;
v_traderel M_TRADE_RELATIONSHIP%ROWTYPE;
v_gen_stmt t_gen_stmt%ROWTYPE;
v_gen_stmt_slot t_gen_stmt_slot%ROWTYPE;
v_comp_serv v_company_service%ROWTYPE;
v_traderel_cursor sys_refcursor;
v_gen_stmt_slot_cursor sys_refcursor;
v_es t_energy_sale%ROWTYPE;
v_es_stb t_energy_sale%ROWTYPE;
v_es_usage_summary t_es_usage_summary%ROWTYPE;
v_es_charge t_es_charge%ROWTYPE;
v_gs_slot1_units varchar2(50):=0; 
v_gs_slot2_units varchar2(50):=0;
v_gs_slot3_units varchar2(50):=0;
v_gs_slot4_units varchar2(50):=0;
v_gs_slot5_units varchar2(50):=0;
v_gs_slot1_bb varchar2(50):=0;
v_gs_slot2_bb varchar2(50):=0;
v_gs_slot3_bb varchar2(50):=0;
v_gs_slot4_bb varchar2(50):=0;
v_gs_slot5_bb varchar2(50):=0;

v_es_stb_c1 varchar2(50):=0;
v_es_stb_c2 varchar2(50):=0;
v_es_stb_c3 varchar2(50):=0;
v_es_stb_c4 varchar2(50):=0;
v_es_stb_c5 varchar2(50):=0;
v_es_stb_bc1 varchar2(50):=0;
v_es_stb_bc2 varchar2(50):=0;
v_es_stb_bc3 varchar2(50):=0;
v_es_stb_bc4 varchar2(50):=0;
v_es_stb_bc5 varchar2(50):=0;
v_es_stb_gc1 varchar2(50):=0;
v_es_stb_gc2 varchar2(50):=0;
v_es_stb_gc3 varchar2(50):=0;
v_es_stb_gc4 varchar2(50):=0;
v_es_stb_gc5 varchar2(50):=0;
v_service_number varchar2(50);
BEGIN

-- begin for exception handling
BEGIN

   v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','START','Start - '||v_gen_stmt_id,'',v_created_By,'','', '',v_gen_stmt_id);

   select count(*), DISP_SERVICE_NUMBER into v_gs_count, v_service_number from t_gen_stmt where id = v_gen_stmt_id and status_code!='ALLOCATED'  GROUP BY  DISP_SERVICE_NUMBER ;

   v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','v_gs_count - '||v_gs_count,'',v_created_By,'','', v_service_number,v_gen_stmt_id);

   if(v_gs_count=0) then
      Raise_Application_Error (-20343, 'Gen-Stmt already allocated or No records to process');
   ELSIF v_gs_count>1 then
      Raise_Application_Error (-20343, 'Multiple Gen-Stmts with same id!!');
   else  -- v_gs_count=1 
        select * into v_gen_stmt from t_gen_stmt where id = v_gen_stmt_id;

        select count(*) into v_service_count from v_company_service where m_company_id=v_gen_stmt.m_company_id;

        v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','v_service_count - '||v_service_count,'',v_created_By,'','', v_service_number,v_gen_stmt_id);

        if v_service_count = 1 then
--            select * into v_comp_serv from v_company_service where m_company_id=v_gen_stmt.m_company_id;
            v_stmt_month:=v_gen_stmt.stmt_month||'-'||v_gen_stmt.stmt_year;
--            -- dbms_output.put_line('v_stmt_month'||v_stmt_month);


            if v_gen_stmt.status_code='PART-ALLOC' then            
                 select count(*) into v_es_stb_count from t_energy_sale where T_GEN_STMT_ID=v_gen_stmt_id and IS_STB='Y';                 
                 if v_es_stb_count>0 then                 
                      select * into v_es_stb from t_energy_sale where T_GEN_STMT_ID=v_gen_stmt_id and IS_STB='Y';
                      v_es_stb_c1:=v_es_stb.c1;
                      v_es_stb_c2:=v_es_stb.c2;
                      v_es_stb_c3:=v_es_stb.c3;
                      v_es_stb_c4:=v_es_stb.c4;
                      v_es_stb_c5:=v_es_stb.c5; 
                      v_es_stb_bc1:=v_es_stb.bc1;
                      v_es_stb_bc2:=v_es_stb.bc2;
                      v_es_stb_bc3:=v_es_stb.bc3;
                      v_es_stb_bc4:=v_es_stb.bc4;
                      v_es_stb_bc5:=v_es_stb.bc5; 
                      v_es_stb_gc1:=v_es_stb.gc1;
                      v_es_stb_gc2:=v_es_stb.gc2;
                      v_es_stb_gc3:=v_es_stb.gc3;
                      v_es_stb_gc4:=v_es_stb.gc4;
                      v_es_stb_gc5:=v_es_stb.gc5; 
                 end if;        

            end if;


            OPEN v_gen_stmt_slot_cursor for select * from t_gen_stmt_slot where t_gen_stmt_id=v_gen_stmt_id;
            LOOP
            FETCH v_gen_stmt_slot_cursor INTO v_gen_stmt_slot;
            EXIT WHEN v_gen_stmt_slot_cursor%NOTFOUND;
                -- v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_gen_stmt_slot.slot_code||'-'||v_gen_stmt_slot.net_units,v_gen_stmt_slot.banked_balance,v_created_By,'','', v_service_number,v_gen_stmt_id);

                if v_gen_stmt_slot.slot_code='C1' then
                    v_gs_slot1_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot1_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C2' then
                    v_gs_slot2_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot2_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C3' then
                    v_gs_slot3_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot3_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C4' then 
                    v_gs_slot4_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot4_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C5' then
                    v_gs_slot5_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot5_bb:=v_gen_stmt_slot.banked_balance; 
                end if;       
               --  v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','END-'||v_gen_stmt_slot.net_units,v_gen_stmt_slot.banked_balance,v_created_By,'','', v_service_number,v_gen_stmt_id);

            END LOOP;

            v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','Gen Stmt Slots Read','',v_created_By,'','', v_service_number,v_gen_stmt_id);

            v_es.AVAIL_C1:= to_number(nvl(v_gen_stmt.c1,0))-to_number(nvl(v_es_stb_c1,0)); 
            v_es.AVAIL_C2:= to_number(nvl(v_gen_stmt.c2,0))-to_number(nvl(v_es_stb_c2,0)); 
            v_es.AVAIL_C3:= to_number(nvl(v_gen_stmt.c3,0))-to_number(nvl(v_es_stb_c3,0)); 
            v_es.AVAIL_C4:= to_number(nvl(v_gen_stmt.c4,0))-to_number(nvl(v_es_stb_c4,0)); 
            v_es.AVAIL_C5:= to_number(nvl(v_gen_stmt.c5,0))-to_number(nvl(v_es_stb_c5,0)); 

            v_es.AVAIL_GC1:= to_number(nvl(v_gs_slot1_units,0))-to_number(nvl(v_es_stb_gc1,0)); 
            v_es.AVAIL_GC2:= to_number(nvl(v_gs_slot2_units,0))-to_number(nvl(v_es_stb_gc2,0)); 
            v_es.AVAIL_GC3:= to_number(nvl(v_gs_slot3_units,0))-to_number(nvl(v_es_stb_gc3,0)); 
            v_es.AVAIL_GC4:= to_number(nvl(v_gs_slot4_units,0))-to_number(nvl(v_es_stb_gc4,0)); 
            v_es.AVAIL_GC5:= to_number(nvl(v_gs_slot5_units,0))-to_number(nvl(v_es_stb_gc5,0)); 

            v_es.AVAIL_BC1:= to_number(nvl(v_gs_slot1_bb,0))-to_number(nvl(v_es_stb_bc1,0)); 
            v_es.AVAIL_BC2:= to_number(nvl(v_gs_slot2_bb,0))-to_number(nvl(v_es_stb_bc2,0)); 
            v_es.AVAIL_BC3:= to_number(nvl(v_gs_slot3_bb,0))-to_number(nvl(v_es_stb_bc3,0)); 
            v_es.AVAIL_BC4:= to_number(nvl(v_gs_slot4_bb,0))-to_number(nvl(v_es_stb_bc4,0)); 
            v_es.AVAIL_BC5:= to_number(nvl(v_gs_slot5_bb,0))-to_number(nvl(v_es_stb_bc5,0)); 

            v_es.T_GEN_STMT_ID :=v_gen_stmt_id;
            v_es.SELLER_COMP_SERV_ID :=v_gen_stmt.M_COMPANY_SERVICE_ID;
            v_es.SELLER_END_ORG_ID :=v_gen_stmt.M_ORG_ID;
            v_es.MONTH :=v_gen_stmt.stmt_month;
            v_es.year :=v_gen_stmt.stmt_year;
            v_es.INJECTING_VOLTAGE_CODE :=v_gen_stmt.INJECTING_VOLTAGE_CODE;
            v_es.FROM_DT :=v_gen_stmt.INIT_STMT_DT;
            v_es.TO_DT :=v_gen_stmt.FINAL_STMT_DT;
            v_es.SIMPLE_ENERGY_SALE :='N';
            v_es.IS_STB:='N';
            v_es.C1 :=0;
            v_es.C2 :=0;
            v_es.C3 :=0;
            v_es.C4 :=0;
            v_es.C5 :=0;
            v_es.BC1 :=0;
            v_es.BC2 :=0;
            v_es.BC3 :=0;
            v_es.BC4 :=0;
            v_es.BC5 :=0;
            v_es.GC1 :=0;
            v_es.GC2 :=0;
            v_es.GC3 :=0;
            v_es.GC4 :=0;
            v_es.GC5 :=0;
            v_es.NET_GENERATION :=0;
            v_es.NET_ALLOCATION :=0;
            v_es.FUEL_GROUPE := v_gen_stmt.DISP_FUEL_TYPE_GROUP;
            v_es.TOTAL_BANK_UNITS_USED :=0;
            v_es.CREATED_BY :=v_process_name;
            v_es.CREATED_DATE :=sysdate;
            v_es.M_SUBSTATION_ID :=v_gen_stmt.M_SUBSTATION_ID;
            v_es.ENABLED :='Y';
            v_es.STATUS_CODE :='CREATED';
            v_es.ID:=T_ENERGY_SALE_SEQ.NEXTVAL;
            v_es_id:= v_es.ID;
            insert into t_energy_sale values v_es;


            v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','Energy Sale inserted','',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);
            select count(*) into v_trade_count from m_trade_relationship trade  where trade.m_seller_company_id=v_gen_stmt.m_company_id and to_date(v_stmt_month,'MM-YYYY') between trade.from_date and trade.to_date;
--            -- dbms_output.put_line('v_trade_count'||v_trade_count);

            if v_trade_count>0 then

                  OPEN v_traderel_cursor for select * from m_trade_relationship trade  where trade.m_seller_company_id=v_gen_stmt.m_company_id and to_date(v_stmt_month,'MM-YYYY') between trade.from_date and trade.to_date;
                    LOOP
                    FETCH v_traderel_cursor INTO v_traderel;
                    EXIT WHEN v_traderel_cursor%NOTFOUND;
                        v_es_usage_summary.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_usage_summary.C1:=0;
                        v_es_usage_summary.C2:=0;
                        v_es_usage_summary.C3:=0; 
                        v_es_usage_summary.C4:=0;
                        v_es_usage_summary.C5:=0;
                        v_es_usage_summary.total:=0;
                        v_es_usage_summary.BUYER_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_usage_summary.M_TRADE_RELATIONSHIP_ID:=v_traderel.id;
                        v_es_usage_summary.CREATED_DATE:=sysdate;
                        v_es_usage_summary.ENABLED:='Y';
                        v_es_usage_summary.id:=T_ES_USAGE_SUMMARY_SEQ.nextval;
                        insert into t_es_usage_summary values v_es_usage_summary;

                        v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','v_es_usage_summary-'||v_es_usage_summary.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C001';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C002';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C003';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C004';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C005';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C006';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C007';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C008';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);

                        v_es_charge.T_ENERGY_SALE_ID:=v_es_id;
                        v_es_charge.M_COMP_SERV_ID:=v_traderel.M_BUYER_COMP_SERVICE_ID;
                        v_es_charge.CHARGE_CODE:='C009';
                        v_es_charge.TOTAL_CHARGE:=0;
                        v_es_charge.CREATED_DATE:=sysdate;
                        v_es_charge.CREATED_BY:=v_process_name;
                        v_es_charge.ENABLED:='Y';
                        v_es_charge.id:=T_ES_CHARGE_SEQ.nextval;
                        insert into t_es_charge values v_es_charge;
                        --v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS',v_es_charge.id,'',v_created_By,'',v_es_id, v_service_number,v_gen_stmt_id);
                  END LOOP;

            update t_gen_stmt set status_code='ALLOCATED' where id=v_gen_stmt_id; 
            v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','PROCESS','Energy Sale Created','energy_sale_id'||v_es_id,v_created_By,'','gen_stmt_id'||v_gen_stmt_id, v_service_number,v_gen_stmt_id);

            else
                v_reason:='trade relationship does not exist';
                v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','trade relationship does not exist','v_trade_count - '||v_trade_count,'',v_created_By,'','', v_service_number,v_gen_stmt_id);
            end if;
        else 
            v_reason:='company does not exist';
            v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','company does not exist','v_service_count - '||v_service_count,'',v_created_By,'','', v_service_number, v_gen_stmt_id);
        end if;

   end if;



      commit;
    exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 150);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
       -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','EXCEPTION',v_reason,'',v_created_By,'','', v_service_number,v_gen_stmt_id);
END;

v_log_result := log_activity('FUNCTION','CREATE_ENERGY_SALE','END',v_reason,'energy_sale_id'||v_es_id,v_created_By,'','gen_stmt_id'||v_gen_stmt_id, v_service_number,v_gen_stmt_id);



END CREATE_ENERGY_SALE;

/
--------------------------------------------------------
--  DDL for Procedure DISC_SURP_ADJ_ANALYSIS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."DISC_SURP_ADJ_ANALYSIS" (v_r_month varchar2,v_r_year varchar2) AS 
-- under development :
--to check surplus case discrepancy between HT & OA -- by rini AE/LT5
BEGIN
  DECLARE
  v_subquery_a varchar2(1000):=''; v_subquery_b varchar2(1000):='';v_query varchar2(2000):='';
 
  BEGIN
  execute immediate 'truncate table r_disc_int_adj';   
execute immediate 'truncate table r_disc_f_energy';  

v_subquery_a:='select  r.reading_dt
,r.created_dt,r.READING_MNTH,r.reading_yr,r.buyer_service_no,r.seller_service_no,nvl(c1,0),nvl(c2,0),nvl(c3,0),nvl(c4,0),nvl(c5,0),
surp_c1,surp_c2,surp_c3,surp_c4,surp_c5, 
surp_c1-nvl(c1,0) as diff_C1,surp_c2-nvl(c2,0) as diff_C2,surp_c3-nvl(c3,0) as diff_C3,surp_c4-nvl(c4,0) as diff_C4,
surp_c5-nvl(c5,0) as diff_C5,
surp_c1-nvl(c1,0)+surp_c2-nvl(c2,0)+surp_c3-nvl(c3,0)+surp_c4-nvl(c4,0)+surp_c5-nvl(c5,0) as TOT_DIFF_surp,
adj_c1-f.adjusted_c1+adj_c2-f.adjusted_c2+adj_c3-f.adjusted_c3+adj_c4-f.adjusted_c4+adj_c5-f.adjusted_c5 as TOT_DIFF_ADJ,
adj_c1-f.adjusted_c1,adj_c2-f.adjusted_c2,adj_c3-f.adjusted_c3,adj_c4-f.adjusted_c4,adj_c5-f.adjusted_c5
from R_SURPLUS_CASES_FROM_HT r,F_ENERGY_ADJUSTMET f
where r.buyer_service_no=f.service_no 
and r.seller_service_no=f.suplr_code 
and r.READING_MNTH='||v_r_month||' AND r.READING_YR='||v_r_year||' and f.reading_yr=r.READING_YR 
--and trim(r.reading_mnth)=trim(substr(f.reading_mnth,1) )
and r.reading_mnth=f.reading_mnth
and (adj_c1-adjusted_c1!=0 or adj_c2-adjusted_c2!=0 or adj_c3-adjusted_c3 !=0 or adj_c4-adjusted_c4! =0 or adj_c5-adjusted_c5!=0)';

v_subquery_b :='select  r.READING_MNTH,r.reading_yr,r.buyer_service_no,r.seller_service_no,nvl(c1,0),nvl(c2,0),nvl(c3,0),nvl(c4,0),nvl(c5,0),
surp_c1,surp_c2,surp_c3,surp_c4,surp_c5, 
surp_c1-nvl(c1,0) as diff_C1,surp_c2-nvl(c2,0) as diff_C2,surp_c3-nvl(c3,0) as diff_C3,surp_c4-nvl(c4,0) as diff_C4,
surp_c5-nvl(c5,0) as diff_C5,
surp_c1-nvl(c1,0)+surp_c2-nvl(c2,0)+surp_c3-nvl(c3,0)+surp_c4-nvl(c4,0)+surp_c5-nvl(c5,0) as TOT_DIFF_surp,
adj_c1-f.adjusted_c1+adj_c2-f.adjusted_c2+adj_c3-f.adjusted_c3+adj_c4-f.adjusted_c4+adj_c5-f.adjusted_c5 as TOT_DIFF_ADJ,
adj_c1-f.adjusted_c1,adj_c2-f.adjusted_c2,adj_c3-f.adjusted_c3,adj_c4-f.adjusted_c4,adj_c5-f.adjusted_c5
from R_SURPLUS_CASES_FROM_HT r,F_ENERGY_ADJUSTMET f
where r.buyer_service_no=f.service_no 
and r.seller_service_no=f.suplr_code 
and r.READING_MNTH='||v_r_month||' AND r.READING_YR='||v_r_year||' and f.reading_yr=r.READING_YR 
--and trim(r.reading_mnth)=trim(substr(f.reading_mnth,1) )
and r.reading_mnth=f.reading_mnth
and (surp_c1-nvl(c1,0)!=0 or surp_c2-nvl(c2,0)!=0 or surp_c3-nvl(c3,0) !=0 or surp_c4-nvl(c4,0) !=0 or surp_c5-nvl(c5,0)!=0)';

v_query := v_subquery_a||'union'|| v_subquery_b;

FOR LOOP_SURP IN (select  f.reading_dt
,f.created_dt,r.READING_MNTH,r.reading_yr,r.buyer_service_no,r.seller_service_no,nvl(c1,0),nvl(c2,0),nvl(c3,0),nvl(c4,0),nvl(c5,0),
surp_c1,surp_c2,surp_c3,surp_c4,surp_c5, 
surp_c1-nvl(c1,0) as diff_C1,surp_c2-nvl(c2,0) as diff_C2,surp_c3-nvl(c3,0) as diff_C3,surp_c4-nvl(c4,0) as diff_C4,
surp_c5-nvl(c5,0) as diff_C5,
surp_c1-nvl(c1,0)+surp_c2-nvl(c2,0)+surp_c3-nvl(c3,0)+surp_c4-nvl(c4,0)+surp_c5-nvl(c5,0) as TOT_DIFF_surp,
adj_c1-f.adjusted_c1+adj_c2-f.adjusted_c2+adj_c3-f.adjusted_c3+adj_c4-f.adjusted_c4+adj_c5-f.adjusted_c5 as TOT_DIFF_ADJ,
adj_c1-f.adjusted_c1,adj_c2-f.adjusted_c2,adj_c3-f.adjusted_c3,adj_c4-f.adjusted_c4,adj_c5-f.adjusted_c5
from R_SURPLUS_CASES_FROM_HT r,F_ENERGY_ADJUSTMET f
where r.buyer_service_no=f.service_no 
and r.seller_service_no=f.suplr_code 
and r.READING_MNTH='||v_r_month||' AND r.READING_YR='||v_r_year||' and f.reading_yr=r.READING_YR 
--and trim(r.reading_mnth)=trim(substr(f.reading_mnth,1) )
and r.reading_mnth=f.reading_mnth
and (adj_c1-adjusted_c1!=0 or adj_c2-adjusted_c2!=0 or adj_c3-adjusted_c3 !=0 or adj_c4-adjusted_c4! =0 or adj_c5-adjusted_c5!=0)
union
select   f.reading_dt
,f.created_dt,r.READING_MNTH,r.reading_yr,r.buyer_service_no,r.seller_service_no,nvl(c1,0),nvl(c2,0),nvl(c3,0),nvl(c4,0),nvl(c5,0),
surp_c1,surp_c2,surp_c3,surp_c4,surp_c5, 
surp_c1-nvl(c1,0) as diff_C1,surp_c2-nvl(c2,0) as diff_C2,surp_c3-nvl(c3,0) as diff_C3,surp_c4-nvl(c4,0) as diff_C4,
surp_c5-nvl(c5,0) as diff_C5,
surp_c1-nvl(c1,0)+surp_c2-nvl(c2,0)+surp_c3-nvl(c3,0)+surp_c4-nvl(c4,0)+surp_c5-nvl(c5,0) as TOT_DIFF_surp,
adj_c1-f.adjusted_c1+adj_c2-f.adjusted_c2+adj_c3-f.adjusted_c3+adj_c4-f.adjusted_c4+adj_c5-f.adjusted_c5 as TOT_DIFF_ADJ,
adj_c1-f.adjusted_c1,adj_c2-f.adjusted_c2,adj_c3-f.adjusted_c3,adj_c4-f.adjusted_c4,adj_c5-f.adjusted_c5
from R_SURPLUS_CASES_FROM_HT r,F_ENERGY_ADJUSTMET f
where r.buyer_service_no=f.service_no 
and r.seller_service_no=f.suplr_code 
and r.READING_MNTH='||v_r_month||' AND r.READING_YR='||v_r_year||' and f.reading_yr=r.READING_YR 
--and trim(r.reading_mnth)=trim(substr(f.reading_mnth,1) )
and r.reading_mnth=f.reading_mnth
and (surp_c1-nvl(c1,0)!=0 or surp_c2-nvl(c2,0)!=0 or surp_c3-nvl(c3,0) !=0 or surp_c4-nvl(c4,0) !=0 or surp_c5-nvl(c5,0)!=0);)
LOOP




END LOOP;
  END;
END DISC_SURP_ADJ_ANALYSIS;

/
--------------------------------------------------------
--  DDL for Procedure FIND_SS_ID
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."FIND_SS_ID" AS
BEGIN

FOR i IN (
select f.id f_id, f.ss_name, s.id from m_feeder f, m_substation s
where f.ss_name = s.name
) LOOP
      update m_feeder set m_substation_id = i.id where ss_name = i.ss_name;
    END LOOP;

END FIND_SS_ID;



/
--------------------------------------------------------
--  DDL for Procedure GENERATOR_BASED_INSENTIVE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."GENERATOR_BASED_INSENTIVE" (service_number VARCHAR2,r_month VARCHAR2,r_year VARCHAR2)
AS 
BEGIN
declare
import_units_total VARCHAR2(200);
export_units_total VARCHAR2(200);
net_units_difference varchar2(200);
gen_id VARCHAR2(50);
m_com_meter_id varchar2(50);
tariff_r VARCHAR2(100);
tariff_net_amt VARCHAR2(100);
total_charges_sum VARCHAR2(200);
net_payables_cal VARCHAR2(200);

begin
select id into gen_id from t_gen_stmt where disp_service_number=service_number and stmt_month=r_month and stmt_year=r_year;
select m_company_meter_id into m_com_meter_id from t_gen_stmt where disp_service_number=service_number and stmt_month=r_month and stmt_year=r_year;
select total_import_gen into import_units_total from t_meter_reading_hdr where m_company_meter_id=m_com_meter_id and reading_month=r_month and reading_year=r_year;
select total_export_gen into export_units_total from t_meter_reading_hdr where m_company_meter_id=m_com_meter_id and reading_month=r_month and reading_year=r_year;
--select import_units_total into sum(imp_units) from t_gen_stmt_slot where t_gen_stmt_id=gen_id;
--select export_units_total into sum(exp_units) from t_gen_stmt_slot where t_gen_stmt_id=gen_id;
net_units_difference:=export_units_total-import_units_total;

update t_gen_stmt set net_generation=net_units_difference where id=gen_id;

update t_meter_reading_hdr set net_gen_units=net_units_difference where m_company_meter_id=m_com_meter_id and reading_month=r_month and 
reading_year=r_year;

select tariff_rate into tariff_r from t_gen_stmt where id=gen_id;

tariff_net_amt:=tariff_r*net_units_difference;

update t_gen_stmt set tariff_net_amount=tariff_net_amt where id=gen_id;

select sum(total_charges) into total_charges_sum from t_gen_stmt_charge where t_gen_stmt_id=gen_id AND CHARGE_CODE<>'C006';

net_payables_cal:=tariff_net_amt-total_charges_sum;

update t_gen_stmt set net_payable=net_payables_cal where id=gen_id;
update T_GEN_STMT_CHARGE set TOTAL_CHARGES ='0' where T_GEN_STMT_ID= gen_id and CHARGE_CODE='C006'; ---my

end;
END GENERATOR_BASED_INSENTIVE;

/
--------------------------------------------------------
--  DDL for Procedure MANUAL_GS_FOR_10_1_SS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."MANUAL_GS_FOR_10_1_SS" (i_remarks in varchar2,
  o_result_code out varchar2, o_result_desc out varchar2) 
  is
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
  begin
  BEGIN  -- exception handling start
      v_log_result := log_activity('PROCEDURE','MANUAL_GS_FOR_10_1_SS','START',I_remarks,'',v_created_by, sysdate,i_remarks);

      if(i_remarks is null or i_remarks = '' ) then
        Raise_Application_Error (-20343, 'i_remarks is mandatory  ');
      end if;

      update MANUAL_GS_101SS set PROCESSED=null,update_REMARKS=null where remarks = i_remarks;

      for ss in (select * from MANUAL_GS_101SS where REMARKS = i_remarks)
       loop
       begin
--         v_log_result := log_activity('PROCEDURE','MANUAL_GS_FOR_10_1_SS','inside for loop',ss.SUBSTATION_ID,'',v_created_by, sysdate,i_remarks);
--       -- dbms_output.put_line('VALUES:'||ss.SUBSTATION_ID||','||ss.GEN_SERVICE_NUMBER||','||ss.ORG_ID||','||ss.reading_month);
       GENERATION_STATEMENT.CREATE_WITH_SS_LOSS(ss.SUBSTATION_ID,ss.GEN_SERVICE_NUMBER ,ss.ORG_ID,ss.reading_month,ss.reading_year ,O_RESULT_CODE,O_RESULT_DESC );
--       -- dbms_output.put_line('SERVICE :'||ss.GEN_SERVICE_NUMBER);
         exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','MANUAL_GS_FOR_10_1_SS','EXCEPTION',o_result_desc,i_remarks,'', sysdate,i_remarks);

       END;
      end loop;

      o_result_code :='SUCCESS';
      exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        o_result_code := 'FAILURE';
        o_result_desc := v_exception_code || ' - ' || v_exception_msg;
        -- dbms_output.put_line(o_result_desc);
      END;
          commit;
       v_log_result := log_activity('PROCEDURE','MANUAL_GS_FOR_10_1_SS','RESULT',o_result_code,o_result_desc,v_created_by, sysdate,i_remarks);
	END MANUAL_GS_FOR_10_1_SS;


/
--------------------------------------------------------
--  DDL for Procedure METER_CHANGE_COMPUTE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."METER_CHANGE_COMPUTE" (v_sc_no varchar2,v_r_month varchar2,v_r_year varchar2,v_loss_pc number) AS 
BEGIN
--this proc is called from METER_CHANGE_TABLE_INS proc
--TO compute consumption units from the readings stored in R_METER_CHANGE and store into an
--intermediate table R_METER_CHANGE_INT
--and final result table R_INT_METER_CHANGE.
 DECLARE 
 v_old_meter varchar2(50);v_new_meter varchar2(50);
 --v_sc_no varchar2(50):='0039224341047'; 
 --v_r_month varchar2(50):='01';  v_r_year varchar2(50):='2020';

 v_meterno varchar2(50):=''; v_ikwhc1_diff varchar2(50):='';v_ikwhc2_diff varchar2(50):='';
  v_ikwhc3_diff varchar2(50):='';v_ikwhc4_diff varchar2(50):='';v_ikwhc5_diff varchar2(50):='';
  v_ekwhc1_diff varchar2(50):='';
  v_ekwhc2_diff varchar2(50):='';v_ekwhc3_diff varchar2(50):='';v_ekwhc4_diff varchar2(50):='';
  v_ekwhc5_diff varchar2(50):='';v_ikvah_diff varchar2(50):='';v_kvarh_diff varchar2(50):='';v_mf  varchar2(50):='';

  v_ekwhc1_units varchar2(50):='';
  v_ekwhc2_units varchar2(50):='';v_ekwhc3_units varchar2(50):='';v_ekwhc4_units varchar2(50):='';
  v_ekwhc5_units varchar2(50):='';v_ikvah_units varchar2(50):='';v_kvarh_units varchar2(50):='';

     v_ikwhc1_units varchar2(50):='';
  v_ikwhc2_units varchar2(50):='';v_ikwhc3_units varchar2(50):='';v_ikwhc4_units varchar2(50):='';
  v_ikwhc5_units varchar2(50):='';

  v_exp_units varchar2(50):='';  v_imp_units varchar2(50):='';
   v_net_units varchar2(50):='';

    v_net_c1_units varchar2(50):='';
  v_net_c2_units varchar2(50):='';v_net_c3_units varchar2(50):='';v_net_c4_units varchar2(50):='';
  v_net_c5_units varchar2(50):='';

  v_rdg_date date:='';
  v_remarks varchar2(100);

  v_loss_frac number;

begin


--SYS.-- dbms_output.put_line('v_r_month'||v_sc_no);
--SYS.-- dbms_output.put_line('v_r_month'||v_r_month);
--SYS.-- dbms_output.put_line('v_r_year'||v_r_year);

select oldmeterno,newmeterno
into v_old_meter,v_new_meter
from r_meter_change_from_amr where newmeterno=
(SELECT meter_number FROM  v_company_service WHERE  "number" IN (v_sc_no))
;

--bad design of code -  to remove loop and change it
 FOR loop_mtr IN (
 select T1.reading_date,T1.m_company_meter_id,
round(t2.ikwhc1-t1.ikwhc1,3) as ikwhc1_diff ,round(t2.ikwhc2-t1.ikwhc2,3) as ikwhc2_diff,round(t2.ikwhc3-t1.ikwhc3,3) as ikwhc3_diff,round(t2.ikwhc4-t1.ikwhc4,3) as ikwhc4_diff,
round(t2.ikwhc5-t1.ikwhc5,3) as ikwhc5_diff,
round(t2.ekwhc1-t1.ekwhc1,3) as ekwhc1_diff,round(t2.ekwhc2-t1.ekwhc2,3)  as ekwhc2_diff,round(t2.ekwhc3-t1.ekwhc3,3) as ekwhc3_diff,
round(t2.ekwhc4-t1.ekwhc4,3) as ekwhc4_diff,
round(t2.ekwhc5-t1.ekwhc5,3) as ekwhc5_diff,
round(t2.kvah-t1.kvah,3) as kvah_diff,round(t2.kvarh-t1.kvarh,3) as kvarh_diff,t1.mf 
from r_meter_change T1
inner join r_meter_change T2
on T1.m_company_meter_id=T2.m_company_meter_id
and T2.reading_date>T1.reading_date and T1.m_company_meter_id in (v_old_meter,v_new_meter) and T1.sc_no = v_sc_no) loop
-- and T1.m_company_meter_id in (v_old_meter,v_new_meter)
--T1.m_company_meter_id in (v_new_meter)

v_ekwhc1_units := loop_mtr.ekwhc1_diff * loop_mtr.mf; v_ekwhc2_units := loop_mtr.ekwhc2_diff * loop_mtr.mf;v_ekwhc3_units := loop_mtr.ekwhc3_diff * loop_mtr.mf;
v_ekwhc4_units := loop_mtr.ekwhc4_diff * loop_mtr.mf;v_ekwhc5_units := loop_mtr.ekwhc5_diff * loop_mtr.mf;

--loss is applicable only for Exported units for 10_1 SS case
if(v_loss_pc>0) then
v_loss_frac:=v_loss_pc/100;
v_ekwhc1_units := v_ekwhc1_units - v_loss_frac*v_ekwhc1_units ; 
v_ekwhc2_units := v_ekwhc2_units - v_loss_frac*v_ekwhc2_units ; 
v_ekwhc3_units := v_ekwhc3_units - v_loss_frac*v_ekwhc3_units ; 
v_ekwhc4_units := v_ekwhc4_units - v_loss_frac*v_ekwhc4_units ; 
v_ekwhc5_units := v_ekwhc5_units - v_loss_frac*v_ekwhc5_units ;
end if;

v_ikwhc1_units := loop_mtr.ikwhc1_diff * loop_mtr.mf;v_ikwhc2_units := loop_mtr.ikwhc2_diff * loop_mtr.mf;v_ikwhc3_units := loop_mtr.ikwhc3_diff * loop_mtr.mf;
v_ikwhc4_units := loop_mtr.ikwhc4_diff * loop_mtr.mf;v_ikwhc5_units := loop_mtr.ikwhc5_diff * loop_mtr.mf;

--loop_mtr.imp_units :=loop_mtr.ikwhc1_units+loop_mtr.ikwhc2_units+loop_mtr.ikwhc3_units+loop_mtr.ikwhc4_units+loop_mtr.ikwhc5_units;

v_kvarh_units := loop_mtr.kvarh_diff *loop_mtr.mf;
v_ikvah_units := loop_mtr.kvah_diff * loop_mtr.mf;

--loop_mtr.net_units := loop_mtr.exp_units-loop_mtr.imp_units;

-- dbms_output.put_line('insert into r_meter_change_int values(loop_mtr.rdg_date,loop_mtr.meterno,loop_mtr.ikwhc1_units,loop_mtr.ikwhc2_units,loop_mtr.ikwhc3_units ,loop_mtr.ikwhc4_units,
--  loop_mtr.ikwhc5_units, loop_mtr.ekwhc1_units , loop_mtr.ekwhc2_units,loop_mtr.ekwhc3_units ,loop_mtr.ekwhc4_units,
--  loop_mtr.ekwhc5_units,loop_mtr.ikvah_units,loop_mtr.kvarh_units,loop_mtr.mf' );

insert into r_meter_change_int values(loop_mtr.reading_date,loop_mtr.m_company_meter_id,v_ikwhc1_units,v_ikwhc2_units,v_ikwhc3_units ,v_ikwhc4_units,
  v_ikwhc5_units, v_ekwhc1_units , v_ekwhc2_units,v_ekwhc3_units ,v_ekwhc4_units,
  v_ekwhc5_units,v_ikvah_units,v_kvarh_units,loop_mtr.mf,v_sc_no );

    end loop;

  --=========computing sum of old and new meter======= 
select sum(ikwhc1),
sum(ikwhc2),sum(ikwhc3),sum(ikwhc4),sum(ikwhc5),
sum(ekwhc1),sum(ekwhc2)  ,sum(ekwhc3),sum(ekwhc4),sum(ekwhc5),
sum(kvah) ,sum(kvarh) , sum(mf) 
into 
v_ikwhc1_units,v_ikwhc2_units,v_ikwhc3_units ,v_ikwhc4_units,
  v_ikwhc5_units, v_ekwhc1_units , v_ekwhc2_units,v_ekwhc3_units ,v_ekwhc4_units,
  v_ekwhc5_units,v_ikvah_units,v_kvarh_units,v_mf
  from r_meter_change_int
where m_company_meter_id in (v_old_meter,v_new_meter)  ;



    v_imp_units :=v_ikwhc1_units+v_ikwhc2_units+v_ikwhc3_units+v_ikwhc4_units+v_ikwhc5_units;
v_exp_units :=v_ekwhc1_units+v_ekwhc2_units+v_ekwhc3_units+v_ekwhc4_units+v_ekwhc5_units;
v_net_units := v_exp_units-v_imp_units;

if(v_net_units < 0) then
    v_net_units :=0;
end if;

  v_net_c1_units := v_ekwhc1_units-v_ikwhc1_units;
  v_net_c2_units :=v_ekwhc2_units-v_ikwhc2_units;
  v_net_c3_units  := v_ekwhc3_units-v_ikwhc3_units;v_net_c4_units  :=v_ekwhc4_units-v_ikwhc4_units;
  v_net_c5_units :=v_ekwhc5_units-v_ikwhc5_units;
  v_remarks:='MC-'||v_sc_no||'-'||sysdate;
  if (v_loss_pc > 0) then
  v_remarks:='MC-'||v_sc_no||'-loss-'||v_loss_pc||'-'||sysdate;
  end if;


INSERT INTO r_int_meter_change VALUES (    'id',    v_sc_no,    v_old_meter,    v_new_meter,    v_r_month, 
v_r_year,    v_imp_units,    v_exp_units,    v_kvarh_units,    v_net_units, 
v_remarks,    v_ikwhc1_units,    v_ikwhc2_units,    v_ikwhc3_units,
v_ikwhc4_units,    v_ikwhc5_units,    v_ekwhc1_units,    v_ekwhc2_units,    v_ekwhc3_units,    v_ekwhc4_units,
v_ekwhc5_units,    v_net_c1_units,    v_net_c2_units,    v_net_c3_units,    v_net_c4_units,    v_net_c5_units,
'',    'PROC METER_CHANGE_TABLE_INS ',    sysdate,    '',    '');


end;
END METER_CHANGE_COMPUTE;

/
--------------------------------------------------------
--  DDL for Procedure METER_CHANGE_TABLE_INS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."METER_CHANGE_TABLE_INS" (v_r_month varchar2,v_r_year varchar2,ten_1_ss number) AS 
--create or replace PROCEDURE METER_CHANGE_TABLE_INS(v_sc_no varchar2,v_r_month varchar2,v_r_year varchar2,ten_1_ss number) AS 

--this procedure is to merge data from three tables to aid in meter change
--1.T_METER_READING_HDR
--2.T_METER_READING_SLOT
--3.T_HIS_MASTER_METER_CHANGE(This table comes from AMR)

--two sub procedures - METER_CHANGE_TABLE_INS_SUB & METER_CHANGE_COMPUTE are called in this procedure
--The procedure requires following parameters :
--v_r_month varchar2 : reading month
--v_r_year varchar2 : reading year
--ten_1_ss number : 0- not 10_1, 1- means its a 10_1_ss ; 


BEGIN
DECLARE 

  v_log_result VARCHAR2(100);
 -- v_meter_id varchar2(50) := '303830';v_new_meter_no varchar2(50) := 'HT2180034';
v_new_meter_no varchar2(50) := ''; v_m_company_meter_id varchar2(50) := '';
  v_r_prev_month varchar2(50):='';  v_r_prev_year varchar2(50):=''; 
  v_result_code  varchar2(50):='FAILURE';
v_sc_no varchar2(15):='';
  v_modifydate date:='';v_oldmeterno varchar2(50):=''; v_oldikwhtod1 varchar2(50):='';v_oldikwhtod2 varchar2(50):='';
  v_oldikwhtod3 varchar2(50):='';v_oldikwhtod4 varchar2(50):='';v_oldikwhtod5 varchar2(50):='';v_oldekwhtod1 varchar2(50):='';
  v_oletkwhtod2 varchar2(50):='';v_oldekwhtod3 varchar2(50):='';v_oldekwhtod4 varchar2(50):='';
  v_oldekwhtod5 varchar2(50):='';v_oldikvah varchar2(50):='';v_oldkvarh varchar2(50):='';v_oldmf  varchar2(50):='';
  v_newmeterno varchar2(50):=''; v_newikwhtod1 varchar2(50):='';v_newikwhtod2 varchar2(50):='';
  v_newikwhtod3 varchar2(50):='';v_newikwhtod4 varchar2(50):='';v_newikwhtod5 varchar2(50):='';v_newekwhtod1 varchar2(50):='';
  v_newekwhtod2 varchar2(50):='';v_newekwhtod3 varchar2(50):='';v_newekwhtod4 varchar2(50):='';
  v_newekwhtod5 varchar2(50):='';v_newikvah varchar2(50):='';v_newkvarh varchar2(50):='';v_newmf  varchar2(50):='';
v_loss_pc varchar2(50):='';

  begin

v_r_prev_month := v_r_month - 1;
if(v_r_prev_month = '0') then
    v_r_prev_month := '12';
    v_r_prev_year := v_r_year - 1;
else
    v_r_prev_year := v_r_year ;
end if;

 v_r_prev_month:=lpad(v_r_prev_month,2,0);


execute immediate 'truncate table r_meter_change';   
execute immediate 'truncate table r_meter_change_int';  
execute immediate 'truncate table r_int_meter_change';   

FOR loop_meter IN (SELECT "number",m_company_meter_id,meter_number FROM  v_company_service WHERE  "number" in ('059224760146'))

LOOP
  v_log_result := log_activity('PROCEDURE','METER_CHANGE_TABLE_INS','START','','','','', sysdate,'');

  v_sc_no := loop_meter."number";
  v_new_meter_no := loop_meter.meter_number;
  v_m_company_meter_id := loop_meter.m_company_meter_id;

--sys.dbms_output.put_line('SELECT "number",m_company_meter_id,meter_number FROM  v_company_service WHERE  "number" =v_sc_no');  
--SYS dbms_output.put_line('meter change ins');  
SYS.dbms_output.put_line('v_new_meter_no'||v_new_meter_no);
--SYS.-- dbms_output.put_line('v_r_month'||v_r_month);
--SYS.-- dbms_output.put_line('v_r_prev_month'||v_r_year);
--SYS.-- dbms_output.put_line('v_r_prev_year'||v_r_year);


 select modifydate,oldmeterno,oldikwhtod1,oldikwhtod2,oldikwhtod3,oldikwhtod4,oldikwhtod5,oldekwhtod1,oletkwhtod2,oldekwhtod3,oldekwhtod4,oldekwhtod5,
 oldikvah,oldq1kvarh+oldq2kvarh,oldmf,
 newmeterno, newikwhtod1,newikwhtod2,newikwhtod3,newikwhtod4,newikwhtod5,newekwhtod1,newekwhtod2,newekwhtod3,newekwhtod4,newekwhtod5,newikvah,newq1kvarh+newq2kvarh,newmf
 INTO 
 v_modifydate,v_oldmeterno,v_oldikwhtod1,v_oldikwhtod2,v_oldikwhtod3,v_oldikwhtod4,v_oldikwhtod5,v_oldekwhtod1,v_oletkwhtod2,v_oldekwhtod3,v_oldekwhtod4
 ,v_oldekwhtod5, v_oldikvah,v_oldkvarh,v_oldmf,
 v_newmeterno, v_newikwhtod1,v_newikwhtod2,v_newikwhtod3,v_newikwhtod4,v_newikwhtod5,v_newekwhtod1,v_newekwhtod2,v_newekwhtod3,v_newekwhtod4,v_newekwhtod5,
 v_newikvah,v_newkvarh,v_newmf
 FROM r_meter_change_from_amr WHERE newmeterno=v_new_meter_no;

-- sys.dbms_output.put_line('insert into r_meter_change values('||v_modifydate||','||v_oldmeterno||','||v_oldikwhtod1||','||v_oldikwhtod2||','||v_oldikwhtod3||','||v_oldikwhtod4||','||v_oldikwhtod5||','||v_oldekwhtod1||','||v_oletkwhtod2||','||v_oldekwhtod3||','||v_oldekwhtod4
--||','||v_oldekwhtod5||','||v_oldikvah||','||v_oldkvarh||','||v_oldmf||','||v_sc_no||'');
--  SYS.-- dbms_output.put_line('meter change ins : v_oldmeterno'||v_oldmeterno);
   insert into r_meter_change values(v_modifydate,v_oldmeterno,v_oldikwhtod1,v_oldikwhtod2,v_oldikwhtod3,v_oldikwhtod4,v_oldikwhtod5,v_oldekwhtod1,v_oletkwhtod2,v_oldekwhtod3,v_oldekwhtod4
 ,v_oldekwhtod5,v_oldikvah,v_oldkvarh,v_oldmf,v_sc_no);

  insert into r_meter_change values(v_modifydate,v_newmeterno,v_newikwhtod1,v_newikwhtod2,v_newikwhtod3,v_newikwhtod4,v_newikwhtod5,v_newekwhtod1,v_newekwhtod2,v_newekwhtod3,v_newekwhtod4
 ,v_newekwhtod5,v_newikvah,v_newkvarh,v_newmf,v_sc_no);

---entering reading particulars for OLD AND NEW METER----------
    meter_change_table_ins_sub(v_m_company_meter_id,v_oldmeterno,v_r_prev_month,v_r_prev_year,v_sc_no);
    meter_change_table_ins_sub(v_m_company_meter_id,v_newmeterno,v_r_month,v_r_year,v_sc_no);

           if(ten_1_ss = '1') then
       select loss_percent into v_loss_pc from t_substation_loss where m_substation_id=(select m_substation_id from v_company_service where "number"=v_sc_no) and month=v_r_month
       and year=v_r_year;
       end if;
    Meter_change_compute(v_sc_no,v_r_month,v_r_year,v_loss_pc);



   END LOOP; 

     end;
END METER_CHANGE_TABLE_INS;

/
--------------------------------------------------------
--  DDL for Procedure METER_CHANGE_TABLE_INS_SUB
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."METER_CHANGE_TABLE_INS_SUB" (v_m_company_meter_id varchar2,v_meter_no varchar2,v_r_month varchar2,v_r_year varchar2,v_sc_no varchar2 ) AS 
BEGIN
--makes use of an intermediate array for merging slot data 079204721346	295443	190037880
--this proc is called from METER_CHANGE_TABLE_INS proc
DECLARE
type type1 is table of VARCHAR2(50 BYTE);
  type data_type is table of type1;
  slot_array data_type;
    v_m_reading_hdr_id varchar2(50):='';      i number;      v_mf_ins varchar2(50):='';
    v_mf varchar2(50):='';        v_fin_rdg_date date:='';          v_imp_kvah_final varchar2(100):='';
    v_imp_rkvah_final varchar2(100):=''; 

BEGIN
SYS.dbms_output.put_line('METER_CHANGE_TABLE_INS_SUB');  
SYS.dbms_output.put_line('v_m_company_meter_id'||v_m_company_meter_id);
SYS.dbms_output.put_line('v_meter_no'||v_meter_no);
SYS.dbms_output.put_line('v_r_month'||v_r_month);
SYS.dbms_output.put_line('v_r_year'||v_r_year);

select id into v_m_reading_hdr_id from t_meter_reading_hdr where  m_company_meter_id=v_m_company_meter_id 
 and reading_month=v_r_month and reading_year=v_r_year;

   slot_array := data_type();
  slot_array.extend(5);
  for i in 1..5 loop
    slot_array(i) := type1();
    slot_array(i).extend(4);
    for j in 1..4 loop
         slot_array(i)(j) := 0; 
       end loop;
    end loop;

   i := 1;
  --SLOT DATA IMPORTED INTO AN ARRAY - 
   --fetch slot data and populate an 5x4 array 
  for slt_var in (select slot_code,imp_final,exp_final from T_METER_READING_HDR mrh,T_METER_READING_SLOT mrs
  where mrh.id=mrs.T_METER_READING_HDR_ID
  and mrs.T_METER_READING_HDR_ID=v_m_reading_hdr_id order by slot_code)loop
    slot_array(i).extend(2);
    slot_array(i)(1) := round(slt_var.imp_final,2); 
    slot_array(i)(2) := round(slt_var.exp_final,2);
--   SYS.-- dbms_output.put_line(slot_array(i)(1));
--    SYS.-- dbms_output.put_line(slot_array(i)(2));
         i := i+1;
     end loop;

     --===========================INSERTION OF FIRST & LAST RECORD(FINAL READING DATA OF OLD & NEW)=========================================
-- for i in 1..5 loop
--    for j in 1..4 loop
--        SYS.-- dbms_output.put_line('slot array i: ' ||i ||' j : '||j  ||' val : '||slot_array(i)(j));
--         end loop;
--    end loop;

 select mf,final_reading_dt,round(imp_kvah_final,2),round(imp_rkvah_final,2) 
      into v_mf,v_fin_rdg_date,v_imp_kvah_final,v_imp_rkvah_final 
      from t_meter_reading_hdr where m_company_meter_id=v_m_company_meter_id and id=v_m_reading_hdr_id;


       insert into r_meter_change values(v_fin_rdg_date,v_meter_no,slot_array(1)(1),slot_array(2)(1),slot_array(3)(1),slot_array(4)(1),slot_array(5)(1),
      slot_array(1)(2),slot_array(2)(2),slot_array(3)(2),slot_array(4)(2),slot_array(5)(2),v_imp_kvah_final,v_imp_rkvah_final,v_mf,v_sc_no);
 end;     
END METER_CHANGE_TABLE_INS_SUB;

/
--------------------------------------------------------
--  DDL for Procedure MY_INC_SURPLUS_UNIT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."MY_INC_SURPLUS_UNIT" AS
    v_htsurcursor sys_refcursor ;
    v_adj_unit ht_0420_netsurp%ROWTYPE;
    v_total_loss VARCHAR2(200);
    v_drawl_code VARCHAR2(200); 
    v_inj_code VARCHAR2(200); 
    v_inj_units number; 
    v_trans_loss VARCHAR2(200); 
    v_dis_loss VARCHAR2(200); 
    v_drawl_units  number; 
    v_comp_id VARCHAR2(200); 
    v_bank_service_id VARCHAR2(200); 
    v_banking_count VARCHAR2(50); 
    v_inj_units1 VARCHAR2(200); 
    v_inj_units2 VARCHAR2(200); 
    v_inj_units3 VARCHAR2(200); 
    v_inj_units4 VARCHAR2(200); 
    v_inj_units5 VARCHAR2(200); 
    v_reason VARCHAR2(300);
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);

  BEGIN
  bEGIN
        OPEN v_htsurcursor for select * from ht_0420_netsurp;
    LOOP
    FETCH v_htsurcursor INTO v_adj_unit;
    EXIT WHEN v_htsurcursor%NOTFOUND;

      SELECT voltage_code INTO v_inj_code FROM m_company_service WHERE "number"=v_adj_unit.SELLERSERVICENO;
      SELECT voltage_code INTO v_drawl_code FROM m_company_service WHERE "number"=v_adj_unit.BUYERSERVICENO;
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC
(v_inj_code,v_drawl_code,v_adj_unit.SURPLUSC1,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units1);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC
(v_inj_code,v_drawl_code,v_adj_unit.SURPLUSC2,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units2);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC
(v_inj_code,v_drawl_code,v_adj_unit.SURPLUSC3,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units3);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC
(v_inj_code,v_drawl_code,v_adj_unit.SURPLUSC4,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units4);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC
(v_inj_code,v_drawl_code,v_adj_unit.SURPLUSC5,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units5);


      UPDATE ht_0420_netsurp SET C1NET=round(nvl(v_inj_units1,0),0),C2NET=round(nvl(v_inj_units2,0),0),
             C3NET=round(nvl(v_inj_units3,0),0),C4NET=round(nvl(v_inj_units4,0),0),C5NET=round(nvl
(v_inj_units5,0),0)  WHERE ID = v_adj_unit.ID;
    END LOOP;

      exception
        when others then
                    -- dbms_output.put_line('ERROR');
       END;
    COMMIT;
  END mY_INC_SURPLUS_UNIT;


/
--------------------------------------------------------
--  DDL for Procedure PP_DATE_UPD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."PP_DATE_UPD" 
is
wgrp varchar2(10):=null;
begin
--for i in (select pp.m_service_id,pp.COMMISSION_DATE from M_POWERPLANT pp,m_company_service cs 
--where pp.m_service_id=cs.id and cs.flow_type_code ='STB')  
for i in (select pp.m_service_id,pp.COMMISSION_DATE from M_POWERPLANT pp,m_company_service cs 
where pp.m_service_id=cs.id and cs.flow_type_code !='STB' and pp.commission_date > '01-01-12'
)  
loop
--select weg_group_code into wgrp from m_tariff
--where i.commission_date between from_date and to_date;
select weg_group_code into wgrp from m_tariff
where i.commission_date between from_date and to_date and lower(type) like '%wind%' and remarks = 'WITHOUT AD';
insert into r_weg_code_update values (i.m_service_id,i.COMMISSION_DATE,wgrp);
--update m_powerplant set PLANT_CLASS_TYPE_CODE=wgrp where m_service_id=i.m_service_id ;
end loop;
end;


/
--------------------------------------------------------
--  DDL for Procedure PROCESS_SANC_QUAN_FOR_FF
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."PROCESS_SANC_QUAN_FOR_FF" (in_remarks in varchar2, out_result out varchar2) IS
v_sum number;
v_quantum number;
v_no_of_days number;
  BEGIN
select to_number(add_months(trunc(sysdate,'MM'),1) - trunc(sysdate,'MM')) into v_no_of_days from dual;

    for sin in(select * from m_signup where remarks=in_remarks)
    loop
        v_quantum:=(to_number(sin.SANCTIONED_QUANTUM)*1000*v_no_of_days*24);
        for imp in(select sum(c1) c1, sum(c2) c2 , sum(c3) c3, sum(c4) c4, sum(c5) c5 from import_trade_rel 
        where remarks=sin.remarks and seller_company_service_no = sin.HTSC_NUMBER group by seller_company_service_no)
        loop
            v_sum := to_number(imp.c1+imp.c2+imp.c3+imp.c4+imp.c5);
--            if (v_quantum <= v_sum) then
            if (v_sum <= v_quantum) then
            out_result:= 'valid_ff_data';
            update import_trade_rel set import_remarks='valid_ff_data' 
            where remarks=sin.remarks and seller_company_service_no = sin.HTSC_NUMBER;
            update m_signup set import_remarks='valid_ff_data' where remarks=in_remarks and HTSC_NUMBER=sin.HTSC_NUMBER;
            else
            out_result:='not_valid_ff_data';
            update import_trade_rel set import_remarks='not_valid_ff_data' 
            where remarks=sin.remarks and seller_company_service_no = sin.HTSC_NUMBER;
            update m_signup set import_remarks='not_valid_ff_data' where remarks=in_remarks and HTSC_NUMBER=sin.HTSC_NUMBER;
            end if;
        end loop;
      end loop;  
END PROCESS_SANC_QUAN_FOR_FF;


/
--------------------------------------------------------
--  DDL for Procedure PROCPRINTHELLOWORLD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."PROCPRINTHELLOWORLD" 
IS
BEGIN

  DBMS_OUTPUT.PUT_LINE('Hello World!');

END;

exec procPrintHelloWorld;

/
--------------------------------------------------------
--  DDL for Procedure R_LOSS_CALC
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_LOSS_CALC" (v_remarks varchar2) 
--select id into v_m_reading_hdr_id from t_meter_reading_hdr where  m_company_meter_id=v_m_company_meter_id 
-- and reading_month=v_r_month and reading_year=v_r_year;
AS 
BEGIN

DECLARE
    v_total_loss VARCHAR2(200); 
    v_drawl_code VARCHAR2(200); 
    v_inj_code VARCHAR2(200); 
    v_trans_loss VARCHAR2(200); 
    v_dis_loss VARCHAR2(200); 
    v_inj_units1 VARCHAR2(200); 
    v_inj_units2 VARCHAR2(200); 
    v_inj_units3 VARCHAR2(200); 
    v_inj_units4 VARCHAR2(200); 
    v_inj_units5 VARCHAR2(200); 
    v_service_no varchar2(15);
    v_supplier_no varchar2(20);
    v_c1 varchar2(10);v_c2 VARCHAR2(10);v_c3 VARCHAR(10);v_c4 VARCHAR(10);v_c5 VARCHAR(10);


-- SELECT COUNT(*) INTO v_sellerCount FROM M_COMPANY_SERVICE WHERE "number"=v_r_buyer;
-- SELECT COUNT(*) INTO v_buyerCount FROM M_COMPANY_SERVICE WHERE "number"=v_r_seller;
--SERVICE_NO
--SUPLR_CODE
 begin

 select SERVICE_NO,SUPLR_CODE,c1,c2,c3,c4,c5 into v_service_no,v_supplier_no,v_c1,v_c2,v_c3,v_c4,v_c5 from r_energy_adjustment 
 where  remarks=v_remarks;

   SELECT voltage_code INTO v_inj_code FROM m_company_service WHERE "number"=v_supplier_no;
   SELECT voltage_code INTO v_drawl_code FROM m_company_service WHERE "number"=v_service_no;

      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_c1,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units1);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_c2,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units2);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_c3,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units3);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_c4,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units4);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_c5,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units5);

v_inj_units1 := round(v_inj_units1); v_inj_units2 := round(v_inj_units2); v_inj_units3 := round(v_inj_units3); 
v_inj_units4 := round(v_inj_units4); v_inj_units5 := round(v_inj_units5); 
update r_energy_adjustment set c1_withloss=v_inj_units1,c2_withloss=v_inj_units2,c3_withloss=v_inj_units3,c4_withloss=v_inj_units4,
c5_withloss=v_inj_units5 where remarks=v_remarks;

  end;
END R_LOSS_CALC;


/
--------------------------------------------------------
--  DDL for Procedure R_MC_COMP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_MC_COMP" (v_sc_no varchar2,v_r_month varchar2,v_r_year varchar2,ten_1_ss number)  AS 
BEGIN
 DECLARE 
 v_old_meter varchar2(50);v_new_meter varchar2(50);
 --v_sc_no varchar2(50):='0039224341047'; 
 --v_r_month varchar2(50):='01';  v_r_year varchar2(50):='2020';
 
 v_meterno varchar2(50):=''; v_ikwhc1_diff varchar2(50):='';v_ikwhc2_diff varchar2(50):='';
  v_ikwhc3_diff varchar2(50):='';v_ikwhc4_diff varchar2(50):='';v_ikwhc5_diff varchar2(50):='';
  v_ekwhc1_diff varchar2(50):='';
  v_ekwhc2_diff varchar2(50):='';v_ekwhc3_diff varchar2(50):='';v_ekwhc4_diff varchar2(50):='';
  v_ekwhc5_diff varchar2(50):='';v_ikvah_diff varchar2(50):='';v_kvarh_diff varchar2(50):='';v_mf  varchar2(50):='';
  
  v_ekwhc1_units varchar2(50):='';
  v_ekwhc2_units varchar2(50):='';v_ekwhc3_units varchar2(50):='';v_ekwhc4_units varchar2(50):='';
  v_ekwhc5_units varchar2(50):='';v_ikvah_units varchar2(50):='';v_kvarh_units varchar2(50):='';
  
     v_ikwhc1_units varchar2(50):='';
  v_ikwhc2_units varchar2(50):='';v_ikwhc3_units varchar2(50):='';v_ikwhc4_units varchar2(50):='';
  v_ikwhc5_units varchar2(50):='';
  
  v_exp_units varchar2(50):='';  v_imp_units varchar2(50):='';
   v_net_units varchar2(50):='';
   
    v_net_c1_units varchar2(50):='';
  v_net_c2_units varchar2(50):='';v_net_c3_units varchar2(50):='';v_net_c4_units varchar2(50):='';
  v_net_c5_units varchar2(50):='';
  
  v_rdg_date date:='';
  v_remarks varchar2(100);
  
  v_loss_frac number;v_loss_pc varchar2(50):='';
  
begin
execute immediate 'truncate table r_meter_change_int';  
execute immediate 'truncate table r_int_meter_change';   

 if(ten_1_ss = '1') then
       select loss_percent into v_loss_pc from t_substation_loss where m_substation_id=(select m_substation_id from v_company_service where "number"=v_sc_no) and month=v_r_month
       and year=v_r_year;
       end if;

select oldmeterno,newmeterno
into v_old_meter,v_new_meter
from r_meter_change_from_amr where newmeterno=
(SELECT meter_number FROM  v_company_service WHERE  "number" IN (v_sc_no))
;

--bad design of code -  to remove loop and change it
 FOR loop_mtr IN (
 select T1.reading_date,T1.m_company_meter_id,
round(t2.ikwhc1-t1.ikwhc1,3) as ikwhc1_diff ,round(t2.ikwhc2-t1.ikwhc2,3) as ikwhc2_diff,round(t2.ikwhc3-t1.ikwhc3,3) as ikwhc3_diff,round(t2.ikwhc4-t1.ikwhc4,3) as ikwhc4_diff,
round(t2.ikwhc5-t1.ikwhc5,3) as ikwhc5_diff,
round(t2.ekwhc1-t1.ekwhc1,3) as ekwhc1_diff,round(t2.ekwhc2-t1.ekwhc2,3)  as ekwhc2_diff,round(t2.ekwhc3-t1.ekwhc3,3) as ekwhc3_diff,
round(t2.ekwhc4-t1.ekwhc4,3) as ekwhc4_diff,
round(t2.ekwhc5-t1.ekwhc5,3) as ekwhc5_diff,
round(t2.kvah-t1.kvah,3) as kvah_diff,round(t2.kvarh-t1.kvarh,3) as kvarh_diff,t1.mf 
from r_meter_change T1
inner join r_meter_change T2
on T1.m_company_meter_id=T2.m_company_meter_id
and T2.reading_date>T1.reading_date and T1.m_company_meter_id in (v_old_meter,v_new_meter) and T1.sc_no = v_sc_no) loop
-- and T1.m_company_meter_id in (v_old_meter,v_new_meter)
--T1.m_company_meter_id in (v_new_meter)

v_ekwhc1_units := loop_mtr.ekwhc1_diff * loop_mtr.mf; v_ekwhc2_units := loop_mtr.ekwhc2_diff * loop_mtr.mf;v_ekwhc3_units := loop_mtr.ekwhc3_diff * loop_mtr.mf;
v_ekwhc4_units := loop_mtr.ekwhc4_diff * loop_mtr.mf;v_ekwhc5_units := loop_mtr.ekwhc5_diff * loop_mtr.mf;

--loss is applicable only for Exported units for 10_1 SS case
if(v_loss_pc>0) then
v_loss_frac:=v_loss_pc/100;
v_ekwhc1_units := v_ekwhc1_units - v_loss_frac*v_ekwhc1_units ; 
v_ekwhc2_units := v_ekwhc2_units - v_loss_frac*v_ekwhc2_units ; 
v_ekwhc3_units := v_ekwhc3_units - v_loss_frac*v_ekwhc3_units ; 
v_ekwhc4_units := v_ekwhc4_units - v_loss_frac*v_ekwhc4_units ; 
v_ekwhc5_units := v_ekwhc5_units - v_loss_frac*v_ekwhc5_units ;
end if;

v_ikwhc1_units := loop_mtr.ikwhc1_diff * loop_mtr.mf;v_ikwhc2_units := loop_mtr.ikwhc2_diff * loop_mtr.mf;v_ikwhc3_units := loop_mtr.ikwhc3_diff * loop_mtr.mf;
v_ikwhc4_units := loop_mtr.ikwhc4_diff * loop_mtr.mf;v_ikwhc5_units := loop_mtr.ikwhc5_diff * loop_mtr.mf;

--loop_mtr.imp_units :=loop_mtr.ikwhc1_units+loop_mtr.ikwhc2_units+loop_mtr.ikwhc3_units+loop_mtr.ikwhc4_units+loop_mtr.ikwhc5_units;

v_kvarh_units := loop_mtr.kvarh_diff *loop_mtr.mf;
v_ikvah_units := loop_mtr.kvah_diff * loop_mtr.mf;

--loop_mtr.net_units := loop_mtr.exp_units-loop_mtr.imp_units;

dbms_output.put_line('insert into r_meter_change_int values(loop_mtr.rdg_date,loop_mtr.meterno,loop_mtr.ikwhc1_units,loop_mtr.ikwhc2_units,loop_mtr.ikwhc3_units ,loop_mtr.ikwhc4_units,
  loop_mtr.ikwhc5_units, loop_mtr.ekwhc1_units , loop_mtr.ekwhc2_units,loop_mtr.ekwhc3_units ,loop_mtr.ekwhc4_units,
  loop_mtr.ekwhc5_units,loop_mtr.ikvah_units,loop_mtr.kvarh_units,loop_mtr.mf' );

insert into r_meter_change_int values(loop_mtr.reading_date,loop_mtr.m_company_meter_id,v_ikwhc1_units,v_ikwhc2_units,v_ikwhc3_units ,v_ikwhc4_units,
  v_ikwhc5_units, v_ekwhc1_units , v_ekwhc2_units,v_ekwhc3_units ,v_ekwhc4_units,
  v_ekwhc5_units,v_ikvah_units,v_kvarh_units,loop_mtr.mf,v_sc_no );
  
    end loop;
  
  --=========computing sum of old and new meter======= 
select sum(ikwhc1),
sum(ikwhc2),sum(ikwhc3),sum(ikwhc4),sum(ikwhc5),
sum(ekwhc1),sum(ekwhc2)  ,sum(ekwhc3),sum(ekwhc4),sum(ekwhc5),
sum(kvah) ,sum(kvarh) , sum(mf) 
into 
v_ikwhc1_units,v_ikwhc2_units,v_ikwhc3_units ,v_ikwhc4_units,
  v_ikwhc5_units, v_ekwhc1_units , v_ekwhc2_units,v_ekwhc3_units ,v_ekwhc4_units,
  v_ekwhc5_units,v_ikvah_units,v_kvarh_units,v_mf
  from r_meter_change_int
where m_company_meter_id in (v_old_meter,v_new_meter)  ;


    
    v_imp_units :=v_ikwhc1_units+v_ikwhc2_units+v_ikwhc3_units+v_ikwhc4_units+v_ikwhc5_units;
v_exp_units :=v_ekwhc1_units+v_ekwhc2_units+v_ekwhc3_units+v_ekwhc4_units+v_ekwhc5_units;
v_net_units := v_exp_units-v_imp_units;

if(v_net_units < 0) then
    v_net_units :=0;
end if;

  v_net_c1_units := v_ekwhc1_units-v_ikwhc1_units;
  v_net_c2_units :=v_ekwhc2_units-v_ikwhc2_units;
  v_net_c3_units  := v_ekwhc3_units-v_ikwhc3_units;v_net_c4_units  :=v_ekwhc4_units-v_ikwhc4_units;
  v_net_c5_units :=v_ekwhc5_units-v_ikwhc5_units;
  v_remarks:='MC-'||v_sc_no||'-'||sysdate;
  if (v_loss_pc > 0) then
  v_remarks:='MC-'||v_sc_no||'-loss-'||v_loss_pc||'-'||sysdate;
  end if;


INSERT INTO r_int_meter_change VALUES (    'id',    v_sc_no,    v_old_meter,    v_new_meter,    v_r_month, 
v_r_year,    v_imp_units,    v_exp_units,    v_kvarh_units,    v_net_units, 
v_remarks,    v_ikwhc1_units,    v_ikwhc2_units,    v_ikwhc3_units,
v_ikwhc4_units,    v_ikwhc5_units,    v_ekwhc1_units,    v_ekwhc2_units,    v_ekwhc3_units,    v_ekwhc4_units,
v_ekwhc5_units,    v_net_c1_units,    v_net_c2_units,    v_net_c3_units,    v_net_c4_units,    v_net_c5_units,
'',    'PROC METER_CHANGE_TABLE_INS ',    sysdate,    '',    '');
  
   
end;
END R_MC_COMP;

/
--------------------------------------------------------
--  DDL for Procedure R_MC_INP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_MC_INP" (v_r_month varchar2,v_r_year varchar2,ten_1_ss number)  AS 
BEGIN
DECLARE 

  v_log_result VARCHAR2(100);
 -- v_meter_id varchar2(50) := '303830';v_new_meter_no varchar2(50) := 'HT2180034';
v_new_meter_no varchar2(50) := ''; v_m_company_meter_id varchar2(50) := '';
  v_r_prev_month varchar2(50):='';  v_r_prev_year varchar2(50):=''; 
  
v_sc_no varchar2(15):='';
  v_modifydate date:='';v_oldmeterno varchar2(50):=''; v_oldikwhtod1 varchar2(50):='';v_oldikwhtod2 varchar2(50):='';
  v_oldikwhtod3 varchar2(50):='';v_oldikwhtod4 varchar2(50):='';v_oldikwhtod5 varchar2(50):='';v_oldekwhtod1 varchar2(50):='';
  v_oletkwhtod2 varchar2(50):='';v_oldekwhtod3 varchar2(50):='';v_oldekwhtod4 varchar2(50):='';
  v_oldekwhtod5 varchar2(50):='';v_oldikvah varchar2(50):='';v_oldkvarh varchar2(50):='';v_oldmf  varchar2(50):='';
  v_newmeterno varchar2(50):=''; v_newikwhtod1 varchar2(50):='';v_newikwhtod2 varchar2(50):='';
  v_newikwhtod3 varchar2(50):='';v_newikwhtod4 varchar2(50):='';v_newikwhtod5 varchar2(50):='';v_newekwhtod1 varchar2(50):='';
  v_newekwhtod2 varchar2(50):='';v_newekwhtod3 varchar2(50):='';v_newekwhtod4 varchar2(50):='';
  v_newekwhtod5 varchar2(50):='';v_newikvah varchar2(50):='';v_newkvarh varchar2(50):='';v_newmf  varchar2(50):='';
v_loss_pc varchar2(50):='';

  begin

v_r_prev_month := v_r_month - 1;
if(v_r_prev_month = '0') then
    v_r_prev_month := '12';
    v_r_prev_year := v_r_year - 1;
else
    v_r_prev_year := v_r_year ;
end if;
 
 v_r_prev_month:=lpad(v_r_prev_month,2,0);
 
 
execute immediate 'truncate table r_meter_change';   
 

FOR loop_meter IN (SELECT "number",m_company_meter_id,meter_number FROM  v_company_service WHERE  "number" in ('079494700400'))
LOOP
--  v_log_result := log_activity('PROCEDURE','METER_CHANGE_TABLE_INS','START','','','','', sysdate,'');
  
  v_sc_no := loop_meter."number";
  v_new_meter_no := loop_meter.meter_number;
  v_m_company_meter_id := loop_meter.m_company_meter_id;


 select modifydate,oldmeterno,oldikwhtod1,oldikwhtod2,oldikwhtod3,oldikwhtod4,oldikwhtod5,oldekwhtod1,oletkwhtod2,oldekwhtod3,oldekwhtod4,oldekwhtod5,
 oldikvah,oldq1kvarh+oldq2kvarh,oldmf,
 newmeterno, newikwhtod1,newikwhtod2,newikwhtod3,newikwhtod4,newikwhtod5,newekwhtod1,newekwhtod2,newekwhtod3,newekwhtod4,newekwhtod5,newikvah,newq1kvarh+newq2kvarh,newmf
 INTO 
 v_modifydate,v_oldmeterno,v_oldikwhtod1,v_oldikwhtod2,v_oldikwhtod3,v_oldikwhtod4,v_oldikwhtod5,v_oldekwhtod1,v_oletkwhtod2,v_oldekwhtod3,v_oldekwhtod4
 ,v_oldekwhtod5, v_oldikvah,v_oldkvarh,v_oldmf,
 v_newmeterno, v_newikwhtod1,v_newikwhtod2,v_newikwhtod3,v_newikwhtod4,v_newikwhtod5,v_newekwhtod1,v_newekwhtod2,v_newekwhtod3,v_newekwhtod4,v_newekwhtod5,
 v_newikvah,v_newkvarh,v_newmf
 FROM r_meter_change_from_amr WHERE newmeterno=v_new_meter_no;
  
 
    insert into r_meter_change values(v_modifydate,v_oldmeterno,v_oldikwhtod1,v_oldikwhtod2,v_oldikwhtod3,v_oldikwhtod4,v_oldikwhtod5,v_oldekwhtod1,v_oletkwhtod2,v_oldekwhtod3,v_oldekwhtod4
 ,v_oldekwhtod5,v_oldikvah,v_oldkvarh,v_oldmf,v_sc_no);
 
  insert into r_meter_change values(v_modifydate,v_newmeterno,v_newikwhtod1,v_newikwhtod2,v_newikwhtod3,v_newikwhtod4,v_newikwhtod5,v_newekwhtod1,v_newekwhtod2,v_newekwhtod3,v_newekwhtod4
 ,v_newekwhtod5,v_newikvah,v_newkvarh,v_newmf,v_sc_no);

---entering reading particulars for OLD AND NEW METER----------
    meter_change_table_ins_sub(v_m_company_meter_id,v_oldmeterno,v_r_prev_month,v_r_prev_year,v_sc_no);
  meter_change_table_ins_sub(v_m_company_meter_id,v_newmeterno,v_r_month,v_r_year,v_sc_no);
       

 
   END LOOP; 

     end;
END R_MC_INP;

/
--------------------------------------------------------
--  DDL for Procedure R_PP_DATE_UPD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_PP_DATE_UPD" 
is
wgrp varchar2(10):=null;

begin
--for i in (select pp.m_service_id,pp.COMMISSION_DATE from M_POWERPLANT pp,m_company_service cs 
--where pp.m_service_id=cs.id and cs.flow_type_code ='STB')  
for i in (select pp.m_service_id,pp.COMMISSION_DATE from M_POWERPLANT pp,m_company_service cs 
where pp.m_service_id=cs.id and cs.flow_type_code !='STB' 
AND pp.commission_date >= '01-04-18' AND pp.commission_date <= '31-03-21'
)  
loop
--SYS.dbms_output.put_line('service id  & year : '||i.m_service_id ||'*'||i.COMMISSION_DATE);
--select weg_group_code into wgrp from m_tariff
--where i.commission_date between from_date and to_date;
select weg_group_code into wgrp from r_tariff_wind
where i.commission_date between from_date and to_date  ;
--insert into r_weg_code_update values (i.m_service_id,i.COMMISSION_DATE,wgrp);

update m_powerplant set PLANT_CLASS_TYPE_CODE=wgrp where m_service_id=i.m_service_id ;
end loop;
end;

/
--------------------------------------------------------
--  DDL for Procedure R_UPDATE_BANK_BAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_UPDATE_BANK_BAL" AS 
BEGIN
FOR loop_upd IN (SELECT GEN_NUM,C1,C2,C3,C4,C5 FROM TO_UPDATE_LIST)
	LOOP
      update t_banking_balance set c1=LOOP_UPD.C1,c2=LOOP_UPD.C2,c3=LOOP_UPD.C3,c4=LOOP_UPD.C4,
      c5=LOOP_UPD.C5, REMARKS='BANKING-CORRECTED-MAIL-REV DT-1.2.20',
      curr_c1=LOOP_UPD.C1,curr_c2=LOOP_UPD.C2,curr_c3=LOOP_UPD.C3,curr_c4=LOOP_UPD.C4,curr_c5=LOOP_UPD.C5
      where 
      M_COMPANY_ID in
      (select M_COMPANY_ID from m_company_service where "number" =loop_upd.gen_num )
      and t_banking_balance.MONTH='01' and t_banking_balance.YEAR='2020';
 		END LOOP;
END R_UPDATE_BANK_BAL;


/
--------------------------------------------------------
--  DDL for Procedure R_UPDATE_METER_NO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_UPDATE_METER_NO" AS 
BEGIN
FOR loop_upd IN (SELECT oldmeterno,newmeterno FROM r_meter_change_from_amr )
	LOOP
--    update m_company_meter set meter_number=loop_upd.newmeterno , remarks=concat('MC-28-03-20',loop_upd.oldmeterno)
--where meter_number=loop_upd.oldmeterno;
 update m_company_meter set meter_number=loop_upd.newmeterno , remarks=concat('MYMC-31-05-21-old :',loop_upd.oldmeterno)
where meter_number=loop_upd.oldmeterno;
--update m_company_meter set meter_number=loop_upd.oldmeterno 
--where meter_number=loop_upd.newmeterno and remarks is NULL;
--change the date and save and run

 		END LOOP;
END R_UPDATE_METER_NO;

/
--------------------------------------------------------
--  DDL for Procedure R_UPDATE_MNS_STATUS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_UPDATE_MNS_STATUS" AS 
--procedure created to update status in m_powerplant table based on mail sent by AEE/IT/OA . 
--the previous status has been stored as backup in r_to_upd_mns_list_05
BEGIN
declare
v_old_st varchar2(5);
begin
FOR loop_upd IN (SELECT gen_no FROM r_to_upd_mns_list_05  )
	LOOP
select status into v_old_st from m_powerplant p, m_company_service c 
where m_service_id = c.id and "number" =loop_upd.gen_no;
 update r_to_upd_mns_list_05 set OLD_STATUS=v_old_st where gen_no=loop_upd.gen_no;

--rollbACK DONE BASED ON REQUEST by AEE/IT/OA
--UPDATE M_Powerplant SET status=loop_upd.old_status where 
--m_service_id in (select id from m_company_service where "number" =loop_upd.gen_no);

 --after updation this cmd run in editor window
-- UPDATE M_Powerplant SET status='MNS' where 
--m_service_id in (select id from m_company_service where "number" in (select gen_no from r_to_upd_mns_list_05));

 		END LOOP;
end;
END R_UPDATE_MNS_STATUS;


/
--------------------------------------------------------
--  DDL for Procedure R_UPDATE_SALE_ORDER_LINE_ID
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_UPDATE_SALE_ORDER_LINE_ID" (r_mon varchar2, r_yr VARCHAR2) AS 
BEGIN
declare
esol_id varchar2(10);
--r_mon varchar2(10);
--r_yr varchar2(10);
--,gen varchar2
begin
FOR loop_upd IN (select service_no,suplr_code,f_energy_sale_order_id ,f_energy_sale_order_line_id
from f_energy_adjustmet
where 
reading_mnth=r_mon and reading_yr=r_yr and
-- suplr_code=gen and
f_energy_sale_order_line_id is null    )
	LOOP
SYS.dbms_output.put_line('MON/yr'|| r_mon||'/'|| r_yr||  'gener : '||  loop_upd.suplr_code || ' buyer  : ' || loop_upd.service_no    );  

    select esol.id into esol_id from f_energy_sale_order eso,
f_energy_sale_order_lines esol
where eso.id = loop_upd.f_energy_sale_order_id
and esol.f_energy_sale_order_id = eso.id and
esol.d_buyer_comp_serv_name  = loop_upd.service_no 
and eso.month=r_mon and eso.year=r_yr;

    update f_energy_adjustmet ea set ea.f_energy_sale_order_line_id = esol_id,
    import_remarks = concat('SOL upd-18-06-20-old :',loop_upd.f_energy_sale_order_line_id)
where ea.f_energy_sale_order_id = loop_upd.f_energy_sale_order_id and
ea.service_no=loop_upd.service_no and ea.suplr_code = loop_upd.suplr_code and
ea.reading_mnth=r_mon  and ea.reading_yr=r_yr;
SYS.dbms_output.put_line('MON/yr'|| r_mon||'/'|| r_yr||  'gener : '||  loop_upd.suplr_code || ' buyer  : ' || loop_upd.service_no  ||'line id : '  || esol_id  );  

 		END LOOP;
        end;
END R_UPDATE_SALE_ORDER_LINE_ID;

/
--------------------------------------------------------
--  DDL for Procedure R_UPD_SEC_CODE_NAM
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."R_UPD_SEC_CODE_NAM" AS 
BEGIN
  FOR loop_upd IN (SELECT gen_no,section FROM r_to_upd_sec where substr(gen_no,6,3)='432'  )
	LOOP

-- update m_company_service set m_section_name=upper( loop_upd.section_name) 
--where m_section_name is null and m_section_id=loop_upd.id;

update m_company_Service set m_section_name=upper(loop_upd.section) where m_section_name is null and "number"=loop_upd.gen_no;
 		END LOOP;
END R_UPD_SEC_CODE_NAM;


/
--------------------------------------------------------
--  DDL for Procedure TEMP_MIGRATION_FILL_IDS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TEMP_MIGRATION_FILL_IDS" is
BEGIN

/*
update temp_technical_master set wg_htscno = substr(wg_htscno, 1, instr(wg_htscno, '.') -1);
update temp_commercial_master set wg_htscno = substr(wg_htscno, 1, instr(wg_htscno, '.') -1);
update temp_commercial_master set wg_circle = substr(wg_circle, 1, instr(wg_circle, '.') -1);
update temp_technical_master set circlecode = substr(circlecode, 1, instr(circlecode, '.') -1);
UPDATE TEMP_TECHNICAL_MASTER SET wg_Cod = to_char(to_Date(wg_Cod,'mm/dd/yyyy'),'yyyy-mm-dd');
update temp_technical_master set WG_CAP = substr(WG_CAP, 1, instr(WG_CAP, '.') -1);
update temp_technical_master set WG_ABTYN = 'Y' WHERE WG_ABTYN = 'YES';
update temp_technical_master set WG_ABTYN = 'N' WHERE WG_ABTYN = 'NO';
update temp_technical_master set WG_ACCLASS = '01' WHERE WG_ACCLASS = '0.2 CLASS';
update temp_technical_master set WG_ACCLASS = '02' WHERE WG_ACCLASS = '0.5 CLASS';
update temp_technical_master set WG_REC = 'Y' WHERE WG_REC = 'REC';
update temp_technical_master set WG_REC = 'N' WHERE WG_REC = 'Non-REC';
UPDATE TEMP_TECHNICAL_MASTER SET WG_ENTDATE = to_char(to_Date(WG_ENTDATE,'mm/dd/yyyy'),'yyyy-mm-dd');

UPDATE TEMP_COMMERCIAL_MASTER SET WG_DOA = to_char(SYSDATE-61,'mm/dd/yyyy') WHERE substr(WG_DOA, 1,1) = '-';
UPDATE TEMP_COMMERCIAL_MASTER SET WG_DOA = to_char(to_Date(WG_DOA,'mm/dd/yyyy'),'yyyy-mm-dd');


update TEMP_COMMERCIAL_MASTER set WG_CATEGORY = '02' WHERE WG_CATEGORY = 'Sale to TANGEDCO';
update TEMP_COMMERCIAL_MASTER set WG_CATEGORY = '04' WHERE WG_CATEGORY = 'Wheeling to third party';
update TEMP_COMMERCIAL_MASTER set WG_CATEGORY = '03' WHERE WG_CATEGORY = 'Wheeling for Captive Use';
update TEMP_COMMERCIAL_MASTER set WG_CATEGORY = '03,02' WHERE WG_CATEGORY = 'Wheeling for Captive use and balance monthly sales to TANGEDCO';
UPDATE TEMP_COMMERCIAL_MASTER SET WG_ENTDATE = to_char(to_Date(WG_ENTDATE,'mm/dd/yyyy'),'yyyy-mm-dd');


FOR i IN ( select distinct s.id,  s.name from m_substation s join  temp_technical_master t   on t.wg_ssname = s.name)
LOOP
  update temp_technical_master set m_substation_id = i.id where wg_ssname = i.name;
  update temp_commercial_master set m_substation_id = i.id where wg_ssname = i.name;
END LOOP;

FOR j IN ( select distinct f.id, f.name from m_feeder f join  temp_technical_master t   on t.wg_feedname = f.name)
LOOP
  update temp_technical_master set m_feeder_id = j.id where wg_feedname = j.name;
  update temp_commercial_master set m_feeder_id = j.id where wg_feedname = j.name;
END LOOP;


--update wind pass code
FOR i IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'WIND_PASS_CODE')
LOOP
	UPDATE TEMP_TECHNICAL_MASTER SET  WG_PASS = i.VALUE_CODE WHERE WG_PASS= i.VALUE_DESC ;
END LOOP;

--update generator make code
FOR i IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'GENERATOR_MAKE_CODE')
LOOP
	UPDATE TEMP_TECHNICAL_MASTER SET  WG_MAKE = i.VALUE_CODE WHERE WG_MAKE= i.VALUE_DESC ;
END LOOP;


	--update voltage code
FOR i IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'VOLTAGE_CODE')
LOOP
	UPDATE TEMP_TECHNICAL_MASTER SET  WG_INCVOL = i.VALUE_CODE WHERE WG_INCVOL= i.VALUE_DESC ;
END LOOP;


	--update TALUK code
FOR i IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'TALUK_CODE')
LOOP
	UPDATE TEMP_TECHNICAL_MASTER SET  WG_TALUK = i.VALUE_CODE WHERE WG_TALUK= i.VALUE_DESC ;
END LOOP;
COMMIT;

   --update PLANT CLASS TYPE CODE
FOR i IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'PLANT_CLASS_TYPE_CODE')
LOOP
	UPDATE TEMP_COMMERCIAL_MASTER SET  WG_CLASS = i.VALUE_CODE WHERE WG_CLASS= i.VALUE_DESC ;
END LOOP;
COMMIT;



*/


update temp_technical_master set is_enabled = 'Y', remarks='beta data-migration' where m_company_id is not null and length(wg_meterno) > 3;

FOR i IN (select m_company_id from temp_technical_master where  m_company_id is not null and is_enabled = 'Y')
LOOP
	UPDATE TEMP_COMMERCIAL_MASTER SET is_enabled = 'Y', remarks='beta data-migration' WHERE m_company_id= i.m_company_id ;
END LOOP;
COMMIT;


END TEMP_MIGRATION_FILL_IDS;



/
--------------------------------------------------------
--  DDL for Procedure TEMP_MIGRATION_IMPORT1
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TEMP_MIGRATION_IMPORT1" is

v_company_id  VARCHAR2(50);
	v_service_id VARCHAR2(50);
	v_meter_id VARCHAR2(50);
	v_banking_service_id VARCHAR2(50);
	v_powerplant_id VARCHAR2(50);
	v_is_enabled CHAR(1):='Y';
	v_remarks VARCHAR2(200):='beta data-migration';

	v_buyer_company_id VARCHAR2(50);
	v_buyer_service_id VARCHAR2(50);
BEGIN
/*
	 *

	FOR  i IN (
	SELECT  c.wg_ssname, c.wg_feedname,c.M_ORG_ID, c.wg_htscno,
		(CASE WHEN length(t.WG_METERNO) < 3  THEN null ELSE t.WG_METERNO END) AS meter_no
		FROM TEMP_COMMERCIAL_MASTER c JOIN
		temp_technical_master t ON t.wg_ssname = c.wg_ssname AND t.wg_feedname=c.wg_feedname AND t.wg_htscno = c.wg_htscno
		 ORDER BY c.M_SUBSTATION_ID, c.M_FEEDER_ID,c.M_ORG_ID, c.wg_htscno
	)
	LOOP
		SELECT 'COM-'||m_company_seq.nextval INTO v_company_id FROM dual;
		SELECT 'SR-'||m_company_serv_seq.nextval INTO v_service_id FROM dual;
		SELECT round(dbms_random.value() * 8) + 1  INTO v_meter_id FROM dual;
		--SELECT 'BG-'||m_company_serv_seq.nextval INTO v_banking_service_id FROM dual;
		--SELECT 'PP-'||m_powerplant_seq.nextval INTO v_powerplant_id FROM dual;

		IF (i.meter_no IS null) THEN
			v_is_enabled := 'N';
			v_remarks := 'beta data-migration ,No Meter';
	    else
	      	v_is_enabled := 'Y';
			v_remarks := 'beta data-migration';
		END IF;

		UPDATE temp_commercial_master SET M_COMPANY_ID = v_company_id, M_SERVICE_ID=v_service_id , is_enabled=v_is_enabled, remarks= v_remarks, MODIFIED_DATE = SYSDATE
		WHERE  wg_htscno = i.wg_htscno AND wg_ssname = i.wg_ssname AND wg_feedname = i.wg_feedname;

		UPDATE temp_technical_master SET M_COMPANY_ID = v_company_id, M_SERVICE_ID=v_service_id , is_enabled=v_is_enabled, remarks= v_remarks , MODIFIED_DATE = SYSDATE
		WHERE wg_htscno = i.wg_htscno AND wg_ssname = i.wg_ssname AND wg_feedname = i.wg_feedname;

		UPDATE TEMP_HT_ADJUSTMENT_MASTER SET BUYER_COMPANY_ID = v_company_id, BUY_SERVICE_ID=v_service_id , is_enabled=v_is_enabled , remarks= v_remarks, MODIFIED_DATE = SYSDATE
		WHERE wfwind_gencircle = i.M_ORG_ID AND wfwind_genservice = i.wg_htscno;

		UPDATE TEMP_HT_ADJUSTMENT_MASTER SET SELLER_COMPANY_ID = v_company_id, SELL_SERVICE_ID=v_service_id
		WHERE wfwind_edccircle = i.M_ORG_ID AND wfwind_edcservice = i.wg_htscno;

	END LOOP;


INSERT INTO M_COMPANY (id, code, name, TYPE, IS_CAPTIVE, ENABLED, CREATED_BY, CREATED_DATE, REMARKS)
SELECT c.M_COMPANY_ID AS id, c.M_COMPANY_ID AS code, nvl(t.WG_NAMETIEUP,'Empty') AS name, '05' AS TYPE,
DECODE(SUBSTR(c.WG_CATEGORY,1,2),'03','Y','N') AS IS_CAPTIVE, c.is_enabled enabled, 'admin' AS CREATED_BY,to_date('2017-08-24','yyyy-mm-dd') AS CREATED_DATE,
c.remarks
FROM TEMP_commercial_MASTER c JOIN TEMP_TECHNICAL_MASTER t ON c.WG_CIRCLE = t.CIRCLECODE AND c.WG_SSNAME = t.WG_SSNAME AND c.WG_FEEDNAME = t.WG_FEEDNAME AND c.WG_HTSCNO = t.WG_HTSCNO;


INSERT INTO M_COMPANY_SERVICE(id, TYPE, "number", M_COMPANY_ID, M_ORG_ID, M_SUBSTATION_ID, M_FEEDER_ID, REF_NUMBER, VOLTAGE_CODE, TOTAL_CAPACITY, ENABLED, CREATED_BY, CREATED_DATE, remarks)
SELECT c.M_SERVICE_ID AS id, '03' as "TYPE",c.M_SERVICE_ID  "NUMBER", c.M_COMPANY_ID, c.M_ORG_ID, t.M_SUBSTATION_ID, t.M_FEEDER_ID, NULL "REF_NUMBER",t.WG_INCVOL AS voltage_code ,to_number(t.WG_NOUNITS)*to_number(t.WG_CAP) AS total_capacity,
c.is_enabled enabled, 'admin' AS CREATED_BY,to_date('2017-08-24','yyyy-mm-dd') AS CREATED_DATE,c.remarks
FROM TEMP_commercial_MASTER c JOIN TEMP_TECHNICAL_MASTER t ON c.WG_CIRCLE = t.CIRCLECODE AND c.WG_SSNAME = t.WG_SSNAME AND c.WG_FEEDNAME = t.WG_FEEDNAME AND c.WG_HTSCNO = t.WG_HTSCNO;


INSERT INTO M_COMPANY_SERVICE(id, TYPE, "number", M_COMPANY_ID,  ENABLED, CREATED_BY, CREATED_DATE, remarks)
SELECT 'BG-'||m_company_serv_seq.nextval  AS id, '01' as "TYPE",'BG-'||m_company_serv_seq.currval  "NUMBER", c.M_COMPANY_ID,
c.is_enabled enabled, 'admin' AS CREATED_BY,to_date('2017-08-24','yyyy-mm-dd') AS CREATED_DATE,c.remarks
FROM TEMP_commercial_MASTER c JOIN TEMP_TECHNICAL_MASTER t ON c.WG_CIRCLE = t.CIRCLECODE AND c.WG_SSNAME = t.WG_SSNAME AND c.WG_FEEDNAME = t.WG_FEEDNAME AND c.WG_HTSCNO = t.WG_HTSCNO;

INSERT INTO M_COMPANY_METER (id, M_COMPANY_SERVICE_ID, METER_NUMBER, METER_MAKE_CODE, ACCURACY_CLASS_CODE, IS_ABTMETER, MF,CREATED_BY, CREATED_DATE, REMARKS)
SELECT rownum id, c.M_SERVICE_ID M_COMPANY_SERVICE_ID, (CASE WHEN length(t.WG_METERNO) < 3  THEN 'Empty' ELSE t.WG_METERNO END)  METER_NUMBER,
t.WG_MAKE meter_make_code, t.WG_ACCLASS accuracy_class_code, t.WG_ABTYN is_abtmeter, NULL mf, 'admin' AS CREATED_BY,to_date('2017-08-24','yyyy-mm-dd') AS CREATED_DATE, c.remarks
FROM TEMP_commercial_MASTER c JOIN TEMP_TECHNICAL_MASTER t ON c.WG_CIRCLE = t.CIRCLECODE AND c.WG_SSNAME = t.WG_SSNAME AND c.WG_FEEDNAME = t.WG_FEEDNAME AND c.WG_HTSCNO = t.WG_HTSCNO;




 FOR  i IN (
	SELECT 'PP-'||m_powerplant_seq.nextval  AS id,'PP-'||m_powerplant_seq.currval  code, 'PP-'||m_powerplant_seq.currval||' - '||t.WG_NAMETIEUP name,
	'02' plant_type_Code, '02' fuel_type_code, c.M_SERVICE_ID, c.M_ORG_ID, to_number(t.WG_NOUNITS)*to_number(t.WG_CAP) AS total_capacity, t.M_SUBSTATION_ID, t.WG_INCVOL VOLTAGE_CODE,
	to_date(t.wg_cod, 'yyyy-mm-dd') COMMISSION_DATE, t.WG_PASS wind_pass_code, 'Y' enabled, 'Active' status, 'admin' AS CREATED_BY,to_date('2017-08-24','yyyy-mm-dd') AS CREATED_DATE, c.remarks ,
	t.WG_NOUNITS no_of_units, t.WG_MAKE MAKE_CODE, t.WG_CAP capacity, t.CIRCLECODE , t.WG_SSNAME, t.WG_FEEDNAME, t.WG_HTSCNO
	FROM TEMP_commercial_MASTER c JOIN TEMP_TECHNICAL_MASTER t ON c.WG_CIRCLE = t.CIRCLECODE AND c.WG_SSNAME = t.WG_SSNAME AND c.WG_FEEDNAME = t.WG_FEEDNAME AND c.WG_HTSCNO = t.WG_HTSCNO
	)
 LOOP
  UPDATE TEMP_TECHNICAL_MASTER SET m_powerplant_id = i.id where circlecode = i.CIRCLECODE AND WG_SSNAME = i.WG_SSNAME AND WG_FEEDNAME = i.WG_FEEDNAME AND WG_HTSCNO = i.WG_HTSCNO;

  INSERT INTO M_POWERPLANT(id, code, name, PLANT_TYPE_CODE, FUEL_TYPE_CODE, M_SERVICE_ID, M_ORG_ID, TOTAL_CAPACITY, M_SUBSTATION_ID, INTERFACE_VOLTAGE_FREQUENCY,
 COMMISSION_DATE, WIND_PASS_CODE,  ENABLED, STATUS, CREATED_BY, CREATED_DATE, REMARKS)
VALUES (i.id, i.code, i.name, i.PLANT_TYPE_CODE, i.FUEL_TYPE_CODE, i.M_SERVICE_ID, i.M_ORG_ID, i.TOTAL_CAPACITY, i.M_SUBSTATION_ID, i.VOLTAGE_CODE,
 i.COMMISSION_DATE, i.WIND_PASS_CODE,  i.ENABLED, i.STATUS, i.CREATED_BY, i.CREATED_DATE, i.REMARKS);

 INSERT INTO M_GENERATOR(id, M_POWERPLANT_ID, NO_OF_UNITS, MAKE_CODE, CAPACITY, VOLTAGE_CODE, ENABLED,  CREATED_BY, CREATED_DATE,REMARKS )
 VALUES (i.id, i.id, i.NO_OF_UNITS, i.MAKE_CODE, i.CAPACITY, i.VOLTAGE_CODE, i.ENABLED, i.CREATED_BY, i.CREATED_DATE, i.REMARKS);


 end loop;


UPDATE TEMP_HT_ADJUSTMENT_MASTER h
SET (SELLER_COMPANY_ID, SELL_SERVICE_ID) = (SELECT m_company_id, m_service_id  FROM TEMP_COMMERCIAL_MASTER c WHERE h.WFWIND_GENCIRCLE = c.M_ORG_ID AND h.WFWIND_GENSERVICE = c.WG_HTSCNO)
WHERE EXISTS(
	SELECT 1 FROM TEMP_COMMERCIAL_MASTER c WHERE h.WFWIND_GENCIRCLE = c.M_ORG_ID AND h.WFWIND_GENSERVICE = c.WG_HTSCNO);

	UPDATE TEMP_HT_ADJUSTMENT_MASTER h
SET (BUYER_COMPANY_ID, BUY_SERVICE_ID) = (SELECT m_company_id, m_service_id  FROM TEMP_COMMERCIAL_MASTER c WHERE h.WFWIND_EDCCIRCLE = c.M_ORG_ID AND h.WFWIND_EDCSERVICE = c.WG_HTSCNO)
WHERE EXISTS(
	SELECT 1 FROM TEMP_COMMERCIAL_MASTER c WHERE h.WFWIND_EDCCIRCLE = c.M_ORG_ID AND h.WFWIND_EDCSERVICE = c.WG_HTSCNO);


INSERT INTO OPENACCESS.M_TRADE_RELATIONSHIP
(ID, QUANTUM, FROM_DATE, TO_DATE, STATUS_CODE, M_SELLER_COMPANY_ID, M_SELLER_COMP_SERVICE_ID, M_BUYER_COMPANY_ID, M_BUYER_COMP_SERVICE_ID, REFERENCENUMBER, CREATED_BY, CREATED_DATE, REMARKS)
SELECT rownum id, NULL quantum, to_date(c.WG_DOA,'yyyy-mm-dd') FROM_DATE, NULL to_date, decode(c.IS_ENABLED, 'N', '01', '02') status_code,
h.SELLER_COMPANY_ID M_SELLER_COMPANY_ID, h.SELL_SERVICE_ID M_SELLER_COMP_SERVICE_ID, h.BUYER_COMPANY_ID M_BUYER_COMPANY_ID, h.BUY_SERVICE_ID M_BUYER_COMP_SERVICE_ID, NULL REFERENCENUMBER,
 'admin' AS CREATED_BY,to_date('2017-08-24','yyyy-mm-dd') AS CREATED_DATE, c.remarks
FROM TEMP_HT_ADJUSTMENT_MASTER h, TEMP_COMMERCIAL_MASTER c WHERE h.WFWIND_genCIRCLE = c.M_ORG_ID AND h.WFWIND_genSERVICE = c.WG_HTSCNO;

 */
	NULL;

END TEMP_MIGRATION_IMPORT1;




/
--------------------------------------------------------
--  DDL for Procedure TEN_ONE_SS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TEN_ONE_SS" 
(
  M_SUBSTATION_ID IN VARCHAR2 
, M_ORG_ID IN VARCHAR2 
) AS 
BEGIN
NULL;

  
END TEN_ONE_SS;

/
--------------------------------------------------------
--  DDL for Procedure TMP_BB_04_2019_UPDATE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_BB_04_2019_UPDATE" is
v_result VARCHAR2(100);
v_log_result VARCHAR2(100);
O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
v_banking_service_id varchar(50);
v_allotment_count number:=0;
v_curr_month_bb_count number:=0;
v_bb_new T_BANKING_BALANCE%ROWTYPE;
BEGIN 
 v_log_result := log_activity('PROCEDURE','TMP_bb_04_2019_update','START','','','','','', sysdate,'');
 
 for bb in (select * from t_banking_balance where month='05' and year='2019')
  loop
  
--  v_log_result := log_activity('PROCEDURE','TMP_bb_04_2019_update','End',o_result_desc,'','', sysdate,'');
  
-- update  t_banking_balance set remarks='tmp_bb_04_2019_update',curr_c1=bb.c1,curr_c2=bb.c2,curr_c3=bb.c3,curr_c4=bb.c4,curr_c5=bb.c5,modified_by='tmp_bb_04_2019_update',modified_dt=sysdate where m_company_id = bb.m_company_id and month='04' and year='2019';
  end loop;  
 
  
 v_log_result := log_activity('PROCEDURE','TMP_bb_04_2019_update','End',o_result_desc,'','', sysdate,'');
END TMP_bb_04_2019_update;

/
--------------------------------------------------------
--  DDL for Procedure TMP_CALL_BB_FOR_CONFIRM_ES
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_CALL_BB_FOR_CONFIRM_ES" is
v_result VARCHAR2(100);

O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
BEGIN 

  for service in (select  distinct ser.id,ser.banking_service_id  from T_BANKING_BALANCE bb 
                          inner join v_company_service ser on bb.banking_Service_id=ser.banking_Service_id)
  loop
   update T_BANKING_BALANCE set curr_c1 = c1, curr_c2=c2, curr_c3=c3, curr_c4=c4, curr_c5=c5  where banking_service_id = service.banking_service_id;
   for pendin_es in (select id from t_energy_sale es where seller_comp_serv_id = service.id
                    fetch first 1 rows only)
    loop
           BANKING_BALANCE.confirm_energy_sale_event(pendin_es.id,O_RESULT_CODE,O_RESULT_DESC);
    end loop;
  end loop;

  commit;

END TMP_CALL_BB_FOR_CONFIRM_ES;


/
--------------------------------------------------------
--  DDL for Procedure TMP_CALL_OPEN_BB
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_CALL_OPEN_BB" is
v_result VARCHAR2(100);

O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
v_banking_service_id varchar(50);
v_allotment_count number:=0;
BEGIN 


-------- create bb for the  service numbers for whom bb is not available for month= '02', and not allocated
--1) set curr_c1..c5 as 0 if negative
--2) delete any txn except mr for that service in month-02
--3) once loop completes, run create-gs

    --fetch service numbers for whom bb is not available for month= '02', and not allocated
  for service in ( 
                    select "number" d_sell_comp_serv_number from m_company_service where banking_service_id in 
                    (select banking_service_id from t_banking_balance where month = '01'
                    minus
                    select banking_service_id from t_banking_balance where month = '02')
                    minus
                    select d_sell_comp_serv_number from f_energy_sale_order where month='02' and d_sell_comp_serv_number in 
                    --select disp_service_number from t_gen_stmt where status_code='CREATED' and stmt_month='02' and disp_service_number in
                    (
                    select "number" from m_company_service where banking_service_id in 
                    (select banking_service_id from t_banking_balance where month = '01'
                    minus
                    select banking_service_id from t_banking_balance where month = '02')
                    )

                          )
  loop
    select banking_service_id into v_banking_service_id from m_company_service where "number"=service.d_sell_comp_serv_number fetch first 1 rows only;
    -- dbms_output.put_line('v_banking_service_id-->'||v_banking_service_id);
    update t_banking_balance set CURR_C1 = decode(sign(nvl(CURR_C1,0)),1,CURR_C1,0),CURR_C2 = decode(sign(nvl(CURR_C2,0)),1,CURR_C2,0),
		CURR_C3 = decode(sign(nvl(CURR_C3,0)),1,CURR_C3,0), CURR_C4 = decode(sign(nvl(CURR_C4,0)),1,CURR_C4,0), CURR_C5 = decode(sign(nvl(CURR_C5,0)),1,CURR_C5,0)
		where banking_service_id = v_banking_service_id and month='01';
    
    DELETE_TXN.DELETE_BY_SERVICE('call from TMP_CALL_OPEN_BB',service.d_sell_comp_serv_number,'02','2019','Y','Y','Y','N',O_RESULT_CODE,O_RESULT_DESC);
  end loop;

    O_RESULT_CODE := CREATE_GS(null,'02','2019');



-------- create bb for with curr_c1 = double of c1 
/***
	1.loop those records
		a. if alloted, skip (NOTE)
		b. set opening and curr to 0 for month-01
		c. delete bb for month 02 and this service
		c. delete txn except mr
	2. call create-gs
**/
/***

    --fetch service numbers for whom bb is not available for month= '02', and not allocated
  for service in ( 
                    select ser."number" d_sell_comp_serv_number from m_company_service ser join(
                    select id,banking_service_id,month,year, c1, c2,c3,c4,c5, curr_c1,curr_c2,curr_c3,curr_c4,curr_c5 from
                    (
                    select * from t_banking_balance where month = '01' and curr_c1 = c1*2 and c1 > 0
                    union
                    select * from t_banking_balance where month = '01' and curr_c3 = c3*2 and c3 > 0
                    union
                    select * from t_banking_balance where month = '01' and curr_c4 = c4*2 and c4 > 0
                    union
                    select * from t_banking_balance where month = '01' and curr_c5 = c5*2 and c5 > 0
                    ) 
                    where nvl(curr_c1,0) = nvl(c1*2,0)  and nvl(curr_c2,0) = nvl(c2*2,0)  and nvl(curr_c3,0) = nvl(c3*2,0)  and nvl(curr_c4,0) = nvl(c4*2,0)  and nvl(curr_c5,0) = nvl(c5*2,0)
                    order by  banking_service_id,month,year) a
                    on ser.banking_service_id=a.banking_service_id

                          )
  loop
    select count(*) into v_allotment_count from f_energy_sale_order where month='02' and d_sell_comp_serv_number = service.d_sell_comp_serv_number;
    if (v_allotment_count>0) then continue; end if;
    
    select banking_service_id into v_banking_service_id from m_company_service where "number"=service.d_sell_comp_serv_number fetch first 1 rows only;
    -- dbms_output.put_line('v_banking_service_id-->'||v_banking_service_id);
    update t_banking_balance set CURR_C1 = 0, CURR_C2 = 0,CURR_C3 = 0,CURR_C4 = 0,CURR_C5 = 0,
        C1 = 0, C2 = 0,C3 = 0,C4 = 0,C5 = 0
		where banking_service_id = v_banking_service_id and month='01';
    delete from t_banking_balance where  banking_service_id = v_banking_service_id and month='02';
    DELETE_TXN.DELETE_BY_SERVICE('call from TMP_CALL_OPEN_BB',service.d_sell_comp_serv_number,'02','2019','Y','Y','Y','N',O_RESULT_CODE,O_RESULT_DESC);
  end loop;

    O_RESULT_CODE := CREATE_GS(null,'02','2019');

**/
  commit;

END TMP_CALL_OPEN_BB;

/
--------------------------------------------------------
--  DDL for Procedure TMP_GEN_SS_LOSS_CALL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_GEN_SS_LOSS_CALL" is
v_result VARCHAR2(100);
O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
BEGIN 
    for ss_loss in (select * from tmp_gen_ss_loss)

  loop
   GENERATION_STATEMENT.CREATE_WITH_SS_LOSS(ss_loss.M_SUBSTATION_ID,ss_loss.M_SERVICE_NUMBER,ss_loss.M_ORG_ID , ss_loss.MONTH, ss_loss.YEAR,O_RESULT_CODE, O_RESULT_DESC );
  end loop;
END tmp_gen_ss_loss_call;


/
--------------------------------------------------------
--  DDL for Procedure TMP_IMPORT_MANUAL_RDG
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_IMPORT_MANUAL_RDG" is
v_result VARCHAR2(100);
BEGIN
  for mr in (select distinct h.id from imp_mr_header h join  imp_mr_lines l on  l.imp_mr_header_id = h.id  where h.mr_source_code = '02'  and h.CREATED_DATE > to_date('28-02-2019','dd-mm-yyyy')
and l.reading_month = '02' and l.reading_year = '2019')
  loop
    update imp_mr_lines set status_code='CREATED' where imp_mr_header_id=mr.id;
    v_result := IMPORT_AND_PROCESS_MRI_BATCH(mr.id);
  end loop;
END TMP_IMPORT_MANUAL_RDG;

/
--------------------------------------------------------
--  DDL for Procedure TMP_INT_ADJ_UNIT_03_06_19
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_INT_ADJ_UNIT_03_06_19" is
v_result VARCHAR2(100);
v_log_result VARCHAR2(100);
O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);

BEGIN 
v_log_result := log_activity('PROCEDURE','TMP_INT_ADJ_UNIT_03_06_19','start',o_result_desc,'','', sysdate,'');
  FOR dummy IN (SELECT * FROM DUMMY_INT_ADJUSTED_UNIT)
   loop
   IMP_INT_ADJUSTED_UNIT.PROCESS_INT_ADJUSTED_UNIT(dummy.BATCH_KEY,dummy.READING_MNTH,dummy.READING_YR,O_RESULT_CODE,O_RESULT_DESC);


--   -- dbms_output.put_line(LINE.m_company_id);
  END LOOP;

 v_log_result := log_activity('PROCEDURE','TMP_INT_ADJ_UNIT_03_06_19','end',o_result_desc,'','', sysdate,'');
END TMP_INT_ADJ_UNIT_03_06_19;


/
--------------------------------------------------------
--  DDL for Procedure TMP_LOSS_CALC_0419
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_LOSS_CALC_0419" 
IS
  v_result VARCHAR2(100);

    v_total_loss VARCHAR2(200);
    v_drawl_code VARCHAR2(200); 
    v_inj_code VARCHAR2(200); 
    v_inj_units number; 
    v_trans_loss VARCHAR2(200); 
    v_dis_loss VARCHAR2(200); 
    v_drawl_units  number; 
    v_comp_id VARCHAR2(200); 
    v_bank_service_id VARCHAR2(200); 
    v_banking_count VARCHAR2(50); 
    v_inj_units1 VARCHAR2(200); 
    v_inj_units2 VARCHAR2(200); 
    v_inj_units3 VARCHAR2(200); 
    v_inj_units4 VARCHAR2(200); 
    v_inj_units5 VARCHAR2(200); 
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);

BEGIN

  FOR v_adj_unit IN
  (SELECT service_no ,
    reading_mnth ,
    reading_yr ,
    c1_tot ,
    c2_tot ,
    c3_tot ,
    c4_tot ,
    c5_tot ,
    c24_tot ,
    suplr_code ,
    suplr_type,
    sur1_tot,
    sur2_tot,
    sur3_tot,
    sur4_tot,
    sur5_tot,
    sur24_tot
  FROM missing_int_adj_units_0306 where SERVICE_NO='49094220227' AND SUPLR_CODE='79244724394' AND READING_MNTH='4'
  )
  LOOP
    -- dbms_output.put_line('SERVICE_NO--> '||V_ADJ_UNIT.SERVICE_NO||' SUPLR_CODE---> '||V_ADJ_UNIT.SUPLR_CODE);

    SELECT voltage_code
    INTO v_inj_code
    FROM m_company_service
    WHERE "number"='0'||v_adj_unit.SUPLR_CODE;

    SELECT voltage_code
    INTO v_drawl_code
    FROM m_company_service
    WHERE "number"='0'||v_adj_unit.SERVICE_NO;

    v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.c1_tot,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units1);
    v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.c2_tot,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units2);
    v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.c3_tot,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units3);
    v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.c4_tot,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units4);
    v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.c5_tot,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units5);

    UPDATE missing_int_adj_units_0306
    SET sur1_tot     = ROUND(NVL(v_inj_units1,0),0),
      sur2_tot       =ROUND(NVL(v_inj_units2,0),0),
      sur3_tot       =ROUND(NVL(v_inj_units3,0),0),
      sur4_tot       =ROUND(NVL(v_inj_units4,0),0),
      sur5_tot       =ROUND(NVL(v_inj_units5,0),0)
    WHERE SUPLR_CODE = v_adj_unit.SUPLR_CODE
    AND SERVICE_NO   = v_adj_unit.SERVICE_NO;
  END LOOP;
END TMP_LOSS_CALC_0419;


/
--------------------------------------------------------
--  DDL for Procedure TMP_OPEN_BB_03_06_19
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_OPEN_BB_03_06_19" is
v_result VARCHAR2(100);
v_log_result VARCHAR2(100);
O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
v_banking_service_id varchar(50);
v_allotment_count number:=0;
v_curr_month_bb_count number:=0;
v_bb_new T_BANKING_BALANCE%ROWTYPE;
BEGIN 
 v_log_result := log_activity('PROCEDURE','OPEN_BB_04_06_19_SS_LOSS','START',o_result_desc,'','', sysdate,'');
  FOR LINE IN (SELECT * FROM BK_BB_SS_LOSS_04062019_1)
   loop
    select count(*) into v_curr_month_bb_count from t_banking_balance where M_COMPANY_ID = LINE.m_company_id and BANKING_SERVICE_ID = LINE.BANKING_SERVICE_ID and month = '05' and year = '2019'  fetch first 1 rows only;
     if(v_curr_month_bb_count = 0) then 
      v_log_result := log_activity('PROCEDURE','OPEN_BB_04_06_19_SS_LOSS','INSERTED','LINE.m_company_id-'||LINE.m_company_id||',05'',2019','','', sysdate,'');
        v_bb_new.M_COMPANY_ID := LINE.M_COMPANY_ID;
        v_bb_new.BANKING_SERVICE_ID := LINE.BANKING_SERVICE_ID;
        v_bb_new.enabled:='Y';
        v_bb_new.CALCULATED:='N';
        v_bb_new.month:='05';
        v_bb_new.year:='2019';
        v_bb_new.remarks:='MANUAL-UPDATE-SS_LOSS';
        v_bb_new.CREATED_BY:='BK_BB_SS_LOSS';
        v_bb_new.CREATED_DATE:=sysdate;
        v_bb_new.id:=T_BANKING_BALANCE_SEQ.NEXTVAL;

          select  LINE.CURR_C1,LINE.CURR_C2,LINE.CURR_C3,LINE.CURR_C4,LINE.CURR_C5,LINE.CURR_C1,LINE.CURR_C2,LINE.CURR_C3,LINE.CURR_C4,LINE.CURR_C5
          into  v_bb_new.C1,v_bb_new.C2,v_bb_new.C3,v_bb_new.C4,v_bb_new.C5,v_bb_new.CURR_C1,v_bb_new.CURR_C2,v_bb_new.CURR_C3,v_bb_new.CURR_C4,v_bb_new.CURR_C5 from dual;

          insert into t_banking_balance values v_bb_new;

    else
     v_log_result := log_activity('PROCEDURE','OPEN_BB_04_06_19_SS_LOSS','NOT INSERTED','LINE.m_company_id-'||LINE.m_company_id||',05'',2019','','', sysdate,'');
     end if;
--   -- dbms_output.put_line(LINE.m_company_id);
  END LOOP;

 v_log_result := log_activity('PROCEDURE','OPEN_BB_04_06_19_SS_LOSS','END',o_result_desc,'','', sysdate,'');
END TMP_OPEN_BB_03_06_19;


/
--------------------------------------------------------
--  DDL for Procedure TMP_OPEN_BB_ISSUE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_OPEN_BB_ISSUE" is
v_result VARCHAR2(100);
v_log_result VARCHAR2(100);
O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
v_banking_service_id varchar(50);
v_es_count number:=0; 
v_gen_stmt_count number:=0;
v_curr_month_bb_count number:=0;
v_bb_new T_BANKING_BALANCE%ROWTYPE;
v_gen_stmt t_gen_stmt%ROWTYPE;
v_gen_stmt_slot t_gen_stmt_slot%ROWTYPE;
v_es t_energy_sale%ROWTYPE;

BEGIN 
 v_log_result := log_activity('PROCEDURE','TMP_OPEN_BB_ISSUE','START','','','','','', sysdate,'');
 
      for bb in (select * from t_banking_balance where month='06' and M_COMPANY_ID in (select M_COMPANY_ID from DUMMY_BANKING))
      loop
        select count(*) into v_gen_stmt_count from t_gen_stmt where stmt_month='06' and stmt_year='2019'  and m_company_id=bb.m_company_id;  
        if v_gen_stmt_count=1 then
            
            for gen_stmt in (select * from t_gen_stmt where stmt_month='06' and stmt_year='2019'  and m_company_id=bb.m_company_id )
              loop
              
               for gen_stmt_slot in (select * from t_gen_stmt_slot where t_gen_stmt_id=gen_stmt.id )
               loop
                
                    if gen_stmt_slot.SLOT_CODE = 'C1' then
                    
                        update t_gen_stmt_slot set BANKED_BALANCE=bb.C1,REMARKS='05-BANKING-ISSUE' where id=gen_stmt_slot.id;
                        
                        select count(*) into v_es_count from t_energy_sale where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019';
                        if v_es_count=1 then
                            update t_energy_sale set avail_bc1=bb.c1,IMPORT_REMARKS='05-BANKING-ISSUE' where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019'; 
                            
                        end if;
                     v_log_result := log_activity('PROCEDURE','TMP_OPEN_BB_ISSUE','bb.M_COMPANY_ID'||bb.M_COMPANY_ID,'gen_stmt.id'||gen_stmt.id ,'','','','', sysdate,'');
                    end if;
                    
                    if gen_stmt_slot.SLOT_CODE = 'C2' then
                    
                        update t_gen_stmt_slot set BANKED_BALANCE=bb.C2,REMARKS='05-BANKING-ISSUE' where id=gen_stmt_slot.id;
                        
                        select count(*) into v_es_count from t_energy_sale where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019';
                        if v_es_count=1 then
                            update t_energy_sale set avail_bc2=bb.c2,IMPORT_REMARKS='05-BANKING-ISSUE'  where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019'; 
                        end if;
                    
                    end if;
                    
                     
                    if gen_stmt_slot.SLOT_CODE = 'C3' then
                    
                        update t_gen_stmt_slot set BANKED_BALANCE=bb.C3,REMARKS='05-BANKING-ISSUE' where id=gen_stmt_slot.id;
                        
                        select count(*) into v_es_count from t_energy_sale where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019';
                        if v_es_count=1 then
                            update t_energy_sale set avail_bc3=bb.c3,IMPORT_REMARKS='05-BANKING-ISSUE'  where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019'; 
                        end if;
                    
                    end if;
                    
                    
                     
                    if gen_stmt_slot.SLOT_CODE = 'C4' then
                    
                        update t_gen_stmt_slot set BANKED_BALANCE=bb.C4,REMARKS='05-BANKING-ISSUE' where id=gen_stmt_slot.id;
                        
                        select count(*) into v_es_count from t_energy_sale where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019';
                        if v_es_count=1 then
                            update t_energy_sale set avail_bc4=bb.c4,IMPORT_REMARKS='05-BANKING-ISSUE'  where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019'; 
                        end if;
                    
                    end if;
                    
                     
                    if gen_stmt_slot.SLOT_CODE = 'C5' then
                    
                        update t_gen_stmt_slot set BANKED_BALANCE=bb.C5,REMARKS='05-BANKING-ISSUE' where id=gen_stmt_slot.id;
                        
                        select count(*) into v_es_count from t_energy_sale where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019';
                        if v_es_count=1 then
                            update t_energy_sale set avail_bc5=bb.c5,IMPORT_REMARKS='05-BANKING-ISSUE'  where t_gen_stmt_id=gen_stmt.id and  month='06' and year='2019'; 
                        end if;
                    
                    end if;
                    
                
               end loop;
                
              end loop;
            
        end if;
      end loop;

 
 
 




 v_log_result := log_activity('PROCEDURE','TMP_OPEN_BB_ISSUE','End',o_result_desc,'','', sysdate,'');
END TMP_OPEN_BB_ISSUE;

/
--------------------------------------------------------
--  DDL for Procedure TMP_REPROCESS_ENERGY_SALE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_REPROCESS_ENERGY_SALE" is
v_result VARCHAR2(100);
 v_log_result varchar(300):='SUCCESS';
BEGIN 
v_log_result := log_activity('PROCEDURE','TMP_REPROCESS_ENERGY_SALE','START','', '','admin', sysdate,'');
    for ES in (SELECT ES.ID
FROM T_ENERGY_SALE es
left join M_COMPANY_SERVICE s on es.SELLER_COMP_SERV_ID=s.id
WHERE es.MONTH='05' and  es.BC1+es.BC2+es.BC3+es.BC4+es.BC5>0 and es.STATUS_CODE='CREATED' )
  --  for ES in (select ID from t_energy_sale where PROCESS_REMARKS is not null and status_code='CREATED' and created_date < (SYSDATE - 2/24) )
  loop
--    update t_energy_sale set status_code='CREATED' , PROCESS_REMARKS='REPROCESSING' where ID=ES.id;
    v_result := ENERGY_SALE_CONFIRMATION(ES.id);
      v_log_result := log_activity('PROCEDURE','TMP_REPROCESS_ENERGY_SALE','LOOP','', '','admin', sysdate,ES.id);
  end loop;
  v_log_result := log_activity('PROCEDURE','TMP_REPROCESS_ENERGY_SALE','END','', '','admin', sysdate,'');
END TMP_REPROCESS_ENERGY_SALE;

/
--------------------------------------------------------
--  DDL for Procedure TMP_UPDATE_BB
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_UPDATE_BB" 
(
  i_reading_month IN VARCHAR2 , i_reading_year IN VARCHAR2 , i_batch_key in varchar2
) is
O_RESULT_CODE VARCHAR2(100);
O_RESULT_DESC VARCHAR2(100);
v_remarks VARCHAR2(100);
BEGIN
    v_remarks :='UPDATE-BB-'||systimestamp;
    delete from t_banking_balance where month =i_reading_month and year= i_reading_year and banking_service_id in
        (
        select distinct s.banking_service_id from bk_upd_curvalues bk inner join m_company_service s on s."number"=bk.service_no where bk.batch_key=i_batch_key
        minus
        select distinct so.banking_service_id from f_energy_sale_order so inner join m_company_service s on s.id=so.seller_comp_serv_id where month=i_reading_month and year=i_reading_year and d_sell_comp_serv_number in
        (select service_no from bk_upd_curvalues  where batch_key=i_batch_key)
        and nvl(total_banking_units_sold,0) >0
        );


    INSERT INTO INT_DELETE_TXN (REMARKS,GEN_SERVICE_NUMBER, READING_MONTH, READING_YEAR, CREATED_BY, CREATED_DT)
        select v_remarks REMARKS,  GEN_SERVICE_NUMBER,i_reading_month READING_MONTH,i_reading_year READING_YEAR,'TMP_UPDATE_BB' CREATED_BY,sysdate CREATED_DT from (
         select distinct s."number" GEN_SERVICE_NUMBER from bk_upd_curvalues bk inner join m_company_service s on s."number"=bk.service_no where bk.batch_key=i_batch_key
            minus
            select distinct s."number" GEN_SERVICE_NUMBER from f_energy_sale_order so inner join m_company_service s on s.id=so.seller_comp_serv_id where month=i_reading_month and year=i_reading_year and d_sell_comp_serv_number in
            (select service_no from bk_upd_curvalues where batch_key=i_batch_key)
            and nvl(total_banking_units_sold,0) >0);
            
    O_RESULT_CODE := BK_TO_UPDATE_CURC1();
    
    DELETE_TXN.PROCESS_INT_DELETE_TXN(v_remarks,'Y','Y','Y','N',O_RESULT_CODE,O_RESULT_DESC );
    
    O_RESULT_CODE := CREATE_GS(null,i_reading_month,i_reading_year);
    
END TMP_UPDATE_BB;

/
--------------------------------------------------------
--  DDL for Procedure TMP_UPDATE_GS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_UPDATE_GS" is
v_result VARCHAR2(100);
BEGIN

 /* updating GS to allocated if ES is available
  for ES in (SELECT T_GEN_STMT_ID FROM T_ENERGY_SALE ES JOIN T_GEN_STMT  GS ON GS.ID=ES.T_GEN_STMT_ID  WHERE GS.STATUS_CODE ='CREATED')
  loop
    update T_GEN_STMT set status_code='ALLOCATED', MODIFIED_BY='ADMIN', MODIFIED_DT=SYSDATE where ID=ES.T_GEN_STMT_ID; 
  end loop;

  */

  /*
  -- updating GS.flow-type-code for is-captive for month-02 (similar for  3rd party and stb)
 for GS in (select gs.id from t_gen_stmt gs join m_company_Service ser on ser."number"=gs.DISP_SERVICE_NUMBER
                  where ser.flow_type_code ='IS-CAPTIVE' and gs.flow_type_code is null
                  and stmt_month='02')
  loop
    update T_GEN_STMT set flow_type_code='IS-CAPTIVE', MODIFIED_BY='ADMIN', MODIFIED_DT=SYSDATE where ID=GS.ID; 

  end loop;
  */
  null;

END TMP_UPDATE_GS;


/
--------------------------------------------------------
--  DDL for Procedure TMP_UPDATE_T_BANKING_SERVICE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."TMP_UPDATE_T_BANKING_SERVICE" 
IS
  v_result          VARCHAR2(100);
  v_total_loss      VARCHAR2(200);
  v_drawl_code      VARCHAR2(200);
  v_inj_code        VARCHAR2(200);
  v_inj_units       NUMBER;
  v_trans_loss      VARCHAR2(200);
  v_dis_loss        VARCHAR2(200);
  v_drawl_units     NUMBER;
  v_comp_id         VARCHAR2(200);
  v_bank_service_id VARCHAR2(200);
  v_banking_count   VARCHAR2(50);
  v_inj_units1      VARCHAR2(200);
  v_inj_units2      VARCHAR2(200);
  v_inj_units3      VARCHAR2(200);
  v_inj_units4      VARCHAR2(200);
  v_inj_units5      VARCHAR2(200);
  v_log_result      VARCHAR(300):='SUCCESS';
  v_exception_code  VARCHAR2(150);
  v_exception_msg   VARCHAR2(150);
  v_reason          VARCHAR2(300);
BEGIN
  FOR v_adj_unit IN
  (SELECT id ,
    m_company_id ,
    banking_service_id ,
    c1 ,
    c2 ,
    c3 ,
    c4 ,
    c5 ,
    remarks ,
    created_by ,
    created_dt ,
    modified_by ,
    modified_dt ,
    created_date ,
    enabled ,
    MONTH ,
    YEAR ,
    curr_c1 ,
    curr_c2 ,
    curr_c3 ,
    curr_c4 ,
    curr_c5 ,
    calculated
  FROM T_BANKING_BALANCE
  WHERE M_COMPANY_ID IN
    (SELECT M_COMPANY_ID
    FROM M_COMPANY_SERVICE
    WHERE "number" IN
      (SELECT '0'||SUPLR_CODE FROM missing_int_adj_units_0306
      )
    )
  AND MONTH = '06'
  )
  LOOP
    -- dbms_output.put_line('m_company_id--> '||V_ADJ_UNIT.m_company_id);
    UPDATE t_banking_balance
    SET C1 =
      (SELECT SUR1_TOT FROM missing_int_adj_units_0306
      ),
      C2 =
      (SELECT SUR2_TOT FROM missing_int_adj_units_0306
      ),
      C3 =
      (SELECT SUR3_TOT FROM missing_int_adj_units_0306
      ),
      C4 =
      (SELECT SUR4_TOT FROM missing_int_adj_units_0306
      ),
      C5 =
      (SELECT SUR5_TOT FROM missing_int_adj_units_0306
      ) WHERE m_company_id = V_ADJ_UNIT.m_company_id;
  END LOOP;
END TMP_UPDATE_T_BANKING_SERVICE;


/
--------------------------------------------------------
--  DDL for Procedure UPDATE_MERGE_MR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."UPDATE_MERGE_MR" AS 
BEGIN
for mr in (select distinct id from t_meter_reading_slot where t_meter_reading_hdr_id in
                (select id from t_meter_reading_hdr where MERGE_WITH_NEXT_BILLING = 'Y' and  reading_month='12' and reading_year='2018' )
                and imp_init = '0')
  loop
    update t_meter_reading_slot set IMP_INIT = IMP_FINAL,  EXP_INIT = EXP_FINAL,  IMP_DIFF=0, IMP_UNITS=0, EXP_DIFF=0, EXP_UNITS=0, NET_UNITS=0, MODIFIED_BY='UPDATE_MERGE_MR', MODIFIED_DATE=SYSDATE where ID=mr.id; 
  end loop;
END UPDATE_MERGE_MR;


/
--------------------------------------------------------
--  DDL for Procedure UPDATE_VOLTAGE_INPP
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "OPENACCESS"."UPDATE_VOLTAGE_INPP" AS 
BEGIN

 /*
    for pp in (select pp.id,  trim(ser.fuel_type_code) fuel_type_code from m_powerplant pp join m_company_service ser on pp.m_service_id = ser.id
                    where pp.fuel_type_code is null or pp.fuel_type_code <>ser.fuel_type_code)
    loop
        update m_powerplant set fuel_type_code = pp.fuel_type_code, modified_by='abul-voltage-update', modified_date=sysdate where id=pp.id;
    end loop;
    */
    null;
END UPDATE_VOLTAGE_INPP;


/
--------------------------------------------------------
--  DDL for Package BANKING_BALANCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."BANKING_BALANCE" AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
  procedure process_import_table (i_remarks in varchar2, i_overwrite in char default 'N', o_result_code out varchar2, o_result_desc out varchar2);
  procedure open_balance (i_service_no in varchar2, i_reading_month in varchar2, i_reading_year in varchar2, o_result_code out varchar2, o_result_desc out varchar2);
  procedure confirm_energy_sale_event(V_ES_ID in varchar2, o_result_code out varchar2, o_result_desc out varchar2);
  procedure increment_surplus_units(i_ht_surplus_units_id in varchar2, o_result_code out varchar2, o_result_desc out varchar2);
  procedure reset_for_yearend(i_service_no in varchar2, i_reading_month in varchar2, i_reading_year in varchar2,o_result_code out varchar2, o_result_desc out varchar2);

END BANKING_BALANCE;

/
--------------------------------------------------------
--  DDL for Package BILLING_PERIOD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."BILLING_PERIOD" AS 

  PROCEDURE UPDATE_SURPLUS_FROM_HT(i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2);
  PROCEDURE OPEN_ALL_EXS_BALANCES(i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2);

END BILLING_PERIOD;

/
--------------------------------------------------------
--  DDL for Package DBMS_RCVCAT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."DBMS_RCVCAT" authid current_user is
 
--
TRUE#  CONSTANT number := 1;
FALSE# CONSTANT number := 0;
 
--
UPGRADE_COMPLETED CONSTANT number := 1;
 
--
RESYNC_FULL    CONSTANT number := 1;
RESYNC_PARTIAL CONSTANT number := 2;
RESYNC_NONE    CONSTANT number := 3;
 
CONFIGRESYNC_NO        CONSTANT number := 0;
CONFIGRESYNC_TORC      CONSTANT number := 1;
CONFIGRESYNC_TOCF      CONSTANT number := 2;
CONFIGRESYNC_TORC_TOCF CONSTANT number := 3;
 
--
--
CF_CURRENT     CONSTANT number := 1;
CF_BACKUP      CONSTANT number := 2;
CF_CREATED     CONSTANT number := 3;
CF_STANDBY     CONSTANT number := 4;
CF_CLONE       CONSTANT number := 5;
CF_NOMOUNT     CONSTANT number := 6;
 
--
--
this_db_key      number := NULL;
this_dbinc_key   number := NULL;
 
type registerDbPending_t is record
(
   dbid        number  := null,
   con_id      number  := null,
   guid        raw(16) := null
);
registerDbPending registerDbPending_t;
 
RESYNC_REASON_NOACTION    CONSTANT number := 1;  -- do not display reasons
RESYNC_REASON_NONE        CONSTANT number := 2;  -- no reason is yet set
RESYNC_REASON_DF          CONSTANT number := 3; 
RESYNC_REASON_TF          CONSTANT number := 4;
RESYNC_REASON_TS          CONSTANT number := 5;
RESYNC_REASON_THR         CONSTANT number := 6;
RESYNC_REASON_ORL         CONSTANT number := 7;
RESYNC_REASON_CONF        CONSTANT number := 8;
RESYNC_REASON_CF          CONSTANT number := 9;
RESYNC_REASON_RSL         CONSTANT number := 10;
RESYNC_REASON_INC         CONSTANT number := 11;
RESYNC_REASON_RESET       CONSTANT number := 12;
RESYNC_REASON_PDB         CONSTANT number := 13;
resync_reason     number  := RESYNC_REASON_NONE;
doResyncReasons   boolean := FALSE;
 
RESYNC_ACTION_ADD         CONSTANT number := 1;
RESYNC_ACTION_DROP        CONSTANT number := 2;
RESYNC_ACTION_CHANGE      CONSTANT number := 3;
RESYNC_ACTION_RECREATE    CONSTANT number := 4;
RESYNC_ACTION_RENAME      CONSTANT number := 5;
RESYNC_ACTION_RESIZE      CONSTANT number := 6;
 
TYPE resyncActionNames_t    IS VARRAY(6) OF varchar2(12);
 
--
RESYNC_ACTION_NAMES         CONSTANT resyncActionNames_t := 
                            resyncActionNames_t('added',   'dropped',
                                                'changed', 'recreated',
                                                'renamed', 'resized');
 
TYPE resyncActionTaken_t    IS VARRAY(6) OF boolean;
 
TYPE resyncActionCounts_t   IS VARRAY(6) OF number;
 
RESYNC_OBJECT_TABLESPACE    CONSTANT number := 1;
RESYNC_OBJECT_DATAFILE      CONSTANT number := 2;
RESYNC_OBJECT_TEMPFILE      CONSTANT number := 3;
RESYNC_OBJECT_REDOTHREAD    CONSTANT number := 4;
RESYNC_OBJECT_ONLINELOG     CONSTANT number := 5;
RESYNC_OBJECT_PDB           CONSTANT number := 6;
 
TYPE resyncActionObjects_t  IS VARRAY(5) OF varchar2(16);
 
--
RESYNC_ACTION_OBJECTS       CONSTANT resyncActionObjects_t :=
                            resyncActionObjects_t('Tablespace', 'Datafile', 
                                                  'Tempfile',   'Redo thread', 
                                                  'Online redo log');
--
RCVCAT_LEVEL_ZERO           CONSTANT number := 0;  
RCVCAT_LEVEL_MIN            CONSTANT number := 1;
RCVCAT_LEVEL_LOW            CONSTANT number := 5;
RCVCAT_LEVEL_MID            CONSTANT number := 9;
RCVCAT_LEVEL_HI             CONSTANT number := 12;
RCVCAT_LEVEL_MAX            CONSTANT number := 15;
RCVCAT_LEVEL_DEFAULT        CONSTANT number := RCVCAT_LEVEL_MID; 
 
TYPE fullResyncActions_t IS RECORD
(
   active          boolean,
   valid           boolean,
   lastobjno       number,
   objtype         number,
   actTaken        resyncActionTaken_t,
   actCount        resyncActionCounts_t
);
 
fullResyncAction   fullResyncActions_t; -- :=
--
--
--
 
/*-----------------------*
 * Debugging functions   *
 *-----------------------*/
 
PROCEDURE setDebugOn(dbglevel IN NUMBER DEFAULT RCVCAT_LEVEL_DEFAULT);
 
PROCEDURE setDebugOff;
 
/*-----------------------*
 * Database Registration *
 *-----------------------*/
 
PROCEDURE registerDatabase(
   db_id          IN number
  ,db_name        IN varchar2
  ,reset_scn      IN number
  ,reset_time     IN date
  ,db_unique_name IN varchar2 default null
  ,con_id         IN number   default 0
  ,guid           IN raw      default null
);
 
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
procedure resetDatabase(
  db_id             IN number
 ,db_name           IN varchar2
 ,reset_scn         IN number
 ,reset_time        IN date
 ,parent_reset_scn  IN number
 ,parent_reset_time IN date
);
 
function resetDatabase(
  db_id             IN number
 ,db_name           IN varchar2
 ,reset_scn         IN number
 ,reset_time        IN date
 ,parent_reset_scn  IN number
 ,parent_reset_time IN date
) return number;
 
procedure resetDatabase(
  dbinc_key  IN number
 ,db_name    IN varchar2
);
 
procedure resetDatabase(
  dbinc_key  IN number
 ,db_name    IN varchar2
 ,reset_scn  OUT number
 ,reset_time OUT date
 ,db_id      IN number DEFAULT NULL
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
procedure unregisterDatabase(
  db_key     IN NUMBER DEFAULT NULL
 ,db_id      IN NUMBER
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
/*--------------------------*
 * Set Database Incarnation *
 *--------------------------*/
 
procedure setDatabase(
  db_name         IN varchar2
 ,reset_scn       IN number
 ,reset_time      IN date
 ,db_id           IN number
 ,db_unique_name  IN varchar2
 ,dummy_instance  IN boolean
 ,cf_type         IN number
 ,site_aware      IN boolean default FALSE
 ,ors_instance    IN boolean default FALSE
);
 
procedure setDatabase(
  db_name         IN varchar2
 ,reset_scn       IN number
 ,reset_time      IN date
 ,db_id           IN number
 ,db_unique_name  IN varchar2 default NULL);
 
procedure setDatabase(dbinc_key number);
 
procedure setDatabase;
 
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
/*-----------------------------*
 * Recovery Catalog Checkpoint *
 *-----------------------------*/
function ckptNeeded(
  ckp_scn          IN number
 ,ckp_cf_seq       IN number
 ,cf_version       IN date
 ,cf_type          IN number
 ,high_df_recid    IN number
 ,high_orl_recid   IN number
 ,high_cdf_recid   IN number
 ,high_al_recid    IN number
 ,high_bp_recid    IN number
 ,high_do_recid    IN number
 ,high_offr_recid  IN number
 ,high_pc_recid    IN number  DEFAULT NULL -- for compatibility
 ,high_conf_recid  IN number  DEFAULT NULL -- for compatibility
 ,rltime           IN DATE    DEFAULT NULL -- for compatibility
 ,high_ts_recid    IN number  DEFAULT NULL -- for compatibility
 ,high_bs_recid    IN number  DEFAULT NULL -- for compatibility
 ,lopen_reset_scn  IN number  DEFAULT NULL -- for compatibility
 ,lopen_reset_time IN DATE    DEFAULT NULL -- for compatibility
 ,high_ic_recid    IN number  DEFAULT NULL -- for compatibility
 ,high_tf_recid    IN number  DEFAULT NULL -- for compatibility
 ,high_rt_recid    IN number  DEFAULT NULL -- for compatibility
 ,high_grsp_recid  IN number  DEFAULT NULL -- for compatibility
 ,high_nrsp_recid  IN number  DEFAULT NULL -- for compatibility
 ,high_bcr_recid   IN number  DEFAULT NULL -- for compatibility
 ,high_pdb_recid   IN number  DEFAULT NULL -- for compatibility
 ,high_pic_recid   IN number  DEFAULT NULL -- for compatibility
) return number;
 
PROCEDURE lockForCkpt(ors_inspect IN boolean DEFAULT FALSE);
 
procedure beginCkpt(
  ckp_scn       IN number
 ,ckp_cf_seq    IN number
 ,cf_version    IN date
 ,ckp_time      IN date
 ,ckp_type      IN varchar2
 ,ckp_db_status IN varchar2
 ,high_df_recid IN number
 ,cf_type       IN varchar2 DEFAULT 'CURRENT'   -- for compatibility reasons
);
 
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endCkpt;
 
--
--
--
--
--
--
 
--
--
--
--
 
procedure cancelCkpt;
 
--
--
--
 
--
--
function lastFullCkpt return number;
 
--
--
FUNCTION getPolledRec(rec_type OUT NUMBER,
                      recid    OUT NUMBER,
                      stamp    OUT NUMBER,
                      fname    OUT VARCHAR2) RETURN BOOLEAN;
 
/*-------------------*
 * Resync            *
 *-------------------*/
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
 
/*---------------------*
 * Pluggable DB Resync *
 *---------------------*/
 
FUNCTION beginPluggableDBResync(
  high_pdb_recid IN NUMBER)
RETURN BOOLEAN;
 
--
--
--
 
PROCEDURE checkPluggableDB(
  name       IN VARCHAR2
 ,con_id     IN NUMBER
 ,db_id      IN NUMBER
 ,create_scn IN NUMBER
 ,guid       IN RAW
 ,noBackup   IN VARCHAR2 DEFAULT 'N'
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE endPluggableDBResync;
 
--
--
 
/*-------------------*
 * Tablespace Resync *
 *-------------------*/
 
function beginTableSpaceResync(
  high_ts_recid IN NUMBER,
  force         IN BOOLEAN DEFAULT FALSE
) return boolean;
 
--
--
 
--
--
--
 
--
--
 
 
procedure checkTableSpace(
  ts_name                     IN varchar2
 ,ts#                         IN number
 ,create_scn                  IN number
 ,create_time                 IN date
 ,rbs_count                   IN number   DEFAULT NULL
 ,included_in_database_backup IN varchar2 DEFAULT NULL
 ,bigfile                     IN varchar2 DEFAULT NULL
 ,temporary                   IN varchar2 DEFAULT NULL
 ,encrypt_in_backup           IN varchar2 DEFAULT NULL
 ,plugin_scn                  IN number   DEFAULT 0
 ,con_id                      IN number   DEFAULT 0
 ,pdb_dict_check              IN boolean  DEFAULT FALSE
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
 
procedure endTableSpaceResync;
 
--
 
--
--
 
 
/*-----------------*
 * Datafile Resync *
 *-----------------*/
 
function beginDataFileResync(
  high_df_recid IN number
) return boolean;
 
 
--
--
--
 
--
--
 
procedure checkDataFile(file#               IN NUMBER,
                        fname               IN VARCHAR2,
                        create_scn          IN NUMBER,
                        create_time         IN DATE,
                        blocks              IN NUMBER,
                        block_size          IN NUMBER,
                        ts#                 IN NUMBER,
                        stop_scn            IN NUMBER,
                        read_only           IN NUMBER,
                        stop_time           IN DATE     DEFAULT NULL,
                        rfile#              IN NUMBER   DEFAULT NULL,
                        aux_fname           IN VARCHAR2 DEFAULT NULL,
                        foreign_dbid        IN NUMBER   DEFAULT 0,
                        foreign_create_scn  IN NUMBER   DEFAULT 0,
                        foreign_create_time IN DATE     DEFAULT NULL,
                        plugged_readonly    IN VARCHAR2 DEFAULT 'NO',
                        plugin_scn          IN NUMBER   DEFAULT 0,
                        plugin_reset_scn    IN NUMBER   DEFAULT 0,
                        plugin_reset_time   IN DATE     DEFAULT NULL,
                        create_thread       IN NUMBER   DEFAULT NULL,
                        create_size         IN NUMBER   DEFAULT NULL,
                        con_id              IN NUMBER   DEFAULT 0,
                        pdb_closed          IN NUMBER   DEFAULT 0,
                        pdb_dict_check      IN BOOLEAN  DEFAULT FALSE,
                        pdb_foreign_dbid    IN NUMBER   DEFAULT 0);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
 
procedure endDataFileResync;
 
--
 
--
--
 
--
--
 
function beginDataFileResyncForStandby(
  high_df_recid IN number
) return boolean;
 
procedure checkDataFileForStandby(
                        file#               IN NUMBER,
                        fname               IN VARCHAR2,
                        create_scn          IN NUMBER,
                        create_time         IN DATE,
                        blocks              IN NUMBER,
                        block_size          IN NUMBER,
                        ts#                 IN NUMBER,
                        rfile#              IN NUMBER,
                        stop_scn            IN NUMBER,
                        read_only           IN NUMBER,
                        foreign_dbid        IN NUMBER,
                        plugin_scn          IN NUMBER);
 
--
--
--
--
--
--
 
procedure endDataFileResyncForStandby;
 
function beginTempFileResyncForStandby(
  high_tf_recid IN number
) return boolean;
 
procedure checkTempFileForStandby
                       (file#          IN NUMBER,
                        fname          IN VARCHAR2,
                        create_scn     IN NUMBER,
                        create_time    IN DATE,
                        blocks         IN NUMBER,
                        block_size     IN NUMBER,
                        ts#            IN NUMBER,
                        rfile#         IN NUMBER,
                        autoextend     IN VARCHAR2,
                        max_size       IN NUMBER,
                        next_size      IN NUMBER,
                        con_id         IN NUMBER DEFAULT 0);
 
procedure endTempFileResyncForStandby;
 
procedure setDatafileSize(
  file#       IN number
 ,create_scn  IN number
 ,blocks      IN number
 ,plugin_scn  IN number DEFAULT 0
);
 
/*-----------------*
 * TempFile Resync *
 *-----------------*/
 
function tempFileToResync(
  high_tf_recid IN number
) return boolean;
 
--
--
--
--
--
 
function beginTempFileResync(
  high_tf_recid IN number
) return boolean;
 
 
--
--
--
 
--
--
 
procedure checkTempFile(file#          IN NUMBER,
                        fname          IN VARCHAR2,
                        create_scn     IN NUMBER,
                        create_time    IN DATE,
                        blocks         IN NUMBER,
                        block_size     IN NUMBER,
                        ts#            IN NUMBER,
                        rfile#         IN NUMBER,
                        autoextend     IN VARCHAR2,
                        max_size       IN NUMBER,
                        next_size      IN NUMBER,
                        con_id         IN NUMBER  DEFAULT 0,
                        pdb_dict_check IN BOOLEAN DEFAULT FALSE);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
 
procedure endTempFileResync;
 
--
 
--
--
 
/*---------------------*
 * Redo Thread resync  *
 *---------------------*/
 
function beginThreadResync(
  high_rt_recid IN number
) return boolean;
 
 
--
 
 
procedure checkThread(
  thread#        IN number
 ,last_sequence# IN number
 ,enable_scn     IN number
 ,enable_time    IN date
 ,disable_scn    IN number
 ,disable_time   IN date
 ,status         IN varchar2
);
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
 
procedure endThreadResync;
 
--
 
 
 
/*------------------------*
 * Online Redo Log resync *
 *------------------------*/
 
function beginOnlineRedoLogResync(
  high_orl_recid IN number
) return boolean;
 
--
 
procedure checkOnlineRedoLog(
  thread#        IN number
 ,group#         IN number
 ,fname          IN varchar2
 ,bytes          IN number   default null
 ,type           IN varchar2 default 'ONLINE'
);
 
--
--
--
 
procedure endOnlineRedoLogResync;
 
--
 
/*---------------------------------*
 * Guaranteed Restore Point Resync *
 *---------------------------------*/
 
function beginGuaranteedRPResync(
  high_grsp_recid IN number
) return boolean;
 
--
 
PROCEDURE checkGuaranteedRP(
  rspname            IN VARCHAR2
 ,from_scn           IN NUMBER
 ,to_scn             IN NUMBER
 ,resetlogs_change#  IN NUMBER
 ,resetlogs_time     IN DATE
 ,create_time        IN DATE DEFAULT NULL
 ,rsp_time           IN DATE DEFAULT NULL
 ,guaranteed         IN VARCHAR2 DEFAULT 'YES'
 ,con_id             IN NUMBER   DEFAULT NULL
 ,clean              IN VARCHAR2 DEFAULT 'NO'
);
 
--
--
--
 
procedure endGuaranteedRPResync;
 
--
--
 
 
/*----------------------------------*
 * RMAN Configration records resync *
 *----------------------------------*/
 
function beginConfigResync(
  high_conf_recid IN number
) return number;
 
function beginConfigResync2(
  high_conf_recid IN number
) return number;
 
--
--
 
procedure endConfigResync;
 
procedure endConfigResync2(sync_to_cf_pending IN boolean DEFAULT FALSE);
 
--
--
 
procedure getConfig(
   conf#          OUT    number
  ,name           IN OUT varchar2
  ,value          IN OUT varchar2
  ,first          IN     boolean);
 
--
--
 
PROCEDURE setKeepOutputForSession(days IN number);
--
 
/*-----------------------------*
 * Redo Log History resync     *
 *-----------------------------*/
 
function beginLogHistoryResync return number;
 
--
--
--
--
 
function getLogHistoryLowSCN return number;
 
--
--
--
--
 
procedure checkLogHistory(
  rlh_recid   IN number
 ,rlh_stamp   IN number
 ,thread#     IN number
 ,sequence#   IN number
 ,low_scn     IN number
 ,low_time    IN date
 ,next_scn    IN number
 ,reset_scn   IN number default NULL
 ,reset_time  IN date default NULL
);
 
--
--
--
--
 
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
procedure endLogHistoryResync;
 
--
--
 
 
 
/*-------------------------*
 * Archived Log resync     *
 *-------------------------*/
 
function beginArchivedLogResync return number;
 
--
 
 
procedure checkArchivedLog(
  al_recid    IN number
 ,al_stamp    IN number
 ,thread#     IN number
 ,sequence#   IN number
 ,reset_scn   IN number
 ,reset_time  IN date
 ,low_scn     IN number
 ,low_time    IN date
 ,next_scn    IN number
 ,next_time   IN date
 ,blocks      IN number
 ,block_size  IN number
 ,fname       IN varchar2
 ,archived    IN varchar2
 ,completion_time IN date
 ,status      IN varchar2
 ,is_standby  IN varchar2 DEFAULT NULL
 ,dictionary_begin IN varchar2 DEFAULT NULL
 ,dictionary_end   IN varchar2 DEFAULT NULL
 ,is_recovery_dest_file 
                   IN varchar2 default 'NO'
 ,compressed       IN varchar2 default 'NO'
 ,creator          IN varchar2 default NULL
 ,terminal         IN varchar2 default 'NO'
 ,chk_last_recid   IN boolean  DEFAULT TRUE
);
 
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
 
procedure endArchivedLogResync;
 
--
--
 
 
 
/*-------------------------*
 * Offline range resync    *
 *-------------------------*/
 
function beginOfflineRangeResync return number;
 
--
--
 
 
procedure checkOfflineRange(
  offr_recid     IN number
 ,offr_stamp     IN number
 ,file#          IN number
 ,create_scn     IN number
 ,offline_scn    IN number
 ,online_scn     IN number
 ,online_time    IN date
 ,cf_create_time IN date
 ,reset_scn   IN number default NULL
 ,reset_time  IN date default NULL
);
 
--
 
 
--
--
--
--
--
 
 
procedure endOfflineRangeResync;
 
--
 
 
 
/*-------------------------*
 * Backup Set resync       *
 *-------------------------*/
 
function beginBackupSetResync return number;
 
--
--
 
 
procedure checkBackupSet(
  bs_recid        IN number
 ,bs_stamp        IN number
 ,set_stamp       IN number
 ,set_count       IN number
 ,bck_type        IN varchar2
 ,incr_level      IN number         DEFAULT NULL
 ,pieces          IN number
 ,start_time      IN date
 ,completion_time IN date
 ,controlfile_included
                  IN VARCHAR2       DEFAULT NULL
 ,input_file_scan_only
                  IN VARCHAR2       DEFAULT NULL
 ,keep_options    IN number         DEFAULT 0
 ,keep_until      IN date           DEFAULT NULL
 ,block_size      IN number         DEFAULT NULL
 ,multi_section   IN varchar2       DEFAULT NULL
 ,chk_last_recid  IN boolean        DEFAULT TRUE
 ,guid            IN raw            DEFAULT NULL
 ,dropped_pdb     IN binary_integer DEFAULT 0 
);
 
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endBackupSetResync;
 
--
 
 
 
/*-------------------------*
 * Backup piece resync     *
 *-------------------------*/
 
function beginBackupPieceResync return number;
 
 
procedure checkBackupPiece(
  bp_recid                IN number
 ,bp_stamp                IN number
 ,set_stamp               IN number
 ,set_count               IN number
 ,piece#                  IN number
 ,tag                     IN varchar2
 ,device_type             IN varchar2
 ,handle                  IN varchar2
 ,comments                IN varchar2
 ,media                   IN varchar2
 ,concur                  IN varchar2
 ,start_time              IN date
 ,completion_time         IN date
 ,status                  IN varchar2
 ,copy#                   IN number         default 1
 ,media_pool              IN number         default 0
 ,bytes                   IN number         default NULL
 ,is_recovery_dest_file   IN varchar2       default 'NO'
 ,rsr_recid               IN number         default NULL
 ,rsr_stamp               IN number         default NULL
 ,compressed              IN varchar2       default 'NO'
 ,encrypted               IN varchar2       default 'NO'
 ,backed_by_osb           IN varchar2       default 'NO'
 ,ba_access               IN varchar2       default 'U'
 ,vbkey                   IN number         default NULL
 ,chk_last_recid          IN boolean        default TRUE
 ,lib_key                 IN number         default NULL
 ,guid                    IN raw            default NULL
 ,template_key            IN number         default NULL
 ,dropped_pdb             IN binary_integer default 0
);
 
function checkBackupPiece(
  bp_recid                IN number
 ,bp_stamp                IN number
 ,set_stamp               IN number
 ,set_count               IN number
 ,piece#                  IN number
 ,tag                     IN varchar2
 ,device_type             IN varchar2
 ,handle                  IN varchar2
 ,comments                IN varchar2
 ,media                   IN varchar2
 ,concur                  IN varchar2
 ,start_time              IN date
 ,completion_time         IN date
 ,status                  IN varchar2
 ,copy#                   IN number         default 1
 ,media_pool              IN number         default 0
 ,bytes                   IN number         default NULL
 ,is_recovery_dest_file   IN varchar2       default 'NO'
 ,rsr_recid               IN number         default NULL
 ,rsr_stamp               IN number         default NULL
 ,compressed              IN varchar2       default 'NO'
 ,encrypted               IN varchar2       default 'NO'
 ,backed_by_osb           IN varchar2       default 'NO'
 ,ba_access               IN varchar2       default 'U'
 ,vbkey                   IN number         default NULL
 ,chk_last_recid          IN boolean        default TRUE
 ,lib_key                 IN number         default NULL
 ,guid                    IN raw            default NULL
 ,template_key            IN number         default NULL
 ,dropped_pdb             IN binary_integer default 0
) return number;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endBackupPieceResync;
 
 
 
/*-------------------------*
 * Backup Datafile resync  *
 *-------------------------*/
 
function beginBackupDataFileResync return number;
 
procedure checkBackupDataFile(
  bdf_recid           IN number
 ,bdf_stamp           IN number
 ,set_stamp           IN number
 ,set_count           IN number
 ,file#               IN number
 ,create_scn          IN number
 ,create_time         IN date
 ,reset_scn           IN number
 ,reset_time          IN date
 ,incr_level          IN number
 ,incr_scn            IN number
 ,ckp_scn             IN number
 ,ckp_time            IN date
 ,abs_fuzzy_scn       IN number
 ,datafile_blocks     IN number
 ,blocks              IN number
 ,block_size          IN number
 ,min_offr_recid      IN number
 ,completion_time     IN date
 ,controlfile_type    IN varchar2       DEFAULT NULL
 ,cfile_abck_year     IN number         DEFAULT NULL
 ,cfile_abck_mon_day  IN number         DEFAULT NULL
 ,cfile_abck_seq      IN number         DEFAULT NULL
 ,chk_last_recid      IN boolean        DEFAULT TRUE
 ,blocks_read         IN number         DEFAULT NULL
 ,used_chg_track      IN varchar2       DEFAULT 'NO'
 ,used_optim          IN varchar2       DEFAULT 'NO'
 ,foreign_dbid        IN number         DEFAULT 0
 ,plugged_readonly    IN varchar2       DEFAULT 'NO'
 ,plugin_scn          IN number         DEFAULT 0
 ,plugin_reset_scn    IN number         DEFAULT 0
 ,plugin_reset_time   IN date           DEFAULT NULL
 ,section_size        IN number         DEFAULT NULL
 ,guid                IN raw            DEFAULT NULL
 ,sparse_backup       IN varchar2       DEFAULT 'NO'
 ,isResync            IN boolean        DEFAULT TRUE
 ,isVirtual           IN boolean        DEFAULT FALSE
 ,dropped_pdb         IN binary_integer DEFAULT 0
);
 
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endBackupDataFileResync;
 
/*-------------------------*
 * Backup SPFILE resync  *
 *-------------------------*/
 
function beginBackupSpFileResync return number;
 
procedure checkBackupSpFile(
  bsf_recid         IN number
 ,bsf_stamp         IN number
 ,set_stamp         IN number
 ,set_count         IN number
 ,modification_time IN date
 ,bytes             IN number
 ,chk_last_recid    IN boolean        DEFAULT TRUE
 ,db_unique_name    IN varchar2       DEFAULT NULL
 ,guid              IN raw            DEFAULT NULL
 ,dropped_pdb       IN binary_integer DEFAULT 0
);
 
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
procedure endBackupSpFileResync;
 
/*-------------------------*
 * Backup Redo Log resync  *
 *-------------------------*/
 
function beginBackupRedoLogResync return number;
 
procedure checkBackupRedoLog(
  brl_recid      IN number
 ,brl_stamp      IN number
 ,set_stamp      IN number
 ,set_count      IN number
 ,thread#        IN number
 ,sequence#      IN number
 ,reset_scn      IN number
 ,reset_time     IN date
 ,low_scn        IN number
 ,low_time       IN date
 ,next_scn       IN number
 ,next_time      IN date
 ,blocks         IN number
 ,block_size     IN number
 ,chk_last_recid IN boolean  DEFAULT TRUE
 ,terminal       IN varchar2 DEFAULT 'NO'
 ,activation     IN varchar2 DEFAULT NULL
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endBackupRedoLogResync;
 
 
/*----------------------------*
 * Copy Datafile resync       *
 *----------------------------*/
 
function beginDataFileCopyResync return number;
 
procedure checkDataFileCopy(
  cdf_recid             IN number
 ,cdf_stamp             IN number
 ,fname                 IN varchar2
 ,tag                   IN varchar2
 ,file#                 IN number
 ,create_scn            IN number
 ,create_time           IN date
 ,reset_scn             IN number
 ,reset_time            IN date
 ,incr_level            IN number
 ,ckp_scn               IN number
 ,ckp_time              IN date
 ,onl_fuzzy             IN varchar2
 ,bck_fuzzy             IN varchar2
 ,abs_fuzzy_scn         IN number
 ,rcv_fuzzy_scn         IN number
 ,rcv_fuzzy_time        IN date
 ,blocks                IN number
 ,block_size            IN number
 ,min_offr_recid        IN number
 ,completion_time       IN date
 ,status                IN varchar2
 ,controlfile_type      IN varchar2       DEFAULT NULL
 ,keep_options          IN number         DEFAULT 0
 ,keep_until            IN date           DEFAULT NULL
 ,scanned               IN varchar2       DEFAULT 'NO'
 ,is_recovery_dest_file IN varchar2       DEFAULT 'NO'
 ,rsr_recid             IN number         DEFAULT NULL
 ,rsr_stamp             IN number         DEFAULT NULL
 ,marked_corrupt        IN number         DEFAULT NULL
 ,foreign_dbid          IN number         DEFAULT 0
 ,plugged_readonly      IN varchar2       DEFAULT 'NO'
 ,plugin_scn            IN number         DEFAULT 0
 ,plugin_reset_scn      IN number         DEFAULT 0
 ,plugin_reset_time     IN date           DEFAULT NULL
 ,guid                  IN raw            DEFAULT NULL
 ,sparse_backup         IN varchar2       DEFAULT 'NO'
 ,dropped_pdb           IN binary_integer DEFAULT 0
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endDataFileCopyResync;
 
 
/*----------------------------*
 * Corrupt Block resync       *
 *----------------------------*/
 
function beginBackupCorruptionResync return number;
 
procedure checkBackupCorruption(
  bcb_recid       IN number
 ,bcb_stamp       IN number
 ,set_stamp       IN number
 ,set_count       IN number
 ,piece#          IN number
 ,file#           IN number
 ,block#          IN number
 ,blocks          IN number
 ,corrupt_scn     IN number
 ,marked_corrupt  IN varchar2
 ,corruption_type IN varchar2 default NULL
);
 
procedure endBackupCorruptionResync;
 
 
function beginCopyCorruptionResync return number;
 
procedure checkCopyCorruption(
  ccb_recid       IN number
 ,ccb_stamp       IN number
 ,cdf_recid       IN number
 ,cdf_stamp       IN number
 ,file#           IN number
 ,block#          IN number
 ,blocks          IN number
 ,corrupt_scn     IN number
 ,marked_corrupt  IN varchar2
 ,corruption_type IN varchar2 default NULL
);
 
procedure endCopyCorruptionResync;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
 
/*----------------------------*
 * Deleted Object resync      *
 *----------------------------*/
 
function beginDeletedObjectResync return number;
 
procedure checkDeletedObject(
  do_recid          IN number
 ,do_stamp          IN number
 ,object_type       IN varchar2
 ,object_recid      IN number
 ,object_stamp      IN number
 ,object_data       IN number   DEFAULT NULL
 ,object_fname      IN varchar2 DEFAULT NULL
 ,object_create_scn IN number   DEFAULT NULL
 ,set_stamp         IN number   DEFAULT NULL
 ,set_count         IN number   DEFAULT NULL
 ,handle            IN VARCHAR2 DEFAULT NULL
 ,device_type       IN VARCHAR2 DEFAULT NULL
);
 
procedure endDeletedObjectResync;
 
/*-------------------*
 * Proxy Copy resync *
 *-------------------*/
 
function beginProxyResync return number;
 
procedure checkProxyDataFile(
  xdf_recid         IN number
 ,xdf_stamp         IN number
 ,tag               IN varchar2
 ,file#             IN number
 ,create_scn        IN number
 ,create_time       IN date
 ,reset_scn         IN number
 ,reset_time        IN date
 ,incr_level        IN number
 ,ckp_scn           IN number
 ,ckp_time          IN date
 ,onl_fuzzy         IN varchar2
 ,bck_fuzzy         IN varchar2
 ,abs_fuzzy_scn     IN number
 ,rcv_fuzzy_scn     IN number
 ,rcv_fuzzy_time    IN date
 ,blocks            IN number
 ,block_size        IN number
 ,min_offr_recid    IN number
 ,device_type       IN varchar2
 ,handle            IN varchar2
 ,comments          IN varchar2
 ,media             IN varchar2
 ,media_pool        IN number
 ,start_time        IN date
 ,completion_time   IN date
 ,status            IN varchar2
 ,controlfile_type  IN varchar2       DEFAULT NULL
 ,keep_options      IN number         DEFAULT 0
 ,keep_until        IN date           DEFAULT NULL
 ,rsr_recid         IN number         DEFAULT NULL
 ,rsr_stamp         IN number         DEFAULT NULL
 ,foreign_dbid      IN number         DEFAULT 0
 ,plugged_readonly  IN varchar2       DEFAULT 'NO'
 ,plugin_scn        IN number         DEFAULT 0
 ,plugin_reset_scn  IN number         DEFAULT 0
 ,plugin_reset_time IN date           DEFAULT NULL
 ,guid              IN raw            DEFAULT NULL
 ,dropped_pdb       IN binary_integer DEFAULT 0
);
 
PROCEDURE checkProxyArchivedLog(
  xal_recid          IN NUMBER
 ,xal_stamp          IN NUMBER
 ,tag                IN VARCHAR2
 ,thread#            IN NUMBER
 ,sequence#          IN NUMBER
 ,resetlogs_change#  IN NUMBER
 ,resetlogs_time     IN DATE
 ,first_change#      IN NUMBER
 ,first_time         IN DATE
 ,next_change#       IN NUMBER
 ,next_time          IN DATE
 ,blocks             IN NUMBER
 ,block_size         IN NUMBER
 ,device_type        IN VARCHAR2
 ,handle             IN VARCHAR2
 ,comments           IN VARCHAR2
 ,media              IN VARCHAR2
 ,media_pool         IN NUMBER
 ,start_time         IN DATE
 ,completion_time    IN DATE
 ,status             IN VARCHAR2
 ,rsr_recid          IN NUMBER
 ,rsr_stamp          IN NUMBER
 ,terminal           IN VARCHAR2 default 'NO'
 ,keep_until         IN DATE     default NULL
 ,keep_options       IN NUMBER   default 0
);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
procedure endProxyResync;
 
/*-------------------------*
 * Incarnation resync     *
 *-------------------------*/
 
FUNCTION beginIncarnationResync(return_Recid in boolean DEFAULT FALSE) 
                               return number;
--
--
--
--
 
function checkIncarnation(reset_scn         IN NUMBER,
                          reset_time        IN DATE,
                          prior_reset_scn   IN NUMBER DEFAULT NULL,
                          prior_reset_time  IN DATE DEFAULT NULL,
                          db_name           IN VARCHAR2 DEFAULT 'UNKNOWN')
                         return number;
--
--
--
 
procedure endIncarnationResync(high_kccdivts IN NUMBER, 
                               high_ic_recid IN NUMBER DEFAULT 0);
--
--
 
/*--------------------------------*
 * Pluggable DB Incaration Resync *
 *--------------------------------*/
FUNCTION beginPluggableDbincResync RETURN NUMBER;
 
--
--
--
 
PROCEDURE checkPluggableDbinc(
  recid               IN NUMBER
 ,guid                IN RAW
 ,curr_pdbinc         IN VARCHAR2
 ,inc_scn             IN NUMBER
 ,begin_reset_scn     IN NUMBER
 ,begin_reset_time    IN DATE
 ,end_reset_scn       IN NUMBER
 ,db_reset_scn        IN NUMBER
 ,db_reset_time       IN DATE
 ,pr_inc_scn          IN NUMBER
 ,pr_end_reset_scn    IN NUMBER
 ,pr_db_reset_scn     IN NUMBER
 ,pr_db_reset_time    IN DATE
 ,chk_last_recid      IN BOOLEAN
);
--
--
--
 
PROCEDURE endPluggableDbincResync(high_pic_recid IN NUMBER);
 
--
--
 
/*-----------------------------*
 * Normal restore point Resync *
 *-----------------------------*/
 
FUNCTION beginRestorePointResync RETURN NUMBER;
 
PROCEDURE checkRestorePoint(
  nrsp_recid    IN NUMBER
 ,nrsp_stamp    IN NUMBER
 ,nrsp_name     IN VARCHAR2
 ,reset_scn     IN NUMBER
 ,reset_time    IN DATE
 ,to_scn        IN NUMBER
 ,nrsp_time     IN DATE
 ,create_time   IN DATE
 ,deleted       IN NUMBER
 ,con_id        IN NUMBER   DEFAULT NULL
 ,clean         IN VARCHAR2 DEFAULT 'NO'
);
 
PROCEDURE endRestorePointResync(lowrecid IN number);
 
 
/*----------------------------*
 * RMAN Status resync         *
 *----------------------------*/
 
FUNCTION beginRmanStatusResync RETURN NUMBER;
--
--
 
 
PROCEDURE checkRmanStatus( recid            IN NUMBER
                          ,stamp            IN NUMBER
                          ,parent_recid     IN NUMBER
                          ,parent_stamp     IN NUMBER
                          ,row_level        IN NUMBER
                          ,row_type         IN VARCHAR2
                          ,command_id       IN VARCHAR2
                          ,operation        IN VARCHAR2
                          ,status           IN VARCHAR2
                          ,mbytes_processed IN NUMBER
                          ,start_time       IN DATE
                          ,end_time         IN DATE
                          ,ibytes           IN NUMBER default null
                          ,obytes           IN NUMBER default null
                          ,optimized        IN VARCHAR2 default null
                          ,otype            IN VARCHAR2 default null
                          ,session_recid    IN NUMBER default null
                          ,session_stamp    IN NUMBER default null
                          ,odevtype         IN VARCHAR2 default null
                          ,osb_allocated    IN VARCHAR2 default 'NO');
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE endRmanStatusResync(recid number);
--
 
 
PROCEDURE updateRmanStatusRow( recid   IN number
                              ,stamp   IN number
                              ,mbytes  IN number
                              ,status  IN binary_integer);
--
 
/*----------------------------*
 * RMAN Output resync         *
 *----------------------------*/
 
FUNCTION beginRmanOutputResync(start_timestamp in NUMBER) RETURN NUMBER;
--
--
 
FUNCTION beginRmanOutputResync(start_timestamp IN  NUMBER
                              ,doRoutMining    OUT BOOLEAN) RETURN NUMBER;
 
PROCEDURE checkRmanOutput( recid             IN NUMBER
                          ,stamp             IN NUMBER
                          ,session_recid     IN NUMBER
                          ,session_stamp     IN NUMBER
                          ,rman_status_recid IN NUMBER
                          ,rman_status_stamp IN NUMBER
                          ,output       IN VARCHAR2);
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE endRmanOutputResync;
--
 
/*----------------------------*
 * Block Corruption Resync    *
 *----------------------------*/
function beginBlockCorruptionResync(
  low_bcr_recid   IN number)
 return number;
 
procedure checkBlockCorruption(
  bcr_recid       IN number
 ,bcr_stamp       IN number
 ,file#           IN number
 ,create_scn      IN number
 ,create_time     IN date
 ,block#          IN number
 ,blocks          IN number
 ,corrupt_scn     IN number
 ,corruption_type IN varchar2
);
 
procedure endBlockCorruptionResync;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
/*----------------------------*
 * Change Procedures          *
 *----------------------------*/
 
procedure changeDataFileCopy(
  cdf_recid    IN number
 ,cdf_stamp    IN number
 ,status       IN varchar2
 ,keep_options IN number DEFAULT NULL -- null means don't update
 ,keep_until   IN date   DEFAULT NULL
 ,osite_key    IN number DEFAULT NULL
 ,nsite_key    IN number DEFAULT NULL
);
 
--
--
--
 
procedure changeControlfileCopy(
  cdf_recid    IN number
 ,cdf_stamp    IN number
 ,status       IN varchar2
 ,keep_options IN number DEFAULT NULL -- null means don't update
 ,keep_until   IN date   DEFAULT NULL
 ,osite_key    IN number DEFAULT NULL
 ,nsite_key    IN number DEFAULT NULL
);
 
--
--
 
procedure changeArchivedLog(
  al_recid  IN number
 ,al_stamp  IN number
 ,status    IN varchar2
 ,osite_key IN number DEFAULT NULL
 ,nsite_key IN number DEFAULT NULL
);
 
--
--
 
 
procedure changeBackupSet(
  recid        IN number
 ,stamp        IN number
 ,keep_options IN number   -- null means don't update
 ,keep_until   IN date
 ,osite_key    IN number DEFAULT NULL
 ,nsite_key    IN number DEFAULT NULL
);
 
--
--
--
 
procedure changeBackupPiece(
  bp_recid  IN number
 ,bp_stamp  IN number
 ,status    IN varchar2
 ,set_stamp IN number DEFAULT NULL
 ,set_count IN number DEFAULT NULL
 ,osite_key IN number DEFAULT NULL
 ,nsite_key IN number DEFAULT NULL
 ,handle    IN VARCHAR2  DEFAULT NULL
 ,device_type IN VARCHAR2 DEFAULT NULL
 
);
 
--
--
 
procedure changeProxyCopy(
  pc_recid     IN number
 ,pc_stamp     IN number
 ,status       IN varchar2
 ,keep_options IN number  DEFAULT NULL -- null means don't update
 ,keep_until   IN date    DEFAULT NULL
 ,osite_key IN number DEFAULT NULL
 ,nsite_key    IN number DEFAULT NULL
);
 
--
--
 
 
/*----------------------------*
 * Reconcile for Replication  *
 *----------------------------*/
 
PROCEDURE doReplicationReconcile(p_db_key IN NUMBER, 
                                 p_lib_key IN NUMBER,
                                 p_server_key IN NUMBER);
 
 
--
 
 
/*----------------------------*
 * Stored Script Procedures   *
 *----------------------------*/
 
procedure createScript(name IN varchar2);
 
procedure createScript(name IN varchar2,
                       scr_com IN varchar2,
                       global  IN boolean);
 
procedure replaceScript(name IN varchar2);
 
procedure replaceScript(name IN varchar2,
                        scr_com IN varchar2,
                        global  IN boolean);
 
--
--
--
--
 
procedure putLine(line IN varchar2);
 
--
--
--
--
 
procedure deleteScript(name IN varchar2);
 
procedure deleteScript(name IN varchar2, glob IN number);
 
--
 
procedure getScript(name IN varchar2);
 
procedure getScript(name IN varchar2, glob IN number);
 
--
--
--
 
function getLine return varchar2;
 
--
--
 
procedure commitChanges(msg IN varchar2 default NULL);
 
--
 
/*---------------------------------------*
 * Procedures for EM xml store support   
 * The initial user of this API will be EM, however other client that intends 
 * to save XML data in RMAN's recovery catalog can also use the API.
 * The API provides the versioned file system functionality, i.e. the clients
 * can save multiple version of same XML file, with additional option to
 * overwrite the latest version.
 *---------------------------------------*/
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
procedure createXMLFile (name        IN varchar2 
                        ,name_tag    IN varchar2 default null
                        ,xmldoc      IN clob
                        ,doctype     IN varchar2 default null
                        ,xml_comment IN varchar2 default null
                        ,schema_ver  IN varchar2 default null);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
procedure updateXMLFile (name        IN varchar2
                        ,name_tag    IN varchar2 default null
                        ,xmldoc      IN clob     default null
                        ,xml_comment IN varchar2 default null
                        ,schema_ver  IN varchar2 default null
                        ,new_name    IN varchar2 default null
                        ,new_name_tag IN varchar2 default null
                        ,new_version  IN BOOLEAN default FALSE);
 
--
procedure deleteXMLFile (name       IN varchar2
                        ,name_tag   IN varchar2 default null);
 
--
--
--
--
--
--
--
--
procedure readXMLFile   (name        IN varchar2
                        ,name_tag    IN varchar2 default null
                        ,version_num IN number default null
                        ,xmldoc      OUT clob);
 
--
--
--
--
--
--
--
--
--
procedure getXMLFileAttr (name        IN varchar2
                         ,name_tag    IN varchar2 default null
                         ,version_num IN number default null
                         ,doctype     OUT varchar2
                         ,file_size   OUT number
                         ,xml_comment OUT varchar2
                         ,schema_ver  OUT varchar2);
 
/*---------------------------------------*
 * Procedures for clone database support *
 *---------------------------------------*/
 
procedure setCloneName(file#            IN     number
                      ,creation_change# IN     number
                      ,new_clone_fname  IN     varchar2
                      ,old_clone_fname  IN     varchar2
                      ,changedauxname   OUT    boolean
                      ,plugin_change#   IN number   DEFAULT 0);
 
FUNCTION  getCloneName(file#            IN number
                      ,creation_change# IN number
                      ,plugin_change#   IN number  DEFAULT 0) RETURN VARCHAR2;
 
 
/*-----------------------------------*
 * Procedures for RMAN configuration *
 *-----------------------------------*/
 
PROCEDURE setConfig(conf#            IN NUMBER
                   ,name             IN VARCHAR2
                   ,value            IN VARCHAR2);
 
 
PROCEDURE resetConfig;
 
PROCEDURE setConfig2(conf#           IN NUMBER
                    ,name            IN VARCHAR2
                    ,value           IN VARCHAR2
                    ,nodespec        IN BOOLEAN);
 
PROCEDURE resetConfig2(nodespec      IN BOOLEAN, 
                       high_conf_recid IN NUMBER DEFAULT NULL);
 
PROCEDURE deleteConfig(conf#         IN NUMBER);
 
FUNCTION  setConfig3(name            IN VARCHAR2
                    ,value           IN VARCHAR2
                    ,db_unique_name  IN VARCHAR2) RETURN NUMBER;
 
PROCEDURE deleteConfig3(conf#        IN NUMBER
                    ,db_unique_name  IN VARCHAR2);
 
/*----------------------------*
 * Version info               *
 *----------------------------*/
 
function getPackageVersion return varchar2;
function getCatalogVersion return varchar2;
 
/*-------------------*
 * Utility functions *
 *-------------------*/
 
/*
 * NAME
 *   bsStstusRecalc
 * DESCRIPTION
 *   Recompute the backupset status for all backupset whose current
 *   status is a specified value.  This is intended to be used when
 *   new values are introduced for the bs.status column.
 */
 
PROCEDURE bsStatusRecalc(status IN varchar2);
 
--
--
--
 
--
--
--
--
--
--
 
PROCEDURE reNormalize(newname IN varchar2, oldname OUT varchar2);
 
--
--
--
 
PROCEDURE sanityCheck;
 
--
--
--
--
--
--
--
--
--
--
 
FUNCTION getDbid RETURN NUMBER;
 
PROCEDURE listScriptNames(glob IN number, 
                          allnames IN number);
 
--
--
--
--
--
--
 
PROCEDURE getScriptNames(dbname  OUT varchar2,
                         scnm    OUT varchar2,
                         sccom   OUT varchar2);
 
--
--
--
--
--
 
PROCEDURE updateOldestFlashbackSCN(
                oldest_flashback_scn     IN NUMBER,
                oldest_flashback_time    IN DATE   DEFAULT NULL);
 
--
--
 
FUNCTION getDbinc RETURN NUMBER;
 
--
 
FUNCTION isDuplicateRecord(recid    IN NUMBER
                          ,stamp    IN NUMBER
                          ,type     IN VARCHAR2) RETURN BOOLEAN;
--
--
--
--
--
--
 
FUNCTION doDuplicateMining RETURN BOOLEAN;
--
--
 
--
FUNCTION isRoutDuplicateRecord(recid             IN NUMBER
                              ,stamp             IN NUMBER
                              ,session_recid     IN NUMBER
                              ,session_stamp     IN NUMBER
                              ,rman_status_recid IN NUMBER
                              ,rman_status_stamp IN NUMBER)
RETURN BOOLEAN;
 
--
--
PROCEDURE unregisterSite(db_unique_name IN VARCHAR2, 
                         incbcks IN binary_integer);
 
--
--
PROCEDURE renameSite(from_db_unique_name IN VARCHAR2, 
                     to_db_unique_name IN VARCHAR2);
 
--
--
PROCEDURE resyncAddDBUname(cdbunstr IN varchar2);
 
--
--
FUNCTION  getThisSiteKey(db_unique_name in VARCHAR2 DEFAULT NULL) 
   return NUMBER;
 
--
FUNCTION  isAMSchema RETURN BOOLEAN;
 
--
FUNCTION  getAMTstlevel RETURN NUMBER;
 
PROCEDURE enableResyncActions;
 
PROCEDURE setReason(reason IN number, forceSet IN boolean default FALSE);
 
FUNCTION getReason RETURN number;
 
PROCEDURE incResyncActions(action      IN number,
                           objno       IN number,
                           objname     IN varchar2);
 
PROCEDURE getResyncActions(valid      OUT boolean
                           ,added     OUT number
                           ,dropped   OUT number
                           ,changed   OUT number
                           ,recreated OUT number
                           ,renamed   OUT number
                           ,resized   OUT number);
 
PROCEDURE clearResyncActions;
 
PROCEDURE dumpResyncActions;
 
FUNCTION debOK (level IN number DEFAULT RCVCAT_LEVEL_DEFAULT)  RETURN boolean;
 
--
--
--
--
--
PROCEDURE createTempResource(
   name       IN varchar2
  ,data_type  IN varchar2);
 
--
--
--
--
--
--
--
FUNCTION lockTempResource(
   name      IN varchar2
  ,data_type IN varchar2)
RETURN BOOLEAN;
 
--
--
--
--
--
--
--
PROCEDURE cleanupTempResource;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE addDbidToImport(
   first    IN binary_integer
  ,idb      IN varchar2
  ,idbinc   IN varchar2
  ,dbid     IN number    DEFAULT NULL
  ,dbname   IN varchar2  DEFAULT NULL);
 
--
--
--
--
--
--
--
PROCEDURE lockDbidToImport(
   idb   IN varchar2);
 
--
--
--
--
--
--
--
--
PROCEDURE importSchema(
   dblink   IN varchar2
  ,idb      IN varchar2
  ,idbinc   IN varchar2);
 
--
--
--
--
--
PROCEDURE setArchiveFileScopeAttributes(logs_shared IN NUMBER);
 
--
PROCEDURE setBackupFileScopeAttributes(
                 disk_backups_shared IN NUMBER,
                 tape_backups_shared IN NUMBER);
 
 
--
--
--
--
--
--
PROCEDURE unregisterDatabase(
   idb      IN varchar2);
 
--
PROCEDURE clearUnarchivedLogs;
 
/*--------------------------------------*
 * Virtual Private Catalog Procedures   *
 *--------------------------------------*/
 
PROCEDURE grant_catalog(userid IN varchar2, dbname IN varchar2);
PROCEDURE grant_catalog(userid IN varchar2, 
                        dbid IN number,
                        reg_db_unique_name IN varchar2 default null);
PROCEDURE grant_register(userid IN varchar2);
PROCEDURE revoke_catalog(userid IN varchar2, dbname IN varchar2);
PROCEDURE revoke_catalog(userid IN varchar2, 
                         dbid IN number,
                         reg_db_unique_name IN varchar2 default null);
PROCEDURE revoke_register(userid IN varchar2);
PROCEDURE revoke_all(userid IN varchar2);
PROCEDURE create_virtual_catalog;
PROCEDURE drop_virtual_catalog;
PROCEDURE setupVPD(i_oper IN NUMBER);
 
PROCEDURE dumpPkgState (msg in varchar2 default NULL);
 
/*--------------------------------------*
 * Recovery Server Catalog Procedures   *
 *--------------------------------------*/
 
PROCEDURE put_bucket(bktname in varchar2);
FUNCTION get_bucket(bktname in varchar2) return CLOB;
PROCEDURE delete_bucket(bktname in varchar2);
--
--
--
 
PROCEDURE put_object(bktname in varchar2, objname in varchar2,
                     objtype in varchar2, objval in out CLOB);
FUNCTION get_object(bktname in varchar2, 
                    objname in varchar2,
                    parms   in varchar2 DEFAULT null) return CLOB;
PROCEDURE delete_object(bktname in varchar2, objname in varchar2);
 
PROCEDURE writeFixedSections(bktname IN VARCHAR2 DEFAULT NULL);
PROCEDURE readFixedSections(input_xml_filename  IN VARCHAR2,
                            bktname IN VARCHAR2 DEFAULT NULL);
PROCEDURE rsWriteWaterMarks (input_xml_filename  IN VARCHAR2,
                              bktname IN VARCHAR2 DEFAULT NULL);
PROCEDURE writeBackupSections(input_xml_filename  IN VARCHAR2,
                              bktname IN VARCHAR2 DEFAULT NULL);
PROCEDURE readBackupSections(bktname IN VARCHAR2 DEFAULT NULL);
 
PROCEDURE rsDeleteBackupPiece(bp_key IN number, purged IN varchar2);
 
PROCEDURE addTimeZone(
   db_unique_name IN VARCHAR2
  ,db_timezone    IN VARCHAR2
  ,tmz_src        IN VARCHAR2
  ,incarnations   IN VARCHAR2 default 'CURRENT'
);
--
--
--
--
--
--
--
--
--
--
--
--
--
 
FUNCTION getValueFromConfig(entry IN VARCHAR2) RETURN VARCHAR2;
--
--
 
PROCEDURE throttle_me(p_oam_job_id         IN VARCHAR2,
                      p_channels_reqd      IN NUMBER,
                      p_request_time       IN DATE,
                      p_wait               OUT BOOLEAN,
                      p_error_str          OUT VARCHAR2);
 
end dbms_rcvcat;

/
--------------------------------------------------------
--  DDL for Package DBMS_RCVMAN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."DBMS_RCVMAN" authid current_user is
 
--
 
--
--
--
 
TRUE#  CONSTANT number := 1;
FALSE# CONSTANT number := 0;
 
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
 
COPY                  CONSTANT NUMBER :=  1; -- any image copy of a file
FULL_DF_BACKUP        CONSTANT NUMBER :=  2; -- datafile in a full backup set
INCREMENTAL_DF_BACKUP CONSTANT NUMBER :=  3; -- datafile in an incr backup set
BACKUP                CONSTANT NUMBER :=  4; -- any file in a backup set
--
OFFLINE_RANGE         CONSTANT NUMBER :=  5; -- an offline range
CUMULATIVE            CONSTANT NUMBER :=  6; -- cumulative incremental
--
PROXY                 CONSTANT NUMBER :=  7; -- any proxy copy of a file
NONPROXY              CONSTANT NUMBER  := 9; -- any img, bs other than proxy
AVMCOPY               CONSTANT NUMBER := 10; -- only avm image copy of a file
SPARSE                CONSTANT NUMBER := 11; -- for sparse backup
NONSPARSE             CONSTANT NUMBER := 12; -- for nonsparse backup
 
--
 
implicitOfflRange CONSTANT NUMBER := 2**0;
cleanRange        CONSTANT NUMBER := 2**1;
applyOfflRange    CONSTANT NUMBER := 2**2;
dfCopy            CONSTANT NUMBER := 2**3;
proxyFull         CONSTANT NUMBER := 2**4;
buSet             CONSTANT NUMBER := 2**5;
applyIncremental  CONSTANT NUMBER := 2**6;
redo              CONSTANT NUMBER := 2**7;
 
--
maxKind           CONSTANT NUMBER := redo;            -- last real kind above
allKind           CONSTANT NUMBER := (maxKind*2) - 1; -- all real backup types
fullKind          CONSTANT NUMBER := dfCopy + proxyFull + buSet;
tagKind           CONSTANT NUMBER := fullKind + applyIncremental;
 
--
deletedKind       CONSTANT NUMBER := maxKind*2;      -- action deleted
 
--
--
--
 
BSavailable     CONSTANT BINARY_INTEGER := 2**0;
BSunavailable   CONSTANT BINARY_INTEGER := 2**1;
BSdeleted       CONSTANT BINARY_INTEGER := 2**2;
BSexpired       CONSTANT BINARY_INTEGER := 2**3;
--
--
--
--
BSpartial_avail CONSTANT BINARY_INTEGER := 2**4;
 
 
--
--
--
BSdatafile_full  CONSTANT BINARY_INTEGER := 2**0;
BSdatafile_incr  CONSTANT BINARY_INTEGER := 2**1;
BSarchivelog     CONSTANT BINARY_INTEGER := 2**2;
 
--
--
--
BScfile_all      CONSTANT BINARY_INTEGER := 2**0;      -- shouldn't be altered
BScfile_auto     CONSTANT BINARY_INTEGER := 2**1;
 
--
--
--
 
TYPE dfRec_t IS RECORD
(
   dfNumber             number,
   dfCreationSCN        number,
   dfCreationTime       date,
   fileName             varchar2(1024),
   tsName               varchar2(30),
   tsNumber             number,
   status               number,
   blocks               number,
   blockSize            number,
   kbytes               number,
   unrecovSCN           number,
   stopSCN              number,
   readOnly             number,
   rfNumber             number,
   inBackup             number,     -- if greater than 0 then
--
   auxName              varchar2(1024),
   dbincKey             number,
   dfOfflineSCN         number, 
   dfOnlineSCN          number, 
   dfOnlineTime         date,
   encrypt              number,     -- encrypt value 1=ON, 2=OFF, 3=CLEAR
   foreignDbid          number,         -- foreign database id
   pluggedRonly         binary_integer, -- 1 for read-only. Otherwise, 0
   pluginSCN            number,         -- plugin change#
   pluginRlgSCN         number,         -- plugin resetlogs_change#
   pluginRlgTime        date,           -- plugin resetlogs_time
   newDfCreationSCN     number,         -- plugin scn or creation scn
   creation_thread      number,         -- creation thread
   creation_size        number,         -- creation size
   pdbId                number,         -- pdbid
   pdbKey               number,         -- pdbKey
   pdbName              varchar2(128),  -- pdbname
   pdbClosed            number,         -- pdbclosed
   pdbForeignDbid       number, -- dbid of PDB from which this file came from
   noBackupPdb          number          -- this PDB is excluded from backup
);
 
TYPE prePluginDfRec_t IS RECORD
(
   dfNumber             number,
   pdbId                number,
   prePluginDfNumber    number
);
   
--
--
--
 
TYPE tfRec_t IS RECORD
(
   tfNumber             number,
   tfCreationSCN        number,
   tfCreationTime       date,
   fileName             varchar2(1024),
   tsName               varchar2(30),
   tsNumber             number,
   status               number,
   isSFT                varchar2(3),
   blocks               number,
   blockSize            number,
   maxSize              number,
   nextSize             number,
   rfNumber             number,
   dbincKey             number,
   pdbId                number,
   pdbKey               number,
   pdbName              varchar2(128)
);
 
--
--
--
 
TYPE alRec_t IS RECORD
(
   key                  number,
   recid                number,
   stamp                number,
   thread               number,
   sequence             number,
   fileName             varchar2(1024),
   lowSCN               number,
   lowTime              date,
   nextSCN              number,
   nextTime             date,
   rlgSCN               number,
   rlgTime              date,
   blocks               number,
   blockSize            number,
   status               varchar2(1),
   compTime             date,
   duplicate            number,
   isrdf                varchar2(3),
   compressed           varchar2(3),
   stby                 varchar2(1),
   terminal             varchar2(3),
   site_key             number,
   site_key_order_col   number,
   source_dbid          number
);
 
--
--
--
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
 
--
 
--
--
--
 
TYPE rcvRec_t IS RECORD
(
--
 
   type_con             number,         -- recovery container type
   key_con              number,         -- primary key
   recid_con            number,         -- recid
   stamp_con            number,         -- stamp
   setStamp_con         number,         -- set count if backup set (null)
   setCount_con         number,         -- set stamp if backup set (null)
   bsRecid_con          number,         -- backup set recid (null)
   bsStamp_con          number,         -- backup set stamp (null)
   bsKey_con            number,         -- backup set key (null)
   bsLevel_con          number,         -- backup set level (null)
   bsType_con           varchar2(1),    -- backup set type
   elapseSecs_con       number,         -- backup set elapse seconds (null)
   pieceCount_con       number,         -- backup set piece count (null)
   fileName_con         varchar2(1024), -- filename if a copy (or) piece (null)
   tag_con              varchar2(32),   -- tag (null)
--
--
   copyNumber_con       number,         -- backup set copy# (null) maxlimit 256
--
   status_con           varchar2(1),    -- status (null)
   blocks_con           number,         -- size of file in blocks (null)
   blockSize_con        number,         -- block size (null)
   deviceType_con       varchar2(255),  -- device type required (null)
--
--
   compTime_con         date,           -- completion time
   cfCreationTime_con   date,           -- controlfile creation time if
--
   pieceNumber_con      number,
   bpCompTime_con       date,
   bpCompressed_con     varchar2(3),
 
   multi_section_con    varchar2(1),    -- multi-section backup piece
 
--
 
   type_act             number,         -- recovery action type
   fromSCN_act          number,
   toSCN_act            number,
   toTime_act           date,
   rlgSCN_act           number,
   rlgTime_act          date,
   dbincKey_act         number,
   level_act            number,
   section_size_act     number,
 
--
 
   dfNumber_obj         number,
   dfCreationSCN_obj    number,
   cfSequence_obj       number,        -- controlfile autobackup sequence
   cfDate_obj           date,          -- controlfile autobackup date
   logSequence_obj      number,
   logThread_obj        number,
   logRlgSCN_obj        number,
   logRlgTime_obj       date,
   logLowSCN_obj        number,
   logLowTime_obj       date,
   logNextSCN_obj       number,
   logNextTime_obj      date,
   logTerminal_obj      varchar2(3),
   cfType_obj           varchar2(1),   -- controlfile type ('B' or 'S')
   pdbKey_obj           number,
 
--
   keep_options         number,
   keep_until           date,
 
--
 
   afzSCN_act           number,
   rfzTime_act          date,
   rfzSCN_act           number,
 
--
   media_con            varchar2(80),    -- media volume name for backup piece
 
   isrdf_con            varchar2(3),
 
--
   site_key_con         number,
 
--
   foreignDbid_obj      number,         -- foreign database id
   pluggedRonly_obj     binary_integer, -- 1 for read-only. Otherwise, 0
   pluginSCN_obj        number,         -- plugin change#
   pluginRlgSCN_obj     number,         -- plugin resetlogs change#
   pluginRlgTime_obj    date,           -- plugin resetlogs time
 
--
   newDfCreationSCN_obj number,         -- plugin scn or creation scn
   newToSCN_act         number,         -- plugin scn or checkpoint scn
   newRlgSCN_act        number,         -- plugin rlgscn or rlgscn
   newRlgTime_act       date,           -- plugin rlgtime or rlgtime
 
--
   sfDbUniqueName_obj   varchar2(30),
 
--
   sparse_backup_con    varchar2(3),    -- whether sparse or nonsparse backup
   ppl_pdb_id_con       number,         -- preplugin pdb id
   ppl_cdb_dbid_con     number          -- preplugin cdb database id
);
 
--
--
--
 
--
--
--
--
--
--
--
--
 
--
 
offlineRangeRec_con_t   CONSTANT NUMBER := 2**0;
proxyCopy_con_t         CONSTANT NUMBER := 2**1;
imageCopy_con_t         CONSTANT NUMBER := 2**2;
backupSet_con_t         CONSTANT NUMBER := 2**3;
addredo_con_t           CONSTANT NUMBER := 2**4;
deleted_con_t           CONSTANT NUMBER := 2**8;
datafile_con_t          CONSTANT NUMBER := 2**9;
avmImageCopy_con_t      CONSTANT NUMBER := 2**10;
 
--
backupMask_con_t        CONSTANT NUMBER := proxyCopy_con_t + imageCopy_con_t +
                                           backupSet_con_t;
tagMask_con_t           CONSTANT NUMBER := proxyCopy_con_t + imageCopy_con_t +
                                           backupSet_con_t;
 
--
--
--
 
full_act_t              CONSTANT NUMBER := 2**0;
incremental_act_t       CONSTANT NUMBER := 2**1;
redo_act_t              CONSTANT NUMBER := 2**2;
offlineRange_act_t      CONSTANT NUMBER := 2**3;
cleanRange_act_t        CONSTANT NUMBER := 2**4;
implicitRange_act_t     CONSTANT NUMBER := 2**5;
spanningRange_act_t     CONSTANT NUMBER := 2**6;
createdatafile_act_t    CONSTANT NUMBER := 2**7;
 
--
--
--
 
--
--
--
 
getCfCopy               CONSTANT NUMBER := 0;
getDfCopy               CONSTANT NUMBER := 1;
getAnyProxy             CONSTANT NUMBER := 2;
getCfBackup             CONSTANT NUMBER := 3;
listCfCopy              CONSTANT NUMBER := 4;
listDfCopy              CONSTANT NUMBER := 5;
listCfBackup            CONSTANT NUMBER := 6;
listDfBackup            CONSTANT NUMBER := 7;
listAlBackup            CONSTANT NUMBER := 8;
listDfProxy             CONSTANT NUMBER := 9;
getRecovAction          CONSTANT NUMBER := 10;
getAlBackup             CONSTANT NUMBER := 11;
listAlCopy              CONSTANT NUMBER := 12;
listBSet                CONSTANT NUMBER := 13;
getSfBackup             CONSTANT NUMBER := 14;
listSfBackup            CONSTANT NUMBER := 15;
getAllBSet              CONSTANT NUMBER := 16;
listAlProxy             CONSTANT NUMBER := 17;
getRangeAlBackup        CONSTANT NUMBER := 18;
 
--
--
--
--
--
--
unknownCmd_t            CONSTANT BINARY_INTEGER := 0;
recoverCmd_t            CONSTANT BINARY_INTEGER := 1;
rcvCopyCmd_t            CONSTANT BINARY_INTEGER := 2;
obsoleteCmd_t           CONSTANT BINARY_INTEGER := 3;
restoreCmd_t            CONSTANT BINARY_INTEGER := 4;
blkRestoreCmd_t         CONSTANT BINARY_INTEGER := 5;
 
--
--
--
--
--
--
stuckMemorySize CONSTANT NUMBER := 50 * 1024 * 1024;
 
--
--
--
 
TYPE bsRec_t IS RECORD
(
   recid                number,
   stamp                number,
   key                  number,
   setStamp             number,
   setCount             number,
   bsType               varchar2(1),
   level                number,
   elapseSecs           number,
   compTime             date,
   status               varchar2(1),
   pieceCount           number,
   keep_options         number,
   keep_until           date,
   multi_section        varchar2(1),
   ppl_pdb_id           number,         -- preplugin pdb id
   ppl_cdb_dbid         number          -- preplugin cdb database id
);
 
--
--
--
 
TYPE bpRec_t IS RECORD
(
   recid                number,
   stamp                number,
   key                  number,
   bskey                number,
   setStamp             number,
   setCount             number,
   bsType               varchar2(1),
   pieceNumber          number,
   copyNumber           number,
   status               varchar2(1),
   compTime             date,
   handle               varchar2(1024),
   tag                  varchar2(32),
   deviceType           varchar2(255),
   media                varchar2(80),
   bytes                number,
   compressed           varchar2(3),
   site_key             number,
   vb_key               number,
   am_access            varchar2(1), -- need for 12.0 compatibility
   ba_access            varchar2(1),
   ppl_pdb_id           number,         -- preplugin pdb id
   ppl_cdb_dbid         number          -- preplugin cdb database id
);
 
--
--
--
 
TYPE validBackupSetRec_t IS RECORD
(
   deviceType   varchar2(255),
   tag          varchar2(32),                   -- may be null
   order1       number,                         -- preference hint
   copyNumber   number,                         -- null if code 2 or 3
   code         number                          -- 1 => same copy#
--
--
--
);
 
bsRecCacheEnabled   constant boolean := TRUE;  -- FALSE to use pre10i method
bsRecCacheLowLimit  constant number  := 2048;  -- minimum cache size
bsRecCacheHighLimit constant number  := 32768; -- maximum cache size
 
 
TYPE incarnation_t IS RECORD
(
INCARNATION#                                       NUMBER,
RESETLOGS_CHANGE#                                  NUMBER,
RESETLOGS_TIME                                     DATE,
PRIOR_RESETLOGS_CHANGE#                            NUMBER,
PRIOR_RESETLOGS_TIME                               DATE,
STATUS                                             VARCHAR2(7),
RESETLOGS_ID                                       NUMBER,
PRIOR_INCARNATION#                                 NUMBER
);
 
TYPE pdb_incarnation_t IS RECORD
(
CON_ID                                             NUMBER,
PDBINC_KEY                                         NUMBER,
INCSCN                                             NUMBER,
ERSCN                                              NUMBER,
STATUS                                             VARCHAR2(7)
);
 
--
--
--
TYPE bhistoryRec_t IS RECORD
(
   dfNumber        number,
   create_scn      number,
   reset_scn       number,
   reset_time      date,
   ckp_scn         number,
   ckp_time        date,
   stop_scn        number,
   logThread       number,
   logSequence     number,
   setStamp        number,
   setCount        number,
   compTime        date,
   nbackups        number,
   logTerminal     varchar2(3),
   next_scn        number,
   pluggedRonly    binary_integer, -- 1 for read-only. Otherwise, 0
   pluginSCN       number,
   pluginRlgSCN    number,
   pluginRlgTime   date,
   newcreate_scn   number,    -- create_scn or pluginSCN
   newreset_scn    number,    -- reset_scn  or pluginRlgSCN
   newreset_time   date       -- reset_time or pluginRlgTime
);
 
--
--
--
TYPE agedFileRec_t IS RECORD
(
   type           number,
   key            number,
   stamp          number
);
 
--
--
--
 
--
--
--
backupset_txt      CONSTANT VARCHAR2(16) := 'BACKUP SET';
copy_txt           CONSTANT VARCHAR2(16) := 'COPY';
proxycopy_txt      CONSTANT VARCHAR2(16) := 'PROXY COPY';
datafile_txt       CONSTANT VARCHAR2(16) := 'DATAFILE';
spfile_txt         CONSTANT VARCHAR2(16) := 'SPFILE';
archivedlog_txt    CONSTANT VARCHAR2(16) := 'ARCHIVED LOG';
controlfile_txt    CONSTANT VARCHAR2(16) := 'CONTROLFILE';
piece_txt          CONSTANT VARCHAR2(16) := 'PIECE';
available_txt      CONSTANT VARCHAR2(16) := 'AVAILABLE';
unavailable_txt    CONSTANT VARCHAR2(16) := 'UNAVAILABLE';
expired_txt        CONSTANT VARCHAR2(16) := 'EXPIRED';
deleted_txt        CONSTANT VARCHAR2(16) := 'DELETED';
other_txt          CONSTANT VARCHAR2(16) := 'OTHER';
full_txt           CONSTANT VARCHAR2(16) := 'FULL';
incr1_txt          CONSTANT VARCHAR2(16) := 'INCR1';
incr2_txt          CONSTANT VARCHAR2(16) := 'INCR2';
incr3_txt          CONSTANT VARCHAR2(16) := 'INCR3';
incr4_txt          CONSTANT VARCHAR2(16) := 'INCR4';
incr_txt           CONSTANT VARCHAR2(16) := 'INCR';        -- level unknown
 
--
--
--
--
--
--
--
TYPE lbRec_t IS RECORD
(
   list_order1        NUMBER,       -- just hint to correctly order records
 
   list_order2        NUMBER,       -- just hint to correctly order records
 
   pkey               NUMBER,       -- primary key
--
--
--
   backup_type        VARCHAR2(32),  -- Type of the backup:
--
--
--
 
--
--
--
   file_type           VARCHAR2(32), -- Type of the file:
--
--
--
--
--
 
--
--
   keep               VARCHAR2(3),
   keep_until         DATE,
   keep_options       VARCHAR2(13),
   status             VARCHAR2(16),   -- Status of the piece/copy:
--
--
--
--
   fname              VARCHAR2(1024), -- piece or copy name
   tag                VARCHAR2(32),   -- piece or copy tag
   media              VARCHAR2(80),
   recid              NUMBER,
   stamp              NUMBER,
   device_type        VARCHAR2(255),
   block_size         NUMBER,
   completion_time    DATE,
   is_rdf             VARCHAR2(3),
   compressed         VARCHAR2(3),
   obsolete           VARCHAR2(3),
   keep_for_dbpitr    VARCHAR2(3),
   bytes              NUMBER,
 
--
--
   bs_key                NUMBER,        
   bs_count              NUMBER,        
   bs_stamp              NUMBER,        
   bs_type               VARCHAR2(32), -- Type of the backup set:
--
--
   bs_incr_type          VARCHAR2(32), 
   bs_pieces             NUMBER,
   bs_copies             NUMBER,
   bs_completion_time    DATE,
   bs_status             VARCHAR2(16),   -- Status of the backup set:
--
--
--
--
   bs_bytes              NUMBER,
   bs_compressed         VARCHAR2(3),    -- If backup set is compressed:
--
--
--
 
   bs_tag                VARCHAR2(1024), -- List of all tags of pieces.
--
--
 
   bs_device_type        VARCHAR2(255),  -- List of device types of pieces. 
--
 
--
--
   bp_piece#             NUMBER,
   bp_copy#              NUMBER,
   bp_vb_key             NUMBER,
   bp_ba_access          VARCHAR2(1),
   bp_lib_key            NUMBER,
 
--
--
   df_file#                  NUMBER,
   df_ts#                    NUMBER,
   df_plugin_change#         NUMBER,
   df_foreign_dbid           NUMBER,
   df_tablespace             VARCHAR2(30),
   df_resetlogs_change#      NUMBER,
   df_creation_change#       NUMBER,
   df_checkpoint_change#     NUMBER,
   df_ckp_mod_time           DATE, 
   df_incremental_change#    NUMBER,
   
--
--
   rl_thread#            NUMBER,
   rl_sequence#          NUMBER,
   rl_resetlogs_change#  NUMBER,
   rl_first_change#      NUMBER,
   rl_first_time         DATE,
   rl_next_change#       NUMBER,
   rl_next_time          DATE,
 
--
   sf_db_unique_name     VARCHAR2(30),
 
--
   con_id                NUMBER
);
 
--
--
--
TYPE lbDfRec_t IS RECORD
(
   dfRec                dfRec_t,
--
--
--
--
--
   fullmin_scn           NUMBER,
   fullmin_rlgscn        NUMBER,
 
--
--
--
--
--
   incrmin_scn           NUMBER,
   incrmin_rlgscn        NUMBER,
 
--
--
--
--
--
   logmin_scn            NUMBER,
   logmin_rlgscn         NUMBER
);
 
TYPE lbDfRecTab_t  IS TABLE     OF lbDfRec_t      INDEX BY BINARY_INTEGER;
TYPE lbRecTab_t    IS TABLE     OF lbRec_t        INDEX BY BINARY_INTEGER;
TYPE lbRecVar_t    IS VARRAY(1) OF lbRec_t;
TYPE rcvRecTabI_t  IS TABLE     OF rcvRec_t       INDEX BY BINARY_INTEGER;
TYPE rcvRecTabII_t IS TABLE     OF rcvRecTabI_t   INDEX BY BINARY_INTEGER;
TYPE dfRecTab_t    IS TABLE     OF dfRec_t        INDEX BY BINARY_INTEGER;
TYPE numTab_t      IS TABLE     OF number         INDEX BY BINARY_INTEGER;
TYPE lbCursor_t    IS REF                         CURSOR;
 
--
--
--
--
--
TYPE lbState_t   IS RECORD
  (
--
--
--
   lbRecOutTab        lbRecTab_t,
   lbRecOutTab_count  binary_integer,
 
--
--
   lbRecTmpTab        lbRecTab_t,
 
--
   lbRecCmn           lbRec_t,
 
--
--
   lbDfRecTabUs       lbDfRecTab_t,
 
--
--
   lbDfRecTab         dfRecTab_t,
 
--
--
   lbMaxDfNumber      number,
 
--
   lbNowTime          date,
 
--
--
   lbPieceCountTab    numTab_t,
   lbCopyCount        binary_integer,
 
--
--
   lbMkTab            rcvRecTabII_t,
 
--
--
   lbMkITab           rcvRecTabII_t,
 
--
--
--
--
--
--
--
--
--
   lbMinGrsp         number,
 
--
--
--
--
--
   lbFbUntilTime     date,
 
--
--
--
--
   lbRlKeepRlgSCN     number,
 
--
--
--
--
--
--
   lbRlKeepSCN        number,
 
--
--
--
--
--
   lbObsoleteRetention boolean,
   lbKeepForDBPITR     boolean,
   lbObsoleteKeep      boolean,
 
   lbNeedObsoleteData  boolean
 );
 
--
--
--
lbStatePck   lbState_t;
 
--
--
--
 
--
--
--
--
--
--
--
--
 
TYPE restoreRange_t IS RECORD
(
   lowTime       DATE,
   highTime      DATE,
   startScn      NUMBER,
   lowScn        NUMBER,
   highScn       NUMBER,
   lowDbIncKey   NUMBER,
   highDbIncKey  NUMBER,
   lowRlgScn     NUMBER,
   highRlgScn    NUMBER,
   lowRlgTime    DATE,
   highRlgTime   DATE,
   rcvStartScn   NUMBER,
   rcvStartTime  DATE,
   isValidRange  BOOLEAN,
   cfBkupFound   BOOLEAN,
   con_id        NUMBER
);
 
TYPE restoreRangeTab_t IS TABLE OF restoreRange_t INDEX BY BINARY_INTEGER;
 
--
 
TYPE failureRec_t IS RECORD
(
   priority      VARCHAR2(8),
   failureId     NUMBER,
   parentId      NUMBER,
   childCount    NUMBER,
   description   VARCHAR2(1024),
   timeDetected  DATE,
   status        VARCHAR2(12),
   impacts       VARCHAR2(1024)
);
 
TYPE repairRec_t IS RECORD
(
   type          NUMBER,
   failureidx    NUMBER,
   repairidx     NUMBER,
   description   VARCHAR2(1024)
);
 
TYPE repairParmsRec_t IS RECORD
(
   type          NUMBER,
   failureidx    NUMBER,
   repairidx     NUMBER,
   name          VARCHAR2(256),
   value         VARCHAR2(512)
);
 
TYPE repairOptionRec_t IS RECORD
(
   optionidx     NUMBER,
   description   VARCHAR2(1024)
);
 
TYPE repairStepRec_t IS RECORD
(
   type           NUMBER,
   failureidx     NUMBER,
   repairidx      NUMBER,
   repairstepidx  NUMBER,
   workingrepair  NUMBER,
   description    VARCHAR2(1024),
   repairscript   VARCHAR2(1024)
);
    
--
--
--
TYPE pdbNameRec_t IS RECORD
(
   pdbId    NUMBER,
   name     VARCHAR2(128)
);
 
TYPE pdbFileRec_t IS RECORD
(
   pdbId    NUMBER,
   file#    NUMBER,
   stopSCN  NUMBER
);
 
cdbRoot_txt  CONSTANT VARCHAR2(8) := 'CDB$ROOT';
 
--
--
--
 
--
--
--
 
FUNCTION dumpState(
   lineno IN number)
RETURN varchar2;
 
PROCEDURE dumpPkgState(msg in varchar2 default null);
 
PROCEDURE setDebugOn;
 
PROCEDURE setDebugOff;
 
--
--
--
--
--
--
--
 
PROCEDURE initialize(rman_vsn IN number);
 
--
--
--
 
PROCEDURE set_package_constants;
 
--
--
--
 
FUNCTION stamp2date(stamp IN number) RETURN date;
 
--
--
--
PROCEDURE getCurrentIncarnation(
   db_id          IN  number
  ,reset_scn      OUT number
  ,reset_time     OUT date);
 
--
--
--
 
--
--
--
--
--
--
--
--
 
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE setDatabase(
   db_name    IN varchar2
  ,reset_scn  IN number
  ,reset_time IN date
  ,db_id      IN number
  ,db_unique_name IN varchar2 default NULL
  ,site_aware IN boolean default FALSE
  ,dummy_instance  IN boolean default FALSE
  ,ors_instance    IN boolean default FALSE);
 
--
--
--
FUNCTION getDbUniqueName(
   db_id      IN number)
RETURN varchar2;
 
--
FUNCTION getDbKey RETURN NUMBER;
 
--
FUNCTION getMinRcvStartScn RETURN NUMBER;
 
--
PROCEDURE resetDbKey;
 
--
--
FUNCTION DbUniqueNameIsStandby
RETURN NUMBER;
 
--
--
PROCEDURE setCanConvertCf(flag IN boolean);
 
--
--
PROCEDURE setDbincKey(
   key IN number);
 
--
--
--
 
FUNCTION getParentIncarnation(
   resetlogs_change# IN OUT number
  ,resetlogs_time    IN OUT date)
RETURN number;
 
--
--
--
--
 
PROCEDURE getCheckpoint(
   scn OUT number
  ,seq OUT number);
 
--
--
 
PROCEDURE getCheckpoint(
   scn       OUT number
  ,seq       OUT number
  ,ckp_key_1 OUT number
  ,ckp_key_2 OUT number);
 
--
--
--
PROCEDURE SetGetSinceLastBackedAL(ntimes  IN number DEFAULT 1,
                                  devtype IN varchar2 DEFAULT NULL,
                                  sbpscn  IN number);
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE setCompletedRange(
   after  IN date
  ,before IN date);
 
PROCEDURE setLikePattern(
   pattern IN varchar2);
 
PROCEDURE setcanApplyAnyRedo(
   flag IN boolean);
 
--
PROCEDURE setBigScnAware;
 
--
PROCEDURE setAllFlag(
   flag IN boolean);
 
PROCEDURE setAllIncarnations(
   flag IN boolean);
 
PROCEDURE setUntilTime(
   unttime IN date);
 
--
--
--
--
--
--
PROCEDURE setUntilScn(
   scn     IN number
  ,rlgscn  IN number  DEFAULT NULL
  ,rlgtime IN date    DEFAULT NULL
  ,flbrp   IN boolean DEFAULT FALSE
  ,rpoint  IN boolean DEFAULT FALSE);
 
PROCEDURE setUntilLog(
   sequence# IN number
  ,thread#   IN number);
 
PROCEDURE setToLog(
   sequence# IN number
  ,thread#   IN number);
 
PROCEDURE setUntilResetlogs;
 
PROCEDURE setGuid(guid IN varchar2 DEFAULT NULL);
 
FUNCTION getUntilTime return date;
 
FUNCTION getUntilScn return number;
 
PROCEDURE resetUntil;
 
--
--
--
--
--
--
--
 
PROCEDURE setFrom(
   restorefrom IN number DEFAULT NULL);
 
--
--
--
--
--
--
PROCEDURE setSparseness(
   sparseness IN number DEFAULT NULL);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE setDeviceType(
   type IN varchar2);
 
--
--
 
PROCEDURE setStandby(
   stby IN boolean);
 
PROCEDURE setDeviceTypeAny;
 
--
 
PROCEDURE resetDeviceType;
 
--
--
--
--
--
--
--
--
 
PROCEDURE setTag(tag IN varchar2 DEFAULT NULL);
 
--
--
--
--
--
--
--
 
PROCEDURE setRecoveryDestFile(onlyrdf IN BOOLEAN);
 
--
--
--
--
--
--
--
--
--
PROCEDURE setOrsFile(localOnly IN BOOLEAN, libKey IN NUMBER);
 
--
--
--
--
--
PROCEDURE setSiteName(db_unique_name IN VARCHAR2, for_realfiles IN NUMBER);
 
--
PROCEDURE clrSiteName;
 
--
FUNCTION getSiteName(site_key IN NUMBER) RETURN VARCHAR2;
 
--
FUNCTION getSiteKey(db_unique_name IN VARCHAR2) RETURN NUMBER;
 
--
PROCEDURE setArchiveFileScopeAttributes(logs_shared IN NUMBER);
 
--
PROCEDURE setFirstFullBckScopeAttributes(baseline_cap IN NUMBER);
 
--
PROCEDURE setBackupFileScopeAttributes(
                 disk_backups_shared IN NUMBER,
                 tape_backups_shared IN NUMBER);
 
--
--
 
PROCEDURE resetAll(transclause IN BOOLEAN DEFAULT TRUE);
 
--
--
--
 
--
--
 
findValidBackupSetRcvRec rcvRec_t;              -- place to save a rcvRec_t
 
PROCEDURE findValidBackupSet(
   backupSetRec            IN     rcvRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL); -- for compat.
 
findValidBackupSetBsRec  bsRec_t;               -- place to save a bsRec_t
 
--
PROCEDURE findValidBackupSet(
   backupSetRec            IN     bsRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL); -- for compat.
 
FUNCTION getValidBackupSet(
   validBackupSetRec            OUT NOCOPY validBackupSetRec_t
  ,checkDeviceIsAllocated       IN  number DEFAULT FALSE#)
RETURN number;                                  -- TRUE# -> got a record
--
 
--
--
--
 
--
--
--
--
--
--
 
FUNCTION getRcvRec(
   funCode      IN number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,callAgain    OUT number)
RETURN number;
 
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateDatabase(
   sinceUntilSCN IN number DEFAULT NULL);
 
PROCEDURE skipTableSpace(
   tsName  IN varchar2
  ,pdbId   IN number DEFAULT 0);
 
PROCEDURE translateTablespace(
   ts_name IN varchar2, pdb_id IN number DEFAULT 0);
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateDataFile(
   fname IN varchar2);
 
PROCEDURE translateDatafile(
   fno   IN number);
 
PROCEDURE translateDatafile(
   fno    IN number
  ,ckpscn IN number);
 
--
--
 
PROCEDURE translateAllDatafile;
 
PROCEDURE translateCorruptList;
 
PROCEDURE getDatafile(
   dfRec     OUT NOCOPY dfRec_t
  ,oldClient IN  boolean DEFAULT FALSE);
 
--
PROCEDURE getDataFile(
   file#        OUT number
  ,crescn       OUT number
  ,creation_time OUT date
  ,fname        OUT varchar2
  ,ts_name      OUT varchar2
  ,status       OUT number
  ,blksize      OUT number
  ,kbytes       OUT number
  ,blocks       OUT number
  ,unrecoverable_change# OUT number
  ,stop_change# OUT number
  ,read_only    OUT number);
 
--
--
--
--
--
 
PROCEDURE translatePrePluginDf(con_id IN number);
 
FUNCTION getPrePluginDf(
   prePluginDfRec OUT NOCOPY prePluginDfRec_t)
RETURN NUMBER;
 
--
--
--
--
--
PROCEDURE translateTempfile;
 
PROCEDURE translateTempfile(fname IN varchar2);
 
PROCEDURE translateTempfile(fno IN number);
 
--
--
--
PROCEDURE getTempfile(tfRec OUT NOCOPY tfRec_t);
 
--
--
--
 
--
--
 
PROCEDURE translateOnlineLogs(srls IN number DEFAULT 0);
 
PROCEDURE getOnlineLog(
   fname        OUT varchar2
  ,thread#      OUT number
  ,group#       OUT number);
 
--
--
--
 
--
--
 
--
--
--
--
 
--
--
--
--
 
--
--
--
--
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
PROCEDURE getArchivedLog(
   alRec       OUT NOCOPY alRec_t
  ,closeCursor IN  boolean DEFAULT FALSE);
 
PROCEDURE translateArchivedLogKey(
   al_key       IN  number
  ,available    IN  number       DEFAULT 1 -- ignored (for compatability)
  ,unavailable  IN  number       DEFAULT 1 -- ignored (for compatability)
  ,deleted      IN  number       DEFAULT 1 -- ignored (for compatability)
  ,online       IN  number       DEFAULT 1 -- ignored (for compatability)
  ,recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,fname        OUT varchar2
  ,needstby     IN number        DEFAULT NULL);
 
PROCEDURE translateArchivedLogName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,deleted      IN number         DEFAULT NULL   -- for compatability
  ,online       IN number                        -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,needstby     IN number         DEFAULT NULL); -- for compatability
 
--
--
--
--
--
 
PROCEDURE translateArchivedLogSeqRange(
   thread#      IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number                          -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0        -- for compatability
  ,incarn       IN number         DEFAULT NULL);   -- for compatibility
 
PROCEDURE translateArchivedLogTimeRange(
   thread#      IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number                          -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0        -- for compatability
  ,incarn       IN number         DEFAULT NULL);   -- for compatibility
 
PROCEDURE translateArchivedLogSCNRange(
   thread#      IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL
  ,doingRecovery IN  number DEFAULT FALSE#
  ,onlyrdf      IN binary_integer DEFAULT 0        -- for compatability
  ,reset_scn    IN number         DEFAULT NULL     -- for compatability
  ,reset_time   IN date           DEFAULT NULL     -- for compatability
  ,sequence#    IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0        -- for compatability
  ,incarn       IN number         DEFAULT NULL);   -- for compatibility
 
PROCEDURE translateArchivedLogPattern(
   pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number                          -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0);      -- for compatability
 
PROCEDURE translateArchivedLogCancel;
 
 
--
PROCEDURE sv_setSessionKey(skey IN NUMBER);
PROCEDURE sv_setSessionTimeRange(fromTime IN DATE, untilTime IN DATE);
 
FUNCTION sv_getSessionKey RETURN NUMBER;
FUNCTION sv_getSessionfromTimeRange RETURN DATE;
FUNCTION sv_getSessionUntilTimeRange RETURN DATE;
 
--
--
--
 
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE getArchivedLog(
   recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,nxt_scn      OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,blocks       OUT number);
 
--
--
--
 
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateControlFileCopyName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL -- for compatability
  ,unavailable  IN number         DEFAULT NULL -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL -- for compatability
  ,onlyone      IN number         DEFAULT 1);
 
PROCEDURE translateControlFileCopyTag(
   cftag        IN varchar2
  ,available    IN number         DEFAULT NULL -- for compatability
  ,unavailable  IN number         DEFAULT NULL -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL -- for compatability
  ,onlyone      IN number         DEFAULT 1);
 
PROCEDURE translateControlFileCopyKey(
   key          IN number
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL);  -- for compatability
 
 
PROCEDURE getControlFileCopy(
   rcvRec       IN OUT NOCOPY rcvRec_t);
 
--
PROCEDURE getControlFileCopy(
   recid        OUT number
  ,stamp        OUT number
  ,reset_scn    OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number);
 
--
--
--
 
PROCEDURE getDataFileCopy(
   rcvRec       OUT NOCOPY rcvRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE);
 
--
--
 
--
--
 
--
--
--
--
--
 
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL); -- for compatability
 
--
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,file#        OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,create_scn   OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number
  ,blocks       OUT number);
 
PROCEDURE translateDataFileCopyName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,onlyone      IN number         DEFAULT 1
  ,pluginSCN    IN number         DEFAULT 0);
 
PROCEDURE translateDataFileCopyTag(
   tag          IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatibility
  ,unavailable  IN number         DEFAULT NULL     -- for compatibility
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatibility
  ,pluginSCN    IN number         DEFAULT 0
  ,onlytc       IN binary_integer DEFAULT FALSE#); -- for compatibility
 
PROCEDURE translateDataFileCopyFno(
   fno          IN number
  ,available    IN number         DEFAULT NULL
  ,unavailable  IN number         DEFAULT NULL
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL
  ,pluginSCN    IN number         DEFAULT 0);
 
PROCEDURE translateDataFileCopy(
   duplicates   IN number
  ,statusMask   IN binary_integer
  ,onlyrdf      IN binary_integer
  ,pluginSCN    IN number         DEFAULT 0);
 
--
PROCEDURE translateDatafileCancel;
 
--
PROCEDURE getDataFileCopy(
   recid        OUT number
  ,stamp        OUT number
  ,file#        OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,create_scn   OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number
  ,blocks       OUT number);
 
--
--
--
 
PROCEDURE getProxyCopy(
   rcvRec       OUT NOCOPY rcvRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE);
 
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL); -- for compatability
 
--
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2);
 
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL); -- for compatability
 
--
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number);
 
PROCEDURE translateProxyCopyTag(
   tag          IN varchar2
  ,device_type  IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL); -- for compatability
 
PROCEDURE translateProxyCopyGuid(
   guid         IN varchar2
  ,device_type  IN varchar2
  ,statusMask   IN binary_integer);
 
--
--
--
--
 
--
--
 
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE getProxyCopy(
   recid OUT number
  ,stamp OUT number
  ,handle OUT varchar2);
 
--
--
--
 
PROCEDURE getBackupPiece(
   bpRec        OUT NOCOPY bpRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE);
 
PROCEDURE translateBackupPieceKey(
   key         IN  number
  ,available   IN  number            DEFAULT TRUE#
  ,unavailable IN  number            DEFAULT TRUE#
  ,expired     IN  number            DEFAULT TRUE#
  ,statusMask  IN  binary_integer    DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceKey(                        -- only used in 8.1.6
   bp_key       IN  number
  ,available    IN  number
  ,unavailable  IN  number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number);
 
PROCEDURE translateBackupPieceHandle(
   handle      IN  varchar2
  ,deviceType  IN  varchar2
  ,available   IN  number            DEFAULT NULL     -- for compatability
  ,unavailable IN  number            DEFAULT NULL     -- for compatability
  ,expired     IN  number            DEFAULT NULL     -- for compatability
  ,statusMask  IN  binary_integer    DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceHandle(                     -- only used in 8.1.6
   handle       IN  varchar2
  ,device_type  IN  varchar2
  ,available    IN  number
  ,unavailable  IN  number
  ,recid        OUT number
  ,stamp        OUT number
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number);
 
PROCEDURE translateBackupPieceTag(
   tag          IN varchar2
  ,available    IN number             DEFAULT NULL     -- for compatability
  ,unavailable  IN number             DEFAULT NULL     -- for compatability
  ,statusMask   IN binary_integer     DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceGuid(
   guid         IN varchar2
  ,statusMask   IN binary_integer);
 
PROCEDURE translateBackupPieceBSKey(
   key          IN number
  ,tag          IN varchar2           DEFAULT NULL
  ,deviceType   IN varchar2           DEFAULT NULL
  ,pieceCount   IN number
  ,duplicates   IN number             DEFAULT TRUE#
  ,copyNumber   IN number             DEFAULT NULL
  ,available    IN number             DEFAULT TRUE#
  ,unavailable  IN number             DEFAULT FALSE#
  ,deleted      IN number             DEFAULT FALSE#
  ,expired      IN number             DEFAULT FALSE#
  ,statusMask   IN binary_integer     DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceBsKey(
   startBsKey   IN number
  ,tag          IN varchar2        DEFAULT NULL
  ,statusMask   IN binary_integer  DEFAULT NULL);
--
--
   
PROCEDURE translateSeekBpBsKey(
   bsKey        IN number
  ,deviceType   IN varchar2
  ,pieceCount   IN number
  ,duplicates   IN number   DEFAULT TRUE#
  ,copyNumber   IN number   DEFAULT NULL);
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateBpBsKeyCancel;
--
--
--
 
--
PROCEDURE translateBackupSetKey(
   bs_key          IN  number
  ,device_type     IN  varchar2
  ,available       IN  number
  ,unavailable     IN  number
  ,deleted         IN  number
  ,duplicates      IN  number
  ,backup_type     OUT varchar2
  ,recid           OUT number
  ,stamp           OUT number
  ,set_stamp       OUT number
  ,set_count       OUT number
  ,bslevel         OUT number
  ,completion_time OUT date);
 
--
PROCEDURE translateBackupSetKey(
   bs_key      IN  number
  ,device_type IN  varchar2
  ,available   IN  number
  ,unavailable IN  number
  ,deleted     IN  number
  ,duplicates  IN  number
  ,backup_type OUT varchar2
  ,recid       OUT number
  ,stamp       OUT number);
 
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2
  ,bs_key      OUT number
  ,bslevel     OUT number
  ,completed   OUT date);
 
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE getBackupPiece(
   recid      OUT number
  ,stamp      OUT number
  ,bpkey      OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,piece#     OUT number
  ,copy#      OUT number
  ,status     OUT varchar2
  ,completion OUT date
  ,handle     OUT varchar2);
 
--
PROCEDURE getBackupPiece(
   recid      OUT number
  ,stamp      OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,piece#     OUT number
  ,handle     OUT varchar2);
 
--
--
--
 
PROCEDURE translateBackupSetKey(
   key        IN  number
  ,bsRec      OUT NOCOPY bsRec_t);
 
PROCEDURE translateAllBackupSet(
   backupType            IN  binary_integer
  ,tag                   IN  varchar2
  ,statusMask            IN  binary_integer
  ,completedAfter        IN  date
  ,completedBefore       IN  date
  ,onlyrdf               IN  binary_integer DEFAULT 0);
 
PROCEDURE getAllBackupSet(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
--
--
 
FUNCTION translatePdb2Name(
   pdbId IN NUMBER)
RETURN VARCHAR2;
 
--
--
--
 
--
--
--
--
--
--
PROCEDURE findControlfileBackup(
   allCopies      IN boolean default FALSE,
   allBackups     IN boolean default FALSE,
   allIncarnation IN boolean default FALSE,
   fromSCN        IN number  default 0,
   pdbid          IN number  default 0);
 
--
--
FUNCTION getControlfileBackup(
   rcvRec     OUT NOCOPY rcvRec_t)
RETURN number;
 
--
FUNCTION getPrimaryDfName(fno IN NUMBER) RETURN VARCHAR2;
 
--
--
--
--
 
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number)
RETURN number;
 
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number
  ,rlg_scn      OUT number
  ,blksize      OUT number)
RETURN number;
 
--
--
--
 
PROCEDURE findRangeArchivedLogBackup(
   minthread    IN number
  ,minsequence  IN number
  ,minlowSCN    IN number
  ,maxthread    IN number
  ,maxsequence  IN number
  ,maxlowSCN    IN number
  ,allCopies    IN boolean default FALSE);
 
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE findArchivedLogBackup(
   thread    IN number
  ,sequence  IN number
  ,lowSCN    IN number
  ,allCopies IN boolean default FALSE);
 
--
--
--
--
--
--
--
--
--
 
--
FUNCTION getArchivedLogBackup(
   rcvRec       OUT NOCOPY rcvRec_t)
RETURN binary_integer;
 
--
FUNCTION findArchivedLogBackup(
   thread#    IN  number
  ,sequence#  IN  number
  ,low_scn    IN  number
  ,type       OUT number
  ,recid      OUT number
  ,stamp      OUT number
  ,device_type OUT varchar2)
RETURN number;
 
--
--
--
 
--
--
--
--
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE
  ,redundancy IN number  default NULL
  ,rmanCmd    IN number  default unknownCmd_t);
 
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE
  ,redundancy IN number  default NULL
  ,rmanCmd    IN number  default unknownCmd_t
  ,scn_warn  OUT number);
 
--
--
FUNCTION getSpfileBackup(
   rcvRec       OUT NOCOPY rcvRec_t
  ,redundancy   IN         number default NULL
  ,rmanCmd      IN         number default unknownCmd_t)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateControlfileCopy(
   tag             IN  varchar2
  ,completedAfter  IN  date
  ,completedBefore IN  date
  ,statusMask      IN  binary_integer   DEFAULT
                       BSavailable+BSunavailable+BSexpired
  ,liststby        IN  binary_integer   DEFAULT NULL -- default for 8.1
  ,file_pattern    IN varchar2       DEFAULT NULL);
 
PROCEDURE listGetControlfileCopy(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetControlfileCopy(
   bcfkey     OUT number
  ,ckpscn     OUT number
  ,ckptime    OUT date
  ,status     OUT varchar2
  ,completion OUT date
  ,fname      OUT varchar2)
RETURN number;
 
PROCEDURE listTranslateDataFileCopy(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT BSavailable+BSunavailable
--
  ,pluginSCN         IN number          DEFAULT 0);
 
PROCEDURE listGetDataFileCopy(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetDataFileCopy(
   cdf_key            OUT number
  ,status             OUT varchar2
  ,fname              OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number;
 
PROCEDURE listTranslateArchivedLogCopy(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                       BSavailable+BSunavailable+BSexpired  -- 8.0/8.1 defaults
  ,needstby          IN number          DEFAULT NULL);
 
PROCEDURE listGetArchivedLogCopy(
   rcvRec       OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetArchivedLogCopy(
   al_key          OUT number
  ,status          OUT varchar2
  ,fname           OUT varchar2
  ,completion_time OUT date)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateControlfileBackup(
   tag             IN  varchar2
  ,completedAfter  IN  date
  ,completedBefore IN  date
  ,statusMask      IN  binary_integer   DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,autobackup      IN  binary_integer    DEFAULT BScfile_all
  ,liststby        IN  binary_integer    DEFAULT NULL);
 
PROCEDURE listGetControlfileBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetControlfileBackup(
   bskey      OUT number,
   ckpscn     OUT number,
   ckptime    OUT date)
RETURN number;
 
PROCEDURE listTranslateSpfileBackup(
   completedAfter  IN  date
  ,completedBefore IN  date);
 
PROCEDURE listGetSpfileBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
PROCEDURE listTranslateDataFileBackup(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,pluginSCN         IN number          DEFAULT 0);
 
PROCEDURE listGetDataFileBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetDataFileBackup(
   bs_key             OUT number
  ,backup_type        OUT varchar2
  ,incremental_level  OUT number
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number;
 
--
PROCEDURE translateBackupFile(
   bs_recid    IN  number
  ,bs_stamp    IN  number
  ,fno         IN  number
  ,bskey       OUT number
  ,inclevel    OUT number
  ,backup_type OUT varchar2
  ,completed   OUT date);
 
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,completedAfter    IN date           DEFAULT NULL
  ,completedBefore   IN date           DEFAULT NULL
  ,statusMask        IN binary_integer DEFAULT
                      BSavailable+BSunavailable+BSexpired); -- 8.0/8.1 defaults
 
PROCEDURE listGetArchivedLogBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,completion_time OUT date)
RETURN number;
 
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#      IN number   DEFAULT NULL
  ,lowseq       IN number   DEFAULT NULL
  ,highseq      IN number   DEFAULT NULL
  ,lowscn       IN number   DEFAULT NULL
  ,highscn      IN number   DEFAULT NULL
  ,from_time    IN date     DEFAULT NULL
  ,until_time   IN date     DEFAULT NULL
  ,pattern      IN varchar2 DEFAULT NULL);
 
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,thread#         OUT number
  ,sequence#       OUT number
  ,first_change#   OUT number
  ,next_change#    OUT number
  ,first_time      OUT date
  ,next_time       OUT date)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateBackupsetFiles(
   bs_key          IN  number);
 
PROCEDURE listGetBackupsetFiles(
   rcvRec          OUT NOCOPY rcvRec_t);
 
--
--
--
 
--
PROCEDURE listTranslateProxyDataFile(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL 
  ,statusMask        IN binary_integer  DEFAULT
                       BSavailable+BSunavailable+BSexpired
  ,liststby          IN binary_integer  DEFAULT NULL -- default for 8.1
  ,pluginSCN         IN number          DEFAULT 0);
 
PROCEDURE listGetProxyDataFile(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetProxyDataFile(
   xdf_key            OUT number
  ,recid              OUT number
  ,stamp              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number;
 
--
--
--
--
--
--
--
--
PROCEDURE listTranslateProxyDFRecid(
   recid              IN number
  ,stamp              IN number
  ,xdf_key            OUT number
  ,file#              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date);
 
PROCEDURE listTranslateProxyArchivedLog(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                                        BSavailable+BSunavailable+BSexpired);
 
PROCEDURE listGetProxyArchivedLog(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
--
--
 
PROCEDURE listTranslateDBIncarnation(
   db_name       IN varchar2 DEFAULT NULL,
   all_databases IN number  DEFAULT 0);
 
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date
  ,dbinc_status      OUT varchar2)
RETURN number;
 
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateDBSite(
   db_name      IN varchar2 DEFAULT NULL,
   alldbs       IN binary_integer DEFAULT 1);
 
FUNCTION listGetDBSite(
   db_key            OUT number
  ,db_id             OUT number
  ,db_name           OUT varchar2
  ,db_role           OUT varchar2
  ,db_unique_name    OUT varchar2)
RETURN number;
 
--
--
--
 
PROCEDURE listRollbackSegTableSpace;
 
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2)
RETURN number;
 
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2
  ,pdbname           OUT varchar2)
RETURN number;
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
 
FUNCTION getIncrementalScn(
   file#        IN number
  ,create_scn   IN number
  ,reset_scn    IN number
  ,reset_time   IN date
  ,incr_level   IN number
  ,cumulative   IN number
  ,sourcemask   IN number   DEFAULT NULL 
  ,tag          IN varchar2 DEFAULT NULL
  ,pluginSCN    IN number   DEFAULT 0)
RETURN number;
 
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE getIncrementalScn(
   first        IN  boolean                  -- open the cursor if this is TRUE
  ,file#        IN  number
  ,create_scn   IN  number
  ,reset_scn    IN  number
  ,reset_time   IN  date
  ,incr_level   IN  number
  ,cumulative   IN  number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,sourcemask   IN  number    DEFAULT NULL
  ,tag          IN  varchar2  DEFAULT NULL 
  ,pluginSCN    IN  number    DEFAULT 0
  ,keep         IN  boolean   DEFAULT NULL);
 
 
--
--
--
 
PROCEDURE findOfflineRangeCopy(
   offr_recid   IN number
  ,offr_ckpscn  IN number
  ,cf_cretime   IN date
  ,dbinc_key    IN number);
 
PROCEDURE getOfflineRangeCopy(
   rcvRec       OUT  NOCOPY rcvRec_t);
 
--
FUNCTION getOfflineRangeCopy
RETURN varchar2;
 
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
 
--
--
--
 
--
--
--
 
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number
  ,availableMask        IN binary_integer
  ,fullBackups          IN number DEFAULT NULL);
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number);
 
--
PROCEDURE setRAflags(
   kindMask    IN number
  ,allRecords  IN boolean);
 
FUNCTION computeRecoveryActions(
fno        IN number,   -- Datafile number.
crescn     IN number,   -- Datafile creation SCN.
df_rlgscn  IN number    -- Datafile resetlogs SCN.  Null if this is a RESTORE
   default null,        -- command, else this is the value in the datafile
--
df_rlgtime IN date      -- Datafile resetlogs time.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
df_ckpscn  IN number    -- Datafile checkpoint SCN.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
offlscn    IN number    -- kccfeofs (may be null).
   default 0,
onlscn     IN number    -- kccfeonc (null if offlscn is null).
   default 0,
onltime    IN date      -- kccfeonc_time
   default null,
cleanscn   IN number    -- kccfecps if either SOR or WCC set, else null.
   default 0,
clean2scn  IN number    -- CF ckpt SCN if WCC set, infinity if SOR bit set
   default 0,           -- else null.
clean2time IN date      -- cf ckpt time if WCC, SYSDATE if SOR
   default null,
allowfuzzy IN boolean   -- TRUE if can be fuzzy at until SCN/time, FALSE if
  default FALSE,        -- not.  default is FALSE.
partial_rcv IN boolean  -- TRUE if can do partial recovery, FALSE if not
  default FALSE,
cf_scn     IN number    -- controlfile checkpoint SCN (NULL if none mounted)
  default NULL,
cf_cretime IN date      -- controlfile creation time (NULL if none mounted)
  default NULL,
cf_offrrid IN number    -- recid of oldest offline range in controlfile
  default NULL,         -- (NULL if none mounted)
allCopies  IN boolean   -- if TRUE, then stack all valid copies of a bu set
  default FALSE,
df_cretime IN date      -- datafile creation time
  default NULL,
rmanCmd    IN binary_integer
  default unknownCmd_t,
foreignDbid   IN number
  default 0,
pluggedRonly  IN binary_integer
  default 0,
pluginSCN     IN number
  default 0,
pluginRlgSCN  IN number
  default 0,
pluginRlgTime IN date 
  default NULL,
creation_thread IN number
  default NULL,
creation_size   IN number
  default NULL,
pdbId           IN number
  default 1,
pdbForeignDbid  IN number
  default 0
) return binary_integer;
 
--
--
--
 
--
 
SUCCESS     CONSTANT binary_integer := 0;
UNAVAILABLE CONSTANT binary_integer := 1;
AVAILABLE   CONSTANT binary_integer := 2;
RESTORABLE  CONSTANT binary_integer := 3;
NO_ACTION   CONSTANT binary_integer := 4;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
FUNCTION getRecoveryAction(
   action OUT NOCOPY rcvRec_t)
RETURN binary_integer;
 
--
FUNCTION getRecoveryAction(
   kind       OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,recid      OUT number
  ,stamp      OUT number
  ,fname      OUT varchar2
  ,blocksize  OUT number
  ,blocks     OUT number
  ,devtype    OUT varchar2
  ,from_scn   OUT number
  ,to_scn     OUT number
  ,to_time    OUT date
  ,rlgscn     OUT number
  ,rlgtime    OUT date
  ,cfcretime  OUT date
  ,dbinc_key  OUT number)
RETURN binary_integer;
 
PROCEDURE printRecoveryActions;
 
PROCEDURE trimRecoveryActions(
   maxActions           IN number
  ,containerMask        IN number
  ,actionMask           IN number);
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
PROCEDURE reportTranslateDFDel ;
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number)
RETURN number;
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number
  ,key                 OUT number
  ,completion_time     OUT date)
RETURN number;
 
--
--
--
 
FUNCTION getCloneName(
   fno    IN number
  ,crescn IN number
  ,pluscn IN number DEFAULT 0)
RETURN varchar2;
 
 
--
--
--
 
FUNCTION wasFileOffline(
   fno    IN number
  ,untilscn IN number)
RETURN number;
 
--
--
--
 
procedure getConfig(
   conf#          OUT    number
  ,name           IN OUT varchar2
  ,value          IN OUT varchar2
  ,first          IN     boolean);
 
--
--
--
 
FUNCTION getmaxcopyno(
   bsstamp         IN    number
  ,bscount         IN    number)
RETURN number;
 
--
--
--
 
PROCEDURE bmrAddCorruptTable(
   dfnumber    OUT number
  ,blknumber   OUT number
  ,range       OUT number
  ,first       IN  boolean);
 
--
--
--
 
PROCEDURE getDfBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,recentbackup    IN   boolean DEFAULT FALSE  -- get no: recent backups
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
PROCEDURE getAlBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
PROCEDURE getBsBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,set_stamp       IN   number DEFAULT NULL
  ,set_count       IN   number DEFAULT NULL
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
PROCEDURE getDcBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
--
PROCEDURE getBackupHistory(
   dfRec            IN  dfRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date);
 
--
PROCEDURE getBackupHistory(
   alRec            IN  alRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date);
 
PROCEDURE getBackupHistory(
   bpRec            IN  bpRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date
  ,toDest1          IN  varchar2 DEFAULT NULL
  ,toDest2          IN  varchar2 DEFAULT NULL
  ,toDest3          IN  varchar2 DEFAULT NULL
  ,toDest4          IN  varchar2 DEFAULT NULL);
 
--
--
--
 
FUNCTION getPackageVersion
RETURN varchar2;
 
--
--
--
FUNCTION isStatusMatch(status      IN VARCHAR2,
                       mask        IN NUMBER) RETURN NUMBER;
FUNCTION isDeviceTypeAllocated(deviceType IN varchar2)
                      RETURN NUMBER;
FUNCTION isBackupTypeMatch(btype       IN VARCHAR2,
                           mask        IN binary_integer)
                                              RETURN NUMBER;
--
--
--
PROCEDURE setRcvRecBackupAge(age IN number);
 
--
--
--
PROCEDURE resetthisBackupAge;
 
--
--
--
 
PROCEDURE getRetentionPolicy(recovery_window OUT number
                            ,redundancy      OUT number);
--
--
--
--
 
FUNCTION listBackup(lbRecOut         OUT     NOCOPY lbRec_t
                   ,firstCall        IN      boolean
                   ,only_obsolete    IN      boolean
                   ,redundancy       IN      number
                   ,piped_call       IN      boolean
                   ,lbCursor         IN  OUT NOCOPY lbCursor_t
                   ,lbState          IN  OUT NOCOPY lbState_t
                   ,extRlKeepSCN     IN      number DEFAULT NULL)
  RETURN boolean;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
--
 
FUNCTION getRestoreRangeSet(restoreRangeTab OUT restoreRangeTab_t
                           ,opCode  IN  varchar2
                           ,db_id   IN  number)
    
  RETURN boolean;
 
--
 
PROCEDURE setNeedObsoleteData(NeedObsoleteData IN boolean DEFAULT TRUE);
--
--
 
--
 
--
--
PROCEDURE getCopyofDatafile(
   first          IN      boolean     -- TRUE if this is the first time called
  ,itag           IN      varchar2    -- tag that the copy should have or NULL
  ,fno            OUT     number      -- datafile number
  ,crescn         OUT     number      -- creation scn of the datafile
  ,rlogscn        OUT     number      -- resetlogs scn of the datafile
  ,rlgtime        OUT     date        -- resetlogs time of the datafile
  ,recid          OUT     binary_integer -- recid of the latest datafilecopy
  ,stamp          OUT     binary_integer -- stamp of the latest datafilecopy
  ,name           OUT     varchar2    -- name of the datafilecopy
  ,otag           OUT     varchar2    -- tag of the datafilecopy
  ,status         OUT     varchar2    -- status of the datafilecopy
  ,nblocks        OUT     binary_integer -- number of blocks of datafilecopy
  ,bsz            OUT     binary_integer -- blocksize of the datafilecopy
  ,ctime          OUT     date        -- creation time of the datafilecopy
  ,toscn          OUT     number      -- checkpoint scn of the datafilecopy
  ,totime         OUT     date        -- checkpoint time of the datafilecopy
  ,pluggedRonly   OUT     binary_integer -- 1 for read-only. Otherwise, 0
  ,pluginSCN      OUT     number      -- plugin scn
  ,pluginRlgSCN   OUT     number      -- resetlogs when datafile was plugged
  ,pluginRlgTime  OUT     date);      -- resetlog time when df was plugged
 
--
--
--
--
 
PROCEDURE getCopyofDatafile(
   dfnumber       IN      number      -- datafile number
  ,itag           IN      varchar2    -- tag that the copy should have or NULL
  ,crescn         IN  OUT number      -- creation scn of the datafile
  ,rlogscn        IN  OUT number      -- resetlogs scn of the datafile
  ,rlgtime        IN  OUT date        -- resetlogs time of the datafile
  ,recid          OUT     binary_integer -- recid of the latest datafilecopy
  ,stamp          OUT     binary_integer -- stamp of the latest datafilecopy
  ,name           OUT     varchar2    -- name of the datafilecopy
  ,otag           OUT     varchar2    -- tag of the datafilecopy
  ,status         OUT     varchar2    -- status of the datafilecopy
  ,nblocks        OUT     binary_integer -- number of blocks of datafilecopy
  ,bsz            OUT     binary_integer -- blocksize of the datafilecopy
  ,ctime          OUT     date        -- creation time of the datafilecopy
  ,toscn          OUT     number      -- checkpoint scn of the datafilecopy
  ,totime         OUT     date        -- checkpoint time of the datafilecopy
  ,pluggedRonly   OUT     binary_integer -- 1 for read-only. Otherwise, 0
  ,pluginSCN      IN      number);    -- plugin scn
 
--
--
--
--
 
PROCEDURE getCopyofDatafile(
   dfnumber    IN  number          -- datafile number
  ,itag        IN  varchar2        -- tag that the copy should have or NULL
  ,crescn      IN  number          -- creation scn of the datafile
  ,rlogscn     IN  number          -- resetlogs scn of the datafile
  ,rlgtime     IN  date            -- resetlogs time of the datafile
  ,recid       OUT binary_integer  -- recid of the latest datafilecopy
  ,stamp       OUT binary_integer  -- stamp of the latest datafilecopy
  ,name        OUT varchar2        -- name of the datafilecopy
  ,otag        OUT varchar2        -- tag of the datafilecopy
  ,status      OUT varchar2        -- status of the datafilecopy
  ,nblocks     OUT binary_integer  -- number of blocks of the datafilecopy
  ,bsz         OUT binary_integer  -- blocksize of the datafilecopy
  ,ctime       OUT date            -- creation time of the datafilecopy
  ,toscn       OUT number          -- checkpoint scn of the datafilecopy
  ,totime      OUT date);          -- checkpoint time of the datafilecopy
 
--
--
--
PROCEDURE getdropOSFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t);
 
PROCEDURE getBackedUpFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t);
 
--
--
PROCEDURE getRedoLogDeletionPolicy(
   policy        OUT varchar2);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE setRedoLogDeletionPolicy(
   policy  IN  varchar2
  ,alldest IN  number);
 
--
--
--
--
--
FUNCTION validateStandbyConfig(
   policy  IN  varchar2
  ,alldest IN  number)
RETURN NUMBER;
 
--
--
--
--
--
--
--
--
--
--
PROCEDURE getSCNForAppliedPolicy(
   minscn    OUT  number
  ,rlgscn    OUT  number);
 
--
--
--
--
--
--
--
--
PROCEDURE getAppliedAl(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t);
 
--
--
--
--
--
PROCEDURE getRequiredSCN(
   reqscn   OUT  number
  ,rlgscn   OUT  number
  ,streams  IN   number DEFAULT 0
  ,alldest  IN   number DEFAULT 0);
 
--
--
PROCEDURE getAppliedSCN(
   appscn   OUT  number
  ,rlgscn   OUT  number
  ,alldest  IN   number);
 
--
--
FUNCTION isTranslatedFno(fno IN number) RETURN NUMBER;
 
--
--
FUNCTION isBsRecCacheMatch(
   key         IN   number
  ,deviceType  IN   varchar2
  ,tag         IN   varchar2
  ,status      IN   varchar2)
RETURN NUMBER;
 
--
PROCEDURE resetReclRecid;
 
--
PROCEDURE setReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number);
 
--
--
FUNCTION IsReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number)
RETURN NUMBER;
 
--
--
FUNCTION getSpaceRecl(ceilAsm IN binary_integer default 0) RETURN NUMBER;
 
--
PROCEDURE getRestorePoint(
   name         IN varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number);
 
--
PROCEDURE getRestorePoint(
   name         IN varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number
  ,con_id       IN number
  ,clean        OUT number
  ,out_con_id   OUT number);
 
--
PROCEDURE listTranslateRestorePoint(
  name          IN  varchar2);
 
--
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2);
 
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2
  ,pdbname      OUT varchar2);
 
--
--
--
FUNCTION Num2DisplaySize(input_size IN NUMBER) return VARCHAR2;
 
--
FUNCTION Sec2DisplayTime(input_secs IN NUMBER) return VARCHAR2;
 
FUNCTION getEncryptTSCount RETURN BINARY_INTEGER;
 
--
--
--
--
PROCEDURE setArchivedLogRecord(
   thread#   IN  number
  ,sequence# IN  number
  ,first     IN  boolean);
 
--
--
--
PROCEDURE setCanHandleTransportableTbs(
   flag IN boolean);
 
--
--
FUNCTION getArchivedNextSCN RETURN NUMBER;
 
--
--
FUNCTION isArchivedLogMissing(fromSCN IN NUMBER, untilSCN IN NUMBER)
  RETURN NUMBER;
 
--
--
FUNCTION getNextAvailableSCN(fromScn           IN  NUMBER, 
                             nextAvailableSCN  OUT  NUMBER,
                             isOrs             IN   NUMBER)
  RETURN BOOLEAN;
 
--
FUNCTION findLogBreakPoint(logBreakPointScn        OUT NUMBER,
                           logBreakPointTime       OUT DATE,
                           logBreakPointDbIncKey   OUT NUMBER,
                           logBreakPointRlgScn     OUT NUMBER,
                           logBreakPointRlgTime    OUT DATE,
                           fromSCN                 IN  NUMBER,
                           untilSCN                IN  NUMBER,
                           isOrs                   IN  NUMBER)
  RETURN boolean;
 
--
--
FUNCTION getMaxRedoSCN(maxScn      OUT NUMBER,
                       maxTime     OUT DATE,
                       maxDbIncKey OUT NUMBER,
                       maxRlgScn   OUT NUMBER,
                       maxRlgTime  OUT DATE,
                       isOrs       IN  NUMBER)
   RETURN boolean;
 
--
PROCEDURE setRestoreRangeDevTyp(typ IN VARCHAR2);
 
--
PROCEDURE resetRestoreRangeDevTyp;
 
--
--
--
 
--
--
FUNCTION getDropSCN(dfNum        IN NUMBER,
                    creScn       IN  NUMBER,
                    creTime      IN  DATE,
                    plugScn      IN  NUMBER,
                    foreignDbId  IN  NUMBER,
                    dropScn      OUT NUMBER,
                    dropTime     OUT DATE,
                    dropDbIncKey OUT NUMBER,
                    dropRlgScn   OUT NUMBER,
                    dropRlgTime  OUT DATE)
RETURN boolean;
 
--
--
--
FUNCTION getIncarnationKey(untilSCN IN NUMBER) RETURN NUMBER;
 
--
--
PROCEDURE setDbidTransClause(dbid IN number);
 
--
--
FUNCTION isTranslatedDbid(dbid IN number) RETURN NUMBER;
 
--
--
FUNCTION getMaxScn RETURN number;
 
FUNCTION getMaxScn(logmaxnt OUT date) RETURN NUMBER;
 
FUNCTION getActualDbinc RETURN number;
--
--
--
--
--
--
 
PROCEDURE setStdbyCtrlScn(ctrlSCN IN NUMBER);
--
--
 
FUNCTION translatePdbName(pdbName IN VARCHAR2) RETURN NUMBER;
--
 
PROCEDURE resetPdbIdList;
--
 
PROCEDURE setPdbId(pdbId IN NUMBER, first IN BOOLEAN);
--
--
 
FUNCTION isTranslatedPdbId(pdbId IN NUMBER) RETURN NUMBER;
--
--
 
FUNCTION isPdbScnOrphan(untilSCN IN NUMBER, pdbId IN NUMBER) RETURN NUMBER;
--
--
 
FUNCTION setLocalOrsSiteKey(db_id IN NUMBER) RETURN boolean;
--
 
PROCEDURE resetLocalOrsSiteKey;
--
 
FUNCTION isNoBackupPdb(pdbname IN VARCHAR2) RETURN NUMBER;
--
 
--
--
--
 
PROCEDURE listApplicationPdbs(root_con_id IN  number);
--
 
FUNCTION listGetAppPdb(pdb_name OUT varchar2) RETURN NUMBER;
--
 
--
 
pragma TIMESTAMP('2000-03-12:13:51:00');
 
END; -- dbms_rcvman or x$dbms_rcvman
 

/
--------------------------------------------------------
--  DDL for Package DBMS_RCVVPC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."DBMS_RCVVPC" 
IS
 
  FUNCTION filter_pass_all (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_vpc_databases (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_db (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_dbinc (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bsf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bs (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_conf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_deleted_object (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_do_seq (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_node (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_pdb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rout (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_watermarks (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_sbt_template_db (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_pdbinc (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_pdb_dbinc (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_al (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bcf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bdf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_brl (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_ccf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_cdf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_ckp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_df (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_fb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_grsp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_nrsp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_offr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_orl (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rlh (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rsr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_tf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_tsatt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_ts (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_xal (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_xcf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_xdf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_scr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rrcache (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bcb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_ccb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_scrl (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_cfs (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_config (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_orsevent (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_rcfile (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_xmlstore (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_bcr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_server (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_vpc_users (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_site_dfatt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
  FUNCTION f_site_tfatt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2;
 
END dbms_rcvvpc;

/
--------------------------------------------------------
--  DDL for Package DELETE_TXN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."DELETE_TXN" AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
  procedure PROCESS_INT_DELETE_TXN (i_remarks in varchar2,
                                    i_del_ledger in CHAR default 'N',
                                    i_del_es in CHAR default 'N',
                                    i_del_gs in CHAR default 'N',
                                    i_del_mr in CHAR default 'N',
                                    o_result_code out varchar2,o_result_desc out varchar2);
  
  procedure DELETE_BY_SERVICE (i_remarks in varchar2,i_service_number IN VARCHAR2,i_reading_month in VARCHAR2,i_reading_year in VARCHAR2,
                                i_del_ledger in CHAR default 'N',
                                i_del_es in CHAR default 'N',
                                i_del_gs in CHAR default 'N',
                                i_del_mr in CHAR default 'N', 
                                o_result_code out varchar2, o_result_desc out varchar2) ;

END DELETE_TXN;

/
--------------------------------------------------------
--  DDL for Package ENERGY_SALE_BULK_ALLOTMENT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."ENERGY_SALE_BULK_ALLOTMENT" AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
  procedure clear(i_energy_sale_id in varchar2, i_overwrite in char default 'N', o_result_code out varchar2, o_result_desc out varchar2);
  procedure init(i_energy_sale_id in varchar2, o_result_code out varchar2, o_result_desc out varchar2, o_es_multi_add_header_id out varchar2);
  procedure validate(i_energy_sale_id in varchar2,i_es_multi_add_header_id in varchar2, o_result_code out varchar2, o_result_desc out varchar2);
  procedure import(i_energy_sale_id in varchar2,i_es_multi_add_header_id in varchar2,  o_result_code out varchar2, o_result_desc out varchar2);

END energy_sale_bulk_allotment;

/
--------------------------------------------------------
--  DDL for Package EXCESS_UNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."EXCESS_UNITS" AS 

  PROCEDURE FIND_TYPE (i_service_number in varchar2, o_type out varchar2, o_reason out varchar2);
  FUNCTION FIND_TYPE_FN (i_service_number in varchar2) RETURN varchar2;
  PROCEDURE OPEN_BALANCES (i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2);
  PROCEDURE INCREASE_BALANCE (i_excess_source in varchar2,i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, i_unit_data in UD_EXCESS_UNIT, o_result out varchar2, o_reason out varchar2);
  PROCEDURE DECREASE_BALANCE (i_excess_source in varchar2,i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, i_unit_data in UD_EXCESS_UNIT, o_result out varchar2, o_reason out varchar2);  
  PROCEDURE RESET_BALANCES_TO_OPEN_BAL (i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2,o_result out varchar2, o_reason out varchar2);  
  PROCEDURE DELETE_BALANCES (i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2,o_result out varchar2, o_reason out varchar2);  
END EXCESS_UNITS;

/
--------------------------------------------------------
--  DDL for Package EXCESS_UNITS_HELPER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."EXCESS_UNITS_HELPER" AS 

  PROCEDURE CREATE_NEW_OBJ (i_excess_unit_type in varchar2, i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_exs_bal out V_EXS_BALANCE%ROWTYPE);
  PROCEDURE CREATE_OBJ_FROM_PREV_MONTH (i_excess_unit_type in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, i_prev_bal in V_EXS_BALANCE%ROWTYPE, o_curr_bal out V_EXS_BALANCE%ROWTYPE);
  PROCEDURE SET_OBJ (i_obj in V_EXS_BALANCE%ROWTYPE,  o_banking_bal out T_EXS_BANKING_BALANCE%ROWTYPE, o_surplus_stb_bal out T_EXS_SURPLUS_STB_BALANCE%ROWTYPE, o_lapsed_bal out T_EXS_LAPSED_BALANCE%ROWTYPE);
  PROCEDURE SAVE_TO_DB (i_excess_unit_type in varchar2,i_balance_exists in boolean,  i_banking_bal IN T_EXS_BANKING_BALANCE%ROWTYPE, i_surplus_stb_bal IN T_EXS_SURPLUS_STB_BALANCE%ROWTYPE, i_lapsed_bal in T_EXS_LAPSED_BALANCE%ROWTYPE  );
  procedure OPEN_BALANCE (i_excess_unit_type in varchar2, i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2);
END EXCESS_UNITS_HELPER;

/
--------------------------------------------------------
--  DDL for Package EXCESS_UNITS_SOURCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."EXCESS_UNITS_SOURCE" AS 

  procedure update_excess_from_ea(V_ES_ID in varchar2, o_result_code out varchar2, o_result_desc out varchar2) ;
  procedure update_excess_from_ht(i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result_code out varchar2, o_result_desc out varchar2) ;
  procedure find_excess_consumed_in_ea(i_ea in t_energy_sale%rowtype, i_excess_unit_type in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_unit_data out UD_EXCESS_UNIT, o_result_code out varchar2, o_result_desc out varchar2) ;
  procedure find_excess_produced_in_ea(i_ea in t_energy_sale%rowtype, i_excess_unit_type in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_unit_data out UD_EXCESS_UNIT, o_result_code out varchar2, o_result_desc out varchar2) ;  
END EXCESS_UNITS_SOURCE;

/
--------------------------------------------------------
--  DDL for Package GENERATION_STATEMENT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."GENERATION_STATEMENT" AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
    PROCEDURE CREATE_BY_BATCH_ID(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE CREATE_BY_MONTH_YR(I_ORG_ID IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE CREATE_WITH_SS_LOSS(I_SUBSTATION_ID IN VARCHAR2 default null,I_SERVICE_NUMBER IN VARCHAR2 default null,I_ORG_ID IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    FUNCTION CREATE_FROM_MR(v_gs_process_id in varchar2,v_mr_id in varchar2,i_ss_loss_percent in number default 0) return varchar2;
END GENERATION_STATEMENT;

/
--------------------------------------------------------
--  DDL for Package IMP_INT_ADJUSTED_UNIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."IMP_INT_ADJUSTED_UNIT" 
AS
-- Package header
  PROCEDURE PROCESS_INT_ADJUSTED_UNIT(i_batch_key in varchar2,i_month in varchar2,i_year in varchar2 , o_result_code out varchar2, o_result_desc out varchar2);
  PROCEDURE INC_SURPLUS_UNIT(i_batch_key in varchar2, o_result_code out varchar2, o_result_desc out varchar2);
  PROCEDURE UPDATE_SURPLUS_BANKING(i_service_number in varchar2,i_month in varchar2,i_year in varchar2, o_result_code out varchar2, o_result_desc out varchar2);

END IMP_INT_ADJUSTED_UNIT;

/
--------------------------------------------------------
--  DDL for Package METER_NUMBER_CHANGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."METER_NUMBER_CHANGE" AS 

  /* TODO ENTER PACKAGE DECLARATIONS (TYPES, EXCEPTIONS, METHODS ETC) HERE */ 
    PROCEDURE IMPORT(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE METER_CREATION(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE CLEANSE(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE IDENTIFY_ERRORS(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE CREATE_METER_READING(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    PROCEDURE CREATE_TEMP_GENERATION_STATEMENT(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    FUNCTION PROCESS_TEMP_GENERATION_STATEMENT(I_BATCH_KEY in varchar2,v_gs_process_id in varchar2,v_mr_id in varchar2) return varchar2;
    FUNCTION CALC_TMP_GS_CHARGES (v_gs_id IN VARCHAR2 ) RETURN VARCHAR2;
    FUNCTION  CALC_TMP_NEGATIVE_CHARGES(v_gs_id IN VARCHAR2 )  RETURN VARCHAR2;
    PROCEDURE CREATE_CONSOLIDATED_GENERATION_STATEMENT(I_BATCH_KEY IN VARCHAR2,I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
    END METER_NUMBER_CHANGE;

/
--------------------------------------------------------
--  DDL for Package MR_IMPORT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."MR_IMPORT" 
is
	procedure process_mr_interface (v_remarks in varchar2,scenario in varchar2 default 'MERGE-WITH-NEXT-BILLING',v_result_code out varchar2, v_result_desc out varchar2);
  procedure interface_to_mri (v_batch_id in varchar2,scenario in varchar2,  v_remarks in varchar2, v_result_code out varchar2, v_result_desc out varchar2);
	procedure cleanse (v_batch_id in varchar2,scenario in varchar2, v_result_code out varchar2, v_result_desc out varchar2);
	procedure process_mri (v_batch_id in varchar2);
END;

/
--------------------------------------------------------
--  DDL for Package SUBSTATION_LOSS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."SUBSTATION_LOSS" AS 

  /* TODO enter package declarations (types, exceptions, methods etc) here */ 
PROCEDURE START_IMPORT(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
PROCEDURE CLEANSE(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);
PROCEDURE IMPORT(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2);

END SUBSTATION_LOSS;

/
--------------------------------------------------------
--  DDL for Package VIEW_REFRESH
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "OPENACCESS"."VIEW_REFRESH" AS 

 procedure COMP_SERV_REFRESH (i_service_number in varchar2, o_result_code out varchar2,o_result_desc out varchar2);
 procedure COMP_SERV_REFRESH_ALL (o_result_code out varchar2,o_result_desc out varchar2);

END VIEW_REFRESH;

/
--------------------------------------------------------
--  DDL for Package Body BANKING_BALANCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."BANKING_BALANCE" AS

  procedure process_import_table (i_remarks in varchar2, i_overwrite in CHAR default 'N', o_result_code out varchar2, o_result_desc out varchar2) IS
  
    V_OVERWRITE CHAR(1) := 'N';
    v_created_By  varchar2(50):= 'BANKING_BALANCE.PROCESS_IMPORT_TABLE';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_log_result varchar(300):='SUCCESS';
    v_imported_count number:=0;
    v_total_count number:=0;

  BEGIN

    -- begin for exception handling
    BEGIN

      v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','START','Start - '||i_remarks,'','', sysdate,i_remarks);

     if(I_OVERWRITE is not null and I_OVERWRITE='Y') then V_OVERWRITE := 'Y'; end if; 

      o_result_code:='SUCCESS';
      o_result_desc:='';

      select count(*) into v_total_count from IMP_BANKING_BALANCE where remarks = i_remarks;
      if(v_total_count=0) then
          Raise_Application_Error (-20343, 'No records to process');
      end if;

      -- reset values
      update IMP_BANKING_BALANCE set GEN_SERVICE_NUMBER = trim(GEN_SERVICE_NUMBER), M_COMPANY_ID = null, BANKING_SERVICE_ID = null,CLEAN_REC = null,IMPORTED = null, IMPORT_REMARKS=null, modified_by = v_created_By, modified_dt=sysdate where remarks = i_remarks;

      v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','Init Done',''||i_remarks,'','', sysdate,i_remarks);

      --update company-id, banking-service-id,company-service-id
      FOR i IN ( select IMP.GEN_SERVICE_NUMBER, SER.M_COMPANY_ID, SER.BANKING_SERVICE_ID,SER.ID  from IMP_BANKING_BALANCE IMP inner join v_company_service SER on SER."number" = IMP.GEN_SERVICE_NUMBER where IMP.remarks =i_remarks)
      LOOP
        update IMP_BANKING_BALANCE set BANKING_SERVICE_ID = i.BANKING_SERVICE_ID,  M_COMPANY_ID = i.M_COMPANY_ID ,M_COMPANY_SERVICE_ID=i.ID, CLEAN_REC ='Y', ENABLED='Y', modified_by = v_created_By, modified_dt=sysdate where GEN_SERVICE_NUMBER = i.GEN_SERVICE_NUMBER and remarks = i_remarks;
      END LOOP;


      --  code cleansing start
      update IMP_BANKING_BALANCE set CLEAN_REC = 'N', IMPORT_REMARKS='ERROR - GEN_SERVICE_NUMBER not in system' where  remarks = i_remarks and CLEAN_REC is null;

      FOR i IN ( select IMP.GEN_SERVICE_NUMBER,bal.BANKING_SERVICE_ID, bal.month,bal.year from IMP_BANKING_BALANCE IMP inner join t_banking_balance bal on bal.BANKING_SERVICE_ID = IMP.BANKING_SERVICE_ID and to_number(bal.month) = to_number(imp.month) and  to_number(bal.year) = to_number(imp.year)
        where IMP.remarks =i_remarks and nvl(CLEAN_REC,'') ='Y')
      LOOP
        IF (V_OVERWRITE='Y') THEN
          DELETE t_banking_balance where BANKING_SERVICE_ID=i.BANKING_SERVICE_ID and  to_number(MONTH)=to_number(i.MONTH) and to_number(YEAR)=to_number(i.YEAR);
        ELSE
          update IMP_BANKING_BALANCE set CLEAN_REC = 'N', IMPORT_REMARKS='ERROR - Banking Balance already exists',modified_by = v_created_By, modified_dt=sysdate  where  remarks = i_remarks and GEN_SERVICE_NUMBER = i.GEN_SERVICE_NUMBER;
        END IF;

      END LOOP;


      -- CODE FOR CHECKING TRADERELATIONSHIP WITH TNEB EXIST
       FOR i IN ( SELECT count(*) total,trade.M_SELLER_COMPANY_ID  FROM IMP_BANKING_BALANCE IMP inner join M_TRADE_RELATIONSHIP trade on TRADE.M_SELLER_COMPANY_ID=imp.M_COMPANY_ID and to_date(to_char(lpad(IMP.month,2,'0')||'-'||IMP.year),'MM-YYYY') BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE 
        and trade.M_BUYER_COMPANY_ID='TNEB' 
        where IMP.remarks =i_remarks and nvl(CLEAN_REC,'') ='Y'  GROUP BY trade.M_SELLER_COMPANY_ID )
      LOOP
      IF to_number(i.total)>0 then
       update IMP_BANKING_BALANCE set CLEAN_REC = 'N', IMPORT_REMARKS='ERROR - TradeRelationship with TNEB already exists',modified_by = v_created_By, modified_dt=sysdate  where  remarks = i_remarks and M_COMPANY_ID=i.M_SELLER_COMPANY_ID;
       end IF;
      END LOOP;

      v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','Cleansing Complete',''||i_remarks,'','', sysdate,i_remarks);

      insert into t_banking_balance (id, remarks, MONTH, YEAR,C1,C2,C3,C4,C5,CREATED_BY,CREATED_DT, ENABLED,M_COMPANY_ID, BANKING_SERVICE_ID,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CALCULATED)
        (SELECT T_BANKING_BALANCE_SEQ.nextval ID, remarks, lpad(month,2,'0'), year,C1,C2,C3,C4,C5,CREATED_BY,CREATED_DT, ENABLED,M_COMPANY_ID, BANKING_SERVICE_ID,round(C1,0),round(C2,0),round(C3,0),round(C4,0),round(C5,0),'N'
          FROM IMP_BANKING_BALANCE
          WHERE remarks = i_remarks
          AND CLEAN_REC = 'Y'
        );

      v_imported_count :=   sql%Rowcount;
      if(v_imported_count>0) then
        update IMP_BANKING_BALANCE set IMPORTED = 'Y', IMPORT_REMARKS='IMPORTED',modified_by = v_created_By, modified_dt=sysdate  where  remarks = i_remarks and CLEAN_REC = 'Y';
        v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','PROCESS','data imported complete','success_records -' ||v_imported_count,'', sysdate,i_remarks);
      else
        v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','PROCESS','no data imported','error_records -' ||(v_total_count-v_imported_count),'', sysdate,i_remarks);
        o_result_code:= 'FAILURE';
        o_result_desc := 'no clean data to import';

      end if;
      commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','EXCEPTION',o_result_desc,'','', sysdate,i_remarks);
    END;

    v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.PROCESS_IMPORT_TABLE','END','Import complete','','', sysdate,i_remarks);

  END process_import_table;


  procedure open_balance (i_service_no in varchar2, i_reading_month in varchar2, i_reading_year in varchar2, o_result_code out varchar2, o_result_desc out varchar2)  IS
    v_created_By  varchar2(50):= 'BANKING_BALANCE.OPEN_BALANCE';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_log_result varchar(300):='SUCCESS';
    v_bb T_BANKING_BALANCE%ROWTYPE;
    v_bb_new T_BANKING_BALANCE%ROWTYPE;
    v_serv_rec V_COMPANY_SERVICE%ROWTYPE;
    v_prev_month varchar2(10);
    v_prev_year varchar2(10);
    v_prev_month_bb_count number:=0;
    v_curr_month_bb_count number:=0;
    v_commission_date Date;
  BEGIN

    -- begin for exception handling
    BEGIN

      v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','START','Start - i_service_no-'||i_service_no||',i_reading_month-'||i_reading_month||',i_reading_year-'||i_reading_year,'','', sysdate,i_service_no);

      o_result_code:='SUCCESS';
      o_result_desc:='';

      select * into  v_serv_rec from v_company_service where "number"=i_service_no fetch first 1 rows only;      
      select count(*) into v_curr_month_bb_count from t_banking_balance where M_COMPANY_ID = v_serv_rec.m_company_id and BANKING_SERVICE_ID = v_serv_rec.BANKING_SERVICE_ID and month = i_reading_month and year = i_reading_year  fetch first 1 rows only;

      if(v_serv_rec.excess_unit_type <> 'BANKING') then
        o_result_code:='FAILURE';
        o_result_desc:='Excess_unit_type -'||v_serv_rec.excess_unit_type||' Banking Balance not applicable for  i_service_no-'||i_service_no||',i_reading_month-'||i_reading_month||',i_reading_year-'||i_reading_year;
        v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','Balance Check',o_result_desc,'','', sysdate,i_service_no);
      elsif(v_curr_month_bb_count > 0) then        
        o_result_code:='FAILURE';
        o_result_desc:='Banking Balance Already exists for  i_service_no-'||i_service_no||',i_reading_month-'||i_reading_month||',i_reading_year-'||i_reading_year;
        v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','Balance Check',o_result_desc,'','', sysdate,i_service_no);
        GOTO THE_END;
      else
      -- here excess_unit_type is BANKING
        -- create new balance record
         /*
         select COMMISSION_DATE into v_commission_date from M_POWERPLANT where M_SERVICE_ID = v_serv_rec.id;
          if v_commission_date is not null and v_commission_date> to_date('01-04-2018','DD-MM-YYYY') then
             GOTO THE_END;
          end if;
          */
        v_bb_new.M_COMPANY_ID := v_serv_rec.M_COMPANY_ID;
        v_bb_new.BANKING_SERVICE_ID := v_serv_rec.BANKING_SERVICE_ID;
        v_bb_new.enabled:='Y';
        v_bb_new.CALCULATED:='N';
        v_bb_new.month:=i_reading_month;
        v_bb_new.year:=i_reading_year;
        v_bb_new.CREATED_BY:=v_created_By;
        v_bb_new.CREATED_DATE:=sysdate;
        v_bb_new.id:=T_BANKING_BALANCE_SEQ.NEXTVAL;

        -- fetch previous month record to get closing balance
        v_prev_month := to_char(to_date( '01-'||i_reading_month||'-'||i_reading_year,'dd-mm-yyyy')-1,'mm');
        v_prev_year := to_char(to_date( '01-'||i_reading_month||'-'||i_reading_year,'dd-mm-yyyy')-1,'yyyy');

        select count(*) into v_prev_month_bb_count from t_banking_balance where M_COMPANY_ID = v_serv_rec.m_company_id and BANKING_SERVICE_ID = v_serv_rec.BANKING_SERVICE_ID and month = v_prev_month and year = v_prev_year  fetch first 1 rows only;
        if(v_prev_month_bb_count >0) then
          -- create New Balance record based on prev month balance

          select * into v_bb from t_banking_balance where M_COMPANY_ID = v_serv_rec.m_company_id and BANKING_SERVICE_ID = v_serv_rec.BANKING_SERVICE_ID and month = v_prev_month and year = v_prev_year  fetch first 1 rows only;

             select  nvl(v_bb.CURR_C1,0)+nvl(v_bb.SURPLUS_C1,0),nvl(v_bb.CURR_C2,0)+nvl(v_bb.SURPLUS_C2,0) ,nvl(v_bb.CURR_C3,0)+nvl(v_bb.SURPLUS_C3,0) ,nvl(v_bb.CURR_C4,0)+nvl(v_bb.SURPLUS_C4,0) ,nvl(v_bb.CURR_C5,0)+nvl(v_bb.SURPLUS_C5,0) ,
             round(nvl(v_bb.CURR_C1,0),0)+round(nvl(v_bb.SURPLUS_C1,0),0) ,round(nvl(v_bb.CURR_C2,0),0)+round(nvl(v_bb.SURPLUS_C2,0),0) ,round(nvl(v_bb.CURR_C3,0),0)+round(nvl(v_bb.SURPLUS_C3,0),0) ,round(nvl(v_bb.CURR_C4,0),0)+round(nvl(v_bb.SURPLUS_C4,0),0) ,round(nvl(v_bb.CURR_C5,0),0)+round(nvl(v_bb.SURPLUS_C5,0),0) 
             into  v_bb_new.C1,v_bb_new.C2,v_bb_new.C3,v_bb_new.C4,v_bb_new.C5,v_bb_new.CURR_C1,v_bb_new.CURR_C2,v_bb_new.CURR_C3,v_bb_new.CURR_C4,v_bb_new.CURR_C5 from dual;

          insert into t_banking_balance values v_bb_new;
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','Process','New Balance record created based on prev month balance. i_service_no-'||i_service_no||',i_reading_month-'||i_reading_month||',i_reading_year-'||i_reading_year,'','', sysdate,i_service_no);

        else
          -- create a new Balance record with empty bb values

          select  '0','0','0','0','0', '0','0','0','0','0'
          into  v_bb_new.C1,v_bb_new.C2,v_bb_new.C3,v_bb_new.C4,v_bb_new.C5,v_bb_new.CURR_C1,v_bb_new.CURR_C2,v_bb_new.CURR_C3,v_bb_new.CURR_C4,v_bb_new.CURR_C5 from dual;

          insert into t_banking_balance values v_bb_new;
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','Process','New Balance record created with empty bb values. i_service_no-'||i_service_no||',i_reading_month-'||i_reading_month||',i_reading_year-'||i_reading_year,'','', sysdate,i_service_no);

        end if;    -- if for v_prev_month_bb_count
      end if;  -- if for v_curr_month_bb_count

      commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','EXCEPTION',o_result_desc,'','', sysdate,i_service_no);
    END;
    <<THE_END>>
    v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','END','Complete','','', sysdate,i_service_no);

  END OPEN_BALANCE;


  procedure confirm_energy_sale_event(V_ES_ID in varchar2, o_result_code out varchar2, o_result_desc out varchar2)  IS

    v_created_By  varchar2(50):= 'BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT';

    V_COMP_SERVICE V_COMPANY_SERVICE%ROWTYPE;

    V_ES T_ENERGY_SALE%ROWTYPE;

    v_result varchar(300):='SUCCESS';
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
    v_excess_es VARCHAR2(300);
  ------------------------------------------------  

  ------------------------------------------------
    V_BB T_BANKING_BALANCE%ROWTYPE;
    V_C1 NUMBER:=0;
    V_C2 NUMBER:=0;
    V_C3 NUMBER:=0;
    V_C4 NUMBER:=0;
    V_C5 NUMBER:=0;
    V_COUNT NUMBER:=0;
    V_UNALLOCATED_GEN_FLAG boolean:=false;
    V_ALLOCATED_BANK_FLAG boolean:=false;

  BEGIN

    -- begin for exception handling
    BEGIN

      v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','START','Start - i_t_es_id-'||V_ES_ID,'','', sysdate,V_ES_ID);

      o_result_code:='SUCCESS';
      o_result_desc:='';


           SELECT * INTO V_ES FROM T_ENERGY_SALE WHERE ID = V_ES_ID;

--       DBMS_OUTPUT.PUT_LINE(V_ES.STATUS_CODE);

       IF V_ES.STATUS_CODE='APPROVED' THEN

            SELECT * INTO V_COMP_SERVICE FROM V_COMPANY_SERVICE WHERE ID=V_ES.SELLER_COMP_SERV_ID;

            if(V_COMP_SERVICE.excess_unit_type<>'BANKING') then

                -- o_result_code:='FAILURE';
                o_result_desc:='Excess_unit_type -'||V_COMP_SERVICE.excess_unit_type||' Banking Balance not applicable for  i_service_no-'||V_COMP_SERVICE."number";
                v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.OPEN_BALANCE','Balance Check',o_result_desc,'','', sysdate,V_COMP_SERVICE."number");
                goto THE_END;
            end if;
            --      calculation for unallocated gen units
            select count(*) into V_COUNT from t_banking_balance where M_COMPANY_ID = V_COMP_SERVICE.m_company_id and month = v_es.month and year = v_es.year;

--         DBMS_OUTPUT.PUT_LINE(V_COUNT);
            if V_COUNT>0 then
                select * into V_BB from t_banking_balance where M_COMPANY_ID = V_COMP_SERVICE.m_company_id and month = v_es.month and year = v_es.year fetch first 1 rows only;
                IF TO_NUMBER(nvl(V_ES.AVAIL_GC1,0))  > TO_NUMBER(nvl(V_ES.GC1,0)) THEN
                    V_C1 := (TO_NUMBER(nvl(V_ES.AVAIL_GC1,0)) - TO_NUMBER(nvl(V_ES.GC1,0)));
                    V_C1 :=(V_C1)-(V_C1 *0.14);  
                    V_UNALLOCATED_GEN_FLAG:=true;
                END IF;

                IF TO_NUMBER(nvl(V_ES.AVAIL_GC2,0))  > TO_NUMBER(nvl(V_ES.GC2,0)) THEN
                    V_C2 := (TO_NUMBER(nvl(V_ES.AVAIL_GC2,0)) - TO_NUMBER(nvl(V_ES.GC2,0)));
                    V_C2 :=(V_C2)-(V_C2 *0.14); 
                    V_UNALLOCATED_GEN_FLAG:=true;
                END IF;

                IF TO_NUMBER(nvl(V_ES.AVAIL_GC3,0))  > TO_NUMBER(nvl(V_ES.GC3,0)) THEN
                    V_C3 := (TO_NUMBER(nvl(V_ES.AVAIL_GC3,0)) - TO_NUMBER(nvl(V_ES.GC3,0)));
                    V_C3 :=(V_C3)-(V_C3 *0.14); 
                    V_UNALLOCATED_GEN_FLAG:=true;
                END IF;

                IF TO_NUMBER(nvl(V_ES.AVAIL_GC4,0))  > TO_NUMBER(nvl(V_ES.GC4,0)) THEN
                    V_C4 := (TO_NUMBER(nvl(V_ES.AVAIL_GC4,0)) - TO_NUMBER(nvl(V_ES.GC4,0)));
                    V_C4 :=(V_C4)-(V_C4 *0.14); 
                    V_UNALLOCATED_GEN_FLAG:=true;
                END IF;

                IF TO_NUMBER(nvl(V_ES.AVAIL_GC5,0))  > TO_NUMBER(nvl(V_ES.GC5,0)) THEN
                    V_C5 := (TO_NUMBER(nvl(V_ES.AVAIL_GC5,0)) - TO_NUMBER(nvl(V_ES.GC5,0)));
                    V_C5 :=(V_C5)-(V_C5 *0.14); 
                    V_UNALLOCATED_GEN_FLAG:=true;
                END IF;

                IF V_UNALLOCATED_GEN_FLAG THEN
                   V_BB.CURR_C1 := TO_NUMBER(nvl(V_BB.CURR_C1,0))+TO_NUMBER(V_C1);
                   V_BB.CURR_C2 := TO_NUMBER(nvl(V_BB.CURR_C2,0))+TO_NUMBER(V_C2);
                   V_BB.CURR_C3 := TO_NUMBER(nvl(V_BB.CURR_C3,0))+TO_NUMBER(V_C3);
                   V_BB.CURR_C4 := TO_NUMBER(nvl(V_BB.CURR_C4,0))+TO_NUMBER(V_C4);
                   V_BB.CURR_C5 := TO_NUMBER(nvl(V_BB.CURR_C5,0))+TO_NUMBER(V_C5);
--                      DBMS_OUTPUT.PUT_LINE('--V_BB.CURR_C1-----'||V_BB.CURR_C1); 
                   UPDATE T_BANKING_BALANCE SET CURR_C1=round(V_BB.CURR_C1,0) ,CURR_C2=round(V_BB.CURR_C2,0),CURR_C3=round(V_BB.CURR_C3,0),CURR_C4=round(V_BB.CURR_C4,0),CURR_C5=round(V_BB.CURR_C5,0),CALCULATED='Y' ,
                            modified_by=v_created_By, modified_dt=sysdate 
                   where M_COMPANY_ID = V_COMP_SERVICE.m_company_id and month = v_es.month and year = v_es.year;

                END IF;

                IF TO_NUMBER(nvl(V_ES.BC1,0))>0 THEN
                    V_BB.CURR_C1 := TO_NUMBER(nvl(V_BB.CURR_C1,0))-TO_NUMBER(nvl(V_ES.BC1,0));                
                    V_ALLOCATED_BANK_FLAG:=true;
                END IF;

                 IF TO_NUMBER(nvl(V_ES.BC2,0))>0 THEN
                    V_BB.CURR_C2 := TO_NUMBER(nvl(V_BB.CURR_C2,0))-TO_NUMBER(nvl(V_ES.BC2,0));                
                    V_ALLOCATED_BANK_FLAG:=true;
                END IF;

                 IF TO_NUMBER(nvl(V_ES.BC3,0))>0 THEN
                    V_BB.CURR_C3 := TO_NUMBER(nvl(V_BB.CURR_C3,0))-TO_NUMBER(nvl(V_ES.BC3,0));                
                    V_ALLOCATED_BANK_FLAG:=true;
                END IF;

                 IF TO_NUMBER(nvl(V_ES.BC4,0))>0 THEN
                    V_BB.CURR_C4 := TO_NUMBER(nvl(V_BB.CURR_C4,0))-TO_NUMBER(nvl(V_ES.BC4,0));                
                    V_ALLOCATED_BANK_FLAG:=true;
                END IF;

                 IF TO_NUMBER(nvl(V_ES.BC5,0))>0 THEN
                    V_BB.CURR_C5 := TO_NUMBER(nvl(V_BB.CURR_C5,0))-TO_NUMBER(nvl(V_ES.BC5,0));                
                    V_ALLOCATED_BANK_FLAG:=true;
                END IF;

                IF V_ALLOCATED_BANK_FLAG THEN
                    --if negative, make balances as empty
                    select decode(sign(V_BB.CURR_C1),1,V_BB.CURR_C1,0), decode(sign(V_BB.CURR_C2),1,V_BB.CURR_C2,0), decode(sign(V_BB.CURR_C3),1,V_BB.CURR_C3,0), decode(sign(V_BB.CURR_C4),1,V_BB.CURR_C4,0), decode(sign(V_BB.CURR_C5),1,V_BB.CURR_C5,0)
                   into V_BB.CURR_C1, V_BB.CURR_C2, V_BB.CURR_C3, V_BB.CURR_C4, V_BB.CURR_C5 from dual;

                   UPDATE T_BANKING_BALANCE SET CURR_C1=round(V_BB.CURR_C1,0) ,CURR_C2=round(V_BB.CURR_C2,0),CURR_C3=round(V_BB.CURR_C3,0),CURR_C4=round(V_BB.CURR_C4,0),CURR_C5=round(V_BB.CURR_C5,0),CALCULATED='Y' ,
                   modified_by=v_created_By, modified_dt=sysdate 
                   where M_COMPANY_ID = V_COMP_SERVICE.m_company_id and month = v_es.month and year = v_es.year;

                END IF;
                v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','UPDATED BB','CONFIRM_ENERGY_SALE_EVENT complete','','', sysdate,V_ES_ID);
          else

                IF TO_NUMBER(nvl(V_ES.AVAIL_GC1,0))  > TO_NUMBER(nvl(V_ES.GC1,0)) THEN
    --                  DBMS_OUTPUT.PUT_LINE(V_ES.AVAIL_GC1 ||'-------'||V_ES.GC1);
                        V_C1 := (TO_NUMBER(nvl(V_ES.AVAIL_GC1,0)) - TO_NUMBER(nvl(V_ES.GC1,0)));
                        V_C1 :=(V_C1)-(V_C1 *0.14);  
--                        DBMS_OUTPUT.PUT_LINE('--V_C1-----'||V_C1); 
                        V_UNALLOCATED_GEN_FLAG:=true;
                    END IF;

                    IF TO_NUMBER(nvl(V_ES.AVAIL_GC2,0))  > TO_NUMBER(nvl(V_ES.GC2,0)) THEN
                        V_C2 := (TO_NUMBER(nvl(V_ES.AVAIL_GC2,0)) - TO_NUMBER(nvl(V_ES.GC2,0)));
                        V_C2 :=(V_C2)-(V_C2 *0.14); 
                        V_UNALLOCATED_GEN_FLAG:=true;
                    END IF;

                    IF TO_NUMBER(nvl(V_ES.AVAIL_GC3,0))  > TO_NUMBER(nvl(V_ES.GC3,0)) THEN
                        V_C3 := (TO_NUMBER(nvl(V_ES.AVAIL_GC3,0)) - TO_NUMBER(nvl(V_ES.GC3,0)));
                        V_C3 :=(V_C3)-(V_C3 *0.14); 
                        V_UNALLOCATED_GEN_FLAG:=true;
                    END IF;

                    IF TO_NUMBER(nvl(V_ES.AVAIL_GC4,0))  > TO_NUMBER(nvl(V_ES.GC4,0)) THEN
                        V_C4 := (TO_NUMBER(nvl(V_ES.AVAIL_GC4,0)) - TO_NUMBER(nvl(V_ES.GC4,0)));
                        V_C4 :=(V_C4)-(V_C4 *0.14); 
                        V_UNALLOCATED_GEN_FLAG:=true;
                    END IF;

                    IF TO_NUMBER(nvl(V_ES.AVAIL_GC5,0))  > TO_NUMBER(nvl(V_ES.GC5,0)) THEN
                        V_C5 := (TO_NUMBER(nvl(V_ES.AVAIL_GC5,0)) - TO_NUMBER(nvl(V_ES.GC5,0)));
                        V_C5 :=(V_C5)-(V_C5 *0.14); 
                        V_UNALLOCATED_GEN_FLAG:=true;                       

                    END IF;
                    IF V_UNALLOCATED_GEN_FLAG THEN
                    select V_COMP_SERVICE.M_COMPANY_ID,V_COMP_SERVICE.BANKING_SERVICE_ID,V_C1,V_C2,V_C3,V_C4,V_C5,round(V_C1,0),round(V_C2,0),round(V_C3,0),round(V_C4,0),round(V_C5,0)
                    into v_bb.M_COMPANY_ID,v_bb.BANKING_SERVICE_ID,v_bb.C1,v_bb.C2,v_bb.C3,v_bb.C4,v_bb.C5,v_bb.CURR_C1,v_bb.CURR_C2,v_bb.CURR_C3,v_bb.CURR_C4,v_bb.CURR_C5 from dual;
                    v_bb.enabled:='Y';
                    v_bb.CALCULATED:='Y';
                    v_bb.month:=V_ES.MONTH;
                    v_bb.year:=V_ES.YEAR;
                    v_bb.CREATED_BY:=v_created_By; 
                    v_bb.CREATED_DT:=sysdate; 
                    v_bb.id:=T_BANKING_BALANCE_SEQ.NEXTVAL;
                    insert into t_banking_balance VALUES v_bb;
                    END IF;
                     v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','INSERT BB','CONFIRM_ENERGY_SALE_EVENT complete','','', sysdate,V_ES_ID);

          end if;

            v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','END','CONFIRM_ENERGY_SALE_EVENT complete','','', sysdate,V_ES_ID);
       ELSE -- else for V_ES.STATUS_CODE='APPROVED'
        o_result_desc    := 'BANKING_BAL - CANNOT PROCESS ENERGY SALE THAT IS NOT APPROVED';
        o_result_code    := 'FAILURE';
        v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','PROCESS',o_result_desc,'','', sysdate,V_ES_ID);
       END IF; -- end if for V_ES.STATUS_CODE='APPROVED'


      -- commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','EXCEPTION',o_result_desc,'','', sysdate,V_ES_ID);
    END;
    <<THE_END>>
    v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.CONFIRM_ENERGY_SALE_EVENT','END','CONFIRM_ENERGY_SALE_EVENT complete','','', sysdate,V_ES_ID);


  END CONFIRM_ENERGY_SALE_EVENT;

  procedure increment_surplus_units(i_ht_surplus_units_id in varchar2, o_result_code out varchar2, o_result_desc out varchar2) AS
  v_created_By VARCHAR2(200):='BANKING_BALANCE.INCREMENT_SURPLUS_UNITS';
  v_htsurcursor sys_refcursor ;
  v_int_surplus_unit INT_SURPLUS_UNIT%ROWTYPE;
    v_total_loss VARCHAR2(200);
    v_drawl_code VARCHAR2(200); 
    v_inj_code VARCHAR2(200); 
    v_inj_units number; 
    v_trans_loss VARCHAR2(200); 
    v_dis_loss VARCHAR2(200); 
    v_drawl_units  number; 
    v_comp_id VARCHAR2(200); 
        v_bank_service_id VARCHAR2(200); 

    v_banking_count VARCHAR2(50); 
        v_inj_units1 VARCHAR2(200); 
    v_inj_units2 VARCHAR2(200); 
    v_inj_units3 VARCHAR2(200); 
    v_inj_units4 VARCHAR2(200); 
    v_inj_units5 VARCHAR2(200); 
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
    v_excess_unit_type varchar2(100);



  BEGIN
    -- TODO: Implementation required for procedure BANKING_BALANCE.increment_surplus_units
                   -- DBMS_OUTPUT.PUT_LINE('start');

    v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','START','Start - '||i_ht_surplus_units_id,'','', sysdate,i_ht_surplus_units_id);
     update int_surplus_unit set reading_mnth=lpad(reading_mnth,2,'0') where batch_key=i_ht_surplus_units_id;
     v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Cleanse','Complete','','', sysdate,i_ht_surplus_units_id);
    OPEN v_htsurcursor for select * from INT_SURPLUS_UNIT where BATCH_KEY=i_ht_surplus_units_id;-- and suplr_code='059224760427';
    LOOP
    FETCH v_htsurcursor INTO v_int_surplus_unit;
    EXIT WHEN v_htsurcursor%NOTFOUND;

      select voltage_code into v_inj_code from m_company_service where "number"=v_int_surplus_unit.SUPLR_CODE;
      select voltage_code into v_drawl_code from m_company_service where "number"=v_int_surplus_unit.SERVICE_NO;

      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_int_surplus_unit.C1,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units1);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_int_surplus_unit.C2,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units2);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_int_surplus_unit.C3,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units3);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_int_surplus_unit.C4,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units4);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_int_surplus_unit.C5,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units5);

     -- select M_COMPANY_ID into v_comp_id from m_company_service where "number"=v_int_surplus_unit.SUPLR_CODE;
     -- select BANKING_SERVICE_ID into v_bank_service_id from m_company_service where "number"=v_int_surplus_unit.SUPLR_CODE;

      UPDATE INT_SURPLUS_UNIT SET C1_WITHLOSS=round(nvl(v_inj_units1,0),0),C2_WITHLOSS=round(nvl(v_inj_units2,0),0),C3_WITHLOSS=round(nvl(v_inj_units3,0),0),C4_WITHLOSS=round(nvl(v_inj_units4,0),0),C5_WITHLOSS=round(nvl(v_inj_units5,0),0)
      WHERE ID = v_int_surplus_unit.ID;
                       --   DBMS_OUTPUT.PUT_LINE(' v_comp_id--'||v_comp_id);

    END LOOP;

    v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Completed Loss Calculation','','','', sysdate,i_ht_surplus_units_id);
    FOR supplier in (  select ser."number" SUPLR_CODE, ser.M_COMPANY_ID,ser.BANKING_SERVICE_ID, READING_MNTH, READING_YR,sum(s.C1_WITHLOSS) c1_wl, sum(s.C2_WITHLOSS) c2_wl,sum(s.C3_WITHLOSS) c3_wl, sum(s.C4_WITHLOSS) c4_wl,sum(s.C5_WITHLOSS) c5_wl 
                        from  INT_SURPLUS_UNIT s join m_company_service ser on ser."number"=s.suplr_code  where batch_key=i_ht_surplus_units_id 
                     --and ser."number"='059224760427'
                        group by ser."number" ,ser.M_COMPANY_ID,ser.BANKING_SERVICE_ID,READING_MNTH, READING_YR)
    loop
      begin

         select excess_unit_type into v_excess_unit_type from v_company_service where "number"=supplier.SUPLR_CODE;
         if(v_excess_unit_type<>'BANKING') then
             UPDATE INT_SURPLUS_UNIT SET imported='N', import_remarks='Excess_unit_type -'||v_excess_unit_type||' Banking Balance not applicable for  suppler_code-'||supplier.SUPLR_CODE||',reading_month-'||supplier.reading_mnth||',reading_year-'||supplier.reading_yr where batch_key=i_ht_surplus_units_id and SUPLR_CODE = supplier.SUPLR_CODE;

            v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Update Banking Balance','Excess_unit_type -'||v_excess_unit_type||' Banking Balance not applicable for  suppler_code-'||supplier.SUPLR_CODE||',reading_month-'||supplier.reading_mnth||',reading_year-'||supplier.reading_yr,'','', sysdate,supplier.SUPLR_CODE);
         else

          select count(*) into v_banking_count from T_BANKING_BALANCE where M_COMPANY_ID = supplier.M_COMPANY_ID and BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID and MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;
                    --  DBMS_OUTPUT.PUT_LINE(' v_banking_count--'||v_banking_count);


          if(v_banking_count>0) then 
               v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Update Banking Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_ht_surplus_units_id);
               update T_BANKING_BALANCE set curr_c1=round(nvl(curr_c1,0),0)+round(supplier.c1_wl,0),curr_C2=round(nvl(curr_c2,0),0)+round(supplier.c2_wl,0),curr_C3=round(nvl(curr_c3,0),0)+round(supplier.c3_wl,0),curr_C4=round(nvl(curr_c4,0),0)+round(supplier.c4_wl,0),curr_C5=round(nvl(curr_c5,0),0)+round(supplier.c5_wl,0),
               modified_by=v_created_By, modified_dt =sysdate where (M_COMPANY_ID = supplier.M_COMPANY_ID or BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID)  AND MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;

          else 
               v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Insert Banking Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_ht_surplus_units_id);
                insert into T_BANKING_BALANCE (ID,M_COMPANY_ID,BANKING_SERVICE_ID,C1,C2,C3,C4,C5,REMARKS,MONTH,YEAR,curr_C1,curr_C2,curr_C3,curr_C4,curr_C5, CREATED_BY,CREATED_DT)
                  values (T_BANKING_BALANCE_SEQ.NEXTVAL,supplier.M_COMPANY_ID,supplier.BANKING_SERVICE_ID,nvl(supplier.c1_wl,0),nvl(supplier.c2_wl,0),nvl(supplier.c3_wl,0),nvl(supplier.c4_wl,0),nvl(supplier.c5_wl,0),i_ht_surplus_units_id,supplier.READING_MNTH,supplier.READING_YR,round(nvl(supplier.c1_wl,0),0),round(nvl(supplier.c2_wl,0),0),round(nvl(supplier.c3_wl,0),0),round(nvl(supplier.c4_wl,0),0),round(nvl(supplier.c5_wl,0),0),v_created_By,sysdate);
          END IF;

        end if;
--           if(v_banking_count>0) then 
--               v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Update Banking Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_ht_surplus_units_id);
--               update T_BANKING_BALANCE set SURPLUS_C1=round(supplier.c1_wl,0),SURPLUS_C2=round(supplier.c2_wl,0),SURPLUS_C3=round(supplier.c3_wl,0),SURPLUS_C4=round(supplier.c4_wl,0),SURPLUS_C5=round(supplier.c5_wl,0),
--               modified_by='BANKING_BALANCE.INCRMENT_SURPLUS_UNITS', modified_dt =sysdate where (M_COMPANY_ID = supplier.M_COMPANY_ID or BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID)  AND MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;
--  
--          else 
--               v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','Insert Banking Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_ht_surplus_units_id);
--                insert into T_BANKING_BALANCE (ID,M_COMPANY_ID,BANKING_SERVICE_ID,C1,C2,C3,C4,C5,REMARKS,MONTH,YEAR,curr_C1,curr_C2,curr_C3,curr_C4,curr_C5,SURPLUS_C1,SURPLUS_C2,SURPLUS_C3,SURPLUS_C4,SURPLUS_C5, CREATED_BY,CREATED_DT)
--                  values (T_BANKING_BALANCE_SEQ.NEXTVAL,supplier.M_COMPANY_ID,supplier.BANKING_SERVICE_ID,round(nvl(supplier.c1_wl,0),0),round(nvl(supplier.c2_wl,0),0),round(nvl(supplier.c3_wl,0),0),round(nvl(supplier.c4_wl,0),0),round(nvl(supplier.c5_wl,0),0),i_ht_surplus_units_id,supplier.READING_MNTH,supplier.READING_YR,round(nvl(supplier.c1_wl,0),0),round(nvl(supplier.c2_wl,0),0),round(nvl(supplier.c3_wl,0),0),round(nvl(supplier.c4_wl,0),0),round(nvl(supplier.c5_wl,0),0),round(nvl(supplier.c1_wl,0),0),round(nvl(supplier.c2_wl,0),0),round(nvl(supplier.c3_wl,0),0),round(nvl(supplier.c4_wl,0),0),round(nvl(supplier.c5_wl,0),0),'BANKING_BALANCE.INCRMENT_SURPLUS_UNITS',sysdate);
--          END IF;
       exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','EXCEPTION',o_result_desc,supplier.BANKING_SERVICE_ID,'', sysdate,i_ht_surplus_units_id);
           UPDATE INT_SURPLUS_UNIT SET imported='N', import_remarks=o_result_desc where batch_key=i_ht_surplus_units_id and SUPLR_CODE = supplier.SUPLR_CODE;
       END;
    END LOOP;

     v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.INCRMENT_SURPLUS_UNITS','End','End','','', sysdate,i_ht_surplus_units_id);
  END increment_surplus_units;

  procedure reset_for_yearend( i_service_no in varchar2,i_reading_month in varchar2, i_reading_year in varchar2,o_result_code out varchar2, o_result_desc out varchar2) AS
     v_created_By  VARCHAR2(50):= 'BANKING_BALANCE.RESET_FOR_YEAREND';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_log_result varchar(300):='SUCCESS';
    v_prev_month varchar2(10);
    v_prev_year varchar2(10);
    v_current_month varchar2(10);
    v_servicecursor sys_refcursor ;
    v_bb_new T_BANKING_BALANCE%ROWTYPE;
    v_seb_new T_NEW_SERVICE_EXCESS_BANKING%ROWTYPE;
    v_comp_service v_company_service%ROWTYPE;
    v_count number;
    v_excess_units_type varchar2(200);
  BEGIN
    -- TODO: Implementation required for procedure BANKING_BALANCE.reset_for_yearend
    BEGIN
     -- fetch previous month record to get closing balance]
     v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.reset_for_yearend','start - '||i_reading_month||'-'||i_reading_year,o_result_desc,'','', sysdate,i_service_no);
   --  select to_char(sysdate,'mm') into v_current_month from dual;
   --  v_prev_month := to_char(to_date( '01-'||i_reading_month||'-'||i_reading_year,'dd-mm-yyyy')-1,'mm');
   --  v_prev_year := to_char(to_date( '01-'||i_reading_month||'-'||i_reading_year,'dd-mm-yyyy')-1,'yyyy');
     if i_reading_month='04' then  

         v_excess_units_type:=excess_units.FIND_TYPE_FN(i_service_no);

		 IF (v_excess_units_type='BANKING' OR v_excess_units_type = 'SURPLUS-EXCESS') THEN

		 	SELECT * INTO v_comp_service FROM V_COMPANY_SERVICE where "number" =i_service_no;
			if(v_excess_units_type='BANKING') THEN
				-- create balance in banking
				v_bb_new.M_COMPANY_ID := v_comp_service.M_COMPANY_ID;
	            v_bb_new.BANKING_SERVICE_ID := v_comp_service.BANKING_SERVICE_ID;
	            v_bb_new.enabled:='Y';
	            v_bb_new.CALCULATED:='Y';
	            v_bb_new.month:=i_reading_month;
	            v_bb_new.year:=i_reading_year;
	            v_bb_new.CREATED_DATE:=sysdate;
	            v_bb_new.CREATED_BY:=v_created_By;
	            v_bb_new.id:=T_BANKING_BALANCE_SEQ.NEXTVAL;
	            select count(*) into v_count from t_banking_balance where month=i_reading_month and year=i_reading_year and M_COMPANY_ID=v_comp_service.M_COMPANY_ID;
	            if v_count=0 then
		            select  '0','0','0','0','0', '0','0','0','0','0', '0','0','0','0','0'
		            into  v_bb_new.C1,v_bb_new.C2,v_bb_new.C3,v_bb_new.C4,v_bb_new.C5,v_bb_new.CURR_C1,v_bb_new.CURR_C2,v_bb_new.CURR_C3,v_bb_new.CURR_C4,v_bb_new.CURR_C5,v_bb_new.SURPLUS_C1,v_bb_new.SURPLUS_C2,v_bb_new.SURPLUS_C3,v_bb_new.SURPLUS_C4,v_bb_new.SURPLUS_C5 from dual;
		            insert into t_banking_balance values v_bb_new;
		        else
		            update t_banking_balance set C1='0',C2='0',C3='0',C4='0',C5='0',CURR_C1='0',CURR_C2='0',CURR_C3='0',CURR_C4='0',CURR_C5='0',SURPLUS_C1='0',SURPLUS_C2='0',SURPLUS_C3='0',SURPLUS_C4='0',SURPLUS_C5='0',modified_by=v_created_By,modified_dt=sysdate WHERE month=i_reading_month and year=i_reading_year and M_COMPANY_ID=v_comp_service.M_COMPANY_ID;            
	            end if;
			ELSE
			-- create balance in surplus-excess (i.e) in T_NEW_SERVICE_EXCESS_BANKING
				v_seb_new.M_COMPANY_ID := v_comp_service.M_COMPANY_ID;
	            v_seb_new.BANKING_SERVICE_ID := v_comp_service.BANKING_SERVICE_ID;
	            v_seb_new.enabled:='Y';
	            v_seb_new.CALCULATED:='Y';
	            v_seb_new.month:=i_reading_month;
	            v_seb_new.year:=i_reading_year;
	            v_seb_new.CREATED_DATE:=sysdate;
	            v_seb_new.CREATED_BY:=v_created_By;
	            v_seb_new.id:=T_BANKING_BALANCE_SEQ.NEXTVAL;
	            select count(*) into v_count from T_NEW_SERVICE_EXCESS_BANKING where month=i_reading_month and year=i_reading_year and M_COMPANY_ID=v_comp_service.M_COMPANY_ID;
	            if v_count=0 then
		            select  '0','0','0','0','0', '0','0','0','0','0', '0','0','0','0','0'
		            into  v_seb_new.C1,v_seb_new.C2,v_seb_new.C3,v_seb_new.C4,v_seb_new.C5,v_seb_new.CURR_C1,v_seb_new.CURR_C2,v_seb_new.CURR_C3,v_seb_new.CURR_C4,v_seb_new.CURR_C5,v_seb_new.SURPLUS_C1,v_seb_new.SURPLUS_C2,v_seb_new.SURPLUS_C3,v_seb_new.SURPLUS_C4,v_seb_new.SURPLUS_C5 from dual;
		            insert into T_NEW_SERVICE_EXCESS_BANKING values v_seb_new;
		        else
		            update T_NEW_SERVICE_EXCESS_BANKING set C1='0',C2='0',C3='0',C4='0',C5='0',CURR_C1='0',CURR_C2='0',CURR_C3='0',CURR_C4='0',CURR_C5='0',SURPLUS_C1='0',SURPLUS_C2='0',SURPLUS_C3='0',SURPLUS_C4='0',SURPLUS_C5='0',modified_by=v_created_By,modified_dt=sysdate WHERE month=i_reading_month and year=i_reading_year and M_COMPANY_ID=v_comp_service.M_COMPANY_ID;            
	            end if;
			END IF;

            o_result_code := 'SUCCESS';
            o_result_desc:=i_service_no||'-'||v_excess_units_type;
		 ELSE
		          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.reset_for_yearend','Cannot reset banking for service'||i_service_no||' as excess-units-type is '||v_excess_units_type||' for '||i_reading_month||'-'||i_reading_year,o_result_desc,'','', sysdate,i_service_no);
                  o_result_code := 'FAILURE';
                  o_result_desc := 'Cannot reset banking for service'||i_service_no||' as excess-units-type is '||v_excess_units_type;


		 END if;
     ELSE
         v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.reset_for_yearend','Cannot reset service'||i_service_no||' for '||i_reading_month||'-'||i_reading_year,o_result_desc,'','', sysdate,i_service_no);

     end if;

          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.reset_for_yearend','End - '||i_service_no||'-'||i_reading_month||'-'||i_reading_year,o_result_desc,'','', sysdate,i_service_no);
     exception
     when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','BANKING_BALANCE.reset_for_yearend','EXCEPTION',o_result_desc,'','', sysdate,'');

       END;            

  END reset_for_yearend;

END BANKING_BALANCE;

/
--------------------------------------------------------
--  DDL for Package Body BILLING_PERIOD
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."BILLING_PERIOD" AS 
 
  PROCEDURE UPDATE_SURPLUS_FROM_HT(i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2)
    IS
    v_process varchar2(500):='BILLING_PERIOD.UPDATE_SURPLUS_FROM_HT';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_log_result  varchar2(500);
    v_service_number varchar2(50);
    BEGIN 
    
		v_stage:='INIT'; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        /*
         example, 
         on june-30th-2020 or in early july2020, to update surplus balance as the first step
            a. call by UPDATE_SURPLUS_FROM_HT('%','05', '2020')
            b. to update surplus for single service (12312312312), call UPDATE_SURPLUS_FROM_HT('12312312312','05', '2020')
        */
        
        if(i_service_number is NULL or i_service_number='') then
             v_service_number := '%';
        else
            v_service_number := i_service_number;
        end if;
        
        v_stage:='PROCESS'; v_message:='Updating Surplus from HT for - '||v_service_number; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        for serv in ( select distinct suplr_code from f_energy_adjustmet where reading_mnth=i_reading_month and reading_yr=i_reading_year and suplr_code like v_service_number)
        LOOP
            excess_units_source.update_excess_from_ht(serv.suplr_code, i_reading_month,i_reading_year , o_result , o_reason);
        END LOOP;

        o_result :=''; o_reason:='';

        commit;
        <<THE_END>>
		v_stage:='END'; v_message:='END'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
    END UPDATE_SURPLUS_FROM_HT;
    
  PROCEDURE OPEN_ALL_EXS_BALANCES(i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2)
    IS
    v_process varchar2(500):='BILLING_PERIOD.OPEN_ALL_EXS_BALANCES';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_log_result  varchar2(500);
    v_service_number varchar2(50);
    BEGIN 
    
        /*
         example, 
         on june-30th-2020 or in early july2020, to open balances 
            a. call by OPEN_ALL_EXS_BALANCES('%','06', '2020')
            b. to open balance for single service (12312312312), call OPEN_ALL_EXS_BALANCES('12312312312','06', '2020')
        */
        
		v_stage:='INIT'; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        if(i_service_number is null or i_service_number='') then
             v_service_number := '%';
        else
            v_service_number := i_service_number;
        end if;
         
        v_stage:='PROCESS'; v_message:='Opening bal for - '||v_service_number; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        for serv in (select "number" from v_company_service where "number" like v_service_number and comp_ser_type_code='03')
        LOOP
            excess_units.open_balances(serv."number", i_reading_month,i_reading_year , o_result , o_reason);
        END LOOP;

        o_result :=''; o_reason:='';

        commit;
		v_stage:='END'; v_message:='END'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
    END OPEN_ALL_EXS_BALANCES;
END BILLING_PERIOD;

/
--------------------------------------------------------
--  DDL for Package Body DBMS_RCVCAT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."DBMS_RCVCAT" IS
--
--
--
 
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
type version_list_type is table of varchar2(14) index by binary_integer;
version_list version_list_type;
version_max_index binary_integer;
version_counter binary_integer := 1;
 
/*-----------*
 * Constants *
 *-----------*/
 
MAXNUMVAL      CONSTANT NUMBER := 2**32-1;
catalogVersion CONSTANT VARCHAR2(11) := '12.02.00.01';
ZERO_GUID      CONSTANT RAW(16) := HEXTORAW(RPAD('0', 32, '0'));
 
/*-------------------------*
 * Package State Variables *
 *-------------------------*/
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
debug               BOOLEAN := FALSE;
this_ckp_key        NUMBER  := NULL;
this_ckp_scn        NUMBER  := NULL;
this_ckp_time       DATE    := NULL;
this_lib_key        NUMBER  := NULL;
last_full_ckp_scn   NUMBER  := NULL;
last_guid           PDB.GUID%TYPE := NULL;
last_con_id_ts#     NUMBER;
last_ts#            NUMBER;
last_file#          NUMBER;
last_thread#        NUMBER;
last_fname          site_dfatt.fname%type;
last_pdb_recid      NUMBER;
last_pic_recid      NUMBER;
last_ts_recid       NUMBER;
last_df_recid       NUMBER;
last_tf_recid       NUMBER;
last_rt_recid       NUMBER;
last_orl_recid      NUMBER;
last_conf_recid     NUMBER;
force_resync2cf     VARCHAR2(3) := 'NO';
last_rlh_recid      NUMBER;
last_al_recid       NUMBER;
last_offr_recid     NUMBER;
last_bs_recid       NUMBER;
last_bp_recid       NUMBER;
last_bdf_recid      NUMBER;
last_bsf_recid      NUMBER;
last_brl_recid      NUMBER;
last_cdf_recid      NUMBER;
last_bcb_recid      NUMBER;
last_ccb_recid      NUMBER;
last_do_recid       NUMBER;
last_xdf_recid      NUMBER := NULL;
last_xal_recid      NUMBER := NULL;
last_rsr_recid      NUMBER;
last_rout_stamp     NUMBER := NULL;
last_inst_startup_stamp NUMBER := NULL;
lrsr_key            NUMBER;
lrout_skey          NUMBER;
lsession_recid      NUMBER;
lsession_stamp      NUMBER;
lrman_status_recid  NUMBER;
lrman_status_stamp  NUMBER;
--
krbmror_llength_bytes NUMBER := 130;
--
--
type rout_list     is table of rout%ROWTYPE index by binary_integer;
lrout_table        rout_list;
lrout_curridx      binary_integer := 0;
 
--
--
last_ic_recid       NUMBER := NULL;
scr_key             NUMBER := NULL;
scr_line            NUMBER;
scr_glob            BOOLEAN;
kccdivts            NUMBER;
type bskeys_v       is table of number index by varchar2(128);
duplicatebs         bskeys_v;
type bskeys is table of number index by binary_integer;
cntbs               NUMBER := 0;
updatebs            bskeys;
last_reset_scn      NUMBER;
last_reset_time     DATE;
last_dbinc_key      NUMBER;
do_temp_ts_resync   BOOLEAN := FALSE;  -- indicates if temp_ts is resynced
last_cf_version_time DATE;
dbglvl              NUMBER := RCVCAT_LEVEL_DEFAULT;
low_nrsp_recid      NUMBER;
last_nrsp_recid     NUMBER;
last_grsp_recid     NUMBER;
last_rspname        grsp.rspname%type;
last_pdb_key        NUMBER;
last_bcr_recid      NUMBER;
last_resync_cksum   NUMBER;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
this_cf_type    VARCHAR2(7) := NULL;
this_cf_version DATE := NULL;
this_ckp_type   VARCHAR2(10) := NULL;
 
--
this_db_unique_name    node.db_unique_name%TYPE;
this_site_key          NUMBER; -- Never NULL even for 9i RMAN client
client_site_aware      boolean := FALSE;
 
--
logs_shared           number := FALSE#; -- used only when client_site_aware
disk_backups_shared   number := TRUE#;  -- indicates shared accross all sites
tape_backups_shared   number := TRUE#;  -- indicates shared accross all sites
 
--
session_keep_output   number := NULL;
rman_keep_output      number := NULL;
 
reNorm_state binary_integer;
RENORM_DFATT CONSTANT binary_integer := 1;
RENORM_ORL   CONSTANT binary_integer := 2;
RENORM_AL    CONSTANT binary_integer := 3;
RENORM_BP    CONSTANT binary_integer := 4;
RENORM_CCF   CONSTANT binary_integer := 5;
RENORM_CDF   CONSTANT binary_integer := 6;
RENORM_TFATT CONSTANT binary_integer := 7;
 
--
--
--
--
--
--
type sessionWaterMarks_t is record
(
last_kccdivts      number := 0,            -- check if ctl version is diff 
high_rout_stamp    number := 0,            -- for rman_output resync
high_ic_recid      number := 0,            -- incarnation recid
high_offr_recid    number := 0,            -- offline range (kkor) recid
high_rlh_recid     number := 0,            -- log history (kcclh) recid
high_al_recid      number := 0,            -- archived log (kccal) recid
high_bs_recid      number := 0,            -- backup set (kccbs) recid
high_bp_recid      number := 0,            -- backup piece (kccbp) recid
high_bdf_recid     number := 0,            -- backup datafile (kccbf) recid
high_cdf_recid     number := 0,            -- datafile copy (kccdc) recid
high_brl_recid     number := 0,            -- backup redo log (kccbl) recid
high_bcb_recid     number := 0,            -- backup datafile corruption recid
high_ccb_recid     number := 0,            -- datafile copy corruption recid
high_do_recid      number := 0,            -- deleted object recid
high_pc_recid      number := 0,            -- proxy copy (kccpc) recid
high_bsf_recid     number := 0,            -- backup SPFILE (kccbi) recid
high_rsr_recid     number := 0,            -- RMAN status (kccrsr) recid
high_nrsp_recid    number := 0,            -- normal restore point recid
high_bcr_recid     number := 0,            -- high blk crpt (kccblkcor) recid
high_pic_recid     number := 0             -- high pdbinc recid
);
 
init_sessionWaterMarks sessionWaterMarks_t;
prev_sessionWaterMarks sessionWaterMarks_t;
sessionWaterMarks      sessionWaterMarks_t;
 
--
type ts_name_list     is table of ts.ts_name%type index by binary_integer;
type numTab_t         is table of number index by binary_integer; 
type key_columns_list is table of varchar2(30);
type sp_columns_list  is table of varchar2(1);
 
--
--
--
import_dbid numTab_t;
--
--
--
--
--
--
--
--
key_columns  CONSTANT key_columns_list := key_columns_list
   ('DB_KEY'          , 'DBINC_KEY'      , 'CURR_DBINC_KEY'    ,
    'PARENT_DBINC_KEY', 'CKP_KEY'        , 'START_CKP_KEY'     ,
    'END_CKP_KEY'     , 'OFFR_KEY'       , 'RR_KEY'            ,
    'RLH_KEY'         , 'AL_KEY'         , 'BS_KEY'            ,
    'BP_KEY'          , 'BCF_KEY'        , 'CCF_KEY'           ,
    'XCF_KEY'         , 'BSF_KEY'        , 'BDF_KEY'           ,
    'CDF_KEY'         , 'XDF_KEY'        , 'XAL_KEY'           ,
    'BRL_KEY'         , 'BDF_KEY'        , 'RSR_KEY'           ,
    'RSR_PKEY'        , 'RSR_L0KEY'      , 'SCR_KEY'           ,
    'ROUT_SKEY'       , 'SITE_KEY'       , 'DF_KEY'            ,
    'TF_KEY'          , 'PDB_KEY'        , 'LIB_KEY'           ,
    'VB_KEY'          , 'CT_KEY'         , 'PDBINC_KEY'        ,
    'CURR_PDBINC_KEY' , 'BORN_DBINC_KEY' , 'PARENT_PDBINC_KEY' ,
    'TS_PDBINC_KEY'   , 'TEMPLATE_KEY');
 
--
--
import_dblink tempres.name%type;
import_offset number;
 
/*---------------------------------------------------*
 * package variables used for recovery server        *
 *---------------------------------------------------*/
this_is_ors              BOOLEAN := FALSE;
this_is_ors_admin        BOOLEAN := FALSE;
orsadmin_user            ALL_USERS.USERNAME%TYPE := NULL;
this_server              SERVER%ROWTYPE;
this_amazon_server       BOOLEAN := FALSE;
this_server_uname        VARCHAR2(512):= NULL;
this_server_passw        VARCHAR2(512):= NULL;
this_server_url          VARCHAR2(512):= NULL;
this_xml_signature_beg   VARCHAR2(50) := '<?xml version="1.0"?> <ALL_TABLES> ';
this_xml_signature_end   VARCHAR2(50) := ' </ALL_TABLES> ';
this_forwatermarks       VARCHAR2(50) := 'forwatermarks_';
this_watermarks          VARCHAR2(50) := 'watermarks_';
this_backupsets          VARCHAR2(50) := 'backupsets_';
this_database            VARCHAR2(50) := 'database_';
this_url_db_unique_name  node.db_unique_name%TYPE;
this_lock_ors_inspect    BOOLEAN      := FALSE;
this_clr_ba_newinc_err   BOOLEAN      := FALSE;
this_upstream_site_key   NUMBER       := NULL;
this_enable_populate_rsr NUMBER       := NULL;
--
--
--
this_verrec                  RC_RCVER%ROWTYPE;
this_curr_inc                RC_DATABASE_INCARNATION%ROWTYPE;
this_wmrec                   RC_WATERMARKS%ROWTYPE;
this_upstream_dbrec          RCI_RA_UPSTREAM_DATABASE%ROWTYPE;
this_rsiterec                RC_SITE%ROWTYPE;
this_v_wmrec                 CLOB;
this_curr_bp_recid           NUMBER;
this_high_bp_recid           NUMBER;
this_bp_key_poll             NUMBER;
 
FUNCTION assert_schema (
  i_schema                   VARCHAR2
, i_enquote                  BOOLEAN DEFAULT FALSE
)
RETURN VARCHAR2;
 
PROCEDURE assert_schema (
  o_schema                   OUT NOCOPY VARCHAR2
, o_eschema                  OUT NOCOPY VARCHAR2
, i_schema                   IN VARCHAR2
);
 
g_catowner                   CONSTANT user_users.username%TYPE :=
  assert_schema(dbms_catowner);
g_ecatowner                  CONSTANT VARCHAR2(130) :=
  assert_schema(dbms_catowner, TRUE);
 
e_no_vpd_setup               CONSTANT NUMBER := -20153;
e_no_vpd_setup_m             CONSTANT VARCHAR2(64) :=
  'recovery catalog does not have VPD support enabled!';
 
--
--
--
--
--
TYPE vtr IS VARRAY(4) OF VARCHAR2(256);
TYPE vtr_t IS TABLE OF vtr;
vpd_table_list CONSTANT vtr_t :=
vtr_t
(
    vtr('VPC_DATABASES', 'SELECT', 'T', 'T')
  , vtr('DB',             NULL,    'T', 'F')
  , vtr('DBINC',          NULL,    'T', 'T')
  , vtr('BP',             NULL,    'T', 'T')
  , vtr('BSF',            NULL,    'T', 'T')
  , vtr('BS',             NULL,    'T', 'T')
  , vtr('CONF',           NULL,    'T', 'T')
  , vtr('DELETED_OBJECT', NULL,    'T', 'T')
  , vtr('DO_SEQ',         NULL,    'T', 'T')
  , vtr('NODE',           NULL,    'T', 'T')
  , vtr('PDB',            NULL,    'T', 'T')
  , vtr('ROUT',           NULL,    'T', 'T')
  , vtr('WATERMARKS',     NULL,    'T', 'T')
  , vtr('PDBINC',         NULL,    'T', 'T')
  , vtr('PDB_DBINC',      NULL,    'T', 'T')
  , vtr('AL',             NULL,    'T', 'T')
  , vtr('BCF',            NULL,    'T', 'T')
  , vtr('BDF',            NULL,    'T', 'T')
  , vtr('BRL',            NULL,    'T', 'T')
  , vtr('CCF',            NULL,    'T', 'T')
  , vtr('CDF',            NULL,    'T', 'T')
  , vtr('CKP',            NULL,    'T', 'T')
  , vtr('DF',             NULL,    'T', 'T')
  , vtr('FB',             NULL,    'T', 'T')
  , vtr('GRSP',           NULL,    'T', 'T')
  , vtr('NRSP',           NULL,    'T', 'T')
  , vtr('OFFR',           NULL,    'T', 'T')
  , vtr('ORL',            NULL,    'T', 'T')
  , vtr('RLH',            NULL,    'T', 'T')
  , vtr('RR',             NULL,    'T', 'T')
  , vtr('RSR',            NULL,    'T', 'T')
  , vtr('RT',             NULL,    'T', 'T')
  , vtr('TF',             NULL,    'T', 'T')
  , vtr('TSATT',          NULL,    'T', 'T')
  , vtr('TS',             NULL,    'T', 'T')
  , vtr('XAL',            NULL,    'T', 'T')
  , vtr('XCF',            NULL,    'T', 'T')
  , vtr('XDF',            NULL,    'T', 'T')
  , vtr('SCR',            NULL,    'T', 'T')
  , vtr('BCB',            NULL,    'T', 'T')
  , vtr('CCB',            NULL,    'T', 'T')
  , vtr('SCRL',           NULL,    'T', 'T')
  , vtr('CFS',           'SELECT', 'T', 'T')
  , vtr('CONFIG',        'SELECT', 'T', 'T')
  , vtr('ORSEVENT',       NULL,    'T', 'T')
  , vtr('RCFILE',         NULL,    'T', 'T')
  , vtr('XMLSTORE',      'SELECT', 'T', 'F')
  , vtr('BCR',            NULL,    'T', 'T')
  , vtr('SERVER',         NULL,    'T', 'F')
  , vtr('VPC_USERS',     'SELECT', 'T', 'T')
  , vtr('SITE_DFATT',     NULL,    'T', 'T')
  , vtr('SITE_TFATT',     NULL,    'T', 'T')
  , vtr('RCVER',         'SELECT', 'F', 'F')
  , vtr('RASCHEMAVER',   'SELECT', 'F', 'F')
  , vtr('RRCACHE',       'SELECT', 'T', 'T')  
  , vtr('SBT_TEMPLATE_DB',NULL,    'T', 'T')
);
--
--
g_vpd_required_policies      NUMBER := 0;
 
/*---------*
 * Cursors *
 *---------*/
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
cursor pdbQ IS
  SELECT pdb.pdb_key, pdb.name, pdb.con_id, pdb.guid,
         pdb.create_scn, pdb.nobackup
    FROM pdb
   WHERE pdb.db_key = this_db_key
     AND pdb.con_id > 1
   ORDER BY pdb.guid;
 
cursor picQ IS
   SELECT pdbinc.pdb_key, pdbinc.pdbinc_key, pdb.con_id,
          pdb.guid, pdb.create_scn, pdbinc.inc_scn, pdbinc.begin_reset_scn,
          pdbinc.begin_reset_time, pdbinc.end_reset_scn,
          dbinc.reset_scn db_reset_scn, dbinc.reset_time db_reset_time,
          pdbinc.parent_pdbinc_key
     FROM pdbinc, pdb, dbinc
    WHERE pdb.pdb_key     = pdbinc.pdb_key
      AND dbinc.dbinc_key = pdbinc.born_dbinc_key
      AND pdb.con_id      > 1
      AND pdb.db_key      = this_db_key
    ORDER BY guid, con_id, create_scn, begin_reset_scn, begin_reset_time,
             end_reset_scn;
--
 
--
cursor tsQ IS
  SELECT ts.ts_name, ts.ts#, ts.create_scn, ts.create_time, tsatt.rbs_count,
         ts.included_in_database_backup, ts.bigfile, ts.temporary,
         ts.encrypt_in_backup, ts.plugin_scn, ts.pdbinc_key, pdbinc.con_id,
         pdbinc.curr_pdbinc_key, pdbinc.pdb_key, pdbinc.drop_scn pdb_drop_scn
  FROM ts, tsatt, rci_pdbinc_this_dbinc pdbinc
  WHERE ts.dbinc_key     = tsatt.dbinc_key
    AND ts.ts#           = tsatt.ts#
    AND ts.pdbinc_key    = pdbinc.pdbinc_key
    AND tsatt.pdbinc_key = pdbinc.pdbinc_key
    AND ts.create_scn    = tsatt.create_scn
    AND ts.dbinc_key     = this_dbinc_key
    AND ts.plugin_scn    = tsatt.plugin_scn
    AND ts.drop_scn       IS NULL              --skip ones we know were dropped
    AND tsatt.end_ckp_key IS NULL
    AND pdbinc.dbinc_key = this_dbinc_key
    AND ts.create_scn    < pdbinc.next_inc_scn --skip ones in orphan scn
  ORDER BY pdbinc.con_id, ts.ts#; -- client passes rows to checkTs in
--
--
 
--
cursor dfQ IS
  SELECT df.file#, df.create_scn, df.create_time, df.plugin_scn, df.ts#,
         site_dfatt.fname, df.blocks, df.clone_fname, df.stop_scn,
         df.read_only, df.plugged_readonly, df.create_thread, df.create_size,
         df.foreign_dbid, df.pdb_closed, df.pdbinc_key,
         pdbinc.curr_pdbinc_key, pdbinc.pdb_key
  FROM df, site_dfatt, rci_pdbinc_this_dbinc pdbinc
  WHERE df.dbinc_key  = this_dbinc_key  -- our dbinc please
    AND df.drop_scn  IS NULL            -- df not dropped
    AND this_site_key = site_dfatt.site_key(+)  -- select names for the site
    AND df.df_key     = site_dfatt.df_key(+)    -- join site_dfatt to df
    AND df.pdbinc_key = pdbinc.pdbinc_key
    AND df.create_scn < pdbinc.next_inc_scn     -- skip ones in orphan scn
    AND df.plugin_scn < pdbinc.next_inc_scn
    AND pdbinc.dbinc_key = this_dbinc_key
  ORDER BY df.file#;                    -- client passes rows to checkDf in
--
--
 
--
cursor tfQ IS
  SELECT tf.file#, tf.create_scn, tf.create_time, tf.ts#,
         site_tfatt.fname, site_tfatt.blocks, site_tfatt.autoextend,
         site_tfatt.max_size, site_tfatt.next_size, tf.tf_key tf_key,
         tf.pdb_key, pdb.con_id
  FROM tf, site_tfatt, pdb
  WHERE tf.dbinc_key  = this_dbinc_key       -- our dbinc please
    AND this_site_key = site_tfatt.site_key  -- select names for the site
    AND tf.tf_key     = site_tfatt.tf_key    -- join site_tfatt to tf
    AND site_tfatt.drop_scn IS NULL          -- tf not dropped
    AND tf.pdb_key    = pdb.pdb_key
  ORDER BY tf.file#;                    -- client passes rows to checkTf in
--
--
 
--
cursor rtQ IS
  SELECT rt.thread#, rt.sequence#, rt.enable_scn,
         rt.enable_time, rt.status
  FROM rt
  WHERE rt.dbinc_key = this_dbinc_key
  ORDER BY rt.thread#;
 
 
--
cursor orlQ IS
  SELECT orl.thread#, orl.group#, orl.fname
  FROM orl
  WHERE orl.dbinc_key = this_dbinc_key
    AND orl.site_key  = this_site_key
  ORDER BY nlssort(orl.fname, 'NLS_COMP=ANSI NLS_SORT=ASCII7'); -- bug 2107554
 
--
cursor grspQ IS
  SELECT grsp.rspname, grsp.from_scn, grsp.to_scn, grsp.pdb_key
  FROM grsp, dbinc, pdb
  WHERE grsp.dbinc_key = dbinc.dbinc_key
    AND dbinc.db_key = this_db_key
    AND grsp.site_key = this_site_key
    AND grsp.pdb_key = pdb.pdb_key
  ORDER BY pdb.con_id, grsp.pdb_key,
           nlssort(grsp.rspname, 'NLS_COMP=ANSI NLS_SORT=ASCII7');
 
--
--
cursor bpq(device_type VARCHAR2, handle VARCHAR2,
           bp_recid VARCHAR2, bp_stamp VARCHAR2) IS
  SELECT bp_key, bs_key
  FROM bp
  WHERE db_key = this_db_key
  AND   status != 'D'
  AND   device_type = bpq.device_type
  AND   ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
         (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
         (this_site_key = nvl(bp.site_key, this_site_key)))
  AND   handle = bpq.handle
  AND   handle_hashkey = substr(bpq.device_type,1,10) ||
                         substr(bpq.handle,1,10) ||
                         substr(bpq.handle,-10)
  AND   NOT (bp_recid = bpq.bp_recid AND
             bp_stamp = bpq.bp_stamp);
 
 
--
cursor scrlQ(key NUMBER) IS
  SELECT text
  FROM scrl
  WHERE scr_key = key
  ORDER BY linenum;
 
--
cursor rcverQ IS
  SELECT version
  FROM rcver
  ORDER BY version;
 
cursor reNorm_dfatt_c IS
  SELECT fname
  FROM site_dfatt
  WHERE df_key in (select df_key from df, dbinc 
                    where df.dbinc_key = dbinc.dbinc_key 
                      and dbinc.db_key = this_db_key)
  FOR UPDATE OF site_dfatt.df_key;
 
cursor reNorm_orl_c IS
  SELECT fname
  FROM orl
  WHERE dbinc_key in (select dbinc_key from dbinc where db_key = this_db_key)
  FOR UPDATE OF orl.dbinc_key;
 
cursor reNorm_al_c IS
  SELECT fname
  FROM al
  where dbinc_key in (select dbinc_key from dbinc where db_key = this_db_key)
  FOR UPDATE OF al.al_key;
 
cursor reNorm_bp_c IS
  SELECT handle
  FROM bp
  WHERE device_type = 'DISK' and db_key = this_db_key
  FOR UPDATE OF bp.bp_key;
 
cursor reNorm_ccf_c IS
  SELECT fname
  FROM ccf
  WHERE dbinc_key in (select dbinc_key from dbinc where db_key = this_db_key)
  FOR UPDATE OF ccf.ccf_key;
 
cursor reNorm_cdf_c IS
  SELECT fname
  FROM cdf
  WHERE dbinc_key in (select dbinc_key from dbinc where db_key = this_db_key)
  FOR UPDATE OF cdf.dbinc_key;
 
cursor reNorm_tfatt_c IS
  SELECT fname
  FROM site_tfatt
  WHERE tf_key in (select tf_key from tf, dbinc 
                    where tf.dbinc_key = dbinc.dbinc_key 
                      and dbinc.db_key = this_db_key)
  FOR UPDATE OF site_tfatt.tf_key;
 
cursor lscrnames_c(glob number, allnames number) IS
    select 1 oby, rdbi.db_name dname, s.scr_name sname, s.scr_comment scomm
      from db rdb, dbinc rdbi, scr s
     where lscrnames_c.glob is null
       and lscrnames_c.allnames is null
       and rdbi.dbinc_key = rdb.curr_dbinc_key
       and rdb.db_key = s.db_key
       and s.db_key = this_db_key
       and s.db_key is not NULL
    UNION ALL
    select 2, 'ORA%GLOB', s.scr_name, s.scr_comment
      from scr s
     where s.db_key IS NULL
    UNION ALL
    select 3, rdbi.db_name, s.scr_name, s.scr_comment
      from db rdb, dbinc rdbi, scr s
     where lscrnames_c.glob is null
       and lscrnames_c.allnames is not null
       and rdbi.dbinc_key = rdb.curr_dbinc_key
       and rdb.db_key = s.db_key
       and s.db_key is not NULL
    order by 1 asc, 2 asc, 3 asc;
 
getPolled_AL BOOLEAN := FALSE;
getPolled_BP BOOLEAN := FALSE;
 
--
RTYP_ARCHIVED_LOG         CONSTANT number := 11;
RTYP_BACKUP_PIECE         CONSTANT number := 13;
RTYP_DFILE_COPY           CONSTANT number := 16;
 
CURSOR feedback_al(bp_key_poll NUMBER) IS
   SELECT al_recid recid, al_stamp stamp, fname
     FROM al, (SELECT distinct dbinc_key, thread#, sequence# 
                  FROM brl
                  WHERE bs_key IN 
                     (SELECT bs_key FROM bp 
                         WHERE db_key = this_db_key
                           AND bp_key > bp_key_poll 
                           AND purged = 'N'
                           AND device_type = 'SBT_TAPE' 
                           AND ba_access IN ('L', 'T')
                           AND site_key IN
                              (SELECT site_key FROM node WHERE
                                  db_unique_name like '$%' AND 
                                  db_key=this_db_key))) bal 
     WHERE al.site_key = this_site_key
       AND al.is_recovery_dest_file = 'YES'
       AND bal.dbinc_key=al.dbinc_key 
       AND bal.thread# = al.thread# 
       AND bal.sequence# = al.sequence#;
 
CURSOR feedback_bp(bp_key_poll NUMBER) IS
--
--
   SELECT bs_key, piece#, device_type, site_key,
          bp_recid recid, bp_stamp stamp, ba_access, handle
     FROM bp
     WHERE db_key = this_db_key
       AND ((site_key=this_site_key AND
             is_recovery_dest_file = 'YES') OR
            (device_type = 'SBT_TAPE' and ba_access in ('L', 'T', 'D')))
       AND bs_key in (SELECT bs_key FROM bp 
                         WHERE db_key = this_db_key
                           AND bp_key > bp_key_poll 
                           AND purged = 'N'
                           AND device_type = 'SBT_TAPE' 
                           AND ba_access IN ('L', 'T')
                           AND site_key IN
                              (SELECT site_key FROM node WHERE
                                  db_unique_name like '$%' AND 
                                  db_key=this_db_key))
   UNION
 
--
--
   SELECT bp.bs_key, piece#, device_type, site_key,
          bp_recid recid, bp_stamp stamp, ba_access, handle
      FROM bp,
            (SELECT distinct a.bs_key FROM bdf a,
                (SELECT bs_key, file#, create_scn, ckp_scn, dbinc_key
                    FROM bdf
                    WHERE bs_key IN 
                       (SELECT bs_key FROM bp
                           WHERE db_key = this_db_key
                             AND bp_key > bp_key_poll
                             AND purged = 'N'
                             AND device_type = 'SBT_TAPE'
                             AND ba_access IN ('L', 'T')
                             AND site_key IN
                                (SELECT site_key FROM node WHERE
                                    db_unique_name like '$%' AND
                                    db_key=this_db_key))) b
                 WHERE b.file#=a.file#
                   AND b.create_scn=a.create_scn
                   AND b.ckp_scn=a.ckp_scn
                   AND b.dbinc_key=a.dbinc_key
                   AND b.bs_key <> a.bs_key) c
     WHERE db_key = this_db_key
       AND site_key = this_site_key
       AND bp.bs_key = c.bs_key
       AND is_recovery_dest_file = 'YES'
 
     ORDER BY bs_key, piece#, device_type, ba_access desc;
 
disk_bp_rec  feedback_bp%ROWTYPE;
curr_bp_key_poll NUMBER;
 
 
/*----------------------*
 * Cursor Row Variables *
 *----------------------*/
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
pdbRec          pdbQ%rowtype;
picRec          picQ%rowtype;
tsRec           tsQ%rowtype;
dfRec           dfQ%rowtype;
tfRec           tfQ%rowtype;
rtRec           rtQ%rowtype;
orlRec          orlQ%rowtype;
grspRec         grspQ%rowtype;
 
/*---------------*
 * Private Types *
 *---------------*/
 
/*-------------------*
 * Private functions *
 *-------------------*/
 
FUNCTION vtr_tname(i IN number) RETURN VARCHAR2 IS
BEGIN
  RETURN vpd_table_list(i)(1);
END;
 
FUNCTION vtr_privs(i IN number) RETURN VARCHAR2 IS
BEGIN
  RETURN NVL(vpd_table_list(i)(2), 'SELECT,UPDATE,DELETE,INSERT');
END;
 
FUNCTION vtr_policy_required(i IN number) RETURN BOOLEAN IS
BEGIN
  RETURN vpd_table_list(i)(3) = 'T';
END;
 
FUNCTION vtr_update_check(i IN number) RETURN BOOLEAN IS
BEGIN
  RETURN vpd_table_list(i)(4) = 'T';
END;
 
PROCEDURE setDebugOn(dbglevel IN NUMBER DEFAULT RCVCAT_LEVEL_DEFAULT) IS
BEGIN
--
--
--
--
   dbms_output.enable(buffer_size => null);
   debug := TRUE;
   dbglvl := dbglevel;
END;
 
PROCEDURE setDebugOff IS
BEGIN
   dumpPkgState('Debug off');
   dbms_output.disable;  -- free memory
   debug := FALSE;
END;
 
PROCEDURE deb(line IN varchar2
              ,level IN number DEFAULT RCVCAT_LEVEL_DEFAULT) IS
BEGIN
   IF debOK(level) THEN
      IF this_is_ors_admin THEN
         EXECUTE IMMEDIATE 'BEGIN sys.kbrsi_icd.rsTrace(:1); END;' USING
            'RCVCAT: ' || line;
      END IF;
      dbms_output.put_line('DBGRCVCAT: '||line);
   END IF;
EXCEPTION
   WHEN others THEN
      dbms_output.put_line('(DO_NOT_IGNORE)caught exception during deb ' ||
                           substr(sqlerrm, 1, 512));
END deb;
 
PROCEDURE deb_put(line IN varchar2
              ,level IN number DEFAULT RCVCAT_LEVEL_DEFAULT) IS
BEGIN
   if debOK(level) then
      dbms_output.put('DBGRCVCAT: '||line);
   end if;
EXCEPTION
   WHEN others THEN
      dbms_output.put_line('(DO_NOT_IGNORE)caught exception during deb ' ||
                           substr(sqlerrm, 1, 512));
END deb_put;
 
FUNCTION debOK(level IN number DEFAULT RCVCAT_LEVEL_DEFAULT) RETURN boolean IS
BEGIN
  return (debug and dbglvl >= level);
END debOK;
 
PROCEDURE init_package_vars(p_server_key NUMBER DEFAULT NULL) IS
  proxy   varchar2(512);
  got_srvr_info  boolean := TRUE;
  no_ds_err         EXCEPTION;
  PRAGMA EXCEPTION_INIT(no_ds_err, -1034); -- Oracle not available
BEGIN
  BEGIN
    IF p_server_key IS NOT NULL THEN 
      SELECT * INTO this_server 
        FROM server 
        WHERE filter_user=user
          AND server_key = p_server_key;
    ELSE 
      SELECT * INTO this_server FROM server where filter_user=user;
    END IF;
         
--
--
    IF (INSTR(this_server.server_host, 'amazonaws.com') <> 0) THEN
      this_amazon_server := TRUE;
      this_server_url    := this_server.server_host;
      if (this_server.server_port is not null) then
         this_server_url := this_server_url || ':' || this_server.server_port;
      end if;
      this_server_uname  := NULL;
      this_server_passw  := NULL;
    ELSE
      this_amazon_server := FALSE;
      IF p_server_key IS NOT NULL THEN 
         BEGIN
           execute immediate 'begin dbms_rai_wallet2url(
                                wallet_loc   => :wallet_path,
                                cred_alias   => :wallet_alias,
                                username     => :username,
                                password     => :password,
                                url          => :url,
                                client       => ''REPLICATION''); end;'
                  using in this_server.wallet_path, in this_server.wallet_alias,
                        out this_server_uname, out this_server_passw,
                        out this_server_url;
         EXCEPTION
            WHEN no_ds_err THEN
               got_srvr_info := FALSE;
               deb('INIT_PKG_VARS:  Unable to communicate with downstream '||
                   'replication server');
         END;
      END IF;
    END IF;
    if got_srvr_info then
       if this_server.proxy_url is not null then
          proxy := this_server.proxy_url;
          if (this_server.proxy_port is not null) then
             proxy := proxy || ':' || this_server.proxy_port;
          end if;
          utl_http.set_proxy(proxy, null /* noproxy */);
       end if;
       utl_http.set_response_error_check(TRUE);
       utl_http.set_detailed_excp_support(TRUE);
       utl_http.set_wallet(path     => this_server.wallet_path,
                           password => null);
    end if;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      deb('init_package_vars(no_data_found): ignore it');
    WHEN TOO_MANY_ROWS THEN
      deb('init_package_vars(too_many_rows): ignore it');
    WHEN OTHERS THEN
      deb('init_package_vars(fail): p_server_key=' || p_server_key ||
          ',error='|| sqlerrm);
      RAISE;
  END;
END init_package_vars;
 
--
--
PROCEDURE checkResync IS
BEGIN
 
  IF (this_ckp_key IS NULL) THEN
    raise_application_error(-20031, 'Resync not started');
  END IF;
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
  IF (this_site_key IS NULL) THEN
    raise_application_error(-20199, 'Database site key not set');
  END IF;
 
END checkResync;
 
--
function date2stamp(dt IN date) return number is
  stamp number;
begin
  stamp := (((((to_number(to_char(dt, 'YYYY'))-1988)*12
         +     (to_number(to_char(dt, 'MM'))-1))*31
         +     (to_number(to_char(dt, 'DD'))-1))*24
         +     (to_number(to_char(dt, 'HH24'))))*60
         +     (to_number(to_char(dt, 'MI'))))*60
         +     (to_number(to_char(dt, 'SS')));
  return stamp;
end;
 
--
function stamp2date(stamp IN number) return date IS
x number;
dt varchar2(19);
begin
   if stamp is null then
       return null;
   end if;
 
   x := stamp;
 
   dt := to_char(mod(x,60), 'FM09'); -- seconds
   x := floor(x/60);
 
   dt := to_char(mod(x,60), 'FM09') || ':' || dt; -- minutes
   x := floor(x/60);
 
   dt := to_char(mod(x,24), 'FM09') || ':' || dt; -- hours
   x := floor(x/24);
 
   dt := to_char(mod(x,31)+1, 'FM09') || ' ' || dt; -- days
   x := floor(x/31);
 
   dt := to_char(mod(x,12)+1, 'FM09') || '/' || dt; -- months
 
   dt := to_char(floor(x/12)+1988)   || '/' || dt;
 
   return to_date(dt, 'YYYY/MM/DD HH24:MI:SS');
end;
 
--
PROCEDURE recomputeDbincStatus(db_key IN NUMBER,
                               dbinc_key IN NUMBER) IS
--
 PROCEDURE updateDbincStatus(db_key IN NUMBER, dbinc_key IN NUMBER) IS
 parent_key NUMBER;
 BEGIN
  BEGIN
   deb('updateDbincStatus - for db_key='||db_key||' dbinc='||dbinc_key);
   update dbinc set dbinc_status='PARENT'
      where dbinc_key =  updateDbincStatus.dbinc_key and
            db_key = updateDbincStatus.db_key;
 
--
   select parent_dbinc_key into parent_key from dbinc
      where dbinc_key= updateDbincStatus.dbinc_key and
            db_key = updateDbincStatus.db_key;
 
   updateDbincStatus(db_key, parent_key);
   deb('updateDbincStatus - normal return for dbinc=' || dbinc_key);
 
  EXCEPTION
    WHEN no_data_found THEN
       deb('updateDbincStatus- Last parent is  ' || dbinc_key);
       IF (dbinc_key is NOT NULL) THEN -- set last incarnation in the chain
           update dbinc set dbinc_status='PARENT'
              where dbinc_key=updateDbincStatus.dbinc_key and
                    db_key = updateDbincStatus.db_key;
       END IF;
       return;  -- reached the last known parent
    WHEN OTHERS THEN
       deb('updateDbincStatus - rollback all, release locks');
       rollback;
       RAISE;
  END;
 END updateDbincStatus;
BEGIN
 
--
  UPDATE db SET curr_dbinc_key = recomputeDbincStatus.dbinc_key
    WHERE db_key = recomputeDbincStatus.db_key;
 
  UPDATE dbinc SET dbinc_status='ORPHAN'
     WHERE dbinc.db_key = recomputeDbincStatus.db_key;
  updateDbincStatus(db_key, dbinc_key);
  UPDATE dbinc SET dbinc_status='CURRENT'
    where dbinc_key=recomputeDbincStatus.dbinc_key and
          db_key = recomputeDbincStatus.db_key;
END recomputeDbincStatus;
 
--
--
FUNCTION isOrsMedia(media IN VARCHAR2) RETURN BOOLEAN IS
BEGIN
   IF (media LIKE '%Recovery Appliance%') THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END IF;
END isOrsMedia;
 
--
PROCEDURE initOrsAdmin IS
BEGIN
   EXECUTE IMMEDIATE 'begin :owner := dbms_rai_owner; end;'
      USING OUT orsadmin_user;
EXCEPTION
   WHEN OTHERS THEN
      deb('initOrsAdmin(DO_NOT_IGNORE):' || substr(sqlerrm, 1, 132));
END initOrsAdmin;
 
--
PROCEDURE inheritPdbInc(
   db_key           IN NUMBER
  ,dbinc_key        IN NUMBER
  ,reset_scn        IN NUMBER
  ,parent_dbinc_key IN NUMBER) IS
BEGIN
   deb('inheritPdbInc - dbinc_key=' || dbinc_key ||
       ' parent_dbinc_key=' || parent_dbinc_key);
 
--
   FOR r IN (SELECT pdb.pdb_key, pdbinc.pdbinc_key
               FROM pdbinc, pdb
              WHERE pdb.pdb_key = pdbinc.pdb_key
                AND pdb.db_key  = inheritPdbInc.db_key
                AND pdb.con_id in (0, 1))
   LOOP
      deb('inheritPdbInc root');
      INSERT INTO pdb_dbinc
         (dbinc_key, pdb_key, drop_scn, drop_time, curr_pdbinc_key)
      VALUES
         (inheritPdbInc.dbinc_key, r.pdb_key, NULL, NULL, r.pdbinc_key);
   END LOOP;
 
   IF (parent_dbinc_key IS NULL) THEN
      RETURN;
   END IF;
 
--
   FOR r IN (SELECT pdb.pdb_key, pdb_dbinc.curr_pdbinc_key
               FROM pdb_dbinc, pdb
              WHERE pdb_dbinc.dbinc_key = inheritPdbInc.parent_dbinc_key
                AND pdb.pdb_key = pdb_dbinc.pdb_key
                AND pdb.create_scn < inheritPdbInc.reset_scn
                AND (pdb_dbinc.drop_scn IS NULL OR
                     pdb_dbinc.drop_scn > inheritPdbInc.reset_scn)
                AND pdb.con_id > 1)
   LOOP
      deb('inheritPdbInc - pdb_key=' || r.pdb_key ||
          ' curr_pdbinc_key=' || r.curr_pdbinc_key);
 
      INSERT INTO pdb_dbinc
         (dbinc_key, pdb_key, drop_scn, drop_time, curr_pdbinc_key)
      VALUES
         (inheritPdbInc.dbinc_key, r.pdb_key, NULL, NULL, r.curr_pdbinc_key);
   END LOOP;
END inheritPdbInc;
 
--
PROCEDURE recomputePluggableDbincStatus(dbinc_key IN NUMBER) IS
   CURSOR pdbincQ(dbinc_key NUMBER) IS
      SELECT curr_pdbinc_key, pdb_key
        FROM pdb_dbinc
       WHERE dbinc_key = pdbincQ.dbinc_key;
 
--
   PROCEDURE updatePluggableDbincStatus(pdbinc_key IN NUMBER) IS
      parent_key NUMBER;
   BEGIN
      UPDATE pdbinc SET pdbinc_status='PARENT'
       WHERE pdbinc_key = updatePluggableDbincStatus.pdbinc_key;
 
--
      SELECT parent_pdbinc_key INTO parent_key FROM pdbinc
       WHERE pdbinc_key= updatePluggableDbincStatus.pdbinc_key;
 
      updatePluggableDbincStatus(parent_key);
   EXCEPTION
      WHEN no_data_found THEN
         RETURN; -- reached the last known parent
   END updatePluggableDbincStatus;
BEGIN
   deb('recomputePluggableDbincStatus for dbinc_key ' || dbinc_key);
   FOR pdbincQrec in pdbincQ(recomputePluggableDbincStatus.dbinc_key) LOOP
--
      UPDATE pdbinc SET pdbinc_status = 'ORPHAN'
       WHERE pdbinc.pdb_key = pdbincQrec.pdb_key;
 
--
      updatePluggableDbincStatus(pdbincQrec.curr_pdbinc_key);
 
      UPDATE pdbinc SET pdbinc_status='CURRENT'
       WHERE pdbinc.pdbinc_key = pdbincQrec.curr_pdbinc_key;
   END LOOP;
END recomputePluggableDbincStatus;
 
FUNCTION getPdbInc(
   birth_scn      IN NUMBER
  ,con_id         IN NUMBER
  ,out_pdb_key   OUT NUMBER
) RETURN NUMBER IS
   local_pdbinc_key   NUMBER;
BEGIN
   IF (last_full_ckp_scn IS NULL) THEN
      deb('getPdbInc - full resync for first time');
      SELECT pdbinc_key, pdb_key
        INTO local_pdbinc_key, out_pdb_key
        FROM rci_pdbinc_this_dbinc pdbinc
       WHERE pdbinc.dbinc_key = this_dbinc_key
         AND pdbinc.drop_scn IS NULL
         AND pdbinc.con_id = getPdbInc.con_id
         AND pdbinc.pdbinc_status = 'CURRENT';
   ELSE
      deb('getPdbInc - last_full_ckp_scn ' || last_full_ckp_scn ||
                     ' birth_scn ' || birth_scn);
      FOR r IN (SELECT pdbinc.pdbinc_key, pdbinc.pdb_key, pdbinc.inc_scn,
                       pdbinc.next_inc_scn
                  FROM rci_pdbinc_this_dbinc pdbinc
                 WHERE pdbinc.dbinc_key = this_dbinc_key
                   AND pdbinc.drop_scn IS NULL
                   AND pdbinc.con_id  = getPdbInc.con_id
                   AND pdbinc.next_inc_scn > last_full_ckp_scn
                 ORDER BY pdbinc.inc_scn)
      LOOP
--
         IF (birth_scn >= r.inc_scn      AND
             birth_scn <= r.next_inc_scn AND
             birth_scn >= last_full_ckp_scn) THEN
            local_pdbinc_key := r.pdbinc_key;
            out_pdb_key      := r.pdb_key;
            EXIT;
         END IF;
 
         local_pdbinc_key := r.pdbinc_key;
         out_pdb_key      := r.pdb_key;
      END LOOP;
   END IF;
 
   IF (local_pdbinc_key IS NULL) THEN
      raise_application_error(-20999, 'getPdbInc - pdbinc not known');
   ELSE
      deb('getPdbInc - pdbinc ' || local_pdbinc_key);
   END IF;
   RETURN local_pdbinc_key;
END getPdbInc;
 
/* convert guid to pdb key */
FUNCTION guidToPdbKey(guid IN RAW, dropped_pdb IN binary_integer)
RETURN NUMBER IS
   l_pdb_key NUMBER;
BEGIN
   IF (guid IS NULL OR guid = ZERO_GUID) THEN
      SELECT pdb_key INTO l_pdb_key
        FROM pdb
       WHERE pdb.db_key = this_db_key
         AND pdb.con_id IN (1, 0);
   ELSE
      SELECT max(pdb_key) INTO l_pdb_key
        FROM pdb
       WHERE pdb.db_key = this_db_key
         AND pdb.guid   = guidToPdbKey.guid;
   END IF;
 
--
--
--
--
--
   IF (l_pdb_key IS NULL) THEN
      IF (dropped_pdb > 0) THEN
         SELECT pdb_key INTO l_pdb_key
           FROM pdb
          WHERE pdb.db_key = this_db_key
            AND pdb.con_id IN (1, 0);
      ELSE
         RAISE no_data_found;
      END IF;
   END IF;
 
   RETURN l_pdb_key;
EXCEPTION
   WHEN OTHERS THEN
      deb('guidToPdbKey translation failed for ' || guid);
      RAISE;
END guidToPdbKey;
 
/*-------------------*
 * Register Database *
 *-------------------*/
PROCEDURE registerDatabase(db_id          IN NUMBER
                          ,db_name        IN VARCHAR2
                          ,reset_scn      IN NUMBER
                          ,reset_time     IN DATE
                          ,db_unique_name IN VARCHAR2 default null
                          ,con_id         IN NUMBER   default 0
                          ,guid           IN RAW      default null
                          ) IS
 
  loc_dbinc_key number;
  loc_db_key    number;
  loc_pdb_key   number;
  p_dbun        node.db_unique_name%TYPE := upper(db_unique_name);
 
BEGIN
--
  BEGIN
    SELECT NULL INTO loc_dbinc_key FROM rcver WHERE version = catalogVersion;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20298, 'Not compatible recovery catalog');
  END;
 
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030 , 'Resync in progress');
  END IF;
 
  this_db_key := NULL;
  this_dbinc_key := NULL;
 
--
--
  IF p_dbun is NULL and registerDbPending.dbid is null THEN
     registerDbPending.dbid   := db_id;
     registerDbPending.con_id := con_id;
     registerDbPending.guid   := guid;
     deb('registerDatabase pushed to setDatabase stage for dbid = ' || db_id);
     RETURN;
  END IF;
 
  BEGIN
    INSERT INTO db(db_key, db_id, reg_db_unique_name) 
      VALUES(rman_seq.nextval, db_id, p_dbun)
    RETURNING db_key INTO loc_db_key;
  EXCEPTION
    WHEN dup_val_on_index THEN
      raise_application_error(-20002, 'Database already registered');
  END;
 
  INSERT INTO dbinc
    (dbinc_key, db_key, db_name, reset_scn, reset_time)
  VALUES
    (rman_seq.nextval, loc_db_key, upper(db_name), reset_scn, reset_time)
  RETURNING dbinc_key INTO loc_dbinc_key;
 
--
  recomputeDbincStatus(loc_db_key, loc_dbinc_key);
 
  deb('registerDatabase - ' ||
      'adding node row, db_unique_name value=' || p_dbun);
  INSERT INTO node(db_key, force_resync2cf, database_role, site_key,
                   db_unique_name)
     VALUES(loc_db_key, 'NO', 'PRIMARY', rman_seq.nextval,
            p_dbun);
 
  deb('registerDatabase - adding a row to pdb for rootdb, con_id=' ||
       con_id || ' guid=' || nvl(guid, ZERO_GUID));
  IF (con_id IS NULL OR con_id NOT IN (0, 1)) THEN
     raise_application_error(-20999, 
        'internal error: only con_id 0 or 1 can register database');
  END IF;
 
  INSERT INTO pdb
     (pdb_key, db_key, name, con_id, db_id, create_scn, guid)
  VALUES
     (rman_seq.nextval, loc_db_key, NULL, con_id, db_id, 1,
      nvl(guid, ZERO_GUID))
  RETURNING pdb_key INTO loc_pdb_key;
 
  INSERT INTO pdbinc
     (pdbinc_key, pdb_key, born_dbinc_key, inc_scn,
      begin_reset_scn, begin_reset_time, end_reset_scn,
      parent_pdbinc_key,  pdbinc_status)
  VALUES
     (rman_seq.nextval, loc_pdb_key, loc_dbinc_key, 1,
      reset_scn, reset_time, 1,
      NULL, 'CURRENT');
 
  INSERT INTO pdb_dbinc
     (dbinc_key, pdb_key, drop_scn, drop_time, curr_pdbinc_key)
  VALUES
     (loc_dbinc_key, loc_pdb_key, NULL, NULL, rman_seq.currval);
 
  setReason(RESYNC_REASON_NOACTION);
  commitChanges('registerDatabase');
 
--
  registerDbPending.dbid := null;
 
--
EXCEPTION
  WHEN OTHERS THEN
    deb('registerDatabase - rollback, release locks');
    rollback;
--
    registerDbPending.dbid := null;
    RAISE;
 
END registerDatabase;
 
--
--
 
PROCEDURE resetDatabase(db_id             IN NUMBER
                       ,db_name           IN VARCHAR2
                       ,reset_scn         IN NUMBER
                       ,reset_time        IN DATE
                       ,parent_reset_scn  IN NUMBER
                       ,parent_reset_time IN DATE
                       ) IS
 
local          dbinc%rowtype;                    -- local variables
BEGIN
--
  BEGIN
    SELECT NULL INTO local.db_key FROM rcver WHERE version = catalogVersion;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20298, 'Not compatible with recovery catalog');
  END;
 
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
  IF (db_id IS NULL) THEN
    raise_application_error(-20007, 'db_id is null');
  END IF;
 
  this_db_key := NULL;
  this_dbinc_key := NULL;
 
  BEGIN
    SELECT db_key, curr_dbinc_key INTO local.db_key, local.dbinc_key
    FROM db
    WHERE db.db_id = resetDatabase.db_id               -- should return 1 row
    FOR UPDATE OF db.db_key;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20001, 'Database not found');
  END;
 
--
  BEGIN
    SELECT dbinc_key INTO local.parent_dbinc_key
    FROM dbinc
    WHERE dbinc.db_key = local.db_key
    AND   dbinc.reset_scn = resetDatabase.parent_reset_scn
    AND   dbinc.reset_time = resetDatabase.parent_reset_time;
  EXCEPTION
    WHEN no_data_found THEN
      local.parent_dbinc_key := NULL;
  END;
 
--
  BEGIN
    INSERT INTO dbinc
      (dbinc_key, db_key, db_name, reset_scn, reset_time, parent_dbinc_key)
    VALUES
      (rman_seq.nextval, local.db_key, upper(db_name), reset_scn,
       reset_time, local.parent_dbinc_key)
    RETURNING dbinc_key INTO local.dbinc_key;
  EXCEPTION
    WHEN dup_val_on_index THEN
      raise_application_error(-20009, 'Db incarnation already registered');
  END;
 
  inheritPdbInc(
     local.db_key, local.dbinc_key, reset_scn, local.parent_dbinc_key);
 
--
  recomputeDbincStatus(local.db_key, local.dbinc_key);
  recomputePluggableDbincStatus(local.dbinc_key);
  commitChanges('resetDatabase');
 
--
EXCEPTION
  WHEN OTHERS THEN
    deb('resetDatabase - rollback, release locks');
    rollback;
    RAISE;
 
END resetDatabase;
 
--
FUNCTION resetDatabase(db_id             IN NUMBER
                      ,db_name           IN VARCHAR2
                      ,reset_scn         IN NUMBER
                      ,reset_time        IN DATE
                      ,parent_reset_scn  IN NUMBER
                      ,parent_reset_time IN DATE
                       ) RETURN NUMBER IS
local    dbinc%rowtype;                    -- local variables
BEGIN
--
  BEGIN
    SELECT NULL INTO local.db_key FROM rcver WHERE version = catalogVersion;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20298, 'Not compatible with recovery catalog');
  END;
 
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
  IF (db_id IS NULL) THEN
    raise_application_error(-20007, 'db_id is null');
  END IF;
 
  BEGIN
    SELECT db_key INTO local.db_key
      FROM db
     WHERE db.db_id = resetDatabase.db_id;              -- should return 1 row
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20001, 'Database not found');
  END;
 
  SELECT dbinc_key INTO local.dbinc_key
    FROM dbinc
   WHERE dbinc.db_key = local.db_key
     AND dbinc.reset_scn = resetDatabase.reset_scn
     AND dbinc.reset_time = resetDatabase.reset_time;
 
  resetDatabase(local.dbinc_key, db_name);
 
  RETURN local.dbinc_key;
END resetDatabase;
 
--
 
PROCEDURE resetDatabase(
  dbinc_key  IN NUMBER
 ,db_name    IN VARCHAR2
) IS
 
local     dbinc%rowtype;                    -- local variables
BEGIN
--
  BEGIN
    SELECT NULL INTO local.db_key FROM rcver WHERE version = catalogVersion;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20298, 'Not compatible with recovery catalog');
  END;
 
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
  IF (dbinc_key IS NULL) THEN
    raise_application_error(-20008, 'Database incarnation key is missing');
  END IF;
 
  this_db_key := NULL;
  this_dbinc_key := NULL;
 
  BEGIN
    SELECT db_key, db_name
    INTO local.db_key, local.db_name
    FROM dbinc
    WHERE dbinc.dbinc_key = resetDatabase.dbinc_key;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20010, 'Database incarnation not found');
  END;
 
--
  IF (upper(db_name) <> local.db_name) THEN
     IF (db_name != 'UNKNOWN') THEN
        UPDATE dbinc
           SET db_name = upper(resetDatabase.db_name)
         WHERE dbinc.dbinc_key = resetDatabase.dbinc_key;
     ELSE
        raise_application_error(-20004, 'Database name does not match');
     END IF;
  END IF;
 
--
  recomputeDbincStatus(local.db_key, resetDatabase.dbinc_key);
  recomputePluggableDbincStatus(resetDatabase.dbinc_key);
 
  commitChanges('resetDatabase');
 
--
EXCEPTION
  WHEN OTHERS THEN
    deb('resetDatabase - rollback, release locks');
    rollback;
    RAISE;
END resetDatabase;
 
procedure resetDatabase(
  dbinc_key  IN  number
 ,db_name    IN  varchar2
 ,reset_scn  OUT number
 ,reset_time OUT date
 ,db_id      IN  number DEFAULT NULL
) IS
  local_db_key dbinc.db_key%TYPE;
BEGIN
  IF db_id IS NOT NULL THEN
     BEGIN
       SELECT db_key INTO local_db_key
         FROM db
        WHERE db.db_id = resetDatabase.db_id;           -- should return 1 row
     EXCEPTION
       WHEN no_data_found THEN
         raise_application_error(-20001, 'Database not found');
     END;
  ELSE
     local_db_key := this_db_key;
  END IF;
 
  BEGIN
    SELECT reset_scn, reset_time
    INTO resetDatabase.reset_scn, resetDatabase.reset_time
    FROM dbinc
    WHERE dbinc.dbinc_key = resetDatabase.dbinc_key AND
          (db_id IS NULL OR dbinc.db_key = local_db_key);
 
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20010, 'Database incarnation not found');
  END;
 
  resetDatabase(dbinc_key, db_name);
END resetDatabase;
 
PROCEDURE unRegisterDatabase(
  db_key     IN NUMBER DEFAULT NULL
 ,db_id      IN NUMBER
) IS
 
tmp         NUMBER;
cnt         NUMBER := 0;
 
BEGIN
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
 
--
  BEGIN
    SELECT 0 INTO tmp FROM db
    WHERE db.db_id = unRegisterDatabase.db_id;
  EXCEPTION
  WHEN no_data_found THEN
    raise_application_error(-20001, 'Database not found');
  END;
 
--
--
  SELECT count(*) INTO cnt FROM db
   WHERE storage_prov = 'Y'
     AND db.db_id = unRegisterDatabase.db_id;
 
  IF (cnt <> 0) THEN
    raise_application_error(-20301, 'Cannot unregister database');
  END IF;
 
--
--
  SELECT 0 INTO tmp FROM db
    WHERE db.db_id = unRegisterDatabase.db_id FOR UPDATE OF db.db_key;
 
  DELETE FROM bp 
    WHERE db_key = 
      (select db_key from db where db.db_id = unRegisterDatabase.db_id);
   
  DELETE FROM db WHERE db.db_id = unRegisterDatabase.db_id;
  commitChanges('unRegisterDatabase');
 
--
EXCEPTION
  WHEN OTHERS THEN
    deb('unregisterDatabase - rollback, release locks');
    rollback;
    RAISE;
 
END unRegisterDatabase;
 
--
PROCEDURE setArchiveFileScopeAttributes(logs_shared  IN NUMBER) IS
BEGIN
   deb('setArchiveFileScopeAttributes');
 
   IF logs_shared > 0 THEN
      dbms_rcvcat.logs_shared := TRUE#;
   ELSE
      dbms_rcvcat.logs_shared := FALSE#;
   END IF;
   deb('logs_shared = ' || dbms_rcvcat.logs_shared);
 
   dbms_rcvman.setArchiveFileScopeAttributes(logs_shared);
 
   deb('exiting setArchiveFileScopeAttributes');
END setArchiveFileScopeAttributes;
 
--
PROCEDURE setBackupFileScopeAttributes(
                 disk_backups_shared IN NUMBER,
                 tape_backups_shared IN NUMBER) IS
   lsite_key NUMBER;
BEGIN
   deb('setBackupFileScopeAttributes');
 
   IF disk_backups_shared IS NOT NULL THEN
      IF disk_backups_shared > 0 THEN
         dbms_rcvcat.disk_backups_shared := TRUE#;
      ELSE
         dbms_rcvcat.disk_backups_shared := FALSE#;
      END IF;
   END IF;
 
   IF tape_backups_shared IS NOT NULL THEN
      IF tape_backups_shared > 0 THEN
         dbms_rcvcat.tape_backups_shared := TRUE#;
      ELSE
         dbms_rcvcat.tape_backups_shared := FALSE#;
      END IF;
   END IF;
 
   deb('disk_backups_shared='||dbms_rcvcat.disk_backups_shared);
   deb('tape_backups_shared='||dbms_rcvcat.tape_backups_shared);
 
   dbms_rcvman.setBackupFileScopeAttributes(disk_backups_shared,
                                            tape_backups_shared);
 
   deb('exiting setBackupFileScopeAttributes');
END setBackupFileScopeAttributes;
 
/*--------------*
 * Set Database *
 *--------------*/
 
--
 
PROCEDURE setDatabase(db_name        IN VARCHAR2
                     ,reset_scn      IN NUMBER
                     ,reset_time     IN DATE
                     ,db_id          IN NUMBER
                     ,db_unique_name IN VARCHAR2
                     ,dummy_instance IN BOOLEAN
                     ,cf_type        IN NUMBER
                     ,site_aware     IN BOOLEAN default FALSE
                     ,ors_instance   IN BOOLEAN default FALSE) IS
 
   local             dbinc%rowtype;                    -- local variables
   current_inc       VARCHAR2(3);
   dbnm              dbinc.db_name%TYPE;
   dbnm_in           dbinc.db_name%TYPE;
   rid               varchar2(18);
   local_site_key    number;
   dbunqnm           node.db_unique_name%TYPE;
   db_role           node.database_role%type;
   dbunqnm_in        node.db_unique_name%TYPE;
   l_reg_dbunqnm     node.db_unique_name%TYPE;
   cat_version       varchar2(12);
   vpd_version       varchar2(12);
   prim_dbunqnm_in   node.db_unique_name%TYPE;
   db_id_in          number;
   tmp_dbunqnm_cnt   number;
   tmp_primary_cnt   number;
   cf_type_in        number;
   my_dbunqnm        watermarks.db_unique_name%TYPE;
BEGIN
--
  BEGIN
    SELECT NULL INTO local.db_key FROM rcver WHERE version = catalogVersion;
  EXCEPTION
    WHEN no_data_found THEN
      raise_application_error(-20298, 'Not compatible with recovery catalog');
  END;
 
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
 
  this_db_key := NULL;                  -- clear in case exception raised
  this_dbinc_key := NULL;
  kccdivts := NULL;
  dbnm_in := upper(db_name);
  dbunqnm_in := upper(db_unique_name);
  db_id_in := db_id;
  cf_type_in := cf_type;
 
--
--
  IF registerDbPending.dbid = db_id AND NOT ors_instance THEN
     registerDatabase(db_id          => db_id,
                      db_name        => dbnm_in,
                      reset_scn      => reset_scn,
                      reset_time     => reset_time,
                      db_unique_name => dbunqnm_in,
                      con_id         => registerDbPending.con_id,
                      guid           => registerDbPending.guid);
  END IF;  
 
  deb('setDatabase(db_unique_name)='||db_unique_name);
 
--
  IF ors_instance THEN
    IF db_unique_name IS NULL OR substr(db_unique_name, 1, 1) = '$' THEN
      raise_application_error(-20999, 
         'internal error: db_unique_name value is invalid=' || db_unique_name);
    END IF;
    IF db_id IS NULL THEN
      raise_application_error(-20999, 
         'internal error: db_id must be specified for ORS instance');
    END IF;
    cf_type_in := CF_STANDBY;
 
--
--
--
    IF instr(dbunqnm_in, '$'|| db_id) = 0 THEN
       dbunqnm_in := dbunqnm_in || '$' || db_id;
    END IF;
    dbunqnm_in := '$' || dbunqnm_in;
  END IF;
 
<<now_try_with_dbid>>
 
--
--
--
--
 
  IF (db_id_in IS NOT NULL) THEN
    BEGIN
      SELECT db_key, curr_dbinc_key, db_name, reg_db_unique_name
        INTO local.db_key, local.dbinc_key, local.db_name, l_reg_dbunqnm
      FROM db
      WHERE db.db_id = db_id_in;                        -- should return 1 row
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(-20001, 'Database not found');
    END;
 
--
    IF (dbnm_in is NOT NULL AND db_id is NOT NULL) THEN
--
--
--
--
 
       BEGIN
         SELECT decode(dbinc.dbinc_key, db.curr_dbinc_key, 'YES', 'NO'),
                dbinc.db_name, dbinc.rowid
         INTO   current_inc, dbnm, rid
         FROM db, dbinc
         WHERE db.db_key = dbinc.db_key
         AND   db.db_id = setDatabase.db_id
         AND   dbinc.reset_scn = setDatabase.reset_scn
         AND   dbinc.reset_time = setDatabase.reset_time;
       EXCEPTION
         WHEN no_data_found THEN
           raise_application_error(-20003, 'Database incarnation not found');
       END;
 
       IF (current_inc = 'NO') THEN
         raise_application_error(-20011, 'Database incarnation not current');
       END IF;
       IF (dbnm != dbnm_in) THEN
          UPDATE dbinc
             SET dbinc.db_name = dbnm_in
           WHERE rowid = rid;
          commitChanges('setDatabase');
       END IF;
    END IF;
 
    IF (NOT dummy_instance AND dbunqnm_in IS NOT NULL) THEN
       deb('setDatabase - check db_unique_name= ' || dbunqnm_in ||
           ' cf_type_in= ' || cf_type_in);
 
--
--
--
--
       IF l_reg_dbunqnm IS NULL THEN
          UPDATE db
             SET db.reg_db_unique_name = dbunqnm_in
           WHERE db.db_key = local.db_key
             AND db.db_id = setDatabase.db_id
             AND db.reg_db_unique_name IS NULL;
          deb('setDatabase: updating null db_unique_name in DB with  ' ||
              dbunqnm_in || 'number of rows updated ' || sql%rowcount);
          commitChanges('setDatabase1');
       END IF;
 
--
--
--
--
--
--
       SELECT count(*) into tmp_dbunqnm_cnt
          FROM node
          WHERE node.db_unique_name is NULL
            AND node.db_key = local.db_key;
       IF tmp_dbunqnm_cnt = 1 THEN
          SELECT count(*) into tmp_dbunqnm_cnt
             FROM node
             WHERE node.db_unique_name is not NULL
               AND node.db_key = local.db_key;
          IF tmp_dbunqnm_cnt > 0 THEN
             raise_application_error(-20999, 
                'internal error: found non-null and null site name');
          END IF;
          UPDATE NODE SET node.db_unique_name = dbunqnm_in
             WHERE node.db_unique_name is NULL
               AND node.db_key = local.db_key;
          deb('setDatabase: updating null db_unique_name with ' ||dbunqnm_in ||
              'number of rows updated ' || sql%rowcount);
       END IF;
 
       BEGIN
--
          SELECT node.database_role, site_key
            INTO db_role, local_site_key
            FROM node
           WHERE node.db_key = local.db_key
             AND node.db_unique_name = dbunqnm_in;
 
--
--
          SELECT count(*) into tmp_primary_cnt
            FROM node
           WHERE node.database_role = 'PRIMARY'
             AND site_key <> local_site_key
             AND node.db_key = local.db_key;
 
          deb('setDatabase - check database_role');
          IF (cf_type_in = CF_STANDBY AND db_role != 'STANDBY') THEN
--
             deb('setDatabase - database role not standby - updating');
             UPDATE node
                SET node.database_role = 
                       decode(substr(node.db_unique_name,1,1), '$',
                             'RA', 'STANDBY'),
                    node.high_conf_recid = 0
              WHERE site_key = local_site_key
                AND (node.database_role <>
                     decode(substr(node.db_unique_name,1,1), '$',
                            'RA', 'STANDBY'));
             commitChanges('setDatabase2');
          ELSIF ((cf_type_in = CF_CURRENT OR cf_type_in = CF_BACKUP) AND 
                 (db_role != 'PRIMARY' OR tmp_primary_cnt > 1)) THEN
--
             deb('setDatabase - not primary or primary_cnt='||tmp_primary_cnt);
--
             UPDATE node
                SET node.database_role =
                    decode(substr(node.db_unique_name,1,1), '$',
                          'RA', 'STANDBY'),
                    node.high_conf_recid = 0
              WHERE site_key <> local_site_key
                AND db_key = local.db_key;
 
--
--
--
--
             UPDATE node
                SET node.database_role = 'PRIMARY',
                    node.high_conf_recid = 0,
                    high_ic_recid = 0,  
                    high_ts_recid = NULL,
                    high_df_recid = NULL,
                    high_rt_recid = NULL,
                    high_orl_recid = NULL,
                    high_tf_recid = 0,
                    high_pdb_recid = NULL,
                    high_pic_recid = 0
              WHERE site_key = local_site_key
                AND db_key = local.db_key;
 
             sessionWaterMarks.high_ic_recid  := 0;
             sessionWaterMarks.high_pic_recid := 0;
 
             commitChanges('setDatabase3');
             prev_sessionWaterMarks := sessionWaterMarks;
          END IF;
       EXCEPTION
          WHEN no_data_found THEN
             IF (cf_type_in = CF_CURRENT OR cf_type_in = CF_BACKUP) THEN
                deb('setDatabase: adding node row, new primary database...');
--
                UPDATE node
                   SET node.database_role = 
                          decode(substr(node.db_unique_name,1,1),'$',
                                 'RA', 'STANDBY'),
                       node.high_conf_recid = 0
                   WHERE db_key = local.db_key;
                INSERT INTO node(db_unique_name, db_key, force_resync2cf,
                                 database_role, site_key)
                VALUES(dbunqnm_in, local.db_key, 'NO', 
                       'PRIMARY', rman_seq.nextval);
                commitChanges('setDatabase4');
             ELSIF cf_type_in = CF_STANDBY THEN
--
                deb('setDatabase: adding node row, new standby database...');
                BEGIN
                   INSERT INTO node(db_unique_name, db_key, force_resync2cf,
                                    database_role, 
                                    site_key)
                   VALUES(dbunqnm_in, local.db_key, 'NO', 
                          decode(substr(dbunqnm_in,1,1), '$',
                                 'RA', 'STANDBY'), 
                          rman_seq.nextval);
                   commitChanges('setDatabase5');
                EXCEPTION
                  WHEN dup_val_on_index THEN
                     deb('setDatabase - someone inserted same standby');
                END;
             ELSE
--
--
--
--
--
--
                BEGIN
                   deb('setDatabase - falking db_unique_name from'||
                       dbunqnm_in);
                   SELECT db_unique_name into prim_dbunqnm_in from node
                      WHERE db_key = local.db_key AND
                            database_role = 'PRIMARY';
                   dbunqnm_in := prim_dbunqnm_in;
                   deb('setDatabase - changing dbunqnm_in to ' || dbunqnm_in);
                EXCEPTION
                   WHEN no_data_found THEN
                      deb('setDatabase - unknown dbunqnm_in set to null');
                      dbunqnm_in := null;
                END;
             END IF;
       END;
    END IF;
--
  ELSIF (dbnm_in IS NOT NULL) THEN
 
    BEGIN
      SELECT db.db_key, db.curr_dbinc_key, db.db_id
        INTO local.db_key, local.dbinc_key, db_id_in
        FROM db, dbinc
       WHERE db.curr_dbinc_key = dbinc.dbinc_key
         AND dbinc.db_name   = dbnm_in;
    EXCEPTION
      WHEN no_data_found THEN
        raise_application_error(-20001, 'Database not found');
      WHEN too_many_rows THEN
        raise_application_error(-20005, 'Database name is ambiguous');
    END;
    GOTO now_try_with_dbid;
 
  ELSE
    raise_application_error(-20006, 'Database name is missing');
  END IF;
 
--
--
  this_db_unique_name := dbunqnm_in;
  this_db_key         := local.db_key;
  this_dbinc_key      := local.dbinc_key;
  deb('setDatabase - this_db_unique_name='||this_db_unique_name);
  deb('setDatabase - this_dbinc_key:'||to_char(this_dbinc_key));
  deb('setDatabase - this_db_key:'||to_char(this_db_key));
 
  BEGIN
    select site_key into this_site_key from node
        where db_unique_name=upper(dbunqnm_in)
          AND db_key = this_db_key;
    deb('setDatabase - this_site_key:'||this_site_key);
  EXCEPTION
    WHEN no_data_found THEN
      BEGIN
         select site_key, db_unique_name 
             into this_site_key, dbunqnm_in from node
             where database_role='PRIMARY'
               AND db_key = this_db_key;
         deb('setDatabase - this_site_key(primary):'||this_site_key);
      EXCEPTION
         WHEN no_data_found THEN
--
--
            deb('setDatabase - this_site_key is null');
            this_site_key := null;
      END;
  END;
 
  cntbs := 0;
 
--
--
  dbms_rcvman.setDatabase (dbnm_in, reset_scn, reset_time,
                           db_id, this_db_unique_name, site_aware,
                           dummy_instance, ors_instance);
 
  client_site_aware := site_aware;
 
  IF client_site_aware THEN
     setArchiveFileScopeAttributes(logs_shared => 0);
     setBackupFileScopeAttributes (disk_backups_shared => 0, 
                                   tape_backups_shared => 1);
  END IF;
 
  IF this_is_ors THEN
    BEGIN
      IF this_is_ors_admin THEN
         EXECUTE IMMEDIATE 'select rtrim(ltrim(value)) 
            from sys.v_$parameter where lower(name)=''db_unique_name'''
            into my_dbunqnm;
      ELSE
         my_dbunqnm := this_db_unique_name;
      END IF;
      INSERT INTO do_seq(db_key) VALUES (this_db_key);
      INSERT INTO watermarks(db_key, db_unique_name, rs_version_stamp)
        VALUES (this_db_key, my_dbunqnm, SYSDATE);
      commitChanges('setDatabase6 - added a row to watermarks,'||this_db_key);
    EXCEPTION
      WHEN dup_val_on_index THEN
        NULL;
    END;
  END IF;
END setDatabase;
 
--
PROCEDURE setDatabase(db_name        IN VARCHAR2
                     ,reset_scn      IN NUMBER
                     ,reset_time     IN DATE
                     ,db_id          IN NUMBER
                     ,db_unique_name IN VARCHAR2 DEFAULT NULL) IS
BEGIN
   setDatabase(db_name        => db_name,
               reset_scn      => reset_scn,
               reset_time     => reset_time,
               db_id          => db_id,
               db_unique_name => db_unique_name,
               dummy_instance => FALSE,
               cf_type        => CF_CURRENT);
END setDatabase;
 
--
--
--
--
 
PROCEDURE setDatabase(dbinc_key number) IS
  dbinc_row dbinc%ROWTYPE;
  db_row    db%ROWTYPE;
BEGIN
 
  select * into dbinc_row from dbinc where dbinc_key = setDatabase.dbinc_key;
  select * into db_row from db where db_key = dbinc_row.db_key;
  setDatabase(db_name        => dbinc_row.db_name,
              reset_scn      => dbinc_row.reset_scn,
              reset_time     => dbinc_row.reset_time,
              db_id          => db_row.db_id);
 
END setDatabase;
 
procedure setDatabase IS
  dbinckey number;
BEGIN
 
  select curr_dbinc_key into dbinckey from db;
  setDatabase(dbinckey);
 
END setDatabase;
 
 
--
--
--
--
--
--
--
--
--
PROCEDURE doReplicationReconcile(p_db_key           IN NUMBER, 
                                 p_lib_key          IN NUMBER, 
                                 p_server_key    IN NUMBER) IS
  dbinckey              NUMBER;
  dbinc_row             dbinc%ROWTYPE;
  db_row                db%ROWTYPE;
  l_dbun                VARCHAR2(512);
  l_save_this_server    SERVER%ROWTYPE;
  resync_done           NUMBER;
BEGIN
 
  deb('doReplicationReconcile: ' ||
      '( p_db_key=>' || p_db_key||
      ', p_lib_key=>' || p_lib_key||
      ', p_server_key=>' || p_server_key|| ')');
 
  select curr_dbinc_key into dbinckey from db WHERE db_key=p_db_key;
  select * into dbinc_row from dbinc where dbinc_key = dbinckey;
  select * into db_row from db where db_key = dbinc_row.db_key;
 
  execute immediate 'begin :url :=  dbms_ra_int.dbkey2name(:db_key); end;'
          using out this_url_db_unique_name, in dbinc_row.db_key;
 
  execute immediate 'select  rtrim(ltrim(value)) from sys.v_$parameter ' ||
                    'where lower(name)=''db_unique_name''' into l_dbun;
 
  deb('doReplicationReconcile: info for setDatabase ' ||
      '  db_name=>' || dbinc_row.db_name ||
      ', reset_scn=>' ||dbinc_row.reset_scn||
      ', reset_time=>' ||dbinc_row.reset_time||
      ', db_id=>' ||db_row.db_id||
      ', db_unique_name=>' ||l_dbun||
      ', this_url_db_unique_name=>' || this_url_db_unique_name);
 
--
  l_save_this_server  := this_server;
  
--
  this_lib_key := p_lib_key;
 
  init_package_vars(p_server_key);
   
  setDatabase(db_name        => dbinc_row.db_name,
              reset_scn      => dbinc_row.reset_scn,
              reset_time     => dbinc_row.reset_time,
              db_id          => db_row.db_id,
              db_unique_name => l_dbun,
              dummy_instance => FALSE,
              cf_type        => CF_STANDBY,
              site_aware     => TRUE,
              ors_instance   => TRUE);
  
--
  this_verrec := null;
  this_curr_inc := null;
  this_wmrec := null;
  this_v_wmrec := null;
  deb('clearing all variables used for reconcile');
  select nvl(count(*), 0) into resync_done 
     from ts where dbinc_key = this_dbinc_key;
  IF resync_done > 0 THEN
     writeFixedSections;
     readBackupSections;
  ELSE
     deb('doReplicationReconcile: resync not done, skipping reconcile');
  END IF;
  
  this_server  := l_save_this_server;
  this_lib_key := NULL;
  this_url_db_unique_name := NULL;
  this_verrec := null;
  this_curr_inc := null;
  this_wmrec := null;
  this_v_wmrec := null;
  deb('doReplicationReconcile: resync (suc)');
  
EXCEPTION
  WHEN OTHERS THEN
    deb('doReplicationReconcile: resync (fail):' || substr(sqlerrm, 1, 512));
    this_server := l_save_this_server;
    this_url_db_unique_name := NULL;
    this_verrec := null;
    this_curr_inc := null;
    this_wmrec := null;
    this_v_wmrec := null;
    RAISE;
    
END doReplicationReconcile;
 
 
/*-----------------------------*
 * Recovery Catalog Checkpoint *
 *-----------------------------*/
 
PROCEDURE lockForCkpt(ors_inspect IN boolean DEFAULT FALSE) IS
   local_dbid     NUMBER;
   local_dbkey    NUMBER;
   start_time     DATE := sysdate;
BEGIN
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
--
--
--
--
  SELECT db_id INTO local_dbid FROM db
  WHERE db_key = this_db_key FOR UPDATE OF db.db_key;
 
--
--
  IF this_is_ors THEN
    SELECT high_bp_recid INTO this_curr_bp_recid FROM watermarks
      WHERE db_key = this_db_key FOR UPDATE OF watermarks.high_bp_recid;
    this_high_bp_recid := this_curr_bp_recid;
  END IF;
 
  this_lock_ors_inspect := ors_inspect;
  deb('lockForCkpt - took ' || ((sysdate - start_time) * 86400) || ' seconds');
  deb('lockForCkpt - Obtained all locks for db ' || to_char(this_db_key));
 
--
--
--
--
END lockForCkpt;
 
FUNCTION ckptNeeded(
  ckp_scn          IN NUMBER
 ,ckp_cf_seq       IN NUMBER
 ,cf_version       IN DATE
 ,cf_type          IN NUMBER
 ,high_df_recid    IN NUMBER
 ,high_orl_recid   IN NUMBER
 ,high_cdf_recid   IN NUMBER
 ,high_al_recid    IN NUMBER
 ,high_bp_recid    IN NUMBER
 ,high_do_recid    IN NUMBER
 ,high_offr_recid  IN NUMBER
 ,high_pc_recid    IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_conf_recid  IN NUMBER  DEFAULT NULL -- for compatibility
 ,rltime           IN DATE    DEFAULT NULL -- for compatibility
 ,high_ts_recid    IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_bs_recid    IN NUMBER  DEFAULT NULL -- for compatibility
 ,lopen_reset_scn  IN number  DEFAULT NULL -- for compatibility
 ,lopen_reset_time IN DATE    DEFAULT NULL -- for compatibility
 ,high_ic_recid    IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_tf_recid    IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_rt_recid    IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_grsp_recid  IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_nrsp_recid  IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_bcr_recid   IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_pdb_recid   IN NUMBER  DEFAULT NULL -- for compatibility
 ,high_pic_recid   IN NUMBER  DEFAULT NULL -- for compatibility
) RETURN NUMBER IS
 
ckp_type              NUMBER;
local                 node%rowtype;
local_dbid            NUMBER := 0;
local_reset_time      DATE;
local_reset_scn       NUMBER := 0;
cksum                 NUMBER;
ckp_desc              VARCHAR2(30);
BEGIN
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
  IF (this_site_key IS NULL) THEN
    raise_application_error(-20199, 'Site key is not set');
  END IF;
 
  SELECT db_id
  INTO local_dbid
  FROM db
  WHERE db.db_key = this_db_key FOR UPDATE OF db.db_key;
 
  deb('ckptNeeded - Obtained all locks for database ' ||
      to_char(this_db_key));
 
--
  cksum := high_df_recid           + high_orl_recid          +
           high_cdf_recid          + high_al_recid           +
           high_bp_recid           + high_do_recid           +
           high_offr_recid         + nvl(high_pc_recid, 0)   +
           nvl(high_conf_recid, 0) + nvl(high_ts_recid, 0)   +
           nvl(high_bs_recid, 0)   + nvl(high_ic_recid, 0)   +
           nvl(high_tf_recid, 0)   + nvl(high_rt_recid, 0)   +
           nvl(high_grsp_recid, 0) + nvl(high_nrsp_recid, 0) +
           nvl(high_bcr_recid, 0)  + nvl(high_pdb_recid, 0)  +
           nvl(high_pic_recid, 0);
 
--
--
--
--
--
--
  SELECT cf_create_time, nvl(high_df_recid,0), nvl(high_ts_recid,0),
         nvl(high_orl_recid,0), nvl(high_cdf_recid,0), nvl(high_al_recid,0),
         nvl(high_bp_recid,0), nvl(high_do_recid,0), nvl(high_offr_recid,0),
         nvl(high_pc_recid,0), full_ckp_cf_seq, job_ckp_cf_seq,
         nvl(high_ic_recid,0), nvl(high_bs_recid,0), nvl(high_tf_recid, 0),
         nvl(high_rt_recid, 0), nvl(high_grsp_recid, 0),
         nvl(high_nrsp_recid, 0), nvl(high_bcr_recid, 0),
         high_conf_recid, force_resync2cf, nvl(high_pdb_recid, -1),
         nvl(high_pic_recid, 0)
    INTO   local.cf_create_time, local.high_df_recid, local.high_ts_recid,
         local.high_orl_recid, local.high_cdf_recid, local.high_al_recid,
         local.high_bp_recid,  local.high_do_recid, local.high_offr_recid,
         local.high_pc_recid,  local.full_ckp_cf_seq, local.job_ckp_cf_seq,
         local.high_ic_recid, local.high_bs_recid, local.high_tf_recid,
         local.high_rt_recid, local.high_grsp_recid, local.high_nrsp_recid,
         local.high_bcr_recid, local.high_conf_recid, local.force_resync2cf,
         local.high_pdb_recid, local.high_pic_recid
    FROM node
    WHERE site_key = this_site_key;
 
  SELECT reset_scn, reset_time into local_reset_scn, local_reset_time 
    FROM dbinc
    WHERE dbinc_key = this_dbinc_key;
 
  ckp_type := RESYNC_NONE;
  setReason(RESYNC_REASON_NONE);
 
  IF (rltime IS NOT NULL AND rltime != local_reset_time) THEN
--
--
--
--
--
--
    deb('ckptNeeded - rltime='||to_char(rltime)||
         ', local_reset_time='||to_char(local_reset_time));
    ckp_type := RESYNC_NONE;
    GOTO ret;
  ELSIF (cf_version = local.cf_create_time) THEN
    deb('ckptNeeded - local_reset_scn='||local_reset_scn||
                    ' lopen_reset_scn='||lopen_reset_scn);
    deb('ckptNeeded - local_reset_time='||local_reset_time||
                    ' lopen_reset_time='||lopen_reset_time);
--
--
--
--
    IF (cf_type = CF_CURRENT AND
        (lopen_reset_scn IS NULL or local_reset_scn = lopen_reset_scn) AND
        (lopen_reset_time IS NULL or local_reset_time = lopen_reset_time)) THEN
 
      deb('ckptNeeded - high_pdb_recid='||to_char(high_pdb_recid)||
               ', local.high_pdb_recid='||to_char(local.high_pdb_recid));
      IF (high_pdb_recid > local.high_pdb_recid) THEN
        ckp_type := RESYNC_FULL;
        IF local.high_pdb_recid <= 0 THEN
           setReason(RESYNC_REASON_NOACTION);
        ELSE
           setReason(RESYNC_REASON_PDB);
        END IF;
        GOTO ret;
      ELSIF (high_pdb_recid < local.high_pdb_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
 
      deb('ckptNeeded - high_ts_recid='||to_char(high_ts_recid)||
               ', local.high_ts_recid='||to_char(local.high_ts_recid));
 
      IF (high_ts_recid > local.high_ts_recid) THEN
        ckp_type := RESYNC_FULL;
        IF local.high_ts_recid = 0 THEN
           setReason(RESYNC_REASON_NOACTION);
        ELSE
           setReason(RESYNC_REASON_TS);
        END IF;
        GOTO ret;
      ELSIF (high_ts_recid < local.high_ts_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
 
      deb('ckptNeeded - high_df_recid='||to_char(high_df_recid)||
               ', local.high_df_recid='||to_char(local.high_df_recid));
      IF (high_df_recid > local.high_df_recid) THEN
        ckp_type := RESYNC_FULL;
        setReason(RESYNC_REASON_DF);
        GOTO ret;
      ELSIF (high_df_recid < local.high_df_recid) THEN
--
--
--
--
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
 
      deb('ckptNeeded - high_tf_recid='||to_char(high_tf_recid)||
               ', local.high_tf_recid='||to_char(local.high_tf_recid));
      IF (high_tf_recid > local.high_tf_recid) THEN
        ckp_type := RESYNC_FULL;
        setReason(RESYNC_REASON_TF);
        GOTO ret;
      ELSIF (high_tf_recid < local.high_tf_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
 
      deb('ckptNeeded - high_rt_recid='||to_char(high_rt_recid)||
               ', local.high_rt_recid='||to_char(local.high_rt_recid));
      IF (high_rt_recid > local.high_rt_recid) THEN
        ckp_type := RESYNC_FULL;
        setReason(RESYNC_REASON_THR);
        GOTO ret;
      ELSIF (high_rt_recid < local.high_rt_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
 
      deb('ckptNeeded - high_orl_recid='||to_char(high_orl_recid)||
               ', local.high_orl_recid='||to_char(local.high_orl_recid));
      IF (high_orl_recid > local.high_orl_recid) THEN
        ckp_type := RESYNC_FULL;
        setReason(RESYNC_REASON_ORL);
        GOTO ret;
      ELSIF (high_orl_recid < local.high_orl_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
--
--
--
       deb('ckptNeeded - high_conf_recid='||high_conf_recid||
                     ', local.high_conf_recid='||local.high_conf_recid);
       deb('       local.force_resync2cf='||local.force_resync2cf);
      IF (high_conf_recid != local.high_conf_recid OR
          local.force_resync2cf = 'YES')
      THEN
         ckp_type := RESYNC_FULL;
         setReason(RESYNC_REASON_CONF);
         GOTO ret;
      END IF;
 
--
--
--
 
      deb('ckptNeeded - high_cdf_recid='||to_char(high_cdf_recid)||
               ', local.high_cdf_recid='||to_char(local.high_cdf_recid));
      IF (high_cdf_recid > local.high_cdf_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_cdf_recid < local.high_cdf_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_al_recid='||to_char(high_al_recid)||
               ', local.high_al_recid='||to_char(local.high_al_recid));
      IF (high_al_recid > local.high_al_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_al_recid < local.high_al_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_bp_recid='||to_char(high_bp_recid)||
               ', local.high_bp_recid='||to_char(local.high_bp_recid));
      IF (high_bp_recid > local.high_bp_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_bp_recid < local.high_bp_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_bs_recid='||to_char(high_bs_recid)||
               ', local.high_bs_recid='||to_char(local.high_bs_recid));
      IF (high_bs_recid > local.high_bs_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_bs_recid < local.high_bs_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_do_recid='||to_char(high_do_recid)||
               ', local.high_do_recid='||to_char(local.high_do_recid));
      IF (high_do_recid > local.high_do_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_do_recid < local.high_do_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_offr_recid='||to_char(high_offr_recid)||
               ', local.high_offr_recid='||to_char(local.high_offr_recid));
      IF (high_offr_recid > local.high_offr_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_offr_recid < local.high_offr_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_pc_recid='||to_char(high_pc_recid)||
               ', local.high_pc_recid='||to_char(local.high_pc_recid));
      IF (high_pc_recid > local.high_pc_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_pc_recid < local.high_pc_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_ic_recid='||to_char(high_ic_recid)||
               ', local.high_ic_recid='||to_char(local.high_ic_recid));
      IF (high_ic_recid > local.high_ic_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_ic_recid < local.high_ic_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded: high_grsp_recid='||to_char(high_grsp_recid)||
                    ', local.high_grsp_recid='||to_char(local.high_grsp_recid));
      IF (high_grsp_recid > local.high_grsp_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_grsp_recid < local.high_grsp_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded: high_bcr_recid='||to_char(high_bcr_recid)||
                    ', local.high_bcr_recid='||to_char(local.high_bcr_recid));
      IF (high_bcr_recid > local.high_bcr_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_bcr_recid < local.high_bcr_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded: high_nrsp_recid='||to_char(high_nrsp_recid)||
                    ', local.high_nrsp_recid='||to_char(local.high_nrsp_recid));
      IF (high_nrsp_recid > local.high_nrsp_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_nrsp_recid < local.high_nrsp_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
      deb('ckptNeeded - high_pic_recid='||to_char(high_pic_recid)||
               ', local.high_pic_recid='||to_char(local.high_pic_recid));
      IF (high_pic_recid > local.high_pic_recid) THEN
        ckp_type := RESYNC_PARTIAL;
        GOTO ret;
      ELSIF (high_pic_recid < local.high_pic_recid) THEN
        raise_application_error(-20035, 'Invalid high recid');
      END IF;
    ELSE
--
      IF (cksum = last_resync_cksum AND kccdivts = date2stamp(cf_version)) THEN
         deb('ckptNeeded - resync checksum same as last checksum');
         ckp_type := RESYNC_NONE;
      ELSE
         ckp_type := RESYNC_PARTIAL;
         last_resync_cksum := cksum;
      END IF;
    END IF;
  ELSE
--
--
--
--
    IF (cf_type = CF_CURRENT) THEN
      deb('ckptNeeded - cf_type = CF_CURRENT');
      ckp_type := RESYNC_FULL;
      setReason(RESYNC_REASON_CF);
    ELSE
      deb('ckptNeeded - cf_type != CF_CURRENT');
      IF (cksum = last_resync_cksum AND kccdivts = date2stamp(cf_version)) THEN
         deb('ckptNeeded - resync checksum same as last checksum');
         ckp_type := RESYNC_NONE;
      ELSE
         ckp_type := RESYNC_PARTIAL;
         last_resync_cksum := cksum;
      END IF;
    END IF;
  END IF;
 
<<ret>>
--
--
--
--
--
--
  IF (ckp_type = RESYNC_PARTIAL AND
      cf_version = local.cf_create_time AND
      ckp_cf_seq = greatest(local.job_ckp_cf_seq, local.full_ckp_cf_seq)) THEN
     deb('ckptNeeded - cf_seq has not advanced - do not need a resync');
     deb('ckptNeeded - ' || ckp_cf_seq || ',' || local.job_ckp_cf_seq ||
                     ',' || local.full_ckp_cf_seq);
     ckp_type := RESYNC_NONE;
  END IF;
 
--
  IF (ckp_type = RESYNC_NONE) THEN
    deb('ckptNeeded - resync not needed, rollback, release locks');
    rollback;
  END IF;
 
  select decode(ckp_type, RESYNC_NONE, 'RESYNC_NONE',
                          RESYNC_PARTIAL, 'RESYNC_PARTIAL',
                          RESYNC_FULL, 'RESYNC_FULL',
                          'UNKNOWN') into ckp_desc from dual;
  deb('ckptNeeded - resync type is ' || ckp_desc);
  deb('ckptNeeded - returning ckp_type=' ||ckp_type);
  RETURN ckp_type;
 
--
EXCEPTION
  WHEN OTHERS THEN
    deb('ckptNeeded - error, rollback, release locks');
    rollback;
    RAISE;
END ckptNeeded;
 
PROCEDURE addTimeZone(
   db_unique_name IN VARCHAR2
  ,db_timezone    IN VARCHAR2
  ,tmz_src        IN VARCHAR2
  ,incarnations   IN VARCHAR2 default 'CURRENT'
)IS
prev_tmz        node.db_timezone%type;
prev_src        node.timezone_src%type;
l_db_key        NUMBER;
l_dbinc_key     NUMBER;
update_cur      NUMBER :=0;
comma_pos       NUMBER;
is_valid        NUMBER;
is_tmz_valid    VARCHAR2(7);
cur_dbinc       NUMBER;
tail_dbinc      VARCHAR2(256);
invalid_keys    VARCHAR2(256);
l_invalid_val   VARCHAR2(256);
l_err_no        CONSTANT NUMBER := -20244; -- modify in upate_db
--
tmz_err         EXCEPTION;
PRAGMA EXCEPTION_INIT(tmz_err, -20244);
BEGIN
--
--
--
  IF tmz_src = 'P' OR tmz_src = 'A'
  THEN
    BEGIN
      select tz_offset(db_timezone)
        into is_tmz_valid
      from dual;
   EXCEPTION
      when others THEN
        l_invalid_val := 'timezone - ' || db_timezone; 
        RAISE tmz_err;
   END;
  END IF;
 
--
  IF tmz_src = 'R'        -- db_key already available during resync
  THEN
    l_db_key := this_db_key;
    select db_timezone, timezone_src
      into prev_tmz, prev_src
      from node
    where node.db_unique_name = upper(addTimeZone.db_unique_name)
      AND db_key = l_db_key;
  ELSE                   -- need to fetch db_key
    select db_key, db_timezone, timezone_src
      into l_db_key, prev_tmz, prev_src
      from node
    where node.db_unique_name = upper(addTimeZone.db_unique_name);
  END IF;
 
--
  select dbinc_key 
    into l_dbinc_key
    from dbinc
   where db_key = l_db_key
     AND dbinc_status = 'CURRENT';
 
--
  IF incarnations != 'CURRENT'
  THEN
--
    is_valid := LENGTH(TRIM(TRANSLATE(incarnations, 
                                       ',0123456789', ' '))); 
    IF is_valid IS NOT NULL
    THEN
      l_invalid_val := 'incarnations - ' || incarnations;
      RAISE tmz_err;
    END IF;
 
    tail_dbinc := incarnations;
    IF LENGTH(TRIM(tail_dbinc)) > 0
    THEN
      LOOP
        comma_pos := instr(tail_dbinc, ',');
        IF comma_pos = 0
        THEN
          cur_dbinc := TO_NUMBER(TRIM(tail_dbinc));
          tail_dbinc := NULL;
        ELSE
          cur_dbinc := TO_NUMBER(TRIM(substr(tail_dbinc,1, comma_pos-1)));
          tail_dbinc := substr(tail_dbinc, comma_pos+1);
        END IF;
 
--
        IF l_dbinc_key = cur_dbinc
        THEN
          update_cur := 1;
        END IF;
 
        IF cur_dbinc IS NOT NULL
        THEN
          select count(*)
            into is_valid
            from dbinc
           where db_key = l_db_key
             AND dbinc_key = cur_dbinc;
 
          IF is_valid = 0
          THEN
            IF invalid_keys is NULL
            THEN
              invalid_keys := cur_dbinc;
            ELSE
              invalid_keys := invalid_keys || ',' || cur_dbinc;
            END IF;
          END IF;
        END IF;
        
        EXIT WHEN tail_dbinc IS NULL;
      END LOOP;
    END IF;
  END IF;
 
--
  IF invalid_keys IS NOT NULL
  THEN
      l_invalid_val := 'invalid keys in incarnations - '
                                          || invalid_keys;
      RAISE tmz_err;
  END IF;
 
--
--
  IF (prev_src IS NULL AND (update_cur = 1 OR 
                              incarnations = 'CURRENT')) OR
     (                         --no need to re-update
      NOT(prev_src = tmz_src AND prev_tmz = db_timezone)  AND 
      (
       (tmz_src = 'P') OR      -- update if coming from parameter file
--
       (tmz_src = 'A' AND prev_src IN ('A', 'S', 'R') AND (update_cur=1
                                         OR incarnations = 'CURRENT')) OR
--
--
--
       (tmz_src = 'S' AND prev_src IN ('S', 'P', 'R')) OR
--
--
       (tmz_src = 'R' AND prev_src = 'R')
       )
      )
  THEN
    UPDATE node
       SET node.db_timezone = addTimeZone.db_timezone,
           timezone_src = tmz_src
     WHERE node.db_unique_name
              = upper(addTimeZone.db_unique_name)
      AND db_key = l_db_key;      -- could be from resync
 
    UPDATE dbinc
       SET dbinc_timezone = db_timezone
     WHERE db_key = l_db_key
      AND dbinc_status = 'CURRENT';
 
--
    IF tmz_src = 'A'
    THEN
      update_cur := 2;
    END IF;
  END IF;
 
--
  IF incarnations != 'CURRENT'
  THEN
--
    IF update_cur = 1 AND      -- did not allow
--
       NOT(prev_src = tmz_src AND prev_tmz = db_timezone)
    THEN
      l_invalid_val := 'Current incarnation cannot be updated';
      RAISE tmz_err;
    ELSE
      tail_dbinc := incarnations;
      IF NVL(LENGTH(TRIM(tail_dbinc)),0) > 0
      THEN
        LOOP
          comma_pos := NVL(instr(tail_dbinc, ','),0);
          IF comma_pos = 0
          THEN
            cur_dbinc := TO_NUMBER(TRIM(tail_dbinc));
            tail_dbinc := NULL;
          ELSE
            cur_dbinc := TO_NUMBER(TRIM(substr(tail_dbinc,1, comma_pos-1)));
            tail_dbinc := substr(tail_dbinc, comma_pos+1);
          END IF; 
 
          IF cur_dbinc != l_dbinc_key   -- also checks cur_dbinc is null
          THEN
            UPDATE dbinc
               SET dbinc_timezone = db_timezone
             WHERE dbinc_key = cur_dbinc
               AND db_key = l_db_key;
          END IF;
        
          EXIT WHEN tail_dbinc IS NULL;
        END LOOP;
      END IF;
    END IF;
  END IF;
  commitChanges('addTimeZone');
EXCEPTION
  WHEN tmz_err THEN
       deb(l_invalid_val);
       raise_application_error(l_err_no, l_invalid_val);
  WHEN OTHERS THEN
       deb('Error in addTimeZone, release locks');
       ROLLBACK;
       RAISE;
END addTimeZone;
 
 
PROCEDURE beginCkpt(
  ckp_scn       IN NUMBER
 ,ckp_cf_seq    IN NUMBER
 ,cf_version    IN DATE
 ,ckp_time      IN DATE
 ,ckp_type      IN VARCHAR2
 ,ckp_db_status IN VARCHAR2
 ,high_df_recid IN NUMBER
 ,cf_type       IN VARCHAR2 DEFAULT 'CURRENT'   -- for compatibility reasons
) IS
 
local      ckp%rowtype;
node_count NUMBER;
db_role    node.database_role%type;
local_dbid NUMBER;
local_reset_watermarks boolean := TRUE;
BEGIN
  IF (this_ckp_key IS NOT NULL) THEN
    raise_application_error(-20030, 'Resync in progress');
  END IF;
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
  IF (this_site_key IS NULL) THEN
    raise_application_error(-20199, 'Site key is not set');
  END IF;
  IF (cf_type != 'CURRENT' AND ckp_type = 'FULL') THEN
    raise_application_error(-20072, 'full resync from noncurrent controlfile');
  END IF;
 
 
  clearResyncActions;
 
  deb('beginCkpt - ckp_type = '||ckp_type||', cf_type ='||cf_type ||
      ', ckp_scn =' || ckp_scn || ', site_key = ' || this_site_key);
 
--
  SELECT db_id INTO local_dbid FROM db
  WHERE db_key = this_db_key FOR UPDATE OF db.db_key;
 
  deb('beginCkpt - Obtained all locks for db '|| to_char(this_db_key));
 
--
--
--
--
--
--
--
--
  kccdivts := date2stamp(cf_version);           -- save in pkg global
 
--
  SELECT ckp_scn, cf_create_time,
         decode(beginCkpt.ckp_type, 'FULL', full_ckp_cf_seq,
                greatest(job_ckp_cf_seq, full_ckp_cf_seq)), dbinc_key
  INTO local.ckp_scn, local.cf_create_time, local.ckp_cf_seq, local.dbinc_key
  FROM node
  WHERE site_key = this_site_key;
 
--
  last_cf_version_time := local.cf_create_time;
 
--
  SELECT max(ckp_key)
    INTO local.ckp_key
    FROM ckp
    WHERE dbinc_key = this_dbinc_key;
 
  IF (local.ckp_key IS NULL) THEN
    deb('beginCkpt - first checkpoint for this incarnation '|| this_dbinc_key);
    local_reset_watermarks := TRUE;
  ELSIF (cf_type = 'CURRENT' OR
         (cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
--
--
--
--
--
--
    IF (ckp_type = 'FULL' AND this_dbinc_key = local.dbinc_key) THEN
      IF  (ckp_scn < local.ckp_scn) THEN
        deb('beginCkpt - cf scn='||ckp_scn||',catalog cf scn='||local.ckp_scn);
        raise_application_error(-20032, 'Invalid checkpoint SCN');
      ELSIF (ckp_scn = local.ckp_scn AND ckp_cf_seq < local.ckp_cf_seq) THEN
        deb('beginCkpt - cf seq='||ckp_cf_seq||',catalog cf seq='||
            local.ckp_cf_seq);
        raise_application_error(-20033, 'Invalid checkpoint cf seq#');
      ELSIF (ckp_scn = local.ckp_scn AND ckp_cf_seq = local.ckp_cf_seq) THEN
        raise_application_error(-20034, 'Resync not needed');
      END IF;
    END IF;
 
    deb('beginCkpt:last_cf_version' || local.cf_create_time);
    deb('beginCkpt:cf_version' || cf_version);
 
    IF (cf_version = local.cf_create_time) THEN
      deb('beginCkpt - Resync from same last control file');
--
--
--
--
--
      IF (ckp_cf_seq < local.ckp_cf_seq AND
          this_dbinc_key = local.dbinc_key) THEN
        deb('beginCkpt - cf seq='||ckp_cf_seq||',catalog cf seq='||
            local.ckp_cf_seq);
        raise_application_error(-20033, 'Invalid checkpoint cf seq#');
      ELSIF (ckp_cf_seq = local.ckp_cf_seq AND
             this_dbinc_key = local.dbinc_key) THEN
        raise_application_error(-20034, 'Resync not needed');
      END IF;
 
      local_reset_watermarks := FALSE;
    ELSE
      deb('beginCkpt - Resync from different control file');
      local_reset_watermarks := TRUE;
    END IF;
  ELSE
--
--
    IF (ckp_db_status = 'BACKUP') THEN
       deb('beginCkpt - Resync from control file copy');
       local_reset_watermarks := TRUE;
    ELSE
--
--
       IF (kccdivts = sessionWaterMarks.last_kccdivts) THEN
          deb('beginCkpt - Resync from same backup control file');
          local_reset_watermarks := FALSE;
       ELSE
          deb('beginCkpt - Resync from different backup control file');
          local_reset_watermarks := TRUE;
       END IF;
    END IF;
  END IF;
 
  IF (local_reset_watermarks) THEN
     deb('beginCkpt - init session watermarks');
     sessionWaterMarks := init_sessionWaterMarks;
     sessionWaterMarks.last_kccdivts := kccdivts;
  END IF;
 
--
--
  IF (cf_type = 'CURRENT' OR cf_type = 'CREATED' OR 
      (cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
    IF NOT local_reset_watermarks THEN
       deb('beginCkpt - update ckp_scn and use existing water marks');
--
       UPDATE node SET
         ckp_scn =
           greatest(ckp_scn,
             decode(beginCkpt.ckp_type, 'FULL', beginCkpt.ckp_scn, 0)),
         full_ckp_cf_seq =
           greatest(full_ckp_cf_seq,
             decode(beginCkpt.ckp_type, 'FULL', beginCkpt.ckp_cf_seq, 0)),
         job_ckp_cf_seq =
           greatest(job_ckp_cf_seq,
             decode(beginCkpt.ckp_type, 'PARTIAL', beginCkpt.ckp_cf_seq, 0)),
         bcr_in_use = nvl2(high_bcr_recid, 'YES', 'NO')
       WHERE site_key = this_site_key;
    ELSE
--
--
--
--
--
--
--
--
--
--
--
       deb('beginCkpt - update ckp_scn and reset water marks, this_site_key '||
           this_site_key);
       UPDATE node SET
         cf_create_time = beginCkpt.cf_version,
         dbinc_key = this_dbinc_key,
         ckp_scn =
           decode(beginCkpt.ckp_type, 'FULL', beginCkpt.ckp_scn, 0),
         full_ckp_cf_seq =
           decode(beginCkpt.ckp_type, 'FULL', beginCkpt.ckp_cf_seq, 0),
         job_ckp_cf_seq =
           decode(beginCkpt.ckp_type, 'PARTIAL', beginCkpt.ckp_cf_seq, 0),
         high_ic_recid = 0,  
         high_ts_recid = NULL,
         high_df_recid = NULL,
         high_rt_recid = NULL,
         high_orl_recid = NULL,
         high_offr_recid = 0,
         high_rlh_recid = 0,
         high_al_recid = 0,
         high_bs_recid = 0,
         high_bp_recid = 0,
         high_bdf_recid = 0,
         high_cdf_recid = 0,
         high_brl_recid = 0,
         high_bcb_recid = 0,
         high_ccb_recid = 0,
         high_do_recid = 0,
         high_pc_recid = 0,
         high_bsf_recid = 0,
         high_rsr_recid = 0,
         high_tf_recid = 0,
         high_grsp_recid = 0,
         high_nrsp_recid = 0,
         high_bcr_recid = 0,
         bcr_in_use = nvl2(high_bcr_recid, 'YES', 'NO'),
         high_pdb_recid = NULL,
         high_pic_recid = 0
       WHERE site_key = this_site_key;
    END IF;
  ELSE
--
     UPDATE node SET
       cf_create_time = beginCkpt.cf_version,
       dbinc_key = this_dbinc_key,
       ckp_scn =
         decode(beginCkpt.ckp_type, 'FULL', beginCkpt.ckp_scn, 0),
       full_ckp_cf_seq =
         decode(beginCkpt.ckp_type, 'FULL', beginCkpt.ckp_cf_seq, 0),
       job_ckp_cf_seq =
         decode(beginCkpt.ckp_type, 'PARTIAL', beginCkpt.ckp_cf_seq, 0),
       bcr_in_use = nvl2(high_bcr_recid, 'YES', 'NO')
     WHERE site_key = this_site_key;
  END IF;
 
  SELECT max(ckp_scn) INTO last_full_ckp_scn
    FROM ckp 
   WHERE ckp_type = 'FULL'
     AND dbinc_key = this_dbinc_key;
  deb('beginCkpt - last_full_ckp_scn ' || last_full_ckp_scn);
 
--
  BEGIN
    INSERT INTO ckp
       (ckp_key, ckp_scn, ckp_cf_seq, cf_create_time, ckp_time,
        dbinc_key, ckp_type, ckp_db_status, resync_time, site_key)
    VALUES
       (rman_seq.nextval, ckp_scn, ckp_cf_seq, cf_version, ckp_time,
        this_dbinc_key, beginCkpt.ckp_type, ckp_db_status, sysdate,
        this_site_key)
    RETURNING ckp_key INTO this_ckp_key;
  EXCEPTION
    WHEN dup_val_on_index THEN
      IF (cf_type = 'CURRENT' OR 
          (cf_type = 'STANDBY' AND this_db_unique_name IS NOT NULL)) THEN
        RAISE;
      ELSE
--
--
--
--
--
--
        raise_application_error(-20034, 'Resync not needed');
      END IF;
  END;
 
  SELECT count(*) INTO  node_count
  FROM   node
  WHERE  node.db_key = this_db_key AND
         node.db_unique_name = this_db_unique_name;
 
  IF (node_count = 0 AND this_db_unique_name IS NOT NULL) THEN
     IF substr(this_db_unique_name,1,1) = '$' THEN
        db_role := 'RA';
     ELSE
        IF (cf_type = 'STANDBY') THEN
           db_role := 'STANDBY';
        ELSE
           db_role := 'PRIMARY';
        END IF;
     END IF;
     deb('beginCkpt - adding node row with force_resync2cf=NO' ||
         ', db_unique_name = ' || this_db_unique_name ||
         ', db_role = ' || db_role);
     INSERT INTO node(db_unique_name,      db_key,      high_conf_recid,
                      force_resync2cf,     database_role, site_key)
               VALUES(this_db_unique_name, this_db_key, 0,
                      'NO',                db_role,       rman_seq.nextval);
  END IF;
  this_ckp_scn := ckp_scn;
  this_ckp_time := ckp_time;
  this_cf_type := cf_type;
  this_cf_version := cf_version;
  this_ckp_type := ckp_type;
  deb('beginCkpt:this_cf_type' || this_cf_type);
  deb('beginCkpt:this_cf_version' || this_cf_version);
  deb('beginCkpt: clearing watermark indexes');
 
--
--
  select rman_seq.currval into this_bp_key_poll from dual;
  getPolled_AL := TRUE;
  IF feedback_al%ISOPEN THEN CLOSE feedback_al; END IF;
  IF feedback_bp%ISOPEN THEN CLOSE feedback_bp; END IF;
  
  IF this_is_ors THEN
     this_enable_populate_rsr := getValueFromConfig('_enable_populate_rsr_key');
  END IF;
--
EXCEPTION
  WHEN OTHERS THEN
    deb('beginCkpt - error, rollback, release locks');
    rollback;
    RAISE;
 
END beginCkpt;
 
 
PROCEDURE clearCursorVariables IS
 
BEGIN
  pdbRec.guid := NULL;
  picRec.guid := NULL;
  tsRec.ts# := NULL;
  dfRec.file# := NULL;
  tfRec.file# := NULL;
  rtRec.thread# := NULL;
  orlRec.fname := NULL;
  grspRec.rspname := NULL;
 
END clearCursorVariables;
 
 
PROCEDURE endCkpt IS
 
BEGIN
 
  deb('endCkpt:Updating watermarks for backup related columns');
  deb('endCkpt:this_curr_bp_recid=' || this_curr_bp_recid);
  deb('endCkpt:this_high_bp_recid=' || this_high_bp_recid);
  IF this_curr_bp_recid <> this_high_bp_recid THEN
     UPDATE watermarks SET high_bp_recid  = this_high_bp_recid
     WHERE db_key = this_db_key;
  END IF;
--
  IF this_ckp_type = 'FULL' THEN
     deb('endCkpt:this_cf_version updated=' || this_cf_version);
     UPDATE watermarks SET cf_version_stamp = this_cf_version
     WHERE db_key = this_db_key;
  END IF;
 
--
--
  this_enable_populate_rsr := NULL;
  this_upstream_site_key := NULL;
--
  IF this_lock_ors_inspect THEN
    this_ckp_key := NULL;                 -- and update state variable
    this_ckp_scn := NULL;
    this_ckp_time := NULL;
    this_cf_type := NULL;
    this_cf_version := NULL;
    last_cf_version_time := NULL;
    this_ckp_type := NULL;
    commitChanges('endCkpt-1');
  ELSE
    checkResync;
 
    IF (tsRec.ts# IS NOT NULL) THEN
      raise_application_error(-20041, 'Tablespace resync not completed');
    END IF;
    IF (dfRec.file# IS NOT NULL) THEN
      raise_application_error(-20051, 'Datafile resync not completed');
    END IF;
 
    this_ckp_key := NULL;                 -- and update state variable
    this_ckp_scn := NULL;
    this_ckp_time := NULL;
    this_cf_type := NULL;
    this_cf_version := NULL;
    last_cf_version_time := NULL;
    this_ckp_type := NULL;
 
--
    clearCursorVariables;   
 
--
--
--
    IF this_clr_ba_newinc_err AND this_is_ors THEN
       deb('endckpt:fix_error for db_key = '||this_db_key);
--
--
--
       EXECUTE IMMEDIATE
        'BEGIN dbms_rai_fix_error(
          error_num => -64735);
         END;' ;
       this_clr_ba_newinc_err := FALSE;
    END IF;
    commitChanges('endCkpt-2');
 
    prev_sessionWaterMarks := sessionWaterMarks;
 
    /* Do not run cleanupTempResource when connected to a virtual catalog,
     * because we do not allow merging catalogs to be done by a virtual
     * catalog user. The cleanuopTempResource executes DDLs that will
     * automatically commit and release locks */
    if user = g_catowner then
      cleanupTempResource;
    end if;
  END IF;
 
END endCkpt;
 
 
PROCEDURE cancelCkpt IS
 
BEGIN
  deb('cancelCkpt - rollback, release locks');
  rollback;
 
--
--
  this_enable_populate_rsr := NULL;
  this_upstream_site_key := NULL;
--
--
  IF this_lock_ors_inspect THEN
     return;
  END IF;
 
  sessionWaterMarks := prev_sessionWaterMarks;
 
  IF (this_ckp_key IS NOT NULL) THEN
--
    this_ckp_key := NULL;
    this_ckp_scn := NULL;
    this_ckp_time := NULL;
  END IF;
  IF pdbQ%ISOPEN     THEN CLOSE pdbQ;   END IF;
  IF picQ%ISOPEN     THEN CLOSE picQ;   END IF;
  IF tsQ%ISOPEN      THEN CLOSE tsQ;    END IF;
  IF dfQ%ISOPEN      THEN CLOSE dfQ;    END IF;
  IF tfQ%ISOPEN      THEN CLOSE tfQ;    END IF;
  IF rtQ%ISOPEN      THEN CLOSE rtQ;    END IF;
  IF orlQ%ISOPEN     THEN CLOSE orlQ;   END IF;
  IF grspQ%ISOPEN    THEN CLOSE grspQ;  END IF;
  IF bpq%ISOPEN      THEN CLOSE bpq;    END IF;
  IF feedback_al%ISOPEN THEN CLOSE feedback_al; END IF;
  IF feedback_bp%ISOPEN THEN CLOSE feedback_bp; END IF;
  
--
  clearCursorVariables;   
 
--
  last_resync_cksum := NULL;
END cancelCkpt;
 
--
--
FUNCTION lastFullCkpt RETURN NUMBER IS
BEGIN
   RETURN last_full_ckp_scn;
END lastFullCkpt;
 
/* Feedback about files polled by OAM */
FUNCTION getPolledAl (rec_type OUT NUMBER,
                      recid    OUT NUMBER,
                      stamp    OUT NUMBER,
                      fname    OUT VARCHAR2) RETURN BOOLEAN IS
   al_rec       feedback_al%ROWTYPE;
BEGIN
 
   IF NOT feedback_al%ISOPEN THEN 
      deb('getPolledAl - open feedback_al, bp_key_poll=' || curr_bp_key_poll);
      OPEN feedback_al(curr_bp_key_poll);
   END IF;
 
   FETCH feedback_al INTO al_rec;
 
   IF feedback_al%NOTFOUND THEN
      CLOSE feedback_al;
      deb('getPolledAl - closing feedback_al');
      RETURN FALSE;
   ELSE
      deb('getPolledAl - recid='||al_rec.recid||',stamp='||al_rec.stamp);
      deb('getPolledAl - fname='||al_rec.fname);
      rec_type := RTYP_ARCHIVED_LOG;
      recid    := al_rec.recid;
      stamp    := al_rec.stamp;
      fname    := al_rec.fname;
      RETURN TRUE;
   END IF;
 
END getPolledAl;
 
FUNCTION haveProcessedBS (disk_bs_key IN NUMBER) RETURN BOOLEAN IS
   to_process NUMBER;
BEGIN
   deb('haveProcessedBS - disk_bs_key='||disk_bs_key);
 
--
--
   to_process := 0;
   FOR cur_rec IN
      (SELECT file#, create_scn, ckp_scn, dbinc_key 
          FROM bdf where bs_key=disk_bs_key
       MINUS 
       SELECT a.file#, a.create_scn, a.ckp_scn, a.dbinc_key
          FROM bdf a, 
              (SELECT bs_key, file#, create_scn, ckp_scn, dbinc_key
                  FROM bdf 
                  WHERE bs_key=disk_bs_key) b
          WHERE b.file#=a.file# 
            AND b.create_scn=a.create_scn 
            AND b.ckp_scn=a.ckp_scn 
            AND b.dbinc_key=a.dbinc_key 
            AND b.bs_key <> a.bs_key
            AND a.bs_key IN
                (SELECT bs_key FROM bp 
                    WHERE handle like 'VB$%' 
                      AND db_key = this_db_key 
                      AND bp_key > curr_bp_key_poll))
   LOOP
      to_process := to_process + 1;
      deb('haveProcessedBS - not processed file#='||cur_rec.file#||
          ',create_scn='||cur_rec.create_scn||
          ',ckp_scn='||cur_rec.ckp_scn||
          ',dbinc_key='||cur_rec.dbinc_key);
   END LOOP;
   IF to_process = 0 THEN
      deb('haveProcessedBS - Disk backupset processed by OAM');
      return TRUE;
   END IF;
 
   return FALSE;
END haveProcessedBS;
 
FUNCTION getPolledBP (rec_type OUT NUMBER,
                      recid    OUT NUMBER,
                      stamp    OUT NUMBER,
                      fname    OUT VARCHAR2) RETURN BOOLEAN IS
   to_process   NUMBER;
   bp_rec       feedback_bp%ROWTYPE;
 
BEGIN
 
   IF NOT feedback_bp%ISOPEN THEN 
      deb('getPolledBP - open feedback_bp, bp_key_poll=' || curr_bp_key_poll);
      OPEN feedback_bp(curr_bp_key_poll);
   END IF;
 
   IF disk_bp_rec.bs_key is NOT NULL THEN
      deb('getPolledBP - have cached disk piece = '||disk_bp_rec.handle);
      IF haveProcessedBS(disk_bp_rec.bs_key) THEN
         rec_type := RTYP_BACKUP_PIECE;
         recid    := disk_bp_rec.recid;
         stamp    := disk_bp_rec.stamp;
         fname    := disk_bp_rec.handle;
         disk_bp_rec := null;
         deb('getPolledBP - Purgable');
         RETURN TRUE;
      ELSE
         disk_bp_rec := null;
         deb('getPolledBP - Not purgable');
      END IF;
   END IF;
 
<<get_next_rec>>
 
   FETCH feedback_bp INTO bp_rec;
 
   IF feedback_bp%NOTFOUND THEN
      CLOSE feedback_bp;
      deb('getPolledBP - closing feedback_bp');
      RETURN FALSE;
   ELSE
 
      deb('getPolledBP - bs_key='||bp_rec.bs_key||',piece#='||bp_rec.piece#||
       ',device_type='||bp_rec.device_type||',ba_access='||bp_rec.ba_access);
      deb('getPolledBP - recid='||bp_rec.recid||',stamp='||bp_rec.stamp||
         ',site_key='||bp_rec.site_key);
      deb('getPolledBP - handle='||bp_rec.handle);
 
      IF disk_bp_rec.bs_key is NULL AND
         bp_rec.device_type = 'DISK' THEN
         disk_bp_rec := bp_rec;
         deb('getPolledBP - fetch next; Chk disk piece=' ||disk_bp_rec.handle);
         goto get_next_rec;
      END IF;
 
      IF disk_bp_rec.bs_key is NULL THEN
         deb('getPolledBP - fetch next; No disk piece to check');
         goto get_next_rec;
      END IF;
 
      IF bp_rec.device_type = 'SBT_TAPE' AND
         bp_rec.bs_key = disk_bp_rec.bs_key AND
         bp_rec.piece# = disk_bp_rec.piece#  THEN
 
--
--
         IF bp_rec.ba_access = 'L' OR bp_rec.ba_access = 'T' THEN
            rec_type := RTYP_BACKUP_PIECE;
            recid    := disk_bp_rec.recid;
            stamp    := disk_bp_rec.stamp;
            fname    := disk_bp_rec.handle;
            disk_bp_rec := null;
            deb('getPolledBP - Disk backuppiece copied by OAM');
            RETURN TRUE;
--
--
--
         ELSIF bp_rec.ba_access = 'D' AND
               haveProcessedBS(disk_bp_rec.bs_key) THEN
            rec_type := RTYP_BACKUP_PIECE;
            recid    := disk_bp_rec.recid;
            stamp    := disk_bp_rec.stamp;
            fname    := disk_bp_rec.handle;
            disk_bp_rec := null;
            deb('getPolledBP - Polled Disk backuppiece processed');
            RETURN TRUE;
         END IF;
      ELSE
--
--
         IF haveProcessedBS(disk_bp_rec.bs_key) THEN
            rec_type := RTYP_BACKUP_PIECE;
            recid    := disk_bp_rec.recid;
            stamp    := disk_bp_rec.stamp;
            fname    := disk_bp_rec.handle;
            IF bp_rec.device_type = 'DISK' THEN
               disk_bp_rec := bp_rec;    -- save for next call, to avoid fetch
            ELSE
               disk_bp_rec := null;
            END IF;
            return TRUE;
         ELSE
            deb('getPolledBP - Disk backuppiece not processed - check next');
            IF bp_rec.device_type = 'DISK' THEN
               disk_bp_rec := bp_rec;    -- save for next call, to avoid fetch
            ELSE
               disk_bp_rec := null;
            END IF;
         END IF;
      END IF;
      deb('getPolledBP - fetch next');
      goto get_next_rec;
   END IF;
 
 
END getPolledBP;
 
FUNCTION getPolledRec(rec_type OUT NUMBER,
                      recid    OUT NUMBER,
                      stamp    OUT NUMBER,
                      fname    OUT VARCHAR2) RETURN BOOLEAN IS
BEGIN
 
--
--
   IF NOT (this_is_ors AND
           (this_cf_type = 'CURRENT' OR
            (this_cf_type = 'STANDBY' and this_db_unique_name is not null)))
                                                                          THEN
      RETURN FALSE;
   END IF;
 
   SELECT bp_key_poll into curr_bp_key_poll 
      FROM node
      WHERE site_key = this_site_key;
 
   IF getPolled_AL THEN
      IF (getPolledAL(rec_type, recid, stamp, fname)) THEN
         RETURN TRUE;
      ELSE
         getPolled_BP := TRUE;
         getPolled_AL := FALSE;
      END IF;
   END IF;
 
   IF getPolled_BP THEN
      IF (getPolledBP(rec_type, recid, stamp, fname)) THEN
         RETURN TRUE;
      END IF;
   END IF;
 
--
--
   deb('getPolledRec - Polling bp_key='||this_bp_key_poll);
   getPolled_BP := FALSE;
   getPolled_AL := FALSE;
 
   RETURN FALSE;
 
END getPolledRec;
 
/*---------------------*
 * Pluggable DB Resync *
 *---------------------*/
PROCEDURE fetchPdb IS                   -- this is private to the pkg body
 
BEGIN
  FETCH pdbQ INTO pdbRec;               -- get next row
  IF pdbQ%NOTFOUND THEN
    pdbRec.guid := NULL;                -- indicate end of fetch
    CLOSE pdbQ;
  ELSE
    deb('fetchPdb - '||pdbRec.name||' ('||to_char(pdbRec.con_id)||') '||
        to_char(pdbRec.guid));
  END IF;
END fetchPdb;
 
PROCEDURE addPdb(
   name       IN VARCHAR2
  ,con_id     IN NUMBER
  ,db_id      IN NUMBER
  ,create_scn IN NUMBER
  ,guid       IN RAW
  ,nobackup   IN VARCHAR2) IS
  local pdb%rowtype;
BEGIN
  deb('addPdb - db_id '|| to_char(db_id));
 
  INSERT INTO pdb
    (pdb_key, db_key, name, con_id, db_id, create_scn, guid, nobackup)
  VALUES
    (rman_seq.nextval, this_db_key, name, con_id, db_id, create_scn, guid,
     nobackup);
END addPdb;
 
PROCEDURE dropPdb(                       -- private to package body
  pdb_key    IN NUMBER
 ,drop_scn   IN NUMBER
 ,drop_time  IN DATE
) IS
 
BEGIN
  deb('dropPdb - pdb_key ' || to_char(pdb_key));
 
  UPDATE pdb_dbinc SET
         drop_scn  = dropPdb.drop_scn,
         drop_time = dropPdb.drop_time
   WHERE pdb_dbinc.dbinc_key = this_dbinc_key
     AND pdb_dbinc.pdb_key   = dropPdb.pdb_key
     AND pdb_dbinc.drop_scn IS NULL;
END dropPdb;
 
FUNCTION beginPluggableDBResync(
  high_pdb_recid IN NUMBER)
RETURN BOOLEAN IS
 
BEGIN
 
  checkResync;
 
--
--
--
--
--
  
  SELECT high_pdb_recid INTO last_pdb_recid
  FROM node  
  WHERE site_key = this_site_key;
 
  IF (high_pdb_recid = last_pdb_recid) THEN
    deb('beginPluggableDBResync - Resync of PDBs not needed');
    RETURN FALSE;
  ELSIF (high_pdb_recid > last_pdb_recid OR last_pdb_recid IS NULL) THEN
    deb('beginPluggableDBResync - Catalog pdb_recid: '|| last_pdb_recid);
    deb('beginPluggableDBResync - High pdb_recid: '|| high_pdb_recid);
    last_pdb_recid := high_pdb_recid;
  
    OPEN pdbQ;                          -- just open that cursor please
    fetchPdb;                           -- do priming read
    last_guid := NULL;                  -- initialize for ordering assert
 
    if resync_reason = RESYNC_REASON_PDB then
      fullResyncAction.active  := TRUE;
      fullResyncAction.valid   := TRUE;
      fullResyncAction.objtype := RESYNC_OBJECT_PDB;
    else
      fullResyncAction.active  := FALSE;
    end if;
 
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
  
END beginPluggableDBResync;
 
PROCEDURE checkPluggableDB(
  name       IN VARCHAR2
 ,con_id     IN NUMBER
 ,db_id      IN NUMBER
 ,create_scn IN NUMBER
 ,guid       IN RAW
 ,nobackup   IN VARCHAR2 DEFAULT 'N'
) IS
   dbinc_key   number;
BEGIN
  IF (last_guid >= guid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  last_guid := guid;
 
  WHILE (guid > pdbRec.guid) LOOP
    dropPdb(pdbRec.pdb_key, this_ckp_scn, this_ckp_time);
    incResyncActions(RESYNC_ACTION_DROP, pdbRec.con_id, pdbRec.name);
    fetchPdb;
  END LOOP;
 
  IF (guid < pdbRec.guid OR pdbRec.guid IS NULL) THEN
    IF (con_id IN (1, 0)) THEN
       IF (guid != ZERO_GUID) THEN
          UPDATE pdb SET guid = checkPluggableDb.guid
           WHERE pdb.db_key = this_db_key
             AND pdb.con_id = checkPluggableDb.con_id;
       END IF;
    ELSE
--
       addPdb(name, con_id, db_id, create_scn, guid, nobackup);
       incResyncActions(RESYNC_ACTION_ADD, con_id, name);
    END IF;
  ELSE -- (guid = pdbRec.guid)
--
    IF (pdbRec.con_id != con_id OR pdbRec.create_scn != create_scn) THEN
       deb('checkPluggableDb - drop and add new pdb');
       dropPdb(pdbRec.pdb_key, this_ckp_scn, this_ckp_time);
       UPDATE pdb
          SET name       = checkPluggableDB.name,
              con_id     = checkPluggableDB.con_id,
              create_scn = checkPluggableDB.create_scn,
              db_id      = checkPluggableDB.db_id,
              nobackup   = checkPluggableDB.nobackup
        WHERE pdb.pdb_key = pdbRec.pdb_key;
       incResyncActions(RESYNC_ACTION_RENAME, con_id, name);
    ELSIF (pdbRec.name != name OR pdbRec.nobackup != nobackup) THEN
       deb('checkPluggableDb - update name/nobackup');
       UPDATE pdb
          SET name     = checkPluggableDB.name,
              nobackup = checkPluggableDB.nobackup
        WHERE pdb.pdb_key = pdbRec.pdb_key;
       incResyncActions(RESYNC_ACTION_RENAME, con_id, name);
    ELSE
       deb('checkPluggableDb - pdb already known');
    END IF;
    fetchPdb;
  END IF;
END checkPluggableDB;
 
PROCEDURE endPluggableDBResync IS
 
BEGIN
  checkResync;
  WHILE (pdbRec.guid IS NOT NULL) LOOP   -- while extra tablespaces in rcvcat
     dropPdb(pdbRec.pdb_key, this_ckp_scn, this_ckp_time);
     incResyncActions(RESYNC_ACTION_DROP, pdbRec.con_id, pdbRec.name);
     fetchPdb;
  END LOOP;
 
--
  pdbRec.guid := NULL;
 
--
  UPDATE node SET high_pdb_recid = nvl(last_pdb_recid, high_pdb_recid)
  WHERE site_key = this_site_key;
 
  last_pdb_recid := NULL;
END endPluggableDBResync;
 
/*-------------------*
 * Tablespace Resync *
 *-------------------*/
 
PROCEDURE fetchTs IS                    -- this is private to the pkg body
 
BEGIN
  FETCH tsQ INTO tsRec;                 -- get next row
  IF tsQ%NOTFOUND THEN
    tsRec.con_id       := MAXNUMVAL;          -- indicate end of fetch
    tsRec.ts#          := MAXNUMVAL;
    tsRec.pdb_drop_scn := NULL;
    CLOSE tsQ;
  ELSE
    deb('fetchTs - '||tsRec.ts_name||' ('||to_char(tsRec.ts#)||') '||
        to_char(tsRec.create_scn) || ';plugin_scn='||to_char(tsRec.plugin_scn));    
  END IF;
END fetchTs;
 
PROCEDURE addTs(
  ts_name                     IN VARCHAR2
 ,ts#                         IN NUMBER
 ,create_scn                  IN NUMBER
 ,create_time                 IN DATE
 ,rbs_count                   IN NUMBER
 ,included_in_database_backup IN VARCHAR2
 ,bigfile                     IN VARCHAR2
 ,temporary                   IN VARCHAR2
 ,encrypt_in_backup           IN VARCHAR2
 ,plugin_scn                  IN NUMBER
 ,pdbinc_key                  IN NUMBER
) IS
BEGIN
  deb('addTs - tablespace '||ts_name||' ('||to_char(ts#)||') '||
      to_char(create_scn) || ',plugin_scn=' || to_char(plugin_scn));
  INSERT INTO ts
    (dbinc_key, ts#, ts_name, create_scn,
     create_time, included_in_database_backup, bigfile, temporary, 
     encrypt_in_backup, plugin_scn, pdbinc_key)
  VALUES
    (this_dbinc_key, ts#, ts_name, create_scn, create_time,
     included_in_database_backup, bigfile, temporary, encrypt_in_backup,
     plugin_scn, pdbinc_key);
 
  INSERT INTO tsatt
    (dbinc_key, ts#, create_scn, start_ckp_key, rbs_count, plugin_scn,
     pdbinc_key)
  VALUES 
    (this_dbinc_key, ts#, create_scn, this_ckp_key, rbs_count, plugin_scn,
     pdbinc_key);
 
END addTs;
 
PROCEDURE dropTs(                       -- private to package body
  ts#        IN NUMBER
 ,create_scn IN NUMBER
 ,drop_scn   IN NUMBER
 ,drop_time  IN DATE
 ,plugin_scn IN NUMBER
 ,pdbinc_key IN NUMBER
) IS
 
BEGIN
  deb('dropTs - tablespace '||to_char(ts#)||' - '||to_char(create_scn) ||
      ',plugin_scn - ' || plugin_scn);
  UPDATE ts SET
    drop_scn     = dropTs.drop_scn,
    drop_time    = dropTs.drop_time
  WHERE ts.dbinc_key  = this_dbinc_key
  AND   ts.pdbinc_key = dropTs.pdbinc_key
  AND   ts.ts#        = dropTs.ts#
  AND   ts.create_scn = dropTs.create_scn
  AND   ts.plugin_scn = dropTs.plugin_scn;
  deb('dropTs - returning');
END dropTs;
 
PROCEDURE renameTs(
  ts_name    IN VARCHAR2
 ,dbinc_key  IN NUMBER
 ,ts#        IN NUMBER
 ,create_scn IN NUMBER
 ,plugin_scn IN NUMBER
 ,pdbinc_key IN NUMBER
) IS
 
BEGIN
  UPDATE ts SET
     ts.ts_name = renameTs.ts_name
  WHERE ts.dbinc_key  = renameTs.dbinc_key
  AND   ts.pdbinc_key = renameTs.pdbinc_key
  AND   ts.ts#        = renameTs.ts#
  AND   ts.create_scn = renameTs.create_scn
  AND   ts.plugin_scn = renameTs.plugin_scn;
END renameTs;
 
FUNCTION beginTableSpaceResync(
  high_ts_recid IN NUMBER,
  force         IN BOOLEAN DEFAULT FALSE)
RETURN BOOLEAN IS
 
BEGIN
 
  checkResync;
 
--
--
 
--
--
--
--
--
 
  SELECT high_ts_recid INTO last_ts_recid
  FROM node
  WHERE site_key = this_site_key;
 
 
  IF (high_ts_recid = last_ts_recid AND NOT force) THEN
    deb('beginTableSpaceResync - Resync of tablespaces not needed');
    RETURN FALSE;
  ELSIF (high_ts_recid > last_ts_recid OR last_ts_recid IS NULL OR
         high_ts_recid IS NULL OR force) THEN
 
    deb('beginTableSpaceResync - Catalog ts_recid: '||last_ts_recid);
    deb('beginTableSpaceResync - High ts_recid: '||high_ts_recid);
    last_ts_recid := high_ts_recid;
 
    OPEN tsQ;                           -- just open that cursor please
    fetchTs;                            -- do priming read
    last_con_id_ts# := -1;              -- initialize for ordering assert
    last_ts# := -1;                     -- initialize for ordering assert
 
    if resync_reason = RESYNC_REASON_TS then
      fullResyncAction.active  := TRUE;
      fullResyncAction.valid   := TRUE;
      fullResyncAction.objtype := RESYNC_OBJECT_TABLESPACE;
    else
      fullResyncAction.active  := FALSE;
    end if;
 
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
 
END beginTableSpaceResync;
 
 
PROCEDURE checkTableSpace(
  ts_name                     IN VARCHAR2
 ,ts#                         IN NUMBER
 ,create_scn                  IN NUMBER
 ,create_time                 IN DATE
 ,rbs_count                   IN NUMBER   DEFAULT NULL
 ,included_in_database_backup IN VARCHAR2 DEFAULT NULL
 ,bigfile                     IN VARCHAR2 DEFAULT NULL
 ,temporary                   IN VARCHAR2 DEFAULT NULL
 ,encrypt_in_backup           IN VARCHAR2 DEFAULT NULL
 ,plugin_scn                  IN NUMBER   DEFAULT 0
 ,con_id                      IN NUMBER   DEFAULT 0
 ,pdb_dict_check              IN BOOLEAN  DEFAULT FALSE
) IS
--
--
--
idb              varchar2(3) := nvl(included_in_database_backup, 'YES');
--
bf               varchar2(3) := nvl(bigfile, 'NO');   -- actual default value
tmp              varchar2(3) := nvl(temporary, 'NO'); -- actual default value
ts_changed       boolean     := FALSE;
local_pdbinc_key number;
local_pdb_key    number;
BEGIN
  IF (tsRec.ts# IS NULL) THEN   -- assert beginTableSpaceResync was called
    raise_application_error(-20040, 'Tablespace resync not started');
  END IF;
 
--
  IF (last_con_id_ts# > con_id) THEN
     raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (con_id > last_con_id_ts#) THEN
     last_ts# := -1;
  END IF;
 
  IF (last_ts# >= ts#) THEN 
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
--
--
--
--
  IF (temporary IS NOT NULL) THEN
     do_temp_ts_resync := TRUE;
  END IF;
 
--
  last_con_id_ts# := con_id;
  last_ts# := ts#;
 
--
--
--
  IF (create_scn > this_ckp_scn AND tmp = 'NO') THEN
    raise_application_error(-20042, 'Invalid tablespace create SCN');
  END IF;
 
--
--
--
--
--
--
--
  deb('checkTableSpace - ts#: ' || ts# || ' tsRec.ts#: ' || tsRec.ts# ||
      ' con_id ' || con_id || ' tsRec.con_id: ' || tsRec.con_id ||
      ' tsRec.pdb_drop_scn ' || tsRec.pdb_drop_scn);
  WHILE (con_id > tsRec.con_id OR
         (tsRec.con_id = con_id AND ts# > tsRec.ts#) OR
         tsRec.pdb_drop_scn IS NOT NULL) LOOP
    IF (tsRec.temporary = 'NO' OR -- is a permanent tablespace 
        do_temp_ts_resync) THEN   -- is a 10gR2 or later rman client
       deb('checkTableSpace - before calling dropTS');
       dropTs(tsRec.ts#, tsRec.create_scn, this_ckp_scn, this_ckp_time,
              tsRec.plugin_scn, tsRec.pdbinc_key);
       deb('checkTableSpace - before calling incResyncActions');
       begin
          incResyncActions(RESYNC_ACTION_DROP, tsRec.ts#, tsRec.ts_name);
       exception
          when others then
              deb('checkTableSpace - (DO_NOT_IGNORE)caught exception ' ||
                  substr(sqlerrm, 1, 132));
       end;
       deb('checkTableSpace - after calling incResyncActions');
    END IF;
    deb('checkTableSpace - before calling fetchTS');
    fetchTs;
    deb('checkTableSpace - after calling fetchTS');
  END LOOP;
 
  deb('checkTableSpace -out of loop, ts#: ' || ts# || ' tsRec.ts#: ' ||
       tsRec.ts# || ' con_id ' || con_id || ' tsRec.con_id: ' || tsRec.con_id);
 
  IF (con_id != tsRec.con_id OR ts# < tsRec.ts#) THEN
    IF (pdb_dict_check) THEN
        deb('checkTableSpace - skipping tablespace needs dictionary check');
    ELSE
--
       local_pdbinc_key := getPdbInc(greatest(create_scn, plugin_scn),
                                     con_id, local_pdb_key);
       addTs(ts_name, ts#, create_scn, create_time, rbs_count, idb, bf,
             tmp, encrypt_in_backup, plugin_scn, local_pdbinc_key);
    END IF;
    incResyncActions(RESYNC_ACTION_ADD, ts#, ts_name);
  ELSE -- (con_id = tsRec.con_id AND ts# = tsRec.ts#)
    IF (pdb_dict_check) THEN
       deb('checkTableSpace - skipping tablespace needs dictionary check');
       goto next_Ts;
    END IF;
 
    IF (create_scn = tsRec.create_scn) THEN
--
--
      IF (create_time <> tsRec.create_time) THEN
        raise_application_error(-20043, 'Invalid tablespace create time');
      END IF;
 
      IF (plugin_scn > 0) THEN
        IF (tsRec.plugin_scn < checkTableSpace.plugin_scn) THEN
          deb('checkTableSpace - plugin read only tbs dropped and replugged');
--
--
--
          dropTs(tsRec.ts#, tsRec.create_scn, this_ckp_scn, this_ckp_time,
                 tsRec.plugin_scn, tsRec.pdbinc_key);
          incResyncActions(RESYNC_ACTION_DROP, tsRec.ts#, tsRec.ts_name);
          addTs(ts_name, ts#, create_scn, create_time, rbs_count, idb, bf, tmp, 
                encrypt_in_backup, plugin_scn, tsRec.curr_pdbinc_key);
          incResyncActions(RESYNC_ACTION_ADD, ts#, ts_name);
          goto next_Ts;
        ELSIF (tsRec.plugin_scn > checkTableSpace.plugin_scn) THEN
--
          raise_application_error(-20055, 'Invalid tablespace plugin SCN');
        ELSE
--
--
          deb('checkTableSpace - known plugged in tablespace');
        END IF;
      END IF;
 
--
--
      IF (ts_name <> tsRec.ts_name) THEN
        renameTs(ts_name, this_dbinc_key, tsRec.ts#, tsRec.create_scn, 
                 tsRec.plugin_scn, tsRec.pdbinc_key);
        incResyncActions(RESYNC_ACTION_RENAME, tsRec.ts#, ts_name);
      END IF;
 
--
--
      IF (idb <> nvl(tsRec.included_in_database_backup,'XX')) THEN
        UPDATE ts SET ts.included_in_database_backup =
                                  checkTableSpace.included_in_database_backup
        WHERE  ts.dbinc_key  = this_dbinc_key
        AND    ts.ts#        = tsRec.ts#
        AND    ts.pdbinc_key = tsRec.pdbinc_key
        AND    ts.create_scn = tsRec.create_scn
        AND    ts.plugin_scn = tsRec.plugin_scn;
        ts_changed := TRUE;
      END IF;
 
--
--
      IF (tsRec.encrypt_in_backup is null and encrypt_in_backup is not null OR
          tsRec.encrypt_in_backup is not null and encrypt_in_backup is null OR
          tsRec.encrypt_in_backup <> encrypt_in_backup) THEN
        UPDATE ts SET ts.encrypt_in_backup = checkTableSpace.encrypt_in_backup
        WHERE  ts.dbinc_key  = this_dbinc_key
        AND    ts.ts#        = tsRec.ts#
        AND    ts.pdbinc_key = tsRec.pdbinc_key
        AND    ts.create_scn = tsRec.create_scn
        AND    ts.plugin_scn = tsRec.plugin_scn;
        ts_changed := TRUE;
      END IF;
 
--
--
      IF (rbs_count <> nvl(tsRec.rbs_count,-1)) THEN
        UPDATE tsatt SET end_ckp_key = this_ckp_key
        WHERE tsatt.dbinc_key = this_dbinc_key
        AND   tsatt.ts# = tsRec.ts#
        AND   tsatt.pdbinc_key = tsRec.pdbinc_key
        AND   tsatt.create_scn = tsRec.create_scn
        AND   tsatt.plugin_scn = tsRec.plugin_scn
        AND   tsatt.end_ckp_key IS NULL;
 
        INSERT INTO tsatt(dbinc_key, ts#, create_scn, start_ckp_key, rbs_count,
               plugin_scn, pdbinc_key)
        VALUES(this_dbinc_key, tsRec.ts#, tsRec.create_scn, this_ckp_key,
               rbs_count, tsRec.plugin_scn, tsRec.pdbinc_key);
        ts_changed := TRUE;
      END IF;
 
      if ts_changed then
        incResyncActions(RESYNC_ACTION_CHANGE, tsRec.ts#, tsRec.ts_name);
      end if;
    ELSIF (create_scn = 0 AND tmp = 'YES') THEN
--
--
--
       dropTs(tsRec.ts#, tsRec.create_scn, create_scn, create_time, 
              tsRec.plugin_scn, tsRec.pdbinc_key);
 
       DELETE FROM ts
        WHERE ts.dbinc_key = this_dbinc_key
          AND ts.ts# = checkTableSpace.ts#
          AND ts.pdbinc_key = tsRec.pdbinc_key
          AND ts.create_scn = 0
          AND ts.plugin_scn = 0;
 
       addTs(ts_name, ts#, create_scn, create_time, rbs_count, idb, bf, tmp,
             encrypt_in_backup, plugin_scn, tsRec.curr_pdbinc_key);
       incResyncActions(RESYNC_ACTION_CHANGE, tsRec.ts#, ts_name);
    ELSE
       IF (tmp = 'YES') THEN
--
--
          IF (tsRec.temporary = 'NO') THEN
             dropTs(tsRec.ts#, tsRec.create_scn, create_scn, create_time,
                    tsRec.plugin_scn, tsRec.pdbinc_key);
          END IF;
 
--
--
--
--
--
          DELETE FROM ts
            WHERE ts.dbinc_key = this_dbinc_key
              AND ts.ts# = checkTablespace.ts#
              AND ts.pdbinc_key = tsRec.pdbinc_key
              AND ts.temporary = 'YES';
          deb('Deleting tablespace entry for ts#=' || ts# ||
              ', ts_name=' || ts_name);
 
          addTs(ts_name, ts#, create_scn, create_time, rbs_count, idb,
                bf, tmp, encrypt_in_backup, plugin_scn, tsRec.curr_pdbinc_key);
          deb('Added tablespace entry for ts#=' || ts# || ', ts_name=' ||
              ts_name);
 
          incResyncActions(RESYNC_ACTION_RECREATE, ts#, ts_name);
       ELSE
          IF (create_scn > tsRec.create_scn) THEN
 
--
--
--
--
--
--
--
--
             dropTs(tsRec.ts#, tsRec.create_scn, create_scn, create_time,
                    tsRec.plugin_scn, tsRec.pdbinc_key);
 
             addTs(ts_name, ts#, create_scn, create_time, rbs_count, idb,
                   bf, tmp, encrypt_in_backup, plugin_scn,
                   tsRec.curr_pdbinc_key);
             incResyncActions(RESYNC_ACTION_RECREATE, tsRec.ts#, ts_name);
          ELSE -- (create_scn < tsRec.create_scn)
--
--
--
--
             raise_application_error(-20042,
                                     'Invalid tablespace creation change#');
          END IF;
       END IF;
    END IF;
 
<<next_Ts>>
    fetchTS;                            -- get next row from TS cursor
 
  END IF; -- (ts# < tsRec.ts)
 
END checkTableSpace;
 
 
PROCEDURE endTableSpaceResync IS
 
BEGIN
  checkResync;
 
  deb('endTableSpaceResync - tsRec.ts#: ' || tsRec.ts#);
 
--
--
--
  begin
     WHILE (tsRec.con_id < MAXNUMVAL) LOOP -- while extra tablespaces in rcvcat
       IF (tsRec.temporary = 'NO' OR -- is a permanent tablespace 
           do_temp_ts_resync) THEN   -- is a 10gR2 or later rman client
          deb('endTableSpaceResync - before calling dropTS');
          dropTs(tsRec.ts#, tsRec.create_scn, this_ckp_scn, this_ckp_time,
                 tsRec.plugin_scn, tsRec.pdbinc_key);
          deb('endTableSpaceResync - before calling incResyncActions');
          begin
             incResyncActions(RESYNC_ACTION_DROP, tsRec.ts#, tsRec.ts_name);
          exception
             when others then
                 deb('endTableSpaceResync (DO_NOT_IGNORE)-caught exception ' ||
                     substr(sqlerrm, 1, 132));
          end;
          deb('endTableSpaceResync - after calling incResyncActions');
       END IF;
       deb('endTableSpaceResync - before calling fetchTS');
       fetchTs;
       deb('endTableSpaceResync - after calling fetchTS');
     END LOOP;
  exception
     when others then
        deb('checkTableSpace(DO_NOT_IGNORE) - caugth exception ' ||
            substr(sqlerrm, 1, 132));
  end;
  deb('endTableSpaceResync -out of loop,  tsRec.ts#: ' || tsRec.ts#);
 
--
  tsRec.ts# := NULL;
 
--
  UPDATE node SET high_ts_recid = nvl(last_ts_recid, high_ts_recid)
  WHERE site_key = this_site_key;
 
--
  IF this_is_ors and this_ckp_type = 'FULL' THEN
     UPDATE watermarks SET high_ts_recid = nvl(last_ts_recid, high_ts_recid)
     WHERE db_key = this_db_key;
  END IF;
 
  last_ts_recid := NULL;
 
--
--
  IF (NOT do_temp_ts_resync) THEN
     UPDATE node SET high_tf_recid = 0
      WHERE site_key = this_site_key;
  END IF;
 
END endTableSpaceResync;
 
 
/*-----------------*
 * Datafile Resync *
 *-----------------*/
 
PROCEDURE fetchDF IS                    -- private to package body
BEGIN
  FETCH dfQ INTO dfRec;
  IF dfQ%NOTFOUND THEN
    dfRec.file# := MAXNUMVAL;           -- indicate end-of-fetch
    CLOSE dfQ;
  ELSE
    deb('fetchDF - file#' || dfRec.file#);
  END IF;
END fetchDF;
 
PROCEDURE addDF(file#               IN NUMBER,  -- private to package body
                fname               IN VARCHAR2,
                create_time         IN DATE,
                create_scn          IN NUMBER,
                blocks              IN NUMBER,
                block_size          IN NUMBER,
                ts#                 IN NUMBER,
                stop_scn            IN NUMBER,
                stop_time           IN DATE,
                read_only           IN NUMBER,
                rfile#              IN NUMBER,
                foreign_dbid        IN NUMBER,
                foreign_create_scn  IN NUMBER,
                foreign_create_time IN DATE,
                plugged_readonly    IN varchar2,
                plugin_scn          IN NUMBER,   
                plugin_reset_scn    IN NUMBER,   
                plugin_reset_time   IN DATE,
                create_thread       IN NUMBER,   
                create_size         IN NUMBER,
                pdbinc_key          IN NUMBER,
                pdb_key             IN NUMBER,
                pdb_closed          IN NUMBER,
                pdb_foreign_dbid    IN NUMBER) IS
 
 
ts_create_scn NUMBER;
ts_plugin_scn NUMBER;
ts_pdbinc_key NUMBER;
ts_name       ts.ts_name%type;
local_df_key  NUMBER;
child_rec     exception;
pragma        exception_init(child_rec, -2292);
BEGIN
  SELECT ts.create_scn, ts.plugin_scn, ts.ts_name, ts.pdbinc_key
  INTO ts_create_scn, ts_plugin_scn, ts_name, ts_pdbinc_key
  FROM ts, rci_pdbinc_this_dbinc pdbinc
  WHERE ts.dbinc_key = this_dbinc_key
  AND   ts.ts# = addDF.ts#
  AND   ts.pdbinc_key = pdbinc.pdbinc_key
  AND   pdbinc.pdb_key = addDF.pdb_key
  AND   pdbinc.dbinc_key = this_dbinc_key
  AND   ts.create_scn  < pdbinc.next_inc_scn
  AND   ts.drop_scn IS NULL;            -- in case ts numbers are reused
 
--
--
--
--
--
  BEGIN
    select distinct df_key into local_df_key from df, dbinc 
      where  file#        = addDF.file#
        and  create_scn   = addDF.create_scn
        and  plugin_scn   = addDF.plugin_scn
        and  foreign_dbid = addDF.foreign_dbid
        and  ts#          = addDF.ts#
        and  df.dbinc_key = dbinc.dbinc_key
        and  dbinc.db_key = this_db_key;
 
  EXCEPTION
    WHEN no_data_found THEN
      select rman_seq.nextval into local_df_key from dual;
  END;
 
--
--
--
--
  INSERT INTO df(dbinc_key, file#, create_scn, create_time,
                 ts#, ts_create_scn, ts_plugin_scn, block_size,
                 stop_scn, stop_time, read_only, rfile#, df_key, blocks,
                 foreign_dbid, foreign_create_scn, foreign_create_time,
                 plugged_readonly, plugin_scn, plugin_reset_scn,
                 plugin_reset_time, create_thread, create_size, pdbinc_key,
                 ts_pdbinc_key, pdb_closed, pdb_foreign_dbid)
  VALUES(this_dbinc_key, file#, create_scn, create_time, ts#, ts_create_scn,
         ts_plugin_scn, block_size, stop_scn, stop_time, read_only, rfile#, 
         local_df_key, nvl(blocks, 0), foreign_dbid, foreign_create_scn,
         foreign_create_time, plugged_readonly, plugin_scn, plugin_reset_scn,
         plugin_reset_time, create_thread, create_size, pdbinc_key,
         ts_pdbinc_key, pdb_closed, pdb_foreign_dbid);
 
--
--
--
  BEGIN
    INSERT INTO site_dfatt(df_key, fname, site_key)
    VALUES(local_df_key, fname, this_site_key);
  EXCEPTION
    WHEN dup_val_on_index THEN
--
      UPDATE site_dfatt SET
        fname = addDf.fname
      WHERE 
        site_key = this_site_key AND
        df_key   = local_df_key;      
  END;
END addDf;
 
PROCEDURE setDatafileSize(file#      IN number
                         ,create_scn IN number
                         ,blocks     IN number
                         ,plugin_scn IN number default 0) IS
BEGIN
  IF (this_dbinc_key is NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
  update df
  set df.blocks = setDatafileSize.blocks
     where dbinc_key = this_dbinc_key
     and   df.file# = setDatafileSize.file#
     and   df.create_scn = setDatafileSize.create_scn
     and   df.plugin_scn = setDatafileSize.plugin_scn;
  commitChanges('setDatafileSize');
END setDatafileSize;
 
PROCEDURE dropDf(                       -- private to package body
  file# IN NUMBER
 ,create_scn IN NUMBER
 ,plugin_scn IN NUMBER
 ,drop_scn IN NUMBER
 ,drop_time IN DATE
 ,pdbinc_key IN NUMBER
) IS
 
BEGIN
--
--
--
--
--
--
--
--
 
  UPDATE df SET
    drop_scn     = dropDf.drop_scn,
    drop_time    = dropDf.drop_time
  WHERE df.dbinc_key  = this_dbinc_key
  AND   df.file#      = dropDf.file#
  AND   df.create_scn = dropDf.create_scn
  AND   df.plugin_scn = dropDf.plugin_scn
  AND   df.pdbinc_key = dropDf.pdbinc_key;
END dropDf;
 
FUNCTION beginDataFileResyncForStandby(
  high_df_recid IN number
) return boolean IS
BEGIN
  checkResync;
 
  SELECT high_df_recid INTO last_df_recid
  FROM node
  WHERE node.site_key = this_site_key;
 
  deb('high_df_recid='||high_df_recid||',last_df_recid='||last_df_recid);
 
  IF last_full_ckp_scn IS NULL THEN
     deb('beginDataFileResyncForStandby - no full resync');
     raise_application_error(-20079,
        'full resync from primary database is not done');
  END IF;
 
--
--
--
  IF (high_df_recid > last_df_recid OR last_df_recid IS NULL) THEN
     last_df_recid := high_df_recid;
     last_file# := -1;                   -- initialize for ordering assert
--
--
     IF this_ckp_scn > last_full_ckp_scn THEN
        OPEN dfQ;
        fetchDf;                            -- do priming read
     END IF;
     RETURN TRUE;
  END IF;
  deb('no need to resync datafile names for '||this_db_unique_name||
      ' standby site');
  RETURN FALSE;
END;
 
PROCEDURE checkDataFileForStandby(file#               IN NUMBER,
                                  fname               IN VARCHAR2,
                                  create_scn          IN NUMBER,
                                  create_time         IN DATE,
                                  blocks              IN NUMBER,
                                  block_size          IN NUMBER,
                                  ts#                 IN NUMBER,
                                  rfile#              IN NUMBER,
                                  stop_scn            IN NUMBER,
                                  read_only           IN NUMBER,
                                  foreign_dbid        IN NUMBER,
                                  plugin_scn          IN NUMBER) IS
   local_df_key NUMBER;
BEGIN
   IF (last_file# >= file#) THEN        -- assert rows passed in ascending
      raise_application_error(-20036, 'Invalid record order');
   END IF;
 
   last_file# := file#;                 -- for checking next call
 
--
--
   IF this_ckp_scn > last_full_ckp_scn THEN
      IF (file# != dfRec.file#) THEN
         IF (file# > dfRec.file#) THEN
            deb('checkDataFileResyncForStandby - droped file#=' ||dfRec.file#);
         ELSE
--
            deb('checkDataFileResyncForStandby - added file#=' || file#);
         END IF;
         raise_application_error(-20079, 
            'full resync from primary database is not done');
      ELSE
--
--
--
 
--
--
         IF (create_scn <> dfRec.create_scn OR
             plugin_scn <> dfRec.plugin_scn OR
             stop_scn <> dfRec.stop_scn OR
             stop_scn is null and dfRec.stop_scn is not null OR
             stop_scn is not null and dfRec.stop_scn is null OR
             read_only < dfRec.read_only OR
             read_only is null and dfRec.read_only is not null OR
             read_only is not null and dfRec.read_only is null) THEN
            deb('checkDataFileResyncForStandby - change for file#=' || file#);
            raise_application_error(-20079, 
               'full resync from primary database is not done');
         END IF;
      END IF;
      fetchDF;
   END IF;
 
   BEGIN
--
     select distinct df_key into local_df_key from df, dbinc 
       where  file#        = checkDataFileForStandby.file#
         and  create_scn   = checkDataFileForStandby.create_scn
         and  plugin_scn   = checkDataFileForStandby.plugin_scn
         and  decode(foreign_dbid, 0, checkDataFileForStandby.foreign_dbid,
                     foreign_dbid)  = checkDataFileForStandby.foreign_dbid
         and  ts#          = checkDataFileForStandby.ts#
         and  df.dbinc_key = dbinc.dbinc_key
         and  dbinc.db_key = this_db_key;
   EXCEPTION
--
--
      WHEN no_data_found THEN
         raise_application_error(-20999,
           'Internal error in checkDataFileForStandby - 1 ');
--
      WHEN too_many_rows THEN
         raise_application_error(-20999,
           'Internal error in checkDataFileForStandby - 2 ');
   END;
 
--
--
--
   BEGIN
     INSERT INTO site_dfatt(df_key, fname, site_key)
     VALUES(local_df_key, checkDataFileForStandby.fname, this_site_key);
   EXCEPTION
     WHEN dup_val_on_index THEN
--
       UPDATE site_dfatt SET
         fname = checkDataFileForStandby.fname
       WHERE
         site_key = this_site_key AND
         df_key   = local_df_key;      
   END;
END;
 
PROCEDURE endDataFileResyncForStandby IS
BEGIN
  checkResync;
 
--
  IF (this_ckp_scn > last_full_ckp_scn AND
      dfRec.file# < MAXNUMVAL) THEN
     deb('endDataFileResyncForStandby - dropped file# > ' || dfRec.file#);
     raise_application_error(-20079, 
        'full resync from primary database is not done');
     IF dfQ%ISOPEN THEN 
        CLOSE dfQ; 
     END IF;
  END IF;
 
--
  dfRec.file# := NULL;
 
--
  UPDATE node SET high_df_recid = last_df_recid
  WHERE node.site_key = this_site_key;
 
  last_df_recid := NULL;
END;
 
 
FUNCTION beginDataFileResync(
  high_df_recid IN NUMBER
) RETURN BOOLEAN IS
 
BEGIN
  checkResync;
 
  IF (tsRec.ts# IS NOT NULL) THEN
    raise_application_error(-20041, 'Tablespace resync not completed');
  END IF;
 
  SELECT high_df_recid INTO last_df_recid
  FROM node
  WHERE site_key = this_site_key;
 
  IF (high_df_recid = last_df_recid) THEN
    deb('beginDataFileResync - Resync of datafiles not needed');
    RETURN FALSE;
  ELSIF (high_df_recid > last_df_recid OR last_df_recid IS NULL) THEN
    deb('beginDataFileResync - Catalog df_recid: '||last_df_recid);
    deb('beginDataFileResync - High df_recid: '||high_df_recid);
    last_df_recid := high_df_recid;
 
    OPEN dfQ;
    fetchDf;                            -- do priming read
    last_file# := -1;                   -- initialize for ordering assert
 
    if resync_reason = RESYNC_REASON_DF then
      fullResyncAction.valid   := TRUE;
      fullResyncAction.active  := TRUE;
      fullResyncAction.objtype := RESYNC_OBJECT_DATAFILE;
    else
      fullResyncAction.active  := FALSE;
    end if;
 
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
 
END beginDataFileResync;
 
 
PROCEDURE checkDataFile(file#         IN  NUMBER,
                        fname         IN  VARCHAR2,
                        create_scn    IN  NUMBER,
                        create_time   IN  DATE,
                        blocks        IN  NUMBER,
                        block_size    IN  NUMBER,
                        ts#           IN  NUMBER,
                        stop_scn      IN  NUMBER,
                        read_only     IN  NUMBER,
                        stop_time     IN  DATE     DEFAULT NULL,
                        rfile#        IN  NUMBER   DEFAULT NULL,
                        aux_fname     IN  VARCHAR2 DEFAULT NULL,
                        foreign_dbid        IN NUMBER   DEFAULT 0,
                        foreign_create_scn  IN NUMBER   DEFAULT 0,
                        foreign_create_time IN DATE     DEFAULT NULL,
                        plugged_readonly    IN VARCHAR2 DEFAULT 'NO',
                        plugin_scn          IN NUMBER   DEFAULT 0,
                        plugin_reset_scn    IN NUMBER   DEFAULT 0,
                        plugin_reset_time   IN DATE     DEFAULT NULL,
                        create_thread       IN NUMBER   DEFAULT NULL,
                        create_size         IN NUMBER   DEFAULT NULL,
                        con_id              IN NUMBER   DEFAULT 0,
                        pdb_closed          IN NUMBER   DEFAULT 0,
                        pdb_dict_check      IN BOOLEAN  DEFAULT FALSE,
                        pdb_foreign_dbid    IN NUMBER   DEFAULT 0)
IS
   local_df_key     NUMBER;
   changedauxname   BOOLEAN;
   local_pdbinc_key NUMBER;
   local_pdb_key    NUMBER;
   existing_file    BOOLEAN;
BEGIN
   IF (dfRec.file# IS NULL) THEN -- assert beginDataFileResync was called
      raise_application_error(-20050, 'Datafile resync not started');
   END IF;
   IF (last_file# >= file#) THEN        -- assert rows passed in ascending
      raise_application_error(-20036, 'Invalid record order');
   END IF;
   last_file# := file#;                 -- for checking next call
   
   IF (plugged_readonly = 'NO' AND create_scn > this_ckp_scn) THEN
      raise_application_error(-20052, 'Invalid datafile create SCN');
   ELSIF (plugged_readonly = 'YES' AND plugin_scn > this_ckp_scn) THEN
      raise_application_error(-20055, 'Invalid datafile plugin SCN');
   END IF;
 
--
--
--
--
--
   WHILE (file# > dfRec.file#) LOOP
      deb('checkDatafile - dropping file#: '||to_char(dfRec.file#));
      dropDf(dfRec.file#, dfRec.create_scn, dfRec.plugin_scn,
             this_ckp_scn, this_ckp_time, dfRec.pdbinc_key);
      incResyncActions(RESYNC_ACTION_DROP, dfRec.file#, dfRec.fname);
      fetchDf;
   END LOOP;
 
   IF (file# < dfRec.file#) THEN
      IF (pdb_dict_check) THEN
         deb('checkDataFile - skipping df needs dictionary check');
      ELSE
         local_pdbinc_key := getPdbInc(greatest(create_scn, plugin_scn),
                                       con_id, local_pdb_key);
--
         deb('checkDatafile - adding file#: '||to_char(file#));
         addDF(file#, fname, create_time, create_scn, blocks, block_size,
               ts#, stop_scn, stop_time, read_only, rfile#, foreign_dbid,
               foreign_create_scn, foreign_create_time, plugged_readonly,
               plugin_scn, plugin_reset_scn, plugin_reset_time,
               create_thread, create_size, local_pdbinc_key,
               local_pdb_key, pdb_closed, pdb_foreign_dbid);
--
--
--
         IF (aux_fname is not NULL) THEN
           setCloneName(file#, create_scn, aux_fname, NULL, changedauxname, 
                        plugin_scn);
         END IF;
      END IF;
      incResyncActions(RESYNC_ACTION_ADD, file#, fname);
   ELSE -- (file# = dfRec.file#)
      existing_file := FALSE;
 
      IF (create_scn = dfRec.create_scn AND
          plugin_scn = dfRec.plugin_scn) THEN
--
--
         IF (create_time <> dfRec.create_time) THEN
            raise_application_error(-20053, 'Invalid datafile create time');
         END IF;
         IF (ts# <> dfRec.ts#) THEN
            raise_application_error(-20054, 'Invalid datafile ts#');
         END IF;
 
         existing_file := TRUE;
 
         SELECT DISTINCT df_key INTO local_df_key FROM df 
            WHERE file#        = checkDataFile.file#
              AND create_scn   = checkDataFile.create_scn
              AND plugin_scn   = checkDataFile.plugin_scn
              AND decode(foreign_dbid, 0, checkDataFile.foreign_dbid,
                         foreign_dbid)  = checkDataFile.foreign_dbid
              AND ts#          = checkDataFile.ts#
              AND dbinc_key    = this_dbinc_key;
 
--
--
         IF (fname <> dfRec.fname OR dfRec.fname is NULL) THEN
--
--
--
--
--
           IF (fname = dfRec.clone_fname and dfRec.fname is not null) THEN
              deb('checkDatafile - new datafilename is old auxname');
              setCloneName(dfRec.file#, dfRec.create_scn, dfRec.fname,
                           dfRec.clone_fname, changedauxname,
                           dfRec.plugin_scn);
           END IF;
 
           incResyncActions(RESYNC_ACTION_RENAME, dfRec.file#, fname);
           UPDATE site_dfatt SET
              fname = checkDataFile.fname
           WHERE 
             site_key = this_site_key AND
             df_key   = local_df_key;
 
--
--
           IF sql%rowcount = 0 THEN
              INSERT INTO site_dfatt (df_key, fname, site_key)
              VALUES(local_df_key, checkDataFile.fname, this_site_key);
           END IF;
         END IF;
      END IF;
 
      IF (pdb_dict_check) THEN
         deb('checkDataFile - skipping df needs dictionary check');
      ELSIF (existing_file) THEN
--
--
         IF ((create_thread is not null AND dfRec.create_thread is null) OR
             (create_size is not null AND dfRec.create_size is null)) THEN
           UPDATE df SET
              create_thread    = checkDataFile.create_thread,
              create_size      = checkDataFile.create_size
              WHERE df.df_key  = local_df_key;
         END IF;
 
--
--
         IF foreign_dbid <> 0 AND dfrec.foreign_dbid = 0 THEN
            UPDATE df SET
              foreign_dbid    = checkDataFile.foreign_dbid
              WHERE df.df_key  = local_df_key;
            deb('checkDatafile - foreign_dbid for file#.df_key('||
                local_df_key || ') changed to ' || checkDataFile.foreign_dbid);
         END IF;
 
--
         IF ((blocks <> dfrec.blocks) OR
             (stop_scn <> dfrec.stop_scn) OR
             (stop_scn IS NULL AND dfrec.stop_scn IS NOT NULL) OR
             (stop_scn IS NOT NULL AND dfrec.stop_scn IS NULL) OR
             (pdb_closed <> dfrec.pdb_closed)) THEN
           IF blocks <> dfRec.blocks THEN
              deb('checkDatafile - size changed for file#: '||
                  to_char(file#)||' from '||to_char(dfRec.blocks)||' to '||
                  to_char(blocks));
              incResyncActions(RESYNC_ACTION_RESIZE, dfRec.file#, fname);
           ELSE
              deb('checkDatafile - stopSCN changed for file#: '||
                  to_char(file#)||' from '||
                  nvl(to_char(dfRec.stop_scn), 'NULL')||' to '||
                  nvl(to_char(checkDatafile.stop_scn), 'NULL'));
              incResyncActions(RESYNC_ACTION_CHANGE, dfRec.file#, fname);
           END IF;
 
           UPDATE df SET
              stop_scn     = checkDataFile.stop_scn,
              stop_time    = checkDataFile.stop_time,
              read_only    = checkDataFile.read_only,
              blocks       = checkDataFile.blocks,
              pdb_closed   = checkDataFile.pdb_closed
              WHERE df.dbinc_key  = this_dbinc_key
              AND   df.file#      = dfRec.file#
              AND   df.create_scn = dfRec.create_scn
              AND   df.plugin_scn = dfRec.plugin_scn
              AND   df.pdbinc_key = dfRec.pdbinc_key;
         ELSE
           deb('checkDatafile - stopSCN remains the same for file#: '||
               to_char(file#));
         END IF;
 
--
--
--
         IF (aux_fname is not NULL) THEN
            setCloneName(dfRec.file#, dfRec.create_scn, aux_fname, 
                         dfRec.clone_fname, changedauxname,
                         dfRec.plugin_scn);
            IF changedauxname THEN
               incResyncActions(RESYNC_ACTION_CHANGE, dfRec.file#, fname);
            END IF;
         END IF;
      ELSIF ((case when plugged_readonly = 'NO' then
              create_scn else plugin_scn end) >
             (case when dfRec.plugged_readonly = 'NO' then
              dfRec.create_scn else dfRec.plugin_scn end)) THEN
--
--
--
--
--
--
--
--
--
 
         deb('checkDatafile - file#: '||to_char(file#)||' recreated');
         dropDf(dfRec.file#, dfRec.create_scn, dfRec.plugin_scn,
                this_ckp_scn, this_ckp_time, dfRec.pdbinc_key);
         local_pdbinc_key := getPdbInc(greatest(create_scn, plugin_scn),
                                       con_id, local_pdb_key);
         addDf(file#, fname, create_time, create_scn, blocks, block_size, ts#,
               stop_scn, stop_time, read_only, rfile#, foreign_dbid,
               foreign_create_scn, foreign_create_time, plugged_readonly,
               plugin_scn, plugin_reset_scn, plugin_reset_time,
               create_thread, create_size, local_pdbinc_key,
               local_pdb_key, pdb_closed, pdb_foreign_dbid);
         incResyncActions(RESYNC_ACTION_RECREATE, dfRec.file#, fname);
      ELSE -- (create_scn < dfRec.create_scn)
--
--
--
--
--
         IF (plugged_readonly = 'NO') THEN
            raise_application_error(-20052, 'Invalid datafile create SCN');
         ELSE
            raise_application_error(-20055, 'Invalid datafile plugin SCN');
         END IF;
      END IF;
 
      fetchDF;                          -- get next row from DF cursor
 
   END IF; -- (file# < dfRec.file#)
END checkDataFile;
 
 
PROCEDURE endDataFileResync IS
 
BEGIN
  checkResync;
 
--
  WHILE (dfRec.file# < MAXNUMVAL) LOOP
--
    dropDf(dfRec.file#, dfRec.create_scn, dfRec.plugin_scn,
           this_ckp_scn, this_ckp_time, dfRec.pdbinc_key);
    begin
       incResyncActions(RESYNC_ACTION_DROP, dfRec.file#, dfRec.fname);
    exception
       when others then
           deb('endTableSpaceResync(DO_NOT_IGNORE) - caugth exception ' ||
               substr(sqlerrm, 1, 132));
    end;
    fetchDf;
  END LOOP;
 
--
  dfRec.file# := NULL;
 
--
  UPDATE node SET high_df_recid = last_df_recid
  WHERE site_key = this_site_key;
 
--
  IF this_is_ors and this_ckp_type = 'FULL' THEN
     UPDATE watermarks SET high_df_recid = last_df_recid
     WHERE db_key = this_db_key;
  END IF;
 
  last_df_recid := NULL;
END endDataFileResync;
 
/*-----------------*
 * Tempfile Resync *
 *-----------------*/
 
PROCEDURE fetchTf IS                    -- private to package body
BEGIN
--
  IF tfRec.file# = MAXNUMVAL THEN
     return;
  END IF;
 
  FETCH tfQ INTO tfRec;
  IF tfQ%NOTFOUND THEN
    tfRec.file# := MAXNUMVAL;           -- indicate end-of-fetch
    CLOSE tfQ;
  END IF;
END fetchTf;
 
PROCEDURE addTf(file#          IN NUMBER,  -- private to package body
                fname          IN VARCHAR2,
                create_time    IN DATE,
                create_scn     IN NUMBER,
                blocks         IN NUMBER,
                block_size     IN NUMBER,
                ts#            IN NUMBER,
                rfile#         IN NUMBER,
                autoextend     IN VARCHAR2,
                max_size       IN NUMBER,
                next_size      IN NUMBER,
                con_id         IN NUMBER) IS
   ts_create_scn NUMBER;
   ts_pdbinc_key NUMBER;
   local_tf_key  NUMBER;
   local_pdb_key NUMBER;
BEGIN
   SELECT pdb.pdb_key INTO local_pdb_key
     FROM pdb, pdb_dbinc
    WHERE pdb_dbinc.drop_scn IS NULL
      AND pdb.con_id          = addTf.con_id
      AND pdb.pdb_key         = pdb_dbinc.pdb_key
      AND pdb_dbinc.dbinc_key = this_dbinc_key;
 
   BEGIN
     SELECT ts.create_scn, ts.pdbinc_key
       INTO ts_create_scn, ts_pdbinc_key
     FROM ts, rci_pdbinc_this_dbinc pdbinc
     WHERE ts.dbinc_key = this_dbinc_key
       AND ts.ts# = addTf.ts#
       AND ts.pdbinc_key = pdbinc.pdbinc_key
       AND pdbinc.pdb_key = local_pdb_key
       AND pdbinc.dbinc_key = this_dbinc_key
       AND ts.create_scn  < pdbinc.next_inc_scn
       AND ts.drop_scn IS NULL;            -- in case ts numbers are reused
   EXCEPTION
     WHEN no_data_found THEN
--
--
--
       IF (this_cf_type = 'STANDBY' AND this_db_unique_name is not null) THEN
         RETURN;
       END IF;
   END;
   deb('ts_create_scn=' || ts_create_scn);
 
--
--
  BEGIN
    SELECT DISTINCT tf.tf_key INTO local_tf_key 
    FROM tf, dbinc
    WHERE tf.file#        = addTf.file#
      AND tf.create_scn   = addTf.create_scn
      AND (tf.create_time = addTf.create_time
           OR tf.create_time IS NULL AND addTf.create_time IS NULL)
      AND  tf.ts#         = addTf.ts#
      AND  tf.rfile#      = addTf.rfile#
      AND  tf.dbinc_key   = dbinc.dbinc_key
      AND  dbinc.db_key   = this_db_key;
   EXCEPTION
    WHEN no_data_found THEN
      SELECT rman_seq.nextval INTO local_tf_key FROM dual;
  END;
 
  BEGIN
    INSERT INTO tf(dbinc_key, file#, create_scn, create_time,
                   ts#, ts_create_scn, block_size, rfile#, tf_key, pdb_key,
                   ts_pdbinc_key)
    VALUES(this_dbinc_key, file#, create_scn, create_time, ts#, ts_create_scn,
           block_size, rfile#, local_tf_key, local_pdb_key, ts_pdbinc_key);
  EXCEPTION
    WHEN dup_val_on_index THEN
--
--
--
      IF create_scn = 0 THEN
        UPDATE tf SET 
           create_time   = addTf.create_time,
           ts#           = addTf.ts#,
           ts_create_scn = addTf.ts_create_scn,
           block_size    = addTf.block_size,
           rfile#        = addTf.rfile#,
           pdb_key       = local_pdb_key
        WHERE dbinc_key  = this_dbinc_key
          AND file#      = addTf.file#
          AND create_scn = addTf.create_scn;
      END IF;
 
--
--
--
--
--
--
--
--
--
--
--
  END;
 
--
--
--
  BEGIN
    INSERT INTO site_tfatt(tf_key, fname, site_key, blocks,
          autoextend, max_size, next_size)
    VALUES(local_tf_key, fname, this_site_key, nvl(addTf.blocks, 0),
           addTf.autoextend, addTf.max_size, addTf.next_size);
--
  EXCEPTION
    WHEN dup_val_on_index THEN
--
      UPDATE site_tfatt SET
        fname = addTf.fname,
        blocks     = nvl(addTf.blocks, 0),
        autoextend = addTf.autoextend,
        max_size   = addTf.max_size,
        next_size  = addTf.next_size,
        drop_scn   = NULL,
        drop_time  = NULL
      WHERE site_key = this_site_key
        AND tf_key   = local_tf_key;      
  END;
END addTf;
 
PROCEDURE dropTf(                       -- private to package body
  tf_key IN NUMBER
 ,drop_scn IN NUMBER
 ,drop_time IN DATE
) IS
 
BEGIN
  UPDATE site_tfatt SET
    drop_scn     = dropTf.drop_scn,
    drop_time    = dropTf.drop_time
  WHERE this_site_key = site_key
    AND tf_key = dropTf.tf_key;
END dropTf;
 
FUNCTION tempFileToResync(
   high_tf_recid IN NUMBER
) RETURN BOOLEAN IS
   tf_recid  number;
BEGIN
  checkResync;
 
  SELECT high_tf_recid INTO tf_recid
  FROM node
  WHERE site_key = this_site_key;
 
  IF (high_tf_recid = tf_recid) THEN
    RETURN FALSE;
  ELSIF (high_tf_recid > tf_recid OR tf_recid IS NULL) THEN
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
END tempFileToResync;
 
--
--
--
FUNCTION beginTempFileResyncForStandby(
  high_tf_recid IN NUMBER
) RETURN BOOLEAN IS
BEGIN
  RETURN beginTempFileResync (high_tf_recid);
END beginTempFileResyncForStandby;
 
--
--
--
--
--
--
--
--
PROCEDURE checkTempFileForStandby
                       (file#          IN  NUMBER,
                        fname          IN  VARCHAR2,
                        create_scn     IN  NUMBER,
                        create_time    IN  DATE,
                        blocks         IN  NUMBER,
                        block_size     IN  NUMBER,
                        ts#            IN  NUMBER,
                        rfile#         IN  NUMBER,
                        autoextend     IN  VARCHAR2,
                        max_size       IN  NUMBER,
                        next_size      IN  NUMBER,
                        con_id         IN  NUMBER DEFAULT 0)
IS
   local_tf_key NUMBER;
BEGIN
    checkTempFile(file#, fname, create_scn, create_time, blocks, block_size,
                  ts#, rfile#, autoextend, max_size, next_size, con_id, FALSE);
END checkTempFileForStandby;
 
PROCEDURE endTempFileResyncForStandby IS
BEGIN
  endTempFileResync;
END endTempFileResyncForStandby;
 
 
FUNCTION beginTempFileResync(
  high_tf_recid IN NUMBER
) RETURN BOOLEAN IS
 
BEGIN
  checkResync;
 
  IF (tsRec.ts# IS NOT NULL) THEN
    raise_application_error(-20041, 'Tablespace resync not completed');
  END IF;
 
  SELECT high_tf_recid INTO last_tf_recid
  FROM node
  WHERE site_key = this_site_key;
 
  IF (high_tf_recid = last_tf_recid) THEN
    deb('beginTempFileResync - Resync of tempfiles not needed');
    RETURN FALSE;
  ELSIF (high_tf_recid > last_tf_recid OR last_tf_recid IS NULL) THEN
    deb('beginTempFileResync - Catalog tf_recid: '||last_tf_recid);
    deb('beginTempFileResync - High tf_recid: '||high_tf_recid);
    last_tf_recid := high_tf_recid;
 
    OPEN tfQ;
    fetchTf;                            -- do priming read
    last_file# := -1;                   -- initialize for ordering assert
 
    if resync_reason = RESYNC_REASON_TF then
      fullResyncAction.active  := TRUE;
      fullResyncAction.valid   := TRUE;
      fullResyncAction.objtype := RESYNC_OBJECT_TEMPFILE;
    else
      fullResyncAction.active  := FALSE;
    end if;
 
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
 
END beginTempFileResync;
 
PROCEDURE checkTempFile(file#          IN  NUMBER,
                        fname          IN  VARCHAR2,
                        create_scn     IN  NUMBER,
                        create_time    IN  DATE,
                        blocks         IN  NUMBER,
                        block_size     IN  NUMBER,
                        ts#            IN  NUMBER,
                        rfile#         IN  NUMBER,
                        autoextend     IN  VARCHAR2,
                        max_size       IN  NUMBER,
                        next_size      IN  NUMBER,
                        con_id         IN  NUMBER  DEFAULT 0,
                        pdb_dict_check IN  BOOLEAN DEFAULT FALSE)
IS
   local_tf_key     NUMBER;
BEGIN
   IF (tfRec.file# IS NULL) THEN -- assert beginTempFileResync was called
      raise_application_error(-20050, 'Tempfile resync not started');
   END IF;
   IF (last_file# >= file#) THEN        -- assert rows passed in ascending
      raise_application_error(-20036, 'Invalid record order');
   END IF;
   last_file# := file#;                 -- for checking next call
 
--
--
--
--
 
--
--
--
--
--
   WHILE (file# > tfRec.file#) LOOP
      dropTf(tfRec.tf_key, this_ckp_scn, this_ckp_time);
      incResyncActions(RESYNC_ACTION_DROP, tfRec.file#, tfRec.fname);
      fetchTf;
   END LOOP;
 
   IF (file# < tfRec.file#) THEN
      IF (pdb_dict_check) THEN
         deb('checkTempFile - skipping tf needs dictionary check');
      ELSE 
         addTf(file#, fname, create_time, create_scn, blocks, block_size, ts#,
               rfile#, autoextend, max_size, next_size, con_id);
      END IF;
      incResyncActions(RESYNC_ACTION_ADD, tfRec.file#, fname);
   ELSE -- (file# = tfRec.file#)
      IF (pdb_dict_check) THEN
         deb('checkTempFile - skipping tf needs dictionary check');
      ELSIF (create_scn = 0) THEN
         addTf(file#, fname, create_time, create_scn, blocks, block_size, ts#,
               rfile#, autoextend, max_size, next_size, con_id);
         incResyncActions(RESYNC_ACTION_CHANGE, file#, fname);
      ELSIF (create_scn = tfRec.create_scn) THEN
--
--
         IF (create_time <> tfRec.create_time) THEN
            raise_application_error(-20053, 'Invalid tempfile create time');
         END IF;
         IF (ts# <> tfRec.ts#) THEN
            raise_application_error(-20054, 'Invalid tempfile ts#');
         END IF;
 
--
         addTf(file#, fname, create_time, create_scn, blocks, block_size, ts#,
               rfile#, autoextend, max_size, next_size, con_id);
 
         IF (fname <> tfRec.fname OR tfRec.fname is NULL) THEN
            incResyncActions(RESYNC_ACTION_RENAME, file#, fname);
         END IF;
 
--
--
         IF (blocks <> tfrec.blocks OR
             autoextend <> tfrec.autoextend OR
             max_size <> tfrec.max_size OR
             next_size <> tfrec.next_size ) THEN
           IF blocks <> tfrec.blocks THEN
              incResyncActions(RESYNC_ACTION_RESIZE, file#, fname);
           ELSE
              incResyncActions(RESYNC_ACTION_CHANGE, file#, fname);
           END IF;
         END IF;
      ELSE
--
--
--
--
--
--
         dropTf(tfRec.tf_key, create_scn, create_time);
         addTf(file#, fname, create_time, create_scn, blocks, block_size, ts#,
               rfile#, autoextend, max_size, next_size, con_id);
         incResyncActions(RESYNC_ACTION_RECREATE, file#, fname);
      END IF;
 
      fetchTf;                          -- get next row from Tf cursor
 
   END IF; -- (file# = tfRec.file#)
   
END checkTempFile;
 
 
PROCEDURE endTempFileResync IS
 
BEGIN
  checkResync;
 
--
  deb('endTempFileResync - entering with tempfile number'||tfRec.file#);
  WHILE (tfRec.file# < MAXNUMVAL) LOOP
    dropTf(tfRec.tf_key, this_ckp_scn, this_ckp_time);
    incResyncActions(RESYNC_ACTION_DROP, tfRec.file#, tfRec.fname);
    fetchTf;
    deb('endTempFileResync - dropping tempfile '||tfRec.file#);
  END LOOP;
 
--
  tfRec.file# := NULL;
 
--
  UPDATE node SET high_tf_recid = last_tf_recid
  WHERE site_key = this_site_key;
 
--
  IF this_is_ors and this_ckp_type = 'FULL' THEN
     UPDATE watermarks SET high_tf_recid = last_tf_recid
     WHERE db_key = this_db_key;
  END IF;
 
  last_tf_recid := NULL;
 
END endTempFileResync;
 
/*---------------------*
 * Redo Thread resync  *
 *---------------------*/
 
PROCEDURE fetchRt IS
 
BEGIN
  FETCH rtQ INTO rtRec;
  IF rtQ%NOTFOUND THEN
    rtRec.thread# := MAXNUMVAL;
    CLOSE rtQ;
  END IF;
END fetchRt;
 
PROCEDURE addRt(
  thread#        IN NUMBER
 ,last_sequence# IN NUMBER
 ,enable_scn     IN NUMBER
 ,enable_time    IN DATE
 ,disable_scn    IN NUMBER
 ,disable_time   IN DATE
 ,status         IN VARCHAR2
) IS
 
BEGIN
  INSERT INTO rt
    (dbinc_key, thread#, sequence#,
     enable_scn, enable_time, disable_scn, disable_time, status)
  VALUES
    (this_dbinc_key, thread#, last_sequence#,
     enable_scn, enable_time, disable_scn, disable_time, status);
END addRt;
 
PROCEDURE dropRt(thread# IN NUMBER) IS
BEGIN
--
  DELETE FROM rt
  WHERE rt.dbinc_key = this_dbinc_key
  AND   rt.thread#   = dropRt.thread#;
END dropRt;
 
FUNCTION beginThreadResync(
  high_rt_recid IN NUMBER
) RETURN BOOLEAN IS
 
BEGIN
  checkResync;
 
  SELECT high_rt_recid INTO last_rt_recid
  FROM node
  WHERE site_key = this_site_key;
 
  IF (high_rt_recid = last_rt_recid) THEN
    deb('beginThreadResync - Resync of redo threads not needed');
    RETURN FALSE;
  ELSIF (high_rt_recid > last_rt_recid OR last_rt_recid IS NULL) THEN
    deb('beginThreadResync - Catalog rt_recid: '||last_rt_recid);
    deb('beginThreadResync - High rt_recid: '||high_rt_recid);
    last_rt_recid := high_rt_recid;
 
    OPEN rtQ;
    fetchRt;                            -- do priming read
    last_thread# := -1;
 
    if resync_reason = RESYNC_REASON_THR then
      fullResyncAction.valid   := TRUE;
      fullResyncAction.active  := TRUE;
      fullResyncAction.objtype := RESYNC_OBJECT_REDOTHREAD;
    else
      fullResyncAction.active  := FALSE;
    end if;
 
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
 
END beginThreadResync;
 
PROCEDURE checkThread(
  thread#        IN NUMBER
 ,last_sequence# IN NUMBER
 ,enable_scn     IN NUMBER
 ,enable_time    IN DATE
 ,disable_scn    IN NUMBER
 ,disable_time   IN DATE
 ,status         IN VARCHAR2
) IS
 
BEGIN
  IF (rtRec.thread# IS NULL) THEN
    raise_application_error(-20061, 'Thread resync not started');
  END IF;
  IF (last_thread# >= thread#) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
  last_thread# := thread#;
 
  WHILE (thread# > rtRec.thread#) LOOP
--
--
--
    dropRt(rtRec.thread#);
    incResyncActions(RESYNC_ACTION_DROP, rtRec.thread#, to_char(NULL));
    fetchRt;
  END LOOP;
  IF (thread# < rtRec.thread#) THEN
--
    addRt(thread#, last_sequence#, enable_scn, enable_time,
          disable_scn, disable_time, status);
    incResyncActions(RESYNC_ACTION_ADD, thread#, to_char(NULL));
  ELSE -- (thread# = rtRec.thread#)
--
    UPDATE rt SET
      sequence# = checkThread.last_sequence#,
      enable_scn = checkThread.enable_scn,
      enable_time = checkThread.enable_time,
      disable_scn = checkThread.disable_scn,
      disable_time = checkThread.disable_time,
      status = checkThread.status
    WHERE rt.dbinc_key = this_dbinc_key
    AND   rt.thread# = checkThread.thread#;
    incResyncActions(RESYNC_ACTION_CHANGE, rtRec.thread#, to_char(NULL));
    fetchRt;
  END IF;
 
END checkThread;
 
PROCEDURE endThreadResync IS
BEGIN
  WHILE (rtRec.thread# < MAXNUMVAL) LOOP
--
--
--
    dropRt(rtRec.thread#);
    fetchRt;
  END LOOP;
 
  rtRec.thread# := NULL;
 
--
  UPDATE node SET high_rt_recid = last_rt_recid
  WHERE site_key = this_site_key;
 
  last_rt_recid := NULL;
END endThreadResync;
 
/*------------------------*
 * Online Redo Log resync *
 *------------------------*/
 
--
--
--
--
--
--
--
--
--
--
FUNCTION nlsnamecmp(n1 IN varchar2, n2 IN varchar2) RETURN NUMBER IS
  CURSOR nlsnamecmp_c(n1 varchar2, n2 varchar2) IS
     SELECT name
       FROM (SELECT n1 name FROM dual
             UNION ALL
             SELECT n2 name FROM dual)
      ORDER BY nlssort(name, 'NLS_COMP=ANSI NLS_SORT=ASCII7');
  ln1  varchar2(1024);
  ln2  varchar2(1024);
BEGIN
  if (n1 is null or n2 is null) then
     return null;
  elsif (n1 = n2) then
     return 0;
  elsif (n1 = chr(1) or n2 = chr(255)) then
     return -1;
  elsif (n2 = chr(1) or n1 = chr(255)) then
     return 1;
  end if;
 
  open nlsnamecmp_c(n1, n2);
  fetch nlsnamecmp_c into ln1;
  fetch nlsnamecmp_c into ln2;
  close nlsnamecmp_c;
  if (ln1 = n1) then
     return -1;
  end if;
  return 1;
END nlsnamecmp;
 
PROCEDURE fetchOrl IS
 
BEGIN
  FETCH orlQ INTO orlRec;
  IF orlQ%NOTFOUND THEN
    orlRec.fname := chr(255);      -- assume chr(255) is greater than any name
    CLOSE orlQ;
  END IF;
END fetchOrl;
 
PROCEDURE addOrl(
  thread#        IN NUMBER
 ,group#         IN NUMBER
 ,fname          IN VARCHAR2
 ,bytes          IN NUMBER
 ,type           IN VARCHAR2
) IS
  thread_not_found EXCEPTION;
  PRAGMA EXCEPTION_INIT(thread_not_found, -2291);
BEGIN
  INSERT INTO orl
    (dbinc_key, thread#, group#, fname, bytes, type, site_key)
  VALUES
    (this_dbinc_key, thread#, group#, fname, bytes, type, this_site_key);
EXCEPTION
  WHEN thread_not_found THEN
--
--
    IF type <> 'STANDBY' THEN
       raise_application_error(-20079,
             'full resync from primary database is not done');
    ELSE
       deb('ignored resync of standby redo log ' || fname);
    END IF;
END addOrl;
 
PROCEDURE dropOrl(fname IN VARCHAR2) IS
BEGIN
--
  DELETE FROM orl
  WHERE orl.dbinc_key = this_dbinc_key
  AND   orl.site_key  = this_site_key
  AND   orl.fname     = dropOrl.fname;
END dropOrl;
 
FUNCTION beginOnlineRedoLogResync(
  high_orl_recid IN NUMBER
) RETURN BOOLEAN IS
 
BEGIN
  checkResync;
 
  SELECT high_orl_recid INTO last_orl_recid
  FROM node
  WHERE site_key = this_site_key;
 
  IF (high_orl_recid = last_orl_recid) THEN
    deb('beginOnlineRedoLogResync - Resync of online logs not needed');
    RETURN FALSE;
  ELSIF (high_orl_recid > last_orl_recid OR last_orl_recid IS NULL) THEN
    deb('beginOnlineRedoLogResync - Catalog orl_recid: '||last_orl_recid);
    deb('beginOnlineRedoLogResync - High orl_recid: '||high_orl_recid);
    last_orl_recid := high_orl_recid;
 
    OPEN orlQ;
    fetchOrl;
    last_fname := chr(1);           -- assume chr(1) is less than any name
 
    if resync_reason = RESYNC_REASON_ORL then
      fullResyncAction.active  := TRUE;
      fullResyncAction.valid   := TRUE;
      fullResyncAction.objtype := RESYNC_OBJECT_ONLINELOG;
    else
      fullResyncAction.active := FALSE;
    end if;
 
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
END beginOnlineRedoLogResync;
 
PROCEDURE checkOnlineRedoLog(
  thread#        IN NUMBER
 ,group#         IN NUMBER
 ,fname          IN VARCHAR2
 ,bytes          IN NUMBER   DEFAULT NULL
 ,type           IN VARCHAR2 DEFAULT 'ONLINE'
) IS
BEGIN
  IF (orlRec.fname IS NULL) THEN
    raise_application_error(-20061, 'Redo resync not started');
  END IF;
  IF (nlsnamecmp(last_fname, fname) >= 0) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
  last_fname := fname;
 
  WHILE (nlsnamecmp(fname, orlRec.fname) > 0) LOOP
--
--
--
    dropOrl(orlRec.fname);
    incResyncActions(RESYNC_ACTION_DROP, to_number(NULL), orlRec.fname);
    fetchOrl;
  END LOOP;
  IF (nlsnamecmp(fname, orlRec.fname) < 0) THEN
--
    addOrl(thread#, group#, fname, bytes, type);
    incResyncActions(RESYNC_ACTION_ADD, to_number(NULL), fname);
  ELSE -- (fname = orlRec.fname)
    UPDATE orl SET
      thread# = checkOnlineRedoLog.thread#,
      group#  = checkOnlineRedoLog.group#,
      bytes   = checkOnlineRedoLog.bytes,
      type    = checkOnlineRedoLog.type
    WHERE orl.dbinc_key = this_dbinc_key
    AND   orl.fname = checkOnlineRedoLog.fname
    AND   orl.site_key = this_site_key;
    incResyncActions(RESYNC_ACTION_CHANGE, to_number(NULL), orlRec.fname);
    fetchOrl;
  END IF;
END checkOnlineRedoLog;
 
PROCEDURE endOnlineRedoLogResync IS
BEGIN
  WHILE (orlRec.fname != chr(255)) LOOP
--
--
--
    dropOrl(orlRec.fname);
    incResyncActions(RESYNC_ACTION_DROP, to_number(NULL), orlRec.fname);
    fetchOrl;
  END LOOP;
 
  orlRec.fname := NULL;
 
--
  UPDATE node SET high_orl_recid = last_orl_recid
  WHERE site_key = this_site_key;
 
  last_orl_recid := NULL;
END endOnlineRedoLogResync;
 
/*---------------------------------*
 * Guaranteed restore point Resync *
 *---------------------------------*/
 
PROCEDURE fetchGrsp IS
BEGIN
  FETCH grspQ INTO grspRec;
  IF grspQ%NOTFOUND THEN
    grspRec.rspname := chr(255);  -- assume chr(255) is greater than any name
    grspRec.pdb_key := null;
    CLOSE grspQ;
  END IF;
END fetchGrsp;
 
PROCEDURE addGrsp(
  rspname        IN VARCHAR2
 ,from_scn       IN NUMBER
 ,to_scn         IN NUMBER
 ,dbinc_key      IN NUMBER
 ,create_time    IN DATE
 ,rsp_time       IN DATE
 ,guaranteed     IN VARCHAR2
 ,pdb_key        IN NUMBER
 ,clean          IN VARCHAR2
) IS
 
BEGIN
  INSERT INTO grsp
    (dbinc_key, rspname, from_scn, to_scn, creation_time, rsptime, 
     guaranteed, site_key, pdb_key, clean)
  VALUES
    (dbinc_key, rspname, from_scn, to_scn, create_time, rsp_time,
     guaranteed, this_site_key, pdb_key, clean);
END addGrsp;
 
PROCEDURE dropGrsp(
  rspname   IN VARCHAR2
 ,pdb_key   IN NUMBER) IS
BEGIN
  DELETE FROM grsp
  WHERE grsp.rspname = dropGrsp.rspname
    AND grsp.site_key = this_site_key
    AND grsp.pdb_key = dropGrsp.pdb_key;
END dropGrsp;
 
FUNCTION beginGuaranteedRPResync(
  high_grsp_recid IN NUMBER
) RETURN BOOLEAN IS
BEGIN
  checkResync;
 
  SELECT node.high_grsp_recid INTO last_grsp_recid
  FROM node
  WHERE site_key = this_site_key;
 
  IF (high_grsp_recid = last_grsp_recid) THEN
    RETURN FALSE;
  ELSIF (high_grsp_recid > last_grsp_recid OR last_grsp_recid IS NULL) THEN
    last_grsp_recid := high_grsp_recid;
 
    OPEN grspQ;
    fetchGrsp;
    last_rspname := chr(1);           -- assume chr(1) is less than any name
    last_pdb_key := -1;
    RETURN TRUE;
  ELSE
    raise_application_error(-20035, 'Invalid high recid');
  END IF;
 
END beginGuaranteedRPResync;
 
PROCEDURE checkGuaranteedRP(
  rspname            IN VARCHAR2
 ,from_scn           IN NUMBER
 ,to_scn             IN NUMBER
 ,resetlogs_change#  IN NUMBER
 ,resetlogs_time     IN DATE
 ,create_time        IN DATE DEFAULT NULL
 ,rsp_time           IN DATE DEFAULT NULL
 ,guaranteed         IN VARCHAR2 DEFAULT 'YES'
 ,con_id             IN NUMBER   DEFAULT NULL
 ,clean              IN VARCHAR2 DEFAULT 'NO'
) IS
   dbinc_key     number;
   local_pdb_key number;
BEGIN
  IF (grspRec.rspname IS NULL) THEN
    raise_application_error(-20099, 'restore point resync not started');
  END IF;
 
  dbinc_key := checkIncarnation(resetlogs_change#, resetlogs_time);
 
--
--
  SELECT pdb.pdb_key INTO local_pdb_key
    FROM pdb, pdb_dbinc
   WHERE pdb_dbinc.drop_scn IS NULL
     AND pdb.con_id IN
         (checkGuaranteedRP.con_id,
          0, 
          decode(checkGuaranteedRP.con_id, 0, 1))
     AND pdb.pdb_key         = pdb_dbinc.pdb_key
     AND pdb_dbinc.dbinc_key = this_dbinc_key;
 
  IF (nlsnamecmp(last_rspname, rspname) >= 0 AND
      (last_pdb_key = local_pdb_key)) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
  last_rspname := rspname;
  last_pdb_key := local_pdb_key;
 
  WHILE (grspRec.pdb_key != local_pdb_key) LOOP
--
--
--
    dropGrsp(grspRec.rspname, grspRec.pdb_key);
    fetchGrsp;
  END LOOP;
 
  WHILE (grspRec.pdb_key = local_pdb_key AND
         nlsnamecmp(rspname, grspRec.rspname) > 0) LOOP
--
--
--
    dropGrsp(grspRec.rspname, grspRec.pdb_key);
    fetchGrsp;
  END LOOP;
 
  IF (grspRec.pdb_key != local_pdb_key OR
      nlsnamecmp(rspname, grspRec.rspname) < 0) THEN
--
    addGrsp(rspname, from_scn, to_scn, dbinc_key, create_time, rsp_time,
            guaranteed, local_pdb_key, clean);
  ELSE -- (rspname = grspRec.rspname)
--
    UPDATE grsp SET
      from_scn = checkGuaranteedRP.from_scn,
      to_scn = checkGuaranteedRP.to_scn,
      rsptime = checkGuaranteedRP.rsp_time,
      guaranteed = checkGuaranteedRP.guaranteed,
      dbinc_key = dbinc_key
    WHERE grsp.rspname = checkGuaranteedRP.rspname
      AND grsp.site_key = this_site_key
      AND grsp.pdb_key = local_pdb_key;
 
    fetchGrsp;
  END IF;
END checkGuaranteedRP;
 
PROCEDURE endGuaranteedRPResync IS
BEGIN
  WHILE (grspRec.rspname != chr(255)) LOOP
--
--
    dropGrsp(grspRec.rspname, grspRec.pdb_key);
    fetchGrsp;
  END LOOP;
 
  grspRec.rspname := NULL;
   
--
  UPDATE node SET high_grsp_recid = last_grsp_recid
  WHERE site_key = this_site_key;
      
  last_grsp_recid := NULL;
END endGuaranteedRPResync;
 
 
/*-----------------------------------*
 * RMAN Configuration records resync *
 *-----------------------------------*/
 
FUNCTION beginConfigResync(
  high_conf_recid IN NUMBER
) RETURN NUMBER IS
 
BEGIN
  checkResync;
 
  SELECT high_conf_recid INTO last_conf_recid
  FROM   node
  WHERE  site_key = this_site_key;
 
  IF (high_conf_recid = last_conf_recid)
  THEN
    RETURN CONFIGRESYNC_NO;                                -- no resync needed
  ELSIF (last_conf_recid IS NULL OR high_conf_recid > last_conf_recid)
  THEN
    last_conf_recid := high_conf_recid;
    RETURN CONFIGRESYNC_TORC;                   -- we need resync from CF to RC
  ELSE
    last_conf_recid := high_conf_recid;
    RETURN CONFIGRESYNC_TOCF;                   -- we need resync from RC to CF
  END IF;
 
END beginConfigResync;
 
PROCEDURE endConfigResync IS
BEGIN
 
--
  UPDATE node SET high_conf_recid = last_conf_recid
  WHERE site_key = this_site_key;
 
  last_conf_recid := NULL;
 
END endConfigResync;
 
FUNCTION beginConfigResync2(
  high_conf_recid IN     NUMBER
) RETURN NUMBER IS
  to_CF                 boolean := FALSE;
  to_Catalog            boolean := FALSE;
  local_force_resync2cf VARCHAR2(3) := 'NO';
  curr_cf_version_time  DATE;
  conf_count            NUMBER;
BEGIN
 
  checkResync;
 
  SELECT node.high_conf_recid, node.force_resync2cf, cf_create_time
  INTO   last_conf_recid,      local_force_resync2cf, curr_cf_version_time
  FROM   node
  WHERE  site_key = this_site_key;
 
--
  IF (local_force_resync2cf = 'YES')
  THEN
     to_CF := TRUE;
  END IF;
 
--
--
  IF (last_cf_version_time is NULL) THEN
     SELECT COUNT(*) INTO conf_count FROM CONF
        WHERE site_key = this_site_key;
     IF conf_count = 0 THEN
        to_Catalog := TRUE;
     END IF;
  END IF;
 
--
--
--
--
  IF (last_cf_version_time <> curr_cf_version_time) THEN
     IF (this_cf_type = 'CURRENT') THEN
        IF high_conf_recid > last_conf_recid THEN
           to_Catalog := TRUE;
        ELSIF (high_conf_recid < last_conf_recid) THEN
           to_CF := TRUE;
        END IF;
     ELSE
        to_CF := TRUE;
     END IF;
  END IF;
 
--
--
--
--
--
  IF (last_cf_version_time = curr_cf_version_time) THEN
     IF (high_conf_recid > last_conf_recid) THEN
        to_Catalog := TRUE;
     ELSIF (high_conf_recid < last_conf_recid) THEN
        to_CF := TRUE;
     END IF;
  END IF;
 
--
--
  IF (NOT to_Catalog AND NOT to_CF)
  THEN
     RETURN CONFIGRESYNC_NO;
  END IF;
 
--
--
  last_conf_recid     := high_conf_recid;
 
--
  IF (NOT to_Catalog AND to_CF) THEN
     RETURN CONFIGRESYNC_TOCF;
  END IF;
 
--
  IF (to_Catalog AND NOT to_CF) THEN
     RETURN CONFIGRESYNC_TORC;
  END IF;
 
--
--
  IF (to_Catalog AND to_CF) THEN
     RETURN CONFIGRESYNC_TORC_TOCF;
  END IF;
 
END beginConfigResync2;
 
PROCEDURE endConfigResync2(sync_to_cf_pending IN boolean DEFAULT FALSE) IS
   cf_pending number := 0;
BEGIN
 
  IF sync_to_cf_pending THEN
    cf_pending := 1;
  END IF;
 
  IF (force_resync2cf = 'YES') THEN
    deb('endConfigResync2 - force_resync2cf = TRUE');
--
--
    UPDATE node SET node.force_resync2cf = 'YES'
      WHERE node.db_key = this_db_key
        AND site_key <> this_site_key;
  END IF;
 
--
--
--
--
--
  UPDATE node SET node.high_conf_recid = last_conf_recid,
                  node.force_resync2cf = decode(cf_pending, 1, 'YES', 'NO')
  WHERE site_key = this_site_key;
 
  deb('endConfigResync2 - last_conf_recid='||last_conf_recid);
 
  force_resync2cf := 'NO';
  last_conf_recid := NULL;
 
END endConfigResync2;
 
PROCEDURE getConfig(
   conf#          OUT    number
  ,name           IN OUT varchar2
  ,value          IN OUT varchar2
  ,first          IN     boolean)
IS
   eof          boolean := FALSE;
BEGIN
 
--
--
   dbms_rcvman.getConfig(conf#, name, value, first);
 
END getConfig;
 
PROCEDURE getRmanOutputLogging(days OUT number)
IS
  conf_value             varchar2(512);
  conf_name              varchar2(512) := 'RMAN OUTPUT';
  conf#                  binary_integer;
  len1                   binary_integer;
  len2                   binary_integer;
  len3                   binary_integer;
BEGIN
  deb('Entering getRmanOutputLogging');
  days := 0;
  dbms_rcvman.getConfig(conf#, conf_name, conf_value, TRUE);
 
  len1 := length('TO KEEP FOR ');
  len2 := length(' DAYS');
  len3 := length(conf_value);
  days := to_number(substr(conf_value, len1, len3-len2-len1+1));
  deb('getRmanOutputLogging - days = '||days);
 
EXCEPTION
  WHEN no_data_found THEN
    deb('getRmanOutputLogging - config not set, taking default');
    days := 7;
 
END getRmanOutputLogging;
 
PROCEDURE setKeepOutputForSession(days IN number)
IS
BEGIN
  deb('setKeepOutputForSession - session_keep_output = ' || days);
  session_keep_output := days;
END setKeepOutputForSession;
 
PROCEDURE updateRestorePoint(
  lowscn  IN NUMBER
 ,highscn IN NUMBER DEFAULT NULL -- next scn by another name
) IS
  nextscn number;
  refs number;
BEGIN
--
  IF (highscn is null) THEN
    nextscn := lowscn + 1;
  ELSE
    nextscn := highscn;
  END IF;
 
--
--
  UPDATE nrsp r SET LONG_TERM = NULL
  WHERE r.to_scn >= lowscn AND r.to_scn <= nextscn
    AND r.long_term IS NOT NULL
    AND r.site_key = this_site_key;
  deb('updateRestorePoint - (lowscn ' || lowscn || ' - highscn ' || nextscn ||
      ') rows updated ' || sql%rowcount);
END updateRestorePoint;
 
/*-------------------------*
 * Redo Log History resync *
 *-------------------------*/
 
FUNCTION beginLogHistoryResync RETURN NUMBER IS
 
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
--
--
     SELECT high_rlh_recid INTO last_rlh_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_rlh_recid := sessionWaterMarks.high_rlh_recid;
  END IF;
 
  RETURN last_rlh_recid;
 
END beginLogHistoryResync;
 
FUNCTION getLogHistoryLowSCN RETURN NUMBER IS
   lowSCN  number;
BEGIN
   checkResync;
   SELECT nvl(max(low_scn), 0)
     INTO lowSCN
     FROM rlh
    WHERE rlh.dbinc_key = this_dbinc_key;
   RETURN lowSCN;
END getLogHistoryLowSCN;
 
PROCEDURE checkLogHistory(
  rlh_recid   IN NUMBER
 ,rlh_stamp   IN NUMBER
 ,thread#     IN NUMBER
 ,sequence#   IN NUMBER
 ,low_scn     IN NUMBER
 ,low_time    IN DATE
 ,next_scn    IN NUMBER
 ,reset_scn   IN number default NULL
 ,reset_time  IN date default NULL
) IS
 
local   rlh%rowtype;
 
BEGIN
  IF (last_rlh_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (rlh_recid < last_rlh_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (rlh_recid > last_rlh_recid + 1) THEN
--
--
    NULL;
  END IF;
  last_rlh_recid := rlh_recid;
 
  IF (last_dbinc_key is NULL or reset_scn is NULL) THEN
     deb('checkLogHistory - Init last_dbinc_key');
     last_dbinc_key := this_dbinc_key;
     select reset_scn, reset_time into last_reset_scn, last_reset_time
        from dbinc
        where dbinc_key = this_dbinc_key;
  END IF;
 
  IF (reset_scn IS NOT NULL and reset_time IS NOT NULL) THEN
    IF (reset_scn <> last_reset_scn or reset_time <> last_reset_time) THEN
      BEGIN
         deb('checkLogHistory - new last_dbinc_key');
         deb('checkLogHistory - for reset_time ' || checkLogHistory.reset_time
             || ' reset_scn ' || checkLogHistory.reset_scn
             || ' this_db_key ' || this_db_key);
         select dbinc_key into last_dbinc_key from dbinc
           where reset_time = checkLogHistory.reset_time and
                 reset_scn = checkLogHistory.reset_scn and
                 db_key = this_db_key;
         last_reset_scn := reset_scn;
         last_reset_time := reset_time;
      EXCEPTION
      WHEN others THEN
         raise_application_error(-29999, 'Unknown Incarnation');
      END;
    END IF;
  END IF;
 
  deb('checkLogHistory - last_dbinc_key='||last_dbinc_key||
      ' reset_scn '||reset_scn || ' reset_time '||reset_time);
 
  BEGIN
    INSERT INTO rlh(
       rlh_key, dbinc_key, rlh_recid, rlh_stamp, thread#, sequence#,
       low_scn, low_time, next_scn)
    VALUES(
       rman_seq.nextval, last_dbinc_key, rlh_recid, rlh_stamp,
       thread#, sequence#, low_scn, low_time, next_scn);
  EXCEPTION
    WHEN dup_val_on_index THEN
--
--
      RETURN;
  END;
END checkLogHistory;
 
PROCEDURE endLogHistoryResync IS
 
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
--
     UPDATE node SET high_rlh_recid = last_rlh_recid
     WHERE site_key = this_site_key;
  END IF;
 
  last_rlh_recid := NULL;
 
END endLogHistoryResync;
 
/*-------------------------*
 * Archived Log resync     *
 *-------------------------*/
 
FUNCTION beginArchivedLogResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_al_recid INTO last_al_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_al_recid := sessionWaterMarks.high_al_recid;
  END IF;
 
  RETURN last_al_recid;
END beginArchivedLogResync;
 
PROCEDURE deleteDuplicateAL(recid IN NUMBER,
                            stamp IN NUMBER,
                            fname in VARCHAR2) IS
   lfname al.fname%TYPE;
BEGIN
   
   lfname := fname;
   IF lfname is null THEN
      BEGIN
         SELECT fname INTO lfname from AL 
         WHERE al_recid = recid
           AND al_stamp = stamp
           AND al.dbinc_key in 
               (select dbinc_key from dbinc where db_key = this_db_key);
      EXCEPTION
         WHEN no_data_found THEN
            RETURN;
         WHEN too_many_rows THEN -- unique key is dbinc_key, al_recid, al_stamp
            RETURN;
      END;
   END IF;
 
--
--
   DELETE al
   WHERE al.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
     AND al.fname    = lfname
     AND ((nvl(al.site_key, this_site_key) = this_site_key) OR
          (logs_shared = TRUE#))
     AND al.fname_hashkey = substr(lfname,1,10)||substr(lfname,-10)
     AND NOT  (al.al_recid = recid AND
               al.al_stamp = stamp );
 
END deleteDuplicateAL;
 
PROCEDURE checkArchivedLog(
  al_recid    IN NUMBER
 ,al_stamp    IN NUMBER
 ,thread#     IN NUMBER
 ,sequence#   IN NUMBER
 ,reset_scn   IN NUMBER
 ,reset_time  IN DATE
 ,low_scn     IN NUMBER
 ,low_time    IN DATE
 ,next_scn    IN NUMBER
 ,next_time   IN DATE
 ,blocks      IN NUMBER
 ,block_size  IN NUMBER
 ,fname       IN VARCHAR2
 ,archived    IN VARCHAR2
 ,completion_time IN DATE
 ,status      IN VARCHAR2
 ,is_standby  IN VARCHAR2
 ,dictionary_begin      IN VARCHAR2   default NULL
 ,dictionary_end        IN VARCHAR2   default NULL
 ,is_recovery_dest_file IN VARCHAR2   default 'NO'
 ,compressed            IN VARCHAR2   default 'NO'
 ,creator               IN VARCHAR2   default NULL
 ,terminal              IN VARCHAR2   default 'NO'
 ,chk_last_recid        IN boolean    default TRUE
) IS
 
local  al%rowtype;
my_dbinc_key NUMBER;
 
BEGIN
--
--
  IF chk_last_recid THEN
     IF (last_al_recid IS NULL) THEN
       raise_application_error(-20037, 'Invalid last recid');
     END IF;
 
     IF (al_recid < last_al_recid) THEN
       raise_application_error(-20036, 'Invalid record order');
     END IF;
 
     IF (al_recid > last_al_recid + 1) THEN
--
--
       NULL;
     END IF;
     last_al_recid := al_recid;
  END IF;
 
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
  IF (al_stamp > 0 and al_stamp < kccdivts) THEN
     deb('checkArchivedLog - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
--
  IF (sequence# = 0) THEN
    RETURN;
  END IF;
 
--
--
--
  my_dbinc_key := checkIncarnation(reset_scn, reset_time);
 
  BEGIN
    IF (status = 'D') THEN
--
       NULL;
    ELSE
       INSERT INTO al
         (al_key, dbinc_key, al_recid, al_stamp, thread#, sequence#,
          low_scn, low_time, next_scn, next_time,
          fname, fname_hashkey, archived, blocks, block_size,
          completion_time, status, is_standby,
          dictionary_begin, dictionary_end, is_recovery_dest_file, 
          compressed, creator, terminal, site_key)
       VALUES
         (rman_seq.nextval, my_dbinc_key, al_recid, al_stamp, thread#,
          sequence#, low_scn, low_time, next_scn, next_time,
          fname, substr(fname,1,10)||substr(fname, -10),
          archived, blocks, checkArchivedLog.block_size, completion_time,
          status, is_standby, dictionary_begin, dictionary_end,
          is_recovery_dest_file, compressed, creator, terminal, this_site_key);
 
       deleteDuplicateAL(al_recid, al_stamp, fname);
    END IF;
 
--
--
--
--
    IF checkArchivedLog.archived = 'N' then
       UPDATE rlh SET
         status = decode(fname, NULL, 'C', status)
       WHERE rlh.dbinc_key = my_dbinc_key
       AND   rlh.thread#   = checkArchivedLog.thread#
       AND   rlh.sequence# = checkArchivedLog.sequence#
       AND   rlh.low_scn   = checkArchivedLog.low_scn;
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('checkArchivedLog - Inside dup_val_on_index exception');
--
--
      SELECT * INTO local
      FROM al
        WHERE al.dbinc_key = my_dbinc_key
        AND   (al.is_standby = checkArchivedLog.is_standby OR
                 (al.is_standby is NULL AND 
                  checkArchivedLog.is_standby is NULL))
        AND   al.al_recid = checkArchivedLog.al_recid
        AND   al.al_stamp = checkArchivedLog.al_stamp;
 
--
      IF client_site_aware AND this_site_key <> local.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (fname <> local.fname) THEN
        deb('checkArchivedLog - input fname ['||fname||']; local.fname ['|| 
            local.fname || ']');
        raise_application_error(-20080, 'Invalid archived log name');
       
      END IF;
  END;
 
END checkArchivedLog;
 
PROCEDURE endArchivedLogResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_al_recid = last_al_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_al_recid := last_al_recid;
  last_al_recid := NULL;
 
END endArchivedLogResync;
 
/*-------------------------*
 * Offline range resync    *
 *-------------------------*/
 
FUNCTION beginOfflineRangeResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_offr_recid INTO last_offr_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_offr_recid := sessionWaterMarks.high_offr_recid;
  END IF;
 
  RETURN last_offr_recid;
END beginOfflineRangeResync;
 
PROCEDURE checkOfflineRange(
  offr_recid     IN NUMBER
 ,offr_stamp     IN NUMBER
 ,file#          IN NUMBER
 ,create_scn     IN NUMBER
 ,offline_scn    IN NUMBER
 ,online_scn     IN NUMBER
 ,online_time    IN DATE
 ,cf_create_time IN DATE
 ,reset_scn      IN number default NULL
 ,reset_time     IN date default NULL
) IS
 
   local   offr%rowtype;
 
--
--
BEGIN
  IF (last_offr_recid IS NULL AND offr_recid IS NOT NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  deb('Checkofflinerange - '||
      ' recid: '||           nvl(to_char(offr_recid), 'NULL')||
      ' stamp: '||           nvl(to_char(offr_stamp), 'NULL')||
      ' file#: '||           file#||
      ' create_scn: '||      nvl(to_char(create_scn), 'NULL')||
      ' offline_scn: '||     offline_scn ||
      ' online_scn: '||      online_scn||
      ' online_time: '||     online_time||
      ' cf_create_time: '||  cf_create_time||
      ' reset_scn:'||        nvl(reset_scn, -1));
 
  last_offr_recid := offr_recid;
 
  IF (last_dbinc_key is NULL OR reset_scn IS NULL) THEN
     deb('checkOfflineRange - Init dbinc_key: '||this_dbinc_key);
     last_dbinc_key := this_dbinc_key;
     SELECT reset_scn, reset_time
       INTO last_reset_scn, last_reset_time
       FROM dbinc
      WHERE dbinc_key = this_dbinc_key;
  END IF;
 
  IF (reset_scn IS NOT NULL and reset_time IS NOT NULL) THEN
    IF (reset_scn <> last_reset_scn or reset_time <> last_reset_time) THEN
      BEGIN
         deb('checkOfflineRange - new incarnation detected'||
             ' reset_scn: '||      reset_scn||
             ' last_reset_scn: '|| last_reset_scn);
         SELECT dbinc_key
           INTO last_dbinc_key
           FROM dbinc
          WHERE reset_time = checkOfflineRange.reset_time
            AND reset_scn  = checkOfflineRange.reset_scn
            AND db_key = this_db_key;
         last_reset_scn  := reset_scn;
         last_reset_time := reset_time;
      EXCEPTION
        WHEN others THEN
          raise_application_error(-20070, 'Unknown Incarnation');
      END;
    END IF;
  END IF;
 
  deb('checkOfflineRange - dbinc_key is: '||last_dbinc_key);
 
  deb('checkOfflineRange - Looking if offline range record already '||
      'exists in OFFR');
  BEGIN
--
    SELECT distinct file#, create_scn, offline_scn,
           online_scn, online_time
      INTO local.file#, local.create_scn, local.offline_scn,
           local.online_scn, local.online_time
      FROM offr
      WHERE dbinc_key      = last_dbinc_key
        AND file#          = checkOfflineRange.file#
        AND create_scn     = checkOfflineRange.create_scn
        AND offline_scn    = checkOfflineRange.offline_scn;
 
    IF local.online_scn <> checkOfflineRange.online_scn THEN
      deb('checkOfflineRange - Online_scn OK?'||
          ' online_scn: '       || online_scn ||
          ' local.online_scn: ' || local.online_scn);
--
    END IF;
 
    IF local.online_time <> checkOfflineRange.online_time THEN
      deb('checkOfflineRange - Online_time OK?'||
          ' online_time: '       || online_time ||
          ' local.online_time: ' || local.online_time);
--
    END IF;
 
  EXCEPTION
    WHEN no_data_found THEN
      NULL; -- offline range record not yet known to catalog, go to insert
 
    WHEN too_many_rows THEN
      RAISE;      -- there must not be more then on offline range with same
--
    WHEN others THEN
      RAISE;
  END;
 
  BEGIN
    INSERT INTO
      offr(offr_key, dbinc_key, offr_recid, offr_stamp,
           file#, create_scn, offline_scn, online_scn,
           online_time, cf_create_time)
      VALUES(rman_seq.nextval, last_dbinc_key, offr_recid, nvl(offr_stamp,0),
             file#, create_scn, offline_scn, online_scn,
             online_time, cf_create_time);
    incResyncActions(RESYNC_ACTION_CHANGE, file#, to_char(NULL));
    deb('checkOfflineRange - Succesfully inserted new OFFR.');
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('checkOfflineRange - record already exists');
      IF offr_recid > 0 AND offr_stamp > 0 THEN
        deb('checkOfflineRange - update new offr_recid, offr_stamp, '||
            'online_scn and online_time');
        UPDATE OFFR
            SET offr_recid = checkOfflineRange.offr_recid,
                offr_stamp = checkOfflineRange.offr_stamp,
                online_scn = checkOfflineRange.online_scn,
                online_time= checkOfflineRange.online_time
          WHERE dbinc_key      = last_dbinc_key
            AND file#          = checkOfflineRange.file#
            AND create_scn     = checkOfflineRange.create_scn
            AND offline_scn    = checkOfflineRange.offline_scn
            AND cf_create_time = checkOfflineRange.cf_create_time;
        incResyncActions(RESYNC_ACTION_CHANGE, file#, to_char(NULL));
      END IF;
  END;
 
  deb('checkOfflineRange - exiting');
END;
 
PROCEDURE endOfflineRangeResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_offr_recid = last_offr_recid
     WHERE site_key = this_site_key;
  END IF;
 
--
  IF this_is_ors and this_ckp_type = 'FULL' THEN
     UPDATE watermarks SET high_offr_recid = last_offr_recid
     WHERE db_key = this_db_key;
  END IF;
 
  sessionWaterMarks.high_offr_recid := last_offr_recid;
  last_offr_recid := NULL;
 
END endOfflineRangeResync;
 
/*-------------------------*
 * Backup Set resync       *
 *-------------------------*/
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE updateBackupSetRec(bs_key IN NUMBER) IS
  total_pieces     NUMBER;
  backup_validate  VARCHAR2(3);
  available_pieces NUMBER;
  new_status       VARCHAR2(1);
  bskeep           NUMBER;
  bstype           VARCHAR2(1);
  low              NUMBER := NULL;
  high             NUMBER := NULL;
  bs_site_key      NUMBER := NULL;
  not_purged       NUMBER := 0;
  pieces_on_msite  NUMBER;
  new_site_key     NUMBER;
  need_resync      NUMBER := 0;
  dbkey            NUMBER;
  incr_lvl         NUMBER;
  ra_node_count    NUMBER;
BEGIN
  deb('updateBackupSetRec, bs_key=' || bs_key);
--
--
  BEGIN
    SELECT pieces,input_file_scan_only, keep_options, bck_type, site_key,
           incr_level, db_key
    INTO total_pieces,backup_validate, bskeep, bstype, bs_site_key,
         incr_lvl, dbkey
    FROM bs
    WHERE bs.bs_key = updateBackupSetRec.bs_key;
  EXCEPTION
    WHEN no_data_found THEN
       new_status := 'D'; -- all pieces are deleted or not there
  END;
 
  IF nvl(backup_validate,'NO') <> 'YES' THEN
    SELECT max(count(DISTINCT piece#)) INTO available_pieces
    FROM  bp
    WHERE bp.bs_key = updateBackupSetRec.bs_key
    AND   bp.status = 'A'
    GROUP BY device_type;
 
    SELECT count(*) INTO not_purged
      FROM bp
     WHERE bp.bs_key = updateBackupSetRec.bs_key
       AND bp.purged = 'N'
       AND bp.ba_access IN ('L', 'D');
  END IF;
 
--
  IF bs_site_key IS NULL OR bs_site_key <> this_site_key THEN
    SELECT count(distinct nvl(site_key, 0)) INTO pieces_on_msite
      FROM bp
      WHERE bs_key = updateBackupSetRec.bs_key;
    IF pieces_on_msite = 1 THEN
       SELECT distinct site_key  INTO new_site_key
       FROM BP
       WHERE bs_key = updateBackupSetRec.bs_key;
    END IF;
--
    UPDATE bs SET site_key = new_site_key
    WHERE bs.bs_key = updateBackupSetRec.bs_key;
  END IF;
 
  deb('updateBackupSetRec, total_piece='||total_pieces||
      ', available_pieces='||available_pieces||
      ', not_purged='||not_purged);
  IF (total_pieces = 0 or backup_validate = 'YES') THEN
--
    new_status := 'D';
  ELSIF (available_pieces = total_pieces) THEN
    new_status := 'A';
  ELSE
    BEGIN
--
       SELECT 'O' INTO new_status FROM bp
        WHERE bp.bs_key = updateBackupSetRec.bs_key
          AND bp.status != 'D'
          AND rownum < 2;
    EXCEPTION WHEN no_data_found THEN
       new_status := 'D'; -- all pieces are deleted or not there
    END;
  END IF;
 
  deb('updateBackupSetRec, new_status='||new_status||',val='||backup_validate);
  IF (new_status in ('O', 'A') OR
      backup_validate = 'YES'  OR
      not_purged != 0) THEN
     UPDATE bs SET status = new_status
      WHERE bs.bs_key = updateBackupSetRec.bs_key;
  ELSE
--
     IF (bskeep > 0 and bstype = 'L') THEN
       SELECT min(low_scn), max(next_scn) INTO low, high
       FROM brl
       WHERE bs_key = updateBackupSetRec.bs_key;
     END IF;
     IF (bskeep > 0 and bstype = 'D') THEN
        SELECT min(ckp_scn) INTO low
        FROM bdf
        WHERE bs_key = updateBackupSetRec.bs_key;
     END IF;
    
--
--
--
     IF (this_is_ors
         AND incr_lvl IS NOT NULL 
         AND this_enable_populate_rsr = 1) THEN
       BEGIN 
--
--
         IF this_upstream_site_key IS NULL THEN
           SELECT site_key INTO this_upstream_site_key
           FROM   node
           WHERE  node.db_key = dbkey AND
                  database_role = 'RA' AND
                  db_unique_name like '$%$%' AND
                  db_unique_name not like '$%$%$%';
          END IF;
 
          deb('updateBackupSetRec, this_upstream_site_key = ' || 
                                   this_upstream_site_key);
--
--
          SELECT count(*) INTO need_resync
          FROM   bp
          WHERE  bs_key     =  updateBackupSetRec.bs_key
          AND    ((ba_access = 'L' AND vb_key IS NULL 
                   AND substr(handle,1,6) != 'RA_SBT')
--
--
                  OR (ba_access = 'D' AND rsr_key IS NULL))
--
--
--
          AND    site_key = this_upstream_site_key;
       EXCEPTION
          WHEN no_data_found THEN
            deb('updateBackupSetRec, node table has no RA rows with db_key '
                                                             || dbkey);
       END;
     END IF;
 
     IF need_resync = 0 THEN
--
--
       deb('updateBackupSetRec, deleting rows from BP and BS for bs_key=' || 
                                updateBackupSetRec.bs_key); 
       DELETE from bp WHERE bp.bs_key = updateBackupSetRec.bs_key;
       deb('updateBackupSetRec, deleted rows from bp =' || SQL%ROWCOUNT);
       DELETE FROM bs WHERE bs.bs_key = updateBackupSetRec.bs_key;
       deb('updateBackupSetRec, deleted rows from bs =' || SQL%ROWCOUNT);
     ELSE
       deb('updateBackupSetRec, Skipping deletion of bs_key = ' || bs_key ||
            '. Waiting till resync happens to delete this.');
     END IF;
 
--
     IF (low IS NOT NULL) THEN
       updateRestorePoint(low, high);
     END IF;
  END IF;
END updateBackupSetRec;
 
FUNCTION beginBackupSetResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_bs_recid INTO last_bs_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_bs_recid := sessionWaterMarks.high_bs_recid;
  END IF;
 
  RETURN last_bs_recid;
END beginBackupSetResync;
 
PROCEDURE checkBackupSet(
  bs_recid             IN NUMBER
 ,bs_stamp             IN NUMBER
 ,set_stamp            IN NUMBER
 ,set_count            IN NUMBER
 ,bck_type             IN VARCHAR2
 ,incr_level           IN NUMBER         DEFAULT NULL
 ,pieces               IN NUMBER
 ,start_time           IN DATE
 ,completion_time      IN DATE
 ,controlfile_included IN VARCHAR2       DEFAULT NULL
 ,input_file_scan_only IN VARCHAR2       DEFAULT NULL
 ,keep_options         IN NUMBER         DEFAULT 0
 ,keep_until           IN DATE           DEFAULT NULL
 ,block_size           IN NUMBER         DEFAULT NULL
 ,multi_section        IN VARCHAR2       DEFAULT NULL
 ,chk_last_recid       IN BOOLEAN        DEFAULT TRUE
 ,guid                 IN RAW            DEFAULT NULL
 ,dropped_pdb          IN BINARY_INTEGER DEFAULT 0
) IS
 
local      bs%rowtype;
newbskey   number;
l_pdb_key  number;
 
BEGIN
  IF (chk_last_recid) THEN
     IF (last_bs_recid IS NULL) THEN
       raise_application_error(-20037, 'Invalid last recid');
     END IF;
 
     IF (bs_recid < last_bs_recid) THEN
       raise_application_error(-20036, 'Invalid record order');
     END IF;
 
     IF (bs_recid > last_bs_recid + 1) THEN
--
       NULL;
     END IF;
     last_bs_recid := bs_recid;
  END IF;
 
  IF (bs_stamp > 0 and bs_stamp < kccdivts) THEN
     deb('checkBackupSet - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
  IF (bck_type NOT IN ('D','I','L') OR bck_type IS NULL) THEN
    raise_application_error(-20090, 'Invalid backup set type');
  END IF;
 
  IF (incr_level NOT IN (0,1,2,3,4) OR
      (bck_type NOT IN ('D','I') AND incr_level <> 0)) THEN
    raise_application_error(-20091, 'Invalid backup set level');
  END IF;
 
  l_pdb_key := guidToPdbKey(guid, dropped_pdb);
 
  BEGIN
--
--
    INSERT INTO bs
      (bs_key, db_key, bs_recid, bs_stamp, set_stamp, set_count,
       bck_type, incr_level, pieces, start_time, completion_time, status,
       controlfile_included, input_file_scan_only, keep_options, keep_until,
       block_size, site_key, multi_section, pdb_key)
    VALUES
      (rman_seq.nextval, this_db_key, bs_recid, bs_stamp, set_stamp, set_count,
       bck_type, incr_level, pieces, start_time, completion_time, 'D',
       decode(controlfile_included, 'SBY','STANDBY','YES','BACKUP','NONE'),
       input_file_scan_only, keep_options, keep_until, block_size, 
       this_site_key, decode(multi_section,'YES','Y',null), l_pdb_key)
    RETURNING bs_key INTO newbskey;
 
    cntbs := cntbs + 1;
    updatebs(cntbs) := newbskey;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('checkBackupSet - Inside dup_val_on_index exception');
--
      SELECT * INTO local
      FROM bs
      WHERE bs.db_key = this_db_key
        AND bs.set_stamp = checkBackupSet.set_stamp
        AND bs.set_count = checkBackupSet.set_count;
  
      duplicatebs(local.bs_key) := 1;
 
--
--
--
      IF (pieces > local.pieces) THEN
        UPDATE bs
           SET bs.pieces = checkBackupSet.pieces
        WHERE bs.db_key = this_db_key
        AND bs.bs_key = local.bs_key;
 
--
        cntbs:= cntbs + 1;
        updatebs(cntbs) := local.bs_key;
      END IF;
 
--
--
--
--
 
--
--
      IF local.site_key IS NULL AND cntbs > 0 AND
         updatebs(cntbs) <> local.bs_key THEN
         cntbs := cntbs + 1;
         updatebs(cntbs) := local.bs_key;
      END IF;
 
      IF (local.completion_time <> checkBackupSet.completion_time) THEN
        UPDATE bs
           SET completion_time = checkBackupSet.completion_time
         WHERE bs.db_key = this_db_key
           AND bs.bs_key = local.bs_key;
      END IF;
  END;
END checkBackupSet;
 
PROCEDURE endBackupSetResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
--
     UPDATE node SET high_bs_recid = last_bs_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_bs_recid := last_bs_recid;
  last_bs_recid := NULL;
 
END endBackupSetResync;
 
 /*-------------------------*
 * Backup piece resync     *
 *-------------------------*/
 
FUNCTION beginBackupPieceResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_bp_recid INTO last_bp_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_bp_recid := sessionWaterMarks.high_bp_recid;
  END IF;
 
  RETURN last_bp_recid;
END beginBackupPieceResync;
 
PROCEDURE deleteDuplicateBP(recid IN NUMBER,
                            stamp IN NUMBER,
                            bs_key IN NUMBER,
                            device_type IN VARCHAR2,
                            handle      IN VARCHAR2) IS
   ldevice_type bp.device_type%TYPE;
   lhandle      bp.device_type%TYPE;
BEGIN
 
   ldevice_type := device_type;
   lhandle      := handle;
 
   IF ldevice_type IS NULL OR lhandle IS NULL THEN
      BEGIN
         SELECT device_type, handle INTO ldevice_type, lhandle FROM BP
         WHERE bp.db_key   = this_db_key
           AND bp_recid    = recid
           AND bp_stamp    = stamp
           AND ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
                (this_site_key = nvl(bp.site_key, this_site_key)))
           AND deleteDuplicateBP.bs_key = bp.bs_key;
      EXCEPTION
         WHEN no_data_found THEN
            RETURN;
         WHEN too_many_rows THEN -- unique key is bs_key, recid, stamp
            RETURN;
      END;
   END IF;
 
   IF this_is_ors AND this_ckp_key IS NULL THEN 
      this_enable_populate_rsr := 
                          getValueFromConfig('_enable_populate_rsr_key');
   END IF;
--
--
--
--
   FOR bprec IN bpq(ldevice_type, lhandle, recid, stamp) LOOP
      UPDATE bp SET bp.status = 'D' WHERE bp.bp_key = bprec.bp_key;
      updateBackupSetRec(bprec.bs_key);        -- update the backupset status
   END LOOP;
--
--
   IF this_is_ors AND this_ckp_key IS NULL THEN 
      this_enable_populate_rsr := NULL;
      this_upstream_site_key := NULL;
   END IF;
END deleteDuplicateBP;
 
PROCEDURE checkBackupPiece(
  bp_recid                IN NUMBER
 ,bp_stamp                IN NUMBER
 ,set_stamp               IN NUMBER
 ,set_count               IN NUMBER
 ,piece#                  IN NUMBER
 ,tag                     IN VARCHAR2
 ,device_type             IN VARCHAR2
 ,handle                  IN VARCHAR2
 ,comments                IN VARCHAR2
 ,media                   IN VARCHAR2
 ,concur                  IN VARCHAR2
 ,start_time              IN DATE
 ,completion_time         IN DATE
 ,status                  IN VARCHAR2
 ,copy#                   IN NUMBER         default 1
 ,media_pool              IN NUMBER         default 0
 ,bytes                   IN NUMBER         default NULL
 ,is_recovery_dest_file   IN VARCHAR2       default 'NO'
 ,rsr_recid               IN NUMBER         default NULL
 ,rsr_stamp               IN NUMBER         default NULL
 ,compressed              IN VARCHAR2       default 'NO'
 ,encrypted               IN VARCHAR2       default 'NO'
 ,backed_by_osb           IN VARCHAR2       default 'NO'
 ,ba_access               IN VARCHAR2       default 'U'
 ,vbkey                   IN NUMBER         default NULL
 ,chk_last_recid          IN BOOLEAN        default TRUE
 ,lib_key                 IN NUMBER         default NULL
 ,guid                    IN RAW            default NULL
 ,template_key            IN NUMBER         default NULL
 ,dropped_pdb             IN BINARY_INTEGER default 0
) IS
   bp_key NUMBER;
BEGIN
   bp_key := checkBackupPiece(
                bp_recid               => bp_recid
               ,bp_stamp               => bp_stamp
               ,set_stamp              => set_stamp
               ,set_count              => set_count
               ,piece#                 => piece#
               ,tag                    => tag
               ,device_type            => device_type
               ,handle                 => handle
               ,comments               => comments
               ,media                  => media
               ,concur                 => concur
               ,start_time             => start_time
               ,completion_time        => completion_time
               ,status                 => status
               ,copy#                  => copy#
               ,media_pool             => media_pool
               ,bytes                  => bytes
               ,is_recovery_dest_file  => is_recovery_dest_file
               ,rsr_recid              => rsr_recid
               ,rsr_stamp              => rsr_stamp
               ,compressed             => compressed
               ,encrypted              => encrypted
               ,backed_by_osb          => backed_by_osb
               ,ba_access              => ba_access
               ,vbkey                  => vbkey
               ,chk_last_recid         => chk_last_recid
               ,lib_key                => lib_key
               ,guid                   => guid
               ,template_key           => template_key
               ,dropped_pdb            => dropped_pdb);
END checkBackupPiece;
 
FUNCTION checkBackupPiece(
  bp_recid                IN NUMBER
 ,bp_stamp                IN NUMBER
 ,set_stamp               IN NUMBER
 ,set_count               IN NUMBER
 ,piece#                  IN NUMBER
 ,tag                     IN VARCHAR2
 ,device_type             IN VARCHAR2
 ,handle                  IN VARCHAR2
 ,comments                IN VARCHAR2
 ,media                   IN VARCHAR2
 ,concur                  IN VARCHAR2
 ,start_time              IN DATE
 ,completion_time         IN DATE
 ,status                  IN VARCHAR2
 ,copy#                   IN NUMBER         default 1   -- No longer in use
 ,media_pool              IN NUMBER         default 0
 ,bytes                   IN NUMBER         default NULL
 ,is_recovery_dest_file   IN VARCHAR2       default 'NO'
 ,rsr_recid               IN NUMBER         default NULL
 ,rsr_stamp               IN NUMBER         default NULL
 ,compressed              IN VARCHAR2       default 'NO'
 ,encrypted               IN VARCHAR2       default 'NO'
 ,backed_by_osb           IN VARCHAR2       default 'NO'
 ,ba_access               IN VARCHAR2       default 'U'
 ,vbkey                   IN NUMBER         default NULL
 ,chk_last_recid          IN BOOLEAN        default TRUE
 ,lib_key                 IN NUMBER         default NULL
 ,guid                    IN RAW            default NULL
 ,template_key            IN NUMBER         default NULL
 ,dropped_pdb             IN BINARY_INTEGER default 0
) RETURN NUMBER IS
   localbs  bs%rowtype;
   localbp  bp%rowtype;
   localrsr rsr%rowtype;
   piece_exists BINARY_INTEGER := 0;
   l_copyno NUMBER := 1;
   l_update_bs_pieces BOOLEAN := FALSE;
   l_pdb_key NUMBER;
   l_bp_recid NUMBER;
BEGIN
 
  IF (chk_last_recid) THEN
     IF (last_bp_recid IS NULL) THEN
       raise_application_error(-20037, 'Invalid last recid');
     END IF;
 
     IF (bp_recid < last_bp_recid) THEN
       deb('checkBackupPiece - last_bp_recid=' || last_bp_recid);
       raise_application_error(-20036, 'Invalid record order');
     END IF;
 
     IF (bp_recid > last_bp_recid + 1) THEN
--
--
       NULL;
     END IF;
     last_bp_recid := bp_recid;
  END IF;
 
  IF (bp_stamp > 0 and bp_stamp < kccdivts) THEN
     deb('checkBackupPiece - ignoring record kccdivts='||kccdivts);
     RETURN NULL;               -- obsolete record from a backup controlfile
  END IF;
 
--
  IF handle IS NULL AND status != 'D' THEN
     deb('checkBackupPiece - handle is null, ignore this row');
     RETURN NULL;
  END IF;
 
--
--
--
--
--
--
--
--
--
  IF bp_recid = 0 OR this_wmrec.high_bp_recid >= 0 THEN
     this_high_bp_recid := this_high_bp_recid + 1;
     l_bp_recid := this_high_bp_recid;
     deb('checkBackupPiece - generating bp_recid=' || l_bp_recid ||
         ', ba_access=' || ba_access || ',handle=' || handle);
  ELSE
     l_bp_recid := bp_recid;
  END IF;
 
--
--
--
 
  l_pdb_key := guidToPdbKey(guid, dropped_pdb);
 
--
  BEGIN
    SELECT * into localbs from bs
      WHERE bs.db_key = this_db_key
        AND   bs.set_stamp = checkBackupPiece.set_stamp
        AND   bs.set_count = checkBackupPiece.set_count FOR UPDATE OF bs.bs_key;
    deb('checkBackupPiece - locked bs_key' || localbs.bs_key);
    
    IF this_db_unique_name = upper(this_server.wallet_alias) THEN
      deb('checkBackupPiece - doing reconcile is TRUE');
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
    END IF;
 
  EXCEPTION
    WHEN no_data_found THEN
      IF status != 'D' THEN
        INSERT INTO bs
          (bs_key, db_key, bs_recid, bs_stamp,
           set_stamp, set_count,
           bck_type, incr_level, pieces, start_time, completion_time, status,
           controlfile_included, site_key, multi_section, pdb_key)
        VALUES
--
--
--
--
--
--
--
--
          (rman_seq.nextval, this_db_key, 0, checkBackupPiece.set_stamp,
          checkBackupPiece.set_stamp, checkBackupPiece.set_count,
          NULL, NULL, checkBackupPiece.piece#,
          checkBackupPiece.start_time, checkBackupPiece.completion_time, 'O',
          'NONE', this_site_key, NULL, l_pdb_key)
        RETURNING bs_key INTO localbs.bs_key;
 
        cntbs := cntbs + 1;
        updatebs(cntbs) := localbs.bs_key;
      ELSE
--
         RETURN NULL;
      END IF;
  END;
 
--
--
  IF (status = 'D') THEN
     cntbs:= cntbs + 1;
     updatebs(cntbs) := localbs.bs_key;
     RETURN NULL;
  END IF;
 
--
  IF (localbs.bs_recid is null OR localbs.bs_recid = 0) AND
    checkBackupPiece.piece# > localbs.pieces THEN
    l_update_bs_pieces := TRUE;
  ELSE
--
--
--
--
    SELECT NVL(MAX(copy#), 0)+1 INTO l_copyno
      FROM bp
      WHERE piece# = checkBackupPiece.piece#
      AND bs_key = localbs.bs_key;
  END IF;
 
--
  BEGIN
      SELECT rsr_key
        INTO localrsr.rsr_key
        FROM rsr
       WHERE rsr.dbinc_key = this_dbinc_key
         AND (rsr.site_key = this_site_key OR
              rsr.site_key is null AND this_site_key is NULL)
         AND rsr.rsr_stamp = checkBackupPiece.rsr_stamp
         AND rsr.rsr_recid = checkBackupPiece.rsr_recid;
  EXCEPTION
    WHEN no_data_found THEN
--
      NULL;
  END;
 
  SELECT MAX(bp_key) INTO localbp.bp_key
    FROM bp
   WHERE bp.handle                       = checkBackupPiece.handle
     AND bp.device_type                  = checkBackupPiece.device_type
     AND bp.bs_key                       = localbs.bs_key
     AND ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
          (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
          (this_site_key = nvl(bp.site_key, this_site_key)));
 
  BEGIN
     IF (localbp.bp_key IS NOT NULL) THEN
        UPDATE bp
           SET bp_recid              = l_bp_recid,
               bp_stamp              = checkBackupPiece.bp_stamp,
               comments              = checkBackupPiece.comments,
               media                 = checkBackupPiece.media,
               media_pool            = checkBackupPiece.media_pool,
               concur                = decode(checkBackupPiece.concur,
                                              'YES', 'Y', 'N'),
               start_time            = checkBackupPiece.start_time,
               completion_time       = checkBackupPiece.completion_time,
               bytes                 = checkBackupPiece.bytes,
               is_recovery_dest_file = checkBackupPiece.is_recovery_dest_file,
               rsr_key               = localrsr.rsr_key,
               site_key              = this_site_key,
               backed_by_osb         = decode(checkBackupPiece.backed_by_osb,
                                              'YES', 'Y', 'N')
         WHERE bp_key = localbp.bp_key;
     ELSE
--
--
--
        IF (this_is_ors             AND -- in ORS schema?
            ba_access = 'U'         AND -- record pushed by rman resync?
            isOrsMedia(checkBackupPiece.media)) THEN
           deb('checkBackupPiece - ORS media backup piece - skipping');
           cntbs:= cntbs + 1;
           updatebs(cntbs) := localbs.bs_key;
           RETURN NULL;
        END IF;
        INSERT INTO bp
           (bp_key, bs_key, piece#, db_key, bp_recid, bp_stamp, tag,
            device_type, copy#, handle, handle_hashkey, comments, media,
            media_pool, concur, start_time, completion_time, status, bytes,
            is_recovery_dest_file, rsr_key, compressed, site_key, encrypted,
            backed_by_osb, ba_access, vb_key, lib_key, purged, pdb_key,
            template_key)
        VALUES
           (rman_seq.nextval, localbs.bs_key, checkBackupPiece.piece#,
            this_db_key, l_bp_recid, checkBackupPiece.bp_stamp,
            checkBackupPiece.tag, checkBackupPiece.device_type,
            l_copyno, checkBackupPiece.handle,
            substr(checkBackupPiece.device_type,1,10) ||
            substr(checkBackupPiece.handle,1,10)      ||
            substr(checkBackupPiece.handle,-10),
            checkBackupPiece.comments, checkBackupPiece.media,
            checkBackupPiece.media_pool,
            decode(checkBackupPiece.concur,'YES','Y','N'),
            checkBackupPiece.start_time,
            checkBackupPiece.completion_time,
            checkBackupPiece.status, checkBackupPiece.bytes,
            checkBackupPiece.is_recovery_dest_file, localrsr.rsr_key, 
            checkBackupPiece.compressed, this_site_key,
            decode(checkBackupPiece.encrypted, 'YES', 'Y', 'N'), 
            decode(checkBackupPiece.backed_by_osb, 'YES', 'Y', 'N'),
            checkBackupPiece.ba_access,
            checkBackupPiece.vbkey, checkBackupPiece.lib_key,
            decode(checkBackupPiece.ba_access, 'U', 'U', 'N'),
            l_pdb_key, checkBackupPiece.template_key)
         RETURNING bp_key INTO localbp.bp_key;
 
--
        IF this_is_ors THEN
          UPDATE sbt_template_db std
             SET std.last_bp_key = localbp.bp_key
           WHERE std.db_key = this_db_key
             AND std.last_bp_key > localbp.bp_key;
        END IF;
 
     END IF;
 
--
     IF this_is_ors AND getValueFromConfig('_enable_populate_rsr_key') = 1 THEN
        EXECUTE IMMEDIATE
         'BEGIN dbms_rai_populate_rsr_key(:1,:2); END;'
         USING localbp.bp_key, localbs.bs_key;
     END IF;
--
     deleteDuplicateBP(l_bp_recid, bp_stamp, localbs.bs_key,
                       device_type, handle);
 
--
--
     IF l_update_bs_pieces THEN
       UPDATE bs
          SET bs.pieces = checkBackupPiece.piece#
        WHERE bs.bs_key = localbs.bs_key
          AND bs.bck_type IS NULL;
     END IF;
 
--
     updateBackupSetRec(localbs.bs_key);
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('checkBackupPiece - Inside dup_val_on_index exception');
--
--
      SELECT * INTO localbp
      FROM bp
      WHERE bp.bs_key = localbs.bs_key
      AND   bp.bp_recid = l_bp_recid
      AND   bp.bp_stamp = checkBackupPiece.bp_stamp;
 
--
      IF client_site_aware AND this_site_key <> localbp.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (piece# <> localbp.piece#) THEN
        raise_application_error(-20093, 'Invalid piece#');
      END IF;
 
--
      IF localbp.site_key IS NULL THEN
         UPDATE bp SET site_key = this_site_key
         WHERE  bp.bs_key = localbs.bs_key
          AND   bp.bp_recid = l_bp_recid
          AND   bp.bp_stamp = checkBackupPiece.bp_stamp;
      END IF;
    WHEN OTHERS THEN
       deb('checkBackupPiece - inside exception hndle='||sqlerrm);
       RAISE;
  END;
 
  RETURN localbp.bp_key;
END checkBackupPiece;
 
PROCEDURE endBackupPieceResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     deb('endBackupPieceResync - last_bp_recid=' || last_bp_recid);
     UPDATE node SET high_bp_recid = last_bp_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_bp_recid := last_bp_recid;
  last_bp_recid := NULL;
 
END endBackupPieceResync;
 
/*-------------------------*
 * Backup Datafile resync  *
 *-------------------------*/
 
PROCEDURE addBackupControlFile(
  bs_key             IN NUMBER
 ,bcf_recid          IN NUMBER
 ,bcf_stamp          IN NUMBER
 ,dbinc_key          IN NUMBER
 ,ckp_scn            IN NUMBER
 ,ckp_time           IN DATE
 ,create_time        IN DATE
 ,min_offr_recid     IN NUMBER
 ,blocks             IN NUMBER
 ,block_size         IN NUMBER
 ,controlfile_type   IN VARCHAR2
 ,cfile_abck_year    IN number
 ,cfile_abck_mon_day IN number
 ,cfile_abck_seq     IN number
 ,pdb_key            IN NUMBER
) IS
 
local    bcf%rowtype;
l_conflict_count NUMBER := 0;
BEGIN
  BEGIN
    INSERT INTO bcf(bcf_key, bs_key, dbinc_key, bcf_recid, bcf_stamp,
                    ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
                    controlfile_type, blocks, autobackup_date,
                    autobackup_sequence, pdb_key)
    VALUES (rman_seq.nextval, bs_key, dbinc_key, bcf_recid, bcf_stamp,
            ckp_scn, ckp_time, create_time, min_offr_recid,block_size,
            controlfile_type, blocks,
            decode(cfile_abck_year, 0, to_date(NULL),
                   to_date(to_char(cfile_abck_year)||
                           lpad(to_char(cfile_abck_mon_day), 4, '0'),
                           'YYYYMMDD', 'NLS_CALENDAR=Gregorian')),
            cfile_abck_seq, pdb_key);
    IF (duplicatebs.exists(addBackupControlFile.bs_key)) THEN
       DECLARE
         CURSOR bcf_conflicts(bs_key_new IN NUMBER ) IS
           SELECT bs_key, bcf_key, dbinc_key, ckp_scn, ckp_time, block_size, 
                  controlfile_type, blocks, pdb_key 
             FROM bcf
            WHERE bcf.bs_key = bs_key_new;
         conflict_rec bcf_conflicts%rowtype;
       BEGIN
         FOR conflict_rec IN bcf_conflicts(addBackupControlFile.bs_key)
         LOOP
           deb('addBackupControlfile set stamp set count conflict rec- ' ||
                ' bs_key '           || to_char(conflict_rec.bs_key)     ||
                ' bcf_key '          || to_char(conflict_rec.bcf_key)    ||
                ' dbinc_key '        || to_char(conflict_rec.dbinc_key)  ||
                ' ckp_scn '          || to_char(conflict_rec.ckp_scn)    ||
                ' ckp_time '         || to_char(conflict_rec.ckp_time)   ||
                ' block_size '       || to_char(conflict_rec.block_size) ||
                ' controlfile_type ' || conflict_rec.controlfile_type    ||
                ' blocks '           || to_char(conflict_rec.blocks)     ||
                ' pdb_key '          || to_char(conflict_rec.pdb_key));
         END LOOP;
       END;
       raise_application_error(-20110, 'set stamp set count conflict');
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addBackupControlfile - Inside dup_val_on_index exception');
      
      SELECT count(*) INTO l_conflict_count 
        FROM bcf
       WHERE bcf.bs_key  =  addBackupControlFile.bs_key 
         AND (
                bcf.ckp_scn          <> addBackupControlFile.ckp_scn 
             OR bcf.ckp_time         <> addBackupControlFile.ckp_time
             OR bcf.block_size       <> addBackupControlFile.block_size
             OR bcf.controlfile_type <> addBackupControlFile.controlfile_type
             OR bcf.blocks           <> addBackupControlFile.blocks
             )
         AND ROWNUM       = 1 ;
      IF (l_conflict_count > 0) THEN
         DECLARE
           CURSOR bcf_conflicts(bs_key_new IN NUMBER, ckp_scn_new IN NUMBER, 
                                ckp_time_new IN DATE, block_size_new IN NUMBER,
                                controlfile_type_new IN VARCHAR2, 
                                blocks_new IN NUMBER)
           IS
             SELECT bs_key, bcf_key, dbinc_key, ckp_scn, ckp_time, block_size, 
                    controlfile_type, blocks, pdb_key
               FROM bcf
              WHERE bcf.bs_key = bs_key_new
                AND (
                       bcf.ckp_scn          <> ckp_scn_new
                    OR bcf.ckp_time         <> ckp_time_new
                    OR bcf.block_size       <> block_size_new
                    OR bcf.controlfile_type <> controlfile_type_new
                    OR bcf.blocks           <> blocks_new
                    );
         BEGIN
           FOR conflict_rec IN bcf_conflicts(addBackupControlFile.bs_key, 
                                   addBackupControlFile.ckp_scn,
                                   addBackupControlFile.ckp_time,
                                   addBackupControlFile.block_size,
                                   addBackupControlFile.controlfile_type,
                                   addBackupControlFile.blocks)
           LOOP
             deb('addBackupControlfile set stamp set count existing rec- ' ||
                 ' bs_key '           || to_char(conflict_rec.bs_key)      ||
                 ' bcf_key '          || to_char(conflict_rec.bcf_key)     ||
                 ' dbinc_key '        || to_char(conflict_rec.dbinc_key)   ||
                 ' ckp_scn '          || to_char(conflict_rec.ckp_scn)     ||
                 ' ckp_time '         || to_char(conflict_rec.ckp_time)    ||
                 ' block_size '       || to_char(conflict_rec.block_size)  ||
                 ' controlfile_type ' || conflict_rec.controlfile_type     ||
                 ' blocks '           || to_char(conflict_rec.blocks)      ||
                 ' pdb_key '          || to_char(conflict_rec.pdb_key));
           END LOOP;
           deb('addBackupControlfile set stamp set count new conflict rec- ' ||
               ' bs_key '      || to_char(addBackupControlfile.bs_key)     ||
               ' dbinc_key '   || to_char(addBackupControlfile.dbinc_key)  ||
               ' ckp_scn '     || to_char(addBackupControlfile.ckp_scn)    ||
               ' ckp_time '    || to_char(addBackupControlfile.ckp_time)   ||
               ' block_size '  || to_char(addBackupControlfile.block_size) ||
               ' controlfile_type ' || addBackupControlfile.controlfile_type ||
               ' blocks '      || to_char(addBackupControlfile.blocks)     ||
               ' pdb_key '     || to_char(addBackupControlfile.pdb_key));
         END;
         raise_application_error(-20110, 'set stamp set count conflict');
      END IF;
 
--
--
      SELECT ckp_scn, ckp_time, bcf_recid, bcf_stamp INTO 
             local.ckp_scn, local.ckp_time, local.bcf_recid, local.bcf_stamp
      FROM bcf
      WHERE bcf.bs_key = addBackupControlFile.bs_key;
 
--
      IF (ckp_scn <> local.ckp_scn or ckp_time <> local.ckp_time) THEN
        deb('addBackupControlfile - ckp_scn '||ckp_scn||' ckp_time '||
            to_char(ckp_time));
        deb('addBackupControlfile - lckp_scn '||local.ckp_scn||' lckp_time '||
            to_char(local.ckp_time));
        raise_application_error(-20095, 'Invalid ckp_scn or ckp_time');
      END IF;
 
--
      IF local.bcf_recid <> bcf_recid or local.bcf_stamp <> bcf_stamp THEN
         UPDATE bcf set bcf_recid = addBackupControlFile.bcf_recid,
                        bcf_stamp = addBackupControlFile.bcf_stamp
         WHERE bcf.bs_key = addBackupControlFile.bs_key;
      END IF;
  END;
END addBackupControlFile;
 
PROCEDURE addBackupDataFile(
  bs_key          IN NUMBER
 ,bdf_recid       IN NUMBER
 ,bdf_stamp       IN NUMBER
 ,file#           IN NUMBER
 ,create_scn      IN NUMBER
 ,dbinc_key       IN NUMBER
 ,incr_level      IN NUMBER
 ,incr_scn        IN NUMBER
 ,ckp_scn         IN NUMBER
 ,ckp_time        IN DATE
 ,abs_fuzzy_scn   IN NUMBER
 ,datafile_blocks IN NUMBER
 ,blocks          IN NUMBER
 ,block_size      IN NUMBER
 ,completion_time IN DATE
 ,blocks_read     IN NUMBER
 ,create_time     IN DATE
 ,marked_corrupt  IN NUMBER
 ,used_chg_track  IN VARCHAR2
 ,used_optim      IN VARCHAR2
 ,foreign_dbid      IN NUMBER
 ,plugged_readonly  IN VARCHAR2
 ,plugin_scn        IN NUMBER
 ,plugin_reset_scn  IN NUMBER
 ,plugin_reset_time IN DATE
 ,section_size      IN NUMBER
 ,pdb_key           IN NUMBER
 ,sparse_backup     IN VARCHAR2
 ,isReSync          IN BOOLEAN
 ,isVirtual         IN BOOLEAN
) IS
 
local            bdf%rowtype;
l_conflict_count NUMBER          := 0;
l_UB4MAXVAL      CONSTANT NUMBER := 4294967295;
 
BEGIN
 
  deb('addBackupDataFile - bs_key ' || bs_key || '  file# ' || file#);
 
  BEGIN
    INSERT INTO bdf(bdf_key, dbinc_key, bdf_recid, bdf_stamp, bs_key,
       file#, create_scn, incr_level, incr_scn,
       ckp_scn, ckp_time, abs_fuzzy_scn, datafile_blocks, blocks, block_size,
       completion_time, blocks_read, create_time, marked_corrupt,
       used_chg_track, used_optim, foreign_dbid, plugged_readonly,
       plugin_scn, plugin_reset_scn, plugin_reset_time, section_size,
       pdb_key, sparse_backup)
    VALUES
      (rman_seq.nextval, dbinc_key, bdf_recid, bdf_stamp, bs_key,
       file#, create_scn, incr_level, incr_scn,
       ckp_scn, ckp_time, abs_fuzzy_scn, datafile_blocks, blocks, block_size,
       completion_time, nvl(blocks_read, datafile_blocks), create_time, 
       marked_corrupt, decode(used_chg_track, 'YES', 'Y', 'N'),
       decode(used_optim, 'YES', 'Y', 'N'), foreign_dbid, plugged_readonly,
       plugin_scn, plugin_reset_scn, plugin_reset_time, section_size,
       pdb_key, sparse_backup);
    IF (duplicatebs.exists(addBackupDataFile.bs_key)) THEN
       DECLARE
         CURSOR bdf_conflicts(bs_key_new IN NUMBER) IS
           SELECT bs_key, bdf_key, dbinc_key, file#, bdf_recid, bdf_stamp,
                  ckp_scn, ckp_time, datafile_blocks, block_size, plugin_scn, 
                  section_size
             FROM bdf
            WHERE bdf.bs_key = bs_key_new;
         conflict_rec bdf_conflicts%rowtype;
       BEGIN
         FOR conflict_rec IN bdf_conflicts(addBackupDatafile.bs_key)
         LOOP
           deb('addBackupDatafile set stamp set count conflict - '         ||
               ' bs_key '          || to_char(conflict_rec.bs_key)          ||
               ' bdf_key '         || to_char(conflict_rec.bdf_key)         ||
               ' dbinc_key '       || to_char(conflict_rec.dbinc_key)       ||
               ' file# '           || to_char(conflict_rec.file#)           ||
               ' bdf_recid '       || to_char(conflict_rec.bdf_recid)       ||
               ' bdf_stamp '       || to_char(conflict_rec.bdf_stamp)       ||
               ' ckp_scn '         || to_char(conflict_rec.ckp_scn)         ||
               ' ckp_time '        || to_char(conflict_rec.ckp_time)        ||
               ' datafile_blocks ' || to_char(conflict_rec.datafile_blocks) ||
               ' block_size '      || to_char(conflict_rec.block_size)      ||
               ' plugin_scn '      || to_char(conflict_rec.plugin_scn)      ||
               ' section_size '    || to_char(conflict_rec.section_size));
           END LOOP;
         END;
       raise_application_error(-20110, 'set stamp set count conflict');
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addBackupDataFile - Inside dup_val_on_index exception');
 
      SELECT count(*) INTO l_conflict_count 
        FROM bdf
       WHERE bdf.bs_key = addBackupDataFile.bs_key 
         AND bdf.file#  = addBackupDataFile.file# 
         AND (
                bdf.ckp_scn         <> addBackupDataFile.ckp_scn 
             OR bdf.ckp_time        <> addBackupDataFile.ckp_time
             OR bdf.datafile_blocks <> addBackupDataFile.datafile_blocks
             OR bdf.block_size      <> addBackupDataFile.block_size
             OR bdf.plugin_scn      <> addBackupDataFile.plugin_scn
             ) 
         AND ROWNUM    = 1;
              
      
      deb('addBackupDataFile - l_conflict_count: '|| l_conflict_count);
      deb('addBackupDataFile - sect size: '|| addBackupDataFile.section_size);
  
      IF (l_conflict_count > 0 AND addBackupDataFile.section_size = 0 ) THEN
         DECLARE
           CURSOR bdf_conflicts(bs_key_new IN NUMBER, file_new IN NUMBER, 
                                ckp_scn_new IN NUMBER, ckp_time_new IN DATE, 
                                datafile_blocks_new IN NUMBER, 
                                block_size_new IN NUMBER, plugin_scn_new IN NUMBER) 
           IS
             SELECT bs_key, bdf_key, dbinc_key, file#, bdf_recid, bdf_stamp,
                    ckp_scn, ckp_time, datafile_blocks, block_size, plugin_scn,
                    section_size 
               FROM bdf
              WHERE bdf.bs_key = bs_key_new
                AND bdf.file#  = file_new
                AND (
                       bdf.ckp_scn         <> ckp_scn_new
                    OR bdf.ckp_time        <> ckp_time_new
                    OR bdf.datafile_blocks <> datafile_blocks_new
                    OR bdf.block_size      <> block_size_new
                    OR bdf.plugin_scn      <> plugin_scn_new
                    );
           conflict_rec bdf_conflicts%rowtype;
         BEGIN
           FOR conflict_rec IN bdf_conflicts(addBackupDatafile.bs_key,
                                   addBackupDatafile.file#, 
                                   addBackupDatafile.ckp_scn, 
                                   addBackupDatafile.ckp_time, 
                                   addBackupDatafile.datafile_blocks, 
                                   addBackupDatafile.block_size, 
                                   addBackupDatafile.plugin_scn)
           LOOP
             deb('addBackupDatafile set stamp set count existing rec-'       ||
                 ' bs_key '         || to_char(conflict_rec.bs_key)          ||
                 ' bdf_key '        || to_char(conflict_rec.bdf_key)         ||
                 ' dbinc_key '      || to_char(conflict_rec.dbinc_key)       ||
                 ' file# '          || to_char(conflict_rec.file#)           ||
                 ' bdf_recid '      || to_char(conflict_rec.bdf_recid)       ||
                 ' bdf_stamp '      || to_char(conflict_rec.bdf_stamp)       ||
                 ' ckp_scn '        || to_char(conflict_rec.ckp_scn)         ||
                 ' ckp_time '       || to_char(conflict_rec.ckp_time)        ||
                 ' datafile_blocks ' || 
                                       to_char(conflict_rec.datafile_blocks) ||
                 ' block_size '     || to_char(conflict_rec.block_size)      ||
                 ' plugin_scn '     || to_char(conflict_rec.plugin_scn)      ||
                 ' section_size '   || to_char(conflict_rec.section_size));
             END LOOP;
             deb('addBackupDatafile set stamp set count new conflict rec- '  ||
                 ' bs_key '         || to_char(addBackupDataFile.bs_key)     ||
                 ' dbinc_key'       || to_char(addBackupDataFile.dbinc_key)  ||
                 ' file# '          || to_char(addBackupDataFile.file#)      ||
                 ' bdf_recid '      || to_char(addBackupDataFile.bdf_recid)  ||
                 ' bdf_stamp '      || to_char(addBackupDataFile.bdf_stamp)  ||
                 ' ckp_scn '        || to_char(addBackupDataFile.ckp_scn)    ||
                 ' ckp_time '        
                                    || to_char(addBackupDataFile.ckp_time)   ||
                 ' datafile_blocks ' || 
                                  to_char(addBackupDataFile.datafile_blocks) ||
                 ' block_size '     || to_char(addBackupDataFile.block_size) ||
                 ' plugin_scn '     || to_char(addBackupDataFile.plugin_scn) ||
                 ' section_size '  || to_char(addBackupDataFile.section_size));
           END;
         raise_application_error(-20110, 'set stamp set count conflict');
      END IF;
 
--
--
      SELECT dbinc_key, create_scn, bdf_recid, bdf_stamp, plugin_scn, 
             completion_time, abs_fuzzy_scn, blocks,
             nvl(blocks_read, datafile_blocks), 
             ckp_scn, ckp_time,
             decode(used_optim, 'YES', 'Y', 'N'),
             decode(used_chg_track, 'YES', 'Y', 'N'),
             nvl(marked_corrupt, 0)
        INTO local.dbinc_key, local.create_scn,local.bdf_recid,
             local.bdf_stamp, local.plugin_scn, local.completion_time,
             local.abs_fuzzy_scn, local.blocks, local.blocks_read, 
             local.ckp_scn, local.ckp_time, local.used_optim,
             local.used_chg_track, local.marked_corrupt
      FROM bdf
      WHERE bdf.bs_key = addBackupDataFile.bs_key
        AND bdf.file#  = addBackupDataFile.file#;
 
--
      deb('addBackupDataFile - dbinc_key:        '||to_char(dbinc_key));
      deb('addBackupDataFile - local.dbinc_key: '|| to_char(local.dbinc_key) ||
          ' local.completion_time: '|| to_char(local.completion_time) ||
          ' local.abs_fuzzy_scn: '|| to_char(local.abs_fuzzy_scn) ||
          ' local.blocks_read: '|| to_char(local.blocks_read) ||
          ' local.marked_corrupt: '|| to_char(local.marked_corrupt));
      IF (dbinc_key <> local.dbinc_key) THEN
        raise_application_error(-20096, 'Invalid dbinc_key');
      END IF;
      IF (create_scn <> local.create_scn AND
          plugin_scn <> local.plugin_scn) THEN
        raise_application_error(-20097, 'Invalid create scn');
      END IF;
 
--
      IF bdf_recid <> local.bdf_recid or bdf_stamp <> local.bdf_stamp THEN
         UPDATE bdf set bdf_recid = addBackupDataFile.bdf_recid,
                        bdf_stamp = addBackupDataFile.bdf_stamp
         WHERE bdf.bs_key = addBackupDataFile.bs_key;
      END IF;
 
      IF (local.completion_time <> addBackupDataFile.completion_time) THEN
        UPDATE bdf
          SET completion_time = addBackupDataFile.completion_time
          WHERE bdf.bs_key = addBackupDataFile.bs_key
            AND bdf.file#  = addBackupDataFile.file#;
      END IF;
 
      /*
       * Following are the scenarios that traverse this code path:
       *
       * 1. Resync: resync can happen for both normal msection
       *    backups and virtual msection backups. If a resync
       *    happens during processing of these backups, like say
       *    there are 5 section pieces, and the resync happens
       *    once after the 3rd piece, and once after all 5 pieces,
       *    then the data stored in blocks_read, blocks and marked_corrupt
       *    may be a little more than it needs to be. However,
       *    ckp_scn and abs_fuzzy_scn would be fine as we are taking
       *    the minimum and maximum of each respectively.
       *    In the case of the other parameters, we need to accumulate
       *    their values across sections and there is no easy way
       *    to achieve that.
       * 2. Prior to 12.2, parameters blocks_read, blocks and marked_corrupt
       *    are at value '0'. However, there is a fix in progress to 
       *    capture the actual values. Once that lands, the scenario
       *    listed in #1 will further manifest itself, with larger than
       *    possible values for blocks, blocks_read and marked_corrupt
       * 3. We need to limit the calculations for copy#1, that way copy to tape
       *    or additional copies created on the backup command using copies
       *    does not further throw off the values on blocks_read, blocks
       *    or marked_corrupt. However, there is no easy way to determine
       *    that at this point in code. Copy2tape currently sets a value
       *    of zero only.
       *
       *  For now, we will take minimum of checkpoint scn's and maximum of 
       *  absolute fuzzy scn's. And only in the case of msection case,
       *  add the values of blocks, blocks_read and marked_corrupt 
       */
 
--
--
      IF (addBackupDataFile.ckp_scn  < local.ckp_scn) THEN
        UPDATE bdf 
          SET ckp_scn  = addBackupDataFile.ckp_scn,
              ckp_time = addBackupDataFile.ckp_time
          WHERE bdf.bs_key = addBackupDataFile.bs_key
            AND bdf.file#  = addBackupDataFile.file#;
 
         deb('addBackupDataFile - updated bdf ckp_scn: '||
             to_char(addBackupDataFile.ckp_scn) || ' local bdf ckp_scn:' ||
             to_char(local.ckp_scn));
      END IF;
 
      /*
       * This applies to regular backups as well but more so for multi-section 
       * backup.
       * Lets assume that there are two sections  (ckp_scn, abs_scn) notation.
       *
       * Section 1: (100, 101)
       * Section 2: (200, 0)  this is not fuzzy. however there can be blocks 
       *           at 150, 160..
       * IF you were to perform a point in time recovery scenario to 150 and 
       * if you take the minimum of the checkpointscns and the maximum of the 
       * absolute fuzzy then the restored datafile will be (100, 101). 
       * This is wrong as recovery will not be able to unfuzzy the block at 
       * scn 150, 160.. as it cannot roll backwards.
       *
       * The correct way of addressing this is to update the bdf with the 
       * appropriate fuzziness by also taking into fact the checkpoint of the 
       * file
       * This is done in restore logic as below (krbr.c:krbr3b2)
       *          f->curfuzz_krbrf =
       *          (*KSCNMAX(f->pkcvfh_krbrf->kcvfhafs,
       *                    KSCNMAX(f->pkcvfh_krbrf->kcvfhrfs,
       *                            f->pkcvfh_krbrf->kcvfhckp.kcvcpscn)));
       *
       * The same is being done below.
       */
 
--
      IF (addBackupDataFile.abs_fuzzy_scn > local.abs_fuzzy_scn) THEN
        UPDATE bdf
          SET abs_fuzzy_scn = addBackupDataFile.abs_fuzzy_scn
          WHERE bdf.bs_key  = addBackupDataFile.bs_key
            AND bdf.file#   = addBackupDataFile.file#;
 
        deb('addBackupDataFile - updated bdf abs_fuzzy_scn: '||
            to_char(addBackupDataFile.abs_fuzzy_scn) || ' 
            local bdf abs_fuzzy_scn:' ||
            to_char(local.abs_fuzzy_scn));
 
      ELSIF (addBackupDataFile.section_size <> 0 AND
             local.abs_fuzzy_scn < addBackupDataFile.ckp_scn) THEN
        
        UPDATE bdf
          SET abs_fuzzy_scn = addBackupDataFile.ckp_scn
          WHERE bdf.bs_key  = addBackupDataFile.bs_key
            AND bdf.file#   = addBackupDataFile.file#;
 
        deb('addBackupDataFile - updated bdf abs_fuzzy_scn to ckp_scn: '||
            to_char(addBackupDataFile.ckp_scn) || ' 
            local bdf abs_fuzzy_scn:' ||
            to_char(local.abs_fuzzy_scn));
 
      END IF;
 
      IF addBackupDataFile.section_size <> 0 AND this_is_ors THEN
 
        deb ('Multi-section on ORS');
--
--
--
--
--
--
        IF (isReSync AND NOT isVirtual) THEN
 
          deb('addBackupDataFile - isResync:TRUE isVirtual:FALSE'||
              to_char(local.blocks_read) || ' ' || 
              to_char(addBackupDataFile.blocks_read));
               
          deb('addBackupDataFile - isResync:TRUE isVirtual:FALSE'||
              to_char(local.blocks) || ' ' || 
              to_char(addBackupDataFile.blocks));
 
          UPDATE bdf
            SET blocks_read    = addBackupDataFile.blocks_read,
                blocks         = addBackupDataFile.blocks,
                marked_corrupt = addBackupDataFile.marked_corrupt
           WHERE bdf.bs_key = addBackupDataFile.bs_key
             AND bdf.file#  = addBackupDataFile.file#
             AND (local.blocks_read    <> addBackupDataFile.blocks_read OR
                  local.blocks         <> addBackupDataFile.blocks      OR
                  local.marked_corrupt <> addBackupDataFile.marked_corrupt);
 
        ELSIF (NOT isReSync AND NOT isVirtual) THEN
--
--
--
--
 
          deb('addBackupDataFile - isResync:FALSE isVirtual:FALSE'||
              to_char(local.blocks_read) || ' ' || 
              to_char(addBackupDataFile.blocks_read));
               
          deb('addBackupDataFile - isResync:FALSE isVirtual:FALSE'||
              to_char(local.blocks) || ' ' || 
              to_char(addBackupDataFile.blocks));
          UPDATE bdf
            SET blocks_read    = CASE WHEN 
                                   local.blocks_read = 0
                                     THEN 
                                       addBackupDataFile.blocks_read 
                                     ELSE 
                                       local.blocks_read 
                                 END,
                blocks         = CASE WHEN 
                                   local.blocks = 0
                                     THEN 
                                       addBackupDataFile.blocks 
                                     ELSE 
                                       local.blocks
                                 END,
                marked_corrupt = CASE WHEN 
                                   local.marked_corrupt = 0
                                     THEN 
                                       addBackupDataFile.marked_corrupt 
                                     ELSE 
                                       local.marked_corrupt 
                                 END
           WHERE bdf.bs_key = addBackupDataFile.bs_key
             AND bdf.file#  = addBackupDataFile.file#
             AND (local.blocks_read = 0 OR
                  local.blocks = 0 OR
                  local.marked_corrupt = 0);
 
        ELSIF (NOT isReSync AND isVirtual) THEN
--
--
--
          deb('addBackupDataFile - isResync:FALSE isVirtual:TRUE'||
              to_char(local.blocks_read) || ' ' || 
              to_char(addBackupDataFile.blocks_read));
               
          deb('addBackupDataFile - isResync:FALSE isVirtual:TRUE'||
              to_char(local.blocks) || ' ' || 
              to_char(addBackupDataFile.blocks));
--
          local.marked_corrupt := local.marked_corrupt + 
                                  addBackupDataFile.marked_corrupt;
 
--
          local.blocks_read := local.blocks_read + 
                               addBackupDataFile.blocks_read;
          local.blocks      := local.blocks + 
                               addBackupDataFile.blocks;
 
          local.blocks := LEAST(local.blocks, 
                                addBackupDataFile.datafile_blocks);
          local.blocks_read := LEAST(local.blocks_read, 
                                     addBackupDataFile.datafile_blocks);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
          IF (local.blocks > l_UB4MAXVAL) THEN
--
             deb('addBackupDataFile - blocks overflow'||
                 to_char(local.blocks) || ' ' || 
                 to_char(addBackupDataFile.blocks));
             
             local.blocks := l_UB4MAXVAL;
             
          END IF;
 
          IF (local.blocks_read > l_UB4MAXVAL) THEN
--
             deb('addBackupDataFile - blocks_read overflow'||
                 to_char(local.blocks_read) || ' ' || 
                 to_char(addBackupDataFile.blocks_read));
             
             local.blocks_read := l_UB4MAXVAL;
             
          END IF;
 
          UPDATE bdf
            SET marked_corrupt = local.marked_corrupt,
                blocks_read    = local.blocks_read, 
                blocks         = local.blocks
           WHERE bdf.bs_key = addBackupDataFile.bs_key
             AND bdf.file#  = addBackupDataFile.file#;
        END IF;
 
      UPDATE bdf
        SET used_chg_track = CASE WHEN 
                               (local.used_chg_track = 'Y' OR 
                                addBackupDataFile.used_chg_track = 'YES')
                                  THEN 
                                    'Y'
                                  ELSE 
                                    'N'
                             END,
            used_optim =    CASE WHEN 
                              (local.used_optim = 'Y' OR
                               addBackupDataFile.used_optim = 'YES')
                                 THEN 
                                   'Y'
                                 ELSE 
                                   'N'
                            END
       WHERE bdf.bs_key = addBackupDataFile.bs_key
         AND bdf.file#  = addBackupDataFile.file#
         AND (local.used_chg_track <> 
                decode(addBackupDataFile.used_chg_track, 'YES', 'Y', 'N') OR
              local.used_optim     <> 
                decode(addBackupDataFile.used_optim, 'YES', 'Y', 'N'));
 
    ELSE
--
      deb('addBackupDataFile - Regular RMAN catalog');
 
      IF (local.completion_time <> addBackupDataFile.completion_time) THEN
        UPDATE bdf
          SET blocks_read    = addBackupDataFile.blocks_read,
              marked_corrupt = addBackupDataFile.marked_corrupt
         WHERE bdf.bs_key = addBackupDataFile.bs_key
           AND bdf.file#  = addBackupDataFile.file#;
      END IF;
    END IF;
  END;
END addBackupDataFile;
 
FUNCTION beginBackupDataFileResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_bdf_recid INTO last_bdf_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_bdf_recid := sessionWaterMarks.high_bdf_recid;
  END IF;
 
  deb('beginBackupDataFileResync returning' || last_bdf_recid);
  RETURN last_bdf_recid;
END beginBackupDataFileResync;
 
 
PROCEDURE checkBackupDataFile(
  bdf_recid       IN NUMBER
 ,bdf_stamp       IN NUMBER
 ,set_stamp       IN NUMBER
 ,set_count       IN NUMBER
 ,file#           IN NUMBER
 ,create_scn      IN NUMBER
 ,create_time     IN DATE
 ,reset_scn       IN NUMBER
 ,reset_time      IN DATE
 ,incr_level      IN NUMBER
 ,incr_scn        IN NUMBER
 ,ckp_scn         IN NUMBER
 ,ckp_time        IN DATE
 ,abs_fuzzy_scn   IN NUMBER
 ,datafile_blocks IN NUMBER
 ,blocks          IN NUMBER
 ,block_size      IN NUMBER
 ,min_offr_recid  IN NUMBER
 ,completion_time IN DATE
 ,controlfile_type
                    IN VARCHAR2       DEFAULT NULL
 ,cfile_abck_year   IN NUMBER         DEFAULT NULL -- contains marked_corrupt
 ,cfile_abck_mon_day
                    IN NUMBER         DEFAULT NULL -- contains media_corrupt
 ,cfile_abck_seq    IN NUMBER         DEFAULT NULL -- contains logical_corrupt
 ,chk_last_recid    IN BOOLEAN        DEFAULT TRUE
 ,blocks_read       IN NUMBER         DEFAULT NULL
 ,used_chg_track    IN VARCHAR2       DEFAULT 'NO'
 ,used_optim        IN VARCHAR2       DEFAULT 'NO'
 ,foreign_dbid      IN NUMBER         DEFAULT 0
 ,plugged_readonly  IN VARCHAR2       DEFAULT 'NO'
 ,plugin_scn        IN NUMBER         DEFAULT 0
 ,plugin_reset_scn  IN NUMBER         DEFAULT 0
 ,plugin_reset_time IN DATE           DEFAULT NULL
 ,section_size      IN NUMBER         DEFAULT NULL
 ,guid              IN RAW            DEFAULT NULL
 ,sparse_backup     IN VARCHAR2       DEFAULT 'NO'
 ,isReSync          IN BOOLEAN        DEFAULT TRUE
 ,isVirtual         IN BOOLEAN        DEFAULT FALSE
 ,dropped_pdb       IN BINARY_INTEGER DEFAULT 0
) IS
 
bs_key    NUMBER;
dbinc_key NUMBER;
l_pdb_key NUMBER;
 
BEGIN
 
--
 IF chk_last_recid THEN
    IF (last_bdf_recid IS NULL) THEN
       raise_application_error(-20037, 'Invalid last recid');
    END IF;
 
    IF (bdf_recid < last_bdf_recid) THEN
       raise_application_error(-20036, 'Invalid record order');
    END IF;
 
    IF (bdf_recid > last_bdf_recid + 1) THEN
--
       NULL;
    END IF;
    last_bdf_recid := bdf_recid;
  END IF;
 
--
  BEGIN
    SELECT bs_key INTO bs_key
    FROM bs
    WHERE bs.db_key = this_db_key
    AND   bs.set_stamp = checkBackupDataFile.set_stamp
    AND   bs.set_count = checkBackupDataFile.set_count FOR UPDATE OF bs.bs_key;
    deb('checkBackupDataFile - locked bs_key' || bs_key);
  EXCEPTION
    WHEN no_data_found THEN
--
--
--
--
--
--
--
       return;
  END;
 
  BEGIN
--
--
    IF (checkBackupDatafile.incr_level > 0) THEN
      UPDATE bs SET bs.incr_level = checkBackupDataFile.incr_level,
                    bs.bck_type = 'I'
      WHERE bs.bs_key = checkBackupDataFile.bs_key
      AND   bs.bck_type IS NULL;
    ELSE
      UPDATE bs SET bs.incr_level = checkBackupDataFile.incr_level,
                    bs.bck_type = 'D'
      WHERE bs.bs_key = checkBackupDataFile.bs_key
      AND   bs.bck_type IS NULL;
    END IF;
    IF (file# = 0 and controlfile_type is not null) then
      UPDATE bs SET bs.controlfile_included=
                 decode(checkBackupDatafile.controlfile_type,'B','BACKUP',
                                                             'S','STANDBY',
                                                             'NONE')
      WHERE bs.bs_key = checkBackupDataFile.bs_key
      AND   bs.controlfile_included = 'NONE';
    END IF;
  END;
 
--
  dbinc_key := checkIncarnation(reset_scn, reset_time);
 
  l_pdb_key := guidToPdbKey(guid, dropped_pdb);
 
  IF (file# = 0) THEN
    addBackupControlFile(bs_key, bdf_recid, bdf_stamp, dbinc_key,
         ckp_scn, ckp_time, create_time, min_offr_recid, blocks, block_size,
         controlfile_type, cfile_abck_year, cfile_abck_mon_day,
         cfile_abck_seq, l_pdb_key);
  ELSE
    addBackupDataFile(bs_key, bdf_recid, bdf_stamp, file#, create_scn,
         dbinc_key, incr_level, incr_scn, ckp_scn, ckp_time,
         abs_fuzzy_scn, datafile_blocks, blocks, block_size, completion_time,
         blocks_read, create_time, cfile_abck_year, used_chg_track, 
         used_optim, foreign_dbid, plugged_readonly, plugin_scn,
         plugin_reset_scn, plugin_reset_time, section_size, l_pdb_key,
         sparse_backup, isReSync, isVirtual);
  END IF;
 
END checkBackupDataFile;
 
PROCEDURE endBackupDataFileResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_bdf_recid = last_bdf_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_bdf_recid := last_bdf_recid;
  last_bdf_recid := NULL;
 
END endBackupDataFileResync;
 
/*-----------------------*
 * Backup SPFILE resync  *
 *-----------------------*/
 
FUNCTION beginBackupSpFileResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_bsf_recid INTO last_bsf_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_bsf_recid := sessionWaterMarks.high_bsf_recid;
  END IF;
 
  RETURN last_bsf_recid;
END beginBackupSpFileResync;
 
PROCEDURE addBackupSpFile(
  bs_key             IN NUMBER
 ,bsf_recid          IN NUMBER
 ,bsf_stamp          IN NUMBER
 ,modification_time  IN DATE
 ,bytes              IN NUMBER
 ,db_unique_name     IN VARCHAR2
 ,pdb_key            IN NUMBER
) IS
 
local    bsf%rowtype;
l_conflict_count number := 0 ;
BEGIN
  deb('addBackupSpfile');
  INSERT INTO bsf(bsf_key, bs_key, db_key, bsf_recid, bsf_stamp,
                  modification_time, bytes, db_unique_name, pdb_key)
  VALUES (rman_seq.nextval, bs_key, this_db_key, bsf_recid, bsf_stamp,
          modification_time, bytes, db_unique_name, pdb_key);
  IF (duplicatebs.exists(addBackupSpFile.bs_key)) THEN
     DECLARE
       CURSOR bsf_conflicts(bs_key_new IN NUMBER ) IS
         SELECT bs_key, bsf_key, bsf_recid, bsf_stamp, bytes, pdb_key 
           FROM bsf
          WHERE bsf.bs_key = bs_key_new;
       conflict_rec bsf_conflicts%rowtype;
     BEGIN
       FOR conflict_rec IN bsf_conflicts(addBackupSpFile.bs_key)
       LOOP
         deb('addBackupSpFile set stamp set count conflict - ' ||
             ' bs_key '    || to_char(conflict_rec.bs_key)       ||
             ' bsf_key '   || to_char(conflict_rec.bsf_key)      ||
             ' bsf_recid ' || to_char(conflict_rec.bsf_recid)    ||
             ' bsf_stamp ' || to_char(conflict_rec.bsf_stamp)    ||
             ' bytes '     || to_char(conflict_rec.bytes)        ||
             ' pdb_key '   || to_char(conflict_rec.pdb_key));
       END LOOP;
     END;
     raise_application_error(-20110, 'set stamp set count conflict');
  END IF;
 
EXCEPTION
  WHEN dup_val_on_index THEN
    deb('addBackupSpfile - Inside dup_val_on_index exception');
--
--
--
--
 
--
--
    SELECT * INTO local
    FROM bsf
    WHERE bsf.bs_key = addBackupSpFile.bs_key;
 
--
    IF (modification_time <> local.modification_time) THEN
      raise_application_error(-20101, 'Invalid modification_time');
    END IF;
 
--
    IF (db_unique_name <> local.db_unique_name) THEN
      raise_application_error(-20101, 
                           'Invalid db_unique_name=' || db_unique_name ||
                           'expected db_unique_name=' || local.db_unique_name);
    END IF;
 
--
    IF local.bsf_recid <> bsf_recid or local.bsf_stamp <> bsf_stamp THEN
       UPDATE bsf set bsf_recid = addBackupSpFile.bsf_recid,
                      bsf_stamp = addBackupSpFile.bsf_stamp
       WHERE bsf.bs_key = addBackupSpFile.bs_key;
    END IF;
END addBackupSpFile;
 
PROCEDURE checkBackupSpFile(
  bsf_recid         IN NUMBER
 ,bsf_stamp         IN NUMBER
 ,set_stamp         IN NUMBER
 ,set_count         IN NUMBER
 ,modification_time IN DATE
 ,bytes             IN NUMBER
 ,chk_last_recid    IN BOOLEAN        DEFAULT TRUE
 ,db_unique_name    IN VARCHAR2       DEFAULT NULL
 ,guid              IN RAW            DEFAULT NULL
 ,dropped_pdb       IN BINARY_INTEGER DEFAULT 0
) IS
 
bs_key    NUMBER;
site_key  NUMBER;
l_pdb_key NUMBER;
 
BEGIN
  IF chk_last_recid THEN
     IF (last_bsf_recid IS NULL) THEN
       raise_application_error(-20037, 'Invalid last recid');
     END IF;
 
    IF (bsf_recid < last_bsf_recid) THEN
       raise_application_error(-20036, 'Invalid record order');
     END IF;
 
     IF (bsf_recid > last_bsf_recid + 1) THEN
--
       NULL;
     END IF;
     last_bsf_recid := bsf_recid;
  END IF;
 
--
  BEGIN
    SELECT bs_key INTO bs_key
    FROM bs
    WHERE bs.db_key = this_db_key
    AND   bs.set_stamp = checkBackupSpFile.set_stamp
    AND   bs.set_count = checkBackupSpFile.set_count FOR UPDATE OF bs.bs_key;
    deb('checkBackupSpFile - locked bs_key' || bs_key);
  EXCEPTION
    WHEN no_data_found THEN
       return;
  END;
 
--
--
  UPDATE bs SET bs.bck_type = 'D'
   WHERE bs.bs_key = checkBackupSpFile.bs_key
     AND bs.bck_type IS NULL;
 
  l_pdb_key := guidToPdbKey(guid, dropped_pdb);
 
  addBackupSpFile(bs_key, bsf_recid, bsf_stamp, modification_time, bytes, 
                  db_unique_name, l_pdb_key);
 
END checkBackupSpFile;
 
PROCEDURE endBackupSpFileResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_bsf_recid = last_bsf_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_bsf_recid := last_bsf_recid;
  last_bsf_recid := NULL;
 
END endBackupSpFileResync;
 
/*-------------------------*
 * Backup Redo Log resync  *
 *-------------------------*/
 
FUNCTION beginBackupRedoLogResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_brl_recid INTO last_brl_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_brl_recid := sessionWaterMarks.high_brl_recid;
  END IF;
 
  RETURN last_brl_recid;
END beginBackupRedoLogResync;
 
PROCEDURE checkBackupRedoLog(
  brl_recid      IN NUMBER
 ,brl_stamp      IN NUMBER
 ,set_stamp      IN NUMBER
 ,set_count      IN NUMBER
 ,thread#        IN NUMBER
 ,sequence#      IN NUMBER
 ,reset_scn      IN NUMBER
 ,reset_time     IN DATE
 ,low_scn        IN NUMBER
 ,low_time       IN DATE
 ,next_scn       IN NUMBER
 ,next_time      IN DATE
 ,blocks         IN NUMBER
 ,block_size     IN NUMBER
 ,chk_last_recid IN BOOLEAN  DEFAULT TRUE
 ,terminal       IN VARCHAR2 DEFAULT 'NO'
 ,activation     IN VARCHAR2 DEFAULT NULL
) IS
 
local brl%rowtype;
bskeep number;
l_conflict_count number :=0;
 
BEGIN
--
--
--
  IF brl_stamp = 0 THEN 
     deb('checkBackupRedoLog: ignoring this record as brl_stamp is 0'); 
     RETURN; 
  END IF; 
 
--
  IF chk_last_recid THEN
     IF (last_brl_recid IS NULL) THEN
        raise_application_error(-20037, 'Invalid last recid');
     END IF;
 
     IF (brl_recid < last_brl_recid) THEN
        raise_application_error(-20036, 'Invalid record order');
     END IF;
 
     IF (brl_recid > last_brl_recid + 1) THEN
--
--
        NULL;
     END IF;
     last_brl_recid := brl_recid;
  END IF;
 
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
--
  BEGIN
    SELECT bs_key,keep_options INTO local.bs_key, bskeep
    FROM bs
    WHERE bs.db_key = this_db_key
    AND   bs.set_stamp = checkBackupRedoLog.set_stamp
    AND   bs.set_count = checkBackupRedoLog.set_count FOR UPDATE OF bs.bs_key;
    deb('checkBackupRedoLog - locked bs_key' || local.bs_key);
  EXCEPTION
    WHEN no_data_found THEN
       RETURN;
  END;
 
  BEGIN
--
--
    UPDATE bs SET bs.bck_type = 'L'
    WHERE bs.bs_key = local.bs_key
    AND   bs.bck_type IS NULL;
  END;
 
--
  local.dbinc_key := checkIncarnation(reset_scn, reset_time);
 
  BEGIN
    INSERT INTO brl
        (brl_key, dbinc_key, brl_recid, brl_stamp,
         thread#, sequence#, low_scn, low_time, next_scn, next_time,
         blocks, block_size, bs_key, terminal, activation)
    VALUES
        (rman_seq.nextval, local.dbinc_key, brl_recid, brl_stamp,
         thread#, sequence#, low_scn, low_time, next_scn, next_time,
         blocks, block_size, local.bs_key, terminal, activation);
    IF (duplicatebs.exists(local.bs_key)) THEN
       DECLARE
         CURSOR brl_conflicts(bs_key_new IN NUMBER) IS
           SELECT bs_key, brl_key, dbinc_key, brl_recid, 
                  brl_stamp, thread#, sequence#, blocks, block_size 
             FROM brl
            WHERE brl.bs_key = bs_key_new;
         conflict_rec brl_conflicts%rowtype;
       BEGIN
         FOR conflict_rec IN brl_conflicts(local.bs_key)
         LOOP
           deb('checkBackupRedoLog set stamp set count conflict - ' ||
               ' bs_key '     || to_char(conflict_rec.bs_key)    ||
               ' brl_key '    || to_char(conflict_rec.brl_key)   ||
               ' dbinc_key '  || to_char(conflict_rec.dbinc_key) ||
               ' brl_recid '  || to_char(conflict_rec.brl_recid) ||
               ' brl_stamp '  || to_char(conflict_rec.brl_stamp) ||
               ' thread# '    || to_char(conflict_rec.thread#)   ||
               ' sequence# '  || to_char(conflict_rec.sequence#) ||
               ' blocks '     || to_char(conflict_rec.blocks)    ||
               ' block_size ' || to_char(conflict_rec.block_size));
         END LOOP;
       END;
       raise_application_error(-20110, 'set stamp set count conflict');
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('checkBackupRedoLog - Inside dup_val_on_index exception');
--
      SELECT count(*) INTO l_conflict_count
      FROM brl
      WHERE brl.bs_key = local.bs_key
        AND  brl.thread# = checkBackupRedoLog.thread#
        AND  brl.sequence# = checkBackupRedoLog.sequence#
        AND (
               brl.blocks     <> checkBackupRedoLog.blocks
            OR brl.block_size <> checkBackupRedoLog.block_size
            )
        AND ROWNUM = 1;
      IF (l_conflict_count > 0) THEN
         DECLARE
           CURSOR brl_conflicts(bs_key_new IN NUMBER, thread_new IN NUMBER, 
                                sequence_new IN NUMBER, blocks_new IN NUMBER,
                                block_size_new IN NUMBER ) 
           IS
             SELECT bs_key, brl_key, dbinc_key, brl_recid, brl_stamp, thread#,
                    sequence#, blocks, block_size
               FROM brl
              WHERE brl.bs_key = bs_key_new
                AND brl.thread# = thread_new
                AND brl.sequence# = sequence_new
                AND (
                       brl.blocks = blocks_new
                    OR brl.block_size = block_size_new
                    );
           conflict_rec brl_conflicts%rowtype;
         BEGIN
           FOR conflict_rec IN brl_conflicts(local.bs_key,
                                             checkBackupRedoLog.thread#,
                                             checkBackupRedoLog.sequence#,
                                             checkBackupRedoLog.blocks,
                                             checkBackupRedoLog.block_size)
           LOOP
             deb('checkBackupRedoLog set stamp set count existing rec-  '  || 
                 ' bs_key '         || to_char(conflict_rec.bs_key)    ||
                 ' brl_key '        || to_char(conflict_rec.brl_key)   ||
                 ' dbinc_key '      || to_char(conflict_rec.dbinc_key) ||
                 ' brl_recid '      || to_char(conflict_rec.brl_recid) ||
                 ' brl_stamp '      || to_char(conflict_rec.brl_stamp) ||
                 ' thread# '        || to_char(conflict_rec.thread#)   ||
                 ' sequence# '      || to_char(conflict_rec.sequence#) ||
                 ' blocks '         || to_char(conflict_rec.blocks)    ||
                 ' block_size '     || to_char(conflict_rec.block_size));
           END LOOP;
           deb('checkBackupRedoLog set stamp set count new conflict rec- '  ||
               ' bs_key '     || to_char(local.bs_key)    ||
               ' dbinc_key '  || to_char(local.dbinc_key) ||
               ' brl_recid '  || to_char(checkBackupRedoLog.brl_recid) ||
               ' brl_stamp '  || to_char(checkBackupRedoLog.brl_stamp) ||
               ' thread# '    || to_char(checkBackupRedoLog.thread#)   ||
               ' sequence# '  || to_char(checkBackupRedoLog.sequence#) ||
               ' blocks '     || to_char(checkBackupRedoLog.blocks)    ||
               ' block_size ' || to_char(checkBackupRedoLog.block_size));
         END;
         
         raise_application_error(-20110, 'set stamp set count conflict');
      END IF;
 
--
--
      SELECT low_scn, brl_recid, brl_stamp 
        INTO local.low_scn, local.brl_recid, local.brl_stamp
      FROM brl
      WHERE brl.bs_key = local.bs_key
       AND  brl.thread# = checkBackupRedoLog.thread#
       AND  brl.sequence# = checkBackupRedoLog.sequence#;
 
--
      IF (low_scn <> local.low_scn) THEN
        raise_application_error(-20098, 'Invalid low scn');
      END IF;
 
--
      IF local.brl_recid <> brl_recid or local.brl_stamp <> brl_stamp THEN
         UPDATE brl set brl_recid = checkBackupRedoLog.brl_recid,
                        brl_stamp = checkBackupRedoLog.brl_stamp
         WHERE brl.bs_key = local.bs_key
           AND brl.thread# = checkBackupRedoLog.thread#
           AND brl.sequence# = checkBackupRedoLog.sequence#;
      END IF;
  END;
 
  IF (bskeep > 0) THEN
    updateRestorePoint(low_scn, next_scn);
  END IF;
 
END checkBackupRedoLog;
 
PROCEDURE endBackupRedoLogResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_brl_recid = last_brl_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_brl_recid := last_brl_recid;
  last_brl_recid := NULL;
 
END endBackupRedoLogResync;
 
/*----------------------------*
 * Datafile Copy resync       *
 *----------------------------*/
 
PROCEDURE deleteDuplicateCCF(recid IN NUMBER,
                             stamp IN NUMBER,
                             fname IN VARCHAR2) IS
   lfname ccf.fname%TYPE;
BEGIN
    lfname := fname;
 
    IF lfname IS NULL THEN
       BEGIN
          SELECT fname INTO lfname FROM ccf
          WHERE ccf.dbinc_key IN
                (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
            AND ccf_recid   = recid
            AND ccf_stamp   = stamp;
       EXCEPTION
          WHEN no_data_found THEN
             RETURN;
          WHEN too_many_rows THEN -- unique_key is dbinc_key, recid and stamp
             RETURN;
       END;
    END IF;
 
--
    DELETE ccf
    WHERE ccf.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
    AND   ccf.fname = lfname
    AND   ((disk_backups_shared = TRUE#) OR
           (this_site_key = nvl(ccf.site_key, this_site_key)))
    AND   ccf.fname_hashkey = substr(lfname, 1, 10) || substr(lfname, -10)
    AND   NOT (ccf.ccf_recid = recid AND
               ccf.ccf_stamp = stamp);
 
END deleteDuplicateCCF;
 
PROCEDURE addControlFileCopy(
  ccf_recid        IN NUMBER
 ,ccf_stamp        IN NUMBER
 ,fname            IN VARCHAR2
 ,tag              IN VARCHAR2
 ,dbinc_key        IN NUMBER
 ,ckp_scn          IN NUMBER
 ,ckp_time         IN DATE
 ,create_time      IN DATE
 ,min_offr_recid   IN NUMBER
 ,block_size       IN NUMBER
 ,completion_time  IN DATE
 ,status           IN VARCHAR2
 ,controlfile_type IN VARCHAR2 DEFAULT NULL
 ,keep_options     IN NUMBER   DEFAULT 0
 ,keep_until       IN DATE     DEFAULT NULL
 ,is_recovery_dest_file IN VARCHAR2
 ,rsr_key          IN NUMBER   DEFAULT NULL
 ,blocks           IN NUMBER
 ,pdb_key          IN NUMBER
) IS
 
local    ccf%rowtype;
 
BEGIN
  BEGIN
    IF (status <> 'D') THEN
       INSERT INTO ccf(ccf_key, dbinc_key, ccf_recid, ccf_stamp, fname,
          fname_hashkey, tag,
          ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
          completion_time, status, controlfile_type, keep_options, keep_until,
          is_recovery_dest_file, rsr_key, blocks, site_key, pdb_key)
       VALUES (rman_seq.nextval, dbinc_key, ccf_recid, ccf_stamp, fname,
         substr(fname,1,10)||substr(fname,-10), tag,
         ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
         completion_time, status, controlfile_type, keep_options, keep_until,
         is_recovery_dest_file, rsr_key, blocks, this_site_key, pdb_key);
   
       deleteDuplicateCCF(ccf_recid, ccf_stamp, fname);
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addControlFileCopy - Inside dup_val_on_index exception');
--
      SELECT * INTO local
      FROM ccf
      WHERE ccf.dbinc_key = addControlFileCopy.dbinc_key
      AND   ccf.ccf_recid = addControlFileCopy.ccf_recid
      AND   ccf.ccf_stamp = addControlFileCopy.ccf_stamp;
 
--
      IF client_site_aware AND this_site_key <> local.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (ckp_scn <> local.ckp_scn) THEN
        raise_application_error(-20095, 'Invalid ckp_scn');
      END IF;
 
--
      IF local.site_key IS NULL THEN
         UPDATE ccf SET site_key = this_site_key
         WHERE ccf.dbinc_key = addControlFileCopy.dbinc_key
           AND ccf.ccf_recid = addControlFileCopy.ccf_recid
           AND ccf.ccf_stamp = addControlFileCopy.ccf_stamp;
      END IF;
  END;
 
END addControlFileCopy;
 
PROCEDURE deleteDuplicateCDF(recid IN NUMBER,
                             stamp IN NUMBER,
                             fname IN VARCHAR2) IS
   lfname cdf.fname%TYPE;
BEGIN
    lfname := fname;
 
    IF lfname IS NULL THEN
       BEGIN
          SELECT fname INTO lfname FROM cdf
          WHERE cdf.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
            AND cdf_recid = recid
            AND cdf_stamp = stamp;
       EXCEPTION
          WHEN no_data_found THEN
             RETURN;
          WHEN too_many_rows THEN -- unique_key is dbinc_key, recid and stamp
             RETURN;
       END;
    END IF;
 
--
    DELETE cdf
    WHERE cdf.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
    AND   cdf.fname = lfname
    AND   ((disk_backups_shared = TRUE#) OR
           (this_site_key = nvl(cdf.site_key, this_site_key)))
    AND   cdf.fname_hashkey = substr(lfname, 1, 10) || substr(lfname, -10)
    AND   NOT (cdf.cdf_recid = recid AND
               cdf.cdf_stamp = stamp);
 
END deleteDuplicateCDF;
 
                             
PROCEDURE addDataFileCopy(
  cdf_recid       IN NUMBER
 ,cdf_stamp       IN NUMBER
 ,fname           IN VARCHAR2
 ,tag             IN VARCHAR2
 ,file#           IN NUMBER
 ,create_scn      IN NUMBER
 ,dbinc_key       IN NUMBER
 ,incr_level      IN NUMBER
 ,ckp_scn         IN NUMBER
 ,ckp_time        IN DATE
 ,onl_fuzzy       IN VARCHAR2
 ,bck_fuzzy       IN VARCHAR2
 ,abs_fuzzy_scn   IN NUMBER
 ,rcv_fuzzy_scn   IN NUMBER
 ,rcv_fuzzy_time  IN DATE
 ,blocks          IN NUMBER
 ,block_size      IN NUMBER
 ,completion_time IN DATE
 ,status          IN VARCHAR2
 ,keep_options    IN NUMBER
 ,keep_until      IN DATE
 ,scanned         IN VARCHAR2
 ,is_recovery_dest_file IN VARCHAR2
 ,rsr_key         IN NUMBER
 ,create_time     IN DATE
 ,marked_corrupt  IN NUMBER
 ,foreign_dbid      IN NUMBER
 ,plugged_readonly  IN VARCHAR2
 ,plugin_scn        IN NUMBER
 ,plugin_reset_scn  IN NUMBER
 ,plugin_reset_time IN DATE
 ,pdb_key           IN NUMBER
 ,sparse_backup     IN VARCHAR2
) IS
 
local    cdf%rowtype;
 
BEGIN
 
  BEGIN
    IF (status <> 'D') THEN
       INSERT INTO cdf(cdf_key, dbinc_key, cdf_recid, cdf_stamp,
          file#, create_scn, fname, fname_hashkey, tag, incr_level,
          ckp_scn, ckp_time, onl_fuzzy, bck_fuzzy, abs_fuzzy_scn,
          rcv_fuzzy_scn, rcv_fuzzy_time, blocks, block_size, completion_time,
          status, keep_options, keep_until, scanned, is_recovery_dest_file, 
          rsr_key, create_time, marked_corrupt, site_key, foreign_dbid,
          plugged_readonly, plugin_scn, plugin_reset_scn, plugin_reset_time,
          pdb_key, sparse_backup)
       VALUES
         (rman_seq.nextval, dbinc_key, cdf_recid, cdf_stamp,
          file#, create_scn, fname, substr(fname,1,10)||substr(fname, -10),
          tag, incr_level, ckp_scn, ckp_time,
          decode(onl_fuzzy,'YES','Y','NO','N'),
          decode(bck_fuzzy,'YES','Y','NO','N'), abs_fuzzy_scn,
          rcv_fuzzy_scn, rcv_fuzzy_time, blocks, block_size, completion_time,
          status, keep_options, keep_until,
          decode(scanned,'YES','Y','NO','N'), is_recovery_dest_file, 
          rsr_key, create_time, marked_corrupt, this_site_key,
          foreign_dbid, plugged_readonly, plugin_scn, plugin_reset_scn,
          plugin_reset_time, pdb_key, sparse_backup);
 
       deleteDuplicateCDF(cdf_recid, cdf_stamp, fname);
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addDataFileCopy - Inside dup_val_on_index exception');
      SELECT * INTO local
      FROM cdf
      WHERE cdf.dbinc_key = addDataFileCopy.dbinc_key
      AND   cdf.cdf_recid = addDataFileCopy.cdf_recid
      AND   cdf.cdf_stamp = addDataFileCopy.cdf_stamp;
 
--
      IF client_site_aware AND this_site_key <> local.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (file# <> local.file#) THEN
        raise_application_error(-20096, 'Invalid file');
      END IF;
      IF (create_scn <> local.create_scn AND
          plugin_scn <> local.plugin_scn) THEN
        raise_application_error(-20097, 'Invalid create scn');
      END IF;
 
--
      IF local.site_key IS NULL THEN
         UPDATE cdf SET site_key = this_site_key
         WHERE cdf.dbinc_key = addDataFileCopy.dbinc_key
           AND cdf.cdf_recid = addDataFileCopy.cdf_recid
           AND cdf.cdf_stamp = addDataFileCopy.cdf_stamp;
      END IF;
  END;
 
END addDataFileCopy;
 
FUNCTION beginDataFileCopyResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_cdf_recid INTO last_cdf_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_cdf_recid := sessionWaterMarks.high_cdf_recid;
  END IF;
 
  RETURN last_cdf_recid;
END beginDataFileCopyResync;
 
PROCEDURE checkDataFileCopy(
  cdf_recid        IN NUMBER
 ,cdf_stamp        IN NUMBER
 ,fname            IN VARCHAR2
 ,tag              IN VARCHAR2
 ,file#            IN NUMBER
 ,create_scn       IN NUMBER
 ,create_time      IN DATE
 ,reset_scn        IN NUMBER
 ,reset_time       IN DATE
 ,incr_level       IN NUMBER
 ,ckp_scn          IN NUMBER
 ,ckp_time         IN DATE
 ,onl_fuzzy        IN VARCHAR2
 ,bck_fuzzy        IN VARCHAR2
 ,abs_fuzzy_scn    IN NUMBER
 ,rcv_fuzzy_scn    IN NUMBER
 ,rcv_fuzzy_time   IN DATE
 ,blocks           IN NUMBER
 ,block_size       IN NUMBER
 ,min_offr_recid   IN NUMBER
 ,completion_time  IN DATE
 ,status           IN VARCHAR2
 ,controlfile_type IN VARCHAR2        DEFAULT NULL
 ,keep_options     IN NUMBER          DEFAULT 0
 ,keep_until       IN DATE            DEFAULT NULL
 ,scanned          IN VARCHAR2        DEFAULT 'NO'
 ,is_recovery_dest_file IN VARCHAR2   DEFAULT 'NO'
 ,rsr_recid        IN NUMBER          DEFAULT NULL
 ,rsr_stamp        IN NUMBER          DEFAULT NULL
 ,marked_corrupt   IN NUMBER          DEFAULT NULL
 ,foreign_dbid      IN NUMBER         DEFAULT 0
 ,plugged_readonly  IN VARCHAR2       DEFAULT 'NO'
 ,plugin_scn        IN NUMBER         DEFAULT 0
 ,plugin_reset_scn  IN NUMBER         DEFAULT 0
 ,plugin_reset_time IN DATE           DEFAULT NULL
 ,guid              IN RAW            DEFAULT NULL
 ,sparse_backup     IN VARCHAR2       DEFAULT 'NO'
 ,dropped_pdb       IN BINARY_INTEGER DEFAULT 0
) IS
 
dbinc_key NUMBER;
localrsr  rsr%rowtype;
l_pdb_key NUMBER;
 
BEGIN
  IF (last_cdf_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (cdf_recid < last_cdf_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (cdf_recid > last_cdf_recid + 1) THEN
--
--
    NULL;
  END IF;
  last_cdf_recid := cdf_recid;
 
  IF (cdf_stamp > 0 and cdf_stamp < kccdivts) THEN
     deb('checkBackupDatafileCopy - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
  dbinc_key := checkIncarnation(reset_scn, reset_time);
 
  l_pdb_key := guidToPdbKey(guid, dropped_pdb);
 
--
  BEGIN
      SELECT rsr_key
        INTO localrsr.rsr_key
        FROM rsr
       WHERE rsr.dbinc_key = this_dbinc_key
         AND (rsr.site_key = this_site_key OR
              rsr.site_key is null AND this_site_key is null)
         AND rsr.rsr_stamp = checkDataFileCopy.rsr_stamp
         AND rsr.rsr_recid = checkDataFileCopy.rsr_recid;
  EXCEPTION
  WHEN no_data_found THEN
--
      NULL;
  END;
 
  IF (file# = 0) THEN
    addControlFileCopy(cdf_recid, cdf_stamp, fname, tag, dbinc_key,
         ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
         completion_time, status, controlfile_type, keep_options, keep_until,
         is_recovery_dest_file, localrsr.rsr_key, blocks, l_pdb_key);
  ELSE
    addDataFileCopy(cdf_recid, cdf_stamp, fname, tag, file#, create_scn,
         dbinc_key, incr_level, ckp_scn, ckp_time,
         onl_fuzzy, bck_fuzzy, abs_fuzzy_scn, rcv_fuzzy_scn, rcv_fuzzy_time,
         blocks, block_size, completion_time, status,
         keep_options, keep_until, scanned, is_recovery_dest_file,
         localrsr.rsr_key, create_time, marked_corrupt, foreign_dbid,
         plugged_readonly, plugin_scn, plugin_reset_scn, plugin_reset_time,
         l_pdb_key, sparse_backup);
  END IF;
END checkDataFileCopy;
 
PROCEDURE endDataFileCopyResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_cdf_recid = last_cdf_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_cdf_recid := last_cdf_recid;
  last_cdf_recid := NULL;
 
END endDataFileCopyResync;
 
/*----------------------------*
 * Proxy Datafile resync      *
 *----------------------------*/
 
PROCEDURE deleteDuplicateXCF(recid       IN NUMBER,
                             stamp       IN NUMBER,
                             device_type IN VARCHAR2,
                             handle      IN VARCHAR2) IS
   lhandle      xcf.handle%TYPE;
   ldevice_type xcf.device_type%TYPE;
 
BEGIN
    lhandle := handle;
 
    IF lhandle IS NULL OR ldevice_type IS NULL THEN
       BEGIN
          SELECT handle, device_type INTO lhandle, ldevice_type FROM xcf
          WHERE xcf.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
            AND xcf_recid = recid
            AND xcf_stamp = stamp;
       EXCEPTION
          WHEN no_data_found THEN
             RETURN;
          WHEN too_many_rows THEN -- unique_key is dbinc_key, recid and stamp
             RETURN;
       END;
    END IF;
 
--
    DELETE xcf
    WHERE xcf.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
    AND   xcf.device_type = ldevice_type
    AND   xcf.handle = lhandle
    AND   ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(xcf.site_key, this_site_key)))
    AND   xcf.handle_hashkey =
              substr(ldevice_type, 1, 10) ||
              substr(lhandle, 1, 10) ||
              substr(lhandle, -10)
    AND   NOT (xcf.xcf_recid = recid AND
               xcf.xcf_stamp = stamp);
 
END deleteDuplicateXCF;
 
PROCEDURE addProxyControlFile(
  dbinc_key       IN NUMBER
 ,xcf_recid       IN NUMBER
 ,xcf_stamp       IN NUMBER
 ,tag             IN VARCHAR2
 ,ckp_scn         IN NUMBER
 ,ckp_time        IN DATE
 ,create_time     IN DATE
 ,min_offr_recid  IN NUMBER
 ,block_size      IN NUMBER
 ,device_type     IN VARCHAR2
 ,handle          IN VARCHAR2
 ,comments        IN VARCHAR2
 ,media           IN VARCHAR2
 ,media_pool      IN NUMBER
 ,start_time      IN VARCHAR2
 ,completion_time IN DATE
 ,status          IN VARCHAR2
 ,controlfile_type
                  IN VARCHAR2
 ,keep_options    IN NUMBER
 ,keep_until      IN DATE
 ,rsr_key         IN NUMBER
 ,blocks          IN NUMBER
 ,pdb_key         IN NUMBER
) IS
 
local    xcf%rowtype;
 
BEGIN
  BEGIN
    IF (status <> 'D') THEN
      INSERT INTO xcf(xcf_key, dbinc_key, xcf_recid, xcf_stamp, tag,
        ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
        device_type, handle, handle_hashkey, comments, media, media_pool,
        start_time, completion_time, status, controlfile_type, keep_options,
        keep_until, rsr_key, site_key, pdb_key)
      VALUES (rman_seq.nextval, dbinc_key, xcf_recid, xcf_stamp, tag,
        ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
        device_type, handle,
        substr(device_type,1,10)||substr(handle,1,10)||substr(handle,-10),
        comments, media, media_pool, start_time, completion_time, status,
        controlfile_type, keep_options, keep_until, rsr_key, this_site_key,
        pdb_key);
 
      deleteDuplicateXCF(xcf_recid, xcf_stamp, device_type, handle);
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addProxyControlFile - Inside dup_val_on_index exception');
--
      SELECT * INTO local
      FROM xcf
      WHERE xcf.dbinc_key = addProxyControlFile.dbinc_key
      AND   xcf.xcf_recid = addProxyControlFile.xcf_recid
      AND   xcf.xcf_stamp = addProxyControlFile.xcf_stamp;
 
--
      IF client_site_aware AND this_site_key <> local.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (ckp_scn <> local.ckp_scn) THEN
        raise_application_error(-20095, 'Invalid ckp_scn');
      END IF;
 
--
      IF local.site_key IS NULL THEN
         UPDATE xcf SET site_key = this_site_key
         WHERE xcf.dbinc_key = addProxyControlFile.dbinc_key
           AND xcf.xcf_recid = addProxyControlFile.xcf_recid
           AND xcf.xcf_stamp = addProxyControlFile.xcf_stamp;
      END IF;
  END;
 
END addProxyControlFile;
 
PROCEDURE deleteDuplicateXDF(recid       IN NUMBER,
                             stamp       IN NUMBER,
                             device_type IN VARCHAR2,
                             handle      IN VARCHAR2) IS
   lhandle      xdf.handle%TYPE;
   ldevice_type xdf.device_type%TYPE;
 
BEGIN
    lhandle := handle;
 
    IF lhandle IS NULL OR ldevice_type IS NULL THEN
       BEGIN
          SELECT handle, device_type INTO lhandle, ldevice_type FROM xdf
           WHERE xdf.dbinc_key IN
                 (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
            AND xdf_recid = recid
            AND xdf_stamp = stamp;
       EXCEPTION
          WHEN no_data_found THEN
             RETURN;
          WHEN too_many_rows THEN -- unique_key is dbinc_key, recid and stamp
             RETURN;
       END;
    END IF;
 
--
    DELETE xdf
    WHERE xdf.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
    AND   xdf.device_type = ldevice_type
    AND   xdf.handle = lhandle
    AND   ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(xdf.site_key, this_site_key)))
    AND   xdf.handle_hashkey =
              substr(ldevice_type, 1, 10) ||
              substr(lhandle, 1, 10) ||
              substr(lhandle, -10)
    AND   NOT (xdf.xdf_recid = recid AND
               xdf.xdf_stamp = stamp);
 
END deleteDuplicateXDF;
 
PROCEDURE addProxyDataFile(
  dbinc_key       IN NUMBER
 ,xdf_recid       IN NUMBER
 ,xdf_stamp       IN NUMBER
 ,tag             IN VARCHAR2
 ,file#           IN NUMBER
 ,create_scn      IN NUMBER
 ,incr_level      IN NUMBER
 ,ckp_scn         IN NUMBER
 ,ckp_time        IN DATE
 ,onl_fuzzy       IN VARCHAR2
 ,bck_fuzzy       IN VARCHAR2
 ,abs_fuzzy_scn   IN NUMBER
 ,rcv_fuzzy_scn   IN NUMBER
 ,rcv_fuzzy_time  IN DATE
 ,blocks          IN NUMBER
 ,block_size      IN NUMBER
 ,device_type     IN VARCHAR2
 ,handle          IN VARCHAR2
 ,comments        IN VARCHAR2
 ,media           IN VARCHAR2
 ,media_pool      IN NUMBER
 ,start_time      IN VARCHAR2
 ,completion_time IN DATE
 ,status          IN VARCHAR2
 ,keep_options    IN NUMBER   DEFAULT 0
 ,keep_until      IN DATE     DEFAULT NULL
 ,rsr_key         IN NUMBER
 ,create_time     IN DATE
 ,foreign_dbid      IN NUMBER
 ,plugged_readonly  IN VARCHAR2
 ,plugin_scn        IN NUMBER
 ,plugin_reset_scn  IN NUMBER
 ,plugin_reset_time IN DATE
 ,pdb_key           IN NUMBER
) IS
 
local    xdf%rowtype;
 
BEGIN
 
  BEGIN
    IF (status <> 'D') THEN
      INSERT INTO xdf(xdf_key, dbinc_key, xdf_recid, xdf_stamp,
         file#, create_scn, tag, incr_level,
         ckp_scn, ckp_time, onl_fuzzy, bck_fuzzy, abs_fuzzy_scn,
         rcv_fuzzy_scn, rcv_fuzzy_time, blocks, block_size,
         device_type, handle, handle_hashkey, comments, media, media_pool,
         start_time, completion_time, status,
         keep_options, keep_until, rsr_key, site_key, foreign_dbid,
         plugged_readonly, plugin_scn, plugin_reset_scn, plugin_reset_time,
         pdb_key)
      VALUES
        (rman_seq.nextval, dbinc_key, xdf_recid, xdf_stamp,
         file#, create_scn, tag,
         incr_level, ckp_scn, ckp_time, decode(onl_fuzzy,'YES','Y','NO','N'),
         decode(bck_fuzzy,'YES','Y','NO','N'), abs_fuzzy_scn,
         rcv_fuzzy_scn, rcv_fuzzy_time, blocks, block_size,
         device_type, handle,
         substr(device_type,1,10)||substr(handle,1,10)||substr(handle,-10),
         comments, media, media_pool, start_time, completion_time, status,
         keep_options, keep_until, rsr_key, this_site_key, foreign_dbid,
         plugged_readonly, plugin_scn, plugin_reset_scn, plugin_reset_time,
         pdb_key);
 
       deleteDuplicateXDF(xdf_recid, xdf_stamp, device_type, handle);
    END IF;
 
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addProxyDatafile - Inside dup_val_on_index exception');
      SELECT * INTO local
      FROM xdf
      WHERE xdf.dbinc_key = addProxyDataFile.dbinc_key
      AND   xdf.xdf_recid = addProxyDataFile.xdf_recid
      AND   xdf.xdf_stamp = addProxyDataFile.xdf_stamp;
 
--
      IF client_site_aware AND this_site_key <> local.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (file# <> local.file#) THEN
        raise_application_error(-20096, 'Invalid file');
      END IF;
      IF (create_scn <> local.create_scn AND
          plugin_scn <> local.plugin_scn) THEN
        raise_application_error(-20097, 'Invalid create scn');
      END IF;
 
--
      IF local.site_key IS NULL THEN
         UPDATE xdf SET site_key = this_site_key
         WHERE xdf.dbinc_key = addProxyDataFile.dbinc_key
           AND xdf.xdf_recid = addProxyDataFile.xdf_recid
           AND xdf.xdf_stamp = addProxyDataFile.xdf_stamp;
      END IF;
  END;
 
END addProxyDataFile;
 
PROCEDURE deleteDuplicateXAL(recid       IN NUMBER,
                             stamp       IN NUMBER,
                             device_type IN VARCHAR2,
                             handle      IN VARCHAR2) IS
   lhandle      xal.handle%TYPE;
   ldevice_type xal.device_type%TYPE;
 
BEGIN
    lhandle := handle;
 
    IF lhandle IS NULL OR ldevice_type IS NULL THEN
       BEGIN
          SELECT handle, device_type INTO lhandle, ldevice_type FROM xal
          WHERE xal.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
            AND xal_recid = recid
            AND xal_stamp = stamp;
       EXCEPTION
          WHEN no_data_found THEN
             RETURN;
          WHEN too_many_rows THEN -- unique_key is dbinc_key, recid and stamp
             RETURN;
       END;
    END IF;
 
--
    DELETE xal
    WHERE xal.dbinc_key IN
            (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
    AND   xal.device_type = ldevice_type
    AND   xal.handle = lhandle
    AND   ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(xal.site_key, this_site_key)))
    AND   xal.handle_hashkey =
              substr(ldevice_type, 1, 10) ||
              substr(lhandle, 1, 10) ||
              substr(lhandle, -10)
    AND   NOT (xal.xal_recid = recid AND
               xal.xal_stamp = stamp);
 
END deleteDuplicateXAL;
 
PROCEDURE addProxyArchivedLog(
  dbinc_key           IN NUMBER
 ,xal_recid           IN NUMBER
 ,xal_stamp           IN NUMBER
 ,tag                 IN VARCHAR2
 ,thread#             IN NUMBER
 ,sequence#           IN NUMBER
 ,resetlogs_change#   IN NUMBER
 ,resetlogs_time      IN DATE
 ,first_change#       IN NUMBER
 ,first_time          IN DATE
 ,next_change#        IN NUMBER
 ,next_time           IN DATE
 ,blocks              IN NUMBER
 ,block_size          IN NUMBER
 ,device_type         IN VARCHAR2
 ,handle              IN VARCHAR2
 ,comments            IN VARCHAR2
 ,media               IN VARCHAR2
 ,media_pool          IN NUMBER
 ,start_time          IN VARCHAR2
 ,completion_time     IN DATE
 ,status              IN VARCHAR2
 ,rsr_key             IN NUMBER
 ,terminal            IN VARCHAR2 default 'NO'
 ,keep_until          IN DATE      default NULL
 ,keep_options        IN NUMBER    default 0
) IS
 
local    xal%rowtype;
 
BEGIN
 
  BEGIN
    IF (status <> 'D') THEN
      INSERT INTO xal(xal_key, dbinc_key, xal_recid, xal_stamp, tag,
         thread#, sequence#, low_scn, low_time, next_scn, next_time,
         blocks, block_size, device_type, handle, handle_hashkey,
         comments, media, media_pool, start_time, completion_time, status,
         rsr_key, terminal, keep_until, keep_options, site_key)
      VALUES
        (rman_seq.nextval, dbinc_key, xal_recid, xal_stamp, tag,
         thread#, sequence#, first_change#, first_time, next_change#,
         next_time, blocks, block_size, device_type, handle,
         substr(device_type,1,10)||substr(handle,1,10)||substr(handle,-10),
         comments, media, media_pool, start_time, completion_time, status,
         rsr_key, terminal, keep_until, keep_options, this_site_key);
 
      deleteDuplicateXAL(xal_recid, xal_stamp, device_type, handle);
    END IF;
 
  EXCEPTION
    WHEN dup_val_on_index THEN
      deb('addProxyArchivedLog - Inside dup_val_on_index exception');
      SELECT * INTO local
      FROM xal
      WHERE xal.dbinc_key = addProxyArchivedLog.dbinc_key
      AND   xal.xal_recid = addProxyArchivedLog.xal_recid
      AND   xal.xal_stamp = addProxyArchivedLog.xal_stamp;
 
--
      IF client_site_aware AND this_site_key <> local.site_key THEN
          raise_application_error(-20081, 'change stamp for the record');
      END IF;
 
--
      IF (first_change# <> local.low_scn) THEN
        raise_application_error(-20098, 'Invalid low scn');
      END IF;
 
--
      IF local.site_key IS NULL THEN
         UPDATE xal SET site_key = this_site_key
         WHERE xal.dbinc_key = addProxyArchivedLog.dbinc_key
           AND xal.xal_recid = addProxyArchivedLog.xal_recid
           AND xal.xal_stamp = addProxyArchivedLog.xal_stamp;
      END IF;
  END;
 
  IF (keep_options > 0) THEN
    updateRestorePoint(first_change#, next_change#);
  END IF;
END addProxyArchivedLog;
 
--
--
FUNCTION beginProxyResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_pc_recid INTO last_xdf_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_xdf_recid := sessionWaterMarks.high_pc_recid;
  END IF;
 
  last_xal_recid := last_xdf_recid;
 
  RETURN last_xdf_recid;
END beginProxyResync;
 
PROCEDURE checkProxyDataFile(
  xdf_recid       IN NUMBER
 ,xdf_stamp       IN NUMBER
 ,tag             IN VARCHAR2
 ,file#           IN NUMBER
 ,create_scn      IN NUMBER
 ,create_time     IN DATE
 ,reset_scn       IN NUMBER
 ,reset_time      IN DATE
 ,incr_level      IN NUMBER
 ,ckp_scn         IN NUMBER
 ,ckp_time        IN DATE
 ,onl_fuzzy       IN VARCHAR2
 ,bck_fuzzy       IN VARCHAR2
 ,abs_fuzzy_scn   IN NUMBER
 ,rcv_fuzzy_scn   IN NUMBER
 ,rcv_fuzzy_time  IN DATE
 ,blocks          IN NUMBER
 ,block_size      IN NUMBER
 ,min_offr_recid  IN NUMBER
 ,device_type     IN VARCHAR2
 ,handle          IN VARCHAR2
 ,comments        IN VARCHAR2
 ,media           IN VARCHAR2
 ,media_pool      IN NUMBER
 ,start_time      IN DATE
 ,completion_time IN DATE
 ,status          IN VARCHAR2
 ,controlfile_type
                  IN VARCHAR2         DEFAULT NULL
 ,keep_options    IN NUMBER           DEFAULT 0
 ,keep_until      IN DATE             DEFAULT NULL
 ,rsr_recid       IN NUMBER           DEFAULT NULL
 ,rsr_stamp       IN NUMBER           DEFAULT NULL
 ,foreign_dbid      IN NUMBER         DEFAULT 0
 ,plugged_readonly  IN VARCHAR2       DEFAULT 'NO'
 ,plugin_scn        IN NUMBER         DEFAULT 0
 ,plugin_reset_scn  IN NUMBER         DEFAULT 0
 ,plugin_reset_time IN DATE           DEFAULT NULL
 ,guid              IN RAW            DEFAULT NULL
 ,dropped_pdb       IN BINARY_INTEGER DEFAULT 0
) IS
 
dbinc_key NUMBER;
localrsr  rsr%rowtype;
l_pdb_key NUMBER;
 
BEGIN
  IF (last_xdf_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (xdf_recid < last_xdf_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
--
--
  last_xdf_recid := xdf_recid;
 
  IF (xdf_stamp > 0 and xdf_stamp < kccdivts) THEN
     deb('checkProxyDatafile - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
--
  dbinc_key := checkIncarnation(reset_scn, reset_time);
 
  l_pdb_key := guidToPdbKey(guid, dropped_pdb);
 
--
  BEGIN
      SELECT rsr_key
        INTO localrsr.rsr_key
        FROM rsr
       WHERE rsr.dbinc_key = this_dbinc_key
         AND (rsr.site_key = this_site_key OR
              rsr.site_key is null AND this_site_key is null)
         AND rsr.rsr_stamp = checkProxyDataFile.rsr_stamp
         AND rsr.rsr_recid = checkProxyDataFile.rsr_recid;
  EXCEPTION
  WHEN no_data_found THEN
--
      NULL;
  END;
 
  IF (file# = 0) THEN
    addProxyControlFile(dbinc_key, xdf_recid, xdf_stamp, tag,
         ckp_scn, ckp_time, create_time, min_offr_recid, block_size,
         device_type, handle, comments, media, media_pool, start_time,
         completion_time, status, controlfile_type, keep_options, keep_until,
         localrsr.rsr_key, blocks, l_pdb_key);
  ELSE
    addProxyDataFile(dbinc_key, xdf_recid, xdf_stamp, tag, file#, create_scn,
         incr_level, ckp_scn, ckp_time,
         onl_fuzzy, bck_fuzzy, abs_fuzzy_scn, rcv_fuzzy_scn, rcv_fuzzy_time,
         blocks, block_size, device_type, handle, comments, media, media_pool,
         start_time, completion_time, status, keep_options, keep_until,
         localrsr.rsr_key, create_time, foreign_dbid, plugged_readonly,
         plugin_scn, plugin_reset_scn, plugin_reset_time, l_pdb_key);
  END IF;
 
END checkProxyDataFile;
 
PROCEDURE checkProxyArchivedLog(
  xal_recid          IN NUMBER
 ,xal_stamp          IN NUMBER
 ,tag                IN VARCHAR2
 ,thread#            IN NUMBER
 ,sequence#          IN NUMBER
 ,resetlogs_change#  IN NUMBER
 ,resetlogs_time     IN DATE
 ,first_change#      IN NUMBER
 ,first_time         IN DATE
 ,next_change#       IN NUMBER
 ,next_time          IN DATE
 ,blocks             IN NUMBER
 ,block_size         IN NUMBER
 ,device_type        IN VARCHAR2
 ,handle             IN VARCHAR2
 ,comments           IN VARCHAR2
 ,media              IN VARCHAR2
 ,media_pool         IN NUMBER
 ,start_time         IN DATE
 ,completion_time    IN DATE
 ,status             IN VARCHAR2
 ,rsr_recid          IN NUMBER
 ,rsr_stamp          IN NUMBER
 ,terminal           IN VARCHAR2  default 'NO'
 ,keep_until         IN DATE      default NULL
 ,keep_options       IN NUMBER    default 0
) IS
dbinc_key NUMBER;
localrsr  rsr%rowtype;
BEGIN
  IF (last_xal_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (xal_recid < last_xal_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
--
--
  last_xal_recid := xal_recid;
 
  IF (xal_stamp > 0 and xal_stamp < kccdivts) THEN
     deb('checkProxyArchivedLog - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
--
  dbinc_key := checkIncarnation(resetlogs_change#, resetlogs_time);
 
--
  BEGIN
      SELECT rsr_key
        INTO localrsr.rsr_key
        FROM rsr
       WHERE rsr.dbinc_key = this_dbinc_key
         AND (rsr.site_key = this_site_key OR
              rsr.site_key is null AND this_site_key is null)
         AND rsr.rsr_stamp = checkProxyArchivedLog.rsr_stamp
         AND rsr.rsr_recid = checkProxyArchivedLog.rsr_recid;
  EXCEPTION
  WHEN no_data_found THEN
--
      NULL;
  END;
 
  addProxyArchivedLog(dbinc_key, xal_recid, xal_stamp, tag, thread#, sequence#,
         resetlogs_change#, resetlogs_time, first_change#, first_time,
         next_change#, next_time, blocks, block_size, device_type, handle,
         comments, media, media_pool, start_time, completion_time, status,
         localrsr.rsr_key, terminal, keep_until, keep_options);
 
END checkProxyArchivedLog;
 
PROCEDURE endProxyResync IS
  last_pc_recid number :=
                   greatest(nvl(last_xdf_recid,0), nvl(last_xal_recid,0));
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_pc_recid = last_pc_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_pc_recid := last_pc_recid;
  last_xdf_recid := NULL;
  last_xal_recid := NULL;
 
END endProxyResync;
 
/*----------------------------*
 * Corrupt Block resync       *
 *----------------------------*/
 
FUNCTION beginBackupCorruptionResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_bcb_recid INTO last_bcb_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_bcb_recid := sessionWaterMarks.high_bcb_recid;
  END IF;
 
  RETURN last_bcb_recid;
END beginBackupCorruptionResync;
 
PROCEDURE checkBackupCorruption(
  bcb_recid       IN NUMBER
 ,bcb_stamp       IN NUMBER
 ,set_stamp       IN NUMBER
 ,set_count       IN NUMBER
 ,piece#          IN NUMBER
 ,file#           IN NUMBER
 ,block#          IN NUMBER
 ,blocks          IN NUMBER
 ,corrupt_scn     IN NUMBER
 ,marked_corrupt  IN VARCHAR2
 ,corruption_type IN VARCHAR2
) IS
 
local   bcb%rowtype;
 
BEGIN
  IF (last_bcb_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (bcb_recid < last_bcb_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (bcb_recid > last_bcb_recid + 1) THEN
--
--
    NULL;
  END IF;
  last_bcb_recid := bcb_recid;
 
  IF (bcb_stamp > 0 and bcb_stamp < kccdivts) THEN
     deb('checkBackupCorruption - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
  BEGIN
    SELECT bdf_key INTO local.bdf_key
    FROM  bdf, bs
    WHERE bdf.bs_key = bs.bs_key
    AND   bs.db_key = this_db_key
    AND   bs.set_stamp = checkBackupCorruption.set_stamp
    AND   bs.set_count = checkBackupCorruption.set_count
    AND   bdf.file# =    checkBackupCorruption.file#;
  EXCEPTION
    WHEN no_data_found THEN
--
      RETURN;
  END;
 
  BEGIN
    INSERT INTO bcb
      (bdf_key, bcb_recid, bcb_stamp, piece#, block#, blocks,
       corrupt_scn, marked_corrupt, corruption_type)
    VALUES
      (local.bdf_key, bcb_recid, bcb_stamp, piece#, block#, blocks,
       corrupt_scn, decode(marked_corrupt,'YES','Y','NO','N'),
       corruption_type);
  EXCEPTION
    WHEN dup_val_on_index THEN
--
      RETURN;
  END;
 
END checkBackupCorruption;
 
PROCEDURE endBackupCorruptionResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_bcb_recid = last_bcb_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_bcb_recid := last_bcb_recid;
  last_bcb_recid := NULL;
 
END endBackupCorruptionResync;
 
FUNCTION beginCopyCorruptionResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_ccb_recid INTO last_ccb_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_ccb_recid :=  sessionWaterMarks.high_ccb_recid;
  END IF;
 
  RETURN last_ccb_recid;
END beginCopyCorruptionResync;
 
PROCEDURE checkCopyCorruption(
  ccb_recid       IN NUMBER
 ,ccb_stamp       IN NUMBER
 ,cdf_recid       IN NUMBER
 ,cdf_stamp       IN NUMBER
 ,file#           IN NUMBER
 ,block#          IN NUMBER
 ,blocks          IN NUMBER
 ,corrupt_scn     IN NUMBER
 ,marked_corrupt  IN VARCHAR2
 ,corruption_type IN VARCHAR2
) IS
 
local   ccb%rowtype;
 
BEGIN
   IF (last_ccb_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (ccb_recid < last_ccb_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (ccb_recid > last_ccb_recid + 1) THEN
--
--
    NULL;
  END IF;
  last_ccb_recid := ccb_recid;
 
  IF (ccb_stamp > 0 and ccb_stamp < kccdivts) THEN
     deb('checkCopyCorruption - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
  BEGIN
    SELECT cdf_key INTO local.cdf_key
    FROM  cdf
    WHERE cdf.dbinc_key = this_dbinc_key
    AND   cdf.cdf_recid = checkCopyCorruption.cdf_recid
    AND   cdf.cdf_stamp = checkCopyCorruption.cdf_stamp
    AND   cdf.file# = checkCopyCorruption.file#;
  EXCEPTION
    WHEN no_data_found THEN
--
      RETURN;
  END;
 
  BEGIN
    INSERT INTO ccb
      (cdf_key, ccb_recid, ccb_stamp, block#, blocks,
       corrupt_scn, marked_corrupt, corruption_type)
    VALUES
      (local.cdf_key, ccb_recid, ccb_stamp, block#, blocks,
       corrupt_scn, decode(marked_corrupt,'YES','Y','NO','N'),
       corruption_type);
  EXCEPTION
    WHEN dup_val_on_index THEN
--
      RETURN;
  END;
END checkCopyCorruption;
 
PROCEDURE endCopyCorruptionResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_ccb_recid = last_ccb_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_ccb_recid := last_ccb_recid;
  last_ccb_recid := NULL;
 
END endCopyCorruptionResync;
 
FUNCTION beginBlockCorruptionResync(
  low_bcr_recid IN number)
RETURN NUMBER IS
   old_bcr_recid number;
BEGIN
  checkResync;
 
  SELECT high_bcr_recid, low_bcr_recid
    INTO last_bcr_recid, old_bcr_recid
    FROM node
   WHERE site_key = this_site_key;
 
--
--
--
--
--
--
--
--
  IF (old_bcr_recid != low_bcr_recid) THEN
     DELETE bcr
      WHERE site_key = this_site_key
        AND bcr_recid < low_bcr_recid;
     UPDATE node SET low_bcr_recid = low_bcr_recid
     WHERE site_key = this_site_key;
  END IF;
 
  RETURN last_bcr_recid;
END beginBlockCorruptionResync;
 
PROCEDURE checkBlockCorruption(
  bcr_recid       IN NUMBER
 ,bcr_stamp       IN NUMBER
 ,file#           IN NUMBER
 ,create_scn      IN NUMBER
 ,create_time     IN DATE
 ,block#          IN NUMBER
 ,blocks          IN NUMBER
 ,corrupt_scn     IN NUMBER
 ,corruption_type IN VARCHAR2
) IS
 
local   df%rowtype;
 
BEGIN
  IF (last_bcr_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (bcr_recid < last_bcr_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (bcr_recid > last_bcr_recid + 1) THEN
--
--
    NULL;
  END IF;
 
  last_bcr_recid := bcr_recid;
 
--
  BEGIN
    SELECT distinct df.df_key INTO local.df_key
    FROM  df, site_dfatt
    WHERE df.df_key = site_dfatt.df_key
    AND   site_dfatt.site_key = this_site_key
    AND   df.file# = checkBlockCorruption.file#
    AND   df.create_scn = checkBlockCorruption.create_scn
    AND   df.create_time = checkBlockCorruption.create_time;
  EXCEPTION
    WHEN no_data_found THEN
--
      deb('checkBlockCorruption - no df_key found');
      RETURN;
  END;
 
  deb('checkBlockCorruption - df_key=' || local.df_key);
 
  BEGIN
    INSERT INTO bcr 
      (bcr_recid, bcr_stamp, df_key, site_key,
       block#, blocks, corrupt_scn, corruption_type)
    VALUES
      (bcr_recid, bcr_stamp, local.df_key, this_site_key,
       block#, blocks, corrupt_scn, corruption_type);
  EXCEPTION
    WHEN dup_val_on_index THEN
--
      RETURN;
  END;
END checkBlockCorruption;
 
PROCEDURE endBlockCorruptionResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_bcr_recid = last_bcr_recid
      WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_bcr_recid := last_bcr_recid;
  last_bcr_recid := NULL;
END endBlockCorruptionResync;
 
/*----------------------------*
 * Deleted Object resync      *
 *----------------------------*/
 
FUNCTION beginDeletedObjectResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_do_recid INTO last_do_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_do_recid := sessionWaterMarks.high_do_recid;
  END IF;
 
  deb('beginDeletedObjectResync - last_do_recid='||last_do_recid);
  RETURN last_do_recid;
END beginDeletedObjectResync;
 
PROCEDURE checkDeletedObject(
  do_recid          IN NUMBER
 ,do_stamp          IN NUMBER
 ,object_type       IN VARCHAR2
 ,object_recid      IN NUMBER
 ,object_stamp      IN NUMBER
 ,object_data       IN NUMBER   DEFAULT NULL
 ,object_fname      IN VARCHAR2 DEFAULT NULL
 ,object_create_scn IN NUMBER   DEFAULT NULL
 ,set_stamp         IN NUMBER   DEFAULT NULL
 ,set_count         IN NUMBER   DEFAULT NULL
 ,handle            IN VARCHAR2 DEFAULT NULL
 ,device_type       IN VARCHAR2 DEFAULT NULL)
IS
  local            bp%rowtype;
  new_status       VARCHAR2(1);
  rc               boolean;
  keep_options     number := NULL;
  keep_until       date   := NULL;
BEGIN
  IF (last_do_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (do_recid < last_do_recid) THEN
    deb('checkDeletedObject - last_do_recid=' || last_do_recid);
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
--
  IF (do_recid > last_do_recid + 1) THEN
--
    NULL;
  END IF;
  last_do_recid := do_recid;
 
  IF (do_stamp > 0 AND do_stamp < kccdivts) THEN
     deb('checkDeletedObject - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
--
--
 
  IF (object_type like 'BACKUP SET%') THEN
    IF (object_type = 'BACKUP SET KEEP UNTIL') THEN 
      IF (object_data > 0) THEN
         keep_until := stamp2date(object_data);
      END IF;
    ELSIF (object_type = 'BACKUP SET KEEP OPTIONS') THEN
       keep_options := object_data;
    ELSE
        raise_application_error(-20999,
           'Internal error in checkDeletedObject(): bad object_type '||
           object_type);
    END IF;
 
    changeBackupSet(object_recid, object_stamp,
                    keep_options, keep_until);
  END IF;
 
  IF (object_type like 'BACKUP PIECE%') THEN
    IF (object_type = 'BACKUP PIECE') THEN
       new_status := 'D';
    ELSIF (object_type = 'BACKUP PIECE AVAILABLE') THEN
       new_status := 'A';
    ELSIF (object_type = 'BACKUP PIECE EXPIRED') THEN
       new_status := 'X';
    ELSIF (object_type = 'BACKUP PIECE UNAVAILABLE') THEN
       new_status := 'U';
    ELSE
       raise_application_error(-20999,
           'Internal error in checkDeletedObject(): bad object_type '||
           object_type);
    END IF;
    changeBackupPiece(object_recid, object_stamp, new_status,
                      set_stamp, set_count, NULL /* osite_key */,
                      NULL /*nsite_key */, handle, device_type);
  END IF;
 
  IF (object_type like 'DATAFILE COPY%') THEN
    IF (object_type = 'DATAFILE COPY') THEN
       new_status := 'D';
    ELSIF (object_type = 'DATAFILE COPY AVAILABLE') THEN
       new_status := 'A';
    ELSIF (object_type = 'DATAFILE COPY EXPIRED') THEN
       new_status := 'X';
    ELSIF (object_type = 'DATAFILE COPY UNAVAILABLE') THEN
       new_status := 'U';
    ELSIF (object_type = 'DATAFILE COPY KEEP UNTIL') THEN
       new_status := NULL;
       keep_until := stamp2date(object_data);
    ELSIF (object_type = 'DATAFILE COPY KEEP OPTIONS') THEN
       new_status := NULL;
       keep_options := object_data;
    ELSE
        raise_application_error(-20999,
           'Internal error in checkDeletedObject(): bad object_type '||
           object_type);
    END IF;
    changeDatafileCopy(object_recid, object_stamp, new_status,
                       keep_options, keep_until);
  END IF;
 
  IF (object_type like 'ARCHIVED LOG%') THEN
    IF (object_type = 'ARCHIVED LOG') THEN
       new_status := 'D';
    ELSIF (object_type = 'ARCHIVED LOG AVAILABLE') THEN
       new_status := 'A';
    ELSIF (object_type = 'ARCHIVED LOG EXPIRED') THEN
       new_status := 'X';
    ELSIF (object_type = 'ARCHIVED LOG UNAVAILABLE') THEN
       new_status := 'U';
    ELSE
       raise_application_error(-20999,
           'Internal error in checkDeletedObject(): bad object_type '||
           object_type);
    END IF;
    changeArchivedLog(object_recid, object_stamp, new_status);
  END IF;
 
  IF (object_type like 'PROXY COPY%') THEN
    IF (object_type = 'PROXY COPY') THEN
       new_status := 'D';
    ELSIF (object_type = 'PROXY COPY AVAILABLE') THEN
       new_status := 'A';
    ELSIF (object_type = 'PROXY COPY EXPIRED') THEN
       new_status := 'X';
    ELSIF (object_type = 'PROXY COPY UNAVAILABLE') THEN
       new_status := 'U';
    ELSIF (object_type = 'PROXY COPY KEEP UNTIL') THEN
       new_status := NULL;
       keep_until := stamp2date(object_data);
    ELSIF (object_type = 'PROXY COPY KEEP OPTIONS') THEN
       new_status := NULL;
       keep_options := object_data;
    ELSE
       raise_application_error(-20999,
           'Internal error in checkDeletedObject(): bad object_type '||
           object_type);
    END IF;
    changeProxyCopy(object_recid, object_stamp, new_status,
                    keep_options, keep_until);
  END IF;
 
  IF (object_type = 'DATAFILE RENAME ON RESTORE')
  THEN
    deb('checkDeletedObject - renaming file#='||object_data||' to '||
        object_fname);
 
--
--
--
--
--
    DECLARE
      local_df_key NUMBER;
    BEGIN
      SELECT DISTINCT df_key INTO local_df_key FROM df
      WHERE dbinc_key = this_dbinc_key
        AND   df.file# = object_data
        AND   df.create_scn = object_create_scn;
 
      UPDATE site_dfatt SET
        fname = object_fname
      WHERE 
        site_key = this_site_key AND
        df_key   = local_df_key;
 
      IF (NOT SQL%FOUND) THEN
        deb('checkDeletedObject - doing an insert');
        INSERT INTO site_dfatt (fname, df_key, site_key)
          VALUES (object_fname, local_df_key, this_site_key);
      END IF;
    EXCEPTION
     WHEN no_data_found THEN
        NULL;
    END;
  END IF;
 
  IF (object_type = 'PLUGGED READONLY RENAME')
  THEN
    deb('In checkDeletedObject, renaming plugged readonly file#='||
        object_data||' to ' ||object_fname);
--
--
--
--
--
--
--
    DECLARE
      CURSOR df_key_plugin_cur(file# IN NUMBER,
                               plugin_scn IN NUMBER) IS
        SELECT df_key FROM df
          WHERE dbinc_key = this_dbinc_key
            AND   df.file# = df_key_plugin_cur.file#
            AND   df.plugin_scn = df_key_plugin_cur.plugin_scn;
    BEGIN
      FOR plugin_df_key IN df_key_plugin_cur(object_data, object_create_scn)
      LOOP
        UPDATE site_dfatt
           SET fname = object_fname
         WHERE site_key = this_site_key AND
           df_key = plugin_df_key.df_key;
 
        IF (NOT SQL%FOUND) THEN
          deb('checkDeletedObject - doing an insert');
          INSERT INTO site_dfatt (fname, df_key, site_key)
            VALUES (object_fname, plugin_df_key.df_key, this_site_key);
        END IF;
      END LOOP;
    END;
  END IF;
 
  IF (object_type = 'TEMPFILE RENAME')
  THEN
    deb('checkDeletedObject - renaming temp file#='||object_data||' to'||
        object_fname);
--
--
--
--
--
    DECLARE
      local_tf_key NUMBER;
    BEGIN
      SELECT tf_key INTO local_tf_key FROM tf
      WHERE dbinc_key = this_dbinc_key
        AND   tf.file# = object_data
        AND   tf.create_scn = object_create_scn;
 
      UPDATE site_tfatt SET
         fname = object_fname
      WHERE 
        site_key = this_site_key AND
        tf_key   = local_tf_key;
 
      IF (NOT SQL%FOUND) THEN
        INSERT INTO site_tfatt (fname, tf_key, site_key)
          VALUES (object_fname, local_tf_key, this_site_key);
      END IF;
    EXCEPTION
     WHEN no_data_found THEN
        NULL;
    END;
  END IF;
 
  IF (object_type = 'DATABASE BLOCK CORRUPTION') THEN
     DELETE bcr
      WHERE site_key  = this_site_key
        AND bcr_recid = object_recid
        AND bcr_stamp = object_stamp;
  END IF;
 
  IF (object_type = 'RESTORE POINT') THEN
    DELETE nrsp
      WHERE site_key  = this_site_key
        AND nrsp_recid = object_recid
        AND nrsp_stamp = object_stamp;
  END IF;
 
  IF (object_type = 'INSTANT RESTORE') THEN
--
--
--
--
    deb('checkDeletedObject - type ='||object_type||
        ' datafile no ='||object_data||' backing file ='||object_fname);
  END IF;
 
END checkDeletedObject;
 
PROCEDURE endDeletedObjectResync IS
BEGIN
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     deb('endDeletedObjectResync - last_do_recid=' || last_do_recid);
     UPDATE node SET high_do_recid = last_do_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_do_recid := last_do_recid;
  last_do_recid := NULL;
 
END endDeletedObjectResync;
 
 
/*----------------------------*
 * RMAN Output resync         *
 *----------------------------*/
 
FUNCTION beginRmanOutputResync(start_timestamp IN NUMBER) RETURN NUMBER IS
  doRoutMining    BOOLEAN;
  last_rout_stamp NUMBER;
BEGIN
  last_rout_stamp := beginRmanOutputResync(start_timestamp, doRoutMining);
  RETURN last_rout_stamp;
END beginRmanOutputResync;
 
FUNCTION beginRmanOutputResync(start_timestamp IN  NUMBER,
                               doRoutMining    OUT BOOLEAN)
RETURN NUMBER IS
BEGIN
--
  getRmanOutputLogging(rman_keep_output);
 
--
  IF (session_keep_output = 0) or (rman_keep_output = 0) THEN
     deb('beginRmanOutputResync - rman output logging is disabled');
     return MAXNUMVAL;
  END IF;
 
  deb('beginRmanOutputResync - input instance start time='||start_timestamp);
 
  checkResync;
 
--
  SELECT inst_startup_stamp, high_rout_stamp into 
     last_inst_startup_stamp, last_rout_stamp from node where
     node.db_key = this_db_key and
     ((this_db_unique_name is null and node.db_unique_name is null) or
      node.db_unique_name = this_db_unique_name);
 
  deb('beginRmanOutputResync - last_inst_startup_stamp='||
      last_inst_startup_stamp||',last_rout_stamp='||last_rout_stamp);
  
--
--
  IF (last_inst_startup_stamp <> start_timestamp) THEN
     last_rout_stamp := sessionWaterMarks.high_rout_stamp;
     last_inst_startup_stamp := start_timestamp;
     doRoutMining := TRUE;
  ELSE
     doRoutMining := FALSE;
  END IF;
 
  RETURN last_rout_stamp;
END beginRmanOutputResync;
 
--
PROCEDURE insertCachedROUT IS
  errors NUMBER;
  dml_errors EXCEPTION;
  PRAGMA EXCEPTION_INIT(dml_errors, -24381);
BEGIN
  IF lrout_curridx = 0 THEN
    RETURN;
  END IF;
  deb('doing bulk update of ' || lrout_curridx || ' rows into ROUT');
  BEGIN
    FORALL i in 1..lrout_curridx SAVE EXCEPTIONS
      INSERT INTO ROUT VALUES lrout_table(i);
  EXCEPTION
    WHEN dml_errors THEN
      errors := SQL%BULK_EXCEPTIONS.COUNT;
      deb('Number of statements that failed: ' || errors);
      FOR i IN 1..errors LOOP
        deb('Error #' || i || ' occurred during '|| 
            'iteration #' || SQL%BULK_EXCEPTIONS(i).ERROR_INDEX); 
        deb('Error message is ' || 
            SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE));
--
        IF -SQL%BULK_EXCEPTIONS(i).ERROR_CODE = -1 THEN
          UPDATE /*+ index(ROUT ROUT_U1) */ ROUT 
            SET rout_text = lrout_table(i).rout_text
            WHERE db_key = this_db_key
              AND rsr_key = lrout_table(i).rsr_key
              AND rout_skey = lrout_table(i).rout_skey
              AND rout_stamp = lrout_table(i).rout_stamp
              AND rout_recid = lrout_table(i).rout_recid
              AND site_key = this_site_key;
        ELSE
          lrout_curridx := 0;
          RAISE;
        END IF;
      END LOOP;
   END;
   lrout_curridx := 0;
END insertCachedROUT;
 
PROCEDURE checkRmanOutput( recid             IN NUMBER
                          ,stamp             IN NUMBER
                          ,session_recid     IN NUMBER
                          ,session_stamp     IN NUMBER
                          ,rman_status_recid IN NUMBER
                          ,rman_status_stamp IN NUMBER
                          ,output       IN VARCHAR2) IS
BEGIN
    deb('checkRmanOutput', RCVCAT_LEVEL_HI);
 
--
    IF (session_keep_output = 0) or (rman_keep_output = 0) THEN
        deb('checkRmanOutput - rman output logging is disabled');
        return;
    END IF;
 
--
    IF (last_rout_stamp < stamp) THEN
       last_rout_stamp := stamp;
    END IF;
 
    IF lrman_status_recid = rman_status_recid AND 
       lrman_status_stamp = rman_status_stamp THEN
       goto rsr_key_known;
    END IF;
 
    deb('checkRmanOutput - Find rsr_ key');
    BEGIN
      select rsr_key into lrsr_key from rsr where 
             rsr.dbinc_key = this_dbinc_key and
             ((rsr.site_key = this_site_key) or
              (rsr.site_key is null AND this_site_key is null)) and
             rsr.rsr_recid = rman_status_recid and
             rsr.rsr_stamp = rman_status_stamp;
    EXCEPTION
    WHEN no_data_found THEN
--
      deb('checkRmanOutput - ignoring following RMAN output row');
      RETURN;
    END;
 
<<rsr_key_known>>
 
    IF lsession_recid = session_recid AND 
       lsession_stamp = session_stamp THEN
       goto rout_skey_known;
    END IF;
 
    deb('checkRmanOutput - Find session key');
    BEGIN
--
--
--
--
--
      select max(rsr_key) into lrout_skey from rsr, dbinc where 
             rsr.dbinc_key  = dbinc.dbinc_key and
             dbinc.db_key   = this_db_key and
             (rsr.site_key = this_site_key or
              rsr.site_key is null AND this_site_key is null) and
             rsr.rsr_srecid = session_recid and
             rsr.rsr_sstamp = session_stamp and
             rsr.rsr_type   = 'SESSION';
    EXCEPTION
    WHEN no_data_found THEN
--
      deb('checkRmanOutput - ignoring following RMAN output row, cause2');
      RETURN;
    WHEN others THEN
      deb('checkRmanOutput - signal error for RMAN output row');
      RAISE;
    END;
 
<<rout_skey_known>>
 
    IF lrout_skey is null THEN
--
      deb('checkRmanOutput: skey not found, ignoring RMAN output row');
      RETURN;
    END IF;
 
--
--
    BEGIN
      lrout_curridx := lrout_curridx + 1;        
      lrout_table(lrout_curridx).db_key        := this_db_key;
      lrout_table(lrout_curridx).rsr_key       := lrsr_key;
      lrout_table(lrout_curridx).rout_skey     := lrout_skey;
      lrout_table(lrout_curridx).rout_recid    := recid;
      lrout_table(lrout_curridx).rout_stamp    := stamp;
      lrout_table(lrout_curridx).site_key      := this_site_key;
      lrout_table(lrout_curridx).rout_text     :=
          substrb(output, 1, krbmror_llength_bytes); -- bug 5906892
--
      IF lrout_curridx = 1000 THEN
        insertCachedROUT;
      END IF;
    END;
 
    lrman_status_recid := rman_status_recid;
    lrman_status_stamp := rman_status_stamp;
    lsession_recid := session_recid;
    lsession_stamp := session_stamp;
 
END checkRmanOutput;
 
PROCEDURE endRmanOutputResync IS
BEGIN
 
--
   IF (session_keep_output = 0) or (rman_keep_output = 0) THEN
      deb('endRmanOutputResync - rman output logging is disabled');
      return;
   END IF;
 
   IF lrout_curridx > 0 THEN
      insertCachedROUT;
   END IF;
 
   UPDATE node SET high_rout_stamp    = last_rout_stamp,
                   inst_startup_stamp = last_inst_startup_stamp
     WHERE node.db_key = this_db_key and
           ((this_db_unique_name is null and node.db_unique_name is null) or
            node.db_unique_name = this_db_unique_name);
  sessionWaterMarks.high_rout_stamp := last_rout_stamp;
  last_rout_stamp := NULL;
  last_inst_startup_stamp := NULL;
  lrsr_key := NULL;
  lrout_skey := NULL;
  lsession_recid := NULL;
  lsession_stamp := NULL;
  lrman_status_recid := NULL;
  lrman_status_stamp := NULL;
 
END endRmanOutputResync;
 
/*----------------------------*
 * RMAN Status resync         *
 *----------------------------*/
 
FUNCTION beginRmanStatusResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_rsr_recid INTO last_rsr_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_rsr_recid := sessionWaterMarks.high_rsr_recid;
  END IF;
 
  RETURN last_rsr_recid;
END beginRmanStatusResync;
 
PROCEDURE checkRmanStatus( recid            IN NUMBER
                          ,stamp            IN NUMBER
                          ,parent_recid     IN NUMBER
                          ,parent_stamp     IN NUMBER
                          ,row_level        IN NUMBER
                          ,row_type         IN VARCHAR2
                          ,command_id       IN VARCHAR2
                          ,operation        IN VARCHAR2
                          ,status           IN VARCHAR2
                          ,mbytes_processed IN NUMBER
                          ,start_time       IN DATE
                          ,end_time         IN DATE
                          ,ibytes           IN NUMBER default null
                          ,obytes           IN NUMBER default null
                          ,optimized        IN VARCHAR2 default null
                          ,otype            IN VARCHAR2 default null
                          ,session_recid    IN NUMBER default null
                          ,session_stamp    IN NUMBER default null
                          ,odevtype         IN VARCHAR2 default null
                          ,osb_allocated    IN VARCHAR2 default 'NO') IS
 
parent   rsr%rowtype;
 
BEGIN
  IF (last_rsr_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (recid < last_rsr_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (stamp < kccdivts) THEN
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
  parent.rsr_pkey := NULL;
  parent.rsr_l0key := NULL;
--
--
--
  IF (checkRmanStatus.row_level > 0)
  THEN
    deb('checkRmanStatus - row_level='||to_char(checkRmanStatus.row_level));
    BEGIN
      SELECT rsr_key, decode(rsr_level, 0, rsr_key, rsr_l0key)
      INTO parent.rsr_key, parent.rsr_l0key
      FROM rsr
      WHERE rsr.dbinc_key = this_dbinc_key
      AND   (rsr.site_key = this_site_key OR
             rsr.site_key is null AND this_site_key is null)
      AND   rsr.rsr_stamp  = checkRmanStatus.parent_stamp
      AND   rsr.rsr_recid  = checkRmanStatus.parent_recid;
    EXCEPTION
    WHEN no_data_found THEN
--
      deb('checkRmanStatus - ignoring this record');
      RETURN;
    END;
  END IF;
 
  BEGIN
 
    deb('checkRmanStatus - inserting into rsr');
    deb('checkRmanStatus - this_dbinc_key:'||to_char(this_dbinc_key));
    deb('checkRmanStatus - recid:         '||to_char(recid));
    deb('checkRmanStatus - stamp:         '||to_char(stamp));
    deb('checkRmanStatus - srecid:        '||to_char(session_recid));
    deb('checkRmanStatus - sstamp:        '||to_char(session_stamp));
    INSERT INTO rsr
      (rsr_key, dbinc_key, rsr_recid, rsr_stamp, rsr_pkey,
       rsr_l0key, rsr_level, rsr_type, rsr_oper, rsr_cmdid,
       rsr_status, rsr_mbytes, rsr_start, rsr_end, rsr_ibytes, 
       rsr_obytes, rsr_optimized, rsr_otype, rsr_srecid, rsr_sstamp, 
       rsr_odevtype, site_key, rsr_osb_allocated)
    VALUES
      (rman_seq.nextval, this_dbinc_key, recid, stamp, parent.rsr_key,
       parent.rsr_l0key, row_level, row_type, operation, command_id,
       status, mbytes_processed, start_time, end_time, ibytes, 
       obytes, optimized, otype, session_recid, session_stamp, odevtype,
       this_site_key, decode(osb_allocated, 'YES', 'Y', 'N'));
 
--
--
    DELETE rsr WHERE
           rsr.dbinc_key = this_dbinc_key 
       AND rsr.rsr_recid = recid
       AND rsr.rsr_stamp = stamp
       AND ((this_site_key is not null AND rsr.site_key is NULL) OR
            (this_site_key is null and rsr.site_key is not null));
  EXCEPTION
     WHEN dup_val_on_index THEN
--
     deb('checkRmanStatus - exception catch');
     deb('checkRmanStatus - this_dbinc_key:'||to_char(this_dbinc_key));
     deb('checkRmanStatus - recid:         '||to_char(recid));
     deb('checkRmanStatus - stamp:         '||to_char(stamp));
     deb('checkRmanStatus - srecid:        '||to_char(session_recid));
     deb('checkRmanStatus - sstamp:        '||to_char(session_stamp));
     UPDATE rsr
        SET rsr_pkey   = parent.rsr_key,
            rsr_l0key  = parent.rsr_l0key,
            rsr_level  = row_level,
            rsr_type   = row_type,
            rsr_oper   = operation,
            rsr_cmdid  = command_id,
            rsr_status = status,
            rsr_mbytes = mbytes_processed,
            rsr_start  = start_time,
            rsr_end    = end_time,
            rsr_ibytes = ibytes,
            rsr_obytes = obytes,
            rsr_optimized = optimized,
            rsr_otype =  otype,
            rsr_odevtype = odevtype,
            rsr_osb_allocated = decode(osb_allocated, 'YES', 'Y', 'N')
      WHERE rsr.rsr_stamp = stamp
      AND   rsr.rsr_recid = recid
      AND   (rsr.site_key = this_site_key OR
             rsr.site_key is null and this_site_key is null)
      AND   rsr.rsr_srecid = session_recid
      AND   rsr.rsr_sstamp = session_stamp
      AND   rsr.dbinc_key = this_dbinc_key;
  END;
END checkRmanStatus;
 
PROCEDURE endRmanStatusResync(recid number) IS
BEGIN
 
  IF (last_rsr_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (recid < last_rsr_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_rsr_recid = recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_rsr_recid := recid;
  last_rsr_recid := NULL;
 
END endRmanStatusResync;
 
PROCEDURE updateRmanStatusRow( recid   IN number
                              ,stamp   IN number
                              ,mbytes  IN number
                              ,status  IN binary_integer ) IS
BEGIN
 
  IF (this_dbinc_key IS NULL) THEN
    return;
  END IF;
 
  UPDATE rsr SET
         rsr_status = decode(status, 1, 'RUNNING',
                                   1+8, 'RUNNING WITH WARNINGS',
                                  1+16, 'RUNNING WITH ERRORS',
                                1+8+16, 'RUNNING WITH ERRORS',
                                     2, 'COMPLETED',
                                   2+8, 'COMPLETED WITH WARNINGS',
                                  2+16, 'COMPLETED WITH ERRORS',
                                2+8+16, 'COMPLETED WITH ERRORS',
                                        'FAILED'),
         rsr_mbytes = mbytes
   WHERE rsr.rsr_stamp = stamp
   AND   rsr.rsr_recid = recid
   AND   (rsr.site_key = this_site_key OR
          rsr.site_key is null AND this_site_key is null)
   AND   rsr.dbinc_key = this_dbinc_key;
 
   commitChanges('updateRmanStatusRow');
 
END updateRmanStatusRow;
 
PROCEDURE rsDeleteBackupPiece(bp_key IN number, purged IN varchar2)
IS
   bs_key number;
   db_key number;
   retention_time timestamp with time zone;
BEGIN
 
--
  SELECT bp.bs_key, bp.db_key INTO bs_key, db_key
    FROM bp, bs
   WHERE bp.bp_key = rsDeleteBackupPiece.bp_key 
     AND bp.bs_key = bs.bs_key FOR UPDATE OF bs.bs_key;
  deb('rsDeleteBackupPiece - locked bs_key' || bs_key);
 
--
  UPDATE bp SET bp.status = 'D',
                bp.purged = rsDeleteBackupPiece.purged
   WHERE bp.bp_key = rsDeleteBackupPiece.bp_key;
 
  IF (purged = 'Y') THEN
     IF this_is_ors THEN
        this_enable_populate_rsr := 
                             getValueFromConfig('_enable_populate_rsr_key');
     END IF;
     updateBackupSetRec(bs_key);
--
--
     IF this_is_ors THEN
        this_enable_populate_rsr := NULL;
        this_upstream_site_key := NULL;
     END IF;
  END IF;
 
--
END rsDeleteBackupPiece;
 
FUNCTION getValueFromConfig(entry IN VARCHAR2) RETURN varchar2 IS
   entryVal config.value%TYPE;
BEGIN
   SELECT UPPER(value)
     INTO entryVal
     FROM config
     WHERE name = entry;
   
   return entryVal;
END getValueFromConfig;
 
/*-------------------*
 * Change Procedures *
 *-------------------*/
 
/*
 * In these change procedures, we don't check that we found the record,
 * because we are processing a DL record - i.e. we already processed the
 * other cf records and hence it might already be flagged deleted.  This
 * applies to any status change because we might make it available and
 * then delete the object, so the object would be marked as deleted when
 * we process the object and the available status change (first DL) would
 * fail to find the object, so would a following DL that marks it deleted.
 */
 
PROCEDURE changeDatafileCopy(
  cdf_recid    IN NUMBER
 ,cdf_stamp    IN NUMBER
 ,status       IN VARCHAR2
 ,keep_options IN NUMBER DEFAULT NULL  -- null means do not update
 ,keep_until   IN DATE   DEFAULT NULL
 ,osite_key    IN number DEFAULT NULL  -- old site_key for the record
 ,nsite_key    IN number DEFAULT NULL  -- null means do not update
) IS
  local    dbinc%rowtype;
  fno      cdf.file#%type;
BEGIN
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
--
  BEGIN
--
     SELECT file# into fno
       FROM cdf
      WHERE dbinc_key in
               (select dbinc_key from dbinc where db_key = this_db_key)
      AND   ((osite_key is null AND cdf.site_key is null) OR 
             cdf.site_key = nvl(osite_key, cdf.site_key))
      AND   cdf.cdf_recid = changeDatafileCopy.cdf_recid
      AND   cdf.cdf_stamp = changeDatafileCopy.cdf_stamp;
  EXCEPTION
     WHEN no_data_found THEN
        BEGIN
--
           SELECT 0 into fno
             FROM ccf
            WHERE dbinc_key in
                     (select dbinc_key from dbinc where db_key = this_db_key)
            AND   ((osite_key is null AND ccf.site_key is null) OR 
                   ccf.site_key = nvl(osite_key, ccf.site_key))
            AND   ccf.ccf_recid = changeDatafileCopy.cdf_recid
            AND   ccf.ccf_stamp = changeDatafileCopy.cdf_stamp;
 
--
           changeControlfileCopy(cdf_recid, cdf_stamp, status,
                                 keep_options, keep_until,
                                 osite_key, nsite_key);
           RETURN;
        EXCEPTION
           WHEN no_data_found THEN
              RETURN; -- already deleted (we are processing a DL record)
        END;
     WHEN OTHERS THEN
        RAISE;
  END;
 
  IF  status IS NULL THEN
--
--
    IF keep_until IS NOT NULL THEN
      UPDATE cdf SET keep_until = changeDatafileCopy.keep_until
      WHERE cdf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND cdf.site_key is null) OR 
             cdf.site_key = nvl(osite_key, cdf.site_key))
      AND   cdf.cdf_recid = changeDatafileCopy.cdf_recid
      AND   cdf.cdf_stamp = changeDatafileCopy.cdf_stamp;
    END IF;
    IF keep_options IS NOT NULL THEN
      UPDATE cdf SET keep_options = changeDatafileCopy.keep_options
      WHERE cdf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND cdf.site_key is null) OR 
             cdf.site_key = nvl(osite_key, cdf.site_key))
      AND   cdf.cdf_recid = changeDatafileCopy.cdf_recid
      AND   cdf.cdf_stamp = changeDatafileCopy.cdf_stamp;
    END IF;
  ELSIF status IN ('A','U','X') THEN
--
--
    UPDATE cdf SET status = changeDatafileCopy.status,
                   site_key = nvl(nsite_key, site_key)
    WHERE cdf.dbinc_key in
      (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND cdf.site_key is null) OR 
             cdf.site_key = nvl(osite_key, cdf.site_key))
      AND   cdf.cdf_recid = changeDatafileCopy.cdf_recid
      AND   cdf.cdf_stamp = changeDatafileCopy.cdf_stamp;
--
    IF sql%rowcount > 0 and nsite_key is not null THEN
       deleteDuplicateCDF(cdf_recid, cdf_stamp, null);
    END IF;
 
  ELSIF status IN ('R','D') THEN
    DELETE FROM cdf
    WHERE cdf.dbinc_key in
      (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND cdf.site_key is null) OR 
             cdf.site_key = nvl(osite_key, cdf.site_key))
      AND   cdf.cdf_recid = changeDatafileCopy.cdf_recid
      AND   cdf.cdf_stamp = changeDatafileCopy.cdf_stamp;
  ELSE
    raise_application_error(-20100, 'Invalid status');
  END IF;
 
--
  commitChanges('changeDatafileCopy');
 
END changeDatafileCopy;
 
PROCEDURE changeControlfileCopy(
  cdf_recid    IN NUMBER
 ,cdf_stamp    IN NUMBER
 ,status       IN VARCHAR2
 ,keep_options IN NUMBER DEFAULT NULL  -- null means do not update
 ,keep_until   IN DATE   DEFAULT NULL
 ,osite_key    IN number DEFAULT NULL  -- old site_key for the record
 ,nsite_key    IN number DEFAULT NULL  -- null means do not update
) IS
 
local    dbinc%rowtype;
 
BEGIN
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
  IF  status IS NULL THEN
--
--
    IF keep_until IS NOT NULL THEN
      UPDATE ccf SET keep_until = changeControlfileCopy.keep_until
      WHERE  ccf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
        AND  ((osite_key is null AND ccf.site_key is null) OR 
              ccf.site_key = nvl(osite_key, ccf.site_key))
        AND  ccf.ccf_recid = changeControlfileCopy.cdf_recid
        AND  ccf.ccf_stamp = changeControlfileCopy.cdf_stamp;
    END IF;
    IF keep_options IS NOT NULL THEN
      UPDATE ccf SET keep_options = changeControlfileCopy.keep_options
      WHERE  ccf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
        AND  ((osite_key is null AND ccf.site_key is null) OR 
              ccf.site_key = nvl(osite_key, ccf.site_key))
        AND  ccf.ccf_recid = changeControlfileCopy.cdf_recid
        AND  ccf.ccf_stamp = changeControlfileCopy.cdf_stamp;
    END IF;
  ELSIF status IN ('A','U','X') THEN
--
--
    UPDATE ccf SET status = changeControlfileCopy.status,
                   site_key = nvl(nsite_key, site_key)
    WHERE  ccf.dbinc_key in
      (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND  ((osite_key is null AND ccf.site_key is null) OR 
            ccf.site_key = nvl(osite_key, ccf.site_key))
      AND   ccf.ccf_recid = changeControlfileCopy.cdf_recid
      AND   ccf.ccf_stamp = changeControlfileCopy.cdf_stamp;
--
    IF sql%rowcount > 0 and nsite_key is not null THEN
       deleteDuplicateCCF(cdf_recid, cdf_stamp, null);
    END IF;
  ELSIF status IN ('R','D') THEN
    DELETE FROM ccf
    WHERE ccf.dbinc_key in
      (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND  ((osite_key is null AND ccf.site_key is null) OR 
            ccf.site_key = nvl(osite_key, ccf.site_key))
      AND   ccf.ccf_recid = changeControlfileCopy.cdf_recid
      AND   ccf.ccf_stamp = changeControlfileCopy.cdf_stamp;
  ELSE
    raise_application_error(-20100, 'Invalid status');
  END IF;
 
--
  commitChanges('changeControlfileCopy');
 
END changeControlfileCopy;
 
PROCEDURE changeArchivedLog(
  al_recid  IN NUMBER
 ,al_stamp  IN NUMBER
 ,status    IN VARCHAR2
 ,osite_key IN NUMBER DEFAULT NULL        -- old site_key for the record
 ,nsite_key IN NUMBER DEFAULT NULL        -- null means do not update
) IS
BEGIN
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
  IF status IN ('A','U','X') THEN
--
--
     UPDATE al SET status = changeArchivedLog.status,
                   site_key = nvl(nsite_key, site_key)
     WHERE al.dbinc_key in
       (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
     AND   al.al_recid = changeArchivedLog.al_recid
     AND   al.al_stamp = changeArchivedLog.al_stamp
     AND   ((osite_key is null AND al.site_key is null) OR 
            al.site_key = nvl(osite_key, al.site_key));
--
     IF sql%rowcount > 0 and nsite_key is not null THEN
        deleteDuplicateAL(al_recid, al_stamp, null);
     END IF;
  ELSIF status IN ('R','D') THEN
--
--
--
    DELETE FROM al
    WHERE al.dbinc_key IN
      (SELECT dbinc_key FROM dbinc WHERE dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND al.site_key is null) OR 
             al.site_key = nvl(osite_key, al.site_key))
      AND al.al_recid = changeArchivedLog.al_recid
      AND al.al_stamp = changeArchivedLog.al_stamp;
  ELSE
    raise_application_error(-20100, 'Invalid status');
  END IF;
 
--
  commitChanges('changeArchivedLog');
 
END changeArchivedLog;
 
PROCEDURE changeBackupSet(
  recid        IN number
 ,stamp        IN number
 ,keep_options IN number   -- null means do not update
 ,keep_until   IN date
 ,osite_key    IN number    DEFAULT NULL  -- old site_key for the record
 ,nsite_key    IN number    DEFAULT NULL  -- null means do not update
) IS
   local    bs%rowtype;
   CURSOR dflist IS
      SELECT * FROM bdf
      WHERE bdf.bs_key = local.bs_key;
   CURSOR rllist IS
      SELECT * FROM brl
      WHERE brl.bs_key = local.bs_key;
   has_virtual boolean := TRUE;
   l_virtual   number  := 0;
BEGIN
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  BEGIN
    SELECT * INTO local
    FROM bs
    WHERE bs.db_key = this_db_key
    AND   bs.bs_recid = changeBackupSet.recid
    AND   bs.bs_stamp = changeBackupSet.stamp FOR UPDATE OF bs.bs_key;
    deb('changeBackupSet - locked bs_key' || local.bs_key);
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN; -- already deleted (we are processing a DL record)
  END;
 
  BEGIN
    SELECT bp.vb_key INTO l_virtual 
    FROM bp,bs 
    WHERE bp.bs_key = bs.bs_key
    AND   bp.vb_key IS NOT NULL
    AND   bs.bs_key = local.bs_key;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      has_virtual := FALSE;  -- no virtual found
  END;  
 
  IF has_virtual THEN
    deb('changeBackupSet - virtual backup piece key (AM)' || l_virtual);
  END IF;
 
  IF nsite_key is not null THEN
     UPDATE bp SET site_key = nsite_key WHERE bs_key = local.bs_key;
     UPDATE bs SET site_key = nsite_key WHERE bs_key = local.bs_key;
  END IF;
 
  IF NOT has_virtual THEN 
    UPDATE bs SET bs.keep_until = changeBackupSet.keep_until
    WHERE  bs.bs_key = local.bs_key;
  END IF;
 
  IF NOT has_virtual AND keep_options IS NOT NULL THEN
    UPDATE bs SET bs.keep_options = changeBackupSet.keep_options
    WHERE  bs.bs_key = local.bs_key;
 
--
    IF (local.bck_type = 'L') THEN
      FOR rlrec IN rllist LOOP
        updateRestorePoint(rlrec.low_scn, rlrec.next_scn);
      END LOOP;
    END IF;
    IF (local.bck_type = 'D') THEN
      FOR dfrec IN dflist LOOP
        updateRestorePoint(dfrec.ckp_scn, null);
      END LOOP;
    END IF;
  END IF;
 
--
  commitChanges('changeBackupSet');
 
END changeBackupSet;
 
PROCEDURE changeBackupPiece(
  bp_recid  IN NUMBER
 ,bp_stamp  IN NUMBER
 ,status    IN VARCHAR2
 ,set_stamp IN NUMBER    DEFAULT NULL
 ,set_count IN NUMBER    DEFAULT NULL
 ,osite_key IN NUMBER    DEFAULT NULL  -- old site_key for the record
 ,nsite_key IN NUMBER    DEFAULT NULL  -- null means do not update
 ,handle    IN VARCHAR2  DEFAULT NULL  -- null means not known
 ,device_type IN VARCHAR2 DEFAULT NULL -- null means not known
) IS
   CURSOR bsQ(bp_recid IN NUMBER, bp_stamp IN NUMBER) IS
      SELECT bs_key
        FROM bp
       WHERE bp.db_key   = this_db_key
         AND ((osite_key is null AND bp.site_key is null) OR 
              bp.site_key = nvl(osite_key, bp.site_key))
         AND bp.bp_recid = bsQ.bp_recid
         AND bp.bp_stamp = bsQ.bp_stamp;
   bsQrec       bsQ%ROWTYPE;
   totalbp      number;
   chgbskey     number := NULL;
   l_ba_access  bp.ba_access%type;
   l_bp_key     number;
   l_bp_recid   number;
   l_bp_stamp   number;
BEGIN
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  l_bp_recid := changeBackupPiece.bp_recid; 
  l_bp_stamp := changeBackupPiece.bp_stamp; 
 
--
--
  IF (set_stamp is not null AND set_count is not null) THEN
     BEGIN
        SELECT bs_key INTO chgbskey
          FROM bs
         WHERE bs.db_key    = this_db_key
           AND bs.set_stamp = changeBackupPiece.set_stamp
           AND bs.set_count = changeBackupPiece.set_count 
         FOR UPDATE OF bs.bs_key;
        deb('changeBackupPiece - locked bs_key' || chgbskey);
     EXCEPTION
       WHEN NO_DATA_FOUND THEN
         RETURN; -- already deleted (we are processing a DL record)
     END;
     deb('changeBackupPiece - chgbskey=' || chgbskey);
  ELSE
--
--
--
--
--
       
     SELECT count(*) INTO totalbp
       FROM bp
      WHERE bp.db_key   = this_db_key
        AND ((osite_key is null AND bp.site_key is null) OR 
             bp.site_key = nvl(osite_key, bp.site_key))
        AND bp.bp_recid = l_bp_recid
        AND bp.bp_stamp = l_bp_stamp
        AND bp.bs_key   = nvl(chgbskey, bp.bs_key);
 
     deb('changeBackupPiece - number of backup pieces match ' || totalbp);
 
     IF totalbp = 0 then
        RETURN; -- already deleted (we are processing a DL record)
     END IF;
  END IF;
 
  IF changeBackupPiece.handle is NOT NULL AND chgbskey IS NOT NULL THEN
     BEGIN
       deb('changeBackupPiece - Override bp_recid/bp_stamp for ' ||
           handle || ', on ' || device_type);
       SELECT bp_recid, bp_stamp INTO
              l_bp_recid, l_bp_stamp
         FROM bp
         WHERE bp.db_key = this_db_key
           AND bp.bs_key = chgbskey
           AND bp.handle = changeBackupPiece.handle
           AND bp.device_type = changeBackupPiece.device_type;
     EXCEPTION
       WHEN NO_DATA_FOUND THEN
         deb('changeBackupPiece - Not found ');
       WHEN OTHERS THEN
         deb('changeBackupPiece(DO_NOT_IGNORE) - Error ' || sqlerrm);
     END;
     deb('changeBackupPiece - recid='||l_bp_recid||', stamp='||l_bp_stamp);
  END IF;
 
--
--
--
 
  IF status in ('A','U','X') THEN
--
--
    UPDATE bp SET status = changeBackupPiece.status,
                  site_key = nvl(nsite_key, site_key)
    WHERE bp.db_key   = this_db_key
      AND ((osite_key is null AND bp.site_key is null) OR 
           bp.site_key = nvl(osite_key, bp.site_key))
      AND bp.bp_recid = l_bp_recid
      AND bp.bp_stamp = l_bp_stamp
      AND bp.bs_key   = nvl(chgbskey, bp.bs_key)
      AND bp.ba_access != 'L'    -- AM: no status changing
      AND bp.status  != 'D';
 
--
    IF sql%rowcount > 0 and nsite_key is not null THEN
--
--
       IF chgbskey is not null THEN
          UPDATE bs SET site_key=null WHERE bs_key = chgbskey; 
       ELSE
          UPDATE bs SET site_key=null WHERE bs_key in 
            (SELECT bs_key FROM bp
             WHERE bp.db_key   = this_db_key
              AND ((osite_key is null AND bp.site_key is null) OR
                   bp.site_key = nvl(osite_key, bp.site_key))
              AND bp.bp_recid = l_bp_recid
              AND bp.bp_stamp = l_bp_stamp);
       END IF;
       deleteDuplicateBP(l_bp_recid, l_bp_stamp, chgbskey, null, null);
    END IF;
  ELSIF status not in ('R', 'D') THEN
     raise_application_error(-20100, 'Invalid status');
  END IF;
 
  IF this_is_ors AND this_ckp_key IS NULL THEN
     this_enable_populate_rsr := getValueFromConfig('_enable_populate_rsr_key');
  END IF;
 
  IF (chgbskey IS NULL) THEN
     FOR bsQrec in bsQ(l_bp_recid, l_bp_stamp) LOOP
--
--
        IF status in ('R', 'D') THEN
           UPDATE bp SET bp.status = 'D'
            WHERE bp.db_key   = this_db_key
              AND ((osite_key is null AND bp.site_key is null) OR 
                   bp.site_key = nvl(osite_key, bp.site_key))
              AND bp.bp_recid = l_bp_recid
              AND bp.bp_stamp = l_bp_stamp
              AND bp.bs_key   = bsQrec.bs_key
           RETURNING bp.ba_access, bp.bp_key INTO l_ba_access, l_bp_key;
 
--
           IF l_ba_access != 'U' THEN
              DELETE FROM bp WHERE bp.bp_key = l_bp_key;
           END IF;
        END IF;
--
        updateBackupSetRec(bsQrec.bs_key);
     END LOOP;
  ELSE
     IF status in ('R', 'D') THEN
         UPDATE bp SET bp.status = 'D'
         WHERE bp.db_key   = this_db_key
           AND ((osite_key is null AND bp.site_key is null) OR 
                bp.site_key = nvl(osite_key, bp.site_key))
           AND bp.bp_recid = l_bp_recid
           AND bp.bp_stamp = l_bp_stamp
           AND bp.bs_key   = chgbskey
           AND bp.ba_access != 'L'    -- AM: no status changing
         RETURNING bp.ba_access, bp.bp_key INTO l_ba_access, l_bp_key;
 
--
        IF l_ba_access = 'U' THEN
           DELETE FROM bp WHERE bp.bp_key = l_bp_key;
        END IF;
     END IF;
--
     updateBackupSetRec(chgbskey);
  END IF;
--
--
  IF this_is_ors AND this_ckp_key IS NULL THEN
     this_enable_populate_rsr := NULL;
     this_upstream_site_key := NULL;
  END IF;
--
  commitChanges('changeBackupPiece');
 
END changeBackupPiece;
 
PROCEDURE changeProxyCopy(
  pc_recid     IN NUMBER
 ,pc_stamp     IN NUMBER
 ,status       IN VARCHAR2
 ,keep_options IN NUMBER DEFAULT NULL  -- null means do not update
 ,keep_until   IN DATE   DEFAULT NULL
 ,osite_key    IN number DEFAULT NULL  -- old site_key for the record
 ,nsite_key    IN number DEFAULT NULL  -- null means do not update
) IS
  low_scn   number;
  next_scn  number;
  xobjid    rowid;  -- proxy object rowid
BEGIN
  IF this_db_key IS NULL THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  IF status IS NULL THEN
--
--
    IF keep_until IS NOT NULL THEN
      UPDATE xdf SET xdf.keep_until = changeProxyCopy.keep_until
      WHERE   xdf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND xdf.site_key is null) OR 
             xdf.site_key = nvl(osite_key, xdf.site_key))
      AND    xdf.xdf_recid = changeProxyCopy.pc_recid
      AND    xdf.xdf_stamp = changeProxyCopy.pc_stamp;
--
      IF sql%rowcount = 0 THEN
        UPDATE xcf SET xcf.keep_until = changeProxyCopy.keep_until
        WHERE  xcf.dbinc_key in
          (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
        AND   ((osite_key is null AND xcf.site_key is null) OR 
               xcf.site_key = nvl(osite_key, xcf.site_key))
        AND   xcf.xcf_recid = changeProxyCopy.pc_recid
        AND   xcf.xcf_stamp = changeProxyCopy.pc_stamp;
      END IF;
    END IF;
    IF keep_options IS NOT NULL THEN
      SELECT min(ckp_scn), min(rowid) into low_scn, xobjid
      FROM xdf
      WHERE   xdf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND    ((osite_key is null AND xdf.site_key is null) OR 
              xdf.site_key = nvl(osite_key, xdf.site_key))
      AND    xdf.xdf_recid = changeProxyCopy.pc_recid
      AND    xdf.xdf_stamp = changeProxyCopy.pc_stamp;
 
--
      IF xobjid IS NOT NULL THEN
        updateRestorePoint(low_scn, null);
        UPDATE xdf SET xdf.keep_options = changeProxyCopy.keep_options
        WHERE rowid = xobjid;
      ELSE
--
        UPDATE xcf SET xcf.keep_options = changeProxyCopy.keep_options
        WHERE  xcf.dbinc_key in
          (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
        AND ((osite_key is null AND xcf.site_key is null) OR 
             xcf.site_key = nvl(osite_key, xcf.site_key))
        AND   xcf.xcf_recid = changeProxyCopy.pc_recid
        AND   xcf.xcf_stamp = changeProxyCopy.pc_stamp;
--
        IF sql%rowcount = 0 THEN
          SELECT min(xal.low_scn), min(xal.next_scn), min(rowid)
                 into low_scn, next_scn, xobjid
          FROM xal
          WHERE  xal.dbinc_key in
            (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
          AND ((osite_key is null AND xal.site_key is null) OR 
               xal.site_key = nvl(osite_key, xal.site_key))
          AND   xal.xal_recid = changeProxyCopy.pc_recid
          AND   xal.xal_stamp = changeProxyCopy.pc_stamp;
--
          IF xobjid IS NOT NULL THEN
            updateRestorePoint(low_scn, next_scn);
            UPDATE xal SET xal.keep_options = changeProxyCopy.keep_options
            WHERE rowid = xobjid;
          END IF;
        END IF;
      END IF;
    END IF;
  ELSIF status in ('A','U','X') THEN
--
--
    UPDATE xdf SET status = changeProxyCopy.status,
                   site_key = nvl(nsite_key, site_key)
    WHERE xdf.dbinc_key in
      (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
    AND   ((osite_key is null AND xdf.site_key is null) OR 
           xdf.site_key = nvl(osite_key, xdf.site_key))
    AND   xdf.xdf_recid = changeProxyCopy.pc_recid
    AND   xdf.xdf_stamp = changeProxyCopy.pc_stamp;
--
    IF sql%rowcount > 0 and nsite_key is not null THEN
       deleteDuplicateXDF(pc_recid, pc_stamp, null, null);
    END IF;
 
--
    IF sql%rowcount = 0 THEN
      UPDATE xcf SET status = changeProxyCopy.status,
                   site_key = nvl(nsite_key, site_key)
      WHERE xcf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND xcf.site_key is null) OR 
             xcf.site_key = nvl(osite_key, xcf.site_key))
      AND   xcf.xcf_recid = changeProxyCopy.pc_recid
      AND   xcf.xcf_stamp = changeProxyCopy.pc_stamp;
--
      IF sql%rowcount > 0 and nsite_key is not null THEN
         deleteDuplicateXCF(pc_recid, pc_stamp, null, null);
      END IF;
    END IF;
 
--
    IF sql%rowcount = 0 THEN
      UPDATE xal SET status = changeProxyCopy.status,
                   site_key = nvl(nsite_key, site_key)
      WHERE xal.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND xal.site_key is null) OR 
             xal.site_key = nvl(osite_key, xal.site_key))
      AND   xal.xal_recid = changeProxyCopy.pc_recid
      AND   xal.xal_stamp = changeProxyCopy.pc_stamp;
--
      IF sql%rowcount > 0 and nsite_key is not null THEN
          deleteDuplicateXAL(pc_recid, pc_stamp, null, null);
      END IF;
    END IF;
  ELSIF status IN ('R','D') THEN
--
    SELECT min(ckp_scn), min(rowid) into low_scn, xobjid
    FROM xdf
    WHERE xdf.dbinc_key in
      (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
    AND   ((osite_key is null AND xdf.site_key is null) OR 
           xdf.site_key = nvl(osite_key, xdf.site_key))
    AND   xdf.xdf_recid = changeProxyCopy.pc_recid
    AND   xdf.xdf_stamp = changeProxyCopy.pc_stamp;
--
    IF xobjid IS NOT NULL THEN
      updateRestorePoint(low_scn, null);
      DELETE FROM xdf
      WHERE rowid = xobjid;
    ELSE
--
      DELETE FROM xcf
      WHERE xcf.dbinc_key in
        (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
      AND   ((osite_key is null AND xcf.site_key is null) OR 
             xcf.site_key = nvl(osite_key, xcf.site_key))
      AND   xcf.xcf_recid = changeProxyCopy.pc_recid
      AND   xcf.xcf_stamp = changeProxyCopy.pc_stamp;
 
--
      IF sql%rowcount = 0 THEN
        SELECT min(xal.low_scn), min(xal.next_scn), min(rowid)
               into low_scn, next_scn, xobjid
        FROM xal
        WHERE xal.dbinc_key in
          (select dbinc_key from dbinc where dbinc.db_key = this_db_key)
        AND   ((osite_key is null AND xal.site_key is null) OR 
               xal.site_key = nvl(osite_key, xal.site_key))
        AND   xal.xal_recid = changeProxyCopy.pc_recid
        AND   xal.xal_stamp = changeProxyCopy.pc_stamp;
        IF xobjid IS NOT NULL THEN
          updateRestorePoint(low_scn, next_scn);
          DELETE FROM xal
          WHERE rowid = xobjid;
        END IF;
      END IF;
    END IF;
  ELSE
    raise_application_error(-20100, 'Invalid status');
  END IF;
 
--
  commitChanges('changeProxyCopy');
 
END changeProxyCopy;
 
/*----------------------------*
 * Stored Script Procedures   *
 *----------------------------*/
 
PROCEDURE createScript(name IN VARCHAR2) IS
BEGIN
  createScript(name, NULL, FALSE);
END;
 
PROCEDURE createScript(name IN VARCHAR2,
                       scr_com IN VARCHAR2,
                       global IN boolean) IS
  foo NUMBER;
  dbkey  NUMBER := this_db_key;
BEGIN
  scr_key := NULL;                      -- for safety
  IF global THEN
     dbkey := NULL;
     scr_glob := TRUE;
  ELSE
     scr_glob := FALSE;
     IF (this_db_key IS NULL) THEN
        raise_application_error(-20021, 'Database not set');
     END IF;
  END IF;
  SELECT count(*)
    INTO foo
    FROM scr
   WHERE ((dbkey is not null and scr.db_key = dbkey)
      OR  (dbkey is null and scr.db_key is null))
     AND scr.scr_name = createScript.name;
  IF foo > 0 THEN
    raise_application_error(-20401, 'script '||name||' already exists');
  END IF;
 
  INSERT INTO scr VALUES(rman_seq.nextval, dbkey, name, scr_com)
  RETURNING scr_key INTO scr_key;
  scr_line := 1;
 
--
  commitChanges('createScript');
 
END;
 
PROCEDURE replaceScript(name IN VARCHAR2) IS
 
BEGIN
   replaceScript(name, NULL, FALSE);
END;
 
PROCEDURE replaceScript(name IN VARCHAR2,
                        scr_com IN VARCHAR2,
                        global IN boolean) IS
  dbkey  NUMBER := this_db_key;
BEGIN
  IF global THEN
     dbkey := NULL;
     scr_glob := TRUE;
  ELSE
     scr_glob := FALSE;
     IF (this_db_key IS NULL) THEN
        raise_application_error(-20021, 'Database not set');
     END IF;
  END IF;
 
  SELECT scr_key
    INTO scr_key
    FROM scr
   WHERE ((dbkey is not null and scr.db_key = dbkey)
      OR  (dbkey is null and scr.db_key is null))
     AND scr.scr_name = replaceScript.name;
 
  UPDATE scr
     SET scr_comment = scr_com
   WHERE scr.scr_key = dbms_rcvcat.scr_key;
 
  DELETE FROM scrl
   WHERE scrl.scr_key = dbms_rcvcat.scr_key;
 
  scr_line := 1;
 
--
  commitChanges('replaceScript');
 
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    createScript(name, scr_com, global);
 
END;
 
PROCEDURE putLine(line IN VARCHAR2) IS
 
BEGIN
  IF not scr_glob and this_db_key IS NULL THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
  IF (scr_key IS NULL) THEN
    raise_application_error(-20402, 'createScript or replaceScript not done');
  END IF;
 
  INSERT INTO scrl(scr_key, linenum, text) VALUES(scr_key, scr_line, line);
  scr_line := scr_line + 1;
 
END;
 
PROCEDURE deleteScript(name IN VARCHAR2) IS
 
BEGIN
   deleteScript(name, 0);
END;
 
PROCEDURE deleteScript(name IN VARCHAR2, glob IN NUMBER) IS
  dbkey  NUMBER := this_db_key;
BEGIN
  IF glob = 1 THEN
     dbkey := NULL;
  ELSE
     IF (this_db_key IS NULL) THEN
        raise_application_error(-20021, 'Database not set');
     END IF;
  END IF;
 
  SELECT scr_key INTO scr_key
  FROM scr
   WHERE ((dbkey is not null and scr.db_key = dbkey)
      OR  (dbkey is null and scr.db_key is null))
     AND scr.scr_name = deleteScript.name;
 
  DELETE FROM scr
  WHERE scr.scr_key = dbms_rcvcat.scr_key;
  scr_key := NULL;
 
--
  commitChanges('deleteScript');
 
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    scr_key := NULL;
    raise_application_error(-20400, 'stored script not found');
 
END;
 
PROCEDURE getScript(name IN VARCHAR2) IS
BEGIN
   getScript(name, 0);
END;
 
PROCEDURE getScript(name IN VARCHAR2, glob IN NUMBER) IS
  dbkey  NUMBER := this_db_key;
BEGIN
  IF glob = 1 THEN
     dbkey := NULL;
     scr_glob := TRUE;
  ELSE
     scr_glob := FALSE;
     IF (this_db_key IS NULL) THEN
        raise_application_error(-20021, 'Database not set');
     END IF;
  END IF;
 
  SELECT scr_key INTO scr_key
  FROM scr
   WHERE ((dbkey is not null and scr.db_key = dbkey)
      OR  (dbkey is null and scr.db_key is null))
     AND scr.scr_name = getScript.name;
 
  IF scrlQ%ISOPEN THEN
    CLOSE scrlQ;
  END IF;
  OPEN scrlQ(scr_key);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    scr_key := NULL;
    raise_application_error(-20400, 'stored script not found');
END;
 
FUNCTION getLine RETURN VARCHAR2 IS
  scrl_row   scrlQ%rowtype;
BEGIN
  IF not scr_glob and this_db_key IS NULL THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
  IF NOT scrlQ%ISOPEN THEN
    raise_application_error(-20403, 'getScript not done');
  END IF;
  FETCH scrlQ INTO scrl_row;
  IF scrlQ%NOTFOUND THEN  -- end of fetch
    close scrlQ;
    return NULL;
  END IF;
  RETURN scrl_row.text;
END;
 
PROCEDURE commitChanges(msg IN varchar2 DEFAULT NULL) IS
BEGIN
  IF (this_ckp_key IS NULL) THEN
    deb(msg || ',commitChanges commit, release locks');
    commit;
  ELSE
    deb(msg || ',resync active, commitChanges ignored');
  END IF;
END;
 
/*---------------------------------------*
 * Procedures for EM xml store support   *
 *---------------------------------------*/
procedure createXMLFile (name        IN varchar2 
                        ,name_tag    IN varchar2
                        ,xmldoc      IN     clob
                        ,doctype     IN varchar2
                        ,xml_comment IN varchar2
                        ,schema_ver  IN varchar2
                        ) IS
begin
 
--
   insert into xmlstore
      (store_key, 
       creation_time, 
       name, 
       name_tag, 
       doctype, 
       schema_ver, 
       xml_comment,
       xmldoc) 
   values
      (rman_seq.nextval, 
       sys_extract_utc(systimestamp),
       createXMLFile.name,
       createXMLFile.name_tag, 
       createXMLFile.doctype,
       createXMLFile.schema_ver, 
       createXMLFile.xml_comment,
       XMLType.createXML(createXMLFile.xmldoc, schema_ver));
   commitChanges('createXMLFile');
 
end createXMLFile;
 
procedure updateXMLFile (name        IN varchar2
                        ,name_tag    IN varchar2
                        ,xmldoc      IN clob
                        ,xml_comment IN varchar2
                        ,schema_ver  IN varchar2
                        ,new_name    IN varchar2
                        ,new_name_tag IN varchar2
                        ,new_version  IN BOOLEAN ) IS
   oldrec          xmlstore%ROWTYPE;
begin
 
--
   begin
      select * into oldrec
      from xmlstore
      where name = updateXMLFile.name
         and (name_tag = updateXMLFile.name_tag or
              (name_tag is null and updateXMLFile.name_tag is null))
      for update;
   exception
      when too_many_rows then
         select * into oldrec
         from xmlstore
          where name = updateXMLFile.name
            and (name_tag = updateXMLFile.name_tag or
                 (name_tag is null and updateXMLFile.name_tag is null))
            and version_num = 
                (select max(version_num) from xmlstore
                 where name = updateXMLFile.name
                   and (name_tag = updateXMLFile.name_tag or
                         (name_tag is null 
                          and updateXMLFile.name_tag is null)))
          for update;
   end;
 
--
   if xmldoc is not null then
      oldrec.xmldoc := 
         XMLType.createXML(xmldoc, nvl(schema_ver, oldrec.schema_ver));
   end if;
 
   if xml_comment is not null then
      oldrec.xml_comment := xml_comment;
   end if;
 
   if schema_ver is not null then
      oldrec.schema_ver := schema_ver;
   end if;
 
   if new_name is not null then
      oldrec.name := new_name;
   end if;
 
   if new_name_tag is not null then
      oldrec.name_tag := new_name_tag;
   end if;
 
--
--
   if new_version then
      oldrec.version_num := oldrec.version_num + 1;
      select rman_seq.nextval into oldrec.store_key from dual;
      insert into xmlstore values oldrec;
   else
     oldrec.modified_time := sys_extract_utc(systimestamp);
      update xmlstore p set row = oldrec
         where p.name = updateXMLFile.name
            and (p.name_tag = updateXMLFile.name_tag or
                 (p.name_tag is null and updateXMLFile.name_tag is null))
            and p.version_num = oldrec.version_num;
   end if;
 
   commitChanges('updateXMLFile');
 
end updateXMLFile;
 
procedure deleteXMLFile (name     IN varchar2
                        ,name_tag IN varchar2) IS
begin
 
--
   delete xmlstore 
      where name = deleteXMLFile.name
        and (name_tag = deleteXMLFile.name_tag or
             (name_tag is null and deleteXMLFile.name_tag is null));
   if sql%rowcount = 0 then
      raise no_data_found;
   end if;
   commitChanges('deleteXMLFile');
 
end deleteXMLFile;
 
procedure readXMLFile   (name        IN varchar2
                        ,name_tag    IN varchar2
                        ,version_num IN number
                        ,xmldoc      OUT clob) IS
begin
 
--
   if version_num is null then
      begin
         select XMLType.getClobVal(xmldoc) into readXMLFile.xmldoc
         from xmlstore
         where name = readXMLFile.name
            and (name_tag = readXMLFile.name_tag or
                 (name_tag is null and readXMLFile.name_tag is null));
      exception
         when too_many_rows then
            select XMLType.getClobVal(xmldoc) into readXMLFile.xmldoc
            from xmlstore
             where name = readXMLFile.name
              and (name_tag = readXMLFile.name_tag or
                   (name_tag is null and readXMLFile.name_tag is null))
              and version_num = 
                  (select max(version_num) from xmlstore
                   where name = readXMLFile.name
                    and (name_tag = readXMLFile.name_tag or
                         (name_tag is null and readXMLFile.name_tag is null)));
      end;
   else
      select XMLType.getClobVal(xmldoc) into readXMLFile.xmldoc
      from xmlstore
      where name = readXMLFile.name
         and (name_tag = readXMLFile.name_tag or
              (name_tag is null and readXMLFile.name_tag is null))
         and version_num = readXMLFile.version_num;
   end if;
 
end readXMLFile;
 
procedure getXMLFileAttr (name        IN varchar2
                         ,name_tag    IN varchar2
                         ,version_num IN number
                         ,doctype     OUT varchar2
                         ,file_size   OUT number
                         ,xml_comment OUT varchar2
                         ,schema_ver  OUT varchar2) is
   myrec xmlstore%ROWTYPE;
begin
 
--
--
   if version_num is null then
      begin
         select * into myrec
         from xmlstore
         where name = getXMLFileAttr.name
           and (name_tag = getXMLFileAttr.name_tag or 
                (name_tag is null and getXMLFileAttr.name_tag is null));
      exception
         when too_many_rows then
            select * into myrec
            from xmlstore
             where name = getXMLFileAttr.name
               and (name_tag = getXMLFileAttr.name_tag or
                    (name_tag is null and getXMLFileAttr.name_tag is null))
               and version_num = 
                   (select max(version_num) from xmlstore
                    where name = getXMLFileAttr.name
                      and (name_tag = getXMLFileAttr.name_tag or
                           (name_tag is null 
                            and getXMLFileAttr.name_tag is null)));
      end;
   else
      select * into myrec
      from xmlstore
      where name = getXMLFileAttr.name
         and (name_tag = getXMLFileAttr.name_tag or
              (name_tag is null and getXMLFileAttr.name_tag is null))
         and version_num = getXMLFileAttr.version_num;
   end if;
 
--
   doctype := myrec.doctype;
   file_size := dbms_lob.getlength(XMLType.getClobVal(myrec.xmldoc));
   xml_comment := myrec.xml_comment;
   schema_ver := myrec.schema_ver;
 
end getXMLFileAttr;
 
--
--
--
FUNCTION getPackageVersion RETURN VARCHAR2 IS
   version raschemaver.version%type;
   table_not_found EXCEPTION;
   PRAGMA EXCEPTION_INIT(table_not_found, -942);
BEGIN
  if version_counter > version_max_index then
    version_counter := 1;
    return null;
  end if;
  version_counter := version_counter + 1;
 
--
  BEGIN
     SELECT to_char(max(version), '09')
       INTO version 
       FROM raschemaver;
  EXCEPTION
     WHEN table_not_found THEN
        version := NULL;
  END;
 
  IF (version IS NULL) THEN
     version := '00';
  END IF;
 
--
  return version_list(version_counter - 1) || '.' || version;
END;
 
FUNCTION getCatalogVersion RETURN VARCHAR2 IS
version rcver.version%type;
BEGIN
  IF NOT rcverQ%ISOPEN THEN
    open rcverQ;
  END IF;
 
  FETCH rcverQ into version;
 
  IF rcverQ%NOTFOUND THEN  -- end of fetch
    close rcverQ;
    return NULL;
  END IF;
 
  RETURN version;
 
END;
 
/*---------------------------------------*
 * Procedures for clone database support *
 *---------------------------------------*/
 
PROCEDURE setCloneName(file#            IN  NUMBER
                      ,creation_change# IN  NUMBER
                      ,new_clone_fname  IN  VARCHAR2
                      ,old_clone_fname  IN  VARCHAR2
                      ,changedauxname   OUT boolean
                      ,plugin_change#   IN NUMBER   DEFAULT 0) IS
lfname df.clone_fname%TYPE;
BEGIN
  deb('setCloneName: file#='           || to_char(file#)||
                  ', creation_fname='  || to_char(nvl(creation_change#, ''))||
                  ', plugin_change#='  || to_char(nvl(plugin_change#, ''))||
                  ', old_clone_fname=' || old_clone_fname ||
                  ', new_clone_fname=' || new_clone_fname);
  changedauxname := FALSE;
--
--
  IF (new_clone_fname = 'UNKNOWN') THEN
     RETURN;
  END IF;
  IF old_clone_fname is NULL THEN
     IF new_clone_fname = 'NONE' THEN
--
        RETURN;
     ELSE
        lfname := new_clone_fname;
     END IF;
  ELSE
     IF new_clone_fname = 'NONE' THEN
        lfname := NULL;
     ELSIF old_clone_fname = new_clone_fname THEN
--
        RETURN;
     ELSE
        lfname := new_clone_fname;
     END IF;
  END IF;
 
  UPDATE df SET df.clone_fname = lfname
   WHERE df.dbinc_key = this_dbinc_key
     AND df.file# = setCloneName.file#
     AND df.create_scn = setCloneName.creation_change#
     AND df.plugin_scn = setCloneName.plugin_change#;
  changedauxname := TRUE;
 
  deb('setCloneName - changed auxname for file# '||to_char(file#)||
      ' from '||nvl(old_clone_fname, 'NULL')||' to '||
      nvl(lfname, 'NULL'));
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    raise_application_error(-20105, 'datafile missing');
END;
 
--
--
FUNCTION getCloneName( file#            IN NUMBER
                      ,creation_change# IN NUMBER
                      ,plugin_change#   IN NUMBER DEFAULT 0)
RETURN VARCHAR2 IS
 
ret df.clone_fname%TYPE;
 
BEGIN
 
--
--
  ret := dbms_rcvman.getCloneName(file#, creation_change#, plugin_change#);
 
  RETURN ret;
 
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    raise_application_error(-20105, 'datafile missing');
END;
 
 
/*-----------------------------------*
 * Procedures for RMAN configuration *
 *-----------------------------------*/
 
--
PROCEDURE setConfig(conf#            IN NUMBER
                   ,name             IN VARCHAR2
                   ,value            IN VARCHAR2) IS
BEGIN
 
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  INSERT INTO
         conf(     db_key, conf#, name, value, cleanup, db_unique_name,
                 site_key)
       VALUES(this_db_key, conf#, name, value,   'YES',           NULL,
                        0);
 
EXCEPTION
  WHEN dup_val_on_index THEN
    UPDATE conf SET
           conf.name = name,
           conf.value = value WHERE conf.conf# = conf#
                              AND   conf.db_key = this_db_key;
  RETURN;
END;
 
--
PROCEDURE setConfig2(conf#     IN NUMBER
                    ,name      IN VARCHAR2
                    ,value     IN VARCHAR2
                    ,nodespec  IN BOOLEAN) IS
  lname    conf.name%TYPE;
  lvalue   conf.value%TYPE;
BEGIN
 
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
--
--
  IF (nodespec)
  THEN
    INSERT INTO
          conf(     db_key, conf#, name, value,  cleanup, db_unique_name,
                  site_key)
        VALUES(this_db_key, conf#, name, value,     'NO', this_db_unique_name,
               this_site_key);
  ELSE
    INSERT INTO
          conf(     db_key, conf#, name, value,  cleanup,  db_unique_name,
                  site_key)
        VALUES(this_db_key, conf#, name, value,     'NO',           NULL,
                           0);
 
  END IF;
 
  deb('setConfig - Added name=(' || name ||
      '), value=(' || value ||
      ') to node ' || this_db_unique_name ||
      '('|| conf# ||')');
 
  EXCEPTION
--
--
    WHEN dup_val_on_index THEN
      select name, value into lname, lvalue from conf where
             conf.conf# = setConfig2.conf# AND
             conf.db_key = this_db_key AND
             db_unique_name = this_db_unique_name;
      IF (lname = name AND lvalue = value) THEN
        RETURN;
      END IF;
      deb('setConfig - lname=' || lname ||
          ', lvalue=' || lvalue);
      RAISE;
    WHEN others THEN
      deb('setConfig - this_db_unique_name='||this_db_unique_name||
          ', conf#='||conf#);
      RAISE;
END;
 
--
--
FUNCTION setConfig3(name            IN VARCHAR2
                    ,value           IN VARCHAR2
                    ,db_unique_name  IN VARCHAR2) 
  RETURN NUMBER IS
  lname     conf.name%TYPE NOT NULL := name;
  lvalue    conf.value%TYPE NOT NULL := value;
  ldbuname  conf.db_unique_name%TYPE NOT NULL := upper(db_unique_name);
  lsite_key NUMBER;
  lconf_key NUMBER;
BEGIN
 
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  deb('setConfig3 - Remote setConfig for '||ldbuname);
 
  SELECT site_key into lsite_key from node 
         where node.db_unique_name = ldbuname AND
         node.db_key = this_db_key;
  deb('setConfig3 - remote_site_key='||lsite_key);
 
--
--
  INSERT INTO conf(db_key, conf#, name, value,  cleanup, db_unique_name,
                   site_key)
      VALUES(this_db_key, rman_seq.nextval, name, value, 'NO', ldbuname,
             lsite_key)
  RETURNING conf# INTO lconf_key;
 
  UPDATE node SET node.force_resync2cf = 'YES'
    WHERE node.db_key = this_db_key
      AND node.db_unique_name = ldbuname;
 
  commitChanges('setConfig3');
  deb('setConfig3 - Added name=(' || lname ||
      '), value=(' || lvalue ||
      ') to node ' || ldbuname ||
      '('|| lconf_key ||')');
 
  RETURN lconf_key;
 
EXCEPTION
  WHEN OTHERS THEN
    deb('setConfig3 - rollback all, release locks');
    ROLLBACK;
    RAISE;
END;
 
--
--
PROCEDURE deleteConfig3(conf#        IN NUMBER
                    ,db_unique_name  IN VARCHAR2) IS
BEGIN
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
--
--
--
  DELETE conf
  WHERE  conf.db_key = this_db_key AND
         conf.db_unique_name = deleteConfig3.db_unique_name AND
         conf.conf# = deleteConfig3.conf#;
 
  IF sql%rowcount <> 1 AND sql%rowcount <> 0 THEN
     raise_application_error(-20999,
            'Internal error in deleteConfig3, deleted rows= ' || sql%rowcount);
  END IF;
 
  UPDATE node SET node.force_resync2cf = 'YES'
    WHERE node.db_key = this_db_key
      AND node.db_unique_name = deleteconfig3.db_unique_name;
 
  commitChanges('deleteConfig3');
EXCEPTION
  WHEN OTHERS THEN
    deb('deleteConfig3 - rollback all, release locks');
    ROLLBACK;
    RAISE;
END;
 
PROCEDURE resetConfig IS
BEGIN
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  DELETE conf
  WHERE  conf.db_key = this_db_key;
 
EXCEPTION
  WHEN NO_DATA_FOUND THEN
--
  RETURN;
END resetConfig;
 
PROCEDURE resetConfig2 (nodespec IN BOOLEAN, high_conf_recid IN NUMBER DEFAULT NULL) IS
BEGIN
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
--
--
--
  DELETE conf
  WHERE  conf.db_key = this_db_key AND conf.cleanup = 'YES';
 
--
--
--
  IF (nodespec)
  THEN
    DELETE conf
    WHERE  conf.db_key = this_db_key AND
           conf.db_unique_name = this_db_unique_name;
  ELSE
 
--
--
--
    force_resync2cf := 'YES';
 
    DELETE conf
    WHERE  conf.db_key = this_db_key AND
           conf.db_unique_name IS NULL;
  END IF;
 
  IF high_conf_recid IS NOT NULL THEN
     last_conf_recid := high_conf_recid;
     deb('resetConfig2 - updated last_conf_recid=' || last_conf_recid);
  END IF;
 
EXCEPTION
  WHEN NO_DATA_FOUND THEN
--
  RETURN;
END resetConfig2;
 
PROCEDURE deleteConfig(conf#            IN NUMBER) IS
BEGIN
--
--
  raise_application_error(-20999,
         'Internal error in deleteConfig should not be called ');
END;
 
/*-------------------------*
 * Catalog upgrade support *
 *-------------------------*/
 
/* NOTES:
 *
 * These procedures *must* tolerate being called *before* dbinc_key
 * has been set.
 */
 
/*-------------------*
 * Utility functions *
 *-------------------*/
 
PROCEDURE bsStatusRecalc(status IN varchar2) IS
 
cursor bsQ(status varchar2) IS
  SELECT bs_key
  FROM bs
  WHERE bs.status = bsStatusRecalc.status
--
  AND bs.db_key = this_db_key;
 
bsQrec bsQ%ROWTYPE;
 
BEGIN
 
  IF this_is_ors AND this_ckp_key IS NULL THEN
     this_enable_populate_rsr := getValueFromConfig('_enable_populate_rsr_key');
  END IF;
 
  FOR bsQrec in bsQ(status) LOOP
    updateBackupSetRec(bsQrec.bs_key);
  END LOOP;
--
--
  IF this_is_ors AND this_ckp_key IS NULL THEN
     this_enable_populate_rsr := NULL;
     this_upstream_site_key := NULL;
  END IF;
 
END;
 
PROCEDURE reNormalize(newname IN varchar2, oldname OUT varchar2) IS
BEGIN
   IF newname IS NULL THEN -- initialize
      IF reNorm_dfatt_c%ISOPEN THEN
         CLOSE reNorm_dfatt_c;
      END IF;
      IF reNorm_orl_c%ISOPEN THEN
         CLOSE reNorm_orl_c;
      END IF;
      IF reNorm_al_c%ISOPEN THEN
         CLOSE reNorm_al_c;
      END IF;
      IF reNorm_bp_c%ISOPEN THEN
         CLOSE reNorm_bp_c;
      END IF;
      IF reNorm_ccf_c%ISOPEN THEN
         CLOSE reNorm_ccf_c;
      END IF;
      IF reNorm_cdf_c%ISOPEN THEN
         CLOSE reNorm_cdf_c;
      END IF;
      IF reNorm_tfatt_c%ISOPEN THEN
         CLOSE reNorm_tfatt_c;
      END IF;
 
      reNorm_state := RENORM_DFATT;
   ELSE -- update the previous row
      IF reNorm_state = RENORM_DFATT THEN
         UPDATE site_dfatt SET fname = newname WHERE CURRENT OF reNorm_dfatt_c;
      ELSIF reNorm_state = RENORM_ORL THEN
         UPDATE orl SET fname = newname WHERE CURRENT OF reNorm_orl_c;
      ELSIF reNorm_state = RENORM_AL THEN
         UPDATE al SET fname = newname,
           fname_hashkey = substr(newname,1,10) || substr(newname, -10)
           WHERE CURRENT OF reNorm_al_c;
      ELSIF reNorm_state = RENORM_BP THEN
         UPDATE bp SET handle = newname,
           handle_hashkey = substr(device_type,1,10) ||
                            substr(newname,1,10)     ||
                            substr(newname,-10)
           WHERE CURRENT OF reNorm_bp_c;
      ELSIF reNorm_state = RENORM_CCF THEN
         UPDATE ccf SET fname = newname,
           fname_hashkey = substr(newname,1,10) || substr(newname, -10)
           WHERE CURRENT OF reNorm_ccf_c;
      ELSIF reNorm_state = RENORM_CDF THEN
         UPDATE cdf SET fname = newname,
           fname_hashkey = substr(newname,1,10) || substr(newname, -10)
           WHERE CURRENT OF reNorm_cdf_c;
      ELSIF reNorm_state = RENORM_TFATT THEN
         UPDATE site_tfatt SET fname = newname WHERE CURRENT OF reNorm_tfatt_c;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_DFATT THEN
      IF NOT reNorm_dfatt_c%ISOPEN THEN
         OPEN reNorm_dfatt_c;
      END IF;
 
      FETCH reNorm_dfatt_c INTO oldname;
 
      IF reNorm_dfatt_c%NOTFOUND THEN
         CLOSE reNorm_dfatt_c;
         reNorm_state := RENORM_ORL;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_ORL THEN
      IF NOT reNorm_orl_c%ISOPEN THEN
         OPEN reNorm_orl_c;
      END IF;
 
      FETCH reNorm_orl_c INTO oldname;
 
      IF reNorm_orl_c%NOTFOUND THEN
         CLOSE reNorm_orl_c;
         reNorm_state := RENORM_AL;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_AL THEN
      IF NOT reNorm_al_c%ISOPEN THEN
         OPEN reNorm_al_c;
      END IF;
 
      FETCH reNorm_al_c INTO oldname;
 
      IF reNorm_al_c%NOTFOUND THEN
         CLOSE reNorm_al_c;
         reNorm_state := RENORM_BP;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_BP THEN
      IF NOT reNorm_bp_c%ISOPEN THEN
         OPEN reNorm_bp_c;
      END IF;
 
      FETCH reNorm_bp_c INTO oldname;
 
      IF reNorm_bp_c%NOTFOUND THEN
         CLOSE reNorm_bp_c;
         reNorm_state := RENORM_CCF;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_CCF THEN
      IF NOT reNorm_ccf_c%ISOPEN THEN
         OPEN reNorm_ccf_c;
      END IF;
 
      FETCH reNorm_ccf_c INTO oldname;
 
      IF reNorm_ccf_c%NOTFOUND THEN
         CLOSE reNorm_ccf_c;
         reNorm_state := RENORM_CDF;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_CDF THEN
      IF NOT reNorm_cdf_c%ISOPEN THEN
         OPEN reNorm_cdf_c;
      END IF;
 
      FETCH reNorm_cdf_c INTO oldname;
 
      IF reNorm_cdf_c%NOTFOUND THEN
         CLOSE reNorm_cdf_c;
         reNorm_state := RENORM_TFATT;
      END IF;
   END IF;
 
   IF reNorm_state = RENORM_TFATT THEN
      IF NOT reNorm_tfatt_c%ISOPEN THEN
         OPEN reNorm_tfatt_c;
      END IF;
 
      FETCH reNorm_tfatt_c INTO oldname;
 
      IF reNorm_tfatt_c%NOTFOUND THEN
         CLOSE reNorm_tfatt_c;
         reNorm_state := NULL;
         oldname := NULL;
         commitChanges('reNormalize');
      END IF;
   END IF;
END reNormalize;
 
 
 
 
--
--
--
 
--
PROCEDURE cleanupResyncedBS;
PROCEDURE cleanupCKP;
PROCEDURE cleanupRLH;
PROCEDURE cleanupRSR;
PROCEDURE cleanupBV;
PROCEDURE cleanupROUT;
PROCEDURE cleanupNRS;
PROCEDURE cleanupDO;
PROCEDURE sanityCheck IS
BEGIN
 
  cleanupResyncedBS;
  cleanupCKP;
  cleanupRLH;
  cleanupRSR;
  cleanupBV;
  cleanupROUT;
  cleanupNRS;
  cleanupDO;
 
END sanityCheck;
 
PROCEDURE cleanupDO IS
  start_time     DATE := sysdate;
BEGIN
 
--
   DELETE deleted_object 
      WHERE db_key = this_db_key
        AND create_time < start_time - 30;
 
   deb('cleanupDO - deleted ' || sql%rowcount || ' rows from deleted_object');
   deb('cleanupDO - took ' || ((sysdate - start_time) * 86400) || ' seconds');
 
END cleanupDO;
 
PROCEDURE cleanupResyncedBS IS
   cnt    number;
BEGIN
 
--
--
--
--
 
  deb('cleanupResyncedBS - cntbs='||cntbs);
 
  IF cntbs is NULL THEN
    raise_application_error(-20107, 'invalid bskey counter');
  END IF;
 
  FOR i IN 1 .. cntbs LOOP
    SELECT count(*) into cnt from bs where bs_key = updatebs(i);
    IF cnt > 0 THEN
      deb('cleanupResyncedBS - updating bs_key='||updatebs(i));
      updateBackupSetRec(updatebs(i));
    END IF;
  END LOOP;
 
  cntbs := 0;
 
END cleanupResyncedBS;
 
PROCEDURE cleanupCKP IS
  scn            NUMBER;
  seq            NUMBER;
  keep_ckp_key_1 NUMBER;
  keep_ckp_key_2 NUMBER;
  start_time     DATE := sysdate;
BEGIN
 
--
--
--
--
 
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  dbms_rcvman.getCheckpoint(scn, seq, keep_ckp_key_1, keep_ckp_key_2);
 
  deb('cleanupCKP - scn=' || scn);
  deb('cleanupCKP - seq=' || seq);
  deb('cleanupCKP - keep_ckp_key_1=' || keep_ckp_key_1);
  deb('cleanupCKP - keep_ckp_key_2=' || keep_ckp_key_2);
 
--
--
--
 
  delete from ckp where dbinc_key = this_dbinc_key and ckp_key in
    (select ckp_key1 from
     (select ckp_key ckp_key1 from ckp where dbinc_key = this_dbinc_key) ckp1,
     (select keep_ckp_key_1 ckp_key2 from dual union
      select keep_ckp_key_2 from dual union
      select nvl(max(ckp_key),0) from ckp where dbinc_key=this_dbinc_key union
      select start_ckp_key from tsatt where dbinc_key = this_dbinc_key union
      select nvl(end_ckp_key,0) from tsatt where dbinc_key = this_dbinc_key)
     ckp2
     where ckp_key1 = ckp_key2(+) and ckp_key2 is null) and
    site_key = this_site_key;
 
   deb('cleanupCKP - deleted ' || sql%rowcount || ' rows from ckp table');
   deb('cleanupCKP - took ' || ((sysdate - start_time) * 86400) || ' seconds');
 
END cleanupCKP;
 
PROCEDURE cleanupRLH IS
  oldscn         NUMBER;
  start_time     DATE := sysdate;
BEGIN
 
--
--
--
--
--
 
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  SELECT nvl(min(scn),power(2,64)-1)
    INTO oldscn
    FROM
        (
         SELECT min(brl.low_scn) scn
           FROM brl
          WHERE brl.dbinc_key = this_dbinc_key
         UNION
         SELECT min(al.low_scn)
           FROM al
          WHERE al.dbinc_key = this_dbinc_key
         UNION
         SELECT min(xal.low_scn)
           FROM xal
          WHERE xal.dbinc_key = this_dbinc_key
         UNION
         SELECT min(bdf.ckp_scn)
           FROM bdf
          WHERE bdf.dbinc_key = this_dbinc_key
         UNION
         SELECT min(cdf.ckp_scn)
           FROM cdf
          WHERE cdf.dbinc_key = this_dbinc_key
         UNION
         SELECT min(xdf.ckp_scn)
           FROM xdf
          WHERE xdf.dbinc_key = this_dbinc_key
         UNION
         SELECT min(bcf.ckp_scn)
           FROM bcf
          WHERE bcf.dbinc_key = this_dbinc_key
         UNION
         SELECT min(ccf.ckp_scn)
           FROM ccf
          WHERE ccf.dbinc_key = this_dbinc_key
         UNION
         SELECT min(xcf.ckp_scn)
           FROM xcf
          WHERE xcf.dbinc_key = this_dbinc_key
           );
 
  deb('cleanupRLH - scn='||oldscn);
 
  DELETE
    FROM rlh
   WHERE rlh.dbinc_key = this_dbinc_key
     AND low_scn < oldscn;
 
   deb('cleanupRLH - deleted ' || sql%rowcount || ' rows from rlh table');
   deb('cleanupRLH - took ' || ((sysdate - start_time) * 86400) || ' seconds');
 
END cleanupRLH;
 
PROCEDURE cleanupBV IS
  start_time DATE := sysdate;
BEGIN
 
--
--
--
 
   DELETE FROM bs
     WHERE db_key = this_db_key
       AND ((input_file_scan_only='YES' AND SYSDATE - completion_time >= 60)
            OR
            (nvl(input_file_scan_only,'NO')='NO' AND status='D'))
       AND NOT EXISTS (SELECT 1 FROM bp
                        WHERE bp.bs_key = bs.bs_key);
 
   deb('cleanupBV - deleted ' || sql%rowcount || ' rows from bs table');
   deb('cleanupBV - took ' || ((sysdate - start_time) * 86400) || ' seconds');
 
END cleanupBV;
 
FUNCTION getDbid RETURN NUMBER IS
  dbid   NUMBER;
BEGIN
  SELECT db.db_id
    INTO dbid
    FROM db
   WHERE db_key = this_db_key
     AND curr_dbinc_key = this_dbinc_key;
  RETURN dbid;
  EXCEPTION
     WHEN no_data_found THEN
        raise_application_error(-20001, 'Database not found');
END getDbid;
 
FUNCTION beginIncarnationResync(return_Recid in boolean DEFAULT FALSE)
RETURN NUMBER IS
local_kccdivts number;
BEGIN
  checkResync;
 
  IF return_Recid THEN
    IF (this_cf_type = 'CURRENT' OR
        (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
       SELECT high_ic_recid INTO last_ic_recid
       FROM node
       WHERE site_key = this_site_key;
    ELSE
       last_ic_recid := sessionWaterMarks.high_ic_recid;
    END IF;
 
    RETURN last_ic_recid;
  ELSE
    IF (this_cf_type = 'CURRENT' OR
        (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
       SELECT last_kccdivts INTO local_kccdivts
       FROM node
       WHERE site_key = this_site_key;
    ELSE
       local_kccdivts := 0;
    END IF;
 
    IF (local_kccdivts IS NULL) THEN
       local_kccdivts := 0;
    END IF;
    RETURN local_kccdivts;
  END IF;
 
END beginIncarnationResync;
 
 
--
--
--
 
FUNCTION checkIncarnation(reset_scn         IN NUMBER,
                          reset_time        IN DATE,
                          prior_reset_scn   IN NUMBER DEFAULT NULL,
                          prior_reset_time  IN DATE DEFAULT NULL,
                          db_name           IN VARCHAR2 DEFAULT 'UNKNOWN')
                        RETURN NUMBER IS
local             dbinc%rowtype;
prior_dbinc_key   number := NULL;
d_name            VARCHAR2(8);
 
BEGIN
 
  BEGIN
    SELECT dbinc_key, parent_dbinc_key, db_name
       INTO local.dbinc_key, local.parent_dbinc_key, local.db_name
    FROM dbinc
    WHERE dbinc.db_key = this_db_key
    AND   dbinc.reset_scn = checkIncarnation.reset_scn
    AND   dbinc.reset_time = checkIncarnation.reset_time;
  EXCEPTION
    WHEN no_data_found THEN
      local.dbinc_key := NULL;
      local.parent_dbinc_key := NULL;
      local.db_name := 'UNKNOWN';
  END;
 
  IF (local.parent_dbinc_key IS NULL AND
      checkIncarnation.prior_reset_scn IS NOT NULL) THEN
     BEGIN
        SELECT dbinc_key
           INTO prior_dbinc_key
        FROM dbinc
        WHERE dbinc.db_key = this_db_key
        AND   dbinc.reset_scn = checkIncarnation.prior_reset_scn
        AND   dbinc.reset_time = checkIncarnation.prior_reset_time;
     EXCEPTION
       WHEN no_data_found THEN
          prior_dbinc_key := NULL;
     END;
  END IF;
 
  IF (local.dbinc_key IS NOT NULL) THEN
--
    IF (local.parent_dbinc_key IS NULL AND
        prior_dbinc_key IS NOT NULL) THEN
      UPDATE dbinc SET parent_dbinc_key = prior_dbinc_key
      WHERE dbinc.dbinc_key = local.dbinc_key;
    END IF;
 
--
    IF (local.db_name != 'UNKNOWN' AND
        checkIncarnation.db_name != 'UNKNOWN') THEN
      UPDATE dbinc SET db_name = checkIncarnation.db_name
      WHERE dbinc.dbinc_key = local.dbinc_key;
    END IF;
 
    RETURN local.dbinc_key;
  END IF;
 
  IF (this_lock_ors_inspect) THEN
--
--
    deb('checkincarnation:server_error for db_key='||this_db_key);
    EXECUTE IMMEDIATE 'BEGIN  dbms_ra_scheduler.log_error(
            p_component => ''INSPECT'',
            p_severity  => dbms_ra_scheduler.SEVERITY_WARNING,
            p_db_key => :1,
            p_keep_stack => TRUE,
            p_errno => dbms_ra_scheduler.E_NEW_INC_ERROR_NUM); END;'
            USING this_db_key ;
  END IF;
--
  BEGIN
--
    d_name := checkIncarnation.db_name;
    IF (d_name = 'UNKNOWN') THEN
       BEGIN
          SELECT db_name
             INTO d_name
          FROM db, dbinc
          WHERE dbinc.db_key = this_db_key
            AND db.curr_dbinc_key = dbinc.dbinc_key;
          EXCEPTION
             WHEN no_data_found THEN
                deb('database name not set');
                d_name := checkIncarnation.db_name;
       END;
    END IF;
    
    INSERT INTO dbinc
      (dbinc_key, db_key, db_name, reset_scn, reset_time, parent_dbinc_key)
    VALUES
      (rman_seq.nextval, this_db_key,
       upper(d_name), checkIncarnation.reset_scn,checkIncarnation.reset_time,
       prior_dbinc_key)
    RETURNING dbinc_key INTO local.dbinc_key;
  EXCEPTION
    WHEN dup_val_on_index THEN
      raise_application_error(-20009, 'Db incarnation already registered');
  END;
 
  inheritPdbInc(
     this_db_key, local.dbinc_key, reset_scn, prior_dbinc_key);
  RETURN local.dbinc_key;
END checkIncarnation;
 
PROCEDURE endIncarnationResync(high_kccdivts IN NUMBER,
                               high_ic_recid IN NUMBER DEFAULT 0) IS
BEGIN
 
--
--
  IF (last_ic_recid IS NOT NULL) THEN
    IF (this_cf_type = 'CURRENT' OR
        (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
--
       UPDATE node SET high_ic_recid = endIncarnationResync.high_ic_recid,
                       last_kccdivts = endIncarnationResync.high_kccdivts
              WHERE site_key = this_site_key;
    END IF;
    sessionWaterMarks.high_ic_recid := high_ic_recid;
    last_ic_recid := NULL;
  ELSE
    IF (this_cf_type = 'CURRENT' OR
        (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
       UPDATE node SET last_kccdivts = high_kccdivts
       WHERE site_key = this_site_key;
    END IF;
  END IF;
 
--
  recomputeDbincStatus(this_db_key, this_dbinc_key);
 
--
--
  IF NOT this_lock_ors_inspect THEN
   this_clr_ba_newinc_err := TRUE;
  END IF;
 
END endIncarnationResync;
 
/*--------------------------------*
 * Pluggable DB Incaration Resync *
 *--------------------------------*/
 
PROCEDURE fetchPic IS                   -- this is private to the pkg body
BEGIN
  FETCH picQ INTO picRec;               -- get next row
  IF picQ%NOTFOUND THEN
    picRec      := NULL;
    picRec.guid := NULL;                -- indicate end of fetch
    CLOSE picQ;
  ELSE
    deb('fetchPic - '||picRec.con_id||'('||to_char(picRec.con_id)||') '||
        to_char(picRec.pdbinc_key));
  END IF;
END fetchPic;
 
FUNCTION beginPluggableDbincResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_pic_recid INTO last_pic_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_pic_recid := sessionWaterMarks.high_pic_recid;
  END IF;
 
  IF (picQ%ISOPEN) THEN
     CLOSE picQ;
  END IF;
 
  OPEN picQ;                          -- just open that cursor please
  fetchPic;                           -- do priming read
 
  RETURN last_pic_recid;
END beginPluggableDbincResync;
 
PROCEDURE checkPluggableDbinc(
  recid               IN NUMBER
 ,guid                IN RAW
 ,curr_pdbinc         IN VARCHAR2
 ,inc_scn             IN NUMBER
 ,begin_reset_scn     IN NUMBER
 ,begin_reset_time    IN DATE
 ,end_reset_scn       IN NUMBER
 ,db_reset_scn        IN NUMBER
 ,db_reset_time       IN DATE
 ,pr_inc_scn          IN NUMBER
 ,pr_end_reset_scn    IN NUMBER
 ,pr_db_reset_scn     IN NUMBER
 ,pr_db_reset_time    IN DATE
 ,chk_last_recid      IN BOOLEAN
) IS
   local_pdb_key       number;
   local_pdbinc_key    number;
   local_pr_pdbinc_key number;
   born_dbinc_key      number;
   pr_born_dbinc_key   number;
   pr_pdbinc_key       number;
BEGIN
  IF (chk_last_recid) THEN
     IF (last_pic_recid IS NULL) THEN
       raise_application_error(-20037, 'Invalid last recid');
     END IF;
 
--
--
--
--
     last_pic_recid := recid;
  END IF;
 
  IF (end_reset_scn = 0) THEN
     deb('checkPluggableDbinc - skipping partial record');
     RETURN;
  END IF;
 
--
  WHILE (guid > picRec.guid)
  LOOP
    fetchPic;
  END LOOP;
 
--
  WHILE (guid = picRec.guid  AND
         (begin_reset_scn  > picRec.begin_reset_scn   OR
          begin_reset_time > picRec.begin_reset_time  OR
          end_reset_scn    > picRec.end_reset_scn))
  LOOP
     fetchPic;
  END LOOP;
 
--
  IF (guid             = picRec.guid             AND
      begin_reset_scn  = picRec.begin_reset_scn  AND
      begin_reset_time = picRec.begin_reset_time AND 
      end_reset_scn    = picRec.end_reset_scn) THEN
 
     deb('checkPluggableDbinc - pdbinc already known');
 
--
     local_pdb_key       := picRec.pdb_key;
     local_pdbinc_key    := picRec.pdbinc_key;
     local_pr_pdbinc_key := picRec.parent_pdbinc_key;
  END IF;
 
  IF (local_pr_pdbinc_key IS NULL) THEN
--
     IF (local_pdb_key IS NULL) THEN
        local_pdb_key := guidToPdbKey(checkPluggableDbinc.guid, 0);
        deb('checkPluggableDbinc - pdb_key=' || local_pdb_key);
     END IF;
 
     IF (pr_db_reset_scn = 0 OR pr_end_reset_scn = 0) THEN
        pr_pdbinc_key := NULL;
        deb('checkPluggableDbinc - no parent_pdbinc_key');
     ELSE
--
        pr_born_dbinc_key :=
           checkIncarnation(pr_db_reset_scn, pr_db_reset_time);
        deb('checkPluggableDbinc - pr_born_dbinc_key=' || pr_born_dbinc_key);
 
        BEGIN
           SELECT pdbinc_key
             INTO pr_pdbinc_key
             FROM pdbinc
            WHERE pdbinc.born_dbinc_key = pr_born_dbinc_key
              AND pdbinc.pdb_key        = local_pdb_key
              AND pdbinc.end_reset_scn  = pr_end_reset_scn;
        EXCEPTION
           WHEN no_data_found THEN
              pr_pdbinc_key := NULL;
        END;
 
        deb('checkPluggableDbinc - parent_pdbinc_key=' || pr_pdbinc_key);
     END IF;
  END IF;
 
  IF (local_pdbinc_key IS NULL) THEN
     born_dbinc_key := checkIncarnation(db_reset_scn, db_reset_time);
     deb('checkPluggableDbinc - born_dbinc_key=' || born_dbinc_key);
 
--
     INSERT INTO pdbinc
       (pdbinc_key, pdb_key, born_dbinc_key, inc_scn, begin_reset_scn,
        begin_reset_time, end_reset_scn, parent_pdbinc_key)
     VALUES
       (rman_seq.nextval, local_pdb_key, born_dbinc_key, inc_scn,
        begin_reset_scn, begin_reset_time, end_reset_scn, pr_pdbinc_key)
     RETURNING pdbinc_key INTO local_pdbinc_key;
  ELSE
     IF (local_pr_pdbinc_key IS NULL AND pr_pdbinc_key IS NOT NULL) THEN
        UPDATE pdbinc SET parent_pdbinc_key = pr_pdbinc_key
         WHERE pdbinc_key = local_pdbinc_key;
     END IF;
  END IF;
 
  IF (curr_pdbinc = 'YES') THEN
     UPDATE pdb_dbinc
        SET curr_pdbinc_key = local_pdbinc_key,
            drop_scn = NULL
      WHERE dbinc_key = this_dbinc_key
        AND pdb_key   = local_pdb_key;
 
     IF (sql%rowcount = 0) THEN 
        INSERT INTO pdb_dbinc
           (dbinc_key, pdb_key, drop_scn, drop_time, curr_pdbinc_key)
        VALUES
           (this_dbinc_key, local_pdb_key, NULL, NULL, local_pdbinc_key);
     END IF;
  END IF;
END checkPluggableDbinc;
 
PROCEDURE endPluggableDbincResync(high_pic_recid IN NUMBER) IS
BEGIN
  IF (last_pic_recid IS NOT NULL) THEN
     IF (this_cf_type = 'CURRENT' OR
         (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
        UPDATE node SET high_pic_recid = endPluggableDbincResync.high_pic_recid
        WHERE site_key = this_site_key;
     END IF;
 
     sessionWaterMarks.high_pic_recid := high_pic_recid;
     last_pic_recid := NULL;
  END IF;
 
--
  recomputePluggableDbincStatus(this_dbinc_key);
 
  IF (picQ%ISOPEN) THEN
     picRec.guid := NULL;         -- indicate end of fetch
     CLOSE picQ;
  END IF;
END endPluggableDbincResync;
 
/*-----------------------------*
 * Normal restore point Resync *
 *-----------------------------*/
 
FUNCTION beginRestorePointResync RETURN NUMBER IS
BEGIN
  checkResync;
 
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     SELECT high_nrsp_recid INTO last_nrsp_recid
     FROM node
     WHERE site_key = this_site_key;
  ELSE
     last_nrsp_recid := sessionWaterMarks.high_nrsp_recid;
  END IF;
 
  RETURN last_nrsp_recid;
END beginRestorePointResync;
 
PROCEDURE checkRestorePoint(
  nrsp_recid    IN NUMBER
 ,nrsp_stamp    IN NUMBER
 ,nrsp_name     IN VARCHAR2
 ,reset_scn     IN NUMBER
 ,reset_time    IN DATE
 ,to_scn        IN NUMBER
 ,nrsp_time     IN DATE
 ,create_time   IN DATE
 ,deleted       IN NUMBER
 ,con_id        IN NUMBER   DEFAULT NULL
 ,clean         IN VARCHAR2 DEFAULT 'NO'
) IS
   my_dbinc_key  NUMBER;
   inscheck      NUMBER;
   local_pdb_key NUMBER;
BEGIN
  IF (last_nrsp_recid IS NULL) THEN
    raise_application_error(-20037, 'Invalid last recid');
  END IF;
 
  IF (nrsp_recid < last_nrsp_recid) THEN
    raise_application_error(-20036, 'Invalid record order');
  END IF;
 
  IF (nrsp_recid > last_nrsp_recid + 1) THEN
--
--
    NULL;
  END IF;
  last_nrsp_recid := nrsp_recid;
 
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
  IF (nrsp_stamp > 0 and nrsp_stamp < kccdivts) THEN
     deb('checkRestorePoint - ignoring record kccdivts='||kccdivts);
     RETURN;                    -- obsolete record from a backup controlfile
  END IF;
 
--
  my_dbinc_key := checkIncarnation(reset_scn, reset_time);
 
--
--
  SELECT pdb.pdb_key INTO local_pdb_key
    FROM pdb, pdb_dbinc
   WHERE pdb_dbinc.drop_scn IS NULL
     AND pdb.con_id  IN
         (checkRestorePoint.con_id,
          0, 
          decode(checkRestorePoint.con_id, 0, 1))
     AND pdb.pdb_key         = pdb_dbinc.pdb_key
     AND pdb_dbinc.dbinc_key = this_dbinc_key;
 
--
  IF (deleted = 1)
  THEN
    DELETE nrsp
    WHERE checkRestorePoint.nrsp_recid = nrsp_recid
      AND checkRestorePoint.nrsp_stamp = nrsp_stamp
      AND my_dbinc_key = nrsp.dbinc_key
      AND this_site_key = site_key;
  ELSE
--
--
    DELETE nrsp
    WHERE this_site_key = nrsp.site_key
      AND local_pdb_key = nrsp.pdb_key
      AND checkRestorePoint.nrsp_name = nrsp.rspname;
 
    IF SQL%ROWCOUNT > 0 THEN
       deb('checkRestorePoint:deleted duplicate restore point:' 
           || checkRestorePoint.nrsp_name);
    END IF;
 
    INSERT INTO nrsp
        (nrsp_recid
        ,nrsp_stamp
        ,rspname
        ,dbinc_key
        ,site_key
        ,to_scn
        ,rsptime
        ,creation_time
        ,long_term
        ,pdb_key
        ,clean)
    VALUES
        (checkRestorePoint.nrsp_recid
        ,checkRestorePoint.nrsp_stamp
        ,checkRestorePoint.nrsp_name
        ,my_dbinc_key
        ,this_site_key
        ,checkRestorePoint.to_scn
        ,checkRestorePoint.nrsp_time
        ,checkRestorePoint.create_time
        ,NULL   -- UNKNOWN: cleanupNRS will reset to YES/NO
        ,local_pdb_key
        ,clean);
  END IF;
 
  EXCEPTION
      WHEN dup_val_on_index THEN
        deb('checkRestorePoint - Inside dup_val_on_index exception for' ||
            ' recid ' || checkRestorePoint.nrsp_recid ||
            ' stamp ' || checkRestorePoint.nrsp_stamp);
        SELECT min(nrsp.nrsp_recid) INTO inscheck
        FROM nrsp
        WHERE nrsp.nrsp_recid = checkRestorePoint.nrsp_recid
          AND nrsp.nrsp_stamp = checkRestorePoint.nrsp_stamp
          AND nrsp.dbinc_key = my_dbinc_key
          AND nrsp.site_key = this_site_key
          AND nrsp.rspname = checkRestorePoint.nrsp_name
          AND nrsp.to_scn = checkRestorePoint.to_scn
          AND nrsp.pdb_key = local_pdb_key;
        IF inscheck IS NULL THEN -- Some internal error to indicate no match
          raise_application_error(-20999,
                              'internal error: no match for restore point');
        END IF;
        RETURN;
      WHEN others THEN
         RAISE;
END checkRestorePoint;
 
PROCEDURE endRestorePointResync(lowrecid IN number) IS
   lowscn number;
BEGIN
--
  IF (lowrecid = 0)
  THEN
    low_nrsp_recid := NULL;
  ELSE
    low_nrsp_recid := lowrecid;
  END IF;
 
--
  IF (this_cf_type = 'CURRENT' OR
      (this_cf_type = 'STANDBY' AND this_db_unique_name is not null)) THEN
     UPDATE node SET high_nrsp_recid = last_nrsp_recid
     WHERE site_key = this_site_key;
  END IF;
 
  sessionWaterMarks.high_nrsp_recid := last_nrsp_recid;
  last_nrsp_recid := NULL;
END endRestorePointResync;
 
 
PROCEDURE listScriptNames(glob IN number,
                          allnames IN number) IS
   lglob number  := NULL;
   lalln number  := NULL;
BEGIN
    deb('listScriptNames - List script Names called with glob: '||
        nvl(to_char(glob), 'NULL')||'and allnames: '||
        nvl(to_char(allnames), 'NULL'));
    IF glob = 1 then
       lglob := 1;
    END IF;
    IF allnames = 1 then
       lalln := 1;
    END IF;
    IF lscrnames_c%ISOPEN THEN
       deb('listScriptNames - Closing lscrnames_c cursor');
       CLOSE lscrnames_c;
    END IF;
    deb('listScriptNames - Opening lscrnames_c cursor');
    OPEN lscrnames_c(lglob, lalln);
END listScriptNames;
 
PROCEDURE getScriptNames(dbname  OUT varchar2,
                         scnm    OUT varchar2,
                         sccom   OUT varchar2) IS
   ldum  number  := NULL;
BEGIN
   IF NOT lscrnames_c%ISOPEN THEN
      raise_application_error(-20403, 'listScriptNames not done');
   END IF;
 
    deb('getScriptNames - Fetching lscrnames_c cursor');
   FETCH lscrnames_c
   INTO  ldum, dbname, scnm, sccom;
 
   IF lscrnames_c%NOTFOUND THEN
      deb('getScriptNames - Closing lscrnames_c cursor');
      CLOSE lscrnames_c;
      raise no_data_found;
   END IF;
END getScriptNames;
 
--
--
PROCEDURE cleanupRSR IS
  nowTime date;
BEGIN
 
  SELECT SYSDATE INTO nowTime from dual;
 
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
--
--
--
--
 
  DELETE FROM rsr
        WHERE rsr_end < nowTime-60 
          AND rsr.dbinc_key IN 
              (select dbinc_key from dbinc 
               where dbinc.db_key = this_db_key);
 
   deb('cleanupRSR - deleted ' || sql%rowcount || ' rows from rsr table');
   deb('cleanupRSR - took ' || ((sysdate - nowTime) * 86400) || ' seconds');
 
END cleanupRSR;
 
--
--
PROCEDURE cleanupROUT IS
  start_time       date;
  high_stamp       number;
  high_session_key number;
  days             number;
BEGIN
  IF (this_db_key IS NULL) THEN
    raise_application_error(-20021, 'Database not set');
  END IF;
 
  IF session_keep_output IS NULL THEN 
     getRmanOutputLogging(days);
     deb('cleanupROUT - keep output is configured to ' || days);
  ELSIF session_keep_output = 0 THEN
     deb('cleanupROUT - session keep output is set to 0, not cleaning up');
     return;
  ELSE
     days := session_keep_output;
     deb('cleanupROUT - session keep output is set to ' || days);
  END IF;
 
  start_time      := SYSDATE;
  high_stamp      := date2stamp(start_time-days);
 
  SELECT max(rsr_key) into high_session_key
    FROM rsr, dbinc
   WHERE dbinc.db_key = this_db_key
     AND rsr.dbinc_key = dbinc.dbinc_key
     AND rsr.site_key = this_site_key
     AND rsr.rsr_stamp < high_stamp;
 
  deb('cleanupROUT select took ' || ((sysdate - start_time) * 86400) ||
      ' seconds');
 
--
  If high_session_key IS NOT NULL THEN
     DELETE FROM rout
     WHERE  db_key     = this_db_key
       AND  (site_key IS NULL) or (site_key  = this_site_key)
       AND  rout_skey <= high_session_key;
     deb('cleanupROUT deleted ' || sql%rowcount || ' rows from rout table');
  END IF;
 
  deb('cleanupROUT took ' || ((sysdate - start_time) * 86400) || ' seconds');
 
END cleanupROUT;
 
--
PROCEDURE cleanupNRS IS
  start_time       date;
BEGIN
  deb('cleanupNRS - low_nrsp_recid is ' ||
      NVL(TO_CHAR(low_nrsp_recid), 'NULL'));
  start_time := SYSDATE;
 
--
--
--
--
--
--
--
--
--
--
--
--
  UPDATE nrsp SET LONG_TERM = 'YES'
  WHERE long_term IS NULL
   AND this_site_key = site_key
   AND nrsp_recid in
   (SELECT nrsp.nrsp_recid
    FROM bs, brl, nrsp
    WHERE bs.bs_key = brl.bs_key
      AND bs.keep_options > 0
      AND brl.low_scn <= nrsp.to_scn
      AND brl.next_scn > nrsp.to_scn
      AND this_site_key = bs.site_key
      AND this_site_key = nrsp.site_key
   UNION
    SELECT nrsp.nrsp_recid
    FROM xal, nrsp
    WHERE xal.keep_options > 0
      AND xal.low_scn <= nrsp.to_scn
      AND xal.next_scn > nrsp.to_scn
      AND this_site_key = xal.site_key
      AND this_site_key = nrsp.site_key
   UNION
    SELECT nrsp_recid
    FROM bs, bdf, nrsp
    WHERE bs.bs_key = bdf.bs_key
      AND bs.keep_options > 0
      AND bdf.ckp_scn = nrsp.to_scn+1
      AND this_site_key = bs.site_key
      AND this_site_key = nrsp.site_key
   UNION
    SELECT nrsp_recid
    FROM xdf, nrsp
    WHERE xdf.keep_options > 0
      AND xdf.ckp_scn = nrsp.to_scn+1
      AND this_site_key = xdf.site_key
      AND this_site_key = nrsp.site_key);
  deb('cleanupNRS - updated ' || sql%rowcount || ' rows to LONG_TERM = YES');
 
--
  UPDATE nrsp SET LONG_TERM = 'NO'
  WHERE long_term IS NULL
   AND this_site_key = site_key;
  deb('cleanupNRS - updated ' || sql%rowcount || ' rows to LONG_TERM = NO');
 
--
--
  DELETE nrsp WHERE nrsp_recid < low_nrsp_recid
                AND long_term = 'NO'
                AND site_key = this_site_key;
  low_nrsp_recid := NULL;
  deb('cleanupNRS - deleted ' || sql%rowcount || ' rows from nrsp table');
  deb('cleanupNRS - took ' || ((sysdate - start_time) * 86400) || ' seconds');
END;
 
PROCEDURE updateOldestFlashbackSCN (
   oldest_flashback_scn     IN NUMBER -- obsolete column
  ,oldest_flashback_time    IN DATE   DEFAULT NULL
) IS
  tmp    NUMBER;
BEGIN
 
   deb('updateOldestFlashbackSCN - guaranteed_flashback_scn=' ||
       nvl(to_char(oldest_flashback_scn), 'NULL') || ' flashback_time=' ||
       nvl(to_char(oldest_flashback_time), 'NULL'));
 
--
   IF (oldest_flashback_scn IS NULL AND oldest_flashback_time IS NULL) THEN
      DELETE FROM fb
       WHERE db_unique_name = this_db_unique_name
         AND dbinc_key      = this_dbinc_key;
      RETURN;
   END IF;
 
   BEGIN
      SELECT 0 INTO tmp
        FROM fb
       WHERE db_unique_name = this_db_unique_name
         AND dbinc_key      = this_dbinc_key;
   EXCEPTION
      WHEN no_data_found THEN
         INSERT INTO fb
            (dbinc_key, db_unique_name, oldest_flashback_scn,
             oldest_flashback_time)
         VALUES
            (this_dbinc_key, this_db_unique_name, oldest_flashback_scn,
             oldest_flashback_time);
         RETURN;
      WHEN others THEN
         RAISE;
   END;
 
   UPDATE fb SET
     oldest_flashback_scn =
        updateOldestFlashbackSCN.oldest_flashback_scn,
     oldest_flashback_time =
        updateOldestFlashbackSCN.oldest_flashback_time
   WHERE db_unique_name = this_db_unique_name
     AND dbinc_key      = this_dbinc_key;
END updateOldestFlashbackSCN;
 
FUNCTION getDbinc RETURN NUMBER IS
BEGIN
  IF (this_dbinc_key IS NULL) THEN
    raise_application_error(-20020, 'Database incarnation not set');
  END IF;
 
  RETURN this_dbinc_key;
END getDbinc;
 
--
--
--
FUNCTION isDuplicateRecord(recid    IN NUMBER
                          ,stamp    IN NUMBER
                          ,type     IN VARCHAR2) RETURN BOOLEAN IS
  rec_count NUMBER;
BEGIN
   checkResync;
 
   IF (type = 'AL') THEN
      SELECT count(*)
        INTO rec_count
        FROM al, dbinc
       WHERE dbinc.db_key = this_db_key
         AND al.dbinc_key = dbinc.dbinc_key
         AND isDuplicateRecord.recid = al.al_recid
         AND isDuplicateRecord.stamp = al.al_stamp
         AND al.site_key = this_site_key;
   ELSIF (type = 'BP') THEN
      SELECT count(*)
        INTO rec_count
        FROM bp
       WHERE bp.db_key = this_db_key
         AND isDuplicateRecord.recid = bp.bp_recid
         AND isDuplicateRecord.stamp = bp.bp_stamp
         AND bp.site_key = this_site_key;
   ELSIF (type = 'DC') THEN
      SELECT count(*)
        INTO rec_count 
        FROM cdf, dbinc
       WHERE dbinc.db_key = this_db_key
         AND cdf.dbinc_key = dbinc.dbinc_key
         AND isDuplicateRecord.recid = cdf.cdf_recid
         AND isDuplicateRecord.stamp = cdf.cdf_stamp
         AND cdf.site_key = this_site_key;
 
      IF (rec_count = 0) THEN
         SELECT count(*)
           INTO rec_count 
           FROM ccf, dbinc
          WHERE dbinc.db_key = this_db_key
            AND ccf.dbinc_key = dbinc.dbinc_key
            AND isDuplicateRecord.recid = ccf.ccf_recid
            AND isDuplicateRecord.stamp = ccf.ccf_stamp
            AND ccf.site_key = this_site_key;
      END IF;
   ELSE
      raise_application_error(-20999,
         'Internal error in isDuplicateRecord(): bad type '|| type);
   END IF;
 
   IF rec_count > 0 THEN
      RETURN TRUE;
   ELSE
      RETURN FALSE;
   END IF;
END isDuplicateRecord;
 
--
--
--
--
--
--
FUNCTION doDuplicateMining RETURN BOOLEAN IS
  last_recid number;
BEGIN
  checkResync;
 
  IF (this_cf_type != 'CURRENT' and this_cf_type != 'STANDBY') THEN
     RETURN TRUE;
  END IF;
 
--
--
  IF (this_cf_type = 'STANDBY' and this_db_unique_name is NULL) THEN
     RETURN TRUE;
  END IF;
 
--
--
--
  SELECT high_rlh_recid INTO last_recid
     FROM node
     WHERE site_key = this_site_key;
 
  IF (last_recid = 0) THEN
     deb('doDuplicateMining returns TRUE');
     RETURN TRUE;
  ELSE
     RETURN FALSE;
  END IF;
 
END doDuplicateMining;
 
--
FUNCTION isRoutDuplicateRecord(recid             IN NUMBER
                              ,stamp             IN NUMBER
                              ,session_recid     IN NUMBER
                              ,session_stamp     IN NUMBER
                              ,rman_status_recid IN NUMBER
                              ,rman_status_stamp IN NUMBER)
 
  RETURN BOOLEAN IS
  lrsrkey    NUMBER;
  lroutskey  NUMBER;
  rec_count  NUMBER;
BEGIN
   checkResync;
 
    deb('isRoutDuplicateRecord - Find rsr_ key');
    BEGIN
      select rsr_key into lrsrkey from rsr, dbinc where 
             rsr.dbinc_key = dbinc.dbinc_key and
             dbinc.db_key  = this_db_key and
             dbinc.dbinc_key = this_dbinc_key and
             ((rsr.site_key = this_site_key) or
              (rsr.site_key is null AND this_site_key is null)) and
             rsr.rsr_recid = rman_status_recid and
             rsr.rsr_stamp = rman_status_stamp;
    EXCEPTION
    WHEN no_data_found THEN
--
      deb('isRoutDuplicateRecord - ignoring following RMAN output row');
      RETURN FALSE;
    END;
 
 
    deb('isRoutDuplicateRecord - Find session key');
    BEGIN
--
--
--
--
--
      select rsr_key into lroutskey from rsr, dbinc where
             rsr.dbinc_key  = dbinc.dbinc_key and
             dbinc.db_key   = this_db_key and
             (rsr.site_key = this_site_key or
              rsr.site_key is null AND this_site_key is null) and
             rsr.rsr_srecid = session_recid and
             rsr.rsr_sstamp = session_stamp and
             rsr.rsr_type   = 'SESSION';
    EXCEPTION
    WHEN no_data_found THEN
--
      deb('isRoutDuplicateRecord -ignoring following RMAN output row, cause2');
      RETURN FALSE;
    WHEN others THEN
      deb('isRoutDuplicateRecord(DO_NOT_IGNORE) - signal err');
      RETURN FALSE;
    END;
 
--
   SELECT count(*)
     INTO rec_count
     FROM rout, db
    WHERE db.db_key = this_db_key
      AND rout.rout_recid = isRoutDuplicateRecord.recid
      AND rout.rout_stamp = isRoutDuplicateRecord.stamp
      AND rout.rsr_key    = lrsrkey
      AND rout.rout_skey  = lroutskey
      AND rout.site_key = this_site_key;
 
   IF rec_count > 0 THEN
    deb('isRoutDuplicateRecord - Return TRUE');
      RETURN TRUE;
   ELSE
    deb('isRoutDuplicateRecord - Return FALSE');
      RETURN FALSE;
   END IF;
END isRoutDuplicateRecord;
 
PROCEDURE unregisterSite(db_unique_name IN VARCHAR2,
                         incbcks        IN BINARY_INTEGER ) IS
 
  lsite_key        number;
  new_ckp_site_key number;
  cnt              number := 0;
  db_role          node.database_role%TYPE;
 
BEGIN
 
   deb('unregisterSite - remove meta-data for node '|| db_unique_name);
 
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'Database not set');
   END IF;
 
--
   IF this_db_unique_name = upper(db_unique_name) THEN
      raise_application_error(-20244,
                              db_unique_name || 
                              ' can not unregister connected target database');
   END IF;
 
--
   BEGIN
      select site_key, database_role into lsite_key, db_role from node 
         where node.db_unique_name = upper(unregisterSite.db_unique_name)
           and node.db_key = this_db_key;
 
   EXCEPTION
      WHEN no_data_found THEN
         raise_application_error(
                             -20243,
                             upper(unregisterSite.db_unique_name) || 
                             ' db_unique_name unknown to recovery catalog:');
   END;
   lockForCkpt;
 
--
--
   select count(*) into cnt from bp
      where bp.site_key = lsite_key and bp.ba_access != 'U';
 
   IF (cnt <> 0) THEN
     cancelCkpt;
     raise_application_error(-20301, 'Cannot unregister database');
   END IF;
  
--
--
--
--
   select site_key into new_ckp_site_key from 
      (select site_key from node
         where db_key=this_db_key
           and site_key <> lsite_key
         order by database_role)
      where rownum = 1;
   IF new_ckp_site_key is not null THEN
      update ckp set site_key = new_ckp_site_key 
         where site_key = lsite_key
           and ckp_type = 'FULL'
           and ckp_key in
               (select start_ckp_key from tsatt 
                  where dbinc_key in 
                     (select dbinc_key from dbinc
                         where db_key=this_db_key)
                union
                select end_ckp_key from tsatt 
                  where dbinc_key in 
                     (select dbinc_key from dbinc
                         where db_key=this_db_key));
      deb('updated ' || sql%rowcount || ' rows in ckp, site_key to ' || 
          new_ckp_site_key);
   END IF;
 
--
   IF incbcks <> 0 THEN
      delete bp WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from bp table');
      delete bs WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from bs table');
      delete ccf WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from ccf table');
      delete xcf WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from xcf table');
      delete cdf WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from cdf table');
      delete xdf WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from xdf table');
      delete xal WHERE site_key = lsite_key;
      deb('deleted ' || sql%rowcount || ' rows from xal table');
   ELSE
      update bp set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from bp table');
      update bs set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from bs table');
      update ccf set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from ccf table');
      update xcf set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from xcf table');
      update cdf set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from cdf table');
      update xdf set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from xdf table');
      update xal set site_key = NULL WHERE site_key = lsite_key;
      deb('updated ' || sql%rowcount || ' rows from xal table');
   END IF;
 
--
   delete node where site_key = lsite_key;
   deb('deleted ' || sql%rowcount || ' rows from node table');
   delete fb
      where db_unique_name = unregisterSite.db_unique_name 
        and dbinc_key in 
            (select dbinc_key from dbinc where db_key = this_db_key);
   deb('deleted ' || sql%rowcount || ' rows from fb table');
 
  UPDATE db
    SET reg_db_unique_name =
      (SELECT max(db_unique_name) FROM
         (SELECT db_unique_name 
          FROM node, db
          WHERE node.db_key = this_db_key
            AND node.db_unique_name <> unRegisterSite.db_unique_name
            AND node.db_unique_name <> db.reg_db_unique_name
            AND node.db_unique_name NOT LIKE '%$%'
            AND node.database_role IN ('PRIMARY','STANDBY')
          ORDER BY node.database_role, node.db_unique_name)
          WHERE ROWNUM =1)
	WHERE db_key = this_db_key
	  AND reg_db_unique_name = unregisterSite.db_unique_name;
 
--
--
--
   delete conf 
     where name = 'DB_UNIQUE_NAME' 
       and db_key = this_db_key 
       and upper(unregisterSite.db_unique_name) =
           upper(substr(value, 2, instr(substr(value, 2, 32), 
                                               substr(value, 1,1))-1))
       and db_unique_name is null;
   deb('deleted ' || sql%rowcount || ' rows from conf table(2)');
 
--
--
   if sql%rowcount <> 0 then
      update node set force_resync2cf = 'YES'
         where db_key = this_db_key;
   end if;
 
--
   delete conf where site_key = lsite_key;
   deb('deleted ' || sql%rowcount || ' rows from conf table (site rows)');
   commitChanges('unregisterSite');
 
END unregisterSite;
 
--
PROCEDURE renameSite(from_db_unique_name IN VARCHAR2, 
                     to_db_unique_name IN VARCHAR2) IS
   rec_count NUMBER;
   my_dbinc_key NUMBER;
BEGIN
   deb('renameSite - rename meta-data from '|| from_db_unique_name ||
       ' to ' || to_db_unique_name);
 
--
   IF this_db_key IS NULL THEN
      BEGIN
         SELECT curr_dbinc_key into my_dbinc_key FROM db
         WHERE db_key = (SELECT db_key FROM node where
                            db_unique_name = upper(from_db_unique_name));
         setDatabase(my_dbinc_key);
      EXCEPTION
         WHEN no_data_found THEN
            raise_application_error(-20243,
                                    from_db_unique_name || 
                                    ' site unknown to recovery catalog:');
      END;
   END IF;
 
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'Database not set');
   END IF;
 
--
   IF this_db_unique_name = upper(from_db_unique_name) THEN
      raise_application_error(-20244,
                              from_db_unique_name || 
                              ' can not rename connected target database');
   END IF;
 
--
   SELECT count(*) INTO rec_count FROM node 
      WHERE node.db_unique_name = upper(from_db_unique_name) 
        AND node.db_key = this_db_key;
 
   IF rec_count = 0 THEN
      raise_application_error(-20243,
                              from_db_unique_name || 
                              ' site unknown to recovery catalog:');
   END IF;
 
--
   SELECT count(*) INTO rec_count FROM node 
      WHERE node.db_unique_name = upper(to_db_unique_name) 
        AND node.db_key = this_db_key;
 
   IF rec_count = 1 THEN
      raise_application_error(-20246,
                              to_db_unique_name || 
                              ' site known to recovery catalog:');
   END IF;
 
   UPDATE NODE SET db_unique_name = upper(to_db_unique_name)
      WHERE db_unique_name = upper(from_db_unique_name)
        AND db_key = this_db_key;
   deb('renamed db_unique_name ' || sql%rowcount || ' row updated');
 
   UPDATE CONF SET db_unique_name = upper(to_db_unique_name)
      WHERE db_unique_name = upper(from_db_unique_name)
        AND db_key = this_db_key;
   deb('updated ' || sql%rowcount || ' rows in conf table');
 
--
   UPDATE FB SET db_unique_name = upper(to_db_unique_name)
      WHERE db_unique_name = upper(from_db_unique_name)
        AND dbinc_key IN 
            (select dbinc_key from dbinc where db_key = this_db_key);
   deb('updated ' || sql%rowcount || ' rows in fb table');
 
   commitChanges('renameSite');
 
END renameSite;
 
--
--
 
PROCEDURE resyncAddDBUname(cdbunstr IN varchar2) IS
     dbuname    node.db_unique_name%TYPE;
     numentries number;
 
  BEGIN
--
--
--
--
--
--
--
--
--
--
--
    deb('resyncAddDBUname - cdbunstr = '|| cdbunstr);
    dbuname := substr(cdbunstr, 2, 30); -- strip out the first quote
--
--
    deb('resyncAddDBUname - dbuname before = '|| dbuname);
    dbuname := substr(dbuname, 1, instr(dbuname, substr(cdbunstr,1,1))-1);
 
    deb('resyncAddDBUname - db_unique_name = '|| dbuname);
 
--
--
    insert into node (db_unique_name, db_key, force_resync2cf, 
                      database_role, site_key)
    values(upper(dbuname), this_db_key, 'YES', 'STANDBY', rman_seq.nextval);
 
    deb('resyncAddDBUname - adding node row with value ' || dbuname);
 
EXCEPTION
   WHEN dup_val_on_index THEN
--
     RETURN;
 
END resyncAddDBUname;
 
 
--
FUNCTION getThisSiteKey(db_unique_name in VARCHAR2 DEFAULT NULL) 
   return NUMBER
IS
   ret_site_key number;
BEGIN
   deb('getThisSiteKey - This site key is '||this_site_key);
   if db_unique_name is not null then
      ret_site_key := dbms_rcvman.getSiteKey(db_unique_name);
   else
      ret_site_key := this_site_key;
   end if;
   deb('Returning site key is '||ret_site_key);
   return ret_site_key;
END getThisSiteKey;
 
--
FUNCTION  isAMSchema RETURN BOOLEAN IS
BEGIN
   return this_is_ors;
END isAMSchema;
 
--
FUNCTION  getAMTstlevel RETURN NUMBER IS
   am_tst_level number := 0;
BEGIN
   if this_is_ors then
      select nvl(max(value), 0) into am_tst_level from config 
         where name = '_oam_tst_level';
      deb('getAMTstlevel from config ='||am_tst_level);
   else
      deb('getAMTstlevel='||am_tst_level||' for non-OAM schema');
   end if;
   return am_tst_level;
END getAMTstlevel;
 
PROCEDURE enableResyncActions IS
BEGIN
   deb('enableResyncActions - resync action tracing enabled');
   doResyncReasons := TRUE;
END enableResyncActions;
 
PROCEDURE setReason(reason IN number, forceSet IN boolean default FALSE) IS
BEGIN
   IF doResyncReasons THEN
--
--
      IF resync_reason = RESYNC_REASON_NONE OR forceSet THEN
         resync_reason := reason;
         deb('setReason - resync_reason: '||to_char(resync_reason));
      END IF;
   ELSE
      resync_reason := RESYNC_REASON_NOACTION;
   END IF;
END setReason;
 
FUNCTION getReason RETURN number IS
BEGIN
   IF doResyncReasons THEN
      deb('getReason - resync_reason: '||to_char(resync_reason));
      RETURN resync_reason;
   ELSE
      RETURN RESYNC_REASON_NOACTION;
   END IF;
END getReason;
 
PROCEDURE incResyncActions(action      IN number,
                           objno       IN number,
                           objname     IN varchar2) IS
BEGIN
   IF not doResyncReasons THEN
      deb('incResynActions - Not debugging');
      RETURN;
   END IF;
 
   BEGIN
      deb('incResynActions - for action: '||to_char(action)||' objno '||
          nvl(to_char(objno), 'IS NULL')||' objname '||nvl(objname, 'IS NULL'),
          RCVCAT_LEVEL_HI);
      IF debOK(RCVCAT_LEVEL_HI) THEN
         dumpResyncActions;
      END IF;
      IF not fullResyncAction.active THEN
         RETURN;
      END IF;
      IF objno is NOT NULL THEN
         IF fullResyncAction.lastobjno = objno THEN
            IF fullResyncAction.actTaken(action) THEN
--
               deb('incResyncActions - '||
                   RESYNC_ACTION_OBJECTS(fullResyncAction.objtype)||' '||
                   to_char(objno)||' already '||
                   RESYNC_ACTION_NAMES(action), RCVCAT_LEVEL_HI);
               RETURN;
            ELSE
               fullResyncAction.actTaken(action) := TRUE;
            END IF;
         ELSE
--
            fullResyncAction.lastobjno := objno;
            fullResyncAction.actTaken  := 
                resyncActionTaken_t(FALSE, FALSE, FALSE, 
                                    FALSE, FALSE, FALSE);
            fullResyncAction.actTaken(action) := TRUE;
         END IF;
      END IF;
 
      fullResyncAction.actCount(action) := fullResyncAction.actCount(action) + 1;
      fullResyncAction.valid := TRUE;
      IF objno is NOT NULL THEN
         IF objname is NOT NULL THEN
            deb('incResyncActions - '||
                RESYNC_ACTION_OBJECTS(fullResyncAction.objtype)||' '||
                objname||'('||to_char(objno)||') '||
                RESYNC_ACTION_NAMES(action), RCVCAT_LEVEL_HI);
         ELSE
            deb('incResyncActions - '||
                RESYNC_ACTION_OBJECTS(fullResyncAction.objtype)||' '||
                to_char(objno)||' '|| RESYNC_ACTION_NAMES(action), 
                RCVCAT_LEVEL_HI);
         END IF;
      ELSE
         deb('incResyncActions - '||
             RESYNC_ACTION_OBJECTS(fullResyncAction.objtype)||' '||
             to_char(objname)||' '|| RESYNC_ACTION_NAMES(action),
             RCVCAT_LEVEL_HI);
      END IF;
      deb('incResyncActions - Exiting', RCVCAT_LEVEL_HI);
   EXCEPTION
      WHEN others THEN
         deb('incResyncActions(DO_NOT_IGNORE) - caught exception '||
             substr(sqlerrm, 1, 132) || ' for '||
             to_char(action) || ' objno ' || nvl(to_char(objno), 'IS NULL') ||
             ' objname ' || nvl(objname, 'IS NULL'));
   END;
END incResyncActions;
 
PROCEDURE dumpResyncActions IS
   i   number;
BEGIN
   IF not doResyncReasons OR not debOK(RCVCAT_LEVEL_HI) THEN
      RETURN;
   END IF;
 
   deb('dumpResyncActions - resync_reason: '||to_char(nvl(resync_reason, -1)));
 
   IF resync_reason = RESYNC_REASON_NOACTION THEN
      RETURN;
   END IF;
 
   IF fullResyncAction.active THEN
      deb('dumpResyncActions - Container is active');
   ELSE
      deb('dumpResyncActions - Container is NOT active');
   END IF;
   IF fullResyncAction.valid THEN
      deb('dumpResyncActions - Container is valid');
   ELSE
      deb('dumpResyncActions - Container is NOT valid');
   END IF;
   IF fullResyncAction.objtype IS NOT NULL THEN
      deb('dumpResyncActions - objtype: '||
          RESYNC_ACTION_OBJECTS(fullResyncAction.objtype));
   ELSE
      deb('dumpResyncActions - objtype is NULL');
   END IF;
   IF fullResyncAction.lastobjno IS NOT NULL THEN
      deb('dumpResyncActions - lastobjno: '||
          to_char(fullResyncAction.lastobjno));
   ELSE
      deb('dumpResyncActions - lastobjno is NULL');
   END IF;
 
   FOR i IN 1..6 LOOP
      IF fullResyncAction.actTaken(i) THEN
         deb('dumpResyncActions - '||RESYNC_ACTION_NAMES(i)||' TRUE - '||
             fullResyncAction.actCount(i));
      ELSE
         deb('dumpResyncActions - '||RESYNC_ACTION_NAMES(i)||' FALSE - '||
             fullResyncAction.actCount(i));
      END IF;
   END LOOP;
END dumpResyncActions;
 
PROCEDURE getResyncActions(valid      OUT boolean
                           ,added     OUT number
                           ,dropped   OUT number
                           ,changed   OUT number
                           ,recreated OUT number
                           ,renamed   OUT number
                           ,resized   OUT number) IS                        
BEGIN
   IF doResyncReasons THEN
      IF debOK(RCVCAT_LEVEL_HI) THEN
         deb('getResyncActions - called', RCVCAT_LEVEL_HI);
         dumpResyncActions;
      END IF;
      fullResyncAction.active := FALSE;
      valid  := fullResyncAction.valid;
      fullResyncAction.valid := FALSE;
      added     := fullResyncAction.actCount(RESYNC_ACTION_ADD);
      dropped   := fullResyncAction.actCount(RESYNC_ACTION_DROP);
      changed   := fullResyncAction.actCount(RESYNC_ACTION_CHANGE);
      recreated := fullResyncAction.actCount(RESYNC_ACTION_RECREATE);
      renamed   := fullResyncAction.actCount(RESYNC_ACTION_RENAME);
      resized   := fullResyncAction.actCount(RESYNC_ACTION_RESIZE);
      setReason(RESYNC_REASON_NONE, TRUE);
   ELSE
      setReason(RESYNC_REASON_NOACTION, TRUE);
   END IF;
END getResyncActions;
 
PROCEDURE clearResyncActions IS
BEGIN
   fullResyncAction.active    := FALSE;
   fullResyncAction.valid     := FALSE;
   fullResyncAction.lastobjno := -1;
   fullResyncAction.objtype   := NULL;
   fullResyncAction.actTaken  := resyncActionTaken_t(FALSE, FALSE, FALSE, 
                                                     FALSE, FALSE, FALSE);
   fullResyncAction.actCount  := resyncActionCounts_t(0, 0, 0, 0, 0, 0);
   dumpResyncActions;
END clearResyncActions;
 
 
/*-------------------------------------------------*
 * Private functions for import catalog processing *
 *-------------------------------------------------*/
--
--
--
--
--
--
PROCEDURE adjustRmanSeq
IS
  currval                          NUMBER;
  newval                           NUMBER;
  incseq                           NUMBER;
BEGIN
  LOOP
    SELECT rman_seq.nextval
      INTO currval
      FROM dual;
 
    EXECUTE IMMEDIATE
      'SELECT rman_seq.nextval@'
    || dbms_assert.qualified_sql_name(import_dblink)
    || ' FROM dual'
      INTO incseq;
 
    EXECUTE IMMEDIATE
    'ALTER SEQUENCE rman_seq INCREMENT BY ' || incseq;
 
    SELECT rman_seq.nextval - incseq
      INTO import_offset
      FROM dual;
 
    EXECUTE IMMEDIATE
    'ALTER SEQUENCE rman_seq INCREMENT BY 1';
 
--
--
--
--
    EXIT WHEN (import_offset >= currval); 
  END LOOP;
END adjustRmanSeq;
 
--
--
--
--
--
--
--
FUNCTION isColumnASeq(
  column_name                      IN VARCHAR2
)
RETURN BOOLEAN
IS
BEGIN
  IF (column_name LIKE '%KEY')
  THEN
    FOR i in 1..key_columns.COUNT
    LOOP
      IF (key_columns(i) = column_name)
      THEN
        RETURN TRUE;
      END IF;
    END LOOP;
 
--
--
--
--
    RAISE_APPLICATION_ERROR(-20999, 'Internal error in ' ||
                            'isColumnASeq(): bad column '|| column_name);
  END IF;
  RETURN FALSE;
END isColumnASeq; 
 
--
--
--
--
--
--
--
FUNCTION getColumnName(
  table_name                       IN VARCHAR2
, offset                           IN NUMBER DEFAULT NULL
)
RETURN VARCHAR2
IS
  v_table                          user_objects.object_name%TYPE;
  v_column                         VARCHAR2(1024);
  isaseq                           BOOLEAN;
 
  CURSOR column_c(tname VARCHAR2)
  IS
    SELECT column_name, data_type
      FROM user_tab_columns
     WHERE table_name = tname
     ORDER BY column_name;
 
  FUNCTION add_comma (
    v_column                       IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    IF (v_column IS NULL)
    THEN
      RETURN NULL;
    ELSE
      RETURN ',';
    END IF;
  END add_comma;
 
  FUNCTION add_offset(
    offset                         IN NUMBER
  , data_type                      IN VARCHAR2
  , column_name                    IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    IF (offset IS NULL)
    THEN
      RETURN NULL;
    END IF;
    IF (data_type = 'NUMBER' AND isColumnASeq(column_name))
    THEN
      RETURN '+' || offset;
    END IF;
    RETURN null;
  END add_offset;
BEGIN
  SELECT object_name
    INTO v_table
    FROM user_objects
   WHERE object_name = UPPER(table_name)
     AND object_type = 'TABLE';
 
--
  FOR cRec in column_c(v_table)
  LOOP
    v_column := v_column
             || add_comma(v_column)
             || dbms_assert.simple_sql_name(table_name)
             || '.'
             || dbms_assert.simple_sql_name(cRec.column_name)
             || add_offset(offset, cRec.data_type, cRec.column_name);
  END LOOP;
  RETURN v_column;
END getColumnName;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE importTable (
  table_name                       IN VARCHAR2
, from_table                       IN ts_name_list
, uniq_rows                        IN BOOLEAN
, where_clause                     IN VARCHAR2
)
IS
  insert_columns                   VARCHAR2(2048);
  from_columns                     VARCHAR2(2048);
  source_table                     VARCHAR2(2048);
  uniq_keyword                     VARCHAR2(8);
  start_time                       DATE;
BEGIN
  deb('Entering importTable table=' || table_name);
  insert_columns := getColumnName(table_name);
  from_columns   := getColumnName(table_name, import_offset);
  source_table   := dbms_assert.qualified_sql_name(
                      table_name || '@' || import_dblink
                    );
  FOR i IN 1..from_table.COUNT
  LOOP
    source_table := source_table
                 || ','
                 || dbms_assert.qualified_sql_name(
                      from_table(i) || '@' || import_dblink
                    );
  END LOOP;
 
  IF (uniq_rows)
  THEN
    uniq_keyword := 'DISTINCT';
  END IF;
--
--
--
--
--
--
--
--
  start_time := SYSDATE;
  EXECUTE IMMEDIATE
     'INSERT INTO '
  || dbms_assert.qualified_sql_name(table_name)
  || '('
  || insert_columns
  || ')'
  || 'SELECT ' || uniq_keyword || ' ' || from_columns
  || '  FROM ' || source_table
  || ' '
  || where_clause;
 
  deb('imported rows = ' || SQL%ROWCOUNT);
  deb('importTable took ' || ((SYSDATE - start_time) * 86400) || ' seconds');
  deb('Finished importTable table=' || table_name);
END importTable;
 
--
--
--
--
--
--
--
--
PROCEDURE registerImportDb (
  idb                              IN VARCHAR2
, idbinc                           IN VARCHAR2
)
IS
  TYPE cur_typ IS ref CURSOR;
  update_c                         cur_typ;
  from_table                       ts_name_list;
  from_columns                     VARCHAR2(2048);
  currkeys                         numTab_t;
  dbids                            numTab_t;
  dbkeys                           numTab_t;
  reg_dbuname                      key_columns_list;
  strg_prov                        sp_columns_list;
BEGIN
  deb('Entering registerImportDb');
  from_columns := getColumnName('db', import_offset);
 
--
--
--
--
--
--
--
--
  EXECUTE IMMEDIATE
     'INSERT INTO db (db.db_key, db.db_id)'
  || 'SELECT db.db_key + ' || import_offset
  || '     , db.db_id'
  || '  FROM db@' ||  dbms_assert.qualified_sql_name(import_dblink)
  || '    ,' || dbms_assert.qualified_sql_name(idb || '@' || import_dblink)
  || ' WHERE db.db_key = '
  || dbms_assert.simple_sql_name(idb) || '.db_key';
 
  deb('Total db imported = ' || SQL%ROWCOUNT);
 
--
  from_table.DELETE;
  from_table(1) := idbinc;
  importTable (
    table_name   => 'dbinc'
  , from_table   => from_table
  , uniq_rows    => FALSE
  , where_clause => 'WHERE dbinc.dbinc_key = '
                 || idbinc || '.dbinc_key'
  );
 
--
--
  OPEN update_c FOR
--
--
--
--
--
--
--
  'SELECT ' || from_columns || 
  '  FROM db@' || dbms_assert.qualified_sql_name(import_dblink)
               || ','
               || dbms_assert.qualified_sql_name(idb || '@' || import_dblink)
               ||
  ' WHERE db.db_key = ' || dbms_assert.simple_sql_name(idb) || '.db_key';
  FETCH update_c BULK COLLECT INTO currkeys, dbids, dbkeys, reg_dbuname, 
                                   strg_prov;
  CLOSE update_c;
 
--
  FORALL i IN 1..dbids.COUNT
   UPDATE db
      SET curr_dbinc_key = currkeys(i)
        , reg_db_unique_name = reg_dbuname(i)
        , storage_prov = strg_prov(i)
    WHERE db.db_key = dbkeys(i);
 
  deb('Finished registerImportDb');
EXCEPTION
  WHEN DUP_VAL_ON_INDEX
  THEN RAISE_APPLICATION_ERROR(-20512, 'Database already registered');
END registerImportDb;
 
--
--
--
--
--
--
--
--
PROCEDURE dropTempResource (
  name                             IN VARCHAR2
, data_type                        IN VARCHAR2
)
IS
  e_dblink_not_found               EXCEPTION;
  e_dblink_not_open                EXCEPTION;
  e_resource_not_found             EXCEPTION;
  e_table_not_found                EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_dblink_not_found, -2024);
  PRAGMA EXCEPTION_INIT(e_dblink_not_open, -2081);
  PRAGMA EXCEPTION_INIT(e_resource_not_found, -20509);
  PRAGMA EXCEPTION_INIT(e_table_not_found, -942);
BEGIN
  deb('Entering dropTempResource name = ' || name ||
      ' , data_type = '|| data_type);
  commitChanges('dropTempResource');
 
--
  IF (NOT lockTempResource(name, data_type))
  THEN
    deb('Finished dropTempResource - resource busy');
    RETURN;
  END IF;
 
  IF (data_type = 'TABLE')
  THEN
    EXECUTE IMMEDIATE
      'DROP TABLE ' || dbms_assert.qualified_sql_name(name);
  ELSIF (data_type = 'DBLINK')
  THEN
    BEGIN
      EXECUTE IMMEDIATE
        'ALTER SESSION CLOSE DATABASE LINK '
      || dbms_assert.qualified_sql_name(name);
    EXCEPTION
      WHEN e_dblink_not_open
      THEN NULL;
    END;
    EXECUTE IMMEDIATE
      'DROP DATABASE LINK '
    || dbms_assert.qualified_sql_name(name);
  END IF;
 
--
  DELETE tempres
   WHERE tempres.name = dropTempResource.name;
 
  commitChanges('dropTempResource-2');
  deb('Finished dropTempResource');
EXCEPTION
  WHEN e_resource_not_found THEN
    DELETE FROM tempres WHERE tempres.name = dropTempResource.name;
    commitChanges('dropTempResource-3');
    deb('Finished dropTempResource - resource_not_found ' || name);
  WHEN e_dblink_not_found THEN
    deb('Finished dropTempResource - dblink_not_found' || name);
  WHEN e_table_not_found THEN
    deb('Finished dropTempResource - table_not_found' || name);
  WHEN OTHERS THEN
    deb('(DO_NOT_IGNORE)caught exception during dropTempResource ' ||
         SUBSTR(SQLERRM, 1, 512));
END dropTempResource;
 
--
--
--
--
--
--
--
--
PROCEDURE importGlobalScript
IS
   type cur_typ is ref cursor;
   global_scr_c    cur_typ;
   global_scr_q    varchar2(1024);
   local           scr%rowtype;
   given_name      scr.scr_name%type;
   from_table      ts_name_list;
   from_columns   varchar2(2048);
   copycnt         number;
   unique_violated exception;
   pragma exception_init(unique_violated, -1);
BEGIN
--
   from_columns := getColumnName('scr');
   global_scr_q := 'SELECT '
                || from_columns
                || '  FROM scr@'
                || dbms_assert.qualified_sql_name(import_dblink)
                || ' WHERE db_key IS NULL';
 
   OPEN global_scr_c FOR global_scr_q;
   LOOP
      FETCH global_scr_c
       INTO local.db_key, local.scr_comment, 
            local.scr_key, local.scr_name;
      EXIT WHEN global_scr_c%NOTFOUND;
      copycnt := 0;
      given_name := local.scr_name;
<<tryagain>>
      BEGIN
--
--
--
--
--
         EXECUTE IMMEDIATE
         'INSERT INTO scr (' || from_columns || ') VALUES ' ||
         '( null,' ||
            case when local.scr_comment is not null then
               '''' || local.scr_comment || ''','
            else
               'null,'
            end ||
            local.scr_key || '+' || import_offset || ',' ||
            '''' || local.scr_name || ''')';
      EXCEPTION
         WHEN unique_violated THEN
--
            copycnt := copycnt + 1;
            IF (copycnt = 1) THEN
               local.scr_name := 'COPY OF ' || given_name;
            ELSE
               local.scr_name := 'COPY(' || copycnt || ') OF ' || given_name;
            END IF;
            goto tryagain;
      END;
   END LOOP;
 
--
   from_table.delete;
   from_table(1) := 'scr';
   importTable(table_name    => 'scrl'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where scr.db_key is null' ||
                                '  and scr.scr_key = scrl.scr_key');
END importGlobalScript;
 
/*------------------------------------------------*
 * Public functions for import catalog processing *
 *------------------------------------------------*/
--
--
--
--
--
PROCEDURE createTempResource(
   name       IN varchar2
  ,data_type  IN varchar2)
IS
   unique_violated exception;
   pragma exception_init(unique_violated ,-1);
BEGIN
--
   INSERT INTO tempres (name, data_type)
   VALUES (name, data_type);
   commitChanges('createTempResource');
EXCEPTION
   WHEN unique_violated THEN
      raise_application_error(-20508, 'resource already in use ' || name);
END createTempResource;
 
--
--
--
--
--
--
FUNCTION lockTempResource(
   name      IN varchar2
  ,data_type IN varchar2)
RETURN BOOLEAN IS
   local         tempres%ROWTYPE;
   found         number;
   resource_busy exception;
   pragma exception_init(resource_busy, -54);
BEGIN
  deb('Entering lockTempResource ' || name);
 
  SELECT name, data_type
    INTO local.name, local.data_type
    FROM tempres
   WHERE name = lockTempResource.name
     FOR UPDATE NOWAIT;
 
  IF (data_type = 'TABLE') THEN
     SELECT count(*)
       INTO found
       FROM user_tab_columns
      WHERE table_name = lockTempResource.name;
  ELSIF (data_type = 'DBLINK') THEN
     SELECT count(*)
       INTO found
       FROM user_db_links
      WHERE db_link = lockTempResource.name;
  ELSE
     raise_application_error(-20999,
        'Internal error in localTempResource(): bad data_type '|| data_type);
  END IF;
 
  IF (found = 0) THEN
     deb('Finished lockTempResource with resource not found');
     raise_application_error(-20509, 'resource not found ' || name);
  END IF;
 
  deb('Finished lockTempResource'); 
  RETURN TRUE;
EXCEPTION
  WHEN resource_busy THEN
     deb('Finished lockTempResource with resource_busy');
     RETURN FALSE;
  WHEN no_data_found THEN
     deb('Finished lockTempResource with no_data_found'); 
     RETURN FALSE;
END lockTempResource;
 
--
--
--
--
--
PROCEDURE cleanupTempResource IS
   CURSOR temp_c IS
      SELECT name, data_type
        FROM tempres;
BEGIN
   FOR tempRec in temp_c LOOP
      dropTempResource(tempRec.name, tempRec.data_type);
   END LOOP;
END cleanupTempResource;
 
--
--
--
--
--
--
--
--
PROCEDURE addDbidToImport(
   first    IN binary_integer
  ,idb      IN varchar2
  ,idbinc   IN varchar2
  ,dbid     IN number    DEFAULT NULL
  ,dbname   IN varchar2  DEFAULT NULL)
IS
   dummy       tempres.name%TYPE;
   ldbid       db.db_id%TYPE := dbid;
   dbid_exists number;
BEGIN
--
   IF (NOT lockTempResource(idb, 'TABLE')) THEN
      raise_application_error(-20508, 'resource already in use ' || idb);
   ELSIF (NOT lockTempResource(idbinc, 'TABLE')) THEN
      raise_application_error(-20508, 'resource already in use ' || idbinc);
   END IF;
 
   IF (dbid IS NULL AND dbname IS NULL) THEN
      EXECUTE IMMEDIATE
      'INSERT INTO ' || idb || '(db_key, db_id) ' ||
      '(SELECT db_key, db_id FROM db)';
 
      IF (sql%rowcount = 0) THEN
         raise_application_error(-20510, 'import database not found');
      END IF;
 
      EXECUTE IMMEDIATE
      'INSERT INTO ' || idbinc || '(dbinc_key) ' ||
      '(SELECT dbinc_key ' ||
      '   FROM dbinc, ' || idb ||
      '  WHERE dbinc.db_key = ' || idb ||'.db_key)'; 
      commitChanges('addDbidToImport');
      RETURN;
   ELSIF (dbname IS NOT NULL) THEN
      BEGIN
         SELECT db.db_id
           INTO ldbid
           FROM db, dbinc
          WHERE db.curr_dbinc_key = dbinc.dbinc_key
            AND dbinc.db_name = upper(addDbidtoImport.dbname);
      EXCEPTION
         WHEN no_data_found THEN
           raise_application_error(-20510, 'import database not found');
         WHEN too_many_rows THEN
           raise_application_error(-20511, 'import database name is ambiguous');
      END;
   ELSE
      BEGIN
         SELECT db.db_id
           INTO ldbid
           FROM db
          WHERE db.db_id = ldbid;
      EXCEPTION
         WHEN no_data_found THEN
           raise_application_error(-20510, 'import database not found');
      END;
   END IF;
 
--
--
   IF (first = 0) THEN
      FOR i in 1..import_dbid.count LOOP
         EXECUTE IMMEDIATE
            'SELECT count(*) FROM ' || idb ||
            ' WHERE ' || idb || '.db_id =' || import_dbid(i)
            INTO dbid_exists;
         IF (dbid_exists != 1) THEN
            raise_application_error(-20508, 'resource already in use ' || idb);
         END IF;
      END LOOP;
 
      EXECUTE IMMEDIATE
         'SELECT count(*) FROM ' || idb INTO dbid_exists;
      IF (dbid_exists != import_dbid.count) THEN
         raise_application_error(-20508, 'resource already in use ' || idb);
      END IF;
      import_dbid(import_dbid.count + 1) := ldbid;
   ELSE
      import_dbid.delete;
      import_dbid(1) := ldbid;
   END IF;
 
   EXECUTE IMMEDIATE
   'INSERT INTO ' || idb || '(db_key, db_id) ' ||
   '(SELECT db_key, db_id FROM db ' ||
   '  WHERE db_id = ' || ldbid || ')';
 
   EXECUTE IMMEDIATE
   'INSERT INTO ' || idbinc || '(dbinc_key) ' ||
   '(SELECT dbinc_key ' ||
   '    FROM dbinc, ' || idb ||
   '  WHERE dbinc.db_key = ' || idb || '.db_key ' ||
   '    AND ' || idb || '.db_id = ' || ldbid || ')'; 
 
   commitChanges('addDbidToImport-2');
 
--
   IF (NOT lockTempResource(idb, 'TABLE')) THEN
      raise_application_error(-20508, 'resource already in use ' || idb);
   ELSIF (NOT lockTempResource(idbinc, 'TABLE')) THEN
      raise_application_error(-20508, 'resource already in use ' || idbinc);
   END IF;
END addDbidToImport;
 
--
--
--
--
--
--
--
PROCEDURE lockDbidToImport(
   idb   IN varchar2)
IS
   TYPE cur_typ IS ref CURSOR;
   idb_c           cur_typ;
   idb_q           varchar2(512);
   local_db_key    db.db_key%TYPE;
   local_db_id     db.db_key%TYPE;
BEGIN
   idb_q := 'SELECT db_key FROM ' || idb;
   OPEN idb_c FOR idb_q;
   LOOP
      FETCH idb_c INTO local_db_key; 
      EXIT WHEN idb_c%NOTFOUND;
      SELECT db_id INTO local_db_id
        FROM db
       WHERE db.db_key = local_db_key
         FOR UPDATE OF db.db_key;
   END LOOP;
END lockDbidToImport;
 
--
--
--
--
--
--
PROCEDURE importSchema(
   dblink  IN varchar2
  ,idb     IN varchar2
  ,idbinc  IN varchar2)
IS
   from_table     ts_name_list;
BEGIN
   import_dblink := dblink;
   adjustRmanSeq;
   registerImportDb(idb, idbinc);
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'pdb'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where pdb.db_key = ' ||
                                idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   from_table(2) := 'pdb';
   importTable(table_name    => 'pdbinc'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where pdb.db_key = ' ||
                                idb || '.db_key'  ||
                                '  and pdbinc.pdb_key = pdb.pdb_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'pdb_dbinc'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where pdb_dbinc.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'conf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where conf.db_key = ' || idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'node'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where node.db_key = ' || idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'ckp'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where ckp.dbinc_key = ' ||
                                 idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'ts'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where ts.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'tsatt'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where tsatt.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'df'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where df.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   from_table(2) := 'node';
   importTable(table_name    => 'site_dfatt'
              ,from_table    => from_table
              ,uniq_rows     => TRUE
              ,where_clause  => 'where node.db_key = ' ||
                                idb || '.db_key'  ||
                                '  and site_dfatt.site_key = node.site_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'offr'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where offr.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'tf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where tf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   from_table(2) := 'node';
   importTable(table_name    => 'site_tfatt'
              ,from_table    => from_table
              ,uniq_rows     => TRUE
              ,where_clause  => 'where node.db_key = ' ||
                                idb || '.db_key'  ||
                                '  and site_tfatt.site_key = node.site_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'rr'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where rr.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'rt'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where rt.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'orl'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where orl.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'rlh'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where rlh.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'al'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where al.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'bs'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bs.db_key = ' || idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'bp'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bp.db_key = ' || idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'bcf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bcf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'ccf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where ccf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'xcf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where xcf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'bsf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bsf.db_key = ' || idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'bdf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bdf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'cdf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where cdf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'xdf'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where xdf.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'xal'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where xal.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'brl'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where brl.dbinc_key = ' ||
                                idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   from_table(2) := 'bdf';
   importTable(table_name    => 'bcb'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bdf.bdf_key = bcb.bdf_key' ||
                                '  and bdf.dbinc_key = ' ||
                                       idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   from_table(2) := 'cdf';
   importTable(table_name    => 'ccb'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where cdf.cdf_key = ccb.cdf_key' ||
                                '  and cdf.dbinc_key = ' ||
                                       idbinc || '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'rsr'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where rsr.dbinc_key= ' ||idbinc||
                                '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'scr'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where scr.db_key = ' || idb || '.db_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   from_table(2) := 'scr';
   importTable(table_name    => 'scrl'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where scr.db_key = ' || idb || '.db_key' ||
                                '  and scr.scr_key = scrl.scr_key');
 
--
   importGlobalScript;
 
--
   from_table.delete;
   from_table(1) := idb;
   importTable(table_name    => 'rout'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where rout.db_key = ' || idb || '.db_key');
 
--
--
--
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'fb'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where fb.dbinc_key = '|| idbinc ||
                                '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'grsp'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where grsp.dbinc_key = '|| idbinc ||
                                '.dbinc_key');
 
--
   from_table.delete;
   from_table(1) := idb;
   from_table(2) := 'node';
   importTable(table_name    => 'bcr'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where bcr.site_key = node.site_key' ||
                                '  and node.db_key = ' ||
                                       idb || '.db_key');
--
   from_table.delete;
   from_table(1) := idbinc;
   importTable(table_name    => 'nrsp'
              ,from_table    => from_table
              ,uniq_rows     => FALSE
              ,where_clause  => 'where nrsp.dbinc_key = '|| idbinc ||
                                '.dbinc_key');
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
   commitChanges('importSchema');
EXCEPTION
   WHEN others THEN
      deb('importSchema - release locks');
      ROLLBACK;
      RAISE;
END importSchema;
 
--
--
--
--
--
--
PROCEDURE unregisterDatabase(
   idb   IN varchar2)
IS
   TYPE cur_typ IS ref CURSOR;
   idb_c           cur_typ;
   idb_q           varchar2(512);
   local_db_id     db.db_id%TYPE;
BEGIN
   idb_q := 'SELECT db_id FROM ' || idb;
   OPEN idb_c FOR idb_q;
   LOOP
      FETCH idb_c INTO local_db_id;
      EXIT WHEN idb_c%NOTFOUND;
      unregisterDatabase(db_id => local_db_id);
   END LOOP;
END unregisterDatabase;
 
PROCEDURE clearUnarchivedLogs IS 
BEGIN
   deb('clearUnarchivedLogs for this_db_key='||this_db_key);
   delete from al
    where archived = 'N'
      and dbinc_key in (select dbinc_key from dbinc where db_key = this_db_key);
   commitChanges('clearUnarchivedLogs');
END clearUnarchivedLogs;
 
/*----------------------------*
 * Virtual Private Catalog    *
 *----------------------------*/
 
--
--
--
--
--
--
--
--
--
--
 
FUNCTION grant_get_dbid(dbname IN varchar2) RETURN number IS
   dbid number;
   cnt  number;
BEGIN
   select max(db_id), count(*) into dbid, cnt from db join
      (select distinct db_key,db_name from dbinc) using(db_key)
      where db_name = dbname;
 
   deb('grant_get_dbid - got dbid and cnt ' || dbid || ' cnt ' ||
       cnt);
 
   if cnt = 0 then
      raise_application_error(-20018, 'database ' || dbname ||
                              ' not found in recovery catalog');
   end if;
 
   if cnt > 1 then
      raise_application_error(-20019, 'database ' || dbname ||
                              ' not unique in recovery catalog');
   end if;
 
   return dbid;
END;
 
FUNCTION get_db_numeric_uid(uname IN VARCHAR2) RETURN NUMBER IS
  numeric_uid NUMBER;
BEGIN
  SELECT user_id INTO numeric_uid FROM all_users WHERE username = uname;
  RETURN numeric_uid;
  EXCEPTION
    WHEN NO_DATA_FOUND
    THEN raise_application_error(-20022, 'user ' || uname || ' not found');
END;
 
PROCEDURE clean_old_uids IS
BEGIN
  DELETE vpc_databases
   WHERE filter_uid NOT IN (SELECT user_id FROM all_users);
  DELETE vpc_users
   WHERE filter_uid NOT IN (SELECT user_id FROM all_users);
 
--
--
 
END;
 
FUNCTION is_vpd_enabled (
  i_full_check                     BOOLEAN DEFAULT TRUE
)
RETURN BOOLEAN
IS
  l_dummy                          VARCHAR2(1);
BEGIN
--
--
  IF (this_is_ors)
  THEN
    RETURN TRUE;
  END IF;
--
--
  IF (SYS_CONTEXT('SYS_SESSION_ROLES', 'RECOVERY_CATALOG_OWNER_VPD') = 'TRUE')
  THEN
    NULL;
  ELSE
--
--
    BEGIN
      SELECT 'x'
        INTO l_dummy
        FROM session_privs
       WHERE privilege IN (
--
               'ADMINISTER DATABASE TRIGGER'
--
             , 'CREATE ANY SYNONYM', 'DROP ANY SYNONYM'
             )
      HAVING COUNT(*) = 3;
    EXCEPTION
      WHEN NO_DATA_FOUND
      THEN RETURN FALSE;
    END;
  END IF;
--
--
--
  BEGIN
    SELECT 'x'
      INTO l_dummy
      FROM all_tab_privs
     WHERE (table_schema, table_name, privilege, grantee) IN (
             ('SYS', 'DBMS_RLS', 'EXECUTE', 'RECOVERY_CATALOG_OWNER_VPD')
           , ('SYS', 'DBMS_RLS', 'EXECUTE', 'RECOVERY_CATALOG_OWNER')
           , ('SYS', 'DBMS_RLS', 'EXECUTE', g_catowner)
           )
    HAVING COUNT(*) > 0;
  EXCEPTION
    WHEN NO_DATA_FOUND
    THEN RETURN FALSE;
  END;
  IF (i_full_check)
  THEN
--
--
--
    BEGIN
      SELECT 'x'
        INTO l_dummy
        FROM user_policies
      HAVING COUNT(*) = g_vpd_required_policies;
    EXCEPTION
      WHEN NO_DATA_FOUND
      THEN RETURN FALSE;
    END;
--
    BEGIN
      SELECT 'x'
        INTO l_dummy
        FROM user_triggers
       WHERE trigger_name = 'VPC_CONTEXT_TRG';
      EXCEPTION
        WHEN NO_DATA_FOUND
        THEN RETURN FALSE;
    END;
  END IF;
  RETURN TRUE;
END;
 
PROCEDURE revoke_clean_userid (
  userid                           IN VARCHAR2
)
IS
  l_privs_remaining                NUMBER;
  l_schema                         user_users.username%TYPE;
  l_eschema                        VARCHAR2(130);
  e_no_synonym                     EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_no_synonym, -1434);
BEGIN
  assert_schema(l_schema, l_eschema, userid);
  
  DELETE vpc_users
   WHERE filter_user = userid
     AND add_new_db = 'N'
     AND NOT EXISTS (
           SELECT *
             FROM vpc_databases
            WHERE filter_user = l_schema
         );
 
  commitChanges('revoke_clean_userid');
 
  SELECT COUNT(*)
    INTO l_privs_remaining
    FROM vpc_users
   WHERE filter_user = l_schema;
 
  deb('revoke_clean_userid - commit, release locks, userid=' || l_schema ||
      ', privs_remaining=' || l_privs_remaining);
 
  IF l_privs_remaining > 0 THEN RETURN; END IF;
 
  IF (NOT this_is_ors)
  THEN
    BEGIN
      EXECUTE IMMEDIATE
        'REVOKE recovery_catalog_user FROM ' || l_eschema;
    EXCEPTION
      WHEN OTHERS
      THEN  deb('revoke_clean_userid(DO_NOT_IGNORE)');
    END;
  END IF;
  BEGIN
    EXECUTE IMMEDIATE
      'DROP SYNONYM ' || l_eschema || '."DBMS_RCVMAN"';
  EXCEPTION
    WHEN e_no_synonym
    THEN NULL;
  END;
  BEGIN
    EXECUTE IMMEDIATE
      'DROP SYNONYM ' || l_eschema || '."DBMS_RCVCAT"';
  EXCEPTION
    WHEN e_no_synonym
    THEN NULL;
  END;
END;
 
PROCEDURE do_vpc_grants (
  userid                           IN VARCHAR2
)
IS
  l_schema                         user_users.username%TYPE;
  l_eschema                        VARCHAR2(130);
BEGIN
  IF (NOT is_vpd_enabled)
  THEN
    RAISE_APPLICATION_ERROR(e_no_vpd_setup, e_no_vpd_setup_m);
  END IF;
 
  assert_schema(l_schema, l_eschema, userid);
 
  IF (NOT this_is_ors)
  THEN
    EXECUTE IMMEDIATE
      'GRANT recovery_catalog_user TO ' || l_eschema;
  END IF;
  /* While stemming from rman client PL/SQL context alter session
   * set current_schema has no effect as far as visibility to packages
   * are concerned. So the additional steps below. (bandaid)
   * Since DDL is, in general, bad activity we have to limit it
   * making sure that the synonyms are created only if they don't
   * exist.
   */
  FOR s IN (
    SELECT synonym_name
      FROM (
           SELECT 'DBMS_RCVMAN' synonym_name FROM dual
            UNION ALL
           SELECT 'DBMS_RCVCAT' FROM dual
           ) x
     WHERE NOT EXISTS (
             SELECT NULL
               FROM all_synonyms s
              WHERE s.table_owner = g_catowner
                AND s.table_name = x.synonym_name
                AND s.owner = userid
                AND s.synonym_name = x.synonym_name
           )
  )
  LOOP
    EXECUTE IMMEDIATE
      'CREATE OR REPLACE SYNONYM '
    || l_eschema   || '.' || s.synonym_name
    || ' FOR '
    || g_ecatowner || '.' || s.synonym_name;
  END LOOP;
END;
 
PROCEDURE grant_catalog(userid IN varchar2, dbname IN varchar2) IS
BEGIN
  grant_catalog(userid, grant_get_dbid(dbname));
END;
 
PROCEDURE grant_catalog(userid             IN varchar2, 
                        dbid               IN number,
                        reg_db_unique_name IN varchar2 default null) IS
   user_count  number;
   numeric_uid number;
   p_dbun      node.db_unique_name%TYPE := upper(reg_db_unique_name);
   p_dbid      number not null := dbid;
BEGIN
   clean_old_uids;
 
   do_vpc_grants(userid);
 
   SELECT COUNT(*), MAX(filter_uid) INTO user_count, numeric_uid FROM vpc_users
    WHERE filter_user = userid;
 
   if user_count = 0 then
      numeric_uid := get_db_numeric_uid(userid);
      insert into vpc_users(filter_user, filter_uid, add_new_db)
         values(userid, numeric_uid, 'N');
   end if;
 
   insert into vpc_databases
      (filter_user, filter_uid, reg_db_unique_name, db_id)
      select userid, numeric_uid, decode(dbid, 0, p_dbun, null), dbid from dual
         where not exists
            (select 1 from vpc_databases
                where filter_user = userid 
                  and ((db_id = 0 and reg_db_unique_name = p_dbun) or
                       (db_id <> 0 and db_id = dbid))
            );
   commitChanges('grant_catalog');
END;
 
PROCEDURE grant_register(userid IN varchar2) IS
   numeric_uid number := get_db_numeric_uid(userid);
BEGIN
   clean_old_uids;
 
   do_vpc_grants(userid);
 
   MERGE INTO vpc_users USING dual ON (filter_user = userid)
      WHEN MATCHED THEN UPDATE SET add_new_db = 'Y'
      WHEN NOT MATCHED THEN
         INSERT(filter_user, filter_uid,  add_new_db)
         VALUES(userid,      numeric_uid, 'Y');
 
   commitChanges('grant_register');
END;
 
PROCEDURE revoke_catalog(userid IN varchar2, dbname IN varchar2) IS
BEGIN
   revoke_catalog(userid, grant_get_dbid(dbname));
END;
 
PROCEDURE revoke_catalog(userid             IN varchar2, 
                         dbid               IN number,
                         reg_db_unique_name IN varchar2 default null) IS
   p_dbun      node.db_unique_name%TYPE := upper(reg_db_unique_name);
   p_dbid      number not null := dbid;
BEGIN
   IF (NOT is_vpd_enabled)
   THEN
     RAISE_APPLICATION_ERROR(e_no_vpd_setup, e_no_vpd_setup_m);
   END IF;
   clean_old_uids;
   deb('revoke_catalog - After clean_old_uids');
   delete from vpc_databases 
      where filter_user = userid 
        and ((dbid <> 0 and db_id = dbid) or
             (dbid = 0 and reg_db_unique_name = p_dbun));
   revoke_clean_userid(userid);
   commitChanges('revoke_catalog');
END;
 
PROCEDURE revoke_register(userid IN varchar2) IS
BEGIN
   IF (NOT is_vpd_enabled)
   THEN
     RAISE_APPLICATION_ERROR(e_no_vpd_setup, e_no_vpd_setup_m);
   END IF;
   clean_old_uids;
   update vpc_users set add_new_db='N' where filter_user=userid;
   revoke_clean_userid(userid);
   commitChanges('revoke_register');
END;
 
PROCEDURE revoke_all (
  userid                           IN VARCHAR2
)
IS
BEGIN
  clean_old_uids;
  DELETE vpc_databases WHERE filter_user = userid;
  DELETE vpc_users     WHERE filter_user = userid;
  revoke_clean_userid(userid);
  commitChanges('revoke_all');
END;
 
PROCEDURE create_virtual_catalog IS
BEGIN
  NULL;
END create_virtual_catalog;
 
PROCEDURE drop_virtual_catalog IS
BEGIN
  NULL;
END drop_virtual_catalog;
 
/*
 * New VPC based on VPD 
 * This routine is setup to be idempotent, can be called
 * again and again.
 * Input i_oper: Can be used to drop the policies on an upgrade
 * when i_oper == 0. Sets the policies when i_oper <> 0
 */
PROCEDURE setupVPD (
  i_oper                           NUMBER
)
IS
  lc_policy_str                    CONSTANT VARCHAR2(32) :=
    'dbms_rcvvpc.f_';
  lc_policy_str_passall            CONSTANT VARCHAR2(32) :=
    'dbms_rcvvpc.filter_pass_all';
  l_policy_str                     VARCHAR2(64);
  e_policy_notexists               EXCEPTION;
  PRAGMA                           EXCEPTION_INIT(e_policy_notexists, -28102);
  l_granted_to                     VARCHAR2(32) := CASE
                                                     WHEN this_is_ors
                                                     THEN 'PUBLIC'
                                                     ELSE 'recovery_catalog_user'
                                                   END;
BEGIN
--
--
--
--
--
  IF (      SYS_CONTEXT('USERENV', 'SESSION_USER') <> g_catowner
     OR NOT is_vpd_enabled(i_full_check => FALSE)
  )
  THEN
    RETURN;
  END IF;
 
  FOR i IN 1..vpd_table_list.COUNT
  LOOP
    EXECUTE IMMEDIATE 'GRANT '
                   || vtr_privs(i)
                   || ' ON '
                   || vtr_tname(i)
                   || ' TO '
                   || l_granted_to;
    IF vtr_policy_required(i)
    THEN
      BEGIN
        EXECUTE IMMEDIATE '
        BEGIN
          dbms_rls.drop_policy (
            object_schema => :1
          , object_name   => :2
          , policy_name   => :3
          );
        END;' USING g_catowner
                  , vtr_tname(i)
                  , vtr_tname(i);
      EXCEPTION
        WHEN e_policy_notexists
        THEN NULL;
      END;
 
      IF (i_oper = 0)
      THEN 
        l_policy_str := lc_policy_str_passall;
      ELSE
        l_policy_str := lc_policy_str || vtr_tname(i);
      END IF;
      
      IF (vtr_update_check(i))
      THEN
        EXECUTE IMMEDIATE '
        BEGIN
           dbms_rls.add_policy (
             object_schema   => :1
           , object_name     => :2
           , policy_name     => :3
           , function_schema => :4
           , policy_function => :5
           , policy_type     => dbms_rls.shared_context_sensitive
           , update_check    => TRUE
           );
         END;' USING g_catowner
                   , vtr_tname(i)
                   , vtr_tname(i)
                   , g_catowner
                   , l_policy_str;
      ELSE
        EXECUTE IMMEDIATE '
        BEGIN
           dbms_rls.add_policy (
             object_schema   => :1
           , object_name     => :2
           , policy_name     => :3
           , function_schema => :4
           , policy_function => :5
           , policy_type     => dbms_rls.shared_context_sensitive
           , update_check    => FALSE
           );
         END;' USING g_catowner
                   , vtr_tname(i)
                   , vtr_tname(i)
                   , g_catowner
                   , l_policy_str;
      END IF;
    END IF;
  END LOOP;
 
  FOR r IN (
    SELECT view_name
      FROM user_views
     WHERE view_name LIKE 'RC~_%' ESCAPE '~'
        OR view_name LIKE 'RCI~_%' ESCAPE '~'
        OR view_name LIKE '~_RS~_RC~_%' ESCAPE '~'
        OR view_name LIKE '~_RS~_RCI~_%' ESCAPE '~'
  )
  LOOP
    EXECUTE IMMEDIATE
      'GRANT SELECT ON '
    || dbms_assert.enquote_name(r.view_name)
    || ' TO ' || l_granted_to;
  END LOOP;
 
  IF (this_is_ors)
  THEN
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_owner TO PUBLIC';
    EXECUTE IMMEDIATE
      'CREATE OR REPLACE PUBLIC SYNONYM dbms_rai_owner FOR dbms_rai_owner';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_verifier TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_inst_addresses TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_sbt_parms TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_url TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_wallet2url TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_throttle_alloc TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_fix_error TO PUBLIC';
    EXECUTE IMMEDIATE 'GRANT EXECUTE ON dbms_rai_populate_rsr_key TO PUBLIC';
  END IF;
 
  deb('setupVPD - after adding policy and grants');
 
--
--
--
  IF (i_oper <> 0)
  THEN
    IF (this_is_ors)
    THEN
    EXECUTE IMMEDIATE REGEXP_REPLACE(q'{
CREATE OR REPLACE TRIGGER vpc_context_trg
AFTER LOGON ON DATABASE
WHEN (
  SYS_CONTEXT('USERENV', 'SESSION_USER') NOT IN (
    'SYSBACKUP', 'XDB', 'SYSMAN', 'ANONYMOUS', 'APPQOSSYS'
  , 'AUDSYS', 'CTXSYS', 'DIP'
  , 'DMSYS', 'EXFSYS', 'GSMADMIN_INTERNAL', 'GSMCATUSER'
  , 'GSMUSER' , 'MDSYS', 'ORABPEL', 'ORACLE_OCM'
  , 'ORAESB', 'ORAWSM', 'ORDPLUGINS', 'ORDSYS', 'OUTLN'
  , 'SI_INFORMTN_SCHEMA', 'SYSDG', 'SYSKM', 'TSMSYS'
  , 'WKSYS', 'WMSYS', 'XS$NULL'
  )
)
DECLARE
  l_dummy                          VARCHAR2(1);
BEGIN
--
--
--
  IF (  SYS_CONTEXT('USERENV', 'SESSION_USER') IN (
         '%o', 'SYS', 'SYSTEM', 'DBSNMP'
        )
  )
  THEN
    EXECUTE IMMEDIATE
      'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
  ELSE
--
--
    SELECT 'Y'
      INTO l_dummy
      FROM vpc_users
     WHERE filter_uid = SYS_CONTEXT('USERENV', 'SESSION_USERID');
    EXECUTE IMMEDIATE
      'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,'' CURRENT_SCHEMA = %o';
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND
  THEN -- All regular users who have access to RA catalog must
--
       IF (SYS_CONTEXT('SYS_SESSION_ROLES', 'RA_CATALOG_SELECT') = 'TRUE')
       THEN
         EXECUTE IMMEDIATE
           'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
       END IF;
END;
}', '%o', g_catowner);
    ELSE
    EXECUTE IMMEDIATE REGEXP_REPLACE(q'{
CREATE OR REPLACE TRIGGER vpc_context_trg
AFTER LOGON ON DATABASE
WHEN (
  SYS_CONTEXT('USERENV', 'SESSION_USER') NOT IN (
    '%o', 'SYS', 'SYSTEM', 'SYSBACKUP'
  , 'XDB', 'SYSMAN', 'ANONYMOUS', 'APPQOSSYS'
  , 'AUDSYS', 'CTXSYS', 'DIP'
  , 'DMSYS', 'EXFSYS', 'GSMADMIN_INTERNAL', 'GSMCATUSER'
  , 'GSMUSER' , 'MDSYS', 'ORABPEL', 'ORACLE_OCM'
  , 'ORAESB', 'ORAWSM', 'ORDPLUGINS', 'ORDSYS', 'OUTLN'
  , 'SI_INFORMTN_SCHEMA', 'SYSDG', 'SYSKM', 'TSMSYS'
  , 'WKSYS', 'WMSYS', 'XS$NULL'
  )
)
DECLARE
  l_dummy                          VARCHAR2(1);
BEGIN
  SELECT 'Y'
    INTO l_dummy
    FROM vpc_users
   WHERE filter_uid = SYS_CONTEXT('USERENV', 'SESSION_USERID');
  EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = %o';
EXCEPTION
  WHEN NO_DATA_FOUND
  THEN NULL;
END;
}', '%o', g_catowner);
    END IF;
  END IF;
 
  deb('setupVPD - create or replace trigger');
END setupVPD;
 
PROCEDURE dumpPkgState (msg in varchar2 default NULL) IS
begin
   deb('Global variables package state ' || nvl(msg,' '));
   deb('Number variables');
   deb('dbglvl: ' || nvl(to_char(dbglvl), 'NULL'));
   deb('this_db_key: ' || nvl(to_char(this_db_key), 'NULL'));
   deb('this_dbinc_key: ' || nvl(to_char(this_dbinc_key), 'NULL'));
   deb('this_ckp_key: ' || nvl(to_char(this_ckp_key), 'NULL'));
   deb('this_ckp_scn: ' || nvl(to_char(this_ckp_scn), 'NULL'));
   deb('this_site_key: ' || nvl(to_char(this_site_key), 'NULL'));
   deb('logs_shared: ' || nvl(to_char(logs_shared), 'NULL'));
   deb('disk_backups_shared: ' || nvl(to_char(disk_backups_shared), 'NULL'));
   deb('tape_backups_shared: ' || nvl(to_char(tape_backups_shared), 'NULL'));
   deb('reNorm_state: ' || nvl(to_char(reNorm_state), 'NULL'));
   deb('resync_reason: ' || nvl(to_char(resync_reason), 'NULL'));
   deb('scr_key: ' || nvl(to_char(scr_key), 'NULL'));
   deb('scr_line: ' || nvl(to_char(scr_line), 'NULL'));
   deb('kccdivts: ' || nvl(to_char(kccdivts), 'NULL'));
   deb('cntbs: ' || nvl(to_char(cntbs), 'NULL'));
   deb('last_full_ckp_scn: ' || nvl(to_char(last_full_ckp_scn), 'NULL'));
   deb('last_con_id_ts#: ' || nvl(to_char(last_con_id_ts#), 'NULL'));
   deb('last_ts#: ' || nvl(to_char(last_ts#), 'NULL'));
   deb('last_file#: ' || nvl(to_char(last_file#), 'NULL'));
   deb('last_thread#: ' || nvl(to_char(last_thread#), 'NULL'));
   deb('last_ts_recid: ' || nvl(to_char(last_ts_recid), 'NULL'));
   deb('last_df_recid: ' || nvl(to_char(last_df_recid), 'NULL'));
   deb('last_tf_recid: ' || nvl(to_char(last_tf_recid), 'NULL'));
   deb('last_rt_recid: ' || nvl(to_char(last_rt_recid), 'NULL'));
   deb('last_orl_recid: ' || nvl(to_char(last_orl_recid), 'NULL'));
   deb('last_conf_recid: ' || nvl(to_char(last_conf_recid), 'NULL'));
   deb('force_resync2cf: ' || nvl(to_char(force_resync2cf), 'NULL'));
   deb('last_rlh_recid: ' || nvl(to_char(last_rlh_recid), 'NULL'));
   deb('last_al_recid: ' || nvl(to_char(last_al_recid), 'NULL'));
   deb('last_offr_recid: ' || nvl(to_char(last_offr_recid), 'NULL'));
   deb('last_bs_recid: ' || nvl(to_char(last_bs_recid), 'NULL'));
   deb('last_bp_recid: ' || nvl(to_char(last_bp_recid), 'NULL'));
   deb('last_bdf_recid: ' || nvl(to_char(last_bdf_recid), 'NULL'));
   deb('last_bsf_recid: ' || nvl(to_char(last_bsf_recid), 'NULL'));
   deb('last_brl_recid: ' || nvl(to_char(last_brl_recid), 'NULL'));
   deb('last_cdf_recid: ' || nvl(to_char(last_cdf_recid), 'NULL'));
   deb('last_bcb_recid: ' || nvl(to_char(last_bcb_recid), 'NULL'));
   deb('last_ccb_recid: ' || nvl(to_char(last_ccb_recid), 'NULL'));
   deb('last_do_recid: ' || nvl(to_char(last_do_recid), 'NULL'));
   deb('last_xdf_recid: ' || nvl(to_char(last_xdf_recid), 'NULL'));
   deb('last_xal_recid: ' || nvl(to_char(last_xal_recid), 'NULL'));
   deb('last_rsr_recid: ' || nvl(to_char(last_rsr_recid), 'NULL'));
   deb('last_rout_stamp: ' || nvl(to_char(last_rout_stamp), 'NULL'));
   deb('last_inst_startup_stamp: ' ||
       nvl(to_char(last_inst_startup_stamp), 'NULL'));
   deb('lrsr_key: ' || nvl(to_char(lrsr_key), 'NULL'));
   deb('lrout_skey: ' || nvl(to_char(lrout_skey), 'NULL'));
   deb('lsession_recid: ' || nvl(to_char(lsession_recid), 'NULL'));
   deb('lsession_stamp: ' || nvl(to_char(lsession_stamp), 'NULL'));
   deb('lrman_status_recid: ' || nvl(to_char(lrman_status_recid), 'NULL'));
   deb('lrman_status_stamp: ' || nvl(to_char(lrman_status_stamp), 'NULL'));
   deb('krbmror_llength_bytes: ' ||
       nvl(to_char(krbmror_llength_bytes), 'NULL'));
   deb('last_ic_recid: ' || nvl(to_char(last_ic_recid), 'NULL'));
   deb('last_reset_scn: ' || nvl(to_char(last_reset_scn), 'NULL'));
   deb('last_dbinc_key: ' || nvl(to_char(last_dbinc_key), 'NULL'));
   deb('low_nrsp_recid: ' || nvl(to_char(low_nrsp_recid), 'NULL'));
   deb('last_nrsp_recid: ' || nvl(to_char(last_nrsp_recid), 'NULL'));
   deb('last_grsp_recid: ' || nvl(to_char(last_grsp_recid), 'NULL'));
   deb('last_bcr_recid: ' || nvl(to_char(last_bcr_recid), 'NULL'));
   deb('last_pdb_recid: ' || nvl(to_char(last_pdb_recid), 'NULL'));
   deb('last_resync_cksum: ' || nvl(to_char(last_resync_cksum), 'NULL'));
 
   deb('Date variables');
   deb('this_ckp_time: ' ||
       nvl(to_char(this_ckp_time, 'DD/MM/YYYY HH24:MI:SS'), 'NULL'));
   deb('last_reset_time: ' ||
       nvl(to_char(last_reset_time, 'DD/MM/YYYY HH24:MI:SS'), 'NULL'));
   deb('last_cf_version_time: ' ||
        nvl(to_char(last_cf_version_time, 'DD/MM/YYYY HH24:MI:SS'), 'NULL'));
 
   deb('Char variables');
   deb('last_fname: ' || nvl(last_fname, 'NULL'));
   deb('last_rspname: '|| nvl(last_rspname, 'NULL'));         
   deb('last_pdb_key: '|| last_pdb_key);
   deb('this_cf_type: '|| nvl(this_cf_type, 'NULL'));
   deb('this_db_unique_name: ' || nvl(this_db_unique_name, 'NULL'));
 
   deb('Boolean variables');
   if debug is NULL then
      deb('debug is NULL');
   elsif scr_glob then
      deb('debug is TRUE');
   else
      deb('debug is FALSE');
   end if;
 
   if client_site_aware is NULL then
      deb('client_site_aware is NULL');
   elsif client_site_aware then
      deb('client_site_aware is TRUE');
   else
      deb('client_site_ware is FALSE');
   end if;
 
   if scr_glob is NULL then
      deb('scr_glob is NULL');
   elsif scr_glob then
      deb('scr_glob is TRUE');
   else
      deb('scr_glob is FALSE');
   end if;
 
   if do_temp_ts_resync is NULL then
      deb('do_temp_ts_resync is NULL');
   elsif do_temp_ts_resync then
      deb('do_temp_ts_resync is TRUE');
   else
      deb('do_temp_ts_resync is FALSE');
   end if;
end dumpPkgState;
 
/*--------------------------------------------------*
 * package private fns required for recover server  *
 *--------------------------------------------------*/
PROCEDURE read_from_http(resp IN OUT utl_http.resp, clobvar IN OUT CLOB) IS
   data raw(1024);
   pos Integer;
   amt Binary_Integer;
BEGIN
   dbms_lob.createtemporary(clobvar, TRUE);
   pos := 1;
   BEGIN
      LOOP
         utl_http.read_raw(resp, data);
         amt := length(utl_raw.cast_to_varchar2(data)); 
         dbms_lob.write(clobvar, amt, pos, utl_raw.cast_to_varchar2(data));
         pos := pos + amt;
      END LOOP;
   EXCEPTION
      WHEN utl_http.end_of_body THEN
      NULL;
   END;
END;
 
PROCEDURE display_http_response(resp IN OUT utl_http.resp) IS
   hdrcnt integer;
   name varchar2(256);
   value varchar2(256);
BEGIN
   IF not debug THEN
      RETURN;
   END IF;
   hdrcnt := utl_http.get_header_count(resp);
   deb('^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ');
   deb('Response header count = ' || hdrcnt);
   deb('^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ');
   loop
      exit when hdrcnt = 0;
      utl_http.get_header(resp, hdrcnt, name, value);
      deb('Hdr# '|| hdrcnt || ' Name= ' || name || 
                           ' Value= ' || value);
      hdrcnt := hdrcnt - 1;
   end loop;
END;
 
PROCEDURE display_clob(val IN CLOB) IS
   buf varchar2(2048 CHAR);
   origlen integer;
   len integer;
   pos integer;
   amt integer;
BEGIN
   IF not debug THEN
      RETURN;
   END IF;
   deb('DISPLAY_CLOB BEGIN');
   amt := 2048; -- amount to read at a time
   len := dbms_lob.getlength(val);
   origlen := len;
   deb('xmlfile len = ' || len);
   pos := 1;
   loop
      exit when pos > origlen;
      if len < amt then
         dbms_lob.read(val, len, pos, buf);
         pos := pos + len;
      else
         dbms_lob.read(val, amt, pos, buf);
         len := len - amt;
         pos := pos + amt;
      end if;
--
--
--
   end loop;
   deb('DISPLAY_CLOB END');
END;
 
FUNCTION get_Complete_URL (bktname in varchar2,
                           objname in varchar2,
                           awsr    OUT varchar2,
                           parms   in varchar2 DEFAULT null) 
RETURN VARCHAR2 IS
   complete_url varchar2(2048);
   aws_resource varchar2(512);
BEGIN
   IF this_amazon_server THEN
     complete_url := bktname || '.' || this_server_url;
   ELSE
     complete_url := this_server_url || '/orssv';
     aws_resource := '/orssv';
   END IF;
 
   IF this_server_url IS NULL THEN
      raise_application_error(-20999, 'internal error:this_server_url');
   END IF;
 
   IF this_url_db_unique_name IS NULL THEN
      raise_application_error(-20999, 'internal error:this_url_db_unique_name');
   END IF;
 
   complete_url := complete_url || '/rcfile/' || objname || '?' || 
                   'x-DBUName=' || this_url_db_unique_name;
   if parms is not null then
      complete_url := complete_url || '&' || parms;
   end if;
 
   aws_resource := aws_resource || '/rcfile/' || objname;
   awsr := aws_resource;
 
   IF debug THEN
      deb('URL=' || complete_url);
      deb('awsr=' || awsr);
   END IF;
   RETURN complete_url;
END get_Complete_URL;
 
/*----------------------------------------------------*
 * package public fns required for recover server     *
 * The concept of bucket is used only for amazon S3   *
 *----------------------------------------------------*/
PROCEDURE put_bucket(bktname in varchar2) IS
   objval CLOB := NULL;
BEGIN
   IF this_amazon_server THEN
     put_object(bktname, null, null, objval);
   END IF;
END;
 
FUNCTION get_bucket(bktname in varchar2) RETURN CLOB IS
BEGIN
   IF this_amazon_server THEN
      return get_object(bktname, null);
   END IF;
   return NULL;
END;
 
PROCEDURE delete_bucket(bktname in varchar2) IS
BEGIN
   IF this_amazon_server THEN
      delete_object(bktname, null);
   END IF;
END;
 
PROCEDURE utl_httl_12cR1fns(req IN OUT utl_http.req, awsr IN VARCHAR2) IS
BEGIN
   $IF DBMS_DB_VERSION.VERSION < 12 $THEN
      raise_application_error(-20999,
         'internal error: not support database version');
   $ELSE
      IF this_amazon_server then
         execute immediate 'begin utl_http.set_property(
                               :req,  
                               ''aws-canonicalized-resource'', :awsr); end;'
                 using in out req, in awsr;
         deb('sqlcode after set_property on: ' || sqlcode);
 
         execute immediate ' begin 
                                 utl_http.set_authentication_from_wallet(
                                                  r      => :req, 
                                                  alias  => :wallet_alias,
                                                  scheme => ''AWS''); end;'
                  using in out req, in this_server.wallet_alias;
         deb('sqlcode after set_authentication_from_wallet on: ' || sqlcode);
      ELSE
         execute immediate ' begin 
                                utl_http.set_authentication(
                                                 r        => :req,
                                                 username => :username,
                                                 password => :password,
                                                 scheme   => ''Digest''); end;'
                 using in out req, in this_server_uname,
                       in this_server_passw;
         deb('sqlcode after set_authentication on: ' || sqlcode);
      END IF;
   $END
END;
 
PROCEDURE put_object(bktname in varchar2, 
                     objname in varchar2,
                     objtype in varchar2,
                     objval in out CLOB) is
   req utl_http.req;
   resp utl_http.resp;
   len Integer;
   pos Integer;
   amt Integer;
   origlen Integer;
   buf raw(2048);
   cbuf varchar2(2048 CHAR);
   local_response_val CLOB;
   ct timestamp(0);
   cdt varchar2(50);
   awsr varchar2(512);
   timeout_secs number;
   retries      number := -1;
 
BEGIN
 
   IF this_server.server_host IS NULL THEN
      deb('put_object: this_server.server_host is null');
      return;
   END IF;
 
   deb('Enter put_object ' || objname);
 
   timeout_secs := this_server.timeout_secs;
 
<<retry_request_again>>
 
   BEGIN
      retries := retries + 1;
      deb('retries count is ' || retries);
      timeout_secs := timeout_secs + retries * timeout_secs;
 
      select sys_extract_utc(current_timestamp) into ct from dual;
      cdt := to_char(ct, 'Dy, DD Mon YYYY HH24:MI:SS') || ' GMT';
 
      utl_http.set_transfer_timeout(timeout_secs);
      req := utl_http.begin_request(get_Complete_URL(bktname, objname, awsr), 
                                    'PUT', utl_http.HTTP_VERSION_1_1);
 
      utl_http.set_header(req, 'Date', cdt);
      if objname is not null then
         utl_http.set_header(req, 'Content-Type', objtype);
      end if;
      
      utl_httl_12cR1fns( req, awsr);
 
      IF objname is null THEN
         utl_http.set_header(req, 'Content-Length', 0);
      ELSE
         dbms_lob.open(objval, dbms_lob.lob_readonly);
         len := dbms_lob.getlength(objval);
         deb('Content-length = ' || len);
         utl_http.set_header(req, 'Content-Length',len);
         origlen := len;
         amt := 2048;
         pos := 1;
         if lower(objtype) = 'text/xml' then
            loop
               exit when pos > origlen;
               if len < amt then
                  dbms_lob.read(objval, len, pos, cbuf);
                  pos := pos + len;
               else
                  dbms_lob.read(objval, amt, pos, cbuf);
                  len := len - amt;
                  pos := pos + amt;
               end if;
               utl_http.write_raw(req, utl_raw.cast_to_raw(cbuf));
            end loop;
         ELSE
            loop
               exit when pos > origlen;
               if len < amt then
                  dbms_lob.read(objval, len, pos, buf);
                  pos := pos + len;
               else
                  dbms_lob.read(objval, amt, pos, buf);
                  len := len - amt;
                  pos := pos + amt;
               end if;
               utl_http.write_raw(req, buf);
            end loop;
         end if;
         dbms_lob.close(objval);
      END IF;
 
      resp := utl_http.get_response(req);
 
      display_http_response(resp);
 
      read_from_http(resp, local_response_val);
      display_clob(local_response_val);
 
      utl_http.end_response(resp);
      deb('Exit put_object');
 
   EXCEPTION
      WHEN Utl_Http.request_failed THEN
         deb ('Request_Failed:' || 
                               Utl_Http.get_detailed_sqlerrm);
         Utl_Http.end_request (req);
      WHEN Utl_Http.http_server_error THEN
         deb ('Http_Server_Error: ' ||
                               Utl_Http.get_detailed_sqlerrm);
         Utl_Http.end_request (req);
      WHEN Utl_Http.http_client_error THEN
         deb ('Http_Client_Error: ' || 
                               Utl_Http.get_detailed_sqlerrm);
         Utl_Http.end_request (req);
      WHEN OTHERS THEN
         deb('HTTP Other error:' || sqlerrm);
         if retries <= 5 and substr(sqlerrm, 1, 9)  = 'ORA-29276' then
            goto retry_request_again;
         else
            raise;
         end if;
   END;
END put_object;
 
PROCEDURE delete_object(bktname in varchar2, objname in varchar2) is
   req utl_http.req;
   resp utl_http.resp;
   tmpfile CLOB := NULL;
   ct timestamp(0);
   cdt varchar2(50);
   awsr varchar2(512);
BEGIN
 
   IF this_server.server_host IS NULL THEN
      deb('delete_object: this_server.server_host is null');
      return;
   END IF;
 
   deb('Enter delete_object');
 
   select sys_extract_utc(current_timestamp) into ct from dual;
   cdt := to_char(ct, 'Dy, DD Mon YYYY HH24:MI:SS') || ' GMT';
 
   utl_http.set_transfer_timeout(this_server.timeout_secs);
   req := utl_http.begin_request(get_Complete_URL(bktname, objname, awsr), 
                                 'DELETE', utl_http.HTTP_VERSION_1_1);
 
   utl_http.set_header(req, 'Date', cdt);
      
   utl_httl_12cR1fns( req, awsr);
 
   resp := utl_http.get_response(req);
   display_http_response(resp);
 
   read_from_http(resp, tmpfile);
   display_clob(tmpfile);
 
   utl_http.end_response(resp);
   deb('Exit delete_object');
 
EXCEPTION
   WHEN Utl_Http.request_failed THEN
      deb ('Request_Failed:' || 
                            Utl_Http.get_detailed_sqlerrm);
      Utl_Http.end_request (req);
   WHEN Utl_Http.http_server_error THEN
      deb ('Http_Server_Error: ' ||
                            Utl_Http.get_detailed_sqlerrm);
      Utl_Http.end_request (req);
   WHEN Utl_Http.http_client_error THEN
      deb ('Http_Client_Error: ' || 
                            Utl_Http.get_detailed_sqlerrm);
      Utl_Http.end_request (req);
      return;
   WHEN OTHERS THEN
      deb('HTTP Other error: ' || sqlerrm);
      raise;
END delete_object;
 
FUNCTION get_object(bktname in varchar2, 
                    objname in varchar2,
                    parms   in varchar2 DEFAULT null) return CLOB is
   req          utl_http.req;
   resp         utl_http.resp;
   objval       CLOB := NULL;
   ct           timestamp(0);
   cdt          varchar2(50);
   awsr         varchar2(512);
   timeout_secs number;
   retries      number := -1;
 
begin
 
   IF this_server.server_host IS NULL THEN
      deb('get_object: this_server.server_host is null');
      return NULL;
   END IF;
 
   deb('Enter get_object ' || objname);
 
   timeout_secs := this_server.timeout_secs;
 
<<retry_request_again>>
 
   BEGIN
      retries := retries + 1;
      deb('retries count is ' || retries);
      timeout_secs := timeout_secs + retries * timeout_secs;
 
 
      select sys_extract_utc(current_timestamp) into ct from dual;
      cdt := to_char(ct, 'Dy, DD Mon YYYY HH24:MI:SS') || ' GMT';
 
      utl_http.set_transfer_timeout(timeout_secs);
      req := utl_http.begin_request(
                                  get_Complete_URL(bktname,objname,awsr,parms),
                                  'GET', utl_http.HTTP_VERSION_1_1);
 
      utl_http.set_header(req, 'Date', cdt);
      utl_httl_12cR1fns( req, awsr);
      resp := utl_http.get_response(req);
      display_http_response(resp);
 
      read_from_http(resp, objval);
      display_clob(objval);
 
      utl_http.end_response(resp);
 
      IF dbms_lob.getlength(objval) > 0 then
         IF objname is null THEN
            delete from rcfile where name = parms;
            insert into rcfile(rcfile_key, creation_time, name, xmldoc)
               values (rman_seq.nextval, sys_extract_utc(systimestamp), parms, 
                       XMLType.createXML(objval));
            deb('got rows for ' || parms);
            commitChanges('get_object-1');
         ELSE
            delete from rcfile where name = objname;
            insert into rcfile(rcfile_key, creation_time, name, xmldoc)
               values (rman_seq.nextval, sys_extract_utc(systimestamp),objname,
                       XMLType.createXML(objval));
            deb('got rows for ' || objname);
            commitChanges('get_object-2');
         END IF;
      END IF;
      deb('Exit get_object');
   
   return objval;
   EXCEPTION
      WHEN Utl_Http.request_failed THEN
         deb ('Request_Failed:' || 
                               Utl_Http.get_detailed_sqlerrm);
         Utl_Http.end_request (req);
      WHEN Utl_Http.http_server_error THEN
         deb ('Http_Server_Error: ' ||
                               Utl_Http.get_detailed_sqlerrm);
         Utl_Http.end_request (req);
      WHEN Utl_Http.http_client_error THEN
         deb ('Http_Client_Error: ' || 
                               Utl_Http.get_detailed_sqlerrm);
         Utl_Http.end_request (req);
      WHEN OTHERS THEN
         deb('HTTP Other error: ' || sqlerrm);
         if retries <= 5 and substr(sqlerrm, 1, 9)  = 'ORA-29276' then
            goto retry_request_again;
         else
            raise;
         end if;
   END;
END get_object;
 
PROCEDURE displayRCWatermarks(cmt IN VARCHAR2, wmrec IN RC_WATERMARKS%ROWTYPE) IS
BEGIN
   IF NOT debug THEN
      RETURN;
   END IF;
 
   deb(cmt || 'DB_KEY=' || wmrec.DB_KEY);
   deb(cmt || 'DB_UNIQUE_NAME=' || wmrec.DB_UNIQUE_NAME);
   deb(cmt || 'RS_VERSION_STAMP=' || wmrec.RS_VERSION_STAMP);
   deb(cmt || 'HIGH_BP_RECID=' || wmrec.HIGH_BP_RECID);
   deb(cmt || 'HIGH_DO_KEY=' || wmrec.HIGH_DO_KEY);
   deb(cmt || 'CF_VERSION_STAMP=' || wmrec.CF_VERSION_STAMP);
   deb(cmt || 'HIGH_DF_RECID=' || wmrec.HIGH_DF_RECID);
   deb(cmt || 'HIGH_TS_RECID=' || wmrec.HIGH_TS_RECID);
   deb(cmt || 'HIGH_TF_RECID=' || wmrec.HIGH_TF_RECID);
   deb(cmt || 'HIGH_OFFR_RECID=' || wmrec.HIGH_OFFR_RECID);
END displayRCWatermarks;
 
PROCEDURE displayRCSite(cmt IN VARCHAR2, siterec IN RC_SITE%ROWTYPE) IS
BEGIN
   IF NOT debug THEN
      RETURN;
   END IF;
 
   deb(cmt || 'SITE_KEY=' || siterec.SITE_KEY);
   deb(cmt || 'DB_KEY=' || siterec.DB_KEY);
   deb(cmt || 'DATABASE_ROLE=' || siterec.DATABASE_ROLE);
   deb(cmt || 'CF_CREATE_TIME=' || siterec.CF_CREATE_TIME);
   deb(cmt || 'DB_UNIQUE_NAME=' || siterec.DB_UNIQUE_NAME);
   deb(cmt || 'HIGH_CONF_RECID=' || siterec.HIGH_CONF_RECID);
   deb(cmt || 'FORCE_RESYNC2CF=' || siterec.FORCE_RESYNC2CF);
   deb(cmt || 'HIGH_ROUT_STAMP=' || siterec.HIGH_ROUT_STAMP);
   deb(cmt || 'INST_STARTUP_STAMP=' || siterec.INST_STARTUP_STAMP);
   deb(cmt || 'LAST_KCCDIVTS=' || stamp2date(siterec.LAST_KCCDIVTS));
   deb(cmt || 'HIGH_IC_RECID=' || siterec.HIGH_IC_RECID);
   deb(cmt || 'DBINC_KEY=' || siterec.DBINC_KEY);
   deb(cmt || 'CKP_SCN=' || siterec.CKP_SCN);
   deb(cmt || 'FULL_CKP_CF_SEQ=' || siterec.FULL_CKP_CF_SEQ);
   deb(cmt || 'JOB_CKP_CF_SEQ=' || siterec.JOB_CKP_CF_SEQ);
   deb(cmt || 'HIGH_TS_RECID=' || siterec.HIGH_TS_RECID);
   deb(cmt || 'HIGH_DF_RECID=' || siterec.HIGH_DF_RECID);
   deb(cmt || 'HIGH_RT_RECID=' || siterec.HIGH_RT_RECID);
   deb(cmt || 'HIGH_ORL_RECID=' || siterec.HIGH_ORL_RECID);
   deb(cmt || 'HIGH_OFFR_RECID=' || siterec.HIGH_OFFR_RECID);
   deb(cmt || 'HIGH_RLH_RECID=' || siterec.HIGH_RLH_RECID);
   deb(cmt || 'HIGH_AL_RECID=' || siterec.HIGH_AL_RECID);
   deb(cmt || 'HIGH_BS_RECID=' || siterec.HIGH_BS_RECID);
   deb(cmt || 'HIGH_BP_RECID=' || siterec.HIGH_BP_RECID);
   deb(cmt || 'HIGH_BDF_RECID=' || siterec.HIGH_BDF_RECID);
   deb(cmt || 'HIGH_CDF_RECID=' || siterec.HIGH_CDF_RECID);
   deb(cmt || 'HIGH_BRL_RECID=' || siterec.HIGH_BRL_RECID);
   deb(cmt || 'HIGH_BCB_RECID=' || siterec.HIGH_BCB_RECID);
   deb(cmt || 'HIGH_CCB_RECID=' || siterec.HIGH_CCB_RECID);
   deb(cmt || 'HIGH_DO_RECID=' || siterec.HIGH_DO_RECID);
   deb(cmt || 'HIGH_PC_RECID=' || siterec.HIGH_PC_RECID);
   deb(cmt || 'HIGH_BSF_RECID=' || siterec.HIGH_BSF_RECID);
   deb(cmt || 'HIGH_RSR_RECID=' || siterec.HIGH_RSR_RECID);
   deb(cmt || 'HIGH_TF_RECID=' || siterec.HIGH_TF_RECID);
   deb(cmt || 'HIGH_GRSP_RECID=' || siterec.HIGH_GRSP_RECID);
   deb(cmt || 'HIGH_NRSP_RECID=' || siterec.HIGH_NRSP_RECID);
   deb(cmt || 'HIGH_BCR_RECID=' || siterec.HIGH_BCR_RECID);
   deb(cmt || 'LOW_BCR_RECID=' || siterec.LOW_BCR_RECID);
   deb(cmt || 'BCR_IN_USE=' || siterec.BCR_IN_USE);
   deb(cmt || 'HIGH_PDB_RECID=' || siterec.HIGH_PDB_RECID);
   deb(cmt || 'HIGH_PIC_RECID=' || siterec.HIGH_PIC_RECID);
END displayRCSite;
 
PROCEDURE displayRCDatabaseIncarnation
   (cmt IN VARCHAR2, icrec IN RC_DATABASE_INCARNATION%ROWTYPE) IS
BEGIN
   IF NOT debug THEN
      RETURN;
   END IF;
 
   deb(cmt || 'DB_KEY=' || icrec.DB_KEY); 
   deb(cmt || 'DBID=' || icrec.DBID); 
   deb(cmt || 'DBINC_KEY=' || icrec.DBINC_KEY);  
   deb(cmt || 'NAME=' || icrec.NAME); 
   deb(cmt || 'RESETLOGS_CHANGE#=' || icrec.RESETLOGS_CHANGE#); 
   deb(cmt || 'RESETLOGS_TIME=' || icrec.RESETLOGS_TIME);
   deb(cmt || 'CURRENT_INCARNATION=' || icrec.CURRENT_INCARNATION);
   deb(cmt || 'PARENT_DBINC_KEY=' || icrec.PARENT_DBINC_KEY); 
   deb(cmt || 'PRIOR_RESETLOGS_CHANGE#=' || icrec.PRIOR_RESETLOGS_CHANGE#);
   deb(cmt || 'PRIOR_RESETLOGS_TIME=' || icrec.PRIOR_RESETLOGS_TIME);
   deb(cmt || 'STATUS=' || icrec.STATUS);
   deb(cmt || 'REG_DB_UNIQUE_NAME=' || icrec.REG_DB_UNIQUE_NAME);
   deb(cmt || 'CON_ID=' || icrec.CON_ID);
   deb(cmt || 'GUID=' || icrec.GUID);
END displayRCDatabaseIncarnation;
 
PROCEDURE writeForWatermarks(bktname   IN VARCHAR2 DEFAULT NULL,
                             full_ckpt IN BOOLEAN) IS
   v_ctx     DBMS_XMLGen.ctxHandle;
   v_xml     CLOB;
   v_xml_tmp CLOB;
   type record_sql_type is table of varchar2(2048) 
             index by binary_integer;
   type record_tbl_type is table of varchar2(30) 
             index by binary_integer;
   record_sql  record_sql_type;
   record_tbl  record_tbl_type;
   my_dbid      number;
   write_xml_filename rcfile.name%TYPE;
 
BEGIN
--
   IF this_server.server_host IS NULL THEN
      deb('writeForWaterMarks: this_server.server_host is null');
      return;
   END IF;
 
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'Database not set');
   END IF;
 
   SELECT DBID INTO MY_DBID FROM RC_DATABASE WHERE DB_KEY=this_db_key;
 
   record_tbl(0)   := 'RC_DATABASE';
   record_sql(0)   := 'SELECT * FROM RC_DATABASE ' || 
                              'WHERE DB_KEY = ' || this_db_key;
 
   record_tbl(1)   := 'RC_DATABASE_INCARNATION';
   record_sql(1)   := 'SELECT * FROM RC_DATABASE_INCARNATION ' ||
                              'WHERE DB_KEY = ' || this_db_key;
 
   record_tbl(2)   := 'RC_SITE';
   IF full_ckpt THEN
      deb('writeForWatermarks for remote readFixedSections');
--
--
--
      record_sql(2)   := 'SELECT -1 high_bp_recid FROM RCI_SITE ' ||
                            'WHERE DB_KEY   = ' || this_db_key ||
                            '  AND SITE_KEY = ' || this_site_key;
   ELSE
      deb('writeForWatermarks for local readBackupSections');
      record_sql(2)   := 'SELECT * FROM RCI_SITE ' ||
                            'WHERE DB_KEY   = ' || this_db_key ||
                            '  AND SITE_KEY = ' || this_site_key;
   END IF;
 
   v_xml := this_xml_signature_beg;
   dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
 
   FOR idx in 0..2 LOOP
      deb('writing XML file for ' || idx);
      deb('executing query:'|| record_sql(idx));
 
      v_ctx := DBMS_XMLGen.newContext(record_sql(idx));
 
--
      DBMS_XMLGen.setRowsetTag(v_ctx, 'TABLE_' || record_tbl(idx));
      v_xml_tmp := DBMS_XMLGen.GetXML(v_ctx);
      DBMS_XMLGen.closeContext(v_ctx);
 
      deb('XML len for ' || idx || '=' || DBMS_LOB.GETLENGTH(v_xml_tmp));
      IF v_xml_tmp IS NOT NULL THEN
         DBMS_LOB.COPY(v_xml, v_xml_tmp, DBMS_LOB.LOBMAXSIZE, 
                       DBMS_LOB.GETLENGTH(v_xml),
                       DBMS_LOB.INSTR(v_xml_tmp, 
                                  '<TABLE_' || record_tbl(idx) ||'>'));
      END IF;
   END LOOP;
 
   v_xml := v_xml || this_xml_signature_end;
 
   write_xml_filename := this_forwatermarks || my_dbid || '.xml';
   put_bucket(bktname);
   put_object(bktname, write_xml_filename, 'text/xml', v_xml);
 
END writeForWatermarks;
 
PROCEDURE rsReadWaterMarks(bktname  IN VARCHAR2 DEFAULT NULL) IS
   xml_filename RCFILE.NAME%TYPE;
   my_dbid      NUMBER;
   v_xml_tmp    CLOB;
   v_ctx        DBMS_XMLGen.ctxHandle;
   verrec       RC_RCVER%ROWTYPE;
   curr_inc     RC_DATABASE_INCARNATION%ROWTYPE;
   wmrec        RC_WATERMARKS%ROWTYPE;
 
   CURSOR rc_rcver_c IS
   SELECT VERSION
   FROM "_RS_RC_RCVER_"
   WHERE RS_RCFILE_NAME = xml_filename;
 
   CURSOR rc_watermarks_c IS
   SELECT DB_KEY,
          DB_UNIQUE_NAME,
          RS_VERSION_STAMP,
          HIGH_BP_RECID,
          HIGH_DO_KEY,
          CF_VERSION_STAMP,
          HIGH_DF_RECID,
          HIGH_TS_RECID,
          HIGH_TF_RECID,
          HIGH_OFFR_RECID
   FROM "_RS_RC_WATERMARKS_"
   WHERE RS_RCFILE_NAME = xml_filename;
 
   CURSOR rc_database_incarnation_c IS
   SELECT DB_KEY, 
          DBID, 
          DBINC_KEY,  
          NAME, 
          RESETLOGS_CHANGE#, 
          RESETLOGS_TIME,
          CURRENT_INCARNATION,
          PARENT_DBINC_KEY, 
          PRIOR_RESETLOGS_CHANGE#,
          PRIOR_RESETLOGS_TIME,
          STATUS,
          REG_DB_UNIQUE_NAME,
          CON_ID,
          GUID
   FROM "_RS_RC_DATABASE_INCARNATION_"
   WHERE RS_RCFILE_NAME = xml_filename
     AND STATUS = 'CURRENT';
 
   upstream_dbrec RCI_RA_UPSTREAM_DATABASE%ROWTYPE;
   CURSOR rci_ra_upstream_database_c IS
   SELECT  DBID,
           NAME
   FROM "_RS_RCI_RA_UPSTREAM_DATABASE_"
   WHERE RS_RCFILE_NAME = xml_filename;
 
   CURSOR local_current_incarnation_c IS
   SELECT *
   FROM RC_DATABASE_INCARNATION
   WHERE DBINC_KEY = this_dbinc_key;
   local_curr_inc RC_DATABASE_INCARNATION%ROWTYPE;
 
BEGIN
 
--
   IF this_server.server_host IS NULL THEN
      deb('rsReadWaterMarks: this_server.server_host is null');
      return;
   END IF;
 
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'Database not set');
   END IF;
 
   SELECT DBID INTO MY_DBID FROM RC_DATABASE
      WHERE DB_KEY=this_db_key;
 
--
--
   xml_filename := this_watermarks || my_dbid || '.xml';
   v_xml_tmp := get_object(bktname, xml_filename);
 
--
   dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
 
--
   OPEN rc_rcver_c;
   FETCH rc_rcver_c INTO verrec;
   CLOSE rc_rcver_c;
 
--
   OPEN rc_watermarks_c;
   FETCH rc_watermarks_c INTO wmrec;
   CLOSE rc_watermarks_c;
 
--
   OPEN rc_database_incarnation_c;
   FETCH rc_database_incarnation_c INTO curr_inc;
   CLOSE rc_database_incarnation_c;
 
--
   OPEN local_current_incarnation_c;
   FETCH local_current_incarnation_c INTO local_curr_inc;
   CLOSE local_current_incarnation_c;
 
--
   OPEN rci_ra_upstream_database_c;
   FETCH rci_ra_upstream_database_c INTO upstream_dbrec;
   CLOSE rci_ra_upstream_database_c;
 
--
   IF curr_inc.dbid <> rsReadWaterMarks.my_dbid THEN
      raise_application_error(-20141, 
                 'Target database id mismatch with registered database in ORS');
   END IF;
 
--
--
--
--
   v_ctx := DBMS_XMLGen.newContext('SELECT DB_KEY, DB_UNIQUE_NAME, ' ||
                'RS_VERSION_STAMP,'||
                'HIGH_BP_RECID,'||
                'HIGH_DO_KEY, CF_VERSION_STAMP,'||
                'HIGH_DF_RECID, '||
                'HIGH_TS_RECID, HIGH_TF_RECID, HIGH_OFFR_RECID '||
                'FROM "_RS_RC_WATERMARKS_" '||
                'WHERE RS_RCFILE_NAME = ''' || xml_filename || '''');
 
--
   DBMS_XMLGen.setRowsetTag(v_ctx, 'TABLE_RC_WATERMARKS');
   this_v_wmrec := DBMS_XMLGen.GetXML(v_ctx);
   DBMS_XMLGen.closeContext(v_ctx);
 
   IF upstream_dbrec.name IS NULL THEN
      raise_application_error(-20999, 'internal error: no rows for upstreamdb');
   END IF;
 
   this_verrec := verrec;
   this_curr_inc := curr_inc;
   this_wmrec  := wmrec;
   this_upstream_dbrec := upstream_dbrec;
 
   IF debug THEN
      deb('rsReadWatermarks: remote reconcile dbname=' || 
           this_upstream_dbrec.name);
      deb('this_curr_inc.dbid: ' || this_curr_inc.dbid);
 
      displayRCWatermarks('rsReadWatermarks remote:', this_wmrec);
      displayRCDatabaseIncarnation('rsReadWatermarks remote:', curr_inc);
      displayRCDatabaseIncarnation('rsReadWatermarks local:', local_curr_inc);
   END IF;
 
   
--
--
   IF curr_inc.resetlogs_change# <> local_curr_inc.resetlogs_change# OR
      curr_inc.resetlogs_time <> local_curr_inc.resetlogs_time THEN
      deb('Clearing this_wmrec.cf_version_stamp so all fixed records are sent');
      this_wmrec.cf_version_stamp := NULL;
   END IF;
 
END rsReadWaterMarks;
 
--
PROCEDURE rsWriteWaterMarks (input_xml_filename  IN VARCHAR2,
                             bktname IN VARCHAR2 DEFAULT NULL) IS
   v_ctx     DBMS_XMLGen.ctxHandle;
   v_xml     CLOB;
   v_xml_tmp CLOB;
   type record_sql_type is table of varchar2(2048) 
             index by binary_integer;
   type record_tbl_type is table of varchar2(30) 
             index by binary_integer;
   record_sql  record_sql_type;
   record_tbl  record_tbl_type;
   my_dbid      number;
   l_max_do_key number;
   l_high_do_key number;
 
   write_xml_filename rcfile.name%TYPE;
 
   curr_inc RC_DATABASE_INCARNATION%ROWTYPE;
   CURSOR rc_database_incarnation_c(curr_inc_val IN VARCHAR2 DEFAULT NULL) IS
   SELECT DB_KEY, 
          DBID, 
          DBINC_KEY,  
          NAME, 
          RESETLOGS_CHANGE#, 
          RESETLOGS_TIME,
          CURRENT_INCARNATION,
          PARENT_DBINC_KEY, 
          PRIOR_RESETLOGS_CHANGE#,
          PRIOR_RESETLOGS_TIME,
          STATUS,
          REG_DB_UNIQUE_NAME,
          CON_ID,
          GUID
   FROM "_RS_RC_DATABASE_INCARNATION_"
   WHERE RS_RCFILE_NAME = input_xml_filename
     AND (curr_inc_val IS NULL OR
          CURRENT_INCARNATION = curr_inc_val);
 
   CURSOR rc_site_c IS
   SELECT  SITE_KEY,
           DB_KEY,
           DATABASE_ROLE,
           CF_CREATE_TIME,
           DB_UNIQUE_NAME,
           HIGH_CONF_RECID,
           FORCE_RESYNC2CF,
           HIGH_ROUT_STAMP,
           INST_STARTUP_STAMP,
           LAST_KCCDIVTS,
           HIGH_IC_RECID,
           DBINC_KEY,
           CKP_SCN,
           FULL_CKP_CF_SEQ,
           JOB_CKP_CF_SEQ,
           HIGH_TS_RECID,
           HIGH_DF_RECID,
           HIGH_RT_RECID,
           HIGH_ORL_RECID,
           HIGH_OFFR_RECID,
           HIGH_RLH_RECID,
           HIGH_AL_RECID,
           HIGH_BS_RECID,
           HIGH_BP_RECID,
           HIGH_BDF_RECID,
           HIGH_CDF_RECID,
           HIGH_BRL_RECID,
           HIGH_BCB_RECID,
           HIGH_CCB_RECID,
           HIGH_DO_RECID,
           HIGH_PC_RECID,
           HIGH_BSF_RECID,
           HIGH_RSR_RECID,
           HIGH_TF_RECID,
           HIGH_GRSP_RECID,
           HIGH_NRSP_RECID,
           HIGH_BCR_RECID,
           LOW_BCR_RECID,
           BCR_IN_USE,
           HIGH_PDB_RECID,
           HIGH_PIC_RECID
   FROM "_RS_RC_SITE_"
   WHERE RS_RCFILE_NAME = input_xml_filename;
 
   l_stmts   NUMBER;
 
BEGIN
 
--
   my_dbid := to_number(substr(input_xml_filename, 
                               length(this_forwatermarks)+1, 
                               instr(input_xml_filename,'.xml')-1
                                     -length(this_forwatermarks)));
 
   deb('rsWriteWaterMarks:remote my_dbid=' || my_dbid);
 
--
   dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
 
--
   OPEN rc_database_incarnation_c(curr_inc_val => 'YES');
   FETCH rc_database_incarnation_c INTO curr_inc;
   CLOSE rc_database_incarnation_c;
 
--
   OPEN rc_site_c;
   FETCH rc_site_c INTO this_rsiterec;
   CLOSE rc_site_c;
   IF debug THEN
      displayRCSite('rsWriteWaterMarks:remote ', this_rsiterec);
   END IF;
 
--
   IF curr_inc.dbid <> my_dbid THEN
      raise_application_error(-20141, 
                 'Target database id mismatch with registered database in ORS');
   END IF;
 
 
   record_tbl(0)   := 'RCI_RA_UPSTREAM_DATABASE';
   record_sql(0)   := 'SELECT * FROM RCI_RA_UPSTREAM_DATABASE';
 
   record_tbl(1)   := 'RC_RCVER';
   record_sql(1)   := 'SELECT * FROM RC_RCVER ';
 
 
   l_stmts  := 1;
 
--
   BEGIN
      SELECT DB_KEY INTO this_db_key FROM DB
         WHERE db_id = my_dbid;
 
      deb('rsWriteWaterMarks:this_db_key=' || this_db_key);
 
--
      dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
 
 
      record_tbl(2)   := 'RC_DATABASE_INCARNATION';
      record_sql(2)   := 'SELECT * FROM RC_DATABASE_INCARNATION ' || 
                            'WHERE DB_KEY = ' || this_db_key;
 
      record_tbl(3)   := 'RC_WATERMARKS';
      record_sql(3)   := 'SELECT * FROM RC_WATERMARKS ' || 
                            'WHERE DB_KEY = ' || this_db_key;
 
      l_stmts  := 3;
 
--
      BEGIN
         SELECT high_do_key INTO l_high_do_key 
            FROM watermarks WHERE db_key = this_db_key;
         SELECT curr_value INTO l_max_do_key 
            FROM do_seq WHERE db_key = this_db_key;
         IF l_max_do_key > l_high_do_key THEN
            UPDATE watermarks
               SET high_do_key = l_max_do_key
               WHERE db_key = this_db_key;
            commitChanges('rsWritewaterMarks, set high_do_key='||l_max_do_key);
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            NULL;
      END;
 
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         deb('rsWritewaterMarks: database with dbid=' || my_dbid ||
                                 ' not found in recovery catalog');
   END;
 
 
--
      v_xml := this_xml_signature_beg;
      FOR idx in 0..l_stmts  LOOP
         deb('writing XML file for ' || idx);
         deb('executing query:'|| record_sql(idx));
   
         v_ctx := DBMS_XMLGen.newContext(record_sql(idx));
 
--
         DBMS_XMLGen.setRowsetTag(v_ctx, 'TABLE_' || record_tbl(idx));
         v_xml_tmp := DBMS_XMLGen.GetXML(v_ctx);
         DBMS_XMLGen.closeContext(v_ctx);
 
         deb('XML len for ' || idx || '=' || DBMS_LOB.GETLENGTH(v_xml_tmp));
         IF v_xml_tmp IS NOT NULL THEN
            DBMS_LOB.COPY(v_xml, v_xml_tmp, DBMS_LOB.LOBMAXSIZE, 
                          DBMS_LOB.GETLENGTH(v_xml),
                          DBMS_LOB.INSTR(v_xml_tmp, 
                                     '<TABLE_' || record_tbl(idx) ||'>'));
         END IF;
      END LOOP;
      v_xml := v_xml || this_xml_signature_end;
 
--
      write_xml_filename := this_watermarks || my_dbid || '.xml';
      IF this_amazon_server THEN
         put_object(null /*bktname */, write_xml_filename, 'text/xml', v_xml);
      ELSE
         delete rcfile where name = write_xml_filename;
         insert into rcfile(rcfile_key, creation_time, name, xmldoc)
            values (rman_seq.nextval, sys_extract_utc(systimestamp), 
                    write_xml_filename, XMLType.createXML(v_xml));
      END IF;
 
--
      IF this_rsiterec.high_bp_recid >= 0 THEN
         deb('rsWritewaterMarks called for remote readBackupSections');
         writeBackupSections(input_xml_filename, bktname);
      ELSE
         deb('rsWritewaterMarks called for local readFixedSections');
      END IF;
 
--
      IF this_amazon_server THEN
         delete_object(null, this_forwatermarks || my_dbid || '.xml');
      ELSE
         delete rcfile where name = this_forwatermarks || my_dbid || '.xml';
      END IF;
 
      commitChanges('rsWritewaterMarks(suc)');
   EXCEPTION
      WHEN OTHERS THEN
         deb('rsWriteWatermarks(fail)- rollback (release locks):' || sqlerrm);
         rollback;
         raise;
END rsWriteWaterMarks;
 
PROCEDURE writeFixedSections(bktname IN VARCHAR2 DEFAULT NULL) IS
   v_ctx     DBMS_XMLGen.ctxHandle;
   v_xml     CLOB;
   v_xml_tmp CLOB;
   type record_sql_type is table of varchar2(2048) 
             index by binary_integer;
   type record_tbl_type is table of varchar2(30) 
             index by binary_integer;
   type record_watermarks_type is table of number 
             index by binary_integer;
   record_sql  record_sql_type;
   record_tbl  record_tbl_type;
   read_wm     record_watermarks_type;
   curr_wm     record_watermarks_type;
 
   my_dbid      number;
   write_xml_filename rcfile.name%TYPE;
 
   full_ckp_key      number;
   curr_dbinc_key    number;
   full_ckp_site_key number;
   noderec           node%ROWTYPE;
 
BEGIN
 
   deb('writeFixedSections - enter');
 
--
   IF this_server.server_host IS NULL THEN
      deb('writeFixedSections: this_server.server_host is null');
      return;
   END IF;
 
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'Database not set');
   END IF;
 
--
--
   BEGIN
      writeForWatermarks(bktname, TRUE);
      rsReadWaterMarks(bktname);
   EXCEPTION
      WHEN OTHERS THEN
         deb('writeFixedSections: error during watermarks read:' || sqlerrm);
         RAISE;
   END;
 
--
   BEGIN
      SELECT ckp_key, site_key INTO full_ckp_key, full_ckp_site_key
         FROM RC_CHECKPOINT
         WHERE CKP_KEY =
            (SELECT MAX(CKP_KEY) FROM RC_CHECKPOINT 
               WHERE DB_KEY = this_db_key 
               AND CKP_TYPE = 'FULL');
   EXCEPTION
      WHEN no_data_found THEN
         deb('writeFixedSections: no full resync yet done for this database');
         return;
   END;
 
   SELECT dbinc_key INTO curr_dbinc_key FROM RC_DATABASE
      WHERE DB_KEY = this_db_key;
 
   SELECT * INTO noderec FROM NODE WHERE SITE_KEY=full_ckp_site_key;
   deb('noderec.cf_version_stamp: ' || noderec.cf_create_time);
   deb('noderec.db_unique_name: ' || noderec.db_unique_name);
   deb('noderec.high_df_recid: ' || noderec.high_df_recid);
   deb('noderec.high_tf_recid: ' || noderec.high_tf_recid);
   deb('noderec.high_ts_recid: ' || noderec.high_ts_recid);
   select nvl(max(offr_key), 0) INTO noderec.high_offr_recid 
      from rc_offline_range where db_key=this_db_key;
   deb('noderec.high_offr_recid: ' || noderec.high_offr_recid);
 
--
   IF noderec.cf_create_time = this_wmrec.cf_version_stamp AND
      noderec.high_ts_recid = this_wmrec.high_ts_recid AND
      noderec.high_df_recid = this_wmrec.high_df_recid AND
      noderec.high_tf_recid = this_wmrec.high_tf_recid AND
      noderec.high_offr_recid = this_wmrec.high_offr_recid THEN
     deb('writeFixedSections: No event of interest occured at catalog');
     return;
   END IF;
 
   IF noderec.cf_create_time <> this_wmrec.cf_version_stamp OR
      this_wmrec.cf_version_stamp IS NULL THEN
      deb('Clearing fixed record section watermarks');
      this_wmrec.high_df_recid := NULL;
      this_wmrec.high_ts_recid := NULL;
      this_wmrec.high_tf_recid := NULL;
      this_wmrec.high_offr_recid := NULL;
   END IF;
 
   SELECT DBID INTO MY_DBID FROM RC_DATABASE WHERE DB_KEY=this_db_key;
 
   record_tbl(0)   := 'RC_DATABASE';
   record_sql(0)   := 'SELECT * FROM RC_DATABASE ' || 
                         'WHERE DB_KEY = ' || this_db_key;
   read_wm(0)      := -1; /* no watermark check for this record */
 
   record_tbl(1)   := 'RC_DATABASE_INCARNATION';
   record_sql(1)   := 'SELECT * FROM RC_DATABASE_INCARNATION ' ||
                         'WHERE DB_KEY = ' || this_db_key;
   read_wm(1)      := -1; /* no watermark check for this record */
 
   record_tbl(2)   := 'RC_SITE';
   record_sql(2)   := 'SELECT * FROM RCI_SITE ' ||
                         'WHERE DB_KEY   = ' || this_db_key ||
                         '  AND SITE_KEY = ' || full_ckp_site_key;
   read_wm(2)      := -1; /* no watermark check for this record */
 
   record_tbl(3)   := 'RC_RMAN_CONFIGURATION';
   record_sql(3)   := 'SELECT * FROM RC_RMAN_CONFIGURATION ' ||
                         'WHERE DB_KEY   = ' || this_db_key ||
                         '  AND (SITE_KEY = ' || full_ckp_site_key ||
                         '       OR SITE_KEY = 0)';
   read_wm(3)      := -1; /* no watermark check for this record */
 
   record_tbl(4)   := 'RC_TABLESPACE';
   record_sql(4)   := 'SELECT * FROM RC_TABLESPACE ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND DBINC_KEY = ' || curr_dbinc_key ||
                         '  AND DROP_CHANGE# IS NULL';
   read_wm(4)      := -1; /* watermark check only if required */
   IF this_wmrec.cf_version_stamp = noderec.cf_create_time THEN
      read_wm(4)      := this_wmrec.high_ts_recid;
      curr_wm(4)      := noderec.high_ts_recid;
   END IF;
 
   record_tbl(5)   := 'RC_REDO_THREAD';
   record_sql(5)   := 'SELECT * FROM RC_REDO_THREAD ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND DBINC_KEY = ' || curr_dbinc_key;
   read_wm(5)      := -1; /* no watermark check for this record */
 
   record_tbl(6)   := 'RCI_DATAFILE';
   record_sql(6)   := 'SELECT * FROM RCI_DATAFILE ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND DBINC_KEY = ' || curr_dbinc_key ||
                         '  AND SITE_KEY = ' || full_ckp_site_key ||
                         '  AND DROP_CHANGE# IS NULL';
   read_wm(6)      := -1; /* watermark check only if required */
   IF this_wmrec.cf_version_stamp = noderec.cf_create_time THEN
      read_wm(6)      := this_wmrec.high_df_recid;
      curr_wm(6)      := noderec.high_df_recid;
   END IF;
 
   record_tbl(7)   := 'RCI_TEMPFILE';
   record_sql(7)   := 'SELECT * FROM RCI_TEMPFILE ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND DBINC_KEY = ' || curr_dbinc_key ||
                         '  AND SITE_KEY = ' || full_ckp_site_key ||
                         '  AND DROP_CHANGE# IS NULL';
   read_wm(7)      := -1; /* watermark check only if required */
   IF this_wmrec.cf_version_stamp = noderec.cf_create_time THEN
      read_wm(7)      := this_wmrec.high_tf_recid;
      curr_wm(7)      := noderec.high_tf_recid;
   END IF;
 
   record_tbl(8)   := 'RC_REDO_LOG';
   record_sql(8)   := 'SELECT * FROM RC_REDO_LOG ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND DBINC_KEY = ' || curr_dbinc_key ||
                         '  AND SITE_KEY = ' || full_ckp_site_key;
   read_wm(8)      := -1; /* no watermark check for this record */
 
   record_tbl(9)   := 'RC_CHECKPOINT';
   record_sql(9)   := 'SELECT * FROM RC_CHECKPOINT ' ||
                         'WHERE CKP_KEY = ' || full_ckp_key;
   read_wm(9)      := -1; /* no watermark check for this record */
 
   record_tbl(10)  := 'RC_OFFLINE_RANGE';
   record_sql(10)  := 'SELECT * FROM RC_OFFLINE_RANGE ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND OFFR_KEY >'||nvl(this_wmrec.high_offr_recid,0);
   read_wm(10)     := -1; /* watermark check not required, send new records */
 
   record_tbl(11)   := 'RCI_PDBS';
   record_sql(11)   := 'SELECT * FROM RCI_PDBS ' || 
                         'WHERE DB_KEY = ' || this_db_key;
   read_wm(11)      := -1; /* no watermark check for this record */
 
   record_tbl(12)   := 'RC_PLUGGABLE_DATABASE_INC';
   record_sql(12)   := 'SELECT * FROM RC_PLUGGABLE_DATABASE_INC ' ||
                         'WHERE DB_KEY = ' || this_db_key;
   read_wm(12)      := -1; /* no watermark check for this record */
 
   record_tbl(13)   := 'RCI_RA_UPSTREAM_DATABASE';
   record_sql(13)   := 'SELECT * FROM RCI_RA_UPSTREAM_DATABASE';
   read_wm(13)      := -1; /* no watermark check for this record */
 
--
   v_xml := this_xml_signature_beg;
   dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
   FOR idx in 0..13 LOOP
      deb('writing XML file for ' || idx);
      IF read_wm (idx) <> -1 AND read_wm(idx) <> 0 AND 
         read_wm(idx) = curr_wm(idx) THEN
         deb('skipping query:'|| record_sql(idx));
      ELSE
         deb('executing query:'|| record_sql(idx));
         v_ctx := DBMS_XMLGen.newContext(record_sql(idx));
 
--
         DBMS_XMLGen.setRowsetTag(v_ctx, 'TABLE_' || record_tbl(idx));
         v_xml_tmp := DBMS_XMLGen.GetXML(v_ctx);
         DBMS_XMLGen.closeContext(v_ctx);
 
         deb('XML len for ' || idx || '=' || DBMS_LOB.GETLENGTH(v_xml_tmp));
         IF v_xml_tmp IS NOT NULL THEN
            DBMS_LOB.COPY(v_xml, v_xml_tmp, DBMS_LOB.LOBMAXSIZE, 
                          DBMS_LOB.GETLENGTH(v_xml),
                          DBMS_LOB.INSTR(v_xml_tmp, 
                                     '<TABLE_' || record_tbl(idx) ||'>'));
         END IF;
      END IF;
   END LOOP;
 
   deb('XML len for v_wmrec=' || DBMS_LOB.GETLENGTH(this_v_wmrec));
   IF this_v_wmrec IS NOT NULL THEN
            DBMS_LOB.COPY(v_xml, this_v_wmrec, DBMS_LOB.LOBMAXSIZE, 
                          DBMS_LOB.GETLENGTH(v_xml),
                          DBMS_LOB.INSTR(this_v_wmrec, 
                                     '<TABLE_RC_WATERMARKS>'));
   ELSE
      deb('writeFixedSections: no watermarks added to uploaded file');
   END IF;
 
   v_xml := v_xml || this_xml_signature_end;
 
--
   write_xml_filename := this_database || my_dbid || '.xml';
   put_bucket(bktname);
   put_object(bktname, write_xml_filename, 'text/xml', v_xml);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
  
   deb('writeFixedSections:(suc)');
END writeFixedSections;
 
--
PROCEDURE readFixedSections(input_xml_filename  IN VARCHAR2,
                            bktname IN VARCHAR2 DEFAULT NULL) IS
 
   ckp_type     NUMBER;
 
   database_already_registered EXCEPTION;
   PRAGMA EXCEPTION_INIT(database_already_registered, -20002);
 
   incarnation_already_registered EXCEPTION;
   PRAGMA EXCEPTION_INIT(incarnation_already_registered, -20009);
 
   resync_not_needed EXCEPTION;
   PRAGMA EXCEPTION_INIT(resync_not_needed, -20034);
 
   local_wmrec  RC_WATERMARKS%ROWTYPE;
   wmrec  RC_WATERMARKS%ROWTYPE;
   CURSOR rc_watermarks_c IS
   SELECT DB_KEY,
          DB_UNIQUE_NAME,
          RS_VERSION_STAMP,
          HIGH_BP_RECID,
          HIGH_DO_KEY,
          CF_VERSION_STAMP,
          HIGH_DF_RECID,
          HIGH_TS_RECID,
          HIGH_TF_RECID,
          HIGH_OFFR_RECID
   FROM "_RS_RC_WATERMARKS_"
   WHERE RS_RCFILE_NAME = input_xml_filename;
 
   local_siterec RC_SITE%ROWTYPE;
   siterec RC_SITE%ROWTYPE;
   CURSOR rc_site_c IS
   SELECT  SITE_KEY,
           DB_KEY,
           DATABASE_ROLE,
           CF_CREATE_TIME,
           DB_UNIQUE_NAME,
           HIGH_CONF_RECID,
           FORCE_RESYNC2CF,
           HIGH_ROUT_STAMP,
           INST_STARTUP_STAMP,
           LAST_KCCDIVTS,
           HIGH_IC_RECID,
           DBINC_KEY,
           CKP_SCN,
           FULL_CKP_CF_SEQ,
           JOB_CKP_CF_SEQ,
           HIGH_TS_RECID,
           HIGH_DF_RECID,
           HIGH_RT_RECID,
           HIGH_ORL_RECID,
           HIGH_OFFR_RECID,
           HIGH_RLH_RECID,
           HIGH_AL_RECID,
           HIGH_BS_RECID,
           HIGH_BP_RECID,
           HIGH_BDF_RECID,
           HIGH_CDF_RECID,
           HIGH_BRL_RECID,
           HIGH_BCB_RECID,
           HIGH_CCB_RECID,
           HIGH_DO_RECID,
           HIGH_PC_RECID,
           HIGH_BSF_RECID,
           HIGH_RSR_RECID,
           HIGH_TF_RECID,
           HIGH_GRSP_RECID,
           HIGH_NRSP_RECID,
           HIGH_BCR_RECID,
           LOW_BCR_RECID,
           BCR_IN_USE,
           HIGH_PDB_RECID,
           HIGH_PIC_RECID
   FROM "_RS_RC_SITE_"
   WHERE RS_RCFILE_NAME = input_xml_filename;
 
   upstream_dbrec rci_ra_upstream_database%ROWTYPE;
   CURSOR rci_ra_upstream_database_c IS
   SELECT  DBID,
           NAME
   FROM "_RS_RCI_RA_UPSTREAM_DATABASE_"
   WHERE RS_RCFILE_NAME = input_xml_filename;
 
   icrec    RC_DATABASE_INCARNATION%ROWTYPE;
   curr_inc RC_DATABASE_INCARNATION%ROWTYPE;
   CURSOR rc_database_incarnation_c(curr_inc_val IN VARCHAR2 DEFAULT NULL) IS
   SELECT DB_KEY, 
          DBID, 
          DBINC_KEY,  
          NAME, 
          RESETLOGS_CHANGE#, 
          RESETLOGS_TIME,
          CURRENT_INCARNATION,
          PARENT_DBINC_KEY, 
          PRIOR_RESETLOGS_CHANGE#,
          PRIOR_RESETLOGS_TIME,
          STATUS,
          REG_DB_UNIQUE_NAME,
          CON_ID,
          GUID
   FROM "_RS_RC_DATABASE_INCARNATION_"
   WHERE RS_RCFILE_NAME = input_xml_filename
     AND (curr_inc_val IS NULL OR
          CURRENT_INCARNATION = curr_inc_val)
   ORDER BY RESETLOGS_CHANGE#;
   
   tbsrec RC_TABLESPACE%ROWTYPE;
   CURSOR rc_tablespace_c IS
   SELECT DB_KEY, 
          DBINC_KEY,
          DB_NAME,
          CON_ID,
          PDB_NAME,
          PDB_KEY,
          PDBINC_KEY,
          TS#, 
          NAME,
          CREATION_CHANGE#,
          CREATION_TIME,
          DROP_CHANGE#,
          DROP_TIME,
          INCLUDED_IN_DATABASE_BACKUP,
          BIGFILE,
          TEMPORARY,
          ENCRYPT_IN_BACKUP,
          PLUGIN_CHANGE#
   FROM "_RS_RC_TABLESPACE_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY CON_ID, TS#;
 
   dfrec RCI_DATAFILE%ROWTYPE;
   CURSOR rci_datafile_c IS
   SELECT  DB_KEY,
           DBINC_KEY,
           DB_NAME,
           CON_ID,
           PDB_NAME,
           PDB_KEY,
           PDB_CLOSED,
           PDBINC_KEY,
           TS#,
           TABLESPACE_NAME,
           FILE#,
           CREATION_CHANGE#,
           CREATION_TIME,
           DROP_CHANGE#,
           DROP_TIME,
           BYTES,
           BLOCKS,
           BLOCK_SIZE,
           NAME,
           STOP_CHANGE#,
           STOP_TIME,
           READ_ONLY,
           RFILE#,
           INCLUDED_IN_DATABASE_BACKUP,
           AUX_NAME,
           ENCRYPT_IN_BACKUP,
           SITE_KEY,
           DB_UNIQUE_NAME,
           FOREIGN_DBID,
           FOREIGN_CREATION_CHANGE#,
           FOREIGN_CREATION_TIME,
           PLUGGED_READONLY,
           PLUGIN_CHANGE#,
           PLUGIN_RESETLOGS_CHANGE#,
           PLUGIN_RESETLOGS_TIME,
           CREATION_THREAD,
           CREATION_SIZE,
           PDB_FOREIGN_DBID,
           PDB_NOBACKUP
   FROM "_RS_RCI_DATAFILE_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY FILE#;
 
   tfrec RCI_TEMPFILE%ROWTYPE;
   CURSOR rci_tempfile_c IS 
   SELECT  DB_KEY,
           DBINC_KEY,
           DB_NAME,
           CON_ID,
           PDB_NAME,
           PDB_KEY,
           TS#,
           TABLESPACE_NAME,
           FILE#,
           CREATION_CHANGE#,
           CREATION_TIME,
           DROP_CHANGE#,
           DROP_TIME,
           BYTES,
           BLOCKS,
           BLOCK_SIZE,
           NAME,
           RFILE#,
           AUTOEXTEND,
           MAXSIZE,
           NEXTSIZE,
           BIGFILE,
           SITE_KEY,
           DB_UNIQUE_NAME,
           TABLESPACE_CREATION_CHANGE#,
           TABLESPACE_CREATION_TIME,
           TABLESPACE_DROP_CHANGE#,
           TABLESPACE_DROP_TIME
   FROM "_RS_RCI_TEMPFILE_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY FILE#;
 
   rtrec RC_REDO_THREAD%ROWTYPE;
   CURSOR rc_redo_thread_c IS 
   SELECT  DB_KEY,
           DBINC_KEY,
           DB_NAME,
           THREAD#,
           STATUS,
           SEQUENCE#,
           ENABLE_CHANGE#,
           ENABLE_TIME,
           DISABLE_CHANGE#,
           DISABLE_TIME
   FROM "_RS_RC_REDO_THREAD_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY THREAD#;
 
   orlrec RC_REDO_LOG%ROWTYPE;
   CURSOR rc_redo_log_c IS 
   SELECT  DB_KEY,
           DBINC_KEY,
           DB_NAME,
           THREAD#,
           GROUP#,
           NAME,
           SITE_KEY,
           BYTES,
           TYPE
   FROM "_RS_RC_REDO_LOG_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY NAME;
 
   ckprec RC_CHECKPOINT%ROWTYPE;
   CURSOR rc_checkpoint_c IS 
   SELECT  DB_KEY,
           DBINC_KEY,
           DB_NAME,
           CKP_KEY,
           CKP_SCN,
           CKP_CF_SEQ,
           CKP_TIME,
           CKP_TYPE,
           CKP_DB_STATUS,
           SITE_KEY
   FROM "_RS_RC_CHECKPOINT_"
   WHERE RS_RCFILE_NAME = input_xml_filename;
 
   offrrec RC_OFFLINE_RANGE%ROWTYPE;
   CURSOR rc_offline_range_c IS 
   SELECT  DB_KEY,
           DBINC_KEY,
           DB_NAME,
           RECID,
           STAMP,
           FILE#,
           CREATION_CHANGE#,
           OFFLINE_CHANGE#,
           ONLINE_CHANGE#,
           ONLINE_TIME,
           CF_CREATE_TIME,
           RESETLOGS_CHANGE#,
           RESETLOGS_TIME,
           OFFR_KEY
   FROM "_RS_RC_OFFLINE_RANGE_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY OFFR_KEY;
 
   pdbrec  RCI_PDBS%ROWTYPE;
   CURSOR rci_pdbs_c IS 
   SELECT PDB_KEY,
          DB_KEY,
          NAME,
          CON_ID,
          DBID,
          CREATION_CHANGE#,
          GUID,
          NOBACKUP
   FROM "_RS_RCI_PDBS_"
   WHERE RS_RCFILE_NAME = input_xml_filename;
 
   picrec1 RC_PLUGGABLE_DATABASE_INC%ROWTYPE;
   CURSOR rc_pluggable_database_inc_c IS 
   SELECT PDB_KEY,
          NAME,
          CON_ID,
          DBID,
          GUID,
          CREATE_SCN,
          PDBINC_KEY,
          DB_KEY,
          CURRENT_INCARNATION,
          INCARNATION_SCN,
          BEGIN_RESETLOGS_SCN,
          BEGIN_RESETLOGS_TIME,
          END_RESETLOGS_SCN,
          DBINC_KEY,
          DB_RESETLOGS_SCN,
          DB_RESETLOGS_TIME,
          PRIOR_PDBINC_KEY,
          PRIOR_INCARNATION_SCN,
          PRIOR_BEGIN_RESETLOGS_SCN,
          PRIOR_BEGIN_RESETLOGS_TIME,
          PRIOR_END_RESETLOGS_SCN,
          PRIOR_DBINC_KEY,
          PRIOR_DB_RESETLOGS_SCN,
          PRIOR_DB_RESETLOGS_TIME,
          STATUS
   FROM "_RS_RC_PLUGGABLE_DATABASE_INC_"
   WHERE RS_RCFILE_NAME = input_xml_filename
   ORDER BY PDBINC_KEY;
 
   offr_key              NUMBER;
   parent_dbinc_key      NUMBER;
   dbid                  NUMBER;
   foundrec              BOOLEAN;
   newincarnation        BOOLEAN := FALSE;
   loc_db_key            NUMBER;
   cdb_mode              NUMBER;
   last_full_ckp_scn     NUMBER;
   local_dbincrec        RC_DATABASE_INCARNATION%ROWTYPE;
 
BEGIN
 
   deb('readFixedSections - enter');
 
--
   dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
 
--
   dbid := to_number(substr(input_xml_filename,length(this_database)+1, 
                    instr(input_xml_filename,'.xml')-1-length(this_database)));
 
   deb('readFixedSections: dbid=' || dbid);
 
--
   OPEN rc_watermarks_c;
   LOOP
      FETCH rc_watermarks_c INTO wmrec;
      EXIT WHEN rc_watermarks_c%NOTFOUND;
   END LOOP;
   CLOSE rc_watermarks_c;
   IF debug THEN
      displayRCWatermarks('readFixedSections remote:', wmrec);
   END IF;
 
--
   OPEN rc_site_c;
   FETCH rc_site_c INTO siterec;
   CLOSE rc_site_c;
   IF debug THEN
      displayRCSite('readFixedSections:remote ', siterec);
   END IF;
 
--
   OPEN rci_ra_upstream_database_c;
   FETCH rci_ra_upstream_database_c INTO upstream_dbrec;
   CLOSE rci_ra_upstream_database_c;
   this_upstream_dbrec := upstream_dbrec;
   deb('readFixedSections: upstream dbname=' || this_upstream_dbrec.name ||
       'reconcile dbname' || siterec.db_unique_name);
 
--
   OPEN rc_database_incarnation_c(curr_inc_val => 'YES');
   FETCH rc_database_incarnation_c INTO curr_inc;
   CLOSE rc_database_incarnation_c;
   IF debug THEN
      displayRCDatabaseIncarnation('readFixedSections: remote ', curr_inc);
   END IF;
 
--
   OPEN rc_checkpoint_c;
   FETCH rc_checkpoint_c INTO ckprec;
   CLOSE rc_checkpoint_c;
 
--
   IF curr_inc.dbid IS NULL THEN
      raise_application_error(-20999, 'internal error: no rows for curr_inc');
   END IF;
 
--
   IF curr_inc.dbid <> readFixedSections.dbid THEN
      raise_application_error(-20141, 
                 'Target database id mismatch with registered database in ORS');
   END IF;
 
--
   BEGIN
      registerDatabase(db_id => curr_inc.dbid,
                       db_name => curr_inc.name,
                       reset_scn => curr_inc.resetlogs_change#,
                       reset_time => curr_inc.resetlogs_time,
                       db_unique_name => curr_inc.reg_db_unique_name,
                       con_id => curr_inc.con_id,
                       guid => curr_inc.guid);
     deb('readFixedSections: registered dbname=' || siterec.db_unique_name);
   EXCEPTION
      WHEN database_already_registered THEN
         deb('database already registered');
         NULL;
     WHEN no_data_found THEN
         deb('database has yet to be added via add_db, dbuname=' || 
             siterec.db_unique_name);
         raise_application_error(-20140, 'Database not yet registered in ORS');
   END;
 
--
--
--
   BEGIN
      SELECT * INTO local_dbincrec
         FROM rc_database_incarnation
         WHERE dbid = dbid 
           AND resetlogs_change# = curr_inc.resetlogs_change#
           AND resetlogs_time = curr_inc.resetlogs_time;
      IF local_dbincrec.status = 'CURRENT' THEN
--
--
         SELECT max(ckp_scn) INTO last_full_ckp_scn
            FROM ckp
            WHERE ckp_type = 'FULL'
              AND dbinc_key = local_dbincrec.dbinc_key;
         IF last_full_ckp_scn > ckprec.ckp_scn THEN
            deb('readFixedSections (wait):Downstream ahead of upstream');
            RETURN;
         END IF;
      ELSE
--
--
--
--
         deb('readFixedSections: Upstream is in a different incarnation');
         IF debug THEN
            displayRCDatabaseIncarnation('readFixedSections: local ',
                                          local_dbincrec);
         END IF;
         IF local_dbincrec.status = 'ORPHAN' THEN
            deb('readFixedSections: local incarnation is orphan');
         ELSE
            deb('readFixedSections (wait): Let upstream catchup');
            RETURN;
         END IF;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         deb('readFixedSections: New incarnation in upstream');
         IF debug THEN
            displayRCDatabaseIncarnation('readFixedSections: remote ',
                                          curr_inc);
         END IF;
   END;
 
--
   BEGIN
      resetDatabase(db_id => curr_inc.dbid,
                    db_name => curr_inc.name,
                    reset_scn => curr_inc.resetlogs_change#,
                    reset_time => curr_inc.resetlogs_time,
                    parent_reset_scn => curr_inc.prior_resetlogs_change#,
                    parent_reset_time => curr_inc.prior_resetlogs_time);
      deb('readFixedSections: registered newinc ' || siterec.db_unique_name);
      newincarnation := TRUE;
   EXCEPTION
      WHEN incarnation_already_registered THEN
         deb('database incarnation already known');
         NULL;
   END;
 
--
--
   curr_inc.dbinc_key :=
      resetDatabase(db_id => curr_inc.dbid,
                    db_name => curr_inc.name,
                    reset_scn => curr_inc.resetlogs_change#,
                    reset_time => curr_inc.resetlogs_time,
                    parent_reset_scn => curr_inc.prior_resetlogs_change#,
                    parent_reset_time => curr_inc.prior_resetlogs_time);
 
   deb('current dbinc_key = ' || curr_inc.dbinc_key);
 
--
   IF this_upstream_dbrec.name IS NULL THEN
      raise_application_error(-20999, 'internal error: no rows for upstreamdb');
   END IF;
   IF siterec.site_key IS NULL THEN
      raise_application_error(-20999, 'internal error: no rows for siterec');
   END IF;
 
   setDatabase(db_name => curr_inc.name,
               reset_scn => curr_inc.resetlogs_change#,
               reset_time => curr_inc.resetlogs_time,
               db_id => curr_inc.dbid,
               db_unique_name => 
                        this_upstream_dbrec.name||'$'||siterec.db_unique_name,
               dummy_instance => FALSE,
               cf_type => CF_STANDBY,
               site_aware => TRUE,
               ors_instance => TRUE);
 
--
   IF newincarnation THEN
      deb('Clearing watermarks at catalog');
      UPDATE watermarks SET
         high_df_recid = 0,
         high_ts_recid = 0,
         high_tf_recid = 0,
         high_offr_recid = 0,
         cf_version_stamp = null
      WHERE db_key = this_db_key;
      UPDATE node SET
         high_df_recid = 0,
         high_ts_recid = 0,
         high_tf_recid = 0,
         high_offr_recid = 0
      WHERE db_key = this_db_key
        AND site_key = this_site_key;
      commitChanges('readFixedSections-1');
   END IF;
 
   select * into local_siterec from rci_site 
      where db_key = this_db_key
        and site_key = this_site_key;
   displayRCSite('readFixedSections:local ', local_siterec);
 
--
--
--
   BEGIN
      SELECT db_key, db_unique_name, rs_version_stamp, high_bp_recid, 
             high_do_key, cf_version_stamp, high_df_recid, high_ts_recid, 
             high_tf_recid, high_offr_recid 
         INTO local_wmrec 
         FROM watermarks 
         WHERE db_key = this_db_key;
      IF debug THEN
         displayRCWatermarks('readFixedSections:local ', local_wmrec);
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         deb('readFixedSections:database with db_key=' || this_db_key ||
                                 ' no watermarks set yet');
   END;
 
--
--
--
   IF local_siterec.last_kccdivts = 0 THEN
      local_siterec.last_kccdivts := date2stamp(local_wmrec.cf_version_stamp);
      update node set last_kccdivts = local_siterec.last_kccdivts,
                      cf_create_time = local_wmrec.cf_version_stamp,
                      high_ts_recid = local_wmrec.high_ts_recid,
                      high_df_recid = local_wmrec.high_df_recid,
                      high_tf_recid = local_wmrec.high_tf_recid,
                      high_offr_recid = local_wmrec.high_offr_recid,
                      high_bp_recid = local_wmrec.high_bp_recid,
                      high_do_recid = local_wmrec.high_do_key
         where db_key = this_db_key
           and site_key = this_site_key;
      commitChanges('readFixedSections-2');
 
      select * into local_siterec from rci_site 
         where db_key = this_db_key
           and site_key = this_site_key;
      displayRCSite('readFixedSections:local,re-fetch ', local_siterec);
   END IF;
 
   deb('CRossed  from watermarks');
 
--
--
--
   IF wmrec.rs_version_stamp is not null AND
      local_wmrec.rs_version_stamp <> wmrec.rs_version_stamp THEN
      raise_application_error(-20142, 
         'The version stamp of backup XML set is different');
   END IF;
 
--
--
   lockForCkpt;
   ckp_type := ckptNeeded(ckp_scn => siterec.ckp_scn,
                          ckp_cf_seq => siterec.full_ckp_cf_seq,
                          cf_version => stamp2date(siterec.last_kccdivts),
                          cf_type => CF_CURRENT,
                          high_df_recid => siterec.high_df_recid,
                          high_orl_recid => siterec.high_orl_recid,
                          high_cdf_recid => NULL,
                          high_al_recid => NULL,
                          high_bp_recid => NULL,
                          high_do_recid => NULL,
                          high_offr_recid => siterec.high_offr_recid,
                          high_pc_recid => NULL,
                          high_conf_recid => siterec.high_conf_recid,
                          rltime => curr_inc.resetlogs_time,
                          high_ts_recid => siterec.high_ts_recid,
                          high_bs_recid => NULL,
                          lopen_reset_scn => NULL,
                          lopen_reset_time => NULL,
                          high_ic_recid => siterec.high_ic_recid,
                          high_tf_recid => siterec.high_tf_recid,
                          high_rt_recid => siterec.high_rt_recid,
                          high_grsp_recid => NULL,
                          high_nrsp_recid => NULL,
                          high_bcr_recid => NULL,
                          high_pdb_recid => siterec.high_pdb_recid,
                          high_pic_recid => siterec.high_pic_recid);
 
   IF ckp_type <> RESYNC_FULL AND ckp_type <> RESYNC_PARTIAL THEN
      deb('readFixedSections (abort) - ckptNeeded returned ' || ckp_type);
      cancelCkpt;
      return;
   END IF;
 
   BEGIN
      beginCkpt(ckp_scn => siterec.ckp_scn,
                ckp_cf_seq => siterec.full_ckp_cf_seq,
                cf_version => stamp2date(siterec.last_kccdivts),
                ckp_time => ckprec.ckp_time,
                ckp_type => 'FULL',
                ckp_db_status => ckprec.ckp_db_status,
                high_df_recid => siterec.high_df_recid,
                cf_type => 'CURRENT');
   EXCEPTION
      WHEN resync_not_needed THEN
         deb('readFixedSections (abort) - resync not needed ' || ckp_type);
         return;
   END;
 
   deb('readFixedSections: have records to read ' || siterec.db_unique_name);
 
--
   foundrec := FALSE;
   IF beginPluggableDBResync(siterec.high_pdb_recid) then
      OPEN rci_pdbs_c;
      LOOP
         FETCH rci_pdbs_c INTO pdbrec;
         EXIT WHEN rci_pdbs_c%NOTFOUND;
 
         deb('Calling checkPluggableDB name=' ||
              pdbrec.name || ' dbid=' || pdbrec.dbid);
         checkPluggableDB(pdbrec.name, pdbrec.con_id, pdbrec.dbid,
                          pdbrec.creation_change#, pdbrec.guid,
                          pdbrec.nobackup);
         foundrec := TRUE;
      END LOOP;
      CLOSE rci_pdbs_c;
      endPluggableDBResync;
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20150, 
                'no records found to resync for plugged databases');
      END IF;
   END IF;
 
--
   foundrec := FALSE;
   newincarnation := FALSE;
   IF siterec.high_ic_recid > beginIncarnationResync(return_recid => TRUE) THEN
      OPEN rc_database_incarnation_c;
      LOOP
         FETCH rc_database_incarnation_c INTO icrec;
         EXIT WHEN rc_database_incarnation_c%NOTFOUND;
 
         deb('Calling checkIncarnation from readfixedsection');
         parent_dbinc_key :=
             dbms_rcvcat.checkIncarnation(icrec.resetlogs_change#,
                                          icrec.resetlogs_time,
                                          icrec.prior_resetlogs_change#,
                                          icrec.prior_resetlogs_time,
                                          icrec.name);
         foundrec := TRUE;
         newincarnation := TRUE;
      END LOOP;
      CLOSE rc_database_incarnation_c;
      endIncarnationResync(siterec.last_kccdivts, siterec.high_ic_recid);
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20143, 
                'no records found to resync for incarnation view');
      END IF;
   END IF;
 
--
--
   SELECT count(*) INTO cdb_mode FROM pdb 
   WHERE con_id >= 1 
     AND db_key = this_db_key;
  
--
   foundrec := FALSE;
   IF ((cdb_mode > 0) AND 
       (siterec.high_pic_recid > beginPluggableDbincResync OR
        newincarnation)) THEN
      OPEN rc_pluggable_database_inc_c;
      LOOP
       FETCH rc_pluggable_database_inc_c INTO picrec1;
         EXIT WHEN rc_pluggable_database_inc_c%NOTFOUND;
  
         deb('Calling checkPluggableDbinc for record' ||
             ' pdbname= ' || picrec1.name ||
             ' dbid=' || picrec1.dbid ||
             ' curr=' || picrec1.current_incarnation ||
             ' inc_scn=' || picrec1.incarnation_scn ||
             ' end_reset_scn=' || picrec1.end_resetlogs_scn ||
             ' pr_inc_scn=' || nvl(picrec1.prior_incarnation_scn, '') ||
             ' pr_reset_scn=' || nvl(picrec1.prior_end_resetlogs_scn, ''));
         checkPluggableDbinc(
            NULL, picrec1.guid,
            picrec1.current_incarnation, picrec1.incarnation_scn,
            picrec1.begin_resetlogs_scn, picrec1.begin_resetlogs_time,
            picrec1.end_resetlogs_scn, picrec1.db_resetlogs_scn,
            picrec1.db_resetlogs_time, picrec1.prior_incarnation_scn,
            picrec1.prior_end_resetlogs_scn, picrec1.prior_db_resetlogs_scn,
            picrec1.prior_db_resetlogs_time, FALSE);
         foundrec := TRUE;
      END LOOP;
      CLOSE rc_pluggable_database_inc_c;
      endPluggableDbincResync(siterec.high_pic_recid);
  
      IF NOT foundrec THEN
--
--
         raise_application_error(-20151, 
                'no records found to resync for pluggable db incarnation view');
      END IF;
   END IF;
 
--
   foundrec := FALSE;
   IF beginTableSpaceResync(siterec.high_ts_recid, FALSE) THEN
      OPEN rc_tablespace_c;
      LOOP
         FETCH rc_tablespace_c INTO tbsrec;
         EXIT WHEN rc_tablespace_c%NOTFOUND;
 
--
--
         deb('Calling checkTableSpace');
         checkTableSpace(tbsrec.name, tbsrec.ts#, tbsrec.creation_change#,
                         tbsrec.creation_time, 0 /* rbs_count not populated */,
                         tbsrec.included_in_database_backup, tbsrec.bigfile,
                         tbsrec.temporary, tbsrec.encrypt_in_backup,
                         tbsrec.plugin_change#, tbsrec.con_id, FALSE);
         foundrec := TRUE;
      END LOOP;
      CLOSE rc_tablespace_c;
      endTableSpaceResync;
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20144, 
                'no records found to resync for tablespace view');
      END IF;
   END IF;
 
--
   foundrec := FALSE;
   IF beginDataFileResync(siterec.high_df_recid) THEN
      OPEN rci_datafile_c;
      LOOP
         FETCH rci_datafile_c INTO dfrec;
         EXIT WHEN rci_datafile_c%NOTFOUND;
 
         checkDataFile(
            file#               => dfRec.file#,
            fname               => dfRec.name,
            create_scn          => dfRec.creation_change#,
            create_time         => dfRec.creation_time,
            blocks              => dfRec.blocks,
            block_size          => dfRec.block_size,
            ts#                 => dfRec.ts#,
            stop_scn            => dfRec.stop_change#,
            read_only           => dfRec.read_only,
            stop_time           => dfRec.stop_time,
            rfile#              => dfRec.rfile#,
            aux_fname           => dfRec.aux_name,
            foreign_dbid        => dfRec.foreign_dbid,
            foreign_create_scn  => dfRec.foreign_creation_change#,
            foreign_create_time => dfRec.foreign_creation_time,
            plugged_readonly    => dfRec.plugged_readonly,
            plugin_scn          => dfRec.plugin_change#,
            plugin_reset_scn    => dfRec.plugin_resetlogs_change#,
            plugin_reset_time   => dfRec.plugin_resetlogs_time,
            create_thread       => dfRec.creation_thread,
            create_size         => dfRec.creation_size,
            con_id              => dfRec.con_id,
            pdb_closed          => dfRec.pdb_closed,
            pdb_dict_check      => FALSE,
            pdb_foreign_dbid    => dfRec.pdb_foreign_dbid);
 
         foundrec := TRUE;
      END LOOP;
      CLOSE rci_datafile_c;
      endDataFileResync;
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20145, 
                'no records found to resync for datafile view');
      END IF;
   END IF;
 
--
--
   foundrec := FALSE;
   IF beginTempFileResync(siterec.high_tf_recid) THEN
      OPEN rci_tempfile_c;
      LOOP
         FETCH rci_tempfile_c INTO tfrec;
         EXIT WHEN rci_tempfile_c%NOTFOUND;
 
         checkTempFile(
            file#          => tfrec.file#,
            fname          => tfrec.name,
            create_scn     => tfrec.creation_change#,
            create_time    => tfrec.creation_time,
            blocks         => tfrec.blocks,
            block_size     => tfrec.block_size,
            ts#            => tfrec.ts#,
            rfile#         => tfrec.rfile#,
            autoextend     => tfrec.autoextend,
            max_size       => tfrec.maxsize,
            next_size      => tfrec.nextsize,
            con_id         => tfrec.con_id,
            pdb_dict_check => FALSE);
         foundrec := TRUE;
 
      END LOOP;
      CLOSE rci_tempfile_c;
      endTempFileResync;
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20145, 
                'no records found to resync for tempfile view');
      END IF;
   END IF;
 
--
   foundrec := FALSE;
   IF beginThreadResync(siterec.high_rt_recid) THEN
      OPEN rc_redo_thread_c;
      LOOP
         FETCH rc_redo_thread_c INTO rtrec;
         EXIT WHEN rc_redo_thread_c%NOTFOUND;
 
         dbms_rcvcat.checkThread
              (rtrec.thread#, rtrec.sequence#, rtrec.enable_change#,
              rtrec.enable_time, rtrec.disable_change#, rtrec.disable_time,
              rtrec.status);
         foundrec := TRUE;
      END LOOP;
      CLOSE rc_redo_thread_c;
      endThreadResync;
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20146, 
                'no records found to resync for thread view');
      END IF;
   END IF;
 
--
   foundrec := FALSE;
   IF beginOnlineRedoLogResync(siterec.high_orl_recid) THEN
      OPEN rc_redo_log_c;
      LOOP
         FETCH rc_redo_log_c INTO orlrec;
         EXIT WHEN rc_redo_log_c%NOTFOUND;
 
         checkOnlineRedoLog
              (orlrec.thread#, orlrec.group#, orlrec.name,
               orlrec.bytes, orlrec.type);
         foundrec := TRUE;
      END LOOP;
      CLOSE rc_redo_log_c;
      endOnlineRedoLogResync;
 
      IF NOT foundrec THEN
--
--
         raise_application_error(-20147, 
                'no records found to resync for online redo log view');
      END IF;
   END IF;
 
   offr_key := beginOfflineRangeResync;
   IF ((wmrec.high_offr_recid IS NOT NULL AND
        wmrec.high_offr_recid > 0 AND
        local_wmrec.high_offr_recid = wmrec.high_offr_recid) OR
       (siterec.high_offr_recid = 0)) THEN
      foundrec := TRUE;
   ELSE
      foundrec := FALSE;
   END IF;
 
   OPEN rc_offline_range_c;
   LOOP
      FETCH rc_offline_range_c INTO offrrec;
      EXIT WHEN rc_offline_range_c%NOTFOUND;
 
--
--
--
      checkOfflineRange(
              offrrec.offr_key, offrrec.stamp, offrrec.file#,
              offrrec.creation_change#,
              offrrec.offline_change#, offrrec.online_change#,
              offrrec.online_time, offrrec.cf_create_time, 
              offrrec.resetlogs_change#, offrrec.resetlogs_time);
      foundrec := TRUE;
   END LOOP;
   CLOSE rc_offline_range_c;
   endOfflineRangeResync;
 
   IF NOT foundrec THEN
--
--
      deb('wmrec.high_offr_recid=' || wmrec.high_offr_recid);
      deb('local_wmrec.high_offr_recid=' || local_wmrec.high_offr_recid);
      raise_application_error(-20148, 
             'no records found to resync for offline range view');
   END IF;
   
 
--
 
   sanityCheck;
   endCkpt;
 
   deb('readFixedSections: (suc) ' || siterec.db_unique_name);
 
EXCEPTION
   WHEN OTHERS THEN
      deb('readFixedSections: (fail) ' || siterec.db_unique_name);
      cancelCkpt;
      raise;
END readFixedSections;
 
--
--
PROCEDURE writeBackupSections(input_xml_filename  IN VARCHAR2,
                              bktname IN VARCHAR2 DEFAULT NULL) IS
   v_ctx     DBMS_XMLGen.ctxHandle;
   v_xml     CLOB;
   v_xml_tmp CLOB;
   type record_sql_type is table of varchar2(2048) 
             index by binary_integer;
   type record_tbl_type is table of varchar2(30) 
             index by binary_integer;
   record_sql  record_sql_type;
   record_tbl  record_tbl_type;
   my_dbid      number;
 
   write_xml_filename rcfile.name%TYPE;
   local_wmrec        rc_watermarks%ROWTYPE;
   l_prefix           rcfile.name%TYPE;
   l_job_ckp_cf_seq   number;
 
BEGIN
 
   deb('writeBackupSections:enter, expects caller to commit');
 
--
   my_dbid := to_number(substr(input_xml_filename,
                               length(this_forwatermarks)+1,
                               instr(input_xml_filename,'.xml')-1
                                     -length(this_forwatermarks)));
   deb('writeBackupSections:my_dbid=' || my_dbid);
 
   BEGIN
      SELECT DB_KEY INTO this_db_key FROM DB
         WHERE db_id = my_dbid;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         deb('writeBackupSections:database with dbid=' || my_dbid ||
                                 ' not found in recovery catalog');
         RETURN;
   END;
 
   deb('writeBackupSections:this_db_key=' || this_db_key);
   BEGIN
      select * into local_wmrec from rc_watermarks where db_key = this_db_key;
      displayRCWatermarks('writeBackupSections local:', local_wmrec);
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         deb('writeBackupSections:database with dbid=' || my_dbid ||
                                 ' no setDatabase called yet');
         RETURN;
   END;
 
--
   l_job_ckp_cf_seq := local_wmrec.high_bp_recid + local_wmrec.high_do_key;
   IF this_rsiterec.cf_create_time = local_wmrec.rs_version_stamp AND
      this_rsiterec.job_ckp_cf_seq = l_job_ckp_cf_seq THEN
      deb('writeBackupSections:No new backup piece or deleted object added');
      RETURN;
   END IF;
 
   record_tbl(0)   := 'RC_DATABASE';
   record_sql(0)   := 'SELECT * FROM RC_DATABASE ' || 
                         'WHERE DB_KEY = ' || this_db_key;
 
   record_tbl(1)   := 'RCI_BACKUP_SET';
   record_sql(1)   := 'SELECT * FROM RCI_BACKUP_SET ' || 
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND BS_KEY IN ' ||
                         '    (SELECT DISTINCT BS_KEY FROM BP ' ||
                         '       WHERE BP_RECID > '||
                         NVL(this_rsiterec.high_bp_recid, 0) ||
                         '    )';
 
   record_tbl(2)   := 'RCI_BACKUP_PIECE';
   record_sql(2)   := 'SELECT * FROM RCI_BACKUP_PIECE ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND RECID > ' || 
                         NVL(this_rsiterec.high_bp_recid,0);
 
   record_tbl(3)   := 'RCI_BACKUP_DATAFILE';
   record_sql(3)   := 'SELECT * FROM RCI_BACKUP_DATAFILE ' ||
                         'WHERE DB_KEY   = ' || this_db_key ||
                         '  AND BS_KEY IN ' ||
                         '    (SELECT DISTINCT BS_KEY FROM BP ' ||
                         '       WHERE BP_RECID > ' || 
                         NVL(this_rsiterec.high_bp_recid, 0) ||
                         '    )';
 
   record_tbl(4)   := 'RCI_BACKUP_CONTROLFILE';
   record_sql(4)   := 'SELECT * FROM RCI_BACKUP_CONTROLFILE ' ||
                         'WHERE DB_KEY   = ' || this_db_key ||
                         '  AND BS_KEY IN ' ||
                         '    (SELECT DISTINCT BS_KEY FROM BP ' ||
                         '       WHERE BP_RECID > ' || 
                         NVL(this_rsiterec.high_bp_recid, 0) ||
                         '    )';
 
   record_tbl(5)   := 'RC_BACKUP_REDOLOG';
   record_sql(5)   := 'SELECT * FROM RC_BACKUP_REDOLOG ' ||
                         'WHERE DB_KEY   = ' || this_db_key ||
                         '  AND BS_KEY IN ' ||
                         '    (SELECT DISTINCT BS_KEY FROM BP ' ||
                         '       WHERE BP_RECID > ' || 
                         NVL(this_rsiterec.high_bp_recid, 0) ||
                         '    )';
 
   record_tbl(6)   := 'RCI_BACKUP_SPFILE';
   record_sql(6)   := 'SELECT * FROM RCI_BACKUP_SPFILE ' ||
                         'WHERE DB_KEY   = ' || this_db_key ||
                         '  AND BS_KEY IN ' ||
                         '    (SELECT DISTINCT BS_KEY FROM BP ' ||
                         '       WHERE BP_RECID > ' || 
                         NVL(this_rsiterec.high_bp_recid, 0) ||
                         '    )';
 
   record_tbl(7)   := 'RC_RCVER';
   record_sql(7)   := 'SELECT * FROM RC_RCVER ';
 
 
   record_tbl(8)   := 'RC_WATERMARKS';
   record_sql(8)   := 'SELECT * FROM RC_WATERMARKS ' || 
                         'WHERE DB_KEY = ' || this_db_key;
 
   record_tbl(9)   := 'RC_DELETED_OBJECT';
   record_sql(9)   := 'SELECT * FROM RC_DELETED_OBJECT ' ||
                         'WHERE DB_KEY = ' || this_db_key ||
                         '  AND DO_KEY > ' || 
                         NVL(this_rsiterec.high_do_recid, 0);
 
--
   v_xml := this_xml_signature_beg;
   FOR idx in 0..9 LOOP
      deb('writing XML file for ' || idx);
      deb('executing query:'|| record_sql(idx));
 
      v_ctx := DBMS_XMLGen.newContext(record_sql(idx));
 
--
      DBMS_XMLGen.setRowsetTag(v_ctx, 'TABLE_' || record_tbl(idx));
      v_xml_tmp := DBMS_XMLGen.GetXML(v_ctx);
      DBMS_XMLGen.closeContext(v_ctx);
 
      deb('XML len for '||idx||'=' || DBMS_LOB.GETLENGTH(v_xml_tmp));
      IF v_xml_tmp IS NOT NULL THEN
         DBMS_LOB.COPY(v_xml, v_xml_tmp, DBMS_LOB.LOBMAXSIZE, 
                       DBMS_LOB.GETLENGTH(v_xml),
                       DBMS_LOB.INSTR(v_xml_tmp, 
                                  '<TABLE_' || record_tbl(idx) ||'>'));
      END IF;
   END LOOP;
   v_xml := v_xml || this_xml_signature_end;
 
--
   l_prefix := 
      this_backupsets || my_dbid || '_' || 
      date2stamp(local_wmrec.rs_version_stamp) || '_';
   write_xml_filename :=  l_prefix || l_job_ckp_cf_seq || '.xml';
 
   IF this_amazon_server THEN
      put_object(null /*bktname */, write_xml_filename, 'text/xml', v_xml);
   ELSE
      DELETE rcfile WHERE name LIKE l_prefix || '%';
      IF SQL%ROWCOUNT > 0 THEN
         deb('writeBackupSections:deleted old backupset rows:' ||SQL%ROWCOUNT);
      END IF;
      INSERT INTO rcfile(rcfile_key, creation_time, name, xmldoc)
         VALUES (rman_seq.nextval, sys_extract_utc(systimestamp), 
                 write_xml_filename, XMLType.createXML(v_xml));
   END IF;
 
   deb('writeBackupSections:(suc) file:' || write_xml_filename);
END writeBackupSections;
 
PROCEDURE readBackupSections(bktname IN VARCHAR2 DEFAULT NULL) IS
 
 
   bs_xml_filename RCFILE.NAME%TYPE;
 
   bsrec  RCI_BACKUP_SET%ROWTYPE;
   CURSOR rci_backup_set_c IS
   SELECT DB_KEY,
          DB_ID, 
          BS_KEY,  
          RECID, 
          STAMP, 
          SET_STAMP,
          SET_COUNT,
          BACKUP_TYPE,
          INCREMENTAL_LEVEL,
          PIECES,
          START_TIME,
          COMPLETION_TIME,
          ELAPSED_SECONDS,
          STATUS,
          CONTROLFILE_INCLUDED,
          INPUT_FILE_SCAN_ONLY,
          KEEP,
          KEEP_UNTIL,
          decode (KEEP_OPTIONS, 'LOGS'         , 256
                              , 'NOLOGS'       , 512
                              , 'BACKUP_LOGS'  , 1024
                                               , 0) KEEP_OPTIONS,
          BLOCK_SIZE,
          SITE_KEY,
          MULTI_SECTION,
          GUID,
          PDB_KEY
   FROM "_RS_RCI_BACKUP_SET_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   ORDER BY RECID;
 
   bprec  RCI_BACKUP_PIECE%ROWTYPE;
   CURSOR rci_backup_piece_c IS
   SELECT DB_KEY,
          DB_ID,
          BP_KEY,
          RECID,
          STAMP,
          BS_KEY,
          SET_STAMP,
          SET_COUNT,
          BACKUP_TYPE,
          INCREMENTAL_LEVEL,
          PIECE#,
          COPY#,
          DEVICE_TYPE,
          HANDLE,
          COMMENTS,
          MEDIA,
          MEDIA_POOL,
          CONCUR,
          TAG,
          START_TIME,
          COMPLETION_TIME,
          ELAPSED_SECONDS,
          STATUS,
          BYTES,
          IS_RECOVERY_DEST_FILE,
          RSR_KEY,
          COMPRESSED,
          SITE_KEY,
          ENCRYPTED,
          BACKED_BY_OSB,
          SUBSTR(BA_ACCESS,1,1) BA_ACCESS,
          VB_KEY,
          VIRTUAL,
          LIB_KEY,
          GUID,
          PDB_KEY
   FROM "_RS_RCI_BACKUP_PIECE_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   ORDER BY RECID;
 
   bdfrec  RCI_BACKUP_DATAFILE%ROWTYPE;
   CURSOR rci_backup_datafile_c IS
   SELECT DB_KEY,
          DBINC_KEY,
          DB_NAME,
          BDF_KEY,
          RECID,
          STAMP,
          BS_KEY,
          SET_STAMP,
          SET_COUNT,
          BS_RECID,
          BS_STAMP,
          BACKUP_TYPE,
          INCREMENTAL_LEVEL,
          COMPLETION_TIME,
          FILE#,
          CREATION_CHANGE#,
          CREATION_TIME,
          RESETLOGS_CHANGE#,
          RESETLOGS_TIME,
          INCREMENTAL_CHANGE#,
          CHECKPOINT_CHANGE#,
          CHECKPOINT_TIME,
          ABSOLUTE_FUZZY_CHANGE#,
          DATAFILE_BLOCKS,
          BLOCKS,
          BLOCK_SIZE,
          STATUS,
          BS_LEVEL,
          PIECES,
          BLOCKS_READ,
          MARKED_CORRUPT,
          USED_CHANGE_TRACKING,
          USED_OPTIMIZATION,
          PCT_NOTREAD,
          FOREIGN_DBID,
          PLUGGED_READONLY,
          PLUGIN_CHANGE#,
          PLUGIN_RESETLOGS_CHANGE#,
          PLUGIN_RESETLOGS_TIME,
          SECTION_SIZE,
          GUID,
          SPARSE_BACKUP,
          PDB_KEY
   FROM "_RS_RCI_BACKUP_DATAFILE_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   UNION
      SELECT DB_KEY,
          DBINC_KEY,
          DB_NAME,
          BCF_KEY,
          RECID,
          STAMP,
          BS_KEY,
          SET_STAMP,
          SET_COUNT,
          BS_RECID,      
          BS_STAMP,      
          decode(BS_LEVEL, 0, 'D', null, 'D', 'I') BACKUP_TYPE,
          BS_LEVEL INCREMENTAL_LEVEL,
          COMPLETION_TIME,
          0 FILE#,
          0 CREATION_CHANGE#,
          CREATION_TIME,
          RESETLOGS_CHANGE#,
          RESETLOGS_TIME,
          0 INCREMENTAL_CHANGE#,
          CHECKPOINT_CHANGE#,
          CHECKPOINT_TIME,
          0 ABSOLUTE_FUZZY_CHANGE#,
          0 DATAFILE_BLOCKS,
          BLOCKS,        
          BLOCK_SIZE,
          STATUS,        
          BS_LEVEL,
          NULL PIECES,
          NULL BLOCKS_READ,
--
--
--
          to_number(to_char(to_date(autobackup_date),'YYYY')) MARKED_CORRUPT,
          'NO' USED_CHANGE_TRACKING,
          'NO' USED_OPTIMIZATION,
          AUTOBACKUP_SEQUENCE PCT_NOTREAD,
          0 FOREIGN_DBID,
          CONTROLFILE_TYPE PLUGGED_READONLY, 
          OLDEST_OFFLINE_RANGE PLUGIN_CHANGE#,
          to_number(to_char(to_date(autobackup_date),'MM')||
             to_char(to_date(autobackup_date),'DD')) PLUGIN_RESETLOGS_CHANGE#,
          NULL PLUGIN_RESETLOGS_TIME,
          NULL SECTION_SIZE,
          GUID,
          'NO' sparse_backup,
          PDB_KEY
   FROM "_RS_RCI_BACKUP_CONTROLFILE_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   ORDER BY 5;
 
   bsfrec  RCI_BACKUP_SPFILE%ROWTYPE;
   CURSOR rci_backup_spfile_c IS
   SELECT DB_KEY,
          BSF_KEY,
          RECID,
          STAMP,
          BS_KEY,
          SET_STAMP,
          SET_COUNT,
          MODIFICATION_TIME,
          STATUS,
          BS_RECID,
          BS_STAMP,
          COMPLETION_TIME,
          BYTES,
          DB_UNIQUE_NAME,
          GUID
   FROM "_RS_RCI_BACKUP_SPFILE_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   ORDER BY RECID;
 
   brlrec  RC_BACKUP_REDOLOG%ROWTYPE;
   CURSOR rc_backup_redolog_c IS
   SELECT DB_KEY,
          DBINC_KEY,                                
          DB_NAME,                                  
          BRL_KEY,                                  
          RECID,                                    
          STAMP,                                    
          BS_KEY,                                   
          SET_STAMP,                                
          SET_COUNT,                                
          BACKUP_TYPE,                                       
          COMPLETION_TIME,                                   
          THREAD#,                                  
          SEQUENCE#,                                
          RESETLOGS_CHANGE#,                        
          RESETLOGS_TIME,                           
          FIRST_CHANGE#,                            
          FIRST_TIME,                               
          NEXT_CHANGE#,                             
          NEXT_TIME,                                
          BLOCKS,                                   
          BLOCK_SIZE,                               
          STATUS,                                            
          BS_RECID,
          BS_STAMP,
          PIECES,
          TERMINAL,
          PARTIAL
   FROM "_RS_RC_BACKUP_REDOLOG_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   ORDER BY RECID;
 
   dlrec  RC_DELETED_OBJECT%ROWTYPE;
   CURSOR rc_deleted_object_c IS
   SELECT DB_KEY,
          DO_KEY,
          OBJECT_TYPE,
          OBJECT_KEY,                                  
          OBJECT_STAMP,                                  
          OBJECT_DATA,                                    
          SET_STAMP,                                
          SET_COUNT,
          HANDLE,
          DEVICE_TYPE
   FROM "_RS_RC_DELETED_OBJECT_"
   WHERE RS_RCFILE_NAME = bs_xml_filename
   ORDER BY DO_KEY;
 
   bsname "_RS_RC_GET_OBJECT_LIST_"%ROWTYPE;
   CURSOR bsnames_c(prefix in varchar2) IS
   SELECT *
   FROM "_RS_RC_GET_OBJECT_LIST_"
   WHERE prefix = bsnames_c.prefix
   ORDER BY rcfile_name asc;
 
   my_dbid      NUMBER;
   ckp_type     NUMBER;
   v_xml_tmp    CLOB; -- TODO remove this after changing get_object prototype
   local_node   NODE%ROWTYPE;
   prefix_value    "_RS_RC_GET_OBJECT_LIST_".PREFIX%TYPE;
 
   resync_not_needed EXCEPTION;
   PRAGMA EXCEPTION_INIT(resync_not_needed, -20034);
 
   incarnation_not_known EXCEPTION;
   PRAGMA EXCEPTION_INIT(incarnation_not_known, -20003);
   
   max_copy_num     NUMBER;
   l_bs_key         NUMBER;
   cursor_name      INTEGER;
   dummy            INTEGER;
   
   r_bp_key       NUMBER;
   r_dbver        NUMBER;
   r_dbid         NUMBER;
   r_db_name      dbinc.db_name%TYPE;
   r_handle       bp.handle%TYPE;
   r_setstamp     NUMBER;
   r_setcount     NUMBER;
   r_pieceno      NUMBER;
   r_pieceblksize NUMBER;
   r_tag          bp.tag%TYPE;
   r_bstyp        NUMBER;
   r_cnt          NUMBER;
   l_dbkey        NUMBER;
   l_cnt          NUMBER;
   l_compressed   bp.compressed%TYPE;
   l_encrypted    bp.encrypted%TYPE;
   l_incremental  NUMBER;
   l_bstyp        NUMBER;
   l_recid        NUMBER;
   l_job_ckp_cf_seq NUMBER;
 
BEGIN
   deb('readBackupSections - enter');
 
--
   IF this_server.server_host IS NULL THEN
      deb('readBackupSections: this_server.server_host is null');
      return;
   END IF;
 
   IF this_curr_inc.dbid IS NULL OR this_wmrec.cf_version_stamp IS NULL THEN
      deb('readBackupSections: DB was registered or inc mismatch, re-read');
      writeForWatermarks(bktname, TRUE);
      rsReadWaterMarks(bktname);
   END IF;
 
--
   IF this_upstream_dbrec.name IS NULL THEN
      raise_application_error(-20999, 'internal error: no rows for upstreamdb');
   END IF;
 
   IF this_url_db_unique_name IS NULL THEN
      raise_application_error(-20999,'internal error:this_url_db_unique_name2');
   END IF;
 
   IF (this_curr_inc.dbid IS NULL) THEN
      raise_application_error(-20021, 'Database not set');
   END IF;
 
   BEGIN 
      setDatabase(db_name => this_curr_inc.name,
                  reset_scn => this_curr_inc.resetlogs_change#,
                  reset_time => this_curr_inc.resetlogs_time,
                  db_id => this_curr_inc.dbid,
                  db_unique_name => 
                     this_upstream_dbrec.name||'$'|| this_url_db_unique_name,
                  dummy_instance => FALSE,
                  cf_type => CF_STANDBY,
                  site_aware => TRUE,
                  ors_instance => TRUE);
   EXCEPTION
      WHEN incarnation_not_known THEN
--
--
--
         deb('readBackupSections: New incarnation not yet known to upstream');
         IF debug THEN
            displayRCDatabaseIncarnation('readBackupSections: remote ', 
                                          this_curr_inc);
         END IF;
         RETURN;
   END;
 
--
   dbms_session.set_nls('NLS_DATE_FORMAT','''DD-MM-YYYY HH24:MI:SS''');
 
--
--
   BEGIN
      writeForWatermarks(bktname, FALSE);
      rsReadWaterMarks(bktname);
   EXCEPTION
      WHEN OTHERS THEN
         deb('readBackupSections: error during watermarks read:' || sqlerrm);
         RAISE;
   END;
 
   IF this_wmrec.rs_version_stamp is NULL THEN
      deb('readBackupSections: no watermarks yet populated at ORS');
      RETURN;
   END IF;
 
   SELECT * into local_node FROM NODE
      WHERE db_key = this_db_key
        AND site_key = this_site_key;
 
--
   l_job_ckp_cf_seq := this_wmrec.high_bp_recid + this_wmrec.high_do_key;
   IF local_node.cf_create_time = this_wmrec.rs_version_stamp AND
      local_node.job_ckp_cf_seq = l_job_ckp_cf_seq THEN
--
      deb('readBackuupSections: no events to reconcile from ORS to catalog');
      return;
   END IF;
 
   deb('local_node.cf_create_time='||local_node.cf_create_time);
   deb('local_node.job_ckp_cf_seq='||local_node.job_ckp_cf_seq);
 
--
   lockForCkpt;
   ckp_type := ckptNeeded(ckp_scn => 0,
                          ckp_cf_seq => l_job_ckp_cf_seq,
                          cf_version => this_wmrec.rs_version_stamp,
                          cf_type => CF_STANDBY,
                          high_df_recid => 0,
                          high_orl_recid => 0,
                          high_cdf_recid => 0,
                          high_al_recid => 0,
                          high_bp_recid => this_wmrec.high_bp_recid,
                          high_do_recid => this_wmrec.high_do_key,
                          high_offr_recid => 0,
                          high_pc_recid => 0,
                          high_conf_recid => 0,
                          rltime => this_curr_inc.resetlogs_time,
                          high_ts_recid => 0,
                          high_bs_recid => 0,
                          lopen_reset_scn => NULL,
                          lopen_reset_time => NULL,
                          high_ic_recid => 0,
                          high_tf_recid => 0,
                          high_rt_recid => 0,
                          high_grsp_recid => 0,
                          high_nrsp_recid => 0,
                          high_bcr_recid => 0,
                          high_pdb_recid => 0,
                          high_pic_recid => 0);
   IF ckp_type <> RESYNC_PARTIAL THEN
      deb('readBackupSections: resync not required, ckp_type=' || ckp_type);
      cancelCkpt;
      return;
   END IF;
 
   BEGIN
      beginCkpt(ckp_scn => 0,
                ckp_cf_seq => l_job_ckp_cf_seq,
                cf_version => this_wmrec.rs_version_stamp,
                ckp_time => NULL,
                ckp_type => 'PARTIAL',
                ckp_db_status => NULL,
                high_df_recid => 0,
                cf_type => 'STANDBY');
   EXCEPTION
      WHEN resync_not_needed THEN
         deb('readBackupSections:resync not needed from beginCkpt');
         return;
   END;
 
--
--
   SELECT DBID INTO MY_DBID FROM RC_DATABASE
      WHERE DB_KEY=this_db_key;
 
--
   prefix_value := this_backupsets || my_dbid || '_' ||
                   date2stamp(this_wmrec.rs_version_stamp) || '_';
 
--
--
--
   v_xml_tmp := get_object(bktname, null, 'prefix='||prefix_value);
 
   OPEN bsnames_c(prefix_value);
   LOOP
      FETCH bsnames_c INTO bsname;
      EXIT WHEN bsnames_c%NOTFOUND;
      bs_xml_filename := bsname.rcfile_name;
 
      deb('readBackupSections: got file ' || bs_xml_filename);
 
--
      v_xml_tmp := get_object(bktname, bs_xml_filename);
 
--
      l_recid := beginBackupsetResync;
      OPEN rci_backup_set_c;
      LOOP
         FETCH rci_backup_set_c INTO bsrec;
         EXIT WHEN rci_backup_set_c%NOTFOUND;
 
         deb('Calling checkBackupset');
         dbms_rcvcat.checkBackupSet(
                 bsrec.recid, bsrec.stamp, bsrec.set_stamp, bsrec.set_count,
                 bsrec.backup_type, bsrec.incremental_level, bsrec.pieces,
                 bsrec.start_time, bsrec.completion_time,
                 bsrec.controlfile_included, bsrec.input_file_scan_only,
                 bsrec.keep_options, bsrec.keep_until, bsrec.block_size,
                 bsrec.multi_section, FALSE /* chk_last_recid */,
                 bsrec.guid);
      END LOOP;
      CLOSE rci_backup_set_c;
      endBackupsetResync;
 
--
      l_recid := beginBackupPieceResync;
      OPEN rci_backup_piece_c;
      LOOP
         FETCH rci_backup_piece_c INTO bprec;
         EXIT WHEN rci_backup_piece_c%NOTFOUND;
         
--
         SELECT bs_key INTO l_bs_key FROM bs
           WHERE bs.db_key = this_db_key
             AND   bs.set_stamp = bprec.set_stamp
             AND   bs.set_count = bprec.set_count;
         
         SELECT NVL(MAX(copy#), 0)
           INTO max_copy_num 
           FROM bp
           WHERE bs_key = l_bs_key;
         
         IF bprec.ba_access != 'U' THEN
            deb('Calling CheckBackupPiece, handle='|| bprec.handle ||',tag=' ||
                bprec.tag || ',max_copy_num=' || max_copy_num ||',l_bs_key=' ||
                l_bs_key || ',bp_recid=' || bprec.recid);
 
            dbms_rcvcat.checkBackupPiece(
                 bprec.recid, bprec.stamp, bprec.set_stamp, bprec.set_count,
                 bprec.piece#, bprec.tag, 'SBT_TAPE', bprec.handle,
                 bprec.comments, this_server.rep_server_name, bprec.concur,
                 bprec.start_time, bprec.completion_time, bprec.status,
                 max_copy_num + 1, bprec.media_pool,
                 bprec.bytes, bprec.is_recovery_dest_file,
                 bprec.rsr_key, null /* rman_status_stamp */,
                 bprec.compressed, bprec.encrypted, bprec.backed_by_osb,
                 'R', NULL /* bprec.vb_key */,
                 TRUE /* chk_last_recid */, this_lib_key, bprec.guid, NULL);
              
--
           SELECT bp_key INTO r_bp_key
             FROM bp
             WHERE handle=bprec.handle
               AND piece#=bprec.piece#;
              
--
--
           EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM sbt_catalog WHERE bp_key=:1'
                       INTO l_cnt USING r_bp_key;
 
           IF l_cnt = 0 THEN 
--
--
             cursor_name := dbms_sql.open_cursor;
                
             sys.dbms_sql.parse(cursor_name,   
                               'begin sys.kbrsi_icd.rsAddToSbtCatalog(
                                    bpkey        => :l_bpkey,
                                    dbver        => :l_dbver,
                                    dbname       => :l_dbname,
                                    dbid         => :l_dbid,
                                    handle       => :l_handle,
                                    setstamp     => :l_setstamp,
                                    setcount     => :l_setcount,
                                    pieceno      => :l_pieceno,
                                    pieceblksize => :l_pieceblksize,
                                    tag          => :l_tag,
                                    bstyp        => :l_bstyp
                                 ); end;',
                                 DBMS_SQL.NATIVE);
                
--
--
--
             IF l_dbkey IS NULL THEN
               SELECT db_key INTO l_dbkey
                 FROM db
                 WHERE db_id=bprec.db_id;
 
               EXECUTE IMMEDIATE 'SELECT MAX(cmpvsn) FROM vbdf WHERE db_key=:1'
                 INTO r_dbver USING l_dbkey;
 
               SELECT db_name INTO r_db_name FROM dbinc
                 WHERE dbinc_key = 
                       (SELECT curr_dbinc_key FROM db WHERE db_key = l_dbkey);
             END IF;
                
             IF r_dbver IS NULL THEN
--
--
--
--
--
--
--
--
--
--
--
               deb ('readBackupSections: r_dbver is NULL - set to 0.0.0.0');
               r_dbver := 0;
             END IF;
 
             SELECT block_size, incr_level
               INTO r_pieceblksize, l_incremental
               FROM bs
               WHERE bs_key=l_bs_key;
                
             r_dbid         := bprec.db_id;
             r_handle       := bprec.handle;
             r_setstamp     := bprec.set_stamp;
             r_setcount     := bprec.set_count;
             r_pieceno      := bprec.piece#;
             r_tag          := bprec.tag;
             
--
--
             r_bstyp := 4;
--
--
             IF l_incremental IS NOT NULL THEN
               r_bstyp := r_bstyp + 16;
             END IF;
                
             IF bprec.compressed = 'YES' THEN
               r_bstyp := r_bstyp + 32;
             END IF;
 
             IF bprec.encrypted = 'Y' THEN
               r_bstyp := r_bstyp + 64;
             END IF;
                
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_bpkey',   r_bp_key   );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_dbver',   r_dbver    );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_dbname',  r_db_name  );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_dbid',    r_dbid     );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_handle',  r_handle   );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_setstamp',r_setstamp );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_setcount',r_setcount );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_pieceno', r_pieceno  );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_pieceblksize',
                                                            r_pieceblksize);
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_tag',     r_tag      );
             DBMS_SQL.BIND_VARIABLE(cursor_name, ':l_bstyp',   r_bstyp    );
 
             deb('Calling rsAddToSbtCatalog');
             dummy := sys.dbms_sql.execute(cursor_name);
             sys.dbms_sql.close_cursor(cursor_name);
 
           END IF;
                
        ELSE 
          deb('Calling CheckBackupPiece ***NOT***, handle='||bprec.handle||
              ',tag=' || bprec.tag || ',max_copy_num=' || max_copy_num ||
              ',l_bs_key=' || l_bs_key || ',bp_recid=' || bprec.recid);
          deb('Ignoring BP rec with bprec.ba_access=' || bprec.ba_access);
        END IF;
      END LOOP;
      CLOSE rci_backup_piece_c;
      endBackupPieceResync;
 
--
      l_recid := beginBackupDataFileResync;
      OPEN rci_backup_datafile_c;
      LOOP
         FETCH rci_backup_datafile_c INTO bdfrec;
         EXIT WHEN rci_backup_datafile_c%NOTFOUND;
 
         deb('Calling checkBackupDatafile');
         dbms_rcvcat.checkBackupDataFile(
                 bdfrec.recid, bdfrec.stamp, bdfrec.set_stamp,
                 bdfrec.set_count, bdfrec.file#, bdfrec.creation_change#,
                 bdfrec.creation_time,
                 bdfrec.resetlogs_change#, bdfrec.resetlogs_time,
                 bdfrec.incremental_level, bdfrec.incremental_change#,
                 bdfrec.checkpoint_change#, bdfrec.checkpoint_time,
                 bdfrec.absolute_fuzzy_change#, bdfrec.datafile_blocks,
                 bdfrec.blocks, bdfrec.block_size, 
                 bdfrec.plugin_change# /*oldest_offline_range*/,
                 bdfrec.completion_time, 
                 bdfrec.plugged_readonly /*controlfile_type*/,
                 bdfrec.marked_corrupt /* cfile_abck_year */, 
                 bdfrec.plugin_resetlogs_change# /* cfile_abck_mon_day */,
                 bdfrec.pct_notread /* cfile_abck_seq */, 
                 FALSE /* chk_last_recid */, bdfrec.blocks_read,
                 bdfrec.used_change_tracking, bdfrec.used_optimization,
                 bdfrec.foreign_dbid, bdfrec.plugged_readonly,
                 bdfrec.plugin_change#, bdfrec.plugin_resetlogs_change#,
                 bdfrec.plugin_resetlogs_time,
                 bdfrec.section_size, bdfrec.guid, bdfrec.sparse_backup);
      END LOOP;
      CLOSE rci_backup_datafile_c;
      endBackupDatafileResync;
 
--
      l_recid := beginBackupRedoLogResync;
      OPEN rc_backup_redolog_c;
      LOOP
         FETCH rc_backup_redolog_c INTO brlrec;
         EXIT WHEN rc_backup_redolog_c%NOTFOUND;
  
         deb('Calling checkBackupRedoLog');
         dbms_rcvcat.checkBackupRedoLog(
                 brlrec.recid, brlrec.stamp, brlrec.set_stamp,
                 brlrec.set_count,
                 brlrec.thread#, brlrec.sequence#, brlrec.resetlogs_change#,
                 brlrec.resetlogs_time, brlrec.first_change#,
                 brlrec.first_time,
                 brlrec.next_change#, brlrec.next_time, brlrec.blocks,
                 brlrec.block_size, FALSE /* chk_last_recid */,
                 brlrec.terminal);
      END LOOP;
      CLOSE rc_backup_redolog_c;
      endBackupRedoLogResync;
 
--
      l_recid := beginBackupSpFileResync;
      OPEN rci_backup_spfile_c;
      LOOP
         FETCH rci_backup_spfile_c INTO bsfrec;
         EXIT WHEN rci_backup_spfile_c%NOTFOUND;
  
         deb('Calling checkBackupSpFile');
         dbms_rcvcat.checkBackupSpFile(
                 bsfrec.recid, bsfrec.stamp, bsfrec.set_stamp, 
                 bsfrec.set_count, bsfrec.modification_time, bsfrec.bytes, 
                 FALSE /* chk_last_recid */,
                 bsfrec.db_unique_name, bsfrec.guid);
      END LOOP;
      CLOSE rci_backup_spfile_c;
      endBackupSpFileResync;
 
--
      l_recid := beginDeletedObjectResync;
      OPEN rc_deleted_object_c;
      LOOP
         FETCH rc_deleted_object_c INTO dlrec;
         EXIT WHEN rc_deleted_object_c%NOTFOUND;
  
         deb('Calling checkDeletedObject for do_key(recid) ' ||
               dlrec.do_key                ||' object type '    ||
               dlrec.object_type           ||' with key '       ||
               dlrec.object_key            ||', stamp '       ||
               dlrec.object_stamp          ||', data '       ||
               dlrec.object_data           ||' and set_stamp '  ||
               nvl(to_char(dlrec.set_stamp), 'NULL') ||' and set_count '  ||
               nvl(to_char(dlrec.set_count), 'NULL') ||', handle ' ||
               dlrec.handle                ||', device_type ' ||
               dlrec.device_type);
 
         dbms_rcvcat.checkDeletedObject(
              dlrec.do_key /* do_recid */, 0 /* do_stamp */,
              dlrec.object_type, dlrec.object_key, dlrec.object_stamp,
              dlrec.object_data,
              null /* dlrec.object_fname */,
              null /* dlrec.object_create_scn */,
              dlrec.set_stamp, dlrec.set_count,
              dlrec.handle, dlrec.device_type);
      END LOOP;
      CLOSE rc_deleted_object_c;
      endDeletedObjectResync;
 
   END LOOP;
   CLOSE bsnames_c;
 
   sanityCheck;
 
--
   deb('readBackupSections:last xml file resynced ' || bs_xml_filename);
   delete rcfile where name like prefix_value || '%' 
                      and name <> bs_xml_filename;
   IF bs_xml_filename IS NOT NULL THEN
      endCkpt;
      deb('readBackupSections(suc)');
   ELSE
      deb('readBackupSections(no_files_found - re-try again)');
      cancelCkpt;
   END IF;
EXCEPTION
   WHEN OTHERS THEN
      deb('readBackupSections(fail):'||sqlerrm);
      cancelCkpt;
      raise;
END readBackupSections;
 
/*----------------------------------------------------------------------------
 * This is for oam front end congestion control. If the requirement for a new  
 * backup job exceeds the system bottleneck the job will have to wait.
 *--------------------------------------------------------------------------*/
 
PROCEDURE throttle_me(p_oam_job_id         IN VARCHAR2,
                      p_channels_reqd      IN NUMBER,
                      p_request_time       IN DATE,
                      p_wait               OUT BOOLEAN,
                      p_error_str          OUT VARCHAR2)
IS
   l_wait      integer;
BEGIN
  
--
  IF NOT this_is_ors THEN
    p_wait := false;
    RETURN;
  END IF;
  
  deb ('throttle_me: request for db: ' || this_db_unique_name);
  
  EXECUTE IMMEDIATE 'begin dbms_rai_throttle_alloc(
                     :p_oam_job_id, :p_db_unique_name, :p_channels_reqd, 
                     :p_request_time, :l_wait, :p_error_str); end;'
          USING IN p_oam_job_id, IN this_db_unique_name, IN p_channels_reqd, 
                IN p_request_time, OUT l_wait, OUT p_error_str;
 
  p_wait := (l_wait > 0);
 
END throttle_me;
 
FUNCTION assert_schema (
  i_schema                   IN VARCHAR2
, i_enquote                  IN BOOLEAN DEFAULT FALSE
)
RETURN VARCHAR2
IS
  l_eschema                  VARCHAR2(130);
  l_schema                   VARCHAR2(130);
BEGIN
  dbms_utility.canonicalize(
    dbms_assert.enquote_name(i_schema, FALSE)
  , l_eschema, 130
  );
  l_schema := dbms_assert.schema_name(l_eschema);
  IF (i_enquote)
  THEN
    RETURN l_eschema;
  ELSE
    RETURN l_schema;
  END IF;
END assert_schema;
 
PROCEDURE assert_schema (
  o_schema                   OUT NOCOPY VARCHAR2
, o_eschema                  OUT NOCOPY VARCHAR2
, i_schema                   IN VARCHAR2
)
IS
BEGIN
  dbms_utility.canonicalize(dbms_assert.enquote_name(i_schema), o_eschema, 130);
  o_schema := dbms_assert.schema_name(o_eschema);
END assert_schema;
 
/*--------------------------------------------------*
 * Package Instantiation:  Initialize Package State *
 *--------------------------------------------------*/
BEGIN
 
  tsRec.ts# := NULL;                    -- not in TableSpaceResync
  dfRec.file# := NULL;                  -- not in middle of dfResync
  version_list(1) := '08.00.04.00';
 
--
--
--
--
--
--
  version_list(2) := '08.00.05.00';
 
--
--
  version_list(3) := '08.01.03.00';
 
--
--
  version_list(4) := '08.01.06.00';
 
--
--
--
--
--
--
--
  version_list(5) := '08.01.07.00';
 
--
--
--
--
--
  version_list(6) := '09.00.00.00';
 
--
--
--
--
--
--
  version_list(7) := '09.02.00.00';
--
--
--
 
  version_list(8) := '10.01.00.00';
 
--
  version_list(9)  := '10.02.00.00';
  version_list(10) := '10.02.00.01';
 
--
  version_list(11) := '11.01.00.00';
  version_list(12) := '11.01.00.01';
  version_list(13) := '11.01.00.02';
  version_list(14) := '11.01.00.03';
  version_list(15) := '11.01.00.04';
  version_list(16) := '11.01.00.05';
  version_list(17) := '11.01.00.06';
  version_list(18) := '11.01.00.07';
  version_list(19) := '11.02.00.00';
  version_list(20) := '11.02.00.01';
  version_list(21) := '11.02.00.02';
 
--
  version_list(22) := '12.01.00.00';
  version_list(23) := '12.01.00.01';
  version_list(24) := '12.01.00.02';
 
--
  version_list(25) := '12.02.00.00';
  version_list(26) := '12.02.00.01';
 
  version_max_index := 26;
  
--
  initOrsAdmin;
 
  IF (orsadmin_user = user) THEN
     this_is_ors_admin := TRUE;
  END IF;
 
  IF (orsadmin_user IS NOT NULL) THEN
     this_is_ors := TRUE;
  END IF;
 
--
  FOR i IN 1..vpd_table_list.COUNT
  LOOP
    IF (vtr_policy_required(i))
    THEN
      g_vpd_required_policies := g_vpd_required_policies + 1;
    END IF;
  END LOOP;
 
  init_package_vars(NULL);
END dbms_rcvcat;

/
--------------------------------------------------------
--  DDL for Package Body DBMS_RCVMAN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."DBMS_RCVMAN" IS
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
--
--
--
 
 
MAXSCNVAL  CONSTANT number := 9e125; -- guaranteed higher than any SCN
UB6MAXVAL  CONSTANT number := 281474976710655;
UB8MAXVAL  CONSTANT number := 18446744073709551615;
MAXSEQVAL  CONSTANT number := 2**32-1;
MINDATEVAL CONSTANT date   := to_date('01/01/1900','MM/DD/YYYY');
MAXDATEVAL CONSTANT date   := to_date('12/31/9999','MM/DD/YYYY');
CONST2GVAL CONSTANT number := 2**31;
CONST4GVAL CONSTANT number := 2**32;
 
--
KEEP_NO      CONSTANT number := 0;
KEEP_LOGS    CONSTANT number := 256;
KEEP_NOLOGS  CONSTANT number := 512;
KEEP_CONSIST CONSTANT number := 1024;
 
DEB_UNDEF  CONSTANT number := 0;
DEB_PRINT  CONSTANT number := 0;
DEB_ENTER  CONSTANT number := 1;
DEB_EXIT   CONSTANT number := 2;
DEB_IN     CONSTANT number := 3;
DEB_OPEN   CONSTANT number := 4;
DEB_DEF_PNAME CONSTANT varchar2(50) := 'prvtrmnu';
 
--
BACKUP_SPARSENESS_UNSPECIFIED CONSTANT number := 0;
BACKUP_SPARSENESS_SPARSE      CONSTANT number := 1;
BACKUP_SPARSENESS_NONSPARSE   CONSTANT number := 2;
 
--
--
--
 
--
--
--
highscnval            number := UB6MAXVAL;
 
this_db_key         number := NULL;
this_dbinc_key      number := NULL;
this_reset_scn      number := NULL;
this_reset_time     date;
this_db_unique_name node.db_unique_name%TYPE;  -- used only to identify rows of
this_site_key       number := NULL;        -- configuration and flashback tbl
--
--
this_dummy_instance boolean := FALSE;
this_stdby_controlfile_scn number := NULL;  -- standby controlfile scn used
--
 
--
--
--
--
--
--
--
--
translation_site_key NUMBER := NULL;      -- Never NULL
 
realf_site_key      number := NULL;        -- override df/tf/online log txln
user_site_key       number := NULL;        -- override log/backups/conf/rp txln
user_db_unique_name node.db_unique_name%TYPE; -- corresponds to user_site_key 
client_site_aware   number := 0;
 
--
--
--
--
--
--
logs_shared           number := 0; -- used only when client_site_aware is 1
disk_backups_shared   number := 1; -- indicates shared accross all sites
tape_backups_shared   number := 1; -- indicates shared accross all sites
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
TYPE incarnation_set_c IS TABLE OF rc_database_incarnation%ROWTYPE
         index by binary_integer;
inc_list incarnation_set_c;  -- 0th one is current incarnation, see setDatabase
max_inc_idx binary_integer;
currInc     binary_integer;  -- temp variable used to keep track of incarnation
 
--
TYPE pdb_incarnation_set_t IS TABLE OF pdb_incarnation_t
   index by binary_integer;
TYPE pdb_incarnation_coll_t IS TABLE OF pdb_incarnation_set_t
   index by binary_integer;
pdb_inc_list pdb_incarnation_coll_t; -- 0th one is current sub incarnation
 
type pnames is table of varchar2(50) index by binary_integer;
pname_i         number :=0;
last_pnames     pnames;
debug           boolean := FALSE;
rsdebug         boolean := NULL;
 
--
--
--
--
--
--
--
--
this_baseline_cap      number;
this_baseline_cap_scn  number := NULL;
 
--
--
--
 
TYPE rcvRecTab_t IS TABLE OF rcvRec_t;          -- recovery record stack type
 
rcvRecStack rcvRecTab_t := rcvRecTab_t();       -- recovery record stack
 
--
--
--
 
TYPE versionList_t IS TABLE OF varchar2(11) INDEX BY binary_integer;
 
versionList             versionList_t;
versionMaxIndex         binary_integer;
versionCounter          binary_integer;
 
--
--
--
 
catalogVersion CONSTANT VARCHAR2(11) := '12.02.00.01';
 
--
getParentIncarnationKey number;
 
--
--
--
 
allIncarnations number;                 -- allow records from non-current
--
 
ignoreCreationSCN number;               -- a stupid flag that is here
--
--
--
--
 
--
lbacked_al_next_scn        NUMBER;
standby_became_primary_scn NUMBER;
 
--
--
TYPE lognames_set_c IS TABLE OF al.fname%TYPE
         index by binary_integer;
lognames_list lognames_set_c;  -- All the log names returned for same logseq
max_lognames_idx binary_integer;
 
--
--
--
--
canApplyAnyRedo number := FALSE#;
 
--
--
--
--
craGetAllCfBackups number := FALSE#;
 
--
--
--
canConvert_Cf number := FALSE#;
 
redoRec      rcvRec_t;
 
untilSCN        number;
untilTime       date;
rpoint_set      boolean;
 
restoreSource   number;
restoreSparse   number := BACKUP_SPARSENESS_UNSPECIFIED;
restoreTag      bp.tag%TYPE;
 
onlyStandby     number;
 
--
--
--
 
TYPE deviceList_t IS TABLE OF rc_backup_piece.device_type%TYPE
     INDEX BY binary_integer;
 
deviceList      deviceList_t;
deviceCount     number;
diskDevice      boolean;
anyDevice       number;
 
--
--
--
recoveryDestFile  boolean;
 
--
--
--
localOrsSiteKey number := null;
 
--
--
--
restoreRangeDevTyp varchar2(10) := null;
 
--
--
--
orsLocalFile  boolean := null;
orsLibKey     number  := null;
orsAnyFile    boolean := null;
 
--
--
--
--
--
--
--
--
--
redoLogDeletionPolicyType  varchar2(512) := 'TO NONE';
 
--
--
--
extendFullSCN  CONSTANT BINARY_INTEGER := 2**0;
extendIncrSCN  CONSTANT BINARY_INTEGER := 2**1;
extendLogSCN   CONSTANT BINARY_INTEGER := 2**2;
extendAllSCN   CONSTANT BINARY_INTEGER :=
   extendFullSCN + extendIncrSCN + extendLogSCN;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
noHint constant binary_integer         := 0;
redundantHint constant binary_integer  := 1;
localityHint constant binary_integer   := 2;
 
TYPE cacheBsRecRow_t IS RECORD
(
   deviceindx   binary_integer,    -- index into cacheBsRecTable.devicelist
   tag          varchar2(32),      -- may be null
   copyNumber   binary_integer,    -- null if code 2 or 3
   code         binary_integer     -- 1 => same copy#
--
--
);
TYPE cacheBsRecIndex_t IS TABLE OF cacheBsRecRow_t INDEX BY BINARY_INTEGER;
TYPE cacheBsRecHash_t IS RECORD
(
   bskey       number,             -- backupset key
   mixcopy     boolean := FALSE,   -- TRUE if mixcopy can make set usuable
   copy        cacheBsRecIndex_t   -- list of copies
);
TYPE cacheBsRecHashList_t IS TABLE OF cacheBsRecHash_t INDEX BY BINARY_INTEGER;
TYPE cacheBsRecBsKey_t IS RECORD
(
   bsindex     binary_integer := 1,    -- index into bslist
   bslist      cacheBsRecHashList_t    -- list of backupset keys in hash table
);
TYPE cacheBsRec_t IS TABLE OF cacheBsRecBsKey_t INDEX BY BINARY_INTEGER;
TYPE cacheBsRecTable_t IS RECORD
(
   initlimit   boolean := FALSE,              -- is limit initialized?
   limit       number  := bsRecCacheLowLimit, -- cache size
   chit        number  := 0,                  -- no: of hits in cache
   mixcopy     boolean := FALSE,              -- does cache have mix of copyno?
   minbskey    number  := 0,                  -- minimum valid bskey
 
   hint        binary_integer := noHint, -- access pattern hint
--
--
--
--
   devicetype  rc_backup_piece.device_type%TYPE,
   mask        binary_integer,
   tag         rc_backup_piece.tag%TYPE,
 
   devicelist  deviceList_t,       -- list of devices
   devicecount binary_integer := 0,
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
   bsRec    cacheBsRec_t,
 
--
--
--
   hitindex    binary_integer := 1,     -- index into hit list
   hitlist     numTab_t
--
--
--
--
--
--
--
--
--
--
--
);
cacheBsRecTable  cacheBsRecTable_t;
 
TYPE cacheRequest_t IS RECORD
(
   bskey                  number,
   icopy                  binary_integer
);
findValidCacheRequest     cacheRequest_t;
 
--
--
--
 
TYPE rcvRecStackState_t IS RECORD
(
   lowAction   number,                  -- action with lowest from_scn on
--
--
--
--
--
   savePoint   number,                  -- most recently added full_act_t
   fullBackups number,                  -- number of full_act_t
   top         number                   -- top of stack at start of a recursive
--
--
);
 
rcvRecStackState        rcvRecStackState_t;
 
--
--
--
 
computeRA_allRecords    number;         -- do not stop at first full backup and
--
 
computeRA_fullBackups   number;         -- stop when reached these many full
--
 
computeRA_restorable    boolean;        -- cannot recover the datafile we've
--
--
--
 
computeRA_available     boolean;        -- there is a backup available on
--
 
computeRA_availableMask binary_integer;
 
computeRA_rcvCopy_avail boolean;        -- there is a backup available on
--
--
--
 
--
action_OK                number := 0;
action_FAIL              number := 1;
action_SKIP              number := 2;
action_OLD_REDO          number := 3;
action_WRONG_INCARNATION number := 4;
action_OLD_INC_REDO      number := 5;
 
old_redo exception;                     -- redo from old incarnation
pragma exception_init(old_redo, -20501);
 
--
--
--
 
getRA_containerMask     number;
getRA_actionMask        number;
getRA_likePattern       cdf.fname%TYPE;
 
getRA_completedAfter    date;
getRA_completedBefore   date;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
rcvRecBackupAge         number;      -- requested age of backup
thisBackupAge           number;      -- current age of backup
getBS_status            number;      -- status of current backup
 
--
--
--
tc_thread               number;
tc_fromTime             date;
tc_toTime               date;
tc_fromSCN              number;
tc_toSCN                number;
tc_fromSeq              number;
tc_toSeq                number;
tc_pattern              varchar2(512);
 
TYPE fileTab_t IS TABLE of boolean index by binary_integer;
tc_fno                  fileTab_t;
tc_database             number;
 
TYPE sequenceTab_t IS TABLE of boolean index by binary_integer;
TYPE threadseqTab_t IS TABLE of sequenceTab_t index by binary_integer;
tc_threadSeq            threadSeqTab_t;
 
TYPE dbidTab_t IS TABLE OF boolean index by binary_integer;
tc_dbid                 dbidTab_t;
tc_anydbid              number;
 
--
--
--
--
--
canHandleTransportableTbs number := FALSE#;
 
guidQualifier        varchar2(32);
guid2pdbkeyQualifier number;
 
--
--
--
actual_dbinc_key number := NULL; -- see comments on getActualDbinc
 
--
--
SESSION_KEY number;
SESSION_FROMTIME DATE;
SESSION_UNTILTIME DATE;
 
--
--
--
--
--
--
--
lb_NeedObsoleteData   number := TRUE#;
CURSOR listBackup_c
RETURN lbRec_t IS
   SELECT
--
           bs.bs_key               list_order1,
           0                       list_order2,
           bs.bs_key               pkey,
           backupset_txt           backup_type,
           backupset_txt           file_type,
           decode(bs.keep_options,
                  0, 'NO',
                     'YES')        keep,
           bs.keep_until           keep_until,
           decode(bs.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         null)     keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bs.bs_recid             recid,
           bs.bs_stamp             stamp,
           null                    device_type,
           0                       block_size,
           bs.completion_time      completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           bs.bs_key               bs_key,
           bs.set_count            bs_count,
           bs.set_stamp            bs_stamp,
           decode(bs.bck_type,
                  'L', archivedlog_txt,
                       datafile_txt)
                                   bs_type,
           decode(bs.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(bs.bck_type, 'I', incr_txt, full_txt))
                                   bs_incr_type,
           bs.pieces               bs_pieces,
           null                    bs_copies,
           bs.completion_time      bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM  bs
    WHERE bs.db_key     = this_db_key
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
   SELECT
--
           bp.bs_key               list_order1,
           1                       list_order2,
           bp.bp_key               pkey,
           backupset_txt           backup_type,
           piece_txt               file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(bp.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           bp.handle               fname,
           bp.tag                  tag,
           bp.media                media,
           bp.bp_recid             recid,
           bp.bp_stamp             stamp,
           bp.device_type          device_type,
           0                       block_size,
           bp.completion_time      completion_time,
           bp.is_recovery_dest_file
                                   is_rdf,
           bp.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bp.bytes                bytes,
           bp.bs_key               bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           bp.piece#               bp_piece#,
           bp.copy#                bp_copy#,
           bp.vb_key               bp_vb_key,
           bp.ba_access            bp_ba_access,
           bp.lib_key              bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bp
    WHERE bp.db_key = this_db_key
      AND bp.status != 'D'
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           bdf.bs_key              list_order1,
           2                       list_order2,
           bdf.bdf_key             pkey,
           backupset_txt           backup_type,
           datafile_txt            file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bdf.bdf_recid           recid,
           bdf.bdf_stamp           stamp,
           null                    device_type,
           bdf.block_size          block_size,
           bdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bdf.block_size * bdf.blocks
                                   bytes,
           bdf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           decode(bdf.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(greatest(bdf.create_scn, bdf.incr_scn),
                         bdf.create_scn, full_txt, incr_txt))
                                   bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           bdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           bdf.create_scn          df_creation_change#,
           bdf.ckp_scn             df_checkpoint_change#,
           bdf.ckp_time            df_ckp_mod_time,
           bdf.incr_scn            df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bdf.dbinc_key
 
   UNION ALL
   SELECT
--
           bcf.bs_key              list_order1,
           2                       list_order2,
           bcf.bcf_key             pkey,
           backupset_txt           backup_type,
           controlfile_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bcf.bcf_recid           recid,
           bcf.bcf_stamp           stamp,
           null                    device_type,
           bcf.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bcf.block_size * bcf.blocks
                                   bytes,
           bcf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           bcf.ckp_scn             df_checkpoint_change#,
           bcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bcf.dbinc_key
 
   UNION ALL
   SELECT
--
           brl.bs_key              list_order1,
           2                       list_order2,
           brl.brl_key             pkey,
           backupset_txt           backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           brl.brl_recid           recid,
           brl.brl_stamp           stamp,
           null                    device_type,
           brl.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           brl.block_size * brl.blocks
                                   bytes,
           brl.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           brl.thread#             rl_thread#,
           brl.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           brl.low_scn             rl_first_change#,
           brl.low_time            rl_first_time,
           brl.next_scn            rl_next_change#,
           brl.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM brl, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = brl.dbinc_key
 
   UNION ALL
   SELECT
--
           bsf.bs_key              list_order1,
           2                       list_order2,
           bsf.bsf_key             pkey,
           backupset_txt           backup_type,
           spfile_txt              file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bsf.bsf_recid           recid,
           bsf.bsf_stamp           stamp,
           null                    device_type,
           0                       block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bsf.bytes               bytes,
           bsf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           0                       df_resetlogs_change#,
           0                       df_creation_change#,
           0                       df_checkpoint_change#,
           bsf.modification_time   df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           db_unique_name          sf_db_unique_name,
           null                    con_id
     FROM bsf
    WHERE bsf.db_key     = this_db_key
 
   UNION ALL
   SELECT
--
           cdf.cdf_key             list_order1,
           -1                      list_order2,
           cdf.cdf_key             pkey,
           copy_txt                backup_type,
           datafile_txt            file_type,
           decode(cdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           cdf.keep_until          keep_until,
           decode(cdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(cdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           cdf.fname               fname,
           cdf.tag                 tag,
           null                    media,
           cdf.cdf_recid           recid,
           cdf.cdf_stamp           stamp,
           'DISK'                  device_type,
           cdf.block_size          block_size,
           cdf.completion_time     completion_time,
           cdf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           cdf.block_size * cdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           cdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           cdf.create_scn          df_creation_change#,
           cdf.ckp_scn             df_checkpoint_change#,
           cdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM cdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = cdf.dbinc_key
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
   UNION ALL
   SELECT
--
           ccf.ccf_key             list_order1,
           -1                      list_order2,
           ccf.ccf_key             pkey,
           copy_txt                backup_type,
           controlfile_txt         file_type,
           decode(ccf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           ccf.keep_until          keep_until,
           decode(ccf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(ccf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           ccf.fname               fname,
           ccf.tag                 tag,
           null                    media,
           ccf.ccf_recid           recid,
           ccf.ccf_stamp           stamp,
           'DISK'                  device_type,
           ccf.block_size          block_size,
           ccf.completion_time     completion_time,
           ccf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           ccf.ckp_scn             df_checkpoint_change#,
           ccf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM ccf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = ccf.dbinc_key
      AND ((user_site_key  = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           al.al_key               list_order1,
           -1                      list_order2,
           al.al_key               pkey,
           copy_txt                backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(al.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           al.fname                fname,
           null                    tag,
           null                    media,
           al.al_recid             recid,
           al.al_stamp             stamp,
           'DISK'                  device_type,
           al.block_size           block_size,
           al.completion_time      completion_time,
           al.is_recovery_dest_file
                                   is_rdf,
           al.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           al.block_size * al.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           al.thread#              rl_thread#,
           al.sequence#            rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           al.low_scn              rl_first_change#,
           al.low_time             rl_first_time,
           al.next_scn             rl_next_change#,
           al.next_time            rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM dbinc,
          al
          LEFT OUTER JOIN
          grsp
          ON al.next_scn   >= grsp.from_scn
         AND al.low_scn    <= (grsp.to_scn + 1)
         AND al.dbinc_key   = grsp.dbinc_key
         AND grsp.from_scn <= grsp.to_scn   -- filter clean grp
         AND grsp.from_scn != 0
         AND grsp.guaranteed = 'YES'
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = al.dbinc_key
      AND al.archived = 'Y'
      AND grsp.from_scn is null
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = al.site_key) OR
             (user_site_key IS NULL AND
              (logs_shared = TRUE# OR
               this_site_key = nvl(al.site_key, this_site_key))))) OR
           (client_site_aware = FALSE#))
 
   UNION ALL
   SELECT
--
           xdf.xdf_key             list_order1,
           -1                      list_order2,
           xdf.xdf_key             pkey,
           proxycopy_txt           backup_type,
           datafile_txt            file_type,
           decode(xdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xdf.keep_until          keep_until,
           decode(xdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xdf.handle              fname,
           xdf.tag                 tag,
           xdf.media               media,
           xdf.xdf_recid           recid,
           xdf.xdf_stamp           stamp,
           xdf.device_type         device_type,
           xdf.block_size          block_size,
           xdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xdf.block_size * xdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           xdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           xdf.create_scn          df_creation_change#,
           xdf.ckp_scn             df_checkpoint_change#,
           xdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xdf.dbinc_key
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
   UNION ALL
   SELECT
--
           xcf.xcf_key             list_order1,
           -1                      list_order2,
           xcf.xcf_key             pkey,
           proxycopy_txt           backup_type,
           controlfile_txt         file_type,
           decode(xcf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xcf.keep_until          keep_until,
           decode(xcf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xcf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xcf.handle              fname,
           xcf.tag                 tag,
           xcf.media               media,
           xcf.xcf_recid           recid,
           xcf.xcf_stamp           stamp,
           xcf.device_type         device_type,
           xcf.block_size          block_size,
           xcf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           xcf.ckp_scn             df_checkpoint_change#,
           xcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xcf.dbinc_key
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           xal.xal_key             list_order1,
           -1                      list_order2,
           xal.xal_key             pkey,
           proxycopy_txt           backup_type,
           archivedlog_txt         file_type,
           decode(xal.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xal.keep_until          keep_until,
           decode(xal.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xal.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xal.handle              fname,
           xal.tag                 tag,
           xal.media               media,
           xal.xal_recid           recid,
           xal.xal_stamp           stamp,
           xal.device_type         device_type,
           xal.block_size          block_size,
           xal.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xal.block_size * xal.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           xal.thread#             rl_thread#,
           xal.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           xal.low_scn             rl_first_change#,
           xal.low_time            rl_first_time,
           xal.next_scn            rl_next_change#,
           xal.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xal, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = xal.dbinc_key
      AND ((user_site_key   = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
   ORDER BY list_order1, list_order2, bp_piece#;
 
--
--
--
 
--
--
--
--
 
CURSOR findControlfileBackup_c(
   sourcemask           IN     number
  ,currentIncarnation   IN     number         DEFAULT TRUE#
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,untilSCN             IN     number         DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable
--
  ,needstby             IN     number         DEFAULT NULL
  ,typemask             IN     binary_integer DEFAULT BScfile_all
  ,fromSCN              IN     number         DEFAULT 0
--
)
RETURN rcvRec_t IS
   SELECT imageCopy_con_t       type_con,
          ccf_key               key_con,
          ccf_recid             recid_con,
          ccf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- ccf doesn't have blocks
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          create_time           cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          ccf.ckp_scn           toSCN_act,
          ccf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          ccf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          ccf.pdb_key           pdbKey_obj,
 
          ccf.keep_options      keep_options,
          ccf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM ccf, dbinc
   WHERE dbinc.db_key = this_db_key            -- belongs to this database
     AND dbinc.dbinc_key = ccf.dbinc_key
     AND (findControlfileBackup_c.currentIncarnation = FALSE# OR
          this_dbinc_key = ccf.dbinc_key)
     AND (findControlfileBackup_c.tag is NULL OR
          findControlfileBackup_c.tag = tag)
     AND (findControlfileBackup_c.pattern is NULL OR
          fname LIKE replace(replace(findControlfileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findControlfileBackup_c.completedAfter is NULL OR
          completion_time >= findControlfileBackup_c.completedAfter)
     AND (findControlfileBackup_c.completedBefore is NULL OR
          completion_time <= findControlfileBackup_c.completedBefore)
     AND (findControlfileBackup_c.untilSCN is NULL OR
          ccf.ckp_scn <= findControlfileBackup_c.untilSCN)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
     AND (needstby is NULL OR
          nvl(controlfile_type,'B') = decode(needstby, TRUE#, 'S', 'B') OR
          canConvert_Cf = TRUE#)
     AND (sourcemask is NULL OR bitand(sourcemask, imageCopy_con_t) != 0)
     AND ((user_site_key = ccf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(ccf.site_key, this_site_key)))))
     AND ccf.ckp_scn >= findControlfileBackup_c.fromSCN
     AND (guidQualifier IS NULL OR ccf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xcf_key               key_con,
          xcf_recid             recid_con,
          xcf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- xcf doesn't have blocks
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xcf.ckp_scn           toSCN_act,
          xcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          xcf.pdb_key           pdbKey_obj,
 
          xcf.keep_options      keep_options,
          xcf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xcf, dbinc
   WHERE db_key = this_db_key          -- belongs to this database
     AND dbinc.dbinc_key = xcf.dbinc_key
     AND (findControlfileBackup_c.currentIncarnation = FALSE# OR
          this_dbinc_key = xcf.dbinc_key)
     AND (findControlfileBackup_c.tag is NULL OR
          findControlfileBackup_c.tag = tag)
     AND (findControlfileBackup_c.pattern is NULL OR
          handle LIKE replace(replace(findControlfileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findControlfileBackup_c.completedAfter is NULL OR
          completion_time >= findControlfileBackup_c.completedAfter)
     AND (findControlfileBackup_c.completedBefore is NULL OR
          completion_time <= findControlfileBackup_c.completedBefore)
     AND (findControlfileBackup_c.untilSCN is NULL OR
          xcf.ckp_scn <= findControlfileBackup_c.untilSCN)
     AND decode(statusMask, BSavailable,
                decode(status, 'A', TRUE#, FALSE#),
                isStatusMatch(status, statusMask)) = TRUE#
     AND (needstby is NULL OR
          nvl(controlfile_type,'B') = decode(needstby, TRUE#, 'S', 'B') OR
          canConvert_Cf = TRUE#)
     AND (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
     AND ((user_site_key  = xcf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xcf.site_key, this_site_key)))))
     AND xcf.ckp_scn >= findControlfileBackup_c.fromSCN
     AND (guidQualifier IS NULL OR xcf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT backupSet_con_t       type_con,
          bcf_key               key_con,
          bcf_recid             recid_con,
          bcf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          bcf.blocks            blocks_con,
          bcf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          bcf.create_time       cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          bcf.ckp_scn           toSCN_act,
          bcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          bcf.autobackup_sequence
                                cfSequence_obj,
          bcf.autobackup_date   cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          bcf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bs, bcf, dbinc
   WHERE dbinc.db_key = this_db_key            -- belongs to this database
     AND bs.db_key = this_db_key               -- belongs to this database
     AND bcf.dbinc_key = dbinc.dbinc_key       -- join bcf and dbinc
     AND bcf.bs_key = bs.bs_key                -- join bcf and bs
     AND bs.bck_type != 'L'                    -- ignore archivelog backups
     AND (findControlfileBackup_c.currentIncarnation = FALSE# OR
          this_dbinc_key = bcf.dbinc_key)
     AND (findControlfileBackup_c.completedAfter is NULL OR
          bs.completion_time >= findControlfileBackup_c.completedAfter)
     AND (findControlfileBackup_c.completedBefore is NULL OR
          bs.completion_time <= findControlfileBackup_c.completedBefore)
     AND (findControlfileBackup_c.untilSCN is NULL OR
          bcf.ckp_scn <= findControlfileBackup_c.untilSCN)
     AND (needstby is NULL OR
          nvl(controlfile_type,'B') = decode(needstby, TRUE#, 'S', 'B') OR
          canConvert_Cf = TRUE#)
     AND ((typemask = 0 AND bcf.autobackup_date IS NULL)  OR -- no autobackups
          (bitand(typemask, BScfile_all) != 0)            OR -- all backups
          (bcf.autobackup_date IS NOT NULL AND             -- only autobackups
           bitand(typemask, BScfile_auto) != 0))
     AND (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
     AND (bs.site_key IS NULL         OR -- always return null site_key
          user_site_key = bs.site_key OR -- user interested in one site
          (user_site_key IS NULL AND     -- return rows per access attr
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key)))
     AND bcf.ckp_scn >= findControlfileBackup_c.fromSCN
     AND (guidQualifier IS NULL OR bcf.pdb_key = guid2pdbKeyQualifier)
 
   ORDER BY toSCN_act desc,
            stamp_con desc;
 
--
--
--
 
CURSOR findSpfileBackup_c(
   completedAfter        IN     date           DEFAULT NULL
  ,completedBefore       IN     date           DEFAULT NULL
  ,untilTime             IN     date           DEFAULT NULL
  ,rmanCmd               IN     number         DEFAULT unknownCmd_t)
RETURN rcvRec_t IS
--
   SELECT backupSet_con_t       type_con,
          bsf_key               key_con,
          bsf_recid             recid_con,
          bsf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          0                     blocks_con,
          0                     blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          0                     toSCN_act,
          nvl(modification_time, bs.completion_time)     toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bsf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          db_unique_name        sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bsf, bs, db
--
--
--
    WHERE rmanCmd != obsoleteCmd_t
      AND bsf.bs_key = bs.bs_key                -- join bsf and bs
      AND bs.bck_type != 'L'                    -- ignore archivelog backups
      AND bs.db_key = this_db_key               -- belongs to this database
      AND bsf.db_key = db.db_key                -- join bsf and db
      AND (findSpfileBackup_c.completedAfter is NULL OR
           bs.completion_time >= findSpfileBackup_c.completedAfter)
      AND (findSpfileBackup_c.completedBefore is NULL OR
           bs.completion_time <= findSpfileBackup_c.completedBefore)
      AND (findSpfileBackup_c.untilTime is NULL OR
           nvl(modification_time,bs.start_time)
               <= findSpfileBackup_c.untilTime)
      AND (rmanCmd != restoreCmd_t OR
           (rmanCmd = restoreCmd_t AND
            (bsf.db_unique_name is NULL OR
             nvl(user_db_unique_name, this_db_unique_name) =
              bsf.db_unique_name)))
      AND (bs.site_key IS NULL         OR -- always return null site_key
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key))
     AND (guidQualifier IS NULL OR bsf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
--
   SELECT backupSet_con_t       type_con,
          bsf_key               key_con,
          bsf_recid             recid_con,
          bsf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          0                     blocks_con,
          0                     blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          0                     toSCN_act,
          nvl(modification_time, bs.completion_time)     toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bsf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          db_unique_name        sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bsf, bs, db,
          (SELECT bs_key,
                  count(distinct piece#) pieces
             FROM  bp
            WHERE rmanCmd = obsoleteCmd_t
              AND bp.db_key  = this_db_key         -- this database
              AND bp.status  = 'A'
              AND (anyDevice = TRUE# OR
                   isDeviceTypeAllocated(bp.device_type) = TRUE#)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared=TRUE# AND bp.device_type='DISK') OR
                     (tape_backups_shared=TRUE# AND bp.device_type<>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
         GROUP BY bs_key, device_type) bp
--
--
--
    WHERE rmanCmd = obsoleteCmd_t
      AND bsf.bs_key = bs.bs_key                -- join bsf and bs
      AND bs.bck_type != 'L'                    -- ignore archivelog backups
      AND bs.db_key = this_db_key               -- belongs to this database
      AND bs.bs_key = bp.bs_key                 -- join bs and bp
      AND bs.pieces = bp.pieces
      AND bsf.db_key = db.db_key                -- join bsf and db
      AND (findSpfileBackup_c.completedAfter is NULL OR
           bs.completion_time >= findSpfileBackup_c.completedAfter)
      AND (findSpfileBackup_c.completedBefore is NULL OR
           bs.completion_time <= findSpfileBackup_c.completedBefore)
      AND (findSpfileBackup_c.untilTime is NULL OR
           nvl(modification_time,bs.start_time)
               <= findSpfileBackup_c.untilTime)
     AND (guidQualifier IS NULL OR bsf.pdb_key = guid2pdbKeyQualifier)
 
    ORDER BY toTime_act desc, -- for finding best backup
             stamp_con desc;  -- to get most recent
 
--
--
--
getDatafileBackupLast   rcvRec_t;
 
CURSOR findDatafileBackup_c(
   sourcemask           IN     number
  ,fno                  IN     number         DEFAULT NULL
  ,crescn               IN     number         DEFAULT NULL
--
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,reset_scn            IN     number         DEFAULT NULL
  ,reset_time           IN     date           DEFAULT NULL
  ,level                IN     number         DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,untilSCN             IN     number         DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable
--
  ,onlyrdf              IN     binary_integer DEFAULT 0
--
  ,duplicates           IN     number         DEFAULT NULL
  ,onlytc               IN     binary_integer DEFAULT FALSE#
--
  ,pluginSCN            IN     number         DEFAULT 0
  ,allowCumuLevelN      IN     binary_integer DEFAULT FALSE#
--
)
 
RETURN rcvRec_t IS
 
   SELECT imageCopy_con_t       type_con,
          cdf.cdf_key           key_con,
          cdf.cdf_recid         recid_con,
          cdf.cdf_stamp         stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          cdf.fname             fileName_con,
          cdf.tag               tag_con,
          to_number(null)       copyNumber_con,
          cdf.status            status_con,
          cdf.blocks            blocks_con,
          cdf.block_size        blockSize_con,
          'DISK'                deviceType_con,
          cdf.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          cdf.ckp_scn           toSCN_act,
          cdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          cdf.dbinc_key         dbincKey_act,
          cdf.incr_level        level_act,
          0                     section_size_act,
 
          cdf.file#             dfNumber_obj,
          cdf.create_scn        dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          cdf.pdb_key           pdbKey_obj,
 
          cdf.keep_options      keep_options,
          cdf.keep_until        keep_until,
 
          cdf.abs_fuzzy_scn     afzSCN_act,
          cdf.rcv_fuzzy_time    rfzTime_act,
          cdf.rcv_fuzzy_scn     rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          cdf.foreign_dbid      foreignDbid_obj,
          decode(cdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          cdf.plugin_scn        pluginSCN_obj,
          cdf.plugin_reset_scn  pluginRlgSCN_obj,
          cdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          decode(cdf.plugged_readonly, 'NO', cdf.ckp_scn,
                 cdf.plugin_scn)
                                newToSCN_act,
          decode(cdf.plugin_scn, 0, dbinc.reset_scn,
                 cdf.plugin_reset_scn)
                                newRlgSCN_act,
          decode(cdf.plugin_scn, 0, dbinc.reset_time,
                 cdf.plugin_reset_time)
                                newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          cdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM cdf, dbinc,
          (SELECT DISTINCT max(cdf_recid) duprecid
             FROM cdf, dbinc
            WHERE (findDatafileBackup_c.tag is NULL OR
                   tag = findDatafileBackup_c.tag)
              AND cdf.dbinc_key = dbinc.dbinc_key
              AND dbinc.db_key  = this_db_key
              AND (findDatafileBackup_c.pattern is NULL OR
                   cdf.fname
                     LIKE replace(replace(findDatafileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                      ESCAPE '*')
         GROUP BY cdf.file#, cdf.create_scn, dbinc.reset_scn,
                  dbinc.reset_time, cdf.ckp_time, cdf.ckp_scn,
                  cdf.abs_fuzzy_scn, cdf.rcv_fuzzy_scn,
                  cdf.bck_fuzzy, cdf.onl_fuzzy, dbinc.db_key,
                  cdf.plugin_scn, cdf.plugin_reset_scn,
                  cdf.plugin_reset_time) dup
   WHERE cdf.cdf_recid = dup.duprecid(+)
     AND (sourcemask is NULL OR bitand(sourcemask, imageCopy_con_t) != 0)
     AND (dbinc.db_key = this_db_key)            -- belongs to this database
     AND (dbinc.dbinc_key = cdf.dbinc_key)       -- join cdf and dbinc
     AND (findDatafileBackup_c.reset_scn is NULL OR
          canApplyAnyRedo = TRUE# OR
          (cdf.plugged_readonly = 'NO' AND
           findDatafileBackup_c.reset_scn = dbinc.reset_scn AND
           findDatafileBackup_c.reset_time = dbinc.reset_time) OR
          (cdf.plugged_readonly = 'YES' AND
           findDatafileBackup_c.reset_scn = cdf.plugin_reset_scn AND
           findDatafileBackup_c.reset_time = cdf.plugin_reset_time))
     AND cdf.file# = nvl(findDatafileBackup_c.fno, cdf.file#)
--
--
     AND cdf.file# != 0                           -- no ctrl bkps
     AND (onlytc = FALSE#     OR
          tc_database = TRUE# OR
          isTranslatedFno(cdf.file#) = TRUE#)     -- only tnslated files
     AND ((findDatafileBackup_c.pluginSCN = 0  AND
           cdf.plugin_scn = 0                  AND
           cdf.create_scn = findDatafileBackup_c.crescn)
          OR
          (findDatafileBackup_c.pluginSCN != 0 AND
           cdf.plugin_scn = findDatafileBackup_c.pluginSCN)
          OR
          (findDatafileBackup_c.pluginSCN = 0 AND
           findDatafileBackup_c.crescn IS NULL))
     AND decode(statusMask, BSavailable,
                decode(status, 'A', TRUE#, FALSE#),
                isStatusMatch(status, statusMask)) = TRUE#
     AND (findDatafileBackup_c.tag is NULL OR
          tag = findDatafileBackup_c.tag)
     AND (findDatafileBackup_c.pattern is NULL OR
          cdf.fname LIKE replace(replace(findDatafileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findDatafileBackup_c.completedAfter is NULL OR
          cdf.completion_time >= findDatafileBackup_c.completedAfter)
     AND (findDatafileBackup_c.completedBefore is NULL OR
          cdf.completion_time <= findDatafileBackup_c.completedBefore)
     AND (findDatafileBackup_c.untilSCN is NULL OR
          (cdf.plugged_readonly = 'NO' AND
           cdf.ckp_scn <= findDatafileBackup_c.untilSCN) OR
          (cdf.plugged_readonly = 'YES' AND
           cdf.plugin_scn <= findDatafileBackup_c.untilSCN))
     AND (findDatafileBackup_c.level is NULL OR
          cdf.incr_level <= findDatafileBackup_c.level)
     AND (findDatafileBackup_c.onlyrdf = 0 OR
          cdf.is_recovery_dest_file = 'YES')
     AND (duplicates IS NULL OR duplicates = TRUE# OR
          (duplicates = FALSE# AND duprecid IS NOT NULL))
     AND ((user_site_key = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
     AND (guidQualifier IS NULL OR cdf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xdf.xdf_key           key_con,
          xdf.xdf_recid         recid_con,
          xdf.xdf_stamp         stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          xdf.handle            fileName_con,
          xdf.tag               tag_con,
          to_number(null)       copyNumber_con,
          xdf.status            status_con,
          xdf.blocks            blocks_con,
          xdf.block_size        blockSize_con,
          xdf.device_type       deviceType_con,
          xdf.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xdf.ckp_scn           toSCN_act,
          xdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xdf.dbinc_key         dbincKey_act,
          xdf.incr_level        level_act,
          0                     section_size_act,
 
          xdf.file#             dfNumber_obj,
          xdf.create_scn        dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          xdf.pdb_key           pdbKey_obj,
 
          xdf.keep_options      keep_options,
          xdf.keep_until        keep_until,
 
          xdf.abs_fuzzy_scn     afzSCN_act,
          xdf.rcv_fuzzy_time    rfzTime_act,
          xdf.rcv_fuzzy_scn     rfzSCN_act,
          xdf.media             media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          xdf.foreign_dbid      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          xdf.plugin_scn        pluginSCN_obj,
          xdf.plugin_reset_scn  pluginRlgSCN_obj,
          xdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          decode(xdf.plugged_readonly, 'NO', xdf.ckp_scn,
                 xdf.plugin_scn)
                                newToSCN_act,
          decode(xdf.plugin_reset_scn, 0, dbinc.reset_scn,
                 xdf.plugin_reset_scn)
                                newRlgSCN_act,
          nvl(xdf.plugin_reset_time, dbinc.reset_time)
                                newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xdf, dbinc
   WHERE (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
     AND (findDatafileBackup_c.onlyrdf = 0)
     AND (dbinc.db_key = this_db_key)            -- belongs to this database
     AND (dbinc.dbinc_key = xdf.dbinc_key)       -- join xdf and dbinc
     AND (findDatafileBackup_c.reset_scn is NULL OR
          canApplyAnyRedo = TRUE# OR
          (xdf.plugged_readonly = 'NO' AND
           findDatafileBackup_c.reset_scn = dbinc.reset_scn AND
           findDatafileBackup_c.reset_time = dbinc.reset_time) OR
          (xdf.plugged_readonly = 'YES' AND
           findDatafileBackup_c.reset_scn = xdf.plugin_reset_scn AND
           findDatafileBackup_c.reset_time = xdf.plugin_reset_time))
     AND xdf.file# = nvl(findDatafileBackup_c.fno, xdf.file#)
     AND xdf.file# != 0                         -- no ctrl bkps
     AND (onlytc = FALSE#     OR
          tc_database = TRUE# OR
          isTranslatedFno(xdf.file#) = TRUE#)   -- only tnslated files
     AND ((findDatafileBackup_c.pluginSCN = 0  AND
           xdf.plugin_scn = 0                  AND
           xdf.create_scn = findDatafileBackup_c.crescn)
          OR
          (findDatafileBackup_c.pluginSCN != 0 AND
           xdf.plugin_scn = findDatafileBackup_c.pluginSCN)
          OR
          (findDatafileBackup_c.pluginSCN = 0 AND
           findDatafileBackup_c.crescn IS NULL))
     AND decode(statusMask, BSavailable,
                decode(xdf.status, 'A', TRUE#, FALSE#),
                isStatusMatch(xdf.status, statusMask)) = TRUE#
     AND (findDatafileBackup_c.tag is NULL OR
          xdf.tag = findDatafileBackup_c.tag)
     AND (findDatafileBackup_c.pattern is NULL OR
          xdf.handle LIKE replace(replace(findDatafileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findDatafileBackup_c.completedAfter is NULL OR
          xdf.completion_time >= findDatafileBackup_c.completedAfter)
     AND (findDatafileBackup_c.completedBefore is NULL OR
          xdf.completion_time <= findDatafileBackup_c.completedBefore)
     AND (findDatafileBackup_c.untilSCN is NULL OR
          (xdf.plugged_readonly = 'NO' AND
           xdf.ckp_scn <= findDatafileBackup_c.untilSCN) OR
          (xdf.plugged_readonly = 'YES' AND
           xdf.plugin_scn <= findDatafileBackup_c.untilSCN))
     AND (findDatafileBackup_c.level is NULL OR
          xdf.incr_level <= findDatafileBackup_c.level)
     AND dbinc.db_key=this_db_key
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
     AND (guidQualifier IS NULL OR xdf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT backupSet_con_t       type_con,
          bdf.bdf_key           key_con,
          bdf.bdf_recid             recid_con,
          bdf.bdf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid              bsRecid_con,
          bs.bs_stamp              bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level  bsLevel_con,
          bs.bck_type        bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          bdf.blocks            blocks_con,
          bdf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          decode(bdf.incr_scn, 0, full_act_t, incremental_act_t)
                                type_act,
          bdf.incr_scn          fromSCN_act,
          bdf.ckp_scn           toSCN_act,
          bdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bdf.dbinc_key         dbincKey_act,
          bdf.incr_level        level_act,
          bdf.section_size      section_size_act,
 
          bdf.file#             dfNumber_obj,
          bdf.create_scn        dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bdf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          bdf.abs_fuzzy_scn     afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          bdf.foreign_dbid      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          bdf.plugin_scn        pluginSCN_obj,
          bdf.plugin_reset_scn  pluginRlgSCN_obj,
          bdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          decode(bdf.plugged_readonly, 'NO', bdf.ckp_scn,
                 bdf.plugin_scn)
                                newToSCN_act,
          decode(bdf.plugin_scn, 0, dbinc.reset_scn,
                 bdf.plugin_reset_scn)
                                newRlgSCN_act,
          decode(bdf.plugin_scn, 0, dbinc.reset_time,
                 bdf.plugin_reset_time)
                                newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          bdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
--
--
--
     FROM  bs, bdf, dbinc
   WHERE (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
     AND (findDatafileBackup_c.onlyrdf = 0)
     AND (dbinc.db_key = this_db_key)            -- belongs to this database
     AND (bs.db_key = this_db_key)               -- belongs to this database
     AND (bdf.dbinc_key = dbinc.dbinc_key)       -- join bdf and dbinc
     AND (bdf.bs_key = bs.bs_key)                -- join bdf and bs
     AND bs.bck_type != 'L'                      -- only datafile backups
     AND (findDatafileBackup_c.reset_scn is NULL  OR
          canApplyAnyRedo = TRUE# OR
          (bdf.plugged_readonly = 'NO' AND
           findDatafileBackup_c.reset_scn  = dbinc.reset_scn AND
           findDatafileBackup_c.reset_time = dbinc.reset_time) OR
          (bdf.plugged_readonly = 'YES' AND
           findDatafileBackup_c.reset_scn  = bdf.plugin_reset_scn AND
           findDatafileBackup_c.reset_time = bdf.plugin_reset_time))
     AND bdf.file# = nvl(findDatafileBackup_c.fno, bdf.file#)
     AND bdf.file# != 0                              -- no ctrl bkps
     AND (onlytc = FALSE#     OR
          tc_database = TRUE# OR
          isTranslatedFno(bdf.file#) = TRUE#)        -- only tnslated files
     AND ((findDatafileBackup_c.pluginSCN = 0  AND
           bdf.plugin_scn = 0                  AND
           bdf.create_scn = findDatafileBackup_c.crescn)
          OR
          (findDatafileBackup_c.pluginSCN != 0 AND
           bdf.plugin_scn = findDatafileBackup_c.pluginSCN)
          OR
          (findDatafileBackup_c.pluginSCN = 0 AND
           findDatafileBackup_c.crescn IS NULL))
     AND (findDatafileBackup_c.completedAfter is NULL OR
          bs.completion_time >= findDatafileBackup_c.completedAfter)
     AND (findDatafileBackup_c.completedBefore is NULL OR
          bs.completion_time <= findDatafileBackup_c.completedBefore)
     AND (findDatafileBackup_c.untilSCN is NULL OR
          (bdf.plugged_readonly = 'NO' AND
           bdf.ckp_scn <= findDatafileBackup_c.untilSCN) OR
          (bdf.plugged_readonly = 'YES' AND
           bdf.plugin_scn <= findDatafileBackup_c.untilSCN))
--
--
--
--
--
--
--
     AND (findDatafileBackup_c.level is NULL OR
         bdf.incr_level <= findDatafileBackup_c.level OR
         (findDatafileBackup_c.allowCumuLevelN = TRUE# AND
          bdf.create_scn = bdf.incr_scn AND
          bdf.foreign_dbid = 0))
     AND (bs.site_key IS NULL         OR -- always return null site_key
          user_site_key = bs.site_key OR -- user interested in one site
          (user_site_key IS NULL AND     -- return rows per access attr
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key)))
     AND (guidQualifier IS NULL OR bdf.pdb_key = guid2pdbKeyQualifier)
 
  ORDER BY  dfNumber_obj,         -- dfNumber_obj
            newRlgSCN_act  desc,  -- rlgSCN_act, last incarnation first
            newRlgTime_act desc,  -- rlgTime_act
            newToSCN_act   desc,  -- toSCN_act
            stamp_con      desc;  -- stamp_con
 
 
CURSOR findDatafileCopyKey(
   copyKey              IN     number
  ,statusMask           IN     binary_integer)
RETURN rcvRec_t IS
--
   SELECT imageCopy_con_t       type_con,
          cdf_key               key_con,
          cdf_recid             recid_con,
          cdf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          cdf.ckp_scn           toSCN_act,
          cdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          cdf.dbinc_key         dbincKey_act,
          incr_level            level_act,
          0                     section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          cdf.pdb_key           pdbKey_obj,
 
          cdf.keep_options      keep_options,
          cdf.keep_until        keep_until,
 
          cdf.abs_fuzzy_scn     afzSCN_act,
          cdf.rcv_fuzzy_time    rfzTime_act,
          cdf.rcv_fuzzy_scn     rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          cdf.foreign_dbid      foreignDbid_obj,
          decode(cdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          cdf.plugin_scn        pluginSCN_obj,
          cdf.plugin_reset_scn  pluginRlgSCN_obj,
          cdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          cdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM cdf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = cdf.dbinc_key       -- join cdf and dbinc
      AND (findDatafileCopyKey.copyKey = cdf_key)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
 
    ORDER BY dfNumber_obj,              -- for duplicate filtering
             decode(pluggedRonly_obj, 0, toSCN_act, pluginSCN_obj) desc,
--
             stamp_con desc;            -- to get most recent
 
CURSOR findControlFileCopyKey(
   copyKey              IN     number
  ,statusMask           IN     binary_integer)
RETURN rcvRec_t IS
--
   SELECT imageCopy_con_t       type_con,
          ccf_key               key_con,
          ccf_recid             recid_con,
          ccf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          create_time           cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          ccf.ckp_scn           toSCN_act,
          ccf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          ccf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          ccf.pdb_key           pdbKey_obj,
 
          ccf.keep_options      keep_options,
          ccf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM ccf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = ccf.dbinc_key       -- join cdf and dbinc
      AND (findControlFileCopyKey.copyKey = ccf_key)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
    ORDER BY toSCN_act desc,            -- for tag translation
             stamp_con desc;            -- to get most recent
 
 
 
CURSOR findBackupsetFiles(
   bskey                IN     number)
RETURN rcvRec_t IS
--
   SELECT backupSet_con_t       type_con,
          bdf_key               key_con,
          bdf_recid             recid_con,
          bdf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          bdf.blocks            blocks_con,
          bdf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          decode(bdf.incr_scn, 0, full_act_t, incremental_act_t)
                                type_act,
          bdf.incr_scn          fromSCN_act,
          bdf.ckp_scn           toSCN_act,
          bdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bdf.dbinc_key         dbincKey_act,
          bdf.incr_level        level_act,
          bdf.section_size      section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bdf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          bdf.abs_fuzzy_scn     afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          bdf.foreign_dbid      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          bdf.plugin_scn        pluginSCN_obj,
          bdf.plugin_reset_scn  pluginRlgSCN_obj,
          bdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          bdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bdf, bs, dbinc
    WHERE (allIncarnations = TRUE# OR
           canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
      AND dbinc.db_key     = this_db_key        -- belongs to this database
      AND dbinc.dbinc_key  = bdf.dbinc_key      -- join bdf and dbinc
      AND bdf.bs_key       = bs.bs_key          -- join bdf and bs
      AND bs.bs_key        = bskey
      AND bs.bck_type     != 'L'                -- only datafile backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
    UNION ALL
--
   SELECT backupSet_con_t       type_con,
          bcf_key               key_con,
          bcf_recid             recid_con,
          bcf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          nvl(bcf.blocks,0)     blocks_con,
          bcf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          bcf.ckp_scn           toSCN_act,
          bcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          bcf.autobackup_sequence
                                cfSequence_obj,
          bcf.autobackup_date   cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                 cfType_obj,
          bcf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bcf, bs, dbinc
    WHERE (allIncarnations = TRUE# OR
           canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
      AND dbinc.db_key     = this_db_key        -- belongs to this database
      AND dbinc.dbinc_key  = bcf.dbinc_key      -- join bcf and dbinc
      AND bcf.bs_key       = bs.bs_key          -- join bcf and bs
      AND bs.bs_key        = bskey
      AND bs.bck_type     != 'L'                -- ignore archivelog backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
    UNION ALL
--
   SELECT backupSet_con_t       type_con,
          bsf_recid             key_con,
          bsf_recid             recid_con,
          bsf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          0                     blocks_con,
          0                     blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          0                     toSCN_act,
          modification_time     toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bsf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bsf, bs, db
    WHERE bsf.bs_key = bs.bs_key                -- join bsf and bs
      AND bs.db_key = this_db_key               -- belongs to this database
      AND bsf.db_key = db.db_key                -- join bsf and db
      AND bs.bs_key = bskey
      AND bs.bck_type != 'L'                    -- ignore archivelog backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
    UNION ALL
--
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM brl, bs, dbinc
    WHERE (allIncarnations = TRUE# OR
           canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
      AND dbinc.db_key     = this_db_key        -- belongs to this database
      AND dbinc.dbinc_key  = brl.dbinc_key      -- join brl and dbinc
      AND brl.bs_key       = bs.bs_key          -- join brl and bs
      AND bs.bs_key        = bskey
      AND bs.bck_type      = 'L'                -- only archivelog backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
--
    ORDER BY dfNumber_obj,
             logThread_obj,
             logSequence_obj,
             logTerminal_obj desc;
 
--
--
--
 
CURSOR findProxyCopy(
   tag                  IN     varchar2       DEFAULT NULL
  ,handle               IN     varchar2       DEFAULT NULL
  ,deviceType           IN     varchar2       DEFAULT NULL
  ,statusMask           IN     binary_integer
  ,pdbKey               IN     number         DEFAULT NULL
  ,guid                 IN     varchar2       DEFAULT NULL)
RETURN rcvRec_t IS
   SELECT proxyCopy_con_t       type_con,
          xdf_key               key_con,
          xdf_recid             recid_con,
          xdf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xdf.ckp_scn           toSCN_act,
          xdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xdf.dbinc_key         dbincKey_act,
          incr_level            level_act,
          0                     section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          xdf.pdb_key           pdbKey_obj,
 
          xdf.keep_options      keep_options,
          xdf.keep_until        keep_until,
 
          xdf.abs_fuzzy_scn     afzSCN_act,
          xdf.rcv_fuzzy_time    rfzTime_act,
          xdf.rcv_fuzzy_scn     rfzSCN_act,
          xdf.media             media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          xdf.foreign_dbid      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          xdf.plugin_scn        pluginSCN_obj,
          xdf.plugin_reset_scn  pluginRlgSCN_obj,
          xdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xdf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = xdf.dbinc_key       -- join xdf and dbinc
      AND (findProxyCopy.tag IS NULL OR
           findProxyCopy.tag = tag)
      AND (findProxyCopy.handle IS NULL OR
           findProxyCopy.handle = handle)
      AND (findProxyCopy.deviceType IS NULL OR
           findProxyCopy.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
      AND (guid IS NULL OR findProxyCopy.pdbKey = xdf.pdb_key)
 
    UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xcf_key               key_con,
          xcf_recid             recid_con,
          xcf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- xcf doesn't have blocks
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xcf.ckp_scn           toSCN_act,
          xcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          xcf.pdb_key           pdbKey_obj,
 
          xcf.keep_options      keep_options,
          xcf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xcf, dbinc
    WHERE db_key = this_db_key          -- belongs to this database
      AND dbinc.dbinc_key = xcf.dbinc_key       -- join dbinc and xcf
      AND (findProxyCopy.tag IS NULL OR
           findProxyCopy.tag = tag)
      AND (findProxyCopy.handle IS NULL OR
           findProxyCopy.handle = handle)
      AND (findProxyCopy.deviceType IS NULL OR
           findProxyCopy.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
      AND (guid IS NULL OR findProxyCopy.pdbKey = xcf.pdb_key)
 
    UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          -1                    dfNumber_obj,         -- to sort last
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xal, dbinc
    WHERE db_key = this_db_key                  -- belongs to this database
      AND dbinc.dbinc_key = xal.dbinc_key       -- join dbinc and xal
--
      AND (findProxyCopy.tag IS NULL OR
           findProxyCopy.tag = tag)
      AND (findProxyCopy.handle IS NULL OR
           findProxyCopy.handle = handle)
      AND (findProxyCopy.deviceType IS NULL OR
           findProxyCopy.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
      AND (findProxyCopy.guid IS NULL)
 
    ORDER BY dfnumber_obj;
 
CURSOR findProxyCopyKey(
   key                  IN     number         DEFAULT NULL
  ,deviceType           IN     varchar2       DEFAULT NULL
  ,statusMask           IN     binary_integer)
RETURN rcvRec_t IS
   SELECT proxyCopy_con_t       type_con,
          xdf_key               key_con,
          xdf_recid             recid_con,
          xdf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xdf.ckp_scn           toSCN_act,
          xdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xdf.dbinc_key         dbincKey_act,
          incr_level            level_act,
          0                     section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          xdf.pdb_key           pdbKey_obj,
 
          xdf.keep_options      keep_options,
          xdf.keep_until        keep_until,
 
          xdf.abs_fuzzy_scn     afzSCN_act,
          xdf.rcv_fuzzy_time    rfzTime_act,
          xdf.rcv_fuzzy_scn     rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          xdf.foreign_dbid      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          xdf.plugin_scn        pluginSCN_obj,
          xdf.plugin_reset_scn  pluginRlgSCN_obj,
          xdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xdf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = xdf.dbinc_key       -- join xdf and dbinc
      AND (findProxyCopyKey.key = xdf_key)
      AND (findProxyCopyKey.deviceType IS NULL OR
           findProxyCopyKey.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
 
    UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xcf_key               key_con,
          xcf_recid             recid_con,
          xcf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- xcf doesn't have blocks
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xcf.ckp_scn           toSCN_act,
          xcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          xcf.pdb_key           pdbKey_obj,
 
          xcf.keep_options      keep_options,
          xcf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xcf, dbinc
    WHERE db_key = this_db_key          -- belongs to this database
      AND dbinc.dbinc_key = xcf.dbinc_key       -- join dbinc and xcf
      AND (findProxyCopyKey.key = xcf_key)
      AND (findProxyCopyKey.deviceType IS NULL OR
           findProxyCopyKey.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
   UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
      FROM xal, dbinc
    WHERE db_key = this_db_key                  -- belongs to this database
      AND dbinc.dbinc_key = xal.dbinc_key       -- join dbinc and xal
      AND (findProxyCopyKey.key = xal_key)
      AND (findProxyCopyKey.deviceType IS NULL OR
           findProxyCopyKey.deviceType = device_type)
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#;
 
 
--
--
--
--
--
--
--
--
--
 
CURSOR findArchivedLogCopy(
   currentIncarnation   IN     number
  ,thread               IN     number
  ,sequence             IN     number
  ,lowSCN               IN     number
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,statusMask           IN     binary_integer
  ,needstby             IN     number         DEFAULT NULL)
RETURN rcvRec_t IS
--
   SELECT imageCopy_con_t       type_con,
          al_key                key_con,
          recid                 recid_con,
          stamp                 stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          name                  fileName_con,
          to_date(null)         tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc_key             dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          sequence#             logSequence_obj,
          thread#               logThread_obj,
          resetlogs_change#     logRlgSCN_obj,
          resetlogs_time        logRlgTime_obj,
          first_change#         logLowSCN_obj,
          first_time            logLowTime_obj,
          next_change#          logNextSCN_obj,
          next_time             logNextTime_obj,
          terminal              logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM rc_archived_log
    WHERE db_key = this_db_key                    -- belongs to this database
      AND(findArchivedLogCopy.currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc_key)
      AND (thread IS NULL OR thread# = thread)
      AND (sequence IS NULL OR sequence# = sequence)
      AND (lowSCN IS NULL OR first_change# = lowSCN)
--
--
--
--
      AND (pattern IS NULL OR name LIKE pattern)
      AND (completedAfter IS NULL OR completion_time >= completedAfter)
      AND (completedBefore IS NULL OR completion_time <= completedBefore)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby is NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
--
      AND (archived = 'YES')
      AND (tc_thread IS NULL   OR thread# = tc_thread)
      AND (tc_fromSeq IS NULL  OR sequence# >= tc_fromSeq)
      AND (tc_toSeq IS NULL    OR sequence# <= tc_toSeq)
      AND (tc_fromSCN IS NULL  OR next_change# > tc_fromSCN)
      AND (tc_toSCN IS NULL    OR first_change# < tc_toSCN)
      AND (tc_pattern IS NULL  OR name like tc_pattern)
      AND (tc_fromTime IS NULL OR next_time > tc_fromTime)
      AND (tc_toTime IS NULL   OR first_time <= tc_toTime)
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal desc, stamp_con desc;
 
CURSOR findArcLogBackup(
   sourcemask           IN     number
  ,currentIncarnation   IN     number         DEFAULT TRUE#
  ,thread               IN     number
  ,sequence             IN     number
  ,lowSCN               IN     number
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable)
RETURN rcvRec_t IS
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM brl, bs, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND (thread IS NULL OR brl.thread# = thread)
      AND (sequence IS NULL OR brl.sequence# = sequence)
      AND (lowSCN IS NULL OR brl.low_scn = lowSCN)
      AND dbinc.dbinc_key = brl.dbinc_key      -- join dbinc, brl
      AND bs.bs_key       = brl.bs_key         -- join bs, brl
      AND bs.bck_type     = 'L'                -- only archivelog backups
--
--
      AND (completedAfter  IS NULL OR bs.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR bs.completion_time <= completedBefore)
      AND (tc_thread IS NULL       OR brl.thread# = tc_thread)
      AND (tc_fromSeq IS NULL      OR brl.sequence# >= tc_fromSeq)
      AND (tc_toSeq IS NULL        OR brl.sequence# <= tc_toSeq)
      AND (tc_fromSCN IS NULL      OR brl.next_scn > tc_fromSCN)
      AND (tc_toSCN IS NULL        OR brl.low_scn < tc_toSCN)
      AND (tc_fromTime IS NULL     OR brl.next_time > tc_fromTime)
      AND (tc_toTime IS NULL       OR brl.low_time <= tc_toTime)
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
 
--
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          xal.keep_options      keep_options,
          xal.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
      FROM xal, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND (thread IS NULL OR xal.thread# = thread)
      AND (sequence IS NULL OR xal.sequence# = sequence)
      AND (lowSCN IS NULL OR xal.low_scn = lowSCN)
      AND dbinc.dbinc_key = xal.dbinc_key      -- join dbinc, xal
      AND decode(statusMask, BSavailable,
                 decode(xal.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(xal.status, statusMask)) = TRUE#
      AND (findArcLogBackup.tag is NULL OR
           tag = findArcLogBackup.tag)
      AND (findArcLogBackup.pattern IS NULL OR
           xal.handle LIKE findArcLogBackup.pattern)
      AND (completedAfter  IS NULL OR xal.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR xal.completion_time <= completedBefore)
      AND (tc_thread IS NULL       OR xal.thread# = tc_thread)
      AND (tc_fromSeq IS NULL      OR xal.sequence# >= tc_fromSeq)
      AND (tc_toSeq IS NULL        OR xal.sequence# <= tc_toSeq)
      AND (tc_fromSCN IS NULL      OR xal.next_scn > tc_fromSCN)
      AND (tc_toSCN IS NULL        OR xal.low_scn < tc_toSCN)
      AND (tc_fromTime IS NULL     OR xal.next_time > tc_fromTime)
      AND (tc_toTime IS NULL       OR xal.low_time <= tc_toTime)
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
    ORDER BY logRlgSCN_obj,
             logRlgTime_obj,
             logThread_obj,
             logSequence_obj,
             logTerminal_obj desc,
             stamp_con desc;
 
--
--
--
CURSOR findRangeArcLogBackup(
   sourcemask           IN     number
  ,currentIncarnation   IN     number         DEFAULT TRUE#
  ,minthread            IN     number
  ,minsequence          IN     number
  ,minlowSCN            IN     number
  ,maxthread            IN     number
  ,maxsequence          IN     number
  ,maxlowSCN            IN     number
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable)
RETURN rcvRec_t IS
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM brl, bs, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND brl.thread# between minthread and maxthread
      AND brl.sequence# between minsequence and maxsequence
      AND brl.low_scn between minlowSCN and maxlowSCN
      AND dbinc.dbinc_key = brl.dbinc_key      -- join dbinc, brl
      AND bs.bs_key       = brl.bs_key         -- join bs, brl
      AND bs.bck_type     = 'L'                -- only archivelog backups
--
--
      AND (completedAfter  IS NULL OR bs.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR bs.completion_time <= completedBefore)
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
 
--
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
      FROM xal, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND xal.thread# between minthread and maxthread
      AND xal.sequence# between minsequence and maxsequence
      AND xal.low_scn between minlowSCN and maxlowSCN
      AND dbinc.dbinc_key = xal.dbinc_key      -- join dbinc, xal
      AND decode(statusMask, BSavailable,
                 decode(xal.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(xal.status, statusMask)) = TRUE#
      AND (findRangeArcLogBackup.tag is NULL OR
           tag = findRangeArcLogBackup.tag)
      AND (findRangeArcLogBackup.pattern IS NULL OR
           xal.handle LIKE findRangeArcLogBackup.pattern)
      AND (completedAfter  IS NULL OR xal.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR xal.completion_time <= completedBefore)
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
    ORDER BY logRlgSCN_obj desc,
             logRlgTime_obj desc,
             logLowSCN_obj desc,
             logTerminal_obj desc, -- records marked 'YES' must be first
             stamp_con desc;
 
CURSOR findAllBackupPiece(
   backupType           IN     binary_integer
  ,tag                  IN     varchar2
  ,statusMask           IN     binary_integer
  ,completedAfter       IN     date
  ,completedBefore      IN     date
  ,onlyrdf              IN     binary_integer)
RETURN rcvRec_t IS
   SELECT backupset_con_t       type_con,
          bp.bp_key             key_con,
          bp.bp_recid           recid_con,
          bp.bp_stamp           stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          bp.handle             fileName_con,
          bp.tag                tag_con,
          bp.copy#              copyNumber_con,
          bp.status             status_con,
          ceil(bp.bytes / bs.block_size)
                                blocks_con,
          bs.block_size         blockSize_con,
          bp.device_type        deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          bp.piece#             pieceNumber_con,
          bp.completion_time    bpCompTime_con,
          bp.compressed         bpCompressed_con,
          multi_section         multi_section_con,
 
          to_number(null)       type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          bp.media              media_con,
          is_recovery_dest_file isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bp, bs
    WHERE (bp.bs_key = bs.bs_key)       -- join bp and bs
      AND (bs.db_key = this_db_key)     -- this database
      AND (bp.status != 'D')
      AND (completedAfter IS NULL OR bs.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR bs.completion_time <= completedBefore)
      AND (findAllBackupPiece.tag IS NULL or bp.tag = findAllBackupPiece.tag)
      AND (anyDevice = TRUE# OR isDeviceTypeAllocated(bp.device_type) = TRUE#)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND (findAllBackupPiece.backupType IS NULL OR
           isBackupTypeMatch(bs.bck_type, backupType) = TRUE#)
      AND (findAllBackupPiece.onlyrdf = 0 OR
           bp.is_recovery_dest_file = 'YES')
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
    ORDER BY bs.bs_key, bp.device_type, bp.tag, bp.copy#, bp.piece#;
 
--
--
--
 
getValidBackupSetLast   validBackupSetRec_t;
 
getValidBackupSetCursor varchar2(30);    -- to indicate what cursor was used
 
--
--
--
--
 
--
--
--
 
--
--
--
 
CURSOR findValidBackupSet_c(
   bsKey                   IN number
  ,pieceCount              IN number
  ,deviceType              IN varchar2 DEFAULT NULL
  ,tag                     IN varchar2 DEFAULT NULL
  ,mask                    IN binary_integer)
RETURN dbms_rcvman.validBackupSetRec_t IS
 
--
--
--
--
--
--
 
--
--
   SELECT device_type, tag,
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          copy#, 1
     FROM rc_backup_piece
    WHERE bs_key = findValidBackupSet_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND (findValidBackupSet_c.tag IS NULL OR
           findValidBackupSet_c.tag = tag)
      AND (findValidBackupSet_c.deviceType IS NULL OR
           findValidBackupSet_c.deviceType = device_type)
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (localOrsSiteKey IS NULL OR 
           (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Disk', 'Local')) OR 
           (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Tape', 'Replication') AND 
            localOrsSiteKey = rc_backup_piece.site_key))
    GROUP BY device_type, tag, copy#
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = findValidBackupSet_c.pieceCount) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= findValidBackupSet_c.pieceCount))
 
    UNION ALL
 
--
--
--
   SELECT device_type, tag,
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          to_number(null), 2
     FROM rc_backup_piece
    WHERE bs_key = findValidBackupSet_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND (findValidBackupSet_c.tag IS NULL OR
           findValidBackupSet_c.tag = tag)
      AND (findValidBackupSet_c.deviceType IS NULL OR
           findValidBackupSet_c.deviceType = device_type)
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (localOrsSiteKey IS NULL OR 
           (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Disk', 'Local')) OR 
           (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Tape', 'Replication') AND
            localOrsSiteKey = rc_backup_piece.site_key))
    GROUP BY device_type, tag
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = findValidBackupSet_c.pieceCount) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= findValidBackupSet_c.pieceCount))
 
    UNION ALL
 
--
--
--
--
--
--
--
   SELECT device_type, to_char(null),
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          to_number(null), 3
     FROM rc_backup_piece
    WHERE bs_key = findValidBackupSet_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND (findValidBackupSet_c.tag IS NULL OR
           findValidBackupSet_c.tag = tag)
      AND (findValidBackupSet_c.deviceType IS NULL OR
           findValidBackupSet_c.deviceType = device_type)
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (localOrsSiteKey IS NULL OR 
           (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Disk', 'Local')) OR 
           (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Tape', 'Replication') AND
            localOrsSiteKey = rc_backup_piece.site_key))
    GROUP BY device_type
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = findValidBackupSet_c.pieceCount) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= findValidBackupSet_c.pieceCount))
    ORDER BY 1,2,3,4,5;
 
--
--
--
CURSOR findValidBackupSet1P_c(
   bsKey                   IN number
  ,pieceCount              IN number
  ,deviceType              IN varchar2 DEFAULT NULL
  ,tag                     IN varchar2 DEFAULT NULL
  ,mask                    IN binary_integer)
RETURN validBackupSetRec_t IS
 
--
--
--
--
--
--
--
--
--
   SELECT device_type, tag,
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          copy#, 1
      FROM rc_backup_piece
   WHERE bs_key = findValidBackupSet1P_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (findValidBackupSet1P_c.tag IS NULL OR
           findValidBackupSet1P_c.tag = tag)
      AND (findValidBackupSet1P_c.deviceType IS NULL OR
           findValidBackupSet1P_c.deviceType = device_type) ;
 
--
--
--
 
--
--
--
--
 
CURSOR findBackupPiece_c(
   tag          IN     varchar2 DEFAULT NULL
  ,handle       IN     varchar2 DEFAULT NULL
  ,deviceType   IN     varchar2 DEFAULT NULL
  ,copyNumber   IN     number   DEFAULT NULL
  ,statusMask   IN     binary_integer
  ,pdbKey       IN     number   DEFAULT NULL
  ,guid         IN     varchar2 DEFAULT NULL)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key               -- belongs to this db
      AND bs.db_key = this_db_key               -- belongs to this db
      AND bp.bs_key = bs.bs_key                 -- join bp and bs
      AND bp.status != 'D'
      AND (findBackupPiece_c.tag IS NULL OR
           tag = findBackupPiece_c.tag)
      AND (findBackupPiece_c.handle IS NULL OR
           handle = findBackupPiece_c.handle)
      AND (findBackupPiece_c.deviceType IS NULL OR
           device_type = findBackupPiece_c.deviceType)
      AND (findBackupPiece_c.copyNumber IS NULL OR
           copy# = findBackupPiece_c.copyNumber)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
      AND (guid IS NULL OR pdbKey = bp.pdb_key)
--
--
    ORDER BY piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
CURSOR findBackupPieceBpKey(
   bpKey        IN     number
  ,tag          IN     varchar2 DEFAULT NULL
  ,handle       IN     varchar2 DEFAULT NULL
  ,deviceType   IN     varchar2 DEFAULT NULL
  ,copyNumber   IN     number   DEFAULT NULL
  ,statusMask   IN     binary_integer)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key
      AND bs.db_key = this_db_key
      AND bp.status != 'D'
      AND bp.bs_key = bs.bs_key
      AND (bp_key = findBackupPieceBpKey.bpkey)
      AND (findBackupPieceBpKey.tag IS NULL OR
           tag = findBackupPieceBpKey.tag)
      AND (findBackupPieceBpKey.handle IS NULL OR
           handle = findBackupPieceBpKey.handle)
      AND (findBackupPieceBpKey.deviceType IS NULL OR
           device_type = findBackupPieceBpKey.deviceType)
      AND (findBackupPieceBpKey.copyNumber IS NULL OR
           copy# = findBackupPieceBpKey.copyNumber)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
--
    ORDER BY piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
CURSOR findBackupPieceBsKey1(
   bsKey        IN     number
  ,tag          IN     varchar2 DEFAULT NULL
  ,handle       IN     varchar2 DEFAULT NULL
  ,deviceType   IN     varchar2 DEFAULT NULL
  ,copyNumber   IN     number   DEFAULT NULL
  ,statusMask   IN     binary_integer)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key
      AND bs.db_key = this_db_key
      AND bp.status != 'D'
      AND bp.bs_key = bs.bs_key
      AND (bs.bs_key = findBackupPieceBsKey1.bsKey)
      AND (findBackupPieceBsKey1.tag IS NULL OR
           tag = findBackupPieceBsKey1.tag)
      AND (findBackupPieceBsKey1.handle IS NULL OR
           handle = findBackupPieceBsKey1.handle)
      AND (findBackupPieceBsKey1.deviceType IS NULL OR
           device_type = findBackupPieceBsKey1.deviceType)
      AND (findBackupPieceBsKey1.copyNumber IS NULL OR
           copy# = findBackupPieceBsKey1.copyNumber)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
--
    ORDER BY piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
CURSOR findBackupPieceBsKey2(
   startBsKey     IN      number
  ,tag            IN      varchar2
  ,statusMask     IN      binary_integer)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key
      AND bs.db_key = this_db_key
      AND bp.status != 'D'
      AND bp.bs_key = bs.bs_key
      AND (bs.bs_key >= startBsKey)
      AND (findBackupPieceBsKey2.tag IS NULL OR
           bp.tag = findBackupPieceBsKey2.tag)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
--
    ORDER BY bs.bs_key, device_type,
             piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
--
--
--
 
TYPE noRows_t IS RECORD
(
   error        number,                 -- error number
   msg          varchar2(100)           -- error msg
);
 
--
--
TYPE tablespace_t IS RECORD
(
   name   rc_tablespace.name%TYPE, -- tablespace name
   pdbId  number                   -- pdb id
);
TYPE tablespaceList_t IS TABLE OF tablespace_t INDEX BY BINARY_INTEGER;
skipTablespaceList    tablespaceList_t;
 
--
TYPE pdbNameList_t is table of number index by rc_pdbs.name%TYPE;
pdbNameList           pdbNameList_t;
 
--
--
TYPE pdbIdList_t is table of boolean index by binary_integer;
pdbIdList             pdbIdList_t;
 
--
TYPE pdbFileList_t is table of pdbFileRec_t index by binary_integer;
pdbFileList           pdbFileList_t;
 
--
--
--
 
getDatafileCursor varchar2(30);         -- pointer to current cursor
getDatafileNoRows noRows_t;             -- Set by function that opens cursor
getDatafileLast   dfRec_t;              -- The last row returned
 
--
--
--
--
--
--
--
--
CURSOR translateDatabase_c(
   fromSCN number,
   toSCN   number)
RETURN dfRec_t IS
   SELECT rcd.file#, rcd.creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          rcd.dbinc_key,
          offr.offline_scn, offr.online_scn, offr.online_time,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd, offr
    WHERE db_key = this_db_key AND                  -- belongs to this database
          rcd.dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          offr.file#(+) = rcd.file# AND         -- outer join with offr
          offr.create_scn(+) = creation_change# AND
          offr.dbinc_key(+) = this_dbinc_key AND
          offr.offr_stamp(+) = 0 AND          -- only offline ranges from kccfe
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) <= toSCN AND
          (drop_change# is null OR drop_change# > fromSCN) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
--
--
          (nvl(realf_site_key, translation_site_key) = site_key)
    ORDER BY rcd.file#;
 
CURSOR translateDatabaseOfPdbId_c(
   fromSCN number,
   toSCN   number,
   pdbId   number)
RETURN dfRec_t IS
   SELECT rcd.file#, rcd.creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          rcd.dbinc_key,
          offr.offline_scn, offr.online_scn, offr.online_time,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd, offr
    WHERE db_key = this_db_key AND                  -- belongs to this database
          rcd.dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          offr.file#(+) = rcd.file# AND         -- outer join with offr
          offr.create_scn(+) = creation_change# AND
          offr.dbinc_key(+) = this_dbinc_key AND
          offr.offr_stamp(+) = 0 AND          -- only offline ranges from kccfe
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) <= toSCN AND
          (drop_change# is null OR drop_change# > fromSCN) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
--
--
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          con_id = translateDatabaseOfPdbId_c.pdbId
    ORDER BY rcd.file#;
 
CURSOR translateDatabaseOfPdbIdL_c(
   fromSCN number,
   toSCN   number)
RETURN dfRec_t IS
   SELECT rcd.file#, rcd.creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          rcd.dbinc_key,
          offr.offline_scn, offr.online_scn, offr.online_time,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd, offr
    WHERE db_key = this_db_key AND                  -- belongs to this database
          rcd.dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          offr.file#(+) = rcd.file# AND         -- outer join with offr
          offr.create_scn(+) = creation_change# AND
          offr.dbinc_key(+) = this_dbinc_key AND
          offr.offr_stamp(+) = 0 AND          -- only offline ranges from kccfe
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) <= toSCN AND
          (drop_change# is null OR drop_change# > fromSCN) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
--
--
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          isTranslatedPdbId(con_id) = TRUE#
    ORDER BY rcd.file#;
 
--
--
CURSOR translateTablespace_c(
   tsName  varchar2
  ,pdbId   number)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd 
    WHERE db_key = this_db_key AND              -- part of this db
          tablespace_name = translateTablespace_c.tsName AND
          dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          ((untilSCN is null AND drop_change# is null) OR
           ((decode(plugin_change#, 0, creation_change#,
                    plugin_change#) <= untilSCN) AND
            (drop_change# is null or drop_change# > untilSCN))) AND
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
          con_id = translateTablespace_c.pdbId
    ORDER BY file#;
 
--
--
 
CURSOR translateDatafileName(
   fileName varchar2)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd 
    WHERE db_key = this_db_key AND              -- belongs to this database
          name = translateDatafilename.fileName AND -- filename matches
          dbinc_key = this_dbinc_key AND
          drop_change# is null AND      -- filename currently part of db
          (untilSCN is null OR
           decode(plugin_change#, 0, creation_change#,
                  plugin_change#) < untilSCN) AND
--
          ((untilSCN is null) OR         -- no until clause
           ((untilTime is not null) AND NOT EXISTS
            (SELECT 1
               FROM rci_datafile_this_dbinc 
              WHERE dbinc_key = this_dbinc_key AND
                    name = translateDatafilename.fileName AND
                    (plugin_change# != 0 OR
                     nvl(creation_time, MINDATEVAL) < untilTime) AND
                    drop_time > untilTime AND
                    (nvl(realf_site_key, translation_site_key) = site_key))) OR
           ((untilSCN is not null) AND NOT EXISTS
            (SELECT 1
               FROM rci_datafile_this_dbinc
              WHERE dbinc_key = this_dbinc_key AND
                    name = translateDatafilename.fileName AND
                    decode(plugin_change#, 0, creation_change#,
                           plugin_change#) < untilSCN AND
                    drop_change# > untilSCN AND
                    (nvl(realf_site_key, translation_site_key)=site_key)))) AND
          (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO');
 
--
--
 
CURSOR translateDatafileNumber(
   fno  number)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd
    WHERE db_key = this_db_key AND              -- belongs to this database
          file# = translateDataFileNumber.fno AND       -- filenumber matches
          dbinc_key = this_dbinc_key AND
          ((untilSCN is null AND drop_change# is null) OR
           ((nvl(creation_time, MINDATEVAL) < untilTime OR
             decode(plugin_change#, 0, creation_change#,
                    plugin_change#) < untilSCN) AND
            (drop_time > untilTime OR
             drop_change# > untilSCN OR
             drop_change# is null))) AND
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO');
 
--
--
 
CURSOR translateDatafileCheckpoint(
   fno          number
  ,ckpSCN       number)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd
    WHERE db_key = this_db_key                  -- belongs to this database
      AND file# = translateDatafileCheckpoint.fno       -- filenumber matches
      AND dbinc_key = this_dbinc_key
      AND translateDatafileCheckpoint.ckpSCN >=
          decode(plugin_change#, 0, creation_change#, plugin_change#)
      AND (drop_change# IS NULL OR
           translateDatafileCheckpoint.ckpSCN < drop_change#)
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
CURSOR translateAllDf_c
RETURN dfRec_t IS
   SELECT DISTINCT
          file#                 dfNumber,
          creation_change#      dfCreationSCN,
          creation_time         dfCreationTime,
          name                  fileName,
          tablespace_name       tsName,
          ts#                   tsNumber,
          to_char(null)         status,
          blocks                blocks,
          block_size            blockSize,
          bytes / 1024          kbytes,
          to_number(null)       unrecovSCN,
          stop_change#          stopSCN,
          FALSE#                readOnly,
          rfile#                rfNumber,
          decode(included_in_database_backup, 'YES', 1, 0)
                                inBackup,
          aux_name              auxNAme,
          dbinc_key             dbincKey,
          NULL                  dfOfflineSCN,
          NULL                  dfOnlineSCN,
          NULL                  dfOnlineTime,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile rcd
    WHERE db_key = this_db_key
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key)
    ORDER BY file#, decode(dbinc_key, this_dbinc_key, 0, 1),
             newDfCreationSCN desc;
 
CURSOR translateAllDfOfPdbId_c(
   pdbId number)
RETURN dfRec_t IS
   SELECT DISTINCT
          file#                 dfNumber,
          creation_change#      dfCreationSCN,
          creation_time         dfCreationTime,
          name                  fileName,
          tablespace_name       tsName,
          ts#                   tsNumber,
          to_char(null)         status,
          blocks                blocks,
          block_size            blockSize,
          bytes / 1024          kbytes,
          to_number(null)       unrecovSCN,
          stop_change#          stopSCN,
          FALSE#                readOnly,
          rfile#                rfNumber,
          decode(included_in_database_backup, 'YES', 1, 0)
                                inBackup,
          aux_name              auxNAme,
          dbinc_key             dbincKey,
          NULL                  dfOfflineSCN,
          NULL                  dfOnlineSCN,
          NULL                  dfOnlineTime,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile rcd
    WHERE db_key = this_db_key
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key)
      AND con_id = translateAllDfOfPdbId_c.pdbId
    ORDER BY file#, decode(dbinc_key, this_dbinc_key, 0, 1),
             newDfCreationSCN desc;
 
CURSOR translateAllDfOfPdbIdL_c
RETURN dfRec_t IS
   SELECT DISTINCT
          file#                 dfNumber,
          creation_change#      dfCreationSCN,
          creation_time         dfCreationTime,
          name                  fileName,
          tablespace_name       tsName,
          ts#                   tsNumber,
          to_char(null)         status,
          blocks                blocks,
          block_size            blockSize,
          bytes / 1024          kbytes,
          to_number(null)       unrecovSCN,
          stop_change#          stopSCN,
          FALSE#                readOnly,
          rfile#                rfNumber,
          decode(included_in_database_backup, 'YES', 1, 0)
                                inBackup,
          aux_name              auxNAme,
          dbinc_key             dbincKey,
          NULL                  dfOfflineSCN,
          NULL                  dfOnlineSCN,
          NULL                  dfOnlineTime,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile rcd
    WHERE db_key = this_db_key
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key)
      AND isTranslatedPdbId(con_id) = TRUE#
    ORDER BY file#, decode(dbinc_key, this_dbinc_key, 0, 1),
             newDfCreationSCN desc;
 
--
--
CURSOR translateCorruptList_c
RETURN dfRec_t IS
   SELECT DISTINCT
          rcd.file#, rcd.creation_change#, rcd.creation_time,
          rcd.name, rcd.tablespace_name, rcd.ts#,
          null, rcd.blocks, rcd.block_size, rcd.bytes / 1024,
          null, rcd.stop_change#, rcd.read_only, rcd.rfile#,
          decode(rcd.included_in_database_backup, 'YES', 1, 0),
          aux_name, rcd.dbinc_key, NULL, NULL, NULL,
          decode(rcd.encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          rcd.creation_thread,
          rcd.creation_size,
          rcd.con_id pdbId,
          rcd.pdb_key pdbKey,
          rcd.pdb_name pdbName,
          rcd.pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd,
          (select distinct file#
             from rc_database_block_corruption
            where dbinc_key = this_dbinc_key
              and corruption_type != 'NOLOGGING') bc
    WHERE rcd.db_key = this_db_key AND          -- belongs to this database
          rcd.file# = bc.file# AND              -- filenumber matches
          rcd.dbinc_key = this_dbinc_key AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
          ((untilSCN is null AND rcd.drop_change# is null) OR
           ((nvl(rcd.creation_time, MINDATEVAL) < untilTime OR
             decode(rcd.plugin_change#, 0, rcd.creation_change#,
                    rcd.plugin_change#) < untilSCN) AND
            (rcd.drop_time > untilTime OR
             rcd.drop_change# > untilSCN OR
             rcd.drop_change# is null))) AND
          (nvl(realf_site_key, translation_site_key) = site_key)
     ORDER BY rcd.file#;  -- do not change this as krmkcortr is
--
 
--
--
--
getTempfileCursor varchar2(30);         -- pointer to current cursor
 
--
--
--
--
CURSOR translateTempfile_c
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    ORDER BY file#;
 
CURSOR translateTempfileOfPdbId_c(
   pdbId number)
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    AND con_id = translateTempfileOfPdbId_c.pdbId
    ORDER BY file#;
 
CURSOR translateTempfileOfPdbIdL_c
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    AND isTranslatedPdbId(con_id) = TRUE#
    ORDER BY file#;
 
CURSOR translateTempfileName_c(fileName IN varchar2)
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND name = translateTempfileName_c.fileName -- filename matches
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    ORDER BY file#;
 
CURSOR translateTempfileNumber_c(fno IN number)
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND file# = translateTempfileNumber_c.fno -- filenumber matches
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    ORDER BY file#;
 
--
--
--
 
CURSOR translateOnlineLogs_c(srls IN number) IS
   SELECT thread#, group#, name
     FROM rc_redo_log
    WHERE dbinc_key = this_dbinc_key
     AND (nvl(realf_site_key, translation_site_key) = site_key)
     AND  ((type = 'ONLINE' AND srls = 0) OR
           (type = 'STANDBY' AND srls = 1))
    ORDER BY thread#, group#, name;
 
--
--
--
 
getArchivedLogNoRows            noRows_t;
getArchivedLogDuplicates        number;         -- Duplicate filtering flag
getArchivedLogLast              alRec_t;        -- used for duplicate filtering
getArchivedLogCursor            varchar2(40);
getArchivedLogDoingRecovery     number;        -- for filtering orphan logs
getArchivedLogOnlyrdf           number := 0;
getrcvRecLast                   rcvRec_t;
 
CURSOR translateArcLogKey(
   alKey        IN     number)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND archived = 'YES'
      AND al_key = translateArcLogKey.alKey;
 
CURSOR translateArcLogName(
   fname        IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number                       -- IGNORED!
  ,needstby     IN number  DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND name = translateArcLogName.fname
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby is NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
    ORDER BY is_recovery_dest_file desc, stamp desc;
 
CURSOR translateArcLogSeqRange(
   thread#      IN number
  ,incarn       IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number                       -- IGNORED!
  ,needstby     IN number  DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND dbinc_key = DECODE (translateArcLogSeqRange.incarn,
                                            -1, this_dbinc_key,
                                            0, dbinc_key,
                                            translateArcLogSeqRange.incarn)
      AND (translateArcLogSeqRange.thread# IS NULL OR
           thread# = translateArcLogSeqRange.thread#)
      AND sequence# between nvl(fromseq#, 0)
                        and nvl(toseq#, MAXSEQVAL)
      AND (pattern is null OR name like pattern)
      AND isstatusMatch(status,statusMask) = TRUE#
      AND archived = 'YES'  -- this will also filter out cleared logs
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             nvl(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
    ORDER BY thread#, sequence#, terminal DESC,
             is_recovery_dest_file DESC, stamp DESC;
 
--
CURSOR translateArcLogSeqRange2(
   thread#      IN number
  ,incarn       IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,statusMask   IN binary_integer  -- must atleast have BSdeleted
  ,online       IN number
  ,needstby     IN number  DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND dbinc_key = DECODE (translateArcLogSeqRange2.incarn,
                                            -1, this_dbinc_key,
                                            0, dbinc_key,
                                            translateArcLogSeqRange2.incarn)
      AND (translateArcLogSeqRange2.thread# IS NULL OR
           thread# = translateArcLogSeqRange2.thread#)
      AND sequence# between NVL(fromseq#, 0)
                        and NVL(toseq#, MAXSEQVAL)
      AND (archived = 'YES' OR     -- this will also filter out cleared logs
           (online = TRUE#
            and archived = 'NO'
            and name IS NOT NULL))
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
      AND isstatusMatch(status,statusMask) = TRUE#
 
    UNION ALL
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last (desc)
          brl.thread#,
          brl.sequence#,
          TO_CHAR(NULL),
          brl.low_scn,
          brl.low_time,
          brl.next_scn,
          brl.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          brl.blocks,
          brl.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          brl.terminal,
          0,
          0 site_key_order_col,
          0 source_dbid
     FROM brl, dbinc
    WHERE brl.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND brl.dbinc_key = DECODE (translateArcLogSeqRange2.incarn,
                                          -1, this_dbinc_key,
                                          0, brl.dbinc_key,
                                          translateArcLogSeqRange2.incarn)
      AND (translateArcLogSeqRange2.thread# IS NULL OR
           brl.thread# = translateArcLogSeqRange2.thread#)
      AND brl.sequence# BETWEEN NVL(fromseq#, 0)
                        AND NVL(toseq#, MAXSEQVAL)
--
--
 
    UNION                      -- to filter duplicates between brl and xal
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last (desc)
          xal.thread#,
          xal.sequence#,
          TO_CHAR(NULL),
          xal.low_scn,
          xal.low_time,
          xal.next_scn,
          xal.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          xal.blocks,
          xal.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          xal.terminal,
          xal.site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM xal, dbinc
    WHERE xal.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND xal.dbinc_key = DECODE (translateArcLogSeqRange2.incarn,
                                          -1, this_dbinc_key,
                                          0, xal.dbinc_key,
                                          translateArcLogSeqRange2.incarn)
      AND (translateArcLogSeqRange2.thread# IS NULL OR
           xal.thread# = translateArcLogSeqRange2.thread#)
      AND xal.sequence# BETWEEN NVL(fromseq#, 0)
                        AND NVL(toseq#, MAXSEQVAL)
--
--
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = NVL(xal.site_key, this_site_key)))))
 
--
--
    ORDER BY     4,       5,       21 DESC,                   18 DESC, 3 DESC;
 
--
CURSOR translateArcLogTimeRange(
   thread#      IN number
  ,incarn       IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number               -- IGNORED!
  ,needstby     IN number   DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR dbinc_key = this_dbinc_key)
      AND dbinc_key = DECODE (translateArcLogTimeRange.incarn,
                                       -1, this_dbinc_key,
                                       0, dbinc_key,
                                       translateArcLogTimeRange.incarn)
      AND (translateArcLogTimeRange.thread# IS NULL OR
           thread# = translateArcLogTimeRange.thread#)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND first_time  <= NVL(toTime, MAXDATEVAL)
      AND (pattern IS NULL OR name LIKE pattern)
      AND DECODE(statusMask, BSavailable,
                 DECODE(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND archived = 'YES'  -- this will also filter out cleared logs
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             nvl(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal DESC, is_recovery_dest_file DESC, stamp DESC;
 
--
--
CURSOR translateArcLogTimeRange2(
   thread#      IN number
  ,incarn       IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,statusMask   IN binary_integer  -- must atleast have BSdeleted
  ,online       IN number
  ,needstby     IN number   DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          DECODE(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR dbinc_key = this_dbinc_key)
      AND dbinc_key = DECODE (translateArcLogTimeRange2.incarn,
                                       -1, this_dbinc_key,
                                       0, dbinc_key,
                                       translateArcLogTimeRange2.incarn)
      AND (translateArcLogTimeRange2.thread# IS NULL OR
           thread# = translateArcLogTimeRange2.thread#)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND first_time  <= NVL(toTime, MAXDATEVAL)
      AND (archived = 'YES' OR   -- this will also filter out cleared logs
           (online = TRUE#
            AND archived = 'NO'
            AND name IS NOT NULL
            AND resetlogs_change# = this_reset_scn
            AND resetlogs_time = this_reset_time))
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             NVL(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
      AND isstatusMatch(status,statusMask) = TRUE#
 
    UNION ALL
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          thread#,
          sequence#,
          TO_CHAR(NULL),
          low_scn,
          low_time,
          next_scn,
          next_time,
          reset_scn,
          reset_time,
          blocks,
          block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          terminal,
          0,
          0 site_key_order_col,
          0 source_dbid
     FROM brl, dbinc
    WHERE brl.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR brl.dbinc_key = this_dbinc_key)
      AND dbinc.dbinc_key = DECODE (translateArcLogTimeRange2.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc.dbinc_key,
                                             translateArcLogTimeRange2.incarn)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND low_time  <= NVL(toTime, MAXDATEVAL)
      AND (translateArcLogTimeRange2.thread# IS NULL OR
           thread# = translateArcLogTimeRange2.thread#)
--
--
 
    UNION                      -- to filter duplicates between brl and xal
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          thread#,
          sequence#,
          TO_CHAR(NULL),
          low_scn,
          low_time,
          next_scn,
          next_time,
          reset_scn,
          reset_time,
          blocks,
          block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM xal, dbinc
    WHERE xal.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR xal.dbinc_key = this_dbinc_key)
      AND dbinc.dbinc_key = DECODE (translateArcLogTimeRange2.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc.dbinc_key,
                                             translateArcLogTimeRange2.incarn)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND low_time  <= NVL(toTime, MAXDATEVAL)
      AND (translateArcLogTimeRange2.thread# IS NULL OR
           thread# = translateArcLogTimeRange2.thread#)
--
--
--
--
--
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = NVL(xal.site_key, this_site_key)))))
 
    ORDER BY        11,         12,       4,       5,
                       21 DESC,     18 DESC,  3 DESC;
 
--
--
CURSOR translateArcLogSCNRange(
   thread#      IN number
  ,incarn       IN number
  ,sequence#    IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number
  ,needstby     IN number  DEFAULT NULL
  ,reset_scn    IN number
  ,reset_time   IN date)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          DECODE(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange.reset_scn IS NULL OR
              (translateArcLogSCNRange.reset_scn = resetlogs_change# AND
               translateArcLogSCNRange.reset_time = resetlogs_time))) OR
           (dbinc_key = this_dbinc_key))
      AND dbinc_key = DECODE (translateArcLogSCNRange.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc_key,
                                             translateArcLogSCNRange.incarn)
      AND (translateArcLogSCNRange.thread# IS NULL OR
           thread# = translateArcLogSCNRange.thread#)
      AND (translateArcLogSCNRange.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange.sequence#)
      AND next_change# > NVL(fromSCN, 0)
      AND first_change#  < NVL(toSCN, MAXSCNVAL)
      AND (pattern IS NULL OR name LIKE pattern)
      AND decode(statusMask, BSavailable,
                 DECODE(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND (archived = 'YES' OR      -- this will also filter out cleared logs
           (online = TRUE#
            and archived = 'NO'
            and name IS NOT NULL
            and resetlogs_change# = this_reset_scn
            and resetlogs_time = this_reset_time))
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             NVL(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal DESC, is_recovery_dest_file DESC, stamp DESC;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
CURSOR translateArcLogSCNRange2(
   thread#      IN number
  ,incarn       IN number
  ,sequence#    IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,toTime       IN date
  ,statusMask   IN binary_integer  -- must atleast have BSdeleted
  ,online       IN number
  ,needstby     IN number  DEFAULT NULL  -- IGNORED
  ,reset_scn    IN number
  ,reset_time   IN date)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          DECODE(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          DECODE(next_change#, highscnval, -1,
                 DECODE(site_key, this_site_key, 1, 0)) site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange2.reset_scn IS NULL OR
              (translateArcLogSCNRange2.reset_scn = resetlogs_change# AND
               translateArcLogSCNRange2.reset_time = resetlogs_time))) OR
           (dbinc_key = this_dbinc_key))
      AND dbinc_key = DECODE (translateArcLogSCNRange2.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc_key,
                                             translateArcLogSCNRange2.incarn)
      AND (translateArcLogSCNRange2.thread# IS NULL OR
           thread# = translateArcLogSCNRange2.thread#)
      AND (translateArcLogSCNRange2.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange2.sequence#)
      AND next_change# > NVL(fromSCN, 0)
      AND first_change#  < NVL(toSCN, MAXSCNVAL)
      AND (toTime IS NULL OR first_time < toTime)
      AND (archived = 'YES' OR   -- this will also filter out cleared logs
           (online = TRUE#
            and archived = 'NO'
            and name IS NOT NULL
            and resetlogs_change# = this_reset_scn
            and resetlogs_time = this_reset_time))
      AND isstatusMatch(status,statusMask) = TRUE#
 
    UNION ALL
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          brl.thread#,
          brl.sequence#,
          TO_CHAR(NULL),
          brl.low_scn,
          brl.low_time,
          brl.next_scn,
          brl.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          brl.blocks,
          brl.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          brl.terminal,
          0,
          0 site_key_order_col,
          0 source_dbid
     FROM brl, dbinc
    WHERE brl.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange2.reset_scn IS NULL OR
               (translateArcLogSCNRange2.reset_scn = dbinc.reset_scn AND
                translateArcLogSCNRange2.reset_time = dbinc.reset_time))) OR
           (dbinc.dbinc_key = this_dbinc_key))
      AND brl.dbinc_key = DECODE (translateArcLogSCNRange2.incarn,
                                               -1, this_dbinc_key,
                                               0, brl.dbinc_key,
                                               translateArcLogSCNRange2.incarn)
      AND (translateArcLogSCNRange2.thread# IS NULL OR
           thread# = translateArcLogSCNRange2.thread#)
      AND (translateArcLogSCNRange2.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange2.sequence#)
      AND next_scn > NVL(fromSCN, 0)
      AND low_scn  < NVL(toSCN, MAXSCNVAL)
      AND (toTime IS NULL OR low_time < toTime)
--
--
 
    UNION                      -- to filter duplicates between brl and xal
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          xal.thread#,
          xal.sequence#,
          TO_CHAR(NULL),
          xal.low_scn,
          xal.low_time,
          xal.next_scn,
          xal.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          xal.blocks,
          xal.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          xal.terminal,
          xal.site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM xal, dbinc
    WHERE xal.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange2.reset_scn IS NULL OR
              (translateArcLogSCNRange2.reset_scn = dbinc.reset_scn AND
               translateArcLogSCNRange2.reset_time = dbinc.reset_time))) OR
           (dbinc.dbinc_key = this_dbinc_key))
      AND xal.dbinc_key = DECODE (translateArcLogSCNRange2.incarn,
                                        -1, this_dbinc_key,
                                        0, xal.dbinc_key,
                                        translateArcLogSCNRange2.incarn)
      AND (translateArcLogSCNRange2.thread# IS NULL OR
           thread# = translateArcLogSCNRange2.thread#)
      AND (translateArcLogSCNRange2.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange2.sequence#)
      AND next_scn > NVL(fromSCN, 0)
      AND low_scn  < NVL(toSCN, MAXSCNVAL)
      AND (toTime IS NULL OR low_time < toTime)
--
--
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = NVL(xal.site_key, this_site_key)))))
 
--
--
--
    ORDER BY         11,         12,       4,       5, 21 DESC,
                     23 DESC,      18 DESC,  3 DESC;
 
CURSOR translateArcLogPattern(
   pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number                       -- IGNORED!
  ,needstby     IN number   DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE (canApplyAnyRedo = TRUE# OR dbinc_key = this_dbinc_key)
      AND db_key = this_db_key
      AND (pattern is null or name like pattern)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND archived = 'YES'
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby is NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal desc, is_recovery_dest_file desc, stamp desc;
 
--
--
--
 
getControlFileCopySingleRow     boolean;
getControlFileCopyCursor        varchar2(30);
 
--
--
--
 
getDatafileCopyCursor           varchar2(30);
getDatafileCopyNoRows           noRows_t;
getDatafileCopyDuplicates       number;   -- match file number
getDatafileCopyLast             rcvRec_t;
getDatafileCopySingleRow        boolean;
getDatafileCopyLatestOnly       boolean;
 
--
--
--
 
getProxyCopyCursor              varchar2(30);
getProxyCopyNoRows              noRows_t;
getProxyCopyByHandle            boolean;
 
--
--
--
 
getBackupPieceCursor            varchar2(30);
getBackupPieceNoRows            noRows_t;
getBackupPieceDuplicates        number; -- TRUE# -> duplicates OK
--
getBackupPieceLast              bpRec_t;
--
--
getBackupPieceDeviceType        bp.device_type%TYPE;
getBackupPieceExpectedPieces    number;
getBackupPiecePieceCount        number;
getBackupPieceByHandle          boolean;
getBackupPieceAvailableMask     binary_integer;
getBackupPieceSeekLast          bpRec_t;
getBackupPieceCopyNumber        number;
getBackupPieceBskey             number;
 
--
--
--
findSpfileBackupCursor          boolean; -- TRUE# -> cursor opened
findControlfileBackupCursor     boolean; -- TRUE# -> cursor opened
 
 
--
--
--
 
listGetBackupTag                bp.tag%TYPE;
listGetBackupAvailableMask      binary_integer;
 
listGetProxyDatafileCursor      varchar2(30);
 
 
--
--
 
CURSOR lbal2(thread#       number,
             lowseq        number,
             highseq       number,
             lowscn        number,
             highscn       number,
             from_time     date  ,
             until_time    date)
RETURN rcvRec_t IS
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
  from  brl, bs, dbinc
  where dbinc.db_key    = this_db_key      -- this database
  and   dbinc.dbinc_key = brl.dbinc_key    -- join dbinc, brl
  and   bs.bs_key       = brl.bs_key       -- join bs, brl
  and  (lbal2.thread# is null or brl.thread# = lbal2.thread#)
  and  (brl.sequence# between nvl(lbal2.lowseq, 0)
                     and     nvl(lbal2.highseq, MAXSEQVAL))
  and  (lowscn        is null or brl.low_scn >= lowscn)
  and  (highscn       is null or brl.next_scn<  highscn)
  and  (from_time     is null or bs.completion_time >= from_time)
  and  (until_time    is null or bs.completion_time <= until_time)
--
  and   bs.status != 'D'
  and   bs.bck_type = 'L'                  -- only archivelog backups
  order by bs.bs_key, brl.thread#, brl.sequence#, brl.terminal desc;
 
CURSOR ldbi(
   db_name varchar2,
   all_databases number)
IS
   SELECT db_key, dbinc_key, name, dbid, current_incarnation,
          resetlogs_change#, resetlogs_time, status dbinc_status
     FROM rc_database_incarnation
    WHERE (all_databases = 1) OR -- user wants all database incarnations
          ((all_databases = 0) AND
           ((name = ldbi.db_name) OR -- user asked for specific database
            (db_name is NULL AND this_db_key=db_key))) -- user wants mounted db
    ORDER BY db_key, resetlogs_change#, dbinc_key;
 
CURSOR lnni(
   db_name varchar2,
   alldbs  number)
IS
   SELECT node.db_key, dbid, name, database_role, db_unique_name
     FROM rc_database, node
    WHERE rc_database.db_key = node.db_key
      AND ((alldbs = 1) OR
           (lnni.db_name IS NOT NULL AND upper(lnni.db_name) = name) OR
           (lnni.db_name IS NULL AND this_db_key = node.db_key))
      AND substr(nvl(db_unique_name, 'A'),1,1) <> '$'
    ORDER BY dbid, database_role;
--
 
CURSOR lrtbs
IS
   SELECT DISTINCT ts.ts#, ts.ts_name, pdbinc.name
     FROM ts, tsatt, ckp, rci_pdbinc_this_dbinc pdbinc
 
--
    WHERE pdbinc.dbinc_key = this_dbinc_key 
      AND ts.pdbinc_key    = pdbinc.pdbinc_key
      AND (untilSCN is NULL or pdbinc.create_scn < untilSCN)
      AND (pdbinc.drop_scn is NULL or pdbinc.drop_scn > untilSCN)
      AND ts.dbinc_key     = tsatt.dbinc_key
      AND ts.ts#           = tsatt.ts#
      AND ts.pdbinc_key    = tsatt.pdbinc_key
      AND ts.create_scn    = tsatt.create_scn
--
--
--
      AND ckp.ckp_key(+)   = tsatt.end_ckp_key
 
--
      AND ts.dbinc_key     = this_dbinc_key
 
--
--
--
      AND (ts.create_scn < untilSCN or untilSCN is NULL)
 
--
--
--
--
--
      AND (ts.drop_scn > untilSCN or ts.drop_scn is NULL)
 
--
--
--
--
      AND (ckp.ckp_scn > untilSCN or ckp.ckp_scn is NULL)
 
--
--
      AND tsatt.rbs_count > 0
    ORDER BY 1,    -- ts#
             3;    -- pdbname
 
--
--
--
 
rcvRec_last     rcvRec_t;                       -- last record returned from:
--
--
 
--
--
--
 
CURSOR getOfflineRangeCopy_c(
   offrRecid    number
  ,offrCkpSCN   number
  ,cfCreTime    date
  ,dbincKey     number)
RETURN rcvRec_t IS
   SELECT imageCopy_con_t       type_con,
          ccf_key               key_con,
          ccf_recid             recid_con,
          ccf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- ccf doesn't have blocks
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          create_time           cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          ccf.ckp_scn           toSCN_act,
          ccf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          ccf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          ccf.pdb_key           pdbKey_obj,
 
          ccf.keep_options      keep_options,
          ccf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM ccf, dbinc
    WHERE dbinc.dbinc_key = getOfflineRangeCopy_c.dbincKey
      AND dbinc.dbinc_key = ccf.dbinc_key
      AND getOfflineRangeCopy_c.cfCretime = create_time
      AND getOfflineRangeCopy_c.offrCkpSCN < ccf.ckp_scn
      AND getOfflineRangeCopy_c.offrRecid >= min_offr_recid
      AND status = 'A'
      AND ((user_site_key = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
    ORDER BY stamp_con desc;
 
--
--
 
cursor rddf is
 
--
 
  select 2 preference,
         file#, COPY filetype, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0 incremental_change#,
         decode(decode(online_fuzzy,'NO',0,1)+decode(backup_fuzzy,'NO',0,1),
            0,greatest(nvl(absolute_fuzzy_change#,0),
                       nvl(recovery_fuzzy_change#,0)),
            maxscnval) fuzzy_change#,
            recid, stamp, name, 0 set_stamp, 0 set_count, cdf_key key,
            completion_time, 'DISK' device_type
  from rc_datafile_copy
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key = rc_datafile_copy.site_key) OR
         (user_site_key IS NULL AND
          ((disk_backups_shared = TRUE#) OR
           (this_site_key = nvl(rc_datafile_copy.site_key, this_site_key)))))
 
  union all
 
--
 
  select 3,
         file#, PROXY, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0,
         decode(decode(online_fuzzy,'NO',0,1)+decode(backup_fuzzy,'NO',0,1),
            0,greatest(nvl(absolute_fuzzy_change#,0),
                       nvl(recovery_fuzzy_change#,0)),
            maxscnval),
            recid, stamp, handle, 0, 0, xdf_key, completion_time, device_type
  from rc_proxy_datafile
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key  = rc_proxy_datafile.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(rc_proxy_datafile.site_key, this_site_key)))))
 
  union all
 
--
 
  select decode(bs.bck_type, 'D', 4,
                             'I', 5),
         file#,
         decode(bs.bck_type, 'D', FULL_DF_BACKUP,
                             'I', INCREMENTAL_DF_BACKUP),
         bdf.ckp_scn, bdf.ckp_time,
         dbinc.reset_scn, dbinc.reset_time, bdf.incr_scn,
         nvl(bdf.abs_fuzzy_scn,0),
         bs.bs_recid, bs.bs_stamp, null, bs.set_stamp, bs.set_count, bs.bs_key,
         bs.completion_time, null
  from bdf, bs, dbinc
  where dbinc.db_key    = this_db_key          -- this database
  and   dbinc.dbinc_key = bdf.dbinc_key        -- join dbinc, bdf
  and   bdf.bs_key      = bs.bs_key            -- join bdf, bs
  and   bs.status      != 'D'
  and   bs.bck_type    != 'L'                  -- only datafile backups
  and   (bs.site_key IS NULL         OR        -- always return null site_key
         user_site_key = bs.site_key OR        -- user interested in one site
         (user_site_key IS NULL AND            -- return rows per access attr
          (disk_backups_shared = TRUE# OR
           tape_backups_shared = TRUE# OR
           this_site_key = bs.site_key)))
 
  union all
 
--
 
  select 2,
         0, COPY, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0, 0, recid, stamp, name, 0, 0,
         ccf_key, completion_time, 'DISK'
  from rc_controlfile_copy
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key = rc_controlfile_copy.site_key) OR
         (user_site_key IS NULL AND
          ((disk_backups_shared = TRUE#) OR
           (this_site_key = nvl(rc_controlfile_copy.site_key,this_site_key)))))
 
  union all
 
--
 
  select 3,
         0, PROXY, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0, 0, recid, stamp, handle, 0, 0,
         xcf_key, completion_time, device_type
  from rc_proxy_controlfile
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key  = rc_proxy_controlfile.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key =nvl(rc_proxy_controlfile.site_key,this_site_key)))))
 
  union all
 
--
 
  select 4,
         0, FULL_DF_BACKUP,
         bcf.ckp_scn, bcf.ckp_time, dbinc.reset_scn, dbinc.reset_time,
         0, 0, bs.bs_recid, bs.bs_stamp, null,
         bs.set_stamp, bs.set_count, bs.bs_key, bs.completion_time, null
  from bcf, bs, dbinc
  where dbinc.db_key = this_db_key              -- this database
  and   dbinc.dbinc_key = bcf.dbinc_key         -- join dbinc, bcf
  and   bcf.bs_key = bs.bs_key                  -- join bcf, bs
  and   bs.status != 'D'
  and   bs.bck_type != 'L'                      -- ignore archivelog backups
  and   (bs.site_key IS NULL         OR         -- always return null site_key
         user_site_key = bs.site_key OR         -- user interested in one site
         (user_site_key IS NULL AND             -- return rows per access attr
          (disk_backups_shared = TRUE# OR
           tape_backups_shared = TRUE# OR
           this_site_key = bs.site_key)))
 
  union all
 
--
 
  select 1,
         file#, OFFLINE_RANGE, online_change#, online_time,
         resetlogs_change#, resetlogs_time, offline_change#, 0,
         recid, stamp, null, 0, 0, 0, online_time, null
  from rc_offline_range ofr
  where ofr.db_key = this_db_key
 
--
--
 
  order by 2 asc,  -- file#
           4 desc, -- checkpoint_change#
           1 asc,  -- preference
          15 desc; -- completion_time, to break ties if all else is equal
 
--
--
--
--
CURSOR translateDatabaseCorruption_c(dfnumber IN number)
IS
   SELECT file#, block#, blocks
     FROM rc_database_block_corruption bc
    WHERE bc.db_key = this_db_key AND           -- belongs to this database
          bc.dbinc_key = this_dbinc_key AND
          bc.file# = nvl(translateDatabaseCorruption_c.dfnumber, bc.file#) AND
          bc.corruption_type != 'NOLOGGING'
    ORDER BY file#, block#;   -- order same as in translateCorruptList_c.
--
--
--
 
 
--
--
--
 
CURSOR cntConfig_c
IS
   SELECT COUNT(*) FROM CONF
   WHERE db_key         = this_db_key
   AND   db_unique_name = nvl(user_db_unique_name, this_db_unique_name);
 
CURSOR getPrimarySite_c
IS
   SELECT db_unique_name FROM NODE
   WHERE db_key        = this_db_key
   AND   database_role = 'PRIMARY';
 
CURSOR findConfig_c(
   name varchar2,
   value varchar2,
   db_unique_name varchar2)
IS
    SELECT conf#, name, value
    FROM   rc_rman_configuration rm
    WHERE  db_key = this_db_key                  -- part of this database
    AND    (findConfig_c.name is null OR
            UPPER(findConfig_c.name) = UPPER(rm.name)) AND
           (findConfig_c.value is null OR
            UPPER(findConfig_c.value) = UPPER(rm.value)) AND
--
           ((nvl(findConfig_c.db_unique_name, rm.db_unique_name) =
             rm.db_unique_name) OR
            rm.db_unique_name IS NULL)                  -- generic conf rows
    ORDER BY conf#;
--
--
 
--
--
--
 
getLastBackupHistory bhistoryRec_t;
 
--
CURSOR dfBackupHistory_c1(
   file#       IN   number
  ,crescn      IN   number
  ,device_type IN   varchar2)
RETURN bhistoryRec_t IS
   SELECT
      bdf.file#                dfNumber,
      bdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bdf.ckp_scn              ckp_scn,
      bdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM bdf,
        dbinc,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT /*+no_merge*/ file#, create_scn, stop_scn, pdbinc_key
           FROM df
          WHERE create_scn = dfBackupHistory_c1.crescn
            AND file#      = dfBackupHistory_c1.file#
            AND dbinc_key  = this_dbinc_key) df,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (dfBackupHistory_c1.device_type IS NULL OR
                 dfBackupHistory_c1.device_type = bp.device_type)
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bdf.dbinc_key    = dbinc.dbinc_key       -- join dbinc, bdf
     AND dbinc.db_key     = this_db_key           -- this database
     AND bdf.create_scn   = df.create_scn         -- create scn match
     AND bdf.file#        = df.file#              -- join bdf, df
     AND bdf.bs_key       = bs.bs_key             -- join bdf, bs
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND bdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      cdf.file#                dfNumber,
      cdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      cdf.ckp_scn              ckp_scn,
      cdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      cdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM cdf,
        dbinc,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT /*+no_merge */ file#, create_scn, stop_scn, pdbinc_key
           FROM df
          WHERE create_scn = dfBackupHistory_c1.crescn
            AND file#      = dfBackupHistory_c1.file#
            AND dbinc_key  = this_dbinc_key) df
   WHERE cdf.dbinc_key   = dbinc.dbinc_key       -- join dbinc, cdf
     AND dbinc.db_key    = this_db_key           -- this database
     AND cdf.create_scn  = df.create_scn         -- create scn match
     AND cdf.file#       = df.file#              -- join cdf, df
     AND cdf.status      = 'A'                   -- available copy
     AND (dfBackupHistory_c1.device_type IS NULL OR
          dfBackupHistory_c1.device_type = 'DISK')
     AND ((user_site_key = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = dbinc.dbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND cdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      xdf.file#                dfNumber,
      xdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      xdf.ckp_scn              ckp_scn,
      xdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM xdf,
        dbinc,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT /*+no_merge*/ file#, create_scn, stop_scn, pdbinc_key
           FROM df
          WHERE create_scn = dfBackupHistory_c1.crescn
            AND file#      = dfBackupHistory_c1.file#
            AND dbinc_key  = this_dbinc_key) df
   WHERE xdf.dbinc_key   = dbinc.dbinc_key       -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key           -- this database
     AND xdf.create_scn  = df.create_scn         -- create scn match
     AND xdf.file#       = df.file#              -- join xdf, df
     AND xdf.status      = 'A'                   -- available proxy df
     AND (dfBackupHistory_c1.device_type IS NULL OR
          dfBackupHistory_c1.device_type = xdf.device_type)
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND xdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
--
   ORDER BY  dfNumber,
             create_scn,
             reset_scn,
             reset_time,
             ckp_scn  desc,
             stop_scn desc,
             compTime;
 
CURSOR dfBackupHistory_c2(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      bdf.file#                dfNumber,
      bdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bdf.ckp_scn              ckp_scn,
      bdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(bdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      bdf.plugin_scn           pluginSCN,
      bdf.plugin_reset_scn     pluginRlgSCN,
      bdf.plugin_reset_time    pluginRlgTime,
      decode(bdf.plugin_scn, 0,
             bdf.create_scn, bdf.plugin_scn)
                               newcreate_scn,
      decode(bdf.plugin_reset_scn, 0,
             dbinc.reset_scn, bdf.plugin_reset_scn)
                               newreset_scn,
      nvl(bdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM bdf,
        dbinc,
        df,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
            AND (dfBackupHistory_c2.cmd is null OR       -- bug 6658764
                 dfBackupHistory_c2.cmd != 'B' OR
                 (dfBackupHistory_c2.cmd = 'B' AND       -- Backup command and
                  (dfBackupHistory_c2.ktag is null AND   -- nokeep cmd matches
                   bs.keep_options = 0) OR               -- nokeep backup or
                  (dfBackupHistory_c2.ktag = bp.tag and  -- keep backup cmd tag
                   bs.keep_options != 0)))               -- matches keep backup
            AND (dfBackupHistory_c2.device_type IS NULL OR
                 dfBackupHistory_c2.device_type = bp.device_type)
            AND ((dfBackupHistory_c2.pattern1 IS NULL AND
                  dfBackupHistory_c2.pattern2 IS NULL AND
                  dfBackupHistory_c2.pattern3 IS NULL AND
                  dfBackupHistory_c2.pattern4 IS NULL) OR
                 (bp.handle LIKE dfBackupHistory_c2.pattern1 OR
                  bp.handle LIKE dfBackupHistory_c2.pattern2 OR
                  bp.handle LIKE dfBackupHistory_c2.pattern3 OR
                  bp.handle LIKE dfBackupHistory_c2.pattern4))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bdf.dbinc_key   = dbinc.dbinc_key       -- join dbinc, bdf
     AND dbinc.db_key    = this_db_key           -- this database
     AND df.dbinc_key    = this_dbinc_key        -- this incarnation
     AND ((df.plugin_scn = 0  AND                -- create/plugin scn match
           bdf.plugin_scn = 0 AND
           bdf.create_scn = df.create_scn) OR
          (df.plugin_scn != 0 AND
           bdf.plugin_scn = df.plugin_scn))
     AND bdf.file#       = df.file#              -- join bdf, df
     AND bdf.bs_key      = bs.bs_key             -- join bdf, bs
     AND (tc_database = TRUE# OR isTranslatedFno(df.file#) = TRUE#)
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND bdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      cdf.file#                dfNumber,
      cdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      cdf.ckp_scn              ckp_scn,
      cdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      cdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(cdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      cdf.plugin_scn           pluginSCN,
      cdf.plugin_reset_scn     pluginRlgSCN,
      cdf.plugin_reset_time    pluginRlgTime,
      decode(cdf.plugin_scn, 0,
             cdf.create_scn, cdf.plugin_scn)
                               newcreate_scn,
      decode(cdf.plugin_reset_scn, 0,
             dbinc.reset_scn, cdf.plugin_reset_scn)
                               newreset_scn,
      nvl(cdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM cdf,
        dbinc,
        df,
        rci_pdbinc_this_dbinc pdbinc
   WHERE cdf.dbinc_key   = dbinc.dbinc_key       -- join dbinc, cdf
     AND dbinc.db_key    = this_db_key           -- this database
     AND df.dbinc_key    = this_dbinc_key        -- this incarnation
     AND ((df.plugin_scn = 0  AND                -- create/plugin scn match
           cdf.plugin_scn = 0 AND
           cdf.create_scn = df.create_scn) OR
          (df.plugin_scn != 0 AND
           cdf.plugin_scn = df.plugin_scn))
     AND cdf.file#       = df.file#              -- join cdf, df
     AND cdf.status      = 'A'                   -- available copy
     AND (tc_database = TRUE# OR isTranslatedFno(df.file#) = TRUE#)
     AND (dfBackupHistory_c2.cmd is null OR        -- bug 6658764
          dfBackupHistory_c2.cmd != 'B' OR
          (dfBackupHistory_c2.cmd = 'B' AND        -- Backup command and
           (dfBackupHistory_c2.ktag is null AND    -- nokeep cmd matches
            cdf.keep_options = 0) OR               -- nokeep backup or
           (dfBackupHistory_c2.ktag = cdf.tag and  -- keep backup cmd tag
            cdf.keep_options != 0)))               -- matches keep backup
     AND (dfBackupHistory_c2.device_type IS NULL OR
          dfBackupHistory_c2.device_type = 'DISK')
     AND ((dfBackupHistory_c2.pattern1 IS NULL AND
           dfBackupHistory_c2.pattern2 IS NULL AND
           dfBackupHistory_c2.pattern3 IS NULL AND
           dfBackupHistory_c2.pattern4 IS NULL) OR
          (cdf.fname LIKE dfBackupHistory_c2.pattern1 OR
           cdf.fname LIKE dfBackupHistory_c2.pattern2 OR
           cdf.fname LIKE dfBackupHistory_c2.pattern3 OR
           cdf.fname LIKE dfBackupHistory_c2.pattern4))
     AND ((user_site_key = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND cdf.ckp_scn NOT BETWEEN                   -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      xdf.file#                dfNumber,
      xdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      xdf.ckp_scn              ckp_scn,
      xdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(xdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      xdf.plugin_scn           pluginSCN,
      xdf.plugin_reset_scn     pluginRlgSCN,
      xdf.plugin_reset_time    pluginRlgTime,
      decode(xdf.plugin_scn, 0,
             xdf.create_scn, xdf.plugin_scn)
                               newcreate_scn,
      decode(xdf.plugin_reset_scn, 0,
             dbinc.reset_scn, xdf.plugin_reset_scn)
                               newreset_scn,
      nvl(xdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM xdf,
        dbinc,
        df,
        rci_pdbinc_this_dbinc pdbinc
   WHERE xdf.dbinc_key   = dbinc.dbinc_key       -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key           -- this database
     AND df.dbinc_key    = this_dbinc_key        -- this incarnation
     AND ((df.plugin_scn = 0  AND                -- create/plugin scn match
           xdf.plugin_scn = 0 AND
           xdf.create_scn = df.create_scn) OR
          (df.plugin_scn != 0 AND
           xdf.plugin_scn = df.plugin_scn))
     AND xdf.file#       = df.file#              -- join xdf, df
     AND xdf.status      = 'A'                   -- available proxy df
     AND (tc_database = TRUE# OR isTranslatedFno(df.file#) = TRUE#)
     AND (dfBackupHistory_c2.cmd is null OR        -- bug 6658764
          dfBackupHistory_c2.cmd != 'B' OR
          (dfBackupHistory_c2.cmd = 'B' AND        -- Backup command and
           (dfBackupHistory_c2.ktag is null AND    -- nokeep cmd matches
            xdf.keep_options = 0) OR               -- nokeep backup or
           (dfBackupHistory_c2.ktag = xdf.tag and  -- keep backup cmd tag
            xdf.keep_options != 0)))               -- matches keep backup
     AND (dfBackupHistory_c2.device_type IS NULL OR
          dfBackupHistory_c2.device_type = xdf.device_type)
     AND ((dfBackupHistory_c2.pattern1 IS NULL AND
           dfBackupHistory_c2.pattern2 IS NULL AND
           dfBackupHistory_c2.pattern3 IS NULL AND
           dfBackupHistory_c2.pattern4 IS NULL) OR
          (xdf.handle LIKE dfBackupHistory_c2.pattern1 OR
           xdf.handle LIKE dfBackupHistory_c2.pattern2 OR
           xdf.handle LIKE dfBackupHistory_c2.pattern3 OR
           xdf.handle LIKE dfBackupHistory_c2.pattern4))
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND xdf.ckp_scn NOT BETWEEN                  -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
--
   ORDER BY  dfNumber,
             newcreate_scn,
             newreset_scn,
             newreset_time,
             ckp_scn desc,
             stop_scn desc,
             compTime desc;  --bug 8412297
 
CURSOR dcBackupHistory_c(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      bdf.file#                dfNumber,
      bdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bdf.ckp_scn              ckp_scn,
      bdf.ckp_time             ckp_time,
      cdf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(bdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      bdf.plugin_scn           pluginSCN,
      bdf.plugin_reset_scn     pluginRlgSCN,
      bdf.plugin_reset_time    pluginRlgTime,
      decode(bdf.plugin_scn, 0,
             bdf.create_scn, bdf.plugin_scn)
                               newcreate_scn,
      decode(bdf.plugin_reset_scn, 0,
             dbinc.reset_scn, bdf.plugin_reset_scn)
                               newreset_scn,
      nvl(bdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM bdf,
        dbinc,
        (SELECT DISTINCT
                cdf.file#, cdf.create_scn, cdf.plugin_scn,
                cdf.plugged_readonly, cdf.ckp_scn, cdf.ckp_time, cdf.dbinc_key
           FROM cdf, dbinc
          WHERE cdf.dbinc_key = dbinc.dbinc_key
            AND dbinc.db_key  = this_db_key
            AND ((user_site_key = cdf.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE#) OR
                   (this_site_key = nvl(cdf.site_key, this_site_key)))))
            AND cdf.status    = 'A') cdf,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (dcBackupHistory_c.cmd is null OR       -- bug 6658764
                 dcBackupHistory_c.cmd != 'B' OR
                 (dcBackupHistory_c.cmd = 'B' AND       -- Backup command and
                  (dcBackupHistory_c.ktag is null AND   -- nokeep cmd matches
                   bs.keep_options = 0) OR              -- nokeep backup or
                  (dcBackupHistory_c.ktag = bp.tag and  -- keep backup cmd tag
                   bs.keep_options != 0)))              -- matches keep backup
            AND (dcBackupHistory_c.device_type IS NULL OR
                 dcBackupHistory_c.device_type = bp.device_type)
            AND ((dcBackupHistory_c.pattern1 IS NULL AND
                  dcBackupHistory_c.pattern2 IS NULL AND
                  dcBackupHistory_c.pattern3 IS NULL AND
                  dcBackupHistory_c.pattern4 IS NULL) OR
                 (bp.handle LIKE dcBackupHistory_c.pattern1 OR
                  bp.handle LIKE dcBackupHistory_c.pattern2 OR
                  bp.handle LIKE dcBackupHistory_c.pattern3 OR
                  bp.handle LIKE dcBackupHistory_c.pattern4))
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bdf.dbinc_key  = dbinc.dbinc_key       -- join dbinc, bdf
     AND dbinc.db_key   = this_db_key           -- this database (all inc)
     AND cdf.plugin_scn = bdf.plugin_scn
     AND cdf.plugged_readonly = bdf.plugged_readonly
     AND bdf.create_scn = cdf.create_scn        -- create scn match
     AND bdf.file#      = cdf.file#             -- join bdf, cdf
     AND bdf.ckp_scn    = cdf.ckp_scn
     AND bdf.ckp_time   = cdf.ckp_time
     AND bdf.dbinc_key  = cdf.dbinc_key
     AND (bdf.incr_scn  = 0 OR
          bdf.incr_scn  = cdf.create_scn)       -- full backup
     AND bdf.bs_key     = bs.bs_key             -- join bdf, bs
 
   UNION ALL
 
   SELECT
      0                        dfNumber,
      0                        create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bcf.ckp_scn              ckp_scn,
      bcf.ckp_time             ckp_time,
      ccf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      0                        newcreate_scn,
      dbinc.reset_scn          newreset_scn,
      dbinc.reset_time         newreset_time
   FROM bcf,
        dbinc,
        (SELECT DISTINCT
                ccf.ckp_scn, ccf.ckp_time, ccf.dbinc_key
           FROM ccf, dbinc
          WHERE ccf.dbinc_key = dbinc.dbinc_key
            AND dbinc.db_key  = this_db_key
            AND ccf.status    = 'A') ccf,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (dcBackupHistory_c.cmd is null OR       -- bug 6658764
                 dcBackupHistory_c.cmd != 'B' OR
                 (dcBackupHistory_c.cmd = 'B' AND       -- Backup command and
                  (dcBackupHistory_c.ktag is null AND   -- nokeep cmd matches
                   bs.keep_options = 0) OR              -- nokeep backup or
                  (dcBackupHistory_c.ktag = bp.tag and  -- keep backup cmd tag
                   bs.keep_options != 0)))              -- matches keep backup
            AND (dcBackupHistory_c.device_type IS NULL OR
                 dcBackupHistory_c.device_type = bp.device_type)
            AND ((dcBackupHistory_c.pattern1 IS NULL AND
                  dcBackupHistory_c.pattern2 IS NULL AND
                  dcBackupHistory_c.pattern3 IS NULL AND
                  dcBackupHistory_c.pattern4 IS NULL) OR
                 (bp.handle LIKE dcBackupHistory_c.pattern1 OR
                  bp.handle LIKE dcBackupHistory_c.pattern2 OR
                  bp.handle LIKE dcBackupHistory_c.pattern3 OR
                  bp.handle LIKE dcBackupHistory_c.pattern4))
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bcf.dbinc_key  = dbinc.dbinc_key       -- join dbinc, bcf
     AND dbinc.db_key   = this_db_key           -- this database (all inc)
     AND bcf.ckp_scn    = ccf.ckp_scn
     AND bcf.ckp_time   = ccf.ckp_time
     AND bcf.dbinc_key  = ccf.dbinc_key
     AND bcf.bs_key     = bs.bs_key             -- join bcf, bs
 
   UNION ALL
 
   SELECT
      cdf.file#                dfNumber,
      cdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      cdf.ckp_scn              ckp_scn,
      cdf.ckp_time             ckp_time,
      cdf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      cdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(cdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly,
      cdf.plugin_scn            pluginSCN,
      cdf.plugin_reset_scn      pluginRlgSCN,
      cdf.plugin_reset_time     pluginRlgTime,
      decode(cdf.plugin_scn, 0,
             cdf.create_scn, cdf.plugin_scn)
                                newcreate_scn,
      decode(cdf.plugin_reset_scn, 0,
             dbinc.reset_scn, cdf.plugin_reset_scn)
                                newreset_scn,
      nvl(cdf.plugin_reset_time, dbinc.reset_time)
                                newreset_time
   FROM cdf, dbinc
   WHERE cdf.dbinc_key   = dbinc.dbinc_key        -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key            -- this database (all inc)
     AND cdf.status      = 'A'                    -- available backup
     AND (dcBackupHistory_c.cmd is null OR        -- bug 6658764
          dcBackupHistory_c.cmd != 'B' OR
          (dcBackupHistory_c.cmd = 'B' AND        -- Backup command and
           (dcBackupHistory_c.ktag is null AND    -- nokeep cmd matches
            cdf.keep_options = 0) OR              -- nokeep backup or
           (dcBackupHistory_c.ktag = cdf.tag and  -- keep backup cmd tag
            cdf.keep_options != 0)))              -- matches keep backup
     AND (dcBackupHistory_c.device_type IS NULL OR
          dcBackupHistory_c.device_type = 'DISK')
     AND (dcBackupHistory_c.pattern1 IS NOT NULL OR
          dcBackupHistory_c.pattern2 IS NOT NULL OR
          dcBackupHistory_c.pattern3 IS NOT NULL OR
          dcBackupHistory_c.pattern4 IS NOT NULL)
     AND (cdf.fname LIKE dcBackupHistory_c.pattern1 OR
          cdf.fname LIKE dcBackupHistory_c.pattern2 OR
          cdf.fname LIKE dcBackupHistory_c.pattern3 OR
          cdf.fname LIKE dcBackupHistory_c.pattern4)
     AND ((user_site_key  = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
 
   UNION ALL
 
   SELECT
      xdf.file#                dfNumber,
      xdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      xdf.ckp_scn              ckp_scn,
      xdf.ckp_time             ckp_time,
      cdf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly,
      xdf.plugin_scn            pluginSCN,
      xdf.plugin_reset_scn      pluginRlgSCN,
      xdf.plugin_reset_time     pluginRlgTime,
      decode(xdf.plugin_scn, 0,
             xdf.create_scn, xdf.plugin_scn)
                                newcreate_scn,
      decode(xdf.plugin_reset_scn, 0,
             dbinc.reset_scn, xdf.plugin_reset_scn)
                                newreset_scn,
      nvl(xdf.plugin_reset_time, dbinc.reset_time)
                                newreset_time
   FROM xdf,
        dbinc,
        (SELECT DISTINCT
                cdf.file#, cdf.create_scn, cdf.plugin_scn,
                cdf.plugged_readonly, cdf.ckp_scn, cdf.ckp_time, cdf.dbinc_key
           FROM cdf, dbinc
          WHERE cdf.dbinc_key = dbinc.dbinc_key
            AND dbinc.db_key  = this_db_key
            AND cdf.status    = 'A') cdf
   WHERE xdf.dbinc_key   = dbinc.dbinc_key         -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key             -- this database (all inc)
     AND xdf.file#       = cdf.file#               -- join xdf, cdf
     AND xdf.plugged_readonly = cdf.plugged_readonly
     AND xdf.plugin_scn  = cdf.plugin_scn
     AND xdf.create_scn  = cdf.create_scn          -- create scn match
     AND xdf.dbinc_key   = cdf.dbinc_key
     AND xdf.ckp_scn     = cdf.ckp_scn
     AND xdf.ckp_time    = cdf.ckp_time
     AND xdf.status      = 'A'                     -- available proxy df
     AND (dcBackupHistory_c.cmd is null OR        -- bug 6658764
          dcBackupHistory_c.cmd != 'B' OR
          (dcBackupHistory_c.cmd = 'B' AND        -- Backup command and
           (dcBackupHistory_c.ktag is null AND    -- nokeep cmd matches
            xdf.keep_options = 0) OR              -- nokeep backup or
           (dcBackupHistory_c.ktag = xdf.tag and  -- keep backup cmd tag
            xdf.keep_options != 0)))              -- matches keep backup
     AND (dcBackupHistory_c.device_type IS NULL OR
          dcBackupHistory_c.device_type = xdf.device_type)
     AND ((dcBackupHistory_c.pattern1 IS NULL AND
           dcBackupHistory_c.pattern2 IS NULL AND
           dcBackupHistory_c.pattern3 IS NULL AND
           dcBackupHistory_c.pattern4 IS NULL) OR
          (xdf.handle LIKE dcBackupHistory_c.pattern1 OR
           xdf.handle LIKE dcBackupHistory_c.pattern2 OR
           xdf.handle LIKE dcBackupHistory_c.pattern3 OR
           xdf.handle LIKE dcBackupHistory_c.pattern4))
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
--
   ORDER BY  dfNumber,
             newcreate_scn,
             newreset_scn,
             newreset_time,
             ckp_scn         desc,
             stop_scn        desc,
             compTime;
 
--
CURSOR alBackupHistory_c1(
   thread#     IN number,
   sequence#   IN number,
   device_type IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      brl.thread#              logThread,
      brl.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      brl.terminal             logTerminal,
      brl.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM brl,
        dbinc,
        (SELECT /*+no_merge*/ DISTINCT thread#, sequence#
           FROM al
          WHERE al.thread#   = alBackupHistory_c1.thread#
            AND al.sequence# = alBackupHistory_c1.sequence#
            AND al.dbinc_key = this_dbinc_key
            AND al.status    = 'A'
            AND al.archived  = 'Y') al,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  = 'L'               -- only al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (alBackupHistory_c1.device_type IS NULL OR
                 alBackupHistory_c1.device_type = bp.device_type)
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE dbinc.dbinc_key = this_dbinc_key           -- this incarnation
     AND brl.dbinc_key   = dbinc.dbinc_key          -- join brl, dbinc
     AND dbinc.db_key    = this_db_key
     AND brl.thread#     = al.thread#              -- join brl and al
     AND brl.sequence#   = al.sequence#
     AND brl.dbinc_key   = this_dbinc_key
     AND brl.bs_key      = bs.bs_key               -- join brl,bs
 
   UNION ALL
 
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          crescn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      xal.thread#              logThread,
      xal.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xal.completion_time      compTime,
      0                        nbackups,
      xal.terminal             logTerminal,
      xal.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM xal,
        dbinc,
        (SELECT /*+no_merge*/ DISTINCT thread#, sequence#
           FROM al
          WHERE al.thread#   = alBackupHistory_c1.thread#
            AND al.sequence# = alBackupHistory_c1.sequence#
            AND al.dbinc_key = this_dbinc_key
            AND al.status    = 'A'
            AND al.archived  = 'Y') al
   WHERE xal.dbinc_key  = dbinc.dbinc_key          -- join xal, dbinc
     AND dbinc.db_key   = this_db_key              -- this database
     AND xal.thread#    = al.thread#
     AND xal.sequence#  = al.sequence#
     AND xal.dbinc_key  = this_dbinc_key
     AND xal.status     = 'A'
     AND (alBackupHistory_c1.device_type IS NULL OR
          alBackupHistory_c1.device_type = xal.device_type)
     AND ((user_site_key  = xal.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
--
   ORDER BY reset_scn,
            reset_time,
            logThread,
            logSequence,
            logTerminal desc,
            compTime;
 
CURSOR alBackupHistory_c2(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      brl.thread#              logThread,
      brl.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      brl.terminal             logTerminal,
      brl.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM brl,
        dbinc,
        (SELECT DISTINCT al.thread#, al.sequence#, al.dbinc_key
           FROM al, dbinc
          WHERE dbinc.dbinc_key = al.dbinc_key
            AND dbinc.db_key    = this_db_key
            AND al.status       = 'A'
            AND al.archived     = 'Y'
            AND (tc_thread IS NULL   OR al.thread# = tc_thread)
            AND (tc_fromSeq IS NULL  OR al.sequence# >= tc_fromSeq)
            AND (tc_toSeq IS NULL    OR al.sequence# <= tc_toSeq)
            AND (tc_fromSCN IS NULL  OR al.next_scn > tc_fromSCN)
            AND (tc_toSCN IS NULL    OR al.low_scn < tc_toSCN)
            AND (tc_pattern IS NULL  OR al.fname like tc_pattern)
            AND (tc_fromTime IS NULL OR al.next_time > tc_fromTime)
            AND (tc_toTime IS NULL   OR al.low_time <= tc_toTime)) al,
        (SELECT DISTINCT
                bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  = 'L'               -- only al backups
            AND bs.status    = 'A'               -- available backupset
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (alBackupHistory_c2.cmd is null OR       -- bug 6658764
                 (alBackupHistory_c2.cmd != 'B' AND
                  alBackupHistory_c2.cmd != 'D') OR
                 ((alBackupHistory_c2.cmd = 'B' OR       -- Backup command or
                   alBackupHistory_c2.cmd = 'D') AND     -- Delete command and
                  ((alBackupHistory_c2.ktag is null AND  -- nokeep cmd matches
                    bs.keep_options = 0) OR              -- nokeep backup or
                   (alBackupHistory_c2.ktag = bp.tag AND -- keep backup cmd tag
                    bs.keep_options != 0))))             -- matches keep backup
            AND (alBackupHistory_c2.device_type IS NULL OR
                 alBackupHistory_c2.device_type = bp.device_type)
            AND ((alBackupHistory_c2.pattern1 IS NULL AND
                  alBackupHistory_c2.pattern2 IS NULL AND
                  alBackupHistory_c2.pattern3 IS NULL AND
                  alBackupHistory_c2.pattern4 IS NULL) OR
                 (bp.handle LIKE alBackupHistory_c2.pattern1 OR
                  bp.handle LIKE alBackupHistory_c2.pattern2 OR
                  bp.handle LIKE alBackupHistory_c2.pattern3 OR
                  bp.handle LIKE alBackupHistory_c2.pattern4))
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE (canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
     AND brl.dbinc_key   = dbinc.dbinc_key         -- join brl, dbinc
     AND dbinc.db_key    = this_db_key
     AND brl.thread#     = al.thread#              -- join brl and al
     AND brl.sequence#   = al.sequence#
     AND brl.dbinc_key   = al.dbinc_key
     AND brl.bs_key      = bs.bs_key               -- join brl,bs
 
   UNION ALL
 
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          crescn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      xal.thread#              logThread,
      xal.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xal.completion_time      compTime,
      0                        nbackups,
      xal.terminal             logTerminal,
      xal.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM xal,
        dbinc,
        (SELECT DISTINCT al.thread#, al.sequence#, al.dbinc_key
           FROM al, dbinc
          WHERE dbinc.dbinc_key = al.dbinc_key
            AND dbinc.db_key    = this_db_key
            AND al.status       = 'A'
            AND al.archived     = 'Y'
            AND (tc_thread IS NULL   OR al.thread# = tc_thread)
            AND (tc_fromSeq IS NULL  OR al.sequence# >= tc_fromSeq)
            AND (tc_toSeq IS NULL    OR al.sequence# <= tc_toSeq)
            AND (tc_fromSCN IS NULL  OR al.next_scn > tc_fromSCN)
            AND (tc_toSCN IS NULL    OR al.low_scn < tc_toSCN)
            AND (tc_pattern IS NULL  OR al.fname like tc_pattern)
            AND (tc_fromTime IS NULL OR al.next_time > tc_fromTime)
            AND (tc_toTime IS NULL   OR al.low_time <= tc_toTime)) al
   WHERE (canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
     AND xal.dbinc_key  = dbinc.dbinc_key          -- join xal, dbinc
     AND dbinc.db_key   = this_db_key              -- this database
     AND xal.thread#    = al.thread#
     AND xal.sequence#  = al.sequence#
     AND xal.dbinc_key  = al.dbinc_key
     AND xal.status     = 'A'
     AND (alBackupHistory_c2.cmd is null OR       -- bug 6658764
          (alBackupHistory_c2.cmd != 'B' AND
           alBackupHistory_c2.cmd != 'D') OR
          ((alBackupHistory_c2.cmd = 'B' OR        -- Backup command or
            alBackupHistory_c2.cmd = 'D') AND      -- Delete command and
           ((alBackupHistory_c2.ktag is null AND   -- nokeep cmd matches
             xal.keep_options = 0) OR              -- nokeep backup or
            (alBackupHistory_c2.ktag = xal.tag AND -- keep backup cmd tag
             xal.keep_options != 0))))             -- matches keep backup
     AND (alBackupHistory_c2.device_type IS NULL OR
          alBackupHistory_c2.device_type = xal.device_type)
     AND ((alBackupHistory_c2.pattern1 IS NULL AND
           alBackupHistory_c2.pattern2 IS NULL AND
           alBackupHistory_c2.pattern3 IS NULL AND
           alBackupHistory_c2.pattern4 IS NULL) OR
          (xal.handle LIKE alBackupHistory_c2.pattern1 OR
           xal.handle LIKE alBackupHistory_c2.pattern2 OR
           xal.handle LIKE alBackupHistory_c2.pattern3 OR
           xal.handle LIKE alBackupHistory_c2.pattern4))
     AND ((user_site_key  = xal.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
--
   ORDER BY reset_scn,
            reset_time,
            logThread,
            logSequence,
            logTerminal desc,
            compTime;
 
CURSOR bsBackupHistory_c1(
   set_stamp   IN   number
  ,set_count   IN   number
  ,device_type IN   varchar2
  ,pattern1    IN   varchar2
  ,pattern2    IN   varchar2
  ,pattern3    IN   varchar2
  ,pattern4    IN   varchar2
  )
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)           dfNumber,
      to_number(null)           create_scn,
      to_number(null)           reset_scn,
      to_date(null)             reset_time,
      to_number(null)           ckp_scn,
      to_date(null)             ckp_time,
      to_number(null)           stop_scn,
      to_number(null)           logThread,
      to_number(null)           logSequence,
      bs.set_stamp              setStamp,
      bs.set_count              setCount,
      max(bp.completion_time)   compTime,
      0                         nbackups,
      to_char(null)             logTerminal,
      to_number(null)           next_scn,
      0                         pluggedRonly,
      0                         pluginSCN,
      0                         pluginRlgSCN,
      to_date(null)             pluginRlgTime,
      to_number(null)           newcreate_scn,
      to_number(null)           newreset_scn,
      to_date(null)             newreset_time
     FROM bs,
          bp
     WHERE bs.db_key       = this_db_key             -- this database
       AND bp.bs_key       = bs.bs_key               -- join bs, bp
       AND bs.set_stamp    = bsBackupHistory_c1.set_stamp
       AND bs.set_count    = bsBackupHistory_c1.set_count
       AND bs.status       = 'A'
       AND bp.status      != 'D'
       AND (bsBackupHistory_c1.device_type IS NULL OR
            bsBackupHistory_c1.device_type = bp.device_type)
       AND ((bsBackupHistory_c1.pattern1 IS NULL AND
             bsBackupHistory_c1.pattern2 IS NULL AND
             bsBackupHistory_c1.pattern3 IS NULL AND
             bsBackupHistory_c1.pattern4 IS NULL) OR
            (bp.handle LIKE bsBackupHistory_c1.pattern1 OR
             bp.handle LIKE bsBackupHistory_c1.pattern2 OR
             bp.handle LIKE bsBackupHistory_c1.pattern3 OR
             bp.handle LIKE bsBackupHistory_c1.pattern4))
       AND ((user_site_key = bp.site_key) OR
            (user_site_key IS NULL AND
             ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
              (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
              (this_site_key = nvl(bp.site_key, this_site_key)))))
  GROUP BY bs.set_stamp, bs.set_count, bs.pieces,
           bp.copy#, bp.device_type
    HAVING count(distinct bp.piece#) = bs.pieces
 
--
   ORDER BY setStamp, setCount, compTime;
 
CURSOR bsBackupHistory_c2(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)           dfNumber,
      to_number(null)           create_scn,
      to_number(null)           reset_scn,
      to_date(null)             reset_time,
      to_number(null)           ckp_scn,
      to_date(null)             ckp_time,
      to_number(null)           stop_scn,
      to_number(null)           logThread,
      to_number(null)           logSequence,
      bs.set_stamp              setStamp,
      bs.set_count              setCount,
      max(bp.completion_time)   compTime,
      0                         nbackups,
      to_char(null)             logTerminal,
      to_number(null)           next_scn,
      0                         pluggedRonly,
      0                         pluginSCN,
      0                         pluginRlgSCN,
      to_date(null)             pluginRlgTime,
      to_number(null)           newcreate_scn,
      to_number(null)           newreset_scn,
      to_date(null)             newreset_time
   FROM bs,
        bp
     WHERE bs.db_key       = this_db_key             -- this database
       AND bp.bs_key       = bs.bs_key               -- join bs, bp
       AND bs.status       = 'A'
       AND bp.status      != 'D'
       AND (bsBackupHistory_c2.device_type IS NULL OR
            bsBackupHistory_c2.device_type = bp.device_type)
       AND ((bsBackupHistory_c2.pattern1 IS NULL AND
             bsBackupHistory_c2.pattern2 IS NULL AND
             bsBackupHistory_c2.pattern3 IS NULL AND
             bsBackupHistory_c2.pattern4 IS NULL) OR
            (bp.handle LIKE bsBackupHistory_c2.pattern1 OR
             bp.handle LIKE bsBackupHistory_c2.pattern2 OR
             bp.handle LIKE bsBackupHistory_c2.pattern3 OR
             bp.handle LIKE bsBackupHistory_c2.pattern4))
       AND ((user_site_key = bp.site_key) OR
            (user_site_key IS NULL AND
             ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
              (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
              (this_site_key = nvl(bp.site_key, this_site_key)))))
  GROUP BY bs.set_stamp, bs.set_count, bs.pieces,
           bp.copy#, bp.device_type
    HAVING count(distinct bp.piece#) = bs.pieces
 
--
   ORDER BY setStamp, setCount, compTime;
 
--
--
--
CURSOR getCopyofDatafile_c2(
   itag        varchar2
)
IS
   SELECT /*+ first_rows */
      file#,
      creation_change#,
      resetlogs_change#,
      resetlogs_time,
      recid,
      stamp,
      name,
      tag,
      status,
      blocks,
      block_size,
      completion_time,
      checkpoint_change#,
      checkpoint_time,
      decode(plugged_readonly, 'YES', 1, 0) pluggedRonly,
      plugin_change#,
      plugin_resetlogs_change#,
      plugin_resetlogs_time
   FROM
      rc_datafile_copy
   WHERE status            = 'A'
     AND (itag is NULL or tag = itag)
     AND (tc_database = TRUE# OR
          isTranslatedFno(file#) = TRUE#)   -- only translated files
     AND ((user_site_key = rc_datafile_copy.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(rc_datafile_copy.site_key, this_site_key)))))
  ORDER BY file#, decode(plugged_readonly, 'YES',
                  plugin_change#, checkpoint_change#) desc, recid desc;
 
--
--
--
--
CURSOR getCopyofDatafile_c(
   dfnumber    number
  ,itag        varchar2
  ,crescn      number
  ,rlgscn      number
  ,rlgtime     date
  ,pluginSCN   number
)
IS
   SELECT /*+ first_rows */
      recid,
      stamp,
      name,
      tag,
      status,
      blocks,
      block_size,
      completion_time,
      checkpoint_change#,
      checkpoint_time,
      creation_change#,
      resetlogs_change#,
      resetlogs_time,
      decode(plugged_readonly, 'YES', 1, 0) pluggedRonly
   FROM
      rc_datafile_copy
   WHERE status            = 'A'
     AND (itag is NULL or tag = itag)
     AND file#             = dfnumber
     AND ((pluginSCN = 0 AND creation_change# = crescn) OR
          (pluginSCN != 0 AND plugin_change# = pluginSCN))
     AND ((plugged_readonly = 'NO' AND
           resetlogs_change# = rlgscn AND
           resetlogs_time    = rlgtime) OR
          (plugged_readonly = 'YES' AND
           plugin_resetlogs_change# = rlgscn AND
           plugin_resetlogs_time = rlgtime))
     AND ((user_site_key = rc_datafile_copy.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(rc_datafile_copy.site_key, this_site_key)))))
 
  ORDER BY
      decode(plugged_readonly, 'YES',
             plugin_change#, checkpoint_change#) desc;
 
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
TYPE rcvRecCursor_t IS RECORD
(
   currc1         rcvRec_t,            -- current fetched rcvRecCursor1_c data
   reqfno         number,              -- requested file number
   reqcrescn      number,              -- requested file number's create scn
   reqpluginSCN   number,              -- requested file number's plugin scn
   excludeAction  binary_integer       -- type of action that is excluded
);
rcvRecCursor rcvRecCursor_t;
 
CURSOR rcvRecCursor1_c(
rmanCmd       IN binary_integer
)
RETURN rcvRec_t IS
 
--
 
   SELECT offlineRangeRec_con_t                 type_con,
          offr.offr_key                         key_con,
          offr.offr_recid                       recid_con,
          offr.offr_stamp                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          offr.cf_create_time                   cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          offlineRange_act_t                    type_act,
          offr.offline_scn                      fromSCN_act,
          offr.online_scn                       toSCN_act,
          offr.online_time                      toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          offr.file#                            dfNumber_obj,
          offr.create_scn                       dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          offr.create_scn                       newDfCreationSCN_obj,
          offr.online_scn                       newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM offr, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(offr.file#) = TRUE#)
      AND (untilSCN is null OR offr.online_scn < untilSCN)
--
--
--
--
--
--
      AND offr.cf_create_time is not null
--
      AND offr.offr_stamp <> 0          -- stamp = 0 -> from kccfe
      AND offr.dbinc_key  = this_dbinc_key
      AND offr.dbinc_key = dbinc.dbinc_key
 
   UNION ALL
 
--
 
   SELECT imageCopy_con_t                       type_con,
          cdf.cdf_key                           key_con,
          cdf.cdf_recid                         recid_con,
          cdf.cdf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          cdf.fname                             fileName_con,
          cdf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          cdf.status                            status_con,
          cdf.blocks                            blocks_con,
          cdf.block_size                        blockSize_con,
          'DISK'                                deviceType_con,
          cdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          cdf.ckp_scn                           toSCN_act,
          cdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          cdf.incr_level                        level_act,
          0                                     section_size_act,
 
          cdf.file#                             dfNumber_obj,
          cdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          cdf.pdb_key                           pdbKey_obj,
 
          cdf.keep_options                      keep_options,
          cdf.keep_until                        keep_until,
 
          cdf.abs_fuzzy_scn                     afzSCN_act,
          cdf.rcv_fuzzy_time                    rfzTime_act,
          cdf.rcv_fuzzy_scn                     rfzSCN_act,
          to_char(null)                         media_con,
          cdf.is_recovery_dest_file             isrdf_con,
          site_key                              site_key_con,
          cdf.foreign_dbid                      foreignDbid_obj,
          decode(cdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          cdf.plugin_scn                        pluginSCN_obj,
          cdf.plugin_reset_scn                  pluginRlgSCN_obj,
          cdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(cdf.plugin_scn, 0, cdf.create_scn,
                 cdf.plugin_scn)                newDfCreation_obj,
          decode(cdf.plugged_readonly, 'NO', cdf.ckp_scn,
                 cdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          cdf.sparse_backup                     sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM cdf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(cdf.file#) = TRUE#)
      AND (untilSCN is null OR
           (cdf.plugged_readonly = 'NO' AND
            greatest(cdf.ckp_scn, cdf.abs_fuzzy_scn,
                     cdf.rcv_fuzzy_scn) <= untilSCN) OR
           (cdf.plugged_readonly = 'YES' AND
            cdf.plugin_scn <= untilSCN))
      AND cdf.status = 'A'
      AND (restoreSource is NULL                        OR
           bitand(restoreSource, imageCopy_con_t) != 0)
      AND cdf.dbinc_key = dbinc.dbinc_key
      AND dbinc.db_key = this_db_key
      AND rmanCmd != recoverCmd_t
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
      AND (cdf.file# = 0 OR -- backup mode is not applicable for control files
           restoreSparse = BACKUP_SPARSENESS_UNSPECIFIED     OR
           (restoreSparse = BACKUP_SPARSENESS_SPARSE AND
            cdf.sparse_backup = 'YES')                       OR
           (restoreSparse = BACKUP_SPARSENESS_NONSPARSE AND
            cdf.sparse_backup = 'NO'))
 
   UNION ALL
 
--
 
   SELECT imageCopy_con_t                       type_con,
          ccf.ccf_key                           key_con,
          ccf.ccf_recid                         recid_con,
          ccf.ccf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          ccf.fname                             fileName_con,
          ccf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          ccf.status                            status_con,
          to_number(null)                       blocks_con,
          ccf.block_size                        blockSize_con,
          'DISK'                                deviceType_con,
          ccf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          ccf.ckp_scn                           toSCN_act,
          ccf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(ccf.controlfile_type, 'B')        cfType_obj,
          ccf.pdb_key                           pdbKey_obj,
 
          ccf.keep_options                      keep_options,
          ccf.keep_until                        keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          is_recovery_dest_file                 isrdf_con,
          site_key                              site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          ccf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM ccf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(0) = TRUE#)
      AND (untilSCN is null OR
           ccf.ckp_scn <= untilSCN)
      AND ccf.status = 'A'
      AND (restoreSource is NULL                        OR
           bitand(restoreSource, imageCopy_con_t) != 0)
      AND ccf.dbinc_key = dbinc.dbinc_key
      AND dbinc.db_key = this_db_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND ((user_site_key = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bdf.bdf_key                           key_con,
          bdf.bdf_recid                         recid_con,
          bdf.bdf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          bs.incr_level                         bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          bdf.blocks                            blocks_con,
          bdf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          decode(bdf.incr_scn,
                 0, full_act_t,
                 bdf.create_scn,
                 decode(rmanCmd,
                        rcvCopyCmd_t,
                        incremental_act_t,
                        recoverCmd_t,
                        incremental_act_t,
                        full_act_t),
                 incremental_act_t)             type_act,
          decode(bdf.incr_scn,
                 bdf.create_scn,
                 decode(rmanCmd,
                        rcvCopyCmd_t,
                        bdf.incr_scn,
                        recoverCmd_t,
                        bdf.incr_scn,
                        0),
                 bdf.incr_scn)                  fromSCN_act,
          bdf.ckp_scn                           toSCN_act,
          bdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          bdf.incr_level                        level_act,
          bdf.section_size                      section_size_act,
 
          bdf.file#                             dfNumber_obj,
          bdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          bdf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          bdf.abs_fuzzy_scn                     afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          bdf.foreign_dbid                      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          bdf.plugin_scn                        pluginSCN_obj,
          bdf.plugin_reset_scn                  pluginRlgSCN_obj,
          bdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(bdf.plugin_scn, 0, bdf.create_scn,
                 bdf.plugin_scn)                newDfCreationSCN_obj,
          decode(bdf.plugged_readonly, 'NO', bdf.ckp_scn,
                 bdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          bdf.sparse_backup                     sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bdf, bs, dbinc
--
--
--
    WHERE rmanCmd != obsoleteCmd_t
      AND (tc_database = TRUE# OR isTranslatedFno(bdf.file#) = TRUE#)
      AND bs.status = 'A'
      AND bs.bck_type != 'L'               -- only datafile backups
      AND (untilSCN IS NULL OR
           (bdf.plugged_readonly = 'NO' AND
            greatest(bdf.ckp_scn, bdf.abs_fuzzy_scn) <= untilSCN) OR
           (bdf.plugged_readonly = 'YES' AND
            bdf.plugin_scn <= untilSCN))
      AND dbinc.dbinc_key  = bdf.dbinc_key   -- join dbinc, bdf
      AND bs.bs_key        = bdf.bs_key      -- join bs, bdf
      AND dbinc.db_key     = this_db_key
      AND (rmanCmd = rcvCopyCmd_t OR -- use incr for recover copy cmd
           rmanCmd = recoverCmd_t OR
           (restoreSource IS NULL OR
            bitand(restoreSource, backupSet_con_t) != 0))
      AND (bdf.file# = 0 OR -- backup mode is not applicable for control files
           restoreSparse = BACKUP_SPARSENESS_UNSPECIFIED      OR
           (restoreSparse = BACKUP_SPARSENESS_SPARSE AND
            bdf.sparse_backup = 'YES')                        OR
           (restoreSparse = BACKUP_SPARSENESS_NONSPARSE AND
            bdf.sparse_backup = 'NO'))
      AND ((rmanCmd = rcvCopyCmd_t AND bdf.incr_scn > 0)               OR
           (rmanCmd = recoverCmd_t AND bdf.incr_scn > 0)               OR
           (rmanCmd IN (restoreCmd_t, blkRestoreCmd_t) AND
            bdf.incr_scn <= bdf.create_scn)                            OR
           (rmanCmd = unknownCmd_t))
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bdf.bdf_key                           key_con,
          bdf.bdf_recid                         recid_con,
          bdf.bdf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          bs.incr_level                         bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          bdf.blocks                            blocks_con,
          bdf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          decode(bdf.incr_scn,
                 0, full_act_t,
                 bdf.create_scn,
                 full_act_t,
                 incremental_act_t)             type_act,
          bdf.incr_scn                          fromSCN_act,
          bdf.ckp_scn                           toSCN_act,
          bdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          bdf.incr_level                        level_act,
          bdf.section_size                      section_size_act,
 
          bdf.file#                             dfNumber_obj,
          bdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          bdf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          bdf.abs_fuzzy_scn                     afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          bdf.foreign_dbid                      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          bdf.plugin_scn                        pluginSCN_obj,
          bdf.plugin_reset_scn                  pluginRlgSCN_obj,
          bdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(bdf.plugin_scn, 0, bdf.create_scn,
                 bdf.plugin_scn)                newDfCreationSCN_obj,
          decode(bdf.plugged_readonly, 'NO', bdf.ckp_scn,
                 bdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          bdf.sparse_backup                     sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bdf, bs, dbinc,
          (SELECT bs_key,
                  count(distinct piece#) pieces
             FROM  bp
            WHERE rmanCmd = obsoleteCmd_t
              AND bp.db_key  = this_db_key         -- this database
              AND bp.status  = 'A'
              AND (anyDevice = TRUE# OR
                   isDeviceTypeAllocated(bp.device_type) = TRUE#)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared =TRUE# AND bp.device_type='DISK') OR
                     (tape_backups_shared =TRUE# AND bp.device_type<>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
           GROUP BY bs_key, device_type) bp
--
--
--
    WHERE rmanCmd = obsoleteCmd_t
--
--
--
      AND bs.status = 'A'
      AND bs.bck_type != 'L'                 -- only datafile backups
      AND (untilSCN IS NULL OR
           (bdf.plugged_readonly = 'NO' AND
            greatest(bdf.ckp_scn, bdf.abs_fuzzy_scn) <= untilSCN) OR
           (bdf.plugged_readonly = 'YES' AND
            bdf.plugin_scn <= untilSCN))
      AND dbinc.dbinc_key  = bdf.dbinc_key   -- join dbinc, bdf
      AND bs.bs_key        = bdf.bs_key      -- join bs, bdf
      AND dbinc.db_key     = this_db_key
      AND (restoreSource IS NULL OR
           bitand(restoreSource, backupSet_con_t) != 0)
      AND (bdf.file# = 0 OR -- backup mode is not applicable for control files
           restoreSparse = BACKUP_SPARSENESS_UNSPECIFIED      OR
           (restoreSparse = BACKUP_SPARSENESS_SPARSE AND
            bdf.sparse_backup = 'YES')                        OR
           (restoreSparse = BACKUP_SPARSENESS_NONSPARSE AND
            bdf.sparse_backup = 'NO'))
      AND bp.bs_key        = bs.bs_key
      AND bp.pieces        = bs.pieces
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bcf.bcf_key                           key_con,
          bcf.bcf_recid                         recid_con,
          bcf.bcf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          0                                     bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          bcf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bs.completion_time                    compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          bcf.ckp_scn                           toSCN_act,
          bcf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(bcf.controlfile_type, 'B')        cfType_obj,
          bcf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          bcf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bcf, bs, dbinc
--
--
--
    WHERE rmanCmd != obsoleteCmd_t
      AND (tc_database = TRUE# OR isTranslatedFno(0) = TRUE#)
      AND bs.status = 'A'
      AND bs.bck_type != 'L'                 -- ignore archivelog backups
      AND (untilSCN IS NULL OR
           bcf.ckp_scn <= untilSCN)
      AND (restoreSource IS NULL OR
           bitand(restoreSource, backupSet_con_t) != 0)
      AND dbinc.dbinc_key  = bcf.dbinc_key   -- join dbinc, bcf
      AND bs.bs_key        = bcf.bs_key      -- join bs, bcf
      AND dbinc.db_key     = this_db_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND (bs.site_key IS NULL         OR    -- always return null site_key
           user_site_key = bs.site_key OR    -- user interested in one site
          (user_site_key IS NULL AND         -- return rows per access attr
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key)))
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bcf.bcf_key                           key_con,
          bcf.bcf_recid                         recid_con,
          bcf.bcf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          0                                     bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          bcf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bs.completion_time                    compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          bcf.ckp_scn                           toSCN_act,
          bcf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(bcf.controlfile_type, 'B')        cfType_obj,
          bcf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          bcf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bcf, bs, dbinc,
          (SELECT bs_key,
                  count(distinct piece#) pieces
             FROM  bp
            WHERE rmanCmd = obsoleteCmd_t
              AND bp.db_key  = this_db_key         -- this database
              AND bp.status  = 'A'
              AND (anyDevice = TRUE# OR
                   isDeviceTypeAllocated(bp.device_type) = TRUE#)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared =TRUE# AND bp.device_type ='DISK') OR
                     (tape_backups_shared =TRUE# AND bp.device_type<>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
         GROUP BY bs_key, device_type) bp
--
--
--
    WHERE rmanCmd = obsoleteCmd_t
--
--
--
      AND bs.status = 'A'
      AND bs.bck_type != 'L'                 -- ignore archivelog backups
      AND (untilSCN IS NULL OR
           bcf.ckp_scn <= untilSCN)
      AND (restoreSource IS NULL OR
           bitand(restoreSource, backupSet_con_t) != 0)
      AND dbinc.dbinc_key  = bcf.dbinc_key   -- join dbinc, bcf
      AND bs.bs_key        = bcf.bs_key      -- join bs, bcf
      AND dbinc.db_key     = this_db_key
      AND bs.bs_key        = bp.bs_key       -- join bp, bs
      AND bp.pieces        = bs.pieces
 
   UNION ALL
 
--
 
   SELECT proxyCopy_con_t                       type_con,
          xdf.xdf_key                           key_con,
          xdf.xdf_recid                         recid_con,
          xdf.xdf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          xdf.handle                            fileName_con,
          xdf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          xdf.status                            status_con,
          xdf.blocks                            blocks_con,
          xdf.block_size                        blockSize_con,
          xdf.device_type                       deviceType_con,
          xdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          xdf.ckp_scn                           toSCN_act,
          xdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          xdf.file#                             dfNumber_obj,
          xdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          xdf.pdb_key                           pdbKey_obj,
 
          keep_options                          keep_options,
          keep_until                            keep_until,
 
          xdf.abs_fuzzy_scn                     afzSCN_act,
          xdf.rcv_fuzzy_time                    rfzTime_act,
          xdf.rcv_fuzzy_scn                     rfzSCN_act,
          xdf.media                             media_con,
          'NO'                                  isrdf_con,
          site_key                              site_key_con,
          xdf.foreign_dbid                      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          xdf.plugin_scn                        pluginSCN_obj,
          xdf.plugin_reset_scn                  pluginRlgSCN_obj,
          xdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(xdf.plugin_scn, 0, xdf.create_scn,
                 xdf.plugin_scn)                newDfCreationSCN_obj,
          decode(xdf.plugged_readonly, 'NO', xdf.ckp_scn,
                 xdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM xdf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(xdf.file#) = TRUE#)
      AND (untilSCN IS NULL OR
           (xdf.plugged_readonly = 'NO' AND
            greatest(xdf.ckp_scn, xdf.abs_fuzzy_scn,
                     xdf.rcv_fuzzy_scn) <= untilSCN) OR
           (xdf.plugged_readonly = 'YES' AND
            xdf.plugin_scn <= untilSCN))
      AND xdf.status = 'A'
      AND (restoreSource is NULL OR
           bitand(restoreSource, proxyCopy_con_t) != 0)
      AND dbinc.db_key = this_db_key
      AND xdf.dbinc_key = dbinc.dbinc_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
 
    UNION ALL
 
--
 
   SELECT proxyCopy_con_t                       type_con,
          xcf.xcf_key                           key_con,
          xcf.xcf_recid                         recid_con,
          xcf.xcf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          xcf.handle                            fileName_con,
          xcf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          xcf.status                            status_con,
          to_number(null)                       blocks_con,
          xcf.block_size                        blockSize_con,
          xcf.device_type                       deviceType_con,
          xcf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          xcf.ckp_scn                           toSCN_act,
          xcf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(xcf.controlfile_type, 'B')        cfType_obj,
          xcf.pdb_key                           pdbKey_obj,
 
          xcf.keep_options                      keep_options,
          xcf.keep_until                        keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          xcf.media                             media_con,
          'NO'                                  isrdf_con,
          site_key                              site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          xcf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM xcf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(0) = TRUE#)
      AND (untilSCN IS NULL OR
           xcf.ckp_scn <= untilSCN)
      AND xcf.status = 'A'
      AND (restoreSource is NULL OR
           bitand(restoreSource, proxyCopy_con_t) != 0)
      AND dbinc.db_key = this_db_key
      AND xcf.dbinc_key = dbinc.dbinc_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
    ORDER BY dfNumber_obj         asc,
             newDfCreationSCN_obj asc,
             newToSCN_act         desc,
             fromSCN_act          asc,
             type_con             asc,
             setStamp_con         desc,     /* better value, but may be null */
             setCount_con         desc,       /* ensures uniqueness with ORS */
             stamp_con            desc;      /* needed when setStamp is null */
 
    /* ORS Preference: Latest backup is returned first. Since virtual copy
    ** has higher set_count, they go first in the restore list than file chunks.
    ** We really don't have the meta-data here to find out whether the piece
    ** exists on tape, replication or file chunk to sort it out. This
    ** requires another join with bp table which is expensive.
    */
 
--
CURSOR rcvRecCursor1Filter_c(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,c1rec         IN     rcvRec_t
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date
  ,rmanCmd       IN     binary_integer)
RETURN rcvRec_t IS
 
--
 
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = offlineRangeRec_con_t
     AND rcvRecCursor1Filter_c.pluggedRonly = 0
     AND c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey
     AND (rcvRecCursor1Filter_c.dfCkpSCN is null OR
          rcvRecCursor1Filter_c.dfCkpSCN <= c1rec.fromSCN_act)
     AND (rcvRecCursor1Filter_c.targetSCN is null OR
          c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN)
 
   UNION ALL
 
--
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = imageCopy_con_t
      AND ((canApplyAnyRedo = TRUE# AND c1rec.dfNumber_obj <> 0) OR
           (craGetAllCfBackups = TRUE# AND c1rec.dfNumber_obj = 0) OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginRlgSCN_obj = rcvRecCursor1Filter_c.dbincRlgSCN AND
            c1rec.pluginRlgTime_obj = rcvRecCursor1Filter_c.dbincRlgTime))
      AND (rcvRecCursor1Filter_c.dfCkpSCN is null OR
           rmanCmd = blkRestoreCmd_t OR
           rcvRecCursor1Filter_c.dfCkpSCN <= c1rec.toSCN_act)
      AND (rcvRecCursor1Filter_c.targetSCN is null OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginSCN_obj <= rcvRecCursor1Filter_c.targetSCN))
      AND (restoreTag is NULL OR
           c1rec.tag_con = restoreTag OR
           computeRA_allRecords = TRUE#)
      AND ((c1rec.foreignDbid_obj = rcvRecCursor1Filter_c.foreignDbid) OR
           (c1rec.foreignDbid_obj = 0 AND
            c1rec.pluginSCN_obj = 0   AND
            rcvRecCursor1Filter_c.pluginSCN = 0))
--
--
--
   UNION ALL
 
--
 
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = backupSet_con_t
      AND ((canApplyAnyRedo     = TRUE# AND c1rec.dfNumber_obj <> 0) OR
           (craGetAllCfBackups = TRUE# AND c1rec.dfNumber_obj = 0) OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginRlgSCN_obj = rcvRecCursor1Filter_c.dbincRlgSCN AND
            c1rec.pluginRlgTime_obj = rcvRecCursor1Filter_c.dbincRlgTime))
      AND (rcvRecCursor1Filter_c.dfCkpSCN IS NULL OR
           rmanCmd = blkRestoreCmd_t OR
           rcvRecCursor1Filter_c.dfCkpSCN < c1rec.toSCN_act)
      AND (rcvRecCursor1Filter_c.targetSCN IS NULL OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginSCN_obj <= rcvRecCursor1Filter_c.targetSCN))
      AND ((c1rec.foreignDbid_obj = rcvRecCursor1Filter_c.foreignDbid) OR
           (c1rec.foreignDbid_obj = 0 AND
            c1rec.pluginSCN_obj = 0   AND
            rcvRecCursor1Filter_c.pluginSCN = 0))
--
--
--
   UNION ALL
 
--
 
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = proxyCopy_con_t
      AND rmanCmd != blkRestoreCmd_t
      AND ((canApplyAnyRedo     = TRUE# AND c1rec.dfNumber_obj <> 0) OR
           (craGetAllCfBackups = TRUE# AND c1rec.dfNumber_obj = 0) OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginRlgSCN_obj = rcvRecCursor1Filter_c.dbincRlgSCN AND
            c1rec.pluginRlgTime_obj = rcvRecCursor1Filter_c.dbincRlgTime))
      AND (rcvRecCursor1Filter_c.dfCkpSCN IS NULL OR
           rcvRecCursor1Filter_c.dfCkpSCN < c1rec.toSCN_act)
      AND (rcvRecCursor1Filter_c.targetSCN IS NULL OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginSCN_obj <= rcvRecCursor1Filter_c.targetSCN))
      AND (restoreTag is NULL OR
           c1rec.tag_con = restoreTag OR
           computeRA_allRecords = TRUE#)
      AND ((c1rec.foreignDbid_obj = rcvRecCursor1Filter_c.foreignDbid) OR
           (c1rec.foreignDbid_obj = 0 AND
            c1rec.pluginSCN_obj = 0   AND
            rcvRecCursor1Filter_c.pluginSCN = 0));
--
--
--
 
CURSOR rcvRecCursor2_c(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,c1frec        IN     rcvRec_t
  ,excludeAction IN     binary_integer
  ,foreignDbid    IN    number
  ,pluggedRonly   IN    binary_integer
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date)
RETURN rcvRec_t IS
 
--
 
   SELECT c1frec.type_con                       type_con,
          c1frec.key_con                        key_con,
          c1frec.recid_con                      recid_con,
          c1frec.stamp_con                      stamp_con,
          c1frec.setStamp_con                   setStamp_con,
          c1frec.setCount_con                   setCount_con,
          c1frec.bsRecid_con                    bsRecid_con,
          c1frec.bsStamp_con                    bsStamp_con,
          c1frec.bsKey_con                      bsKey_con,
          c1frec.bsLevel_con                    bsLevel_con,
          c1frec.bsType_con                     bsType_con,
          c1frec.elapseSecs_con                 elapseSecs_con,
          c1frec.pieceCount_con                 pieceCount_con,
          c1frec.fileName_con                   fileName_con,
          c1frec.tag_con                        tag_con,
          c1frec.copyNumber_con                 copyNumber_con,
          c1frec.status_con                     status_con,
          c1frec.blocks_con                     blocks_con,
          c1frec.blockSize_con                  blockSize_con,
 
          c1frec.deviceType_con                 deviceType_con,
          c1frec.compTime_con                   compTime_con,
          c1frec.cfCreationTime_con             cfCreationTime_con,
          c1frec.pieceNumber_con                pieceNumber_con,
          c1frec.bpCompTime_con                 bpCompTime_con,
          c1frec.bpCompressed_con               bpCompressed_con,
          c1frec.multi_section_con              multi_section_con,
 
          c1frec.type_act                       type_act,
          c1frec.fromSCN_act                    fromSCN_act,
          c1frec.toSCN_act                      toSCN_act,
          c1frec.toTime_act                     toTime_act,
          c1frec.rlgSCN_act                     rlgSCN_act,
          c1frec.rlgTime_act                    rlgTime_act,
          c1frec.dbincKey_act                   dbincKey_act,
          c1frec.level_act                      level_act,
          c1frec.section_size_act               section_size_act,
 
          c1frec.dfNumber_obj                   dfNumber_obj,
          c1frec.dfCreationSCN_obj              dfCreationSCN_obj,
          c1frec.cfSequence_obj                 cfSequence_obj,
          c1frec.cfDate_obj                     cfDate_obj,
          c1frec.logSequence_obj                logSequence_obj,
          c1frec.logThread_obj                  logThread_obj,
          c1frec.logRlgSCN_obj                  logRlgSCN_obj,
          c1frec.logRlgTime_obj                 logRlgTime_obj,
          c1frec.logLowSCN_obj                  logLowSCN_obj,
          c1frec.logLowTime_obj                 logLowTime_obj,
          c1frec.logNextSCN_obj                 logNextSCN_obj,
          c1frec.logNextTime_obj                logNextTime_obj,
          c1frec.logTerminal_obj                logTerminal_obj,
          c1frec.cfType_obj                     cfType_obj,
          c1frec.pdbKey_obj                     pdbKey_obj,
 
          c1frec.keep_options                   keep_options,
          c1frec.keep_until                     keep_until,
 
          c1frec.afzSCN_act                     afzSCN_act,
          c1frec.rfzTime_act                    rfzTime_act,
          c1frec.rfzSCN_act                     rfzSCN_act,
          c1frec.media_con                      media_con,
          c1frec.isrdf_con                      isrdf_con,
          c1frec.site_key_con                   site_key_con,
          c1frec.foreignDbid_obj                foreignDbid_obj,
          c1frec.pluggedRonly_obj               pluggedRonly_obj,
          c1frec.pluginSCN_obj                  pluginSCN_obj,
          c1frec.pluginRlgSCN_obj               pluginRlgSCN_obj,
          c1frec.pluginRlgTime_obj              pluginRlgTime_obj,
 
          c1frec.newDfCreationSCN_obj           newDfCreationSCN_obj,
          c1frec.newToSCN_act                   newToSCN_act,
          c1frec.newRlgSCN_act                  newRlgSCN_act,
          c1frec.newRlgTime_act                 newRlgTime_act,
          c1frec.sfDbUniqueName_obj             sfDbUniqueName_obj,
          c1frec.sparse_backup_con              sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1frec.type_con is not null
 
   UNION ALL
 
--
--
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          implicitRange_act_t                   type_act,
          rcvRecCursor2_c.offlSCN               fromSCN_act,
          rcvRecCursor2_c.onlSCN                toSCN_act,
          rcvRecCursor2_c.onlTime               toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          rcvRecCursor2_c.onlSCN                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction,implicitRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND offlSCN <> 0
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.offlSCN)
      AND (rcvRecCursor2_c.onlSCN >=   -- belongs to this incarnation
           rcvRecCursor2_c.dbincRlgSCN)
      AND (rcvRecCursor2_c.targetSCN is null OR
           rcvRecCursor2_c.onlscn <=   -- don't advance ckpt beyond
           rcvRecCursor2_c.targetSCN)  -- targetSCN
      AND (untilSCN is null OR        -- don't advance ckpt beyond until scn
           rcvRecCursor2_c.onlSCN < untilSCN)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          cleanRange_act_t                      type_act,
          rcvRecCursor2_c.cleanSCN              fromSCN_act,
          rcvRecCursor2_c.clean2SCN             toSCN_act,
          rcvRecCursor2_c.clean2Time            toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          rcvRecCursor2_c.clean2SCN             newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, cleanRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND rcvRecCursor2_c.cleanscn <> 0
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.cleanscn)
      AND -- belongs to this incarnation
          (rcvRecCursor2_c.clean2scn >=
           rcvRecCursor2_c.dbincRlgSCN)
      AND -- ignore if starts beyond target
          (rcvRecCursor2_c.targetscn is null OR
           rcvRecCursor2_c.cleanscn <
           rcvRecCursor2_c.targetSCN)
      AND -- If clean2scn is infinite, then we processed this when scanning
--
          (rcvRecCursor2_c.targetSCN is null OR
           rcvRecCursor2_c.clean2SCN <=
           rcvRecCursor2_c.targetSCN)
      AND -- don't advance ckpt beyond until scn, unless we don't know
--
          (untilscn is null OR
           rcvRecCursor2_c.clean2SCN <= untilSCN OR
           rcvRecCursor2_c.clean2SCN = highscnval)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
          
          cleanRange_act_t                      type_act,
          rcvRecCursor2_c.pluginSCN             fromSCN_act,
          rcvRecCursor2_c.clean2SCN             toSCN_act,
          rcvRecCursor2_c.clean2Time            toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          rcvRecCursor2_c.clean2SCN             newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
 FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, cleanRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 1
      AND rcvRecCursor2_c.cleanscn <> 0
      AND rcvRecCursor2_c.cleanscn <= rcvRecCursor2_c.pluginSCN
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.pluginSCN)
      AND -- belongs to this incarnation
          (rcvRecCursor2_c.clean2scn >=
           rcvRecCursor2_c.dbincRlgSCN)
      AND -- ignore if starts beyond target
          (rcvRecCursor2_c.targetscn is null OR
           rcvRecCursor2_c.pluginSCN <
           rcvRecCursor2_c.targetSCN)
      AND -- If clean2scn is infinite, then we processed this when scanning
--
          (rcvRecCursor2_c.targetSCN is null OR
           rcvRecCursor2_c.clean2SCN <=
           rcvRecCursor2_c.targetSCN)
      AND -- don't advance ckpt beyond until scn, unless we don't know
--
          (untilscn is null OR
           rcvRecCursor2_c.clean2SCN <= untilSCN OR
           rcvRecCursor2_c.clean2SCN = highscnval)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          cleanRange_act_t                      type_act,
          rcvRecCursor2_c.pluginSCN             fromSCN_act,
          rcvRecCursor2_c.crescn                toSCN_act,
          to_date(null)                         toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          crescn                                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, cleanRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND rcvRecCursor2_c.pluginSCN <> 0
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.pluginSCN)
      AND -- belongs to this incarnation
          (crescn >= rcvRecCursor2_c.dbincRlgSCN)
      AND (rcvRecCursor2_c.targetSCN is null OR
           crescn <=   -- don't advance ckpt beyond
           rcvRecCursor2_c.targetSCN)  -- targetSCN
      AND -- don't advance ckpt beyond until scn, unless we don't know
--
          (untilscn is null OR crescn < untilSCN)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          spanningRange_act_t                   type_act,
          rcvRecCursor2_c.targetSCN             fromSCN_act,
          to_number(null)                       toSCN_act,
          to_date(null)                         toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
 
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          to_number(null)                       newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, spanningRange_act_t) = 0
--
--
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND rcvRecCursor2_c.targetSCN <
          rcvRecCursor2_c.dbincRlgSCN
 
    ORDER BY newToSCN_act desc,
             fromSCN_act  desc,
             type_con     asc,
             stamp_con    desc;
 
--
--
--
CURSOR sinceLastBackedAL_c (devtype      IN VARCHAR2,
                            numofbackups IN NUMBER) IS
  SELECT * FROM
    (
    SELECT low_scn,
           next_scn,
           next_time,
           count(*) over
             (partition by sequence#, thread#, dbinc_key) nbackups
      FROM
      (
      SELECT sequence#,
             thread#,
             low_scn,
             next_scn,
             next_time,
             dbinc_key
        FROM brl,
          (SELECT UNIQUE bs.bs_key,
                         copy#,
                         pieces,
                         count(piece#) over
                           (partition by bs.bs_key, copy#) pieces_count,
                         device_type,
                         bs.completion_time
             FROM bs, bp
            WHERE bs.db_key   = this_db_key
              AND bp.status   = 'A'
              AND bs.bck_type = 'L'
              AND bs.bs_key   = bp.bs_key
              AND (devtype IS NULL OR devtype = device_type)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared=TRUE# AND bp.device_type = 'DISK') OR
                     (tape_backups_shared=TRUE# AND bp.device_type <>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
          ) allbs
        WHERE brl.bs_key         = allbs.bs_key
          AND allbs.pieces_count = allbs.pieces
 
      UNION ALL
 
      SELECT sequence#,
             thread#,
             first_change#,
             next_change#,
             next_time,
             dbinc_key
        FROM rc_proxy_archivedlog
       WHERE db_key = this_db_key
         AND status = 'A'
         AND (devtype IS NULL OR devtype = device_type)
      )
    )
    WHERE nbackups >= numofbackups
  ORDER BY next_time       DESC;
 
 
--
CURSOR restore_point_c (con_id IN NUMBER, name  IN VARCHAR2) IS
  SELECT r.name,
         r.dbinc_key dbinc#,
         scn,
         creation_time,
         restore_point_time,
         guarantee_flashback_database guaranteed,
         preserved,
         d.reset_scn,
         d.reset_time,
         pdb.con_id con_id,
         r.clean clean
  FROM rc_restore_point r, dbinc d, pdb, pdb_dbinc
  WHERE d.dbinc_key = r.dbinc_key
    AND site_key = nvl(user_site_key, this_site_key)
    AND (r.name = restore_point_c.name OR restore_point_c.name is null)
    AND pdb.db_key = this_db_key
    AND r.pdb_key = pdb.pdb_key
    AND pdb_dbinc.pdb_key = pdb.pdb_key
    AND pdb_dbinc.drop_scn IS NULL
    AND pdb_dbinc.dbinc_key = this_dbinc_key
  ORDER BY decode(pdb.con_id, restore_point_c.con_id, -1, pdb.con_id),
        scn, creation_time;
 
 
--
CURSOR translatePdbName_c IS
   SELECT con_id, name
     FROM rci_pdbinc_this_dbinc pdbinc
    WHERE pdbinc.dbinc_key  = this_dbinc_key
      AND (untilSCN IS NULL OR pdbinc.create_scn < untilSCN)
      AND (pdbinc.drop_scn IS NULL OR pdbinc.drop_scn > untilSCN)
      AND con_id > 1
 ORDER BY pdbinc.drop_scn desc;
 
--
CURSOR translatePdbFile_c(fromSCN IN number, toSCN IN number) IS
   SELECT con_id, file#, stop_change# stopSCN
     FROM rci_datafile_this_dbinc rcd
    WHERE rcd.dbinc_key  = this_dbinc_key
      AND decode(plugin_change#, 0, creation_change#, plugin_change#) <= toSCN
      AND (drop_change# is null OR drop_change# > fromSCN)
      AND (nvl(realf_site_key, translation_site_key) = site_key);
 
CURSOR translateNoBackupPdb_c(pdbname IN varchar2) IS
   SELECT decode(pdbinc.nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_pdbinc_this_dbinc pdbinc
    WHERE pdbinc.dbinc_key = this_dbinc_key
      AND pdbinc.name = translateNoBackupPdb_c.pdbname
      AND (untilSCN IS NULL OR pdbinc.create_scn < untilSCN)
      AND (pdbinc.drop_scn IS NULL OR pdbinc.drop_scn > untilSCN);
 
--
PROCEDURE debout(
   line IN varchar2
)
IS
    isrs            number;
BEGIN
--
--
   IF rsdebug IS NULL
   THEN
     SELECT COUNT(*) INTO isrs FROM user_tables WHERE table_name = 'BLOCKS';
     rsdebug := isrs > 0;
   END IF;
 
--
   IF rsdebug
   THEN
     EXECUTE IMMEDIATE 'BEGIN sys.kbrsi_icd.rsTrace(:1); END;' USING line;
   ELSE
     dbms_output.put_line(line);
   END IF;
 
EXCEPTION
   WHEN others THEN
     dbms_output.put_line(line);
END debout;
 
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
--
PROCEDURE deb(
   type IN number
  ,line IN varchar2 DEFAULT NULL
)
IS
    pname           varchar2(512);
    pref            varchar2(11) := 'DBGRCVMAN: ';
    dstr            varchar2(1000);
BEGIN
   IF (not debug) THEN
      RETURN;
   END IF;
 
   IF type = DEB_ENTER THEN
      pname := line;
      dstr := (pref||rpad(' ',pname_i)||'ENTERING '||pname);
      pname_i := pname_i + 1;
      last_pnames(pname_i) := pname;
   ELSIF type = DEB_IN THEN
      dstr := (pref||rpad(' ',pname_i+2)||last_pnames(pname_i)||
                           ' '||line);
   ELSIF type = DEB_EXIT THEN
      IF (pname_i >= 1) THEN
          pname := last_pnames(pname_i);
          pname_i := pname_i - 1;
      ELSE
          pname := DEB_DEF_PNAME;
      END IF;
      IF line is not NULL THEN
         dstr := (pref||rpad(' ', pname_i)||'EXITING '||pname||
                              ' '||line);
      ELSE
         dstr := (pref||rpad(' ', pname_i)||'EXITING '||pname);
      END IF;
   ELSIF type = DEB_OPEN THEN
      pname := last_pnames(pname_i);
      dstr := (pref||rpad(' ', pname_i)||'OPENING cursor '||
                           line||' in '||pname);
   ELSE
      dstr := (pref||line);
   END IF;
 
   debout(dstr);
 
EXCEPTION
   WHEN others THEN
      debout('caught exception during deb ' || substr(sqlerrm, 1, 512));
END;
 
FUNCTION bool2char(
   flag IN boolean)
RETURN varchar2 IS
BEGIN
   IF (flag) THEN
      RETURN 'TRUE';
   ELSE
      RETURN 'FALSE';
   END IF;
END bool2char;
 
--
--
--
 
--
PROCEDURE setAlTransClause(
   thread   IN NUMBER   DEFAULT NULL
  ,fromTime IN DATE     DEFAULT NULL
  ,toTime   IN DATE     DEFAULT NULL
  ,fromSCN  IN NUMBER   DEFAULT NULL
  ,toSCN    IN NUMBER   DEFAULT NULL
  ,fromSeq  IN NUMBER   DEFAULT NULL
  ,toSeq    IN NUMBER   DEFAULT NULL
  ,pattern  IN VARCHAR2 DEFAULT NULL)
IS
BEGIN
   tc_thread   := thread;
   tc_fromTime := fromTime;
   tc_toTime   := toTime;
   tc_fromSCN  := fromSCN;
   tc_toSCN    := toSCN;
   tc_fromSeq  := fromSeq;
   tc_toSeq    := toSeq;
   tc_pattern  := pattern;
   deb(DEB_PRINT, 'tc_thread='   || tc_thread);
   deb(DEB_PRINT, 'tc_fromSCN='  || fromSCN);
   deb(DEB_PRINT, 'tc_toSCN='    || toSCN);
   deb(DEB_PRINT, 'tc_fromSeq='  || fromSeq);
   deb(DEB_PRINT, 'tc_fromTime=' || fromTime);
   deb(DEB_PRINT, 'tc_toTime='   || toTime);
   deb(DEB_PRINT, 'tc_toSeq='    || toSeq);
   deb(DEB_PRINT, 'tc_pattern='  || pattern);
END setAlTransClause;
 
--
PROCEDURE setDfTransClause(
   fno IN NUMBER)
IS
BEGIN
   tc_fno(fno) := TRUE;
END setDfTransClause;
 
--
PROCEDURE setDBTransClause
IS
BEGIN
   deb(DEB_PRINT, 'tc_database=TRUE');
   tc_database := TRUE#;
END setDBTransClause;
 
--
PROCEDURE resetAlTransClause
IS
BEGIN
   tc_thread   := to_number(null);
   tc_fromTime := to_date(null);
   tc_toTime   := to_date(null);
   tc_fromSCN  := to_number(null);
   tc_toSCN    := to_number(null);
   tc_fromSeq  := to_number(null);
   tc_toSeq    := to_number(null);
   tc_pattern  := to_char(null);
   currInc     := -1;
   getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
   getArchivedLogOnlyrdf := 0;
   tc_threadSeq.delete;
END resetAlTransClause;
 
--
PROCEDURE resetDBTransClause
IS
BEGIN
   tc_database := FALSE#;
   tc_fno.delete;
END resetDBTransClause;
 
--
PROCEDURE resetDbidTransClause
IS
BEGIN
   tc_anydbid := FALSE#;
   tc_dbid.delete;
END resetDBidTransClause;
 
--
--
--
 
--
 
--
FUNCTION skipTableSpace(
   tsName   IN varchar2
  ,pdbId    IN number)
RETURN boolean IS
BEGIN
   deb(DEB_ENTER, 'skipTableSpace');
   FOR i in 1..skipTablespaceList.count LOOP
      IF (tsName = skipTablespaceList(i).name AND
          pdbId  = skipTablespaceList(i).pdbId) THEN
         deb(DEB_EXIT, 'with: TRUE');
         RETURN TRUE;
      END IF;
   END LOOP;
   deb(DEB_EXIT, 'with: FALSE');
   RETURN FALSE;
END;
 
--
FUNCTION isDeviceTypeAllocated(
   deviceType IN varchar2)
RETURN NUMBER IS
BEGIN
   IF (anyDevice = TRUE#) THEN
      RETURN TRUE#;
   END IF;
 
   FOR i IN 1..deviceCount LOOP
      IF deviceType = deviceList(i) THEN
         RETURN TRUE#;
      END IF;
   END LOOP;
 
   RETURN FALSE#;
END isDeviceTypeAllocated;
 
--
--
--
 
--
--
--
--
FUNCTION computeAvailableMask(
   available            IN number
  ,unavailable          IN number
  ,deleted              IN number
  ,expired              IN number
  ,partial_avail        IN number DEFAULT 0)
RETURN binary_integer IS
   rc           binary_integer := 0;
BEGIN
   deb(DEB_ENTER, 'computeAvailableMask');
   IF (available > 0) THEN
      rc := rc + dbms_rcvman.BSavailable;
   END IF;
   IF (unavailable > 0 ) THEN
      rc := rc + dbms_rcvman.BSunavailable;
   END IF;
   IF (deleted > 0 ) THEN
      rc := rc + dbms_rcvman.BSdeleted;
   END IF;
   IF (expired > 0 ) THEN
      rc := rc + dbms_rcvman.BSexpired;
   END IF;
   IF (partial_avail > 0 ) THEN
      rc := rc + dbms_rcvman.BSpartial_avail;
   END IF;
 
   deb(DEB_EXIT, 'with rc:'||to_char(rc));
   RETURN rc;
END computeAvailableMask;
 
--
FUNCTION validateBackupSet0(
   tag                     IN     varchar2 DEFAULT NULL
  ,tagMatchRequired        IN     boolean  DEFAULT TRUE
  ,checkDeviceIsAllocated  IN     boolean  DEFAULT TRUE
  ,validRec                OUT    NOCOPY validBackupSetRec_t)
RETURN binary_integer IS
   local        validBackupSetRec_t;
   rc           binary_integer;
   gotRecord    number;
BEGIN
   deb(DEB_ENTER, 'validateBackupSet0');
   <<validationLoop>>
   LOOP
      <<nextRow>>
      gotRecord := getValidBackupSet(validBackupSetRec      => local,
                                     checkDeviceIsAllocated => FALSE#);
 
      EXIT WHEN gotRecord = FALSE#;             -- cursor is closed already
 
      IF (checkDeviceIsAllocated) THEN
         IF (anyDevice = FALSE# AND
             isDeviceTypeAllocated(local.deviceType) = FALSE#) THEN
            deb(DEB_IN, 'device is not allocated');
--
--
            IF (rc IS NULL OR rc <> SUCCESS) THEN
               deb(DEB_IN, 'set rc to available');
               rc := dbms_rcvman.AVAILABLE;
            END IF;
            GOTO nextRow;
         END IF;
      END IF;
 
      validRec := local;                        -- set OUT mode arg
 
      IF (tag IS NOT NULL AND NOT tagMatchRequired) THEN
--
--
--
--
         IF (tag = local.tag) THEN
--
--
--
--
--
--
--
            deb(DEB_IN, 'tag matches');
            rc := SUCCESS;
            deb(DEB_IN, 'exiting loop with rc: SUCCESS');
            EXIT validationLoop;
         ELSE
--
--
--
            deb(DEB_IN, 'tag does not match, continuing search');
            rc := SUCCESS;
         END IF;
      ELSE
--
--
--
         rc := SUCCESS;
         deb(DEB_IN, 'exiting loop with rc: SUCCESS');
         EXIT validationLoop;
      END IF;
   END LOOP;
 
   IF (rc IS NULL) THEN
      deb(DEB_IN, 'rc is null, setting to unavailable');
      rc := dbms_rcvman.UNAVAILABLE;
   END IF;
 
   deb(DEB_EXIT, 'with rc:'||to_char(rc));
   RETURN rc;
 
END validateBackupSet0;
 
--
--
--
 
--
FUNCTION getRecStackCount
RETURN binary_integer IS
BEGIN
  RETURN rcvRecStack.count;
END getRecStackCount;
 
--
FUNCTION getRecFullCount
RETURN binary_integer IS
BEGIN
  RETURN rcvRecStackState.fullBackups;
END getRecFullCount;
 
--
PROCEDURE rcvRecPush(
   rcvRec IN rcvRec_t)
IS
BEGIN
   rcvRecStack.extend;
   deb(DEB_PRINT,'rcvRecPush:from_scn='||rcvRec.fromSCN_act||',to_scn='||rcvRec.toSCN_act||',rcvRecStackCount='||rcvRecStack.count);
   rcvRecStack(rcvRecStack.last) := rcvRec;
END rcvRecPush;
 
--
PROCEDURE rcvRecGet(
   indx   IN  number
  ,rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   rcvRec := rcvRecStack(indx);
END rcvRecGet;
 
--
PROCEDURE rcvRecTop(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   IF (rcvRecStack.count = 0) THEN
      rcvRec := NULL;
   ELSE
      rcvRecGet(rcvRecStack.count, rcvRec);
      deb(DEB_PRINT,'rcvRecPop:from_scn='||rcvRec.fromSCN_act||
                    ',to_scn='||rcvRec.toSCN_act||
                    ',rcvRecStackCount='||rcvRecStack.count );
   END IF;
END rcvRecTop;
 
--
PROCEDURE rcvRecPop(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   rcvRecTop(rcvRec);
   rcvRecStack.trim;
END rcvRecPop;
 
--
PROCEDURE rcvRecConvert(
   rcvRec IN OUT NOCOPY rcvRec_t)
IS
BEGIN
--
--
 
  rcvRec.recid_con      := nvl(rcvRec.recid_con, 0);
  rcvRec.stamp_con      := nvl(rcvRec.stamp_con, 0);
  rcvRec.setStamp_con   := nvl(rcvRec.setStamp_con, 0);
  rcvRec.setCount_con   := nvl(rcvRec.setCount_con, 0);
  rcvRec.fileName_con   := nvl(rcvRec.fileName_con, 'NULL');
  rcvRec.blockSize_con  := nvl(rcvRec.blockSize_con, 0);
  rcvRec.blocks_con     := nvl(rcvRec.blocks_con, 0);
  rcvRec.deviceType_con := nvl(rcvRec.deviceType_con, 'NULL');
END rcvRecConvert;
 
--
PROCEDURE printRcvRec(
   action  IN rcvRec_t
  ,summary IN boolean default FALSE)
IS
   l              varchar2(600);
   cfcretime      varchar2(100);
   action_deleted boolean;
 
   procedure prt(str in out varchar2) is begin
      if length(str) > 2 then
         deb(DEB_PRINT, str);
         str := ' ';
      end if;
   end;
BEGIN
 
--
--
--
   deb(DEB_PRINT, 'DUMPING RECOVERY CONTAINER');
--
   IF (action.type_con = backupSet_con_t) THEN
      IF (action.type_act = full_act_t) THEN
         deb(DEB_PRINT, ' Full Backup Set');
      ELSE
         deb(DEB_PRINT, ' Incremental Backup Set');
      END IF;
   ELSIF (action.type_con = proxyCopy_con_t) THEN
      deb(DEB_PRINT, ' Proxy Backup');
   ELSIF (action.type_con = imageCopy_con_t) THEN
      deb(DEB_PRINT, ' Datafile Copy');
   ELSIF (action.type_con = offlineRangeRec_con_t) THEN
      IF (action.type_act = offlineRange_act_t) THEN
         deb(DEB_PRINT, ' Offline Range Record');
      ELSIF (action.type_act = cleanRange_act_t) THEN
         deb(DEB_PRINT, ' Clean Range');
      ELSIF (action.type_act = implicitRange_act_t) THEN
         deb(DEB_PRINT, ' Implicit Offline Range');
      ELSIF (action.type_act = spanningRange_act_t) THEN
         deb(DEB_PRINT, ' Spanning Offline Range');
      ELSE
         deb(DEB_PRINT, ' Unknown Offline Range Action Type');
      END IF;
   ELSIF (action.type_con = datafile_con_t) THEN
      deb(DEB_PRINT, ' datafile container type');
   ELSIF (action.type_con = addredo_con_t) THEN
      deb(DEB_PRINT,'Add Redo');
   ELSE
      deb(DEB_PRINT, ' Unknown recovery container type');
   END IF;
 
--
   IF (action.type_con = backupSet_con_t) THEN
      deb(DEB_PRINT, '   bsKey=' || to_char(action.bsKey_con) ||
          '  bsRecid=' || to_char(action.bsRecid_con) ||
          '  bsStamp=' || to_char(action.bsStamp_con) ||
          '  setStamp=' || to_char(action.setStamp_con) ||
          '  setCount=' || to_char(action.setCount_con) ||
          '  site_key=' || to_char(action.site_key_con));
      deb(DEB_PRINT, '   bsLevel=' || to_char(action.bsLevel_con) ||
          '  bsType=' || action.bsType_con ||
          '  pieceCount=' || to_char(action.pieceCount_con));
      deb(DEB_PRINT, '   multi_section=' ||
                     nvl(action.multi_section_con, 'NULL'));
   ELSIF (action.type_con = proxyCopy_con_t OR
          action.type_con = imageCopy_con_t) THEN
      deb(DEB_PRINT, '   fileName=' || action.fileName_con);
      deb(DEB_PRINT, '   media=' || action.media_con);
   END IF;
 
   IF (summary) THEN
      RETURN;
   END IF;
 
--
   l := ' ';
 
--
   IF (action.key_con is not null) THEN
      l := l || '  key=' || to_char(action.key_con);
   END IF;
 
--
   IF (action.recid_con is not null) THEN
      l := l || '  recid=' || to_char(action.recid_con) ||
                '  stamp=' || to_char(action.stamp_con);
   END IF;
 
--
   IF (action.status_con is not null) THEN
      l := l || '  status=' || action.status_con;
   END IF;
 
   IF (action.type_con = imageCopy_con_t OR
       action.type_con = backupSet_con_t) THEN
      l := l || '  sparse_backup_con =' || action.sparse_backup_con;
   END IF;
 
 
   prt(l);
 
--
   IF (action.tag_con is not null) THEN
      l := l || '  tag=' || action.tag_con;
   END IF;
 
--
   IF (action.compTime_con is not null) THEN
      l := l || '  compTime=' || to_char(action.compTime_con);
   END IF;
 
   prt(l);
 
   IF (action.deviceType_con is not null) THEN
      l := l || '  deviceType=' || action.deviceType_con;
   END IF;
 
   IF (action.blocks_con is not null) THEN
      l := l || '  blocks=' || to_char(action.blocks_con) ||
           '  blockSize=' || to_char(action.blockSize_con);
   END IF;
 
   IF (action.cfCreationTime_con is not null) THEN
      l := l || '  cfCreationTime=' || to_char(action.cfCreationTime_con);
   END IF;
 
   IF (action.pieceNumber_con is not null) THEN
      l := l || '  pieceNumberl=' || to_char(action.pieceNumber_con);
   END IF;
 
   IF (action.bpCompTime_con is not null) THEN
      l := l || '  bpCompTime=' || to_char(action.bpCompTime_con);
   END IF;
 
   IF (action.bpCompressed_con is not null) THEN
      l := l || '  bpCompressed=' || to_char(action.bpCompressed_con);
   END IF;
 
   prt(l);
 
--
--
--
 
--
   IF (action.fromSCN_act is not null) THEN
      l := l || '  fromSCN=' || to_char(action.fromSCN_act);
   END IF;
 
--
   IF (action.toSCN_act is not null) THEN
      l := l || '  toSCN=' || to_char(action.toSCN_act) ||
           '  toTime=' || to_char(action.toTime_act);
   END IF;
 
--
   IF (action.level_act is not null) THEN
      l := l || '  level=' || to_char(action.level_act);
   END IF;
 
--
   IF (action.section_size_act is not null) THEN
      l := l || '  section_size=' || to_char(action.section_size_act);
   END IF;
 
   prt(l);
 
   IF (action.rlgSCN_act is not null) THEN
      l := l || '  rlgSCN=' || to_char(action.rlgSCN_act) ||
           '  rlgTime=' || to_char(action.rlgTime_act) ||
           '  dbincKey=' || to_char(action.dbincKey_act);
   END IF;
 
   prt(l);
 
   IF (action.afzSCN_act is not null) THEN
      l := l || '  afzSCN=' || to_char(action.afzSCN_act);
   END IF;
 
   prt(l);
 
   IF (action.rfzSCN_act is not null AND action.rfzSCN_act != 0) THEN
      l := l || '  rfzSCN=' || to_char(action.rfzSCN_act) ||
           '  rfzTime=' || nvl(to_char(action.rfzTime_act), 'NULL');
   END IF;
 
   prt(l);
 
--
--
--
 
   IF (action.pdbKey_obj IS NOT NULL) THEN
      l := l || ' pdbKey=' || to_char(action.pdbKey_obj);
   END IF;
 
   prt(l);
 
   IF (action.dfNumber_obj IS NOT NULL) THEN
      l := l || '  dfNumber=' || to_char(action.dfNumber_obj) ||
                '  creationSCN=' || to_char(action.dfCreationSCN_obj) ||
                '  pluginSCN=' || to_char(action.pluginSCN_obj) ||
                '  foreignDbid=' || to_char(action.foreignDbid_obj) ||
                '  pluggedRonly=' || to_char(action.pluggedRonly_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  cfType=' || nvl(action.cfType_obj, 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  keep_options=' || nvl(to_char(action.keep_options), 'NULL') ||
                '  keep_until='   || nvl(to_char(action.keep_until), 'NULL');
      deb(DEB_PRINT, l);
      IF (action.cfSequence_obj IS NOT NULL) THEN
         l := ' ';
         l := l || '  cfSequence=' || to_char(action.cfSequence_obj) ||
                   '  cfDate=' || nvl(to_char(action.cfDate_obj), 'NULL');
         deb(DEB_PRINT, l);
      END IF;
   ELSIF (action.logSequence_obj IS NOT NULL) THEN
      l := l || '  logSequence=' || to_char(action.logSequence_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logThread=' || to_char(action.logThread_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logLowSCN=' || to_char(action.logLowSCN_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logLowTime=' || to_char(action.logLowTime_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logNextSCN=' || nvl(to_char(action.logNextSCN_obj), 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logNextTime=' || nvl(to_char(action.logNextTime_obj), 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logTerminalEor=' || action.logTerminal_obj;
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logRlgSCN=' || nvl(to_char(action.logRlgSCN_obj), 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logRlgTime=' || nvl(to_char(action.logRlgTime_obj), 'NULL');
      deb(DEB_PRINT, l);
   ELSIF (action.toTime_act IS NOT NULL) THEN
      deb(DEB_PRINT, '  SPFILE');
      deb(DEB_PRINT, '  modification_time=' ||  to_char(action.toTime_act));
      deb(DEB_PRINT, '  db_unique_name=' || action.sfDbUniqueName_obj);
 
      l := ' ';
      l := l || '  keep_options=' || nvl(to_char(action.keep_options), 'NULL') ||
                '  keep_until='   || nvl(to_char(action.keep_until), 'NULL');
      deb(DEB_PRINT, l);
   ELSE
      deb(DEB_PRINT, '  Unknown Recovery Object');
   END IF;
 
EXCEPTION
   WHEN OTHERS THEN
   deb(DEB_PRINT, 'printRcvRec: caught an exception, aborting print');
   RETURN;
END printRcvRec;
 
--
--
--
 
--
FUNCTION redoNeeded(
   action IN rcvRec_t)
RETURN boolean IS
BEGIN
   deb(DEB_ENTER, 'redoNeeded');
   IF (rcvRecStackState.lowAction > 0 AND   -- Have a non-full_act_t on stack?
       action.toSCN_act <
       rcvRecStack(rcvRecStackState.lowAction).fromSCN_act) THEN
      deb(DEB_EXIT, 'with: TRUE');
      RETURN TRUE;
   ELSE
      deb(DEB_EXIT, 'with: FALSE');
      RETURN FALSE;
   END IF;
END redoNeeded;
 
--
FUNCTION canAddRedo(
   isAncestor    IN boolean
  ,from_scn      IN number
  ,from_rlgscn   IN number
  ,to_action     IN rcvRec_t
  ,partial_rcv   IN boolean
  ,doingRecovery IN boolean)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'canAddRedo');
   IF (from_rlgscn = this_reset_scn) THEN
      IF (partial_rcv) THEN
         deb(DEB_EXIT, 'with: action_OK');
         RETURN action_OK;
      ELSE
--
--
--
--
--
--
--
--
--
--
--
--
         deb(DEB_EXIT, 'with: action_FAIL');
         RETURN action_FAIL;
      END IF;
   ELSE
      deb(DEB_IN, 'from_rlgscn=' || nvl(to_char(from_rlgscn), 'NULL') ||
          ' this_reset_scn=' || to_char(this_reset_scn));
      IF (isAncestor) THEN
         deb(DEB_IN, 'isAncestor is TRUE;');
         IF (canApplyAnyRedo = TRUE# AND
             from_scn >=
               nvl(inc_list(max_inc_idx-1).prior_resetlogs_change#,
                   inc_list(max_inc_idx-1).resetlogs_change#)) THEN
            deb(DEB_PRINT, 'canAddRedo: return action_OLD_INC_REDO');
            return action_OLD_INC_REDO;
         ELSE
--
--
--
--
--
--
--
--
--
--
--
--
--
--
            IF (doingRecovery) THEN
              deb(DEB_PRINT, 'with: action_OLD_REDO (doingRecovery)');
              RETURN action_OLD_REDO;
            ELSIF (allIncarnations = TRUE#) THEN
              deb(DEB_PRINT, 'canAddRedo: returning action_OK');
              RETURN action_OK;
            ELSE
              deb(DEB_PRINT, 'canAddRedo: returning action_OLD_REDO');
              RETURN action_OLD_REDO;
            END IF;
         END IF;
      ELSE
         deb(DEB_IN, 'isAncestor is FALSE;');
--
--
         deb(DEB_EXIT, 'with: action_OLD_REDO');
         RETURN action_OLD_REDO;
      END IF;
   END IF;
   deb(DEB_EXIT, 'with undefined status');
END canAddRedo;
 
--
FUNCTION addRedo(
   isAncestor    IN boolean
  ,from_scn      IN number
  ,from_rlgscn   IN number
  ,to_action     IN rcvRec_t
  ,partial_rcv   IN boolean
  ,doingRecovery IN boolean)
RETURN number IS
   canAdd      number;
BEGIN
   deb(DEB_ENTER, 'addRedo');
   deb(DEB_IN,'Enter - from_scn=' || from_scn|| ',from_rlgscn=' ||from_rlgscn);
 
   canAdd := canAddRedo(isAncestor, from_scn, from_rlgscn,
                        to_action, partial_rcv, doingRecovery);
   IF (canAdd = action_FAIL) THEN
--
--
--
--
--
--
 
--
--
--
--
--
--
      rcvRecStackState.lowAction := 0;
 
      rcvRecStack.trim(rcvRecStack.last -
                       greatest(rcvRecStackState.savePoint,
                                rcvRecStackState.top));
 
      deb(DEB_IN,'trimming savepoint1, rcvRecStackCount='|| rcvRecStack.count);
      deb(DEB_EXIT, 'with: action_FAIL');
      RETURN action_FAIL;
   ELSIF (canAdd = action_OK) THEN
      redoRec.type_act          := redo_act_t;
      redoRec.fromSCN_act       := from_scn;
      redoRec.toSCN_act         := to_action.fromSCN_act;
      redoRec.toTime_act        := to_date(null);
      redoRec.rlgSCN_act        := from_rlgscn;
      redoRec.dfNumber_obj      := to_action.dfNumber_obj;
      redoRec.dfCreationSCN_obj := to_action.dfCreationSCN_obj;
      redoRec.pluginSCN_obj     := 0;
      redoRec.pluggedRonly_obj  := 0;
      rcvRecPush(redoRec);
 
      deb(DEB_EXIT, 'with: action_OK');
      RETURN action_OK;
   ELSIF (canAdd = action_OLD_INC_REDO) THEN
      redoRec.type_con          := addredo_con_t;
      redoRec.type_act          := redo_act_t;
      redoRec.fromSCN_act       := from_scn;
      redoRec.toSCN_act         := to_action.fromSCN_act;
      redoRec.toTime_act        := to_date(null);
      redoRec.rlgSCN_act        := from_rlgscn;
      redoRec.dfNumber_obj      := to_action.dfNumber_obj;
      redoRec.dfCreationSCN_obj := to_action.dfCreationSCN_obj;
      redoRec.pluginSCN_obj     := 0;
      redoRec.pluggedRonly_obj  := 0;
 
      deb(DEB_EXIT, 'with: action_OLD_INC_REDO');
      RETURN action_OLD_INC_REDO;
   ELSE                                         -- ancestral incarnation
--
--
--
--
      deb(DEB_EXIT, 'with: action_OLD_REDO');
      RETURN action_OLD_REDO;
   END IF;
   deb(DEB_EXIT, 'with undefined status');
END addRedo;
 
--
--
FUNCTION isPdbScnOrphan(fromSCN IN NUMBER,
                        toSCN   IN NUMBER,
                        afzSCN  IN NUMBER,
                        pdbId   IN NUMBER)
RETURN BOOLEAN IS
--
   l_afzSCN NUMBER := nvl(greatest(afzSCN, toSCN), toSCN);
BEGIN
   IF (pdb_inc_list.exists(pdbId)) THEN
      FOR inc_idx in 0..pdb_inc_list(pdbId).count-1 LOOP
         IF ((fromSCN = 0 OR
              fromSCN > pdb_inc_list(pdbId)(inc_idx).erscn) AND
             (l_afzSCN > pdb_inc_list(pdbId)(inc_idx).erscn)) THEN
            EXIT;
         END IF;
 
         IF ((fromSCN  >= pdb_inc_list(pdbId)(inc_idx).incscn AND
              fromSCN  <= pdb_inc_list(pdbId)(inc_idx).erscn) OR
             (l_afzSCN >= pdb_inc_list(pdbId)(inc_idx).incscn AND
              l_afzSCN <= pdb_inc_list(pdbId)(inc_idx).erscn)) THEN
            deb(DEB_PRINT, 'isPdbScnOrphan: inc=' || inc_idx||
                           ',fromSCN =' || fromSCN ||
                           ',toSCN ='   || toSCN   ||
                           ',afzSCN ='  || nvl(afzSCN, '')  ||
                           ',incSCN ='  ||
                           pdb_inc_list(pdbId)(inc_idx).incscn ||
                           ',erscn=' ||
                           pdb_inc_list(pdbId)(inc_idx).erscn);
            deb(DEB_PRINT, 'isPdbScnOrphan: belongs to orphan branch ' ||
                           'of this sub incarnation:');
            RETURN TRUE;
         END IF;
      END LOOP;
   END IF;
 
   RETURN FALSE;
END isPdbScnOrphan;
 
--
--
--
FUNCTION CheckRecAction(
   action   IN rcvRec_t
  ,pdbId    IN number
  ,cleanSCN IN number)
RETURN number IS
   rlgSCN   number;
   rlgTime  date;
   toSCN    number;
   fromSCN  number;
   afzSCN   number;
   creSCN   number;
BEGIN
 
  IF (canApplyAnyRedo = FALSE#) THEN
     return SUCCESS;
  END IF;
 
  IF (action.pluggedRonly_obj != 0) THEN
     deb(DEB_PRINT, 'CheckRecAction called for plugged readonly action');
 
     rlgSCN  := action.pluginRlgSCN_obj;
     rlgTime := action.pluginRlgTime_obj;
 
     toSCN   := action.pluginSCN_obj;
     fromSCN := action.pluginSCN_obj;
     creSCN  := action.pluginSCN_obj;
  ELSE
     rlgSCN  := action.rlgSCN_act;
     rlgTime := action.rlgTime_act;
 
     toSCN   := action.toSCN_act;
     fromSCN := action.fromSCN_act;
     afzSCN  := action.afzSCN_act;
     creSCN  := action.dfCreationSCN_obj;
  END IF;
 
  deb(DEB_PRINT, ' CheckRecAction called '||
                   to_char(rlgTime,'MM/DD/RR HH24:MI:SS')||
                  '; rlgscn='||rlgSCN || '; pdbId=' || pdbId ||
                  '; cleanscn=' || nvl(to_char(cleanSCN), 'NULL'));
 
  IF (action.type_con = backupSet_con_t OR
      action.type_con = imageCopy_con_t OR
      action.type_con = proxyCopy_con_t OR
      action.type_con = offlineRangeRec_con_t) THEN
    FOR inc_idx in 0..max_inc_idx-1 LOOP
      IF (rlgSCN = inc_list(inc_idx).resetlogs_change#  AND
          rlgTime = inc_list(inc_idx).resetlogs_time ) THEN
        IF (inc_idx = 0 OR
            toSCN <= inc_list(inc_idx-1).resetlogs_change#) THEN
           deb(DEB_PRINT, 'CheckRecAction:matches inc='||inc_idx||
                          ',fromscn='|| fromSCN ||
                          ',toscn='  || toSCN   ||
                          ',afzSCN=' || nvl(afzSCN, ''));
           IF (pdbId > 1 AND
               isPdbScnOrphan(fromSCN, toSCN, afzSCN, pdbId)) THEN
              return action_SKIP;
           ELSE
              return SUCCESS;
           END IF;
        ELSE
           deb(DEB_PRINT, 'CheckRecAction: inc='||inc_idx||
                          ',toscn='||toSCN||
                          ' exceeds '||inc_list(inc_idx-1).resetlogs_change#);
           deb(DEB_PRINT, 'CheckRecAction:belongs to orphan branch ' ||
                          'of this incarnation:');
           return action_SKIP;
        END IF;
      END IF;
    END LOOP;
 
    deb(DEB_PRINT, 'CheckRecAction:not known to incarnation table');
 
--
    IF (nvl(afzSCN,0) = 0 AND toSCN = cleanSCN) THEN
       deb(DEB_PRINT, 'CheckRecAction: ok because backup ckpscn eq cleanscn');
       return SUCCESS;
    END IF;
  ELSE
     return SUCCESS;
  END IF;
 
--
--
--
  return action_SKIP;
END CheckRecAction;
 
--
FUNCTION isValidAction(action  IN rcvRec_t)
RETURN boolean IS
valid boolean := TRUE;
BEGIN
   IF (bitand(action.type_con, getRA_containerMask) = 0) THEN
      deb(DEB_PRINT, 'isValidAction: skipping non-selected container type');
      deb(DEB_PRINT, 'isValidAction: Container type : '|| action.type_con);
      deb(DEB_PRINT, 'isValidAction: Container Mask : '|| getRA_containerMask);
      valid := FALSE;                           -- then skip this action
   ELSIF (bitand(action.type_act, getRA_actionMask) = 0) THEN
      deb(DEB_PRINT, 'isValidAction: skipping non-selected action type');
      deb(DEB_PRINT, 'isValidAction: Action type : '|| action.type_act);
      deb(DEB_PRINT, 'isValidAction: Action Mask : '|| getRA_actionMask);
      valid := FALSE;                           -- then skip this action
   ELSIF (bitand(action.type_con, deleted_con_t) > 0) THEN
      deb(DEB_PRINT, 'isValidAction: deleted action skipped:');
      valid := FALSE;                             -- then skip this action
--
   ELSIF (computeRA_allRecords = TRUE# AND
          restoreTag is not null AND
          bitand(action.type_con, tagMask_con_t) > 0 AND
          (action.tag_con <> restoreTag OR action.tag_con is null)) THEN
      deb(DEB_PRINT, 'isValidAction: tag mismatch - skipped:');
      valid := FALSE;                             -- then skip this action
--
--
   ELSIF (getRA_completedAfter IS NOT NULL AND
          action.compTime_con < getRA_completedAfter) THEN
      deb(DEB_PRINT, 'isValidAction: compTime < completedAfter - skipped:');
      valid := FALSE;                             -- then skip this action
--
   ELSIF (getRA_completedBefore IS NOT NULL AND
          action.compTime_con > getRA_completedBefore) THEN
      deb(DEB_PRINT, 'isValidAction: compTime > completedBefore - skipped:');
      valid := FALSE;
--
   ELSIF (getRA_likePattern IS NOT NULL AND
          action.fileName_con NOT LIKE getRA_likePattern) THEN
      deb(DEB_PRINT, 'isValidAction: LikePattern not matched - skipped:');
      valid := FALSE;
   END IF;
 
   RETURN valid;
END isValidAction;
 
--
PROCEDURE resetrcvRecStack IS
BEGIN
   IF (rcvRecStack.count > 0) THEN
      rcvRecStack.trim(rcvRecStack.count);
   END IF;
 
   rcvRecStackState.lowAction   := 0;
   rcvRecStackState.savePoint   := 0;
   rcvRecStackState.fullBackups := 0;
   rcvRecStackState.top         := 0;
END resetrcvRecStack;
 
--
--
--
--
--
--
--
--
PROCEDURE fetchCursor1RecoveryAction(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,opcode        IN     binary_integer  -- 1 => seeknext, 2 => seekcurrent
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer  -- 1 => readonly, 0 => readwrite
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date
  ,rmanCmd       IN     binary_integer)
IS
  action    rcvRec_t;
  actCreSCN number;
  inpCreSCN number;
BEGIN
   deb(DEB_ENTER, 'fetchCursor1RecoveryAction');
   deb(DEB_IN, 'opcode=' || to_char(opcode));
 
--
   IF (rcvRecCursor1_c%NOTFOUND) THEN
      rcvRecCursor.currc1.type_con := to_number(null);
      deb(DEB_EXIT, 'no more records');
      RETURN;
   END IF;
 
   IF (pluginSCN != 0) THEN
      inpCreSCN := pluginSCN;
   ELSE
      inpCreSCN := creSCN;
   END IF;
 
--
   IF (opcode = 1) THEN
      goto seekNext;
   ELSIF (opcode = 2) THEN
      goto seekCurrent;
   ELSE
      raise_application_error(-20999, 'fetchCursor1RecoveryAction - 1');
   END IF;
 
--
<<seekNext>>
   deb(DEB_IN, 'seekNext');
   LOOP
      rcvRecCursor.currc1.type_con := to_number(null);
      FETCH rcvRecCursor1_c INTO rcvRecCursor.currc1;
      IF (rcvRecCursor1_c%NOTFOUND) THEN
         rcvRecCursor.currc1.type_con := to_number(null);
         deb(DEB_IN, 'no more records');
         EXIT;
      END IF;
      
--
      IF (rcvRecCursor.currc1.pluggedRonly_obj = 1) THEN
         deb(DEB_IN, 'rcvRecCursor1_c plugged read only object');
         deb(DEB_IN, 'adjust toSCN ' || rcvRecCursor.currc1.toSCN_act ||
             ' to pluginSCN ' || rcvRecCursor.currc1.pluginSCN_obj);
         rcvRecCursor.currc1.toSCN_act := rcvRecCursor.currc1.pluginSCN_obj;
      END IF;
 
      IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
         actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
      ELSE
         actCreSCN := rcvRecCursor.currc1.dfCreationSCN_obj;
      END IF;
      deb(DEB_IN, 'rcvRecCursor1_c record');
      printRcvRec(rcvRecCursor.currc1);
      IF (rcvRecCursor.currc1.dfNumber_obj > fno           OR
          (rcvRecCursor.currc1.dfNumber_obj = fno AND
           actCreSCN > inpCreSCN)                          OR
          (rcvRecCursor.currc1.dfNumber_obj = fno AND
           actCreSCN = inpCreSCN)) THEN
--
--
         EXIT;
      END IF;
      IF (debug) THEN
         deb(DEB_IN, 'skipped following record: summary');
         printRcvRec(rcvRecCursor.currc1, TRUE);
      END IF;
   END LOOP;
 
<<seekCurrent>>
   IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
      actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
   ELSE
      actCreScN := rcvRecCursor.currc1.dfCreationSCN_obj;
   END IF;
 
   IF (rcvRecCursor.currc1.type_con is null         OR
       rcvRecCursor.currc1.dfNumber_obj > fno       OR
       (rcvRecCursor.currc1.dfNumber_obj = fno AND
        actCreSCN > inpCreSCN)) THEN
      deb(DEB_EXIT, 'seekCurrent - beyond current fno, creSCN');
      RETURN;
   END IF;
 
   IF (rcvRecCursor.currc1.dfNumber_obj != fno OR
       actCreSCN != inpCreSCN) THEN
      raise_application_error(-20999, 'fetchCursor1RecoveryAction ' ||
               'dfNumber_obj=' || to_char(rcvRecCursor.currc1.dfNumber_obj) ||
               ' dfCreationSCN_obj=' || to_char(actCreSCN));
   END IF;
 
--
--
   IF (rmanCmd = blkRestoreCmd_t) THEN
      IF (rcvRecCursor.currc1.toSCN_act > targetSCN) THEN
         deb(DEB_IN, 'a. simple filter rejected - trying next');
         goto seekNext;
      END IF;
   ELSE
      IF (rcvRecCursor.currc1.toSCN_act < dfCkpSCN AND
          rcvRecCursor.currc1.fromSCN_act < dfCkpSCN) THEN
         deb(DEB_IN, 'b. simple filter rejected - trying next');
         goto seekNext;
      END IF;
   END IF;
 
--
   OPEN rcvRecCursor1Filter_c( dbincKey        => dbincKey
                              ,fno             => fno
                              ,creSCN          => creSCN
                              ,dfCkpSCN        => dfCkpSCN
                              ,dbincRlgSCN     => dbincRlgSCN
                              ,dbincRlgTime    => dbincRlgTime
                              ,offlSCN         => offlSCN
                              ,onlSCN          => onlSCN
                              ,onlTime         => onlTime
                              ,cleanSCN        => cleanSCN
                              ,clean2SCN       => clean2SCN
                              ,clean2Time      => clean2Time
                              ,targetSCN       => targetSCN
                              ,c1rec           => rcvRecCursor.currc1
                              ,foreignDbid     => foreignDbid
                              ,pluggedRonly    => pluggedRonly
                              ,pluginSCN       => pluginSCN
                              ,pluginRlgSCN    => pluginRlgSCN
                              ,pluginRlgTime   => pluginRlgTime
                              ,rmanCmd         => rmanCmd);
    FETCH rcvRecCursor1Filter_c INTO action;
    IF (rcvRecCursor1Filter_c%NOTFOUND) THEN
--
       CLOSE rcvRecCursor1Filter_c;
       deb(DEB_IN, 'real filter rejected - trying next');
       goto seekNext;
    END IF;
    CLOSE rcvRecCursor1Filter_c;
    deb(DEB_EXIT, 'filter accepted');
END fetchCursor1RecoveryAction;
 
--
FUNCTION fetchRecoveryAction(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,action        IN OUT NOCOPY rcvRec_t
  ,rmanCmd       IN     binary_integer
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer  -- 1 => readonly, 0 => readwrite
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date)
RETURN boolean IS
   top             rcvRec_t;
   c1frec          rcvRec_t;       -- filtered cursor1 record
   actCreSCN       number;
   inpCreSCN       number;
   actRlgSCN       number;
   topRlgSCN       number;
BEGIN
   deb(DEB_ENTER, 'fetchRecoveryAction');
 
   IF (pluginSCN != 0) THEN
      inpCreSCN := pluginSCN;
   ELSE
      inpCreSCN := creSCN;
   END IF;
 
   <<retry>>
   IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
      actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
   ELSE
      actCreSCN := rcvRecCursor.currc1.dfCreationSCN_obj;
   END IF;
 
   IF (rcvRecCursor.currc1.type_con is null          OR
       rcvRecCursor.currc1.dfNumber_obj != fno       OR
       actCreSCN != inpCreSCN) THEN
      c1frec.type_con := to_number(null);
   ELSE
      c1frec := rcvRecCursor.currc1;
   END IF;
 
   OPEN rcvRecCursor2_c( dbincKey        => dbincKey
                        ,fno             => fno
                        ,creSCN          => creSCN
                        ,dfCkpSCN        => dfCkpSCN
                        ,dbincRlgSCN     => dbincRlgSCN
                        ,dbincRlgTime    => dbincRlgTime
                        ,offlSCN         => offlSCN
                        ,onlSCN          => onlSCN
                        ,onlTime         => onlTime
                        ,cleanSCN        => cleanSCN
                        ,clean2SCN       => clean2SCN
                        ,clean2Time      => clean2Time
                        ,targetSCN       => targetSCN
                        ,c1frec          => c1frec
                        ,excludeAction   => rcvRecCursor.excludeAction
                        ,foreignDbid     => foreignDbid
                        ,pluggedRonly    => pluggedRonly
                        ,pluginSCN       => pluginSCN
                        ,pluginRlgSCN    => pluginRlgSCN
                        ,pluginRlgTime   => pluginRlgTime);
 
   FETCH rcvRecCursor2_c INTO action;
 
   IF (rcvRecCursor2_c%NOTFOUND) THEN
      action.type_con := NULL;
      action.type_act := NULL;
      CLOSE rcvRecCursor2_c;
      deb(DEB_EXIT, 'no_data_found with: FALSE');
      RETURN FALSE;
   END IF;
 
   IF (action.type_act = spanningRange_act_t  OR
       action.type_act = cleanRange_act_t     OR
       action.type_act = implicitRange_act_t)  THEN
--
      rcvRecCursor.excludeAction :=
                              rcvRecCursor.excludeAction + action.type_act;
   ELSE
--
      fetchCursor1RecoveryAction(
         dbincKey      => dbincKey
        ,fno           => fno
        ,creSCN        => creSCN
        ,dfCkpSCN      => dfCkpSCN
        ,dbincRlgSCN   => dbincRlgSCN
        ,dbincRlgTime  => dbincRlgTime
        ,offlSCN       => offlSCN
        ,onlSCN        => onlSCN
        ,onlTime       => onlTime
        ,cleanSCN      => cleanSCN
        ,clean2SCN     => clean2SCN
        ,clean2Time    => clean2Time
        ,targetSCN     => targetSCN
        ,opcode        => 1
        ,foreignDbid   => foreignDbid
        ,pluggedRonly  => pluggedRonly
        ,pluginSCN     => pluginSCN
        ,pluginRlgSCN  => pluginRlgSCN
        ,pluginRlgTime => pluginRlgTime
        ,rmanCmd       => rmanCmd);
   END IF;
 
   IF (action.compTime_con IS NULL AND          -- was null in 8.0.2
       action.type_con = backupSet_con_t) THEN
      action.compTime_con := stamp2date(action.bsStamp_con);
   END IF;
 
   IF (rmanCmd = obsoleteCmd_t AND action.type_act = incremental_act_t) THEN
      deb(DEB_PRINT, 'fetchRecoveryAction: incr backup set for obsolete cmd');
   ELSE
      IF (computeRA_allRecords = TRUE#) THEN
         CLOSE rcvRecCursor2_c;
         deb(DEB_EXIT, 'with TRUE');
         RETURN TRUE;
      END IF;
 
      IF (computeRA_fullBackups > 1) THEN
         CLOSE rcvRecCursor2_c;
         deb(DEB_EXIT, 'with TRUE');
         RETURN TRUE;
      END IF;
   END IF;
 
--
--
--
--
--
   IF (rcvRecStack.count > 0) THEN
      rcvRecTop(top);
      IF (action.pluginSCN_obj != 0) THEN
         actRlgSCN := action.pluginRlgSCN_obj;
      ELSE
         actRlgSCN := action.rlgSCN_act;
      END IF;
      IF (top.pluginSCN_obj != 0) THEN
         topRlgSCN := top.pluginRlgSCN_obj;
      ELSE
         topRlgSCN := top.rlgSCN_act;
      END IF;
      IF (not (action.fromSCN_act < top.fromSCN_act) AND
          actrlgSCN = toprlgSCN) THEN
         IF (debug) THEN
            deb(DEB_IN, 'discarding this action:');
            printRcvRec(action);
         END IF;
         CLOSE rcvRecCursor2_c;
         GOTO retry;
      END IF;
   END IF;
 
   CLOSE rcvRecCursor2_c;
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE;
END fetchRecoveryAction;
 
--
PROCEDURE openRecoveryActionCursor(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,rmanCmd       IN     binary_integer
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date)
IS
  openCursor1   boolean := FALSE;     -- TRUE if cursor1 is to be opened
  opcode        binary_integer := 0;  -- seekNext or seekCurrent
  reqCreSCN     number;
  inpCreSCN     number;
  actCreSCN     number;
BEGIN
   deb(DEB_ENTER, 'openRecoveryActionCursor');
 
   IF (pluginSCN != 0) THEN
      inpCreSCN := pluginSCN;
   ELSE
      inpCreSCN := creSCN;
   END IF;
 
   deb(DEB_IN,'target scn is ' ||
       nvl(to_char(targetSCN), 'NULL') || ',creSCN=' || creSCN ||
       ',dfCkpSCN=' || dfCkpSCN || ',dbincRlgSCN=' || dbincRlgSCN ||
       ',offlSCN=' || offlSCN || ',onlSCN=' || onlSCN ||
       ',cleanSCN=' || cleanSCN || ',clean2SCN=' || clean2SCN ||
       ',fno=' || fno || ',pluginSCN=' || pluginSCN ||
       ',rmanCmd=' || rmanCmd);
 
   deb(DEB_IN, 'currc1.type_con=' ||
               nvl(to_char(rcvRecCursor.currc1.type_con),'NULL') ||
               ' currc1.fno=' ||
               nvl(to_char(rcvRecCursor.currc1.dfNumber_obj), 'NULL') ||
               ' currc1.crescn=' ||
               nvl(to_char(rcvRecCursor.currc1.dfCreationSCN_obj), 'NULL'));
 
   deb(DEB_IN, 'restoreSource=' || restoreSource ||
               ', restoreSparse='|| restoreSparse);
 
   IF (rcvRecCursor1_c%ISOPEN) THEN
      deb(DEB_IN, 'cursor1 already open');
      IF (tc_database = TRUE# OR isTranslatedFno(fno) = TRUE#) THEN
         deb(DEB_IN,'cursor1 translated');
         IF (rcvRecCursor.reqpluginSCN != 0) THEN
            reqCreSCN := rcvRecCursor.reqpluginSCN;
         ELSE
            reqCreSCN := rcvRecCursor.reqcrescn;
         END IF;
         IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
            actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
         ELSE
            actCreSCN := rcvRecCursor.currc1.dfCreationSCN_obj;
         END IF;
         IF ((rcvRecCursor.reqfno = fno AND reqCreSCN >= inpCreSCN) OR
             (rcvRecCursor.reqfno > fno)) THEN
--
--
            deb(DEB_IN, 'cursor1 unusable');
            openCursor1 := TRUE;
         ELSIF (rcvRecCursor.currc1.type_con is null    OR
                rcvRecCursor.currc1.dfNumber_obj < fno  OR
                (rcvRecCursor.currc1.dfNumber_obj = fno AND
                 actCreSCN < inpCreSCN)) THEN
               deb(DEB_IN,'reusing cursor1 after seek');
               opcode := 1; -- seekNext
         ELSIF (rcvRecCursor.currc1.dfNumber_obj = fno AND
                actCreSCN = inpCreSCN) THEN
            deb(DEB_IN,'reusing cursor1 with no seek');
            opcode := 2; -- seekCurrent
         ELSE
            deb(DEB_IN,'do nothing to cursor1');
         END IF;
      ELSE
         deb(DEB_IN,'cursor1 did not translate');
         openCursor1 := TRUE;
      END IF;
   ELSE
      deb(DEB_IN,'cursor1 not open yet');
      openCursor1 := TRUE;
   END IF;
 
   IF (openCursor1) THEN
      IF (rcvRecCursor1_c%ISOPEN) THEN
         CLOSE rcvRecCursor1_c;
      END IF;
 
      setDfTransClause(fno => fno);
      rcvRecCursor.currc1.type_con := to_number(null);
      deb(DEB_OPEN, 'rcvRecCursor1_c');
      OPEN rcvRecCursor1_c(rmanCmd => rmanCmd);
      opcode := 1;  -- seekNext
   END IF;
 
--
   IF (opcode != 0) THEN
      fetchCursor1RecoveryAction(
         dbincKey      => dbincKey
        ,fno           => fno
        ,creSCN        => creSCN
        ,dfCkpSCN      => dfCkpSCN
        ,dbincRlgSCN   => dbincRlgSCN
        ,dbincRlgTime  => dbincRlgTime
        ,offlSCN       => offlSCN
        ,onlSCN        => onlSCN
        ,onlTime       => onlTime
        ,cleanSCN      => cleanSCN
        ,clean2SCN     => clean2SCN
        ,clean2Time    => clean2Time
        ,targetSCN     => targetSCN
        ,opcode        => opcode
        ,foreignDbid   => foreignDbid
        ,pluggedRonly  => pluggedRonly
        ,pluginSCN     => pluginSCN
        ,pluginRlgSCN  => pluginRlgSCN
        ,pluginRlgTime => pluginRlgTime
        ,rmanCmd       => rmanCmd);
   END IF;
 
--
   rcvRecCursor.excludeAction := 0;
 
--
   rcvRecCursor.reqfno := fno;
   rcvRecCursor.reqcrescn := creSCN;
   rcvRecCursor.reqpluginSCN := pluginSCN;
 
--
   IF (rcvRecCursor1Filter_c%ISOPEN) THEN
      CLOSE rcvRecCursor1Filter_c;
   END IF;
 
   IF (rcvRecCursor2_c%ISOPEN) THEN
      CLOSE rcvRecCursor2_c;
   END IF;
 
   deb(DEB_EXIT);
END openRecoveryActionCursor;
 
--
 
FUNCTION trimRecoveryActions(
   maxActions           IN number
  ,containerMask        IN number
  ,actionMask           IN number)
RETURN NUMBER IS
   dummy     rcvRec_t;
   remaining number;
BEGIN
 
   deb(DEB_ENTER,'trimRecoveryActions[function](maxactions='||maxActions||')');
   IF (rcvRecStack.count > 0) THEN
      rcvRecPop(dummy);
      remaining := trimRecoveryActions(maxActions, containerMask, actionMask);
 
--
--
--
--
--
--
      IF ((bitand(dummy.type_con, containerMask) = 0) OR
           (bitand(dummy.type_act, actionMask) = 0)) THEN
--
--
         rcvRecPush(dummy);
         deb(DEB_EXIT, 'with: '||to_char(remaining));
         RETURN remaining;
      ELSE
         IF (remaining < maxActions) THEN
            rcvRecPush(dummy);          -- put back on stack
            deb(DEB_EXIT, 'with: '||to_char(remaining+1));
            RETURN remaining + 1;
         ELSE
--
            IF (debug) THEN
               deb(DEB_IN, 'deleting action:');
               printRcvRec(dummy);
               deb(DEB_EXIT, 'with: '||to_char(remaining));
            END IF;
 
            RETURN remaining;
         END IF;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with: 0');
      RETURN 0;
   END IF;
END trimRecoveryActions;
 
--
PROCEDURE setCraGetAllCfBackups(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'craGetAllCfBackups is set to TRUE');
      craGetAllCfBackups := TRUE#;
   ELSE
      deb(DEB_PRINT, 'craGetAllCfBackups is set to FALSE');
      craGetAllCfBackups := FALSE#;
   END IF;
END setCraGetAllCfBackups;
 
--
--
FUNCTION isTranslatedArchivedLog(
   thread#   IN  number
  ,sequence# IN  number) RETURN BOOLEAN
IS
  thrbck   binary_integer;
  seqbck   binary_integer;
BEGIN
--
   IF (thread# >= CONST2GVAL) THEN
      thrbck := CONST2GVAL - thread#;
   ELSE
      thrbck := thread#;
   END IF;
 
--
   IF (sequence# >= CONST2GVAL) THEN
      seqbck := CONST2GVAL - sequence#;
   ELSE
      seqbck := sequence#;
   END IF;
 
   IF NOT tc_threadSeq.exists(thrbck) THEN
      RETURN FALSE;
   ELSIF NOT tc_threadSeq(thrbck).exists(seqbck) THEN
      RETURN FALSE;
   ELSE
      RETURN TRUE;
   END IF;
END isTranslatedArchivedLog;
 
--
FUNCTION getRangeArchivedLogBackup(
   rcvRec  OUT NOCOPY rcvRec_t)
RETURN binary_integer IS
   local        rcvRec_t;
   BSstatus     number;
BEGIN
   deb(DEB_ENTER, 'getRangeArchivedLogBackup');
 
   IF (getRecStackCount = 0) THEN
--
--
      deb(DEB_EXIT, 'with: UNAVAILABLE');
      RETURN UNAVAILABLE;
   END IF;
 
   rcvRecPop(local);
--
--
   IF (local.status_con = '*') THEN
      local.status_con := 'A';
      BSstatus := AVAILABLE;
   ELSE
      BSstatus := SUCCESS;
   END IF;
 
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   IF (BSstatus = AVAILABLE) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
      RETURN AVAILABLE;
   ELSE
      deb(DEB_EXIT, 'with: SUCCESS');
      RETURN SUCCESS;
   END IF;
END getRangeArchivedLogBackup;
 
--
--
FUNCTION startWithPattern(
   toDest IN varchar2) RETURN VARCHAR2
IS
BEGIN
   IF (toDest IS NULL) THEN
      RETURN NULL;
   END IF;
 
   RETURN toDest || '%';
END startWithPattern;
 
 
--
--
PROCEDURE extendKeepSCN(lbDfRec    IN OUT NOCOPY lbDfRec_t,
                        toSCN      IN            number,
                        rlgSCN     IN            number,
                        extendMask IN            binary_integer,
                        force      IN            boolean,
                        dbgcomment IN            varchar2)
IS
BEGIN
   IF (bitand(extendMask, extendFullSCN) != 0) THEN
      IF (force OR toSCN < lbDfRec.fullmin_scn) THEN
         lbDfRec.fullmin_scn    := toSCN;
         lbDfRec.fullmin_rlgscn := rlgSCN;
         IF (debug) THEN
            deb(DEB_PRINT, dbgcomment || ': Extending fullmin_scn to '    ||
                to_char(toSCN));
            deb(DEB_PRINT, dbgcomment || ': Extending fullmin_rlgscn to ' ||
                nvl(to_char(rlgSCN), 'null'));
         END IF;
      END IF;
   END IF;
 
   IF (bitand(extendMask, extendIncrSCN) != 0) THEN
      IF (force OR toSCN < lbDfRec.incrmin_scn) THEN
         lbDfRec.incrmin_scn    := toSCN;
         lbDfRec.incrmin_rlgscn := rlgSCN;
         IF (debug) THEN
            deb(DEB_PRINT, dbgcomment || ': Extending incrmin_scn to '    || 
                to_char(toSCN));
            deb(DEB_PRINT, dbgcomment || ': Extending incrmin_rlgscn to ' || 
                nvl(to_char(rlgSCN), 'null'));
         END IF;
      END IF;
   END IF;
 
   IF (bitand(extendMask, extendLogSCN) != 0) THEN
      IF (force OR toSCN < lbDfRec.logmin_scn) THEN
         lbDfRec.logmin_scn    := toSCN;
         lbDfRec.logmin_rlgscn := rlgSCN;
         IF (debug) THEN
            deb(DEB_PRINT, dbgcomment || ': Extending logmin_scn to '    || 
                to_char(toSCN));
            deb(DEB_PRINT, dbgcomment || ': Extending logmin_rlgscn to ' || 
                nvl(to_char(rlgSCN), 'null'));
         END IF;
      END IF;
   END IF;
END extendKeepSCN;
 
--
PROCEDURE resetPdbNameList IS
BEGIN
   pdbNameList.delete;
END resetPdbNameList;
 
--
PROCEDURE initPdbNameList IS
   local    pdbNameRec_t;
BEGIN
   IF (pdbNameList.count != 0) THEN
      RETURN;
   END IF;
 
   IF (translatePdbName_c%ISOPEN) THEN
      raise_application_error(-20203, 'Translation already started');
   END IF;
 
   resetPdbNameList;
   OPEN translatePdbName_c;
 
<<nextRow>>
   FETCH translatePdbName_c INTO local;
   IF translatePdbName_c%NOTFOUND THEN
      CLOSE translatePdbName_c;
   ELSE
      pdbNameList(local.name) := local.pdbId;
      goto nextRow;
   END IF;
 
   pdbNameList(cdbRoot_txt) := 1;
END initPdbNameList;
 
--
PROCEDURE resetPdbFileList IS
BEGIN
   pdbFileList.delete;
END resetPdbFileList;
 
--
PROCEDURE initPdbFileList IS
   local    pdbFileRec_t;
BEGIN
   IF (pdbFileList.count != 0) THEN
      RETURN;
   END IF;
 
   IF (translatePdbFile_c%ISOPEN) THEN
      raise_application_error(-20203, 'Translation already started');
   END IF;
 
   deb(DEB_PRINT, 'initPdbFileList');
   resetPdbFileList;
   OPEN translatePdbFile_c(
          fromSCN => nvl(untilSCN, MAXSCNVAL),
          toSCN   => nvl(untilSCN, MAXSCNVAL));
 
<<nextRow>>
   FETCH translatePdbFile_c INTO local;
   IF translatePdbFile_c%NOTFOUND THEN
      CLOSE translatePdbFile_c;
   ELSE
      pdbFileList(local.file#) := local;
      goto nextRow;
   END IF;
 
   local.file#    := 0;
   local.pdbId    := 0;
   local.stopSCN  := null;
   pdbFileList(0) := local;
END initPdbFileList;
 
--
FUNCTION translatePdbFile(
   file#    IN  NUMBER
  ,cleanSCN OUT NUMBER)
RETURN NUMBER IS
   local  pdbFileRec_t;
BEGIN
   initPdbFileList;
 
   IF (pdbFileList.exists(file#)) THEN
      local    := pdbFileList(file#);
      cleanSCN := local.stopSCN;
   ELSE
      deb(DEB_PRINT, 'translatePdbFile could not find file# ' || file#);
      IF (NOT pdbFileList.exists(1)) THEN
         raise_application_error(-20999, 'internal error: translatePdbFile');
      END IF;
      local    := pdbFileList(1);
      cleanSCN := NULL;
   END IF;
   RETURN local.pdbId;
END translatePdbFile;
 
--
 
--
PROCEDURE resetBsRecCache(
   reload  IN boolean)
IS
BEGIN
   BEGIN
      deb(DEB_PRINT, '*****BsRecCache Statistics*****');
      deb(DEB_PRINT, 'Cache size=' || to_char(cacheBsRecTable.bsRec.count) ||
                      ' hit=' || to_char(cacheBsRecTable.chit));
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_PRINT, 'No statistics available');
   END;
 
   cacheBsRecTable.bsRec.delete;
   IF (NOT reload) THEN
      cacheBsRecTable.hitlist.delete;
      cacheBsRecTable.hitindex := 1;
      cacheBsRecTable.hint := noHint;
   END IF;
   cacheBSRecTable.chit := 0;
   cacheBsRecTable.mixcopy := FALSE;
   cacheBsRecTable.minbskey := 0;
END resetBsRecCache;
 
--
FUNCTION setCachedDeviceType(
   type IN varchar2)
RETURN binary_integer IS
BEGIN
   FOR i IN 1..cacheBsRecTable.devicecount LOOP
      IF cacheBsRecTable.devicelist(i) = type THEN
         RETURN i;
      END IF;
   END LOOP;
   cacheBsRecTable.devicecount := cacheBsRecTable.devicecount + 1;
   cacheBsRecTable.devicelist(cacheBsRecTable.devicecount) := type;
   RETURN cacheBsRecTable.devicecount;
END setCachedDeviceType;
 
 
--
PROCEDURE lkBsRecCache(
   bskey           IN    number
  ,icopy           IN    binary_integer
  ,bsrec           OUT   NOCOPY cacheBsRecRow_t)
IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   BEGIN
      FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
         IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
            bsrec := cacheBsRecTable.bsRec(sb4_bucket).bslist(i).copy(icopy);
            RETURN;
         END IF;
      END LOOP;
   EXCEPTION
      WHEN no_data_found THEN
         NULL;
   END;
 
   RAISE no_data_found;
END lkBsRecCache;
 
--
FUNCTION addKeyToBsRecCache(
   bskey           IN number)
RETURN BOOLEAN IS
   bsk             cacheBsRecBsKey_t;
   bslist          cacheBsRecHash_t;
   bucket          number;
   sb4_bucket      binary_integer;
   bsindex         binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
--
   IF (cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
         IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
            RETURN FALSE;
         END IF;
      END LOOP;
      bsindex := cacheBsRecTable.bsRec(sb4_bucket).bsindex;
   ELSE
      cacheBsRecTable.bsRec(sb4_bucket) := bsk;
      bsindex := cacheBsRecTable.bsRec(sb4_bucket).bsindex;
      cacheBsRecTable.bsRec(sb4_bucket).bslist(bsindex) := bslist;
   END IF;
 
--
   cacheBsRecTable.bsRec(sb4_bucket).bslist(bsindex).bskey := bskey;
   cacheBsRecTable.bsRec(sb4_bucket).bsindex := bsindex + 1;
   RETURN TRUE;
END addKeyToBsRecCache;
 
--
PROCEDURE addToBsRecCache(
   bskey           IN number
  ,icopy           IN binary_integer
  ,deviceindx      IN binary_integer
  ,tag             IN varchar2
  ,copyNumber      IN binary_integer
  ,code            IN binary_integer)
IS
   bsrec           cacheBsRecRow_t;
   bucket          number;
   sb4_bucket      binary_integer;
   bsindex         binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   bsrec.deviceindx := deviceindx;
   bsrec.tag := tag;
   bsrec.copyNumber := copyNumber;
   bsrec.code := code;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      raise_application_error(-20999, 'internal error: addToBsRecCache1');
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
         cacheBsRecTable.bsRec(sb4_bucket).bslist(i).copy(icopy) := bsrec;
         RETURN;
      END IF;
   END LOOP;
 
--
   raise_application_error(-20999, 'internal error: addToBsRecCache2');
END addToBsRecCache;
 
--
FUNCTION hitBsRecCache(
   bskey       IN   number
  ,deviceType  IN   varchar2
  ,tag         IN   varchar2
  ,mask        IN   binary_integer)
RETURN BOOLEAN IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
--
   IF (deviceType != cacheBsRecTable.deviceType AND
       (deviceType IS NOT NULL OR
        cacheBsRecTable.deviceType IS NOT NULL)) THEN
      RETURN FALSE;
   END IF;
 
--
   IF (nvl(tag, '  ') != nvl(cacheBsRecTable.tag, nvl(tag, '  '))) THEN
      RETURN FALSE;
   END IF;
 
--
   IF (mask != cacheBsRecTable.mask) THEN
      RETURN FALSE;
   END IF;
 
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      IF (bskey < cacheBsRecTable.minbskey) THEN
--
--
--
--
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
          cacheBsRecTable.chit := cacheBsRecTable.chit + 1;
--
         IF (cacheBsRecTable.hitindex > bsRecCacheLowLimit * 0.25) THEN
             cacheBsRecTable.hitindex := 1;
         END IF;
 
--
         cacheBsRecTable.hitlist(cacheBsRecTable.hitindex) := bskey;
         cacheBsRecTable.hitindex := cacheBsRecTable.hitindex + 1;
         RETURN TRUE;
      END IF;
   END LOOP;
 
   RETURN FALSE;
END hitBsRecCache;
 
--
FUNCTION canMixCopy(
   bskey IN   number)
RETURN BOOLEAN IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      raise_application_error(-20999, 'internal error: canMixCopy1');
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
         RETURN cacheBsRecTable.bsRec(sb4_bucket).bslist(i).mixCopy;
      END IF;
   END LOOP;
 
   raise_application_error(-20999, 'internal error: canMixCopy2');
END canMixCopy;
 
--
PROCEDURE loadBsRecCache(
   from_bsRec  IN   rcvRec_t
  ,deviceType  IN   varchar2 DEFAULT NULL
  ,tag         IN   varchar2 DEFAULT NULL
  ,mask        IN   binary_integer
  ,mixcopy     IN   number)
IS
--
--
--
--
--
--
 
--
--
 
--
--
--
--
--
--
--
 
   CURSOR loadBsRecCache_c IS
      SELECT bs.bs_key                             bskey,
             bp.device_type                        deviceType,
             bp.tag                                tag,
             bp.copy#                              copyNumber,
             1                                     code,
             decode(bp.ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0))
                                                   order1,
             bs.pieces                             pieces
        FROM bp, bs
      WHERE loadBsRecCache.mixcopy = FALSE#
        AND bs.db_key = this_db_key
        AND bp.db_key = this_db_key
        AND bp.status != 'D'
        AND bp.bs_key = bs.bs_key
        AND isBsRecCacheMatch(bs.bs_key, bp.device_type, bp.tag,
                              bp.status) = TRUE#  -- See NOTE
        AND ((user_site_key = bp.site_key) OR
             (user_site_key IS NULL AND
              ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
               (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
               (this_site_key = nvl(bp.site_key, this_site_key)))))
    GROUP BY bs.bs_key, bs.pieces, bp.device_type, bp.tag, bp.copy#,
             bp.ba_access, bp.vb_key
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = bs.pieces) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= bs.pieces))
 
    UNION ALL
 
--
--
--
 
      SELECT bs.bs_key                             bskey,
             bp.device_type                        deviceType,
             bp.tag                                tag,
             to_number(null)                       copyNumber,
             2                                     code,
             0                                     order1,
             bs.pieces                             pieces
       FROM bp, bs
      WHERE loadBsRecCache.mixcopy = TRUE#
        AND bs.db_key = this_db_key
        AND bp.db_key = this_db_key
        AND bp.status != 'D'
        AND bp.bs_key = bs.bs_key
        AND isBsRecCacheMatch(bs.bs_key, bp.device_type, bp.tag,
                              bp.status) = TRUE#  -- See NOTE
        AND ((user_site_key = bp.site_key) OR
             (user_site_key IS NULL AND
              ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
               (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
               (this_site_key = nvl(bp.site_key, this_site_key)))))
    GROUP BY bs.bs_key, bs.pieces, bp.device_type, bp.tag
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = bs.pieces) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= bs.pieces))
 
    UNION ALL
 
--
--
--
 
      SELECT bs.bs_key                             bskey,
             bp.device_type                        deviceType,
             to_char(null)                         tag,
             to_number(null)                       copyNumber,
             3                                     code,
             0                                     order1,
             bs.pieces                             pieces
       FROM bp, bs
      WHERE loadBsRecCache.mixcopy = TRUE#
        AND bs.db_key = this_db_key
        AND bp.db_key = this_db_key
        AND bp.status != 'D'
        AND bp.bs_key = bs.bs_key
        AND isBsRecCacheMatch(bs.bs_key, bp.device_type, bp.tag,
                              bp.status) = TRUE#  -- See NOTE
        AND ((user_site_key = bp.site_key) OR
             (user_site_key IS NULL AND
              ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
               (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
               (this_site_key = nvl(bp.site_key, this_site_key)))))
    GROUP BY bs.bs_key, bs.pieces, bp.device_type, bp.ba_access, bp.vb_key
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = bs.pieces) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= bs.pieces))
 
   ORDER BY 1,       -- bskey
            5,       -- code
            6;       -- order1
 
   CURSOR loadRedundDf_c IS
      SELECT bs_key
        FROM (SELECT bs_key, file#
                FROM bdf, dbinc
               WHERE dbinc.db_key = this_db_key
                 AND dbinc.dbinc_key = bdf.dbinc_key
                 AND file# >= nvl(from_bsRec.dfNumber_obj, 0)
              UNION ALL
              SELECT bs_key, 0 file#
                FROM bcf, dbinc
               WHERE dbinc.db_key = this_db_key
                 AND dbinc.dbinc_key = bcf.dbinc_key
                 AND nvl(from_bsRec.dfNumber_obj, 0) = 0
              UNION ALL
              SELECT bs_key, -1 file#
                FROM bsf
               WHERE from_bsRec.dfNumber_obj IS NULL
                 AND from_bsRec.fromSCN_act = 0
                 AND bsf.db_key = this_db_key)
       GROUP BY bs_key 
       ORDER BY min(file#),
                abs(bs_key - from_bsRec.bsKey_con);
 
   CURSOR loadRedundAl_c IS
      SELECT bs_key
        FROM (SELECT bs_key, thread#, sequence#
                FROM brl, dbinc
               WHERE dbinc.db_key = this_db_key
                 AND dbinc.dbinc_key = brl.dbinc_key
                 AND low_scn >= from_bsRec.logLowSCN_obj
                 AND ((thread# = from_bsRec.logThread_obj AND
                       sequence# >= from_bsRec.logSequence_obj) OR
                      (thread# > from_bsRec.logThread_obj)))
       GROUP BY bs_key 
       ORDER BY min(thread#),
                min(sequence#),
                abs(bs_key - from_bsRec.bsKey_con);
 
   CURSOR loadLocality_c(minbskey   IN number,
                         backupType IN varchar2) IS
      SELECT bs_key bskey
        FROM bs
       WHERE bs.db_key = this_db_key
         AND bs.bs_key >= loadLocality_c.minbskey
         AND (loadLocality_c.backupType IS NULL OR
              decode(bs.bck_type, 'L', 'L', 'D')=loadLocality_c.backupType)
      ORDER BY abs(bs_key - from_bsRec.bsKey_con);
 
   icopy            binary_integer := 0;
   bsrec            cacheBsRec_t;
   bsrow            cacheBsRecRow_t;
   prev_bskey       number := 0;
   low_bskey        number;
   deviceindx       binary_integer;
   addperset        binary_integer;     -- no: entries added to cache per set
   bslist           numTab_t;
   addstatus        boolean;
   freec            number;
   backupType       varchar2(1);
BEGIN
   deb(DEB_ENTER, 'loadBsRecCache');
   deb(DEB_IN, 'mixcopy=' || to_char(mixcopy));
 
--
   IF (NOT cacheBsRecTable.initlimit AND this_db_key IS NOT NULL) THEN
--
      SELECT count(*) INTO cacheBsRecTable.limit
        FROM bs, dbinc
       WHERE dbinc.db_key  = this_db_key    -- belongs to this database
         AND dbinc.db_key  = bs.db_key;     -- join bs and dbinc
 
      IF (cacheBsRecTable.limit > bsRecCacheHighLimit) THEN
         cacheBsRecTable.limit := bsRecCacheHighLimit;
      ELSIF (cacheBsRecTable.limit < bsRecCacheLowLimit) THEN
         cacheBsRecTable.limit := bsRecCacheLowLimit;
      END IF;
      cacheBsRecTable.initlimit := TRUE;
   END IF;
 
   IF (mixcopy = FALSE#) THEN
--
      resetBsRecCache(TRUE);
 
      cacheBsRecTable.bsRec := bsrec;
 
--
      cacheBsRecTable.tag := tag;
      cacheBsRecTable.deviceType := deviceType;
      cacheBsRecTable.mask := mask;
   ELSIF (cacheBsRecTable.mixcopy) THEN
      deb(DEB_EXIT, 'loadBsRecCache already loaded with mixcopy');
      RETURN;
   ELSE
      cacheBsRecTable.mixcopy := TRUE;
      FOR rec in loadBsRecCache_c LOOP
         deviceindx :=  setCachedDeviceType(rec.deviceType);
--
--
--
--
--
         <<mixCopyLoop>>
         FOR i in 1..255 LOOP
            BEGIN
               lkBsRecCache(bskey    => rec.bskey,
                            icopy    => i,
                            bsrec    => bsrow);
               EXIT mixCopyLoop WHEN (bsrow.deviceindx = deviceindx AND
                                      bsrow.code < rec.code);
            EXCEPTION
               WHEN no_data_found THEN
                  addToBsRecCache(bskey      => rec.bskey,
                                  icopy      => i,
                                  deviceindx => deviceindx,
                                  tag        => rec.tag,
                                  copyNumber => rec.copyNumber,
                                  code       => rec.code);
                  EXIT mixCopyLoop;
            END;
         END LOOP;
      END LOOP;
      deb(DEB_EXIT, 'loadBsRecCache loaded with mixcopy');
      RETURN;
   END IF;
 
--
   addstatus := addKeyToBsRecCache(bskey => from_bsRec.bsKey_con);
 
--
--
   IF (cacheBsRecTable.hint = redundantHint) THEN
      freec := cacheBsRecTable.limit;           -- only redundant
   ELSIF (cacheBsRecTable.hint = localityHint) THEN
      freec := 0;                               -- only locality
   ELSE
      freec := floor(cacheBsRecTable.limit/2);  -- redundant + locality
   END IF;
 
--
   IF (freec != 0) THEN
      IF (from_bsRec.dfNumber_obj IS NOT NULL OR
          from_bsRec.fromSCN_act = 0) THEN
         deb(DEB_IN, 'loadRedundDf_c');
         OPEN loadRedundDf_c;
         FETCH loadRedundDf_c BULK COLLECT
          INTO bslist LIMIT freec;
         CLOSE loadRedundDf_c;
      ELSIF (from_bsRec.logLowSCN_obj IS NOT NULL) THEN
         deb(DEB_IN, 'loadRedundAl_c');
         OPEN loadRedundAl_c;
         FETCH loadRedundAl_c BULK COLLECT
          INTO bslist LIMIT freec;
         CLOSE loadRedundAl_c; 
      END IF;
 
--
      FOR i in 1..bslist.count LOOP
         addstatus := addKeyToBsRecCache(bslist(i));
      END LOOP;
   END IF;
 
   freec := cacheBsRecTable.limit - bslist.count;
   bslist.delete;     -- free memory
 
--
   FOR i in 1..cacheBsRecTable.hitlist.count LOOP
      IF (addKeyToBsRecCache(cacheBsRecTable.hitlist(i))) THEN
         freec := freec - 1;
      END IF;
      EXIT WHEN (freec <= 0);
   END LOOP;
 
   IF (cacheBsRecTable.minbskey = 0) THEN
      BEGIN
         SELECT nvl(min(bp.bs_key), 0)
           INTO cacheBsRecTable.minbskey
           FROM bp
          WHERE bp.db_key = this_db_key
            AND bp.status != 'D'
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
            AND ((mask = BSavailable AND bp.status = 'A') OR
                 isStatusMatch(bp.status, mask) = TRUE#);
      EXCEPTION
          WHEN no_data_found THEN
             cacheBsRecTable.minbskey := 0;
      END;
   END IF;
 
--
--
   IF (freec > 0) THEN
      backupType := to_char(null);
      IF (cacheBsRecTable.hint = redundantHint) THEN
--
         BEGIN
            SELECT decode(bck_type, 'L', 'L', 'D')
              INTO backupType
              FROM bs
             WHERE bs_key = from_bsRec.bsKey_con;
         EXCEPTION
            WHEN no_data_found THEN
               backupType := 'D';
         END;
      END IF;
 
--
      OPEN loadLocality_c(cacheBsRecTable.minbskey, backupType);
      LOOP
         FETCH loadLocality_c BULK COLLECT
          INTO bslist LIMIT freec;
         FOR i in 1..bslist.count LOOP
            IF (addKeyToBsRecCache(bslist(i))) THEN
               freec := freec - 1;
            END IF;
         END LOOP;
         bslist.delete;     -- free memory
         EXIT WHEN (loadLocality_c%NOTFOUND OR freec <= 0);
      END LOOP;
      CLOSE loadLocality_c;
   END IF;
 
--
   FOR rec in loadBsRecCache_c LOOP
      deviceindx :=  setCachedDeviceType(rec.deviceType);
--
      IF (prev_bskey = rec.bskey AND
          prev_bskey != 0) THEN
         icopy := icopy + 1;
      ELSE
         icopy := 1;           -- start with index 1 because this is new set
      END IF;
 
      addToBsRecCache(bskey      => rec.bskey,
                      icopy      => icopy,
                      deviceindx => deviceindx,
                      tag        => rec.tag,
                      copyNumber => rec.copyNumber,
                      code       => rec.code);
 
--
      prev_bskey := rec.bskey;
   END LOOP;
 
   deb(DEB_IN, 'tag=' || nvl(cacheBsRecTable.tag, 'NULL') ||
               ' deviceType=' || nvl(cacheBsRecTable.deviceType, 'NULL') ||
               ' mask=' || to_char(mask));
 
--
   deb(DEB_IN, 'Cache contains ' || to_char(cacheBsRecTable.bsRec.count) ||
               ' buckets');
--
--
--
--
--
 
   deb(DEB_IN, 'Minimum bskey=' || to_char(cacheBsRecTable.minbskey));
 
   deb(DEB_EXIT);
END loadBsRecCache;
 
--
PROCEDURE cacheFindValidBackupSet(
   bsRec                IN     rcvRec_t
  ,deviceType           IN     varchar2 DEFAULT NULL
  ,tag                  IN     varchar2 DEFAULT NULL
  ,availableMask        IN     binary_integer)
IS
BEGIN
   deb(DEB_PRINT,'cacheFindValidBackupSet:' ||
       ' bskey =' || to_char(bsRec.bsKey_con) ||
       ' tag=' || nvl(tag, 'NULL') ||
       ' deviceType=' || nvl(deviceType, 'NULL') ||
       ' mask=' || to_char(availableMask));
 
   IF (NOT hitBsRecCache(bskey      => bsRec.bsKey_con,
                         deviceType => deviceType,
                         tag        => tag,
                         mask       => availableMask)) THEN
      loadBsRecCache(from_bsRec     => bsRec,
                     deviceType     => deviceType,
                     tag            => tag,
                     mask           => availableMask,
                     mixcopy        => FALSE#);
      cacheBsRecTable.chit := cacheBsRecTable.chit + 1;
   END IF;
 
   findValidCacheRequest.bskey := bsRec.bsKey_con;
   findValidCacheRequest.icopy := 0;
END cacheFindValidBackupSet;
 
--
FUNCTION cacheGetValidBackupSet(
   validBackupSetRec            OUT NOCOPY validBackupSetRec_t
  ,checkDeviceIsAllocated       IN  number DEFAULT FALSE#)
RETURN number IS
   local        validBackupSetRec_t;
   bsrec        cacheBsRecRow_t;
   nullbsrec    rcvRec_t;
BEGIN
 
<<nextRow>>
 
   findValidCacheRequest.icopy := findValidCacheRequest.icopy + 1;
   BEGIN
      lkBsRecCache(
         bskey      => findValidCacheRequest.bskey,
         icopy      => findValidCacheRequest.icopy,
         bsrec      => bsrec);
   EXCEPTION
      WHEN no_data_found THEN
--
         IF (findValidCacheRequest.icopy != 1) THEN
            RAISE;
         END IF;
 
         IF (findValidCacheRequest.bskey< cacheBsRecTable.minbskey) THEN
            deb(DEB_PRINT, 'bskey < cacheBsRecTable.minbskey');
            RAISE;
         END IF;
 
         IF (NOT canMixCopy(bskey => findValidCacheRequest.bskey)) THEN
            RAISE;
         END IF;
 
--
         loadBsRecCache(from_bsRec     => nullbsrec,
                        deviceType     => cacheBsRecTable.deviceType,
                        tag            => cacheBsRecTable.tag,
                        mask           => cacheBsRecTable.mask,
                        mixcopy        => TRUE#);
         lkBsRecCache(
            bskey      => findValidCacheRequest.bskey,
            icopy      => findValidCacheRequest.icopy,
            bsrec      => bsrec);
   END;
 
--
   local.deviceType := cacheBsRecTable.devicelist(bsrec.deviceindx);
   local.tag := bsrec.tag;
   local.copyNumber := bsrec.copyNumber;
   local.code := bsrec.code;
 
   IF (checkDeviceIsAllocated = TRUE#) THEN
      IF (anyDevice = FALSE# AND
          isDeviceTypeAllocated(local.deviceType) = FALSE#) THEN
         GOTO nextRow;
      END IF;
   END IF;
   validBackupSetRec := local;                  -- set OUT mode arg
   deb(DEB_PRINT,'cacheGetValidBackupSet: returning valid rec deviceType=' ||
       local.deviceType || ' tag=' || local.tag || ' copyNumber=' ||
       to_char(local.copyNumber));
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      RETURN FALSE#;
END cacheGetValidBackupSet;
 
--
--
--
 
--
PROCEDURE validateState(
   anyCursor IN varchar2)
IS
BEGIN
   deb(DEB_ENTER,'validateState');
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'database not set');
   END IF;
   IF (this_dbinc_key IS NULL) THEN
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
   IF (translation_site_key IS NULL) THEN
      raise_application_error(-20082, 'Translation site key not set');
   END IF;
   IF (anyCursor IS NOT NULL) THEN
      raise_application_error(-20203, 'Translation already started');
   END IF;
 
--
--
   IF this_db_unique_name is NOT NULL AND this_site_key is NULL AND
      NOT this_dummy_instance THEN
      select site_key into this_site_key from node
         where db_unique_name=this_db_unique_name
           and db_key = this_db_key;
      deb(DEB_PRINT,'this_site_key=' || this_site_key);
   END IF;
   deb(DEB_EXIT,'validateState');
END;
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE computeUntilSCN(
   timeStamp IN  date
  ,scn       OUT number
  ,allinc    IN  number)
IS
   mySCN     number;
BEGIN
   deb(DEB_ENTER, 'computeUntilSCN');
 
--
--
--
   SELECT nvl(max(rlh.low_scn),0)
     INTO mySCN
     FROM rlh,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE rlh.dbinc_key     = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (rlh.low_scn >= d2.reset_scn AND
            rlh.low_scn <  d2.next_reset_scn))
      AND rlh.low_time     <= timeStamp;
 
   SELECT greatest(nvl(max(al.low_scn), 0), mySCN)
     INTO mySCN
     FROM al,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE al.dbinc_key     = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (al.low_scn >= d2.reset_scn AND
            al.low_scn <  d2.next_reset_scn))
      AND al.low_time      <= timeStamp;
 
   SELECT greatest(nvl(max(bdf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM bdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE bdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (bdf.ckp_scn >= d2.reset_scn AND
            bdf.ckp_scn <  d2.next_reset_scn))
      AND bdf.ckp_time <= timeStamp;
 
   SELECT greatest(nvl(max(bcf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM bcf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE bcf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (bcf.ckp_scn >= d2.reset_scn AND
            bcf.ckp_scn <  d2.next_reset_scn))
      AND bcf.ckp_time      <= timeStamp;
 
   SELECT greatest(nvl(max(cdf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM cdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE cdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (cdf.ckp_scn >= d2.reset_scn AND
            cdf.ckp_scn <  d2.next_reset_scn))
      AND cdf.ckp_time      <= timeStamp;
 
   SELECT greatest(nvl(max(cdf.rcv_fuzzy_scn),0), mySCN)
     INTO mySCN
     FROM cdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE cdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (cdf.rcv_fuzzy_scn >= d2.reset_scn AND
            cdf.rcv_fuzzy_scn <  d2.next_reset_scn))
      AND cdf.rcv_fuzzy_time <= timeStamp;
 
   SELECT greatest(nvl(max(ccf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM ccf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE ccf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (ccf.ckp_scn >= d2.reset_scn AND
            ccf.ckp_scn <  d2.next_reset_scn))
      AND ccf.ckp_time <= timeStamp;
 
   SELECT greatest(nvl(max(xdf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM xdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE xdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (xdf.ckp_scn >= d2.reset_scn AND
            xdf.ckp_scn <  d2.next_reset_scn))
      AND xdf.ckp_time <= timeStamp;
 
   SELECT greatest(nvl(max(xdf.rcv_fuzzy_scn),0), mySCN)
     INTO mySCN
     FROM xdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE xdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (xdf.rcv_fuzzy_scn >= d2.reset_scn AND
            xdf.rcv_fuzzy_scn <  d2.next_reset_scn))
      AND xdf.rcv_fuzzy_time<= timeStamp;
 
   SELECT greatest(nvl(max(df.create_scn), 0), mySCN)
     INTO mySCN
     FROM df,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE df.dbinc_key       = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (df.create_scn >= d2.reset_scn AND
            df.create_scn <  d2.next_reset_scn))
      AND df.create_time    <= timeStamp;
 
   SELECT greatest(nvl(max(df.stop_scn), 0), mySCN)
     INTO mySCN
     FROM df,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE df.dbinc_key       = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (df.stop_scn >= d2.reset_scn AND
            df.stop_scn <  d2.next_reset_scn))
      AND df.stop_time      <= timeStamp;
 
   SELECT greatest(nvl(max(offr.online_scn), 0), mySCN)
     INTO mySCN
     FROM offr,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE offr.dbinc_key     = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (offr.online_scn >= d2.reset_scn AND
            offr.online_scn <  d2.next_reset_scn))
      AND offr.online_time  <= timeStamp;
 
   scn := mySCN;
   deb(DEB_EXIT, 'with '||to_char(scn));
END computeUntilSCN;
 
--
PROCEDURE computeSpfileTime(
   inSCN     IN  number
  ,outTime   OUT date
  ,allinc    IN  number
  ,estimated OUT boolean)
IS
   startTime date;
BEGIN
   deb(DEB_ENTER, 'computeSpfileTime');
 
   outTime := NULL;
 
--
   IF rpoint_set THEN
      estimated := FALSE;
      SELECT MIN(rtime) INTO outTime
      FROM (SELECT NVL(rsptime, creation_time) rtime
            FROM nrsp
            WHERE to_scn = inSCN - 1
           UNION
            SELECT NVL(rsptime, creation_time) rtime
            FROM grsp
            WHERE to_scn = inSCN - 1);
   END IF;
 
--
   IF outTime IS NULL THEN
      estimated := TRUE;
      startTime := to_date('01/01/1900','DD/MM/YYYY');
 
--
      SELECT nvl(max(bs.start_time), startTime)
      INTO outTime
      FROM bcf,bs,
           (SELECT dbinc_key,
                   reset_scn,
                   PRIOR reset_scn next_reset_scn
            FROM dbinc
            WHERE allinc = TRUE#
            START WITH dbinc_key = this_dbinc_key
            CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
            SELECT this_dbinc_key dbinc_key,
                   null           reset_scn,
                   null           next_reset_scn
              FROM dual) d2
      WHERE bcf.dbinc_key = d2.dbinc_key
        AND bs.bs_key = bcf.bs_key
        AND (allinc = FALSE#           OR
             d2.next_reset_scn IS NULL OR
             (bcf.ckp_scn >= d2.reset_scn AND
              bcf.ckp_scn <  d2.next_reset_scn))
        AND bcf.ckp_scn <= inSCN;
 
--
 
--
      SELECT greatest(nvl(max(xcf.start_time), startTime), outTime)
      INTO outTime
      FROM xcf,
           (SELECT dbinc_key,
                   reset_scn,
                   PRIOR reset_scn next_reset_scn
            FROM dbinc
            WHERE allinc = TRUE#
            START WITH dbinc_key = this_dbinc_key
            CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
            SELECT this_dbinc_key dbinc_key,
                   null           reset_scn,
                   null           next_reset_scn
              FROM dual) d2
       WHERE xcf.dbinc_key      = d2.dbinc_key
         AND (allinc = FALSE#           OR
              d2.next_reset_scn IS NULL OR
              (xcf.ckp_scn >= d2.reset_scn AND
               xcf.ckp_scn <  d2.next_reset_scn))
         AND xcf.ckp_scn <= inSCN;
 
--
      IF startTime = outTime THEN
         outTime := NULL;
      END IF;
   END IF;
 
--
--
   outTime := outTime + 1/24/60/60; -- Add one second
 
   deb(DEB_EXIT, 'with ' || to_char(outTime, 'DD-MON-YY HH24:MI:SS'));
END computeSpfileTime;
 
--
--
--
 
--
 
--
PROCEDURE findBackupSet(
   bsKey        IN     number DEFAULT NULL
  ,recid        IN     number DEFAULT NULL
  ,stamp        IN     number DEFAULT NULL
  ,bsRec        OUT    NOCOPY bsRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'findBackupSet');
   deb(DEB_IN, 'bsKey:'||nvl(bsKey, -1));
   IF (bsKey IS NOT NULL) THEN
      SELECT recid,
             stamp,
             bs_key,
             set_stamp,
             set_count,
             backup_type,
             incremental_level,
             elapsed_seconds,
             completion_time,
             status,
             pieces,
             decode (keep_options, 'LOGS'         , KEEP_LOGS
                                 , 'NOLOGS'       , KEEP_NOLOGS
                                 , 'BACKUP_LOGS'  , KEEP_CONSIST
                                                  , KEEP_NO),
             keep_until,
             substr(multi_section, 1, 1),
             0 ppl_pdb_id,
             0 ppl_cdb_dbid
        INTO bsRec
        FROM rc_backup_set
       WHERE db_key = this_db_key
         AND findBackupSet.bsKey = bs_key;
   ELSE
      SELECT recid,
             stamp,
             bs_key,
             set_stamp,
             set_count,
             backup_type,
             incremental_level,
             elapsed_seconds,
             completion_time,
             status,
             pieces,
             decode (keep_options, 'LOGS'         , KEEP_LOGS
                                 , 'NOLOGS'       , KEEP_NOLOGS
                                 , 'BACKUP_LOGS'  , KEEP_CONSIST
                                                  , KEEP_NO),
             keep_until,
             substr(multi_section, 1, 1),
             0 ppl_pdb_id,
             0 ppl_cdb_dbid
        INTO bsRec
        FROM rc_backup_set
       WHERE db_key = this_db_key
         AND findBackupSet.recid = recid
         AND findBackupSet.stamp = stamp;
   END IF;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with error 20215');
      raise_application_error(-20215, 'Backup set is missing');
END findBackupSet;
 
--
--
--
 
--
--
--
 
--
PROCEDURE findValidBackupSet(
   bsKey                IN     number
  ,pieceCount           IN     number
  ,deviceType           IN     varchar2 DEFAULT NULL
  ,tag                  IN     varchar2 DEFAULT NULL
  ,availableMask        IN     binary_integer)
IS
   bsRec rcvRec_t;
BEGIN
   IF (bsRecCacheEnabled) THEN
      bsRec.bsKey_con := bsKey;
      bsRec.pieceCount_con := pieceCount;
      cacheFindValidBackupSet(bsRec         => bsRec,
                              deviceType    => deviceType,
                              tag           => tag,
                              availableMask => availableMask);
      RETURN;
   END IF;
 
   deb(DEB_ENTER, 'findValidBackupSet');
 
   IF (pieceCount = 1) THEN
      IF (findValidBackupSet1P_c%ISOPEN) THEN
         CLOSE findValidBackupSet1P_c;
      END IF;
--
--
--
--
      deb(DEB_OPEN, 'findValidBackupSet1P_c');
      OPEN findValidBackupSet1P_c(bsKey         => bsKey,
                                  pieceCount    => pieceCount,
                                  deviceType    => deviceType,
                                  tag           => tag,
                                  mask          => availableMask);
      getValidBackupSetCursor := 'findValidBackupSet1P_c';
   ELSE           -- more than one piece exists in this set
      IF (findValidBackupSet_c%ISOPEN) THEN
         CLOSE findValidBackupSet_c;
      END IF;
      deb(DEB_OPEN, 'findValidBackupSet_c');
      OPEN findValidBackupSet_c(bsKey         => bsKey,
                                pieceCount    => pieceCount,
                                deviceType    => deviceType,
                                tag           => tag,
                                mask          => availableMask);
      getValidBackupSetCursor := 'findValidBackupSet_c';
   END IF;
 
   deb(DEB_IN, 'bsKey=' || to_char(bsKey) || ' pieceCount=' ||
          to_char(pieceCount) ||' tag=' || nvl(tag, 'NULL'));
   deb(DEB_IN, ' deviceType=' || nvl(deviceType, 'NULL') ||
          ' mask=' || to_char(availableMask));
   getValidBackupSetLast.code       := 99;      -- init for getValidBackupSet
   deb(DEB_EXIT);
END findValidBackupSet;
 
--
FUNCTION validateBackupSet(
   backupSetRec            IN     rcvRec_t
  ,tag                     IN     varchar2 DEFAULT NULL
  ,tagMatchRequired        IN     boolean  DEFAULT TRUE
  ,checkDeviceIsAllocated  IN     boolean  DEFAULT TRUE
  ,availableMask           IN     binary_integer
  ,validRec                OUT    NOCOPY validBackupSetRec_t)
RETURN binary_integer IS
   findTag      bp.tag%TYPE;
BEGIN
   deb(DEB_ENTER, 'validateBackupSet');
   IF (tagMatchRequired) THEN
      findTag := tag;
   ELSE
--
--
--
      findTag := NULL;
   END IF;
 
   deb(DEB_IN, 'calling findValidBackupSet with:');
   deb(DEB_IN, ' tag=' || nvl(tag, 'NULL') ||
                    ' findTag=' || nvl(findTag, 'NULL') ||
                    ' tagMatchRequired=' || bool2char(tagMatchRequired) ||
                    ' checkDevice=' || bool2char(checkDeviceIsAllocated) ||
                    ' availableMask=' || to_char(availableMask));
 
  
   IF (bsRecCacheEnabled) THEN
      cacheFindValidBackupSet(bsRec         => backupSetRec,
                              tag           => findTag,
                              availableMask => availableMask);
   ELSE
      findValidBackupSet(bsKey         => backupSetRec.bsKey_con,
                         pieceCount    => backupSetRec.pieceCount_con,
                         tag           => findTag,
                         availableMask => availableMask);
   END IF;
 
   deb(DEB_EXIT, 'with result from validateBackupSet0');
   RETURN validateBackupSet0(
      tag                    => tag,
      tagMatchRequired       => tagMatchRequired,
      checkDeviceIsAllocated => checkDeviceIsAllocated,
      validRec               => validRec);
END validateBackupSet;
 
--
--
--
 
--
PROCEDURE findBackupPiece(
   bpKey        IN     number          DEFAULT NULL
  ,bsKey        IN     number          DEFAULT NULL
  ,tag          IN     varchar2        DEFAULT NULL
  ,handle       IN     varchar2        DEFAULT NULL
  ,deviceType   IN     varchar2        DEFAULT NULL
  ,copyNumber   IN     number          DEFAULT NULL
  ,statusMask   IN     binary_integer  DEFAULT BSavailable
  ,startBsKey   IN     number          DEFAULT NULL
  ,pdbKey       IN     number          DEFAULT NULL
  ,guid         IN     varchar2        DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'findBackupPiece');
   deb(DEB_IN, 'bpKey:'||nvl(bpKey, -1)||
          ' and bsKey:'||nvl(bsKey, -1));
   validateState(getBackupPieceCursor);
 
   IF (bpKey IS NOT NULL) THEN
      deb(DEB_OPEN, 'findBackupPieceBpKey');
      OPEN findBackupPieceBpKey(bpKey       => bpKey,
                                tag         => tag,
                                handle      => handle,
                                deviceType  => deviceType,
                                copyNumber  => copyNumber,
                                statusMask  => statusMask);
      getBackupPieceCursor := 'findBackupPieceBpKey';
   ELSIF (bsKey IS NOT NULL) THEN
      deb(DEB_OPEN, 'findBackupPieceBsKey1');
      OPEN findBackupPieceBsKey1(bsKey       => bsKey,
                                 tag         => tag,
                                 handle      => handle,
                                 deviceType  => deviceType,
                                 copyNumber  => copyNumber,
                                 statusMask  => statusMask);
      getBackupPieceCursor := 'findBackupPieceBsKey1';
   ELSIF (startBsKey IS NOT NULL) THEN
      OPEN findBackupPieceBsKey2(startBsKey  => startBsKey,
                                 tag         => tag,
                                 statusMask  => statusMask);
      getBackupPieceCursor := 'findBackupPieceBsKey2';
   ELSE
      deb(DEB_OPEN, 'findBackupPiece_c');
      OPEN findBackupPiece_c(   tag         => tag,
                                handle      => handle,
                                deviceType  => deviceType,
                                copyNumber  => copyNumber,
                                statusMask  => statusMask,
                                pdbKey      => pdbKey,
                                guid        => guid);
      getBackupPieceCursor := 'findBackupPiece_c';
   END IF;
 
--
--
 
   getBackupPieceNoRows.error     := NULL;
   getBackupPieceDuplicates       := TRUE#;
   getBackupPieceLast.pieceNumber := NULL;
   getBackupPieceDeviceType       := deviceType;
   getBackupPieceExpectedPieces   := NULL;
   getBackupPiecePieceCount       := 0;
   getBackupPieceByHandle         := FALSE;
   getBackupPieceAvailableMask    := NULL;
   getBackupPieceSeekLast.bskey   := NULL;
   getBackupPieceCopyNumber       := NULL;
   getBackupPieceBskey            := bsKey;
   deb(DEB_EXIT);
 
END findBackupPiece;
 
--
--
--
 
--
FUNCTION addAction(                             -- add to the rcvRecStack
   actionIN      IN     rcvRec_t                -- if a backup set, we fill
--
  ,partial_rcv   IN     boolean
  ,isAncestor    IN     boolean
  ,cf_scn        IN     number  DEFAULT NULL
  ,cf_cretime    IN     date    DEFAULT NULL
  ,cf_offrrid    IN     number  DEFAULT NULL
  ,allCopies     IN     boolean DEFAULT FALSE
  ,doingRecovery IN     boolean
  ,rmanCmd       IN     binary_integer
  ,pdbId         IN     number
  ,cleanSCN      IN     number)
RETURN number IS
   dummy                rcvRec_t;
   action               rcvRec_t;
   validate_rc          number;
   cf_count             number;
   addRedo_rc           number;
   chkact_rc            number;
   tagMatchRequired     boolean;
   validationRec        validBackupSetRec_t;
   lowAction            rcvRec_t;
   canrecover           boolean;
   toSCN                number;
BEGIN
   deb(DEB_ENTER, 'addAction');
   deb(DEB_IN, ' action.type_con='|| to_char(action.type_con));
 
   action := actionIN;                  -- copy to local variable
 
--
--
--
--
--
--
--
--
 
   IF (redoNeeded(action)) THEN
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
      rcvRecGet(rcvRecStackState.lowAction, lowAction);
      addRedo_rc := addRedo(isAncestor,
                            action.toSCN_act, action.rlgSCN_act,
                            lowAction,
                            partial_rcv, doingRecovery);
 
      IF (addRedo_rc = action_OLD_REDO) THEN
--
--
--
         deb(DEB_EXIT, 'with addRedo_rc: '||to_char(addRedo_rc));
         RETURN addRedo_rc;
      ELSE
--
--
--
--
--
         NULL;
      END IF;
   ELSE                                 -- redo not needed
--
--
--
--
      NULL;
   END IF;
 
--
--
   chkact_rc := CheckRecAction(action, pdbId, cleanSCN);
 
   IF (chkact_rc = action_SKIP) THEN
      deb(DEB_EXIT, 'with action_SKIP');
      RETURN action_SKIP;
   END IF;
 
 
--
--
--
--
 
   IF (action.type_con = backupSet_con_t) THEN
      IF (computeRA_allRecords = TRUE# OR restoreTag IS NULL) THEN
         tagMatchRequired := FALSE;
      ELSE
         tagMatchRequired := TRUE;
      END IF;
 
      IF (rmanCmd = rcvCopyCmd_t) THEN
--
--
         tagMatchRequired := FALSE;
      END IF;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
      IF (rmanCmd != obsoleteCmd_t OR 
          (restoreTag IS NOT NULL AND this_baseline_cap >= 0)) THEN
         validate_rc :=
            validateBackupSet(backupSetRec           => action,
                              tag                    => restoreTag,
                              tagMatchRequired       => tagMatchRequired,
                              checkDeviceIsAllocated => TRUE,
                              availableMask          => computeRA_availableMask,
                              validRec               => validationRec);
      ELSE
--
--
         validate_rc := SUCCESS;
      END IF;
 
      IF (validate_rc = dbms_rcvman.UNAVAILABLE) THEN
         deb(DEB_EXIT, '(backup set is unavailable) with: action_FAIL');
         RETURN action_FAIL;
      ELSIF (validate_rc = dbms_rcvman.AVAILABLE) THEN
--
--
--
         deb(DEB_IN,'dont have required device type');
 
--
--
--
--
         IF (rmanCmd = rcvCopyCmd_t) THEN
            computeRA_rcvCopy_avail := TRUE;
         ELSE
            computeRA_available := TRUE;
         END IF;
         deb(DEB_EXIT, 'returning FAIL');
         RETURN action_FAIL;
      END IF;
--
--
--
   ELSIF (action.type_con = proxyCopy_con_t) THEN
--
      IF (anyDevice = FALSE# AND
          isDeviceTypeAllocated(action.deviceType_con) = FALSE#) THEN
--
--
--
         IF (rmanCmd = rcvCopyCmd_t) THEN
            computeRA_rcvCopy_avail := TRUE;
         ELSE
            computeRA_available := TRUE;
         END IF;
         deb(DEB_EXIT, '(dont have required device type for proxy)'||
             ' with: action_FAIL');
         RETURN action_FAIL;
      END IF;
   ELSIF (action.type_con = imageCopy_con_t) THEN
--
--
--
      IF (rmanCmd != rcvCopyCmd_t AND not diskDevice) THEN
--
--
         computeRA_available := TRUE;
         deb(DEB_EXIT, '(dont have required device type for imagecopy)'||
             ' with: action_FAIL');
         RETURN action_FAIL;
      END IF;
 
--
--
--
      IF (rmanCmd = rcvCopyCmd_t) THEN
         canrecover := FALSE;
         computeRA_available := computeRA_rcvCopy_avail;
         toSCN := action.toSCN_act;
         deb(DEB_IN,'rcvCopyCmd count= ' || rcvRecStack.count ||
             ' lowAction= ' || rcvRecStackState.lowAction ||
             ' toSCN= ' || toSCN);
         IF (rcvRecStack.count > 0) THEN
            FOR i IN REVERSE 1..rcvRecStackState.lowAction LOOP
               rcvRecGet(i, dummy);
--
               IF (dummy.type_act = incremental_act_t OR
                   dummy.type_con = offlineRangeRec_con_t) THEN
--
--
--
--
                  EXIT WHEN (toSCN < dummy.fromSCN_act);
 
--
                  IF (dummy.type_con = offlineRangeRec_con_t) THEN
                     toSCN := dummy.toSCN_act;
                     deb(DEB_IN,'extending toSCN= ' || toSCN);
                  ELSE -- this is incremental
                     IF (anyDevice = TRUE# OR
                         isDeviceTypeAllocated(dummy.deviceType_con)=TRUE#)
                     THEN
--
                        deb(DEB_IN,'canrecover is TRUE - 2');
                        canrecover := TRUE;
                        computeRA_available := NULL;
                        EXIT;
                     ELSE
--
--
--
                        deb(DEB_IN,'canrecover is FALSE');
                        canrecover := FALSE;
                        computeRA_available := TRUE;
                     END IF;
                  END IF;
               ELSIF (debug) THEN
                  deb(DEB_IN,'rcvCopyCmd skipping');
                  printRcvRec(dummy);
               END IF;
            END LOOP;
         END IF;
 
--
--
--
         IF not canrecover THEN
            resetrcvRecStack;
            deb(DEB_EXIT, 'no valid incrementals with: action_FAIL');
            RETURN action_FAIL;
         END IF;
      END IF;
   ELSIF (action.type_con = offlineRangeRec_con_t AND
          action.type_act = offlineRange_act_t) THEN
--
--
--
--
--
--
       IF (cf_cretime IS NULL AND rmanCmd = obsoleteCmd_t) THEN
--
--
         NULL;
       ELSIF (cf_cretime = action.cfCreationTime_con AND
              action.recid_con >= cf_offrrid AND
              cf_offrrid > 0 AND       -- contains at least 1 record
              cf_scn >= action.toSCN_act) THEN
         NULL;                         -- range is in current cf, we're cool
      ELSE
         SELECT count(*)
         INTO cf_count
         FROM ccf
         WHERE ccf.create_time = action.cfCreationTime_con AND
               ccf.min_offr_recid <= action.recid_con AND
               ccf.ckp_scn >= action.toSCN_act AND
               ((user_site_key = ccf.site_key) OR
                (user_site_key IS NULL AND
                 ((disk_backups_shared = TRUE#) OR
                  (this_site_key = nvl(ccf.site_key, this_site_key))))) AND
               ccf.min_offr_recid > 0;         -- contains at least 1 record
         IF (cf_count = 0) THEN
            deb(DEB_EXIT, '(no controlfile copy with offline range)'||
                          ' with: action_FAIL');
            RETURN action_FAIL;
         END IF;
      END IF;
   END IF;
 
--
--
   IF (addRedo_rc = action_OLD_INC_REDO) THEN
 
      rcvRecStackState.lowAction := 0;
 
      rcvRecStack.trim(rcvRecStack.last -
                       greatest(rcvRecStackState.savePoint,
                                rcvRecStackState.top));
      deb(DEB_IN,'trimming stack, rcvRecStackCount='|| rcvRecStack.count);
   END IF;
 
   <<addAnother>>
 
--
--
--
   IF (validate_rc      = SUCCESS         AND
       action.type_con  = backupSet_con_t AND
       (rmanCmd         != obsoleteCmd_t OR
        (restoreTag IS NOT NULL AND this_baseline_cap >= 0))) THEN
--
--
--
--
--
--
--
      IF (validationRec.tag = restoreTag OR
          restoreTag IS NULL) THEN
         action.tag_con := validationRec.tag;
      END IF;
      action.deviceType_con := validationRec.deviceType;
      action.copyNumber_con := validationRec.copyNumber;
   END IF;
 
   IF (debug) THEN
      printRcvRec(action);
   END IF;
 
   IF (action.type_act = full_act_t) THEN
 
      IF (thisBackupAge < rcvRecBackupAge) THEN
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
 
--
--
--
--
--
         deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                      thisBackupAge || ') < rcvRecBackupAge('  ||
                      rcvRecBackupAge || ')');
         thisBackupAge := thisBackupAge + 1;
         deb(DEB_EXIT, 'with: action_SKIP');
         RETURN action_SKIP;
      END IF;
 
--
      IF (rcvRecStackState.fullBackups >= computeRA_fullBackups) THEN
--
--
         IF (rmanCmd = obsoleteCmd_t AND action.keep_options = 0) THEN
            deb(DEB_IN, 'skipping action because this action has NO KEEP');
            deb(DEB_EXIT, 'with action_SKIP');
            RETURN action_SKIP;
         ELSIF (rmanCmd != obsoleteCmd_t) THEN
            deb(DEB_IN, 'skipping action because stack has enough fullBackups');
            deb(DEB_EXIT, 'with action_SKIP');
            RETURN action_SKIP;
         END IF;
      END IF;
   END IF;
 
--
   IF (rmanCmd = obsoleteCmd_t and NOT isValidAction(action)) THEN
      deb(DEB_EXIT, 'with action_SKIP');
      RETURN action_SKIP;
   END IF;
 
   rcvRecPush(action);               -- add record for this action
 
   deb(DEB_IN, ' Added action:');
 
   IF (allCopies AND action.type_con = backupSet_con_t) THEN
--
      deb(DEB_IN,'allCopies is TRUE, trying to add other copies');
      validate_rc :=
         validateBackupSet0(tag                    => restoreTag,
                            tagMatchRequired       => tagMatchRequired,
                            checkDeviceIsAllocated => TRUE,
                            validRec               => validationRec);
      IF (validate_rc <> SUCCESS) THEN
         GOTO done;
      END IF;
      GOTO addAnother;
   END IF;
 
   <<done>>
 
--
 
   IF (action.type_act = full_act_t) THEN
--
      deb(DEB_IN, ' action.type_act is range/full => setting savePoint='||
           to_char(rcvRecStack.last));
      rcvRecStackState.savePoint   := rcvRecStack.last;
 
--
--
      IF (rmanCmd != obsoleteCmd_t OR action.keep_options = KEEP_NO) THEN
         rcvRecStackState.fullBackups := rcvRecStackState.fullBackups + 1;
      END IF;
   ELSIF (rcvRecStackState.lowAction = 0) THEN
--
      rcvRecStackState.lowAction := rcvRecStack.last;
   ELSIF (action.fromSCN_act <
          rcvRecStack(rcvRecStackState.lowAction).fromSCN_act) THEN
      rcvRecStackState.lowAction := rcvRecStack.last;   -- new lowAction
   END IF;
 
   deb(DEB_EXIT, 'with: action_OK');
   RETURN action_OK;
 
END addAction;
 
--
--
--
FUNCTION computeRecoveryActions2(
   fno         IN number        -- Datafile number.
  ,crescn      IN number        -- Datafile creation SCN.
  ,cretime     IN date          -- Datafile creation time.
  ,df_rlgscn   IN number        -- Datafile resetlogs SCN.
--
--
--
  ,df_rlgtime  IN date          -- Datafile resetlogs time.
--
--
  ,df_ckpscn   IN number        -- Datafile checkpoint SCN.
--
--
  ,offlscn     IN number        -- kccfeofs (may be 0).
  ,onlscn      IN number        -- kccfeonc (0 if offlscn is 0).
  ,onltime     IN date          -- kccfeonc_time (ignored if kccfeofs is 0)
  ,cleanscn    IN number        -- kccfecps if either SOR or WCC set, else 0.
  ,clean2scn   IN number        -- CF ckpt SCN if WCC set.
--
  ,clean2time  IN date          -- cf_checkpoint_time if WCC,
--
  ,allowfuzzy  IN boolean       -- TRUE if can be fuzzy at until SCN/time,
--
  ,partial_rcv IN boolean
  ,target_scn  IN number        -- This is the SCN to which we want to recover
--
--
--
--
--
--
--
--
--
--
  ,dbinc_key   IN number        -- The key of the database incarnation to
--
--
--
  ,cf_scn      IN number
  ,cf_cretime  IN date          -- controlfile creation time.
--
  ,cf_offrrid  IN number        -- recid of oldest offline range in controlfile
--
  ,test_search IN boolean       -- if TRUE, then we have called ourself
--
--
  ,done        IN OUT boolean   -- set to TRUE if successful.  (IN mode so
--
  ,allCopies   IN boolean       -- if true, then stack all copies of
--
  ,recover     IN boolean
  ,rmanCmd     IN binary_integer
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer  -- 1 => readonly, 0 => readwrite
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date
  ,creation_thread IN   number
  ,creation_size   IN   number
  ,pdbId           IN   number
  ,pdbForeignDbid  IN   number)
--
--
--
--
--
--
--
 
RETURN boolean IS
 
--
--
--
 
   null_action          rcvRec_t;
   action               rcvRec_t;       -- current row
   lastAction           rcvRec_t;
   parentDbincKey       number;         -- my parent dbinc's key
 
   dbinc_rlgscn         number;         -- resetlogs scn for dbinc_key
 
   dbinc_rlgtime        date;           -- resetlogs time for dbinc_key
 
   CURSOR dbinc_cursor(db_key number, rstscn number) IS
   SELECT dbinc_key
     FROM dbinc
    WHERE dbinc.db_key = dbinc_cursor.db_key
      AND dbinc.reset_scn < dbinc_cursor.rstscn;
 
   dbinc_row            dbinc_cursor%ROWTYPE;
 
   savedrcvRecStackState rcvRecStackState_t;
 
   addAction_rc         number;         -- return code
 
   addRedo_rc           number;         -- return code
 
   isAncestor           boolean;        -- TRUE if we find an action we could
--
 
   rc                   boolean;        -- return code from recursive search
--
 
   done_flag            boolean;        -- for use in recursive calls
 
   doingRecovery        boolean;        -- doing RECOVER
   stack_df_rlgscn      number;
   savedBackupAge       number;
 
BEGIN
   deb(DEB_ENTER, 'computeRecoveryActions2');
 
   done := FALSE;
 
   doingRecovery := recover;
 
   IF (doingRecovery is null) THEN
--
--
     IF (df_rlgscn is not null) THEN                      -- doing RECOVER
        doingRecovery := TRUE;
     ELSE
        doingRecovery := FALSE;
     END IF;
   END IF;
 
   IF (doingRecovery) THEN                                 -- doing RECOVER
      deb(DEB_IN, ' Doing recovery.');
   ELSE
      deb(DEB_IN, ' Not doing recovery.');
   END IF;
 
--
   SELECT reset_scn, reset_time
     INTO dbinc_rlgscn, dbinc_rlgtime
     FROM dbinc
    WHERE dbinc.dbinc_key = computeRecoveryActions2.dbinc_key;
 
   IF (doingRecovery AND canApplyAnyRedo = FALSE# ) THEN
--
--
--
--
 
      IF (dbinc_rlgscn < df_rlgscn) THEN
         deb(DEB_IN, 'dbinc_rlgscn < df_rlgscn (' || to_char(dbinc_rlgscn) ||
             ' < ' || to_char(df_rlgscn) || ')');
         deb(DEB_EXIT,'computeRecoveryActions2 - 1 with FALSE');
         RETURN FALSE;
      ELSIF (dbinc_rlgscn = df_rlgscn AND dbinc_rlgtime <> df_rlgtime) THEN
         deb(DEB_IN, 'dbinc_rlgtime <> df_rlgtime');
         deb(DEB_EXIT,'computeRecoveryActions2 - 2 with FALSE');
         RETURN FALSE;
      END IF;
   END IF;
 
   IF (not test_search) THEN
--
--
      deb(DEB_IN, ' This is ancestor.');
      isAncestor := TRUE;
   ELSE
      isAncestor := FALSE;
   END IF;
 
   openRecoveryActionCursor( dbincKey     => dbinc_key
                            ,fno          => fno
                            ,creSCN       => crescn
                            ,dfCkpSCN     => df_ckpscn
                            ,dbincRlgSCN  => dbinc_rlgscn
                            ,dbincRlgTime => dbinc_rlgtime
                            ,offlSCN      => offlscn
                            ,onlSCN       => onlscn
                            ,onlTime      => onltime
                            ,cleanSCN     => cleanscn
                            ,clean2SCN    => clean2scn
                            ,clean2Time   => clean2time
                            ,targetSCN    => target_scn
                            ,rmanCmd      => rmanCmd
                            ,foreignDbid  => foreignDbid
                            ,pluggedRonly => pluggedRonly
                            ,pluginSCN    => pluginSCN
                            ,pluginRlgSCN => pluginRlgSCN
                            ,pluginRlgTime=> pluginRlgTime);
 
--
--
--
 
<<action_loop>>
   LOOP
      <<next_row>>
     IF (fetchRecoveryAction(  dbincKey     => dbinc_key
                              ,fno          => fno
                              ,creSCN       => crescn
                              ,dfCkpSCN     => df_ckpscn
                              ,dbincRlgSCN  => dbinc_rlgscn
                              ,dbincRlgTime => dbinc_rlgtime
                              ,offlSCN      => offlscn
                              ,onlSCN       => onlscn
                              ,onlTime      => onltime
                              ,cleanSCN     => cleanscn
                              ,clean2SCN    => clean2scn
                              ,clean2Time   => clean2time
                              ,targetSCN    => target_scn
                              ,action       => action
                              ,rmanCmd      => rmanCmd
                              ,foreignDbid  => foreignDbid
                              ,pluggedRonly => pluggedRonly
                              ,pluginSCN    => pluginSCN
                              ,pluginRlgSCN => pluginRlgSCN
                              ,pluginRlgTime=> pluginRlgTime)) THEN
         deb(DEB_PRINT, 'fetched recovery action');
         printRcvRec(action);
 
--
--
--
 
         IF (bitand(action.type_con, backupMask_con_t) > 0 AND
             action.toSCN_act = target_scn) THEN
            deb(DEB_IN, ' This is ancestor.');
            isAncestor := TRUE;
         END IF;
 
         IF (action.type_con = offlineRangeRec_con_t) THEN
--
--
--
            deb(DEB_IN, ' found an offline range' ||
                ' from=' || to_char(action.fromSCN_act) ||
                ' to=' || to_char(action.toSCN_act));
 
            IF (action.type_act = spanningRange_act_t) THEN
--
--
--
               deb(DEB_IN, ' offline range started before this resetlogs SCN');
 
--
--
--
               addAction_rc := action_OK;
            ELSE
               addAction_rc := addAction(actionIN      => action,
                                         partial_rcv   => partial_rcv,
                                         isAncestor    => isAncestor,
                                         cf_scn        => cf_scn,
                                         cf_cretime    => cf_cretime,
                                         cf_offrrid    => cf_offrrid,
                                         doingRecovery => doingRecovery,
                                         rmanCmd       => rmanCmd,
                                         pdbId         => pdbId,
                                         cleanSCN      => cleanSCN);
            END IF;
         ELSIF (action.type_con = backupSet_con_t AND
                action.type_act = incremental_act_t) THEN
--
--
--
            deb(DEB_IN, 'found an incremental backup set');
 
            addAction_rc := addAction(actionIN      => action,
                                      partial_rcv   => partial_rcv,
                                      isAncestor    => isAncestor,
                                      allCopies     => allCopies,
                                      doingRecovery => doingRecovery,
                                      rmanCmd       => rmanCmd,
                                      pdbId         => pdbId,
                                      cleanSCN      => cleanSCN);
         ELSIF (action.type_act = full_act_t) THEN
--
--
--
            deb(DEB_IN, 'found a copy/full/level0/proxy copy');
 
            IF (doingRecovery) THEN                  -- if doing a RECOVER
--
--
--
--
--
--
               IF (rmanCmd = rcvCopyCmd_t) THEN
                  addAction_rc := addAction(actionIN      => action,
                                            partial_rcv   => partial_rcv,
                                            isAncestor    => isAncestor,
                                            allCopies     => allCopies,
                                            doingRecovery => doingRecovery,
                                            rmanCmd       => rmanCmd,
                                            pdbId         => pdbId,
                                            cleanSCN      => cleanSCN);
               ELSE
                  IF (isAncestor) THEN
                     rcvRecTop(lastAction);
                     IF (not redoNeeded(action) OR
                         canAddRedo(isAncestor,
                                    action.toSCN_act, action.rlgSCN_act,
                                    lastAction, partial_rcv, doingRecovery) <>
                         action_OLD_REDO) THEN
                        computeRA_restorable := TRUE;
                     END IF;
                  END IF;
                  addAction_rc := action_SKIP;
               END IF;
            ELSE                                -- not doing a RECOVER
               addAction_rc := addAction(actionIN      => action,
                                         partial_rcv   => partial_rcv,
                                         isAncestor    => isAncestor,
                                         allCopies     => allCopies,
                                         doingRecovery => doingRecovery,
                                         rmanCmd       => rmanCmd,
                                         pdbId         => pdbId,
                                         cleanSCN      => cleanSCN);
            END IF;
         ELSE
--
--
--
            deb(DEB_IN, 'unknown container type: ' ||
                 to_char(action.type_con) ||
                ' or action type: ' || to_char(action.type_act));
 
--
--
            deb(DEB_EXIT, 'with error 20999');
            raise_application_error(-20999, 'unknown action kind');
         END IF;                                -- "switch" on ACTION.KIND
 
--
--
--
 
         deb(DEB_IN, 'addAction returned code ' || to_char(addAction_rc));
 
         IF (addAction_rc = action_OK) THEN     -- the action was added
 
--
--
--
 
            IF (action.type_act = full_act_t AND
                this_baseline_cap >= 0 AND
                (action.toSCN_act < this_baseline_cap_scn OR
                 this_baseline_cap_scn IS NULL)) THEN
               deb(DEB_IN, 'Found a backup older than baseline_cap');
               done := TRUE;
               deb(DEB_PRINT,'done set to true - 0');
               EXIT action_loop;
            END IF;
 
            IF (rcvRecStackState.savePoint > 0 AND
                computeRA_allRecords = FALSE#  AND
                rcvRecStackState.fullBackups >= computeRA_fullBackups) THEN
--
--
--
--
--
               deb(DEB_IN, 'savePoint > 0' ||
                   ' and computeRA_allRecords = FALSE#');
               done := TRUE;
               deb(DEB_PRINT,'done set to true - 1');
               EXIT action_loop;
            END IF;
 
            IF (doingRecovery) THEN                   -- if doing RECOVER
               IF (action.type_con = offlineRangeRec_con_t) THEN
--
--
                  IF (df_ckpscn = action.fromSCN_act) THEN
                     done := TRUE;
                     deb(DEB_PRINT,'done set to true - 2');
                     EXIT action_loop;
                  END IF;
               ELSE
--
--
                  IF (df_ckpscn >= action.fromSCN_act) THEN
                     done := TRUE;
                     deb(DEB_PRINT,'done set to true - 3');
                     EXIT action_loop;
                  END IF;
               END IF;
            END IF;
 
--
--
--
 
--
--
--
--
 
            IF (action.type_con = offlineRangeRec_con_t AND
                action.fromSCN_act < dbinc_rlgscn AND
                canApplyAnyRedo = FALSE#) THEN
 
               deb(DEB_IN, 'offline range spanning a resetlogs');
 
--
--
--
--
--
--
 
--
 
               SELECT parent_dbinc_key
                 INTO parentDbincKey
                 FROM dbinc
                WHERE dbinc.dbinc_key = computeRecoveryActions2.dbinc_key;
 
               IF (parentDbincKey is null) THEN -- we don't know our parent
 
--
--
--
--
--
--
                  deb(DEB_OPEN, 'dbinc_cursor');
                  OPEN dbinc_cursor(this_db_key, dbinc_rlgscn);
 
                  deb(DEB_IN,
                      'doing scan of all possible parent incarnations, top=' ||
                      to_char(rcvRecStack.last));
 
                  <<dbinc_loop>>
                  LOOP
                     FETCH dbinc_cursor
                      INTO dbinc_row;
                     EXIT WHEN dbinc_cursor%NOTFOUND;
                     deb(DEB_IN,
                         'starting test search of incarnation key=' ||
                         to_char(dbinc_row.dbinc_key));
 
                     savedrcvRecStackState := rcvRecStackState;
                     rcvRecStackState.top := rcvRecStack.last;
 
                     savedBackupAge        := thisBackupAge;
 
--
--
--
 
                     thisBackupAge         := rcvRecBackupAge;
 
                     rc := computeRecoveryActions2(fno, crescn, cretime,
                                                  df_rlgscn, df_rlgtime,
                                                  df_ckpscn,
                                                  offlscn,
                                                  onlscn, onltime,
                                                  cleanscn,
                                                  clean2scn, clean2time,
                                                  allowfuzzy, partial_rcv,
                                    rcvRecStack(rcvRecStack.count).fromSCN_act,
                                                  dbinc_row.dbinc_key,
                                                  cf_scn, cf_cretime,
                                                  cf_offrrid,
                                                  TRUE, done_flag, allCopies,
                                                  doingRecovery,
                                                  rmanCmd, foreignDbid,
                                                  pluggedRonly, pluginSCN,
                                                  pluginRlgSCN, pluginRlgTime,
                                                  creation_thread,
                                                  creation_size, pdbId,
                                                  pdbForeignDbid);
 
--
--
--
--
                     deb(DEB_IN, 'last=' || to_char(rcvRecStack.last) ||
                         ' trimming last ' ||
                         to_char(rcvRecStack.last - rcvRecStackState.top)
                        );
                     rcvRecStack.trim(rcvRecStack.last - rcvRecStackState.top);
                     rcvRecStackState      := savedrcvRecStackState;
                     deb(DEB_PRINT,'restoring rcvRecStackCount after test search'||rcvRecStack.count);
                     thisBackupAge         := savedBackupAge;
                     deb(DEB_IN, 'count is now '|| to_char(rcvRecStack.count));
 
                     IF (rc) THEN
--
--
--
--
--
--
--
--
--
--
--
--
--
                        IF (parentDbincKey is null) THEN
                           parentDbincKey := dbinc_row.dbinc_key;
                        ELSE
--
--
--
                           deb(DEB_IN,
                               'aborting search due to ambiguous ancestory');
                           CLOSE dbinc_cursor;
                           EXIT action_loop;
                        END IF;
                     END IF;
                  END LOOP;     -- dbinc_loop
               END IF;          -- if we don't know our parent
 
--
--
               IF (parentDbincKey is not null) THEN
                  deb(DEB_IN, 'starting search of parent incarnation key='||
                      to_char(parentDbincKey));
                  rc := computeRecoveryActions2(fno, crescn, cretime,
                                               df_rlgscn, df_rlgtime,
                                               df_ckpscn,
                                               offlscn,
                                               onlscn, onltime,
                                               cleanscn,
                                               clean2scn, clean2time,
                                               allowfuzzy, partial_rcv,
                                     rcvRecStack(rcvRecStack.last).fromSCN_act,
                                               parentDbincKey,
                                               cf_scn, cf_cretime,
                                               cf_offrrid,
                                               FALSE, done_flag, allCopies,
                                               doingRecovery,
                                               rmanCmd, foreignDbid,
                                               pluggedRonly, pluginSCN,
                                               pluginRlgSCN, pluginRlgTime,
                                               creation_thread,
                                               creation_size, pdbId,
                                               pdbForeignDbid);
                  IF (done_flag) THEN
                     deb(DEB_PRINT,'done set to true - 4');
                     done := TRUE;
                  END IF;
 
                  IF (action.type_act = spanningRange_act_t) THEN
--
--
--
--
--
--
                     isAncestor := rc;
                  END IF;
               END IF;          -- we know or found our parent
               EXIT action_loop;
            END IF;             -- offline range start SCN < dbinc_rlgscn
         ELSIF (addAction_rc = action_FAIL) THEN         -- FAIL
--
--
            NULL;
         ELSIF (addAction_rc = action_SKIP) THEN        -- SKIP
--
            NULL;
         ELSIF (addAction_rc = action_OLD_REDO) THEN    -- OLD_REDO
--
--
--
--
--
--
            EXIT action_loop;
         ELSE                                   -- unknown return code
            deb(DEB_EXIT, 'with error 20999');
            raise_application_error(-20999, 'unknown add action return code');
         END IF;
      ELSE                                      -- rcvRecCursor exhausted
         deb(DEB_IN, 'end of cursor reached');
         EXIT action_loop;
      END IF;                                   -- if fetchRecoveryAction
   END LOOP;
 
   IF (done) THEN
      deb(DEB_EXIT,'computeRecoveryActions2 - 3');
      RETURN isAncestor;
   END IF;
 
--
--
--
 
   IF (doingRecovery) THEN                      -- if doing RECOVER
      deb(DEB_PRINT,'computeRecoveryActions2:recovery final check');
      deb(DEB_IN, 'crescn=' || crescn ||';this_reset_scn='||this_reset_scn);
      deb(DEB_IN, 'df_rlgscn='||df_rlgscn||';df_rlgtime='||
                  to_char(df_rlgtime));
 
      IF (rmanCmd = rcvCopyCmd_t) THEN
--
--
--
         deb(DEB_PRINT,'computeRecoveryActions2: no copies stacked');
         resetrcvRecStack;
         done := FALSE;
      ELSIF (rcvRecStack.count > 0) THEN           -- if found some action
         deb(DEB_PRINT,'computeRecoveryActions2:'|| rcvRecStack.count ||
                       ' actions stacked');
--
--
--
--
         rcvRecTop(lastAction);
         stack_df_rlgscn := df_rlgscn;
         IF (df_rlgscn is NULL) THEN
            stack_df_rlgscn := this_reset_scn;
         END IF;
         addRedo_rc := addRedo(isAncestor, df_ckpscn, stack_df_rlgscn,
                               lastAction, partial_rcv, doingRecovery);
         IF (addRedo_rc = action_OK OR addRedo_rc = action_FAIL
             OR addRedo_rc = action_OLD_INC_REDO) THEN
--
--
--
--
--
--
            done := TRUE;
         END IF;
         IF (addRedo_rc = action_OLD_INC_REDO) THEN
--
            rcvRecStack.trim(rcvRecStack.count);
         END IF;
      ELSE
         deb(DEB_PRINT,'computeRecoveryActions2: no actions stacked');
--
--
         IF (df_rlgscn = this_reset_scn AND
             df_rlgtime = this_reset_time) THEN
            done := TRUE;
         ELSIF (action_OLD_INC_REDO =
                        addRedo(isAncestor, df_ckpscn, df_rlgscn,
                               null, partial_rcv, doingRecovery)) THEN
            done := TRUE;
         END IF;
--
--
--
         IF (df_rlgscn is NULL AND           -- df may be created during rcv
             cretime > cf_cretime  AND       -- df created after cf creation
             crescn >  nvl(inc_list(max_inc_idx-1).prior_resetlogs_change#,
                           inc_list(max_inc_idx-1).resetlogs_change#)) THEN
--
            done := TRUE;
         END IF;
      END IF;
   ELSE                                         -- not doing a RECOVER
--
--
--
      IF (rcvRecStackState.savePoint = 0) THEN
--
--
--
--
--
         deb(DEB_IN, 'could try create datafile');
 
         rcvRecStack.trim(rcvRecStack.count - rcvRecStackState.top);
         rcvRecStackState.lowAction := rcvRecStack.count;
         deb(DEB_IN, 'rcvRecStackState :' || rcvRecStackState.top || ' ' ||
                      rcvRecStackState.savePoint || ' ' ||
                      rcvRecStackState.lowAction);
--
 
--
--
--
--
--
--
         IF ((computeRA_available = FALSE)  AND    -- no backup found
             pluginSCN = 0                  AND    -- not a plugin file
             foreignDbid = 0                AND    -- not a foreign file
             pdbForeignDbid = 0             AND    -- not a pdb plugin file
             (creation_thread IS NULL or creation_thread > 0) AND
--
             (creation_size IS NULL or creation_size > 0) AND
--
             (cretime > cf_cretime)  AND           -- df created after cf
             (crescn >  nvl(inc_list(max_inc_idx-1).prior_resetlogs_change#,
                            inc_list(max_inc_idx-1).resetlogs_change#)) AND
--
             (bitand(createdatafile_act_t, getRA_actionMask) != 0) AND
--
             restoreTag is null) THEN              -- from tag not specified
             action          := null_action;
             action.type_con := datafile_con_t;
             action.type_act := createdatafile_act_t;
             action.dfNumber_obj := fno;
             action.dfCreationSCN_obj := crescn;
             action.fromSCN_act := 0;
             action.toSCN_act := crescn;
             action.toTime_act := cretime;
             action.pluggedRonly_obj := 0;
             action.pluginSCN_obj := 0;
             FOR inc_idx in 0..max_inc_idx-1 LOOP
                IF (crescn > inc_list(inc_idx).resetlogs_change#) THEN
                    deb(DEB_PRINT, 'data file created with resetlogs scn='||
                                    inc_list(inc_idx).resetlogs_change#);
                    action.rlgSCN_act := inc_list(inc_idx).resetlogs_change#;
                    action.rlgTime_act := inc_list(inc_idx).resetlogs_time;
                    exit;
                END IF;
             END LOOP;
             IF (action.rlgSCN_act IS NULL) THEN
                deb(DEB_IN, 'rlgSCN is null');
                addAction_rc := action_FAIL;
             ELSE
                addAction_rc := addAction(actionIN      => action,
                                          partial_rcv   => partial_rcv,
                                          isAncestor    => isAncestor,
                                          allCopies     => allCopies,
                                          doingRecovery => doingRecovery,
                                          rmanCmd       => rmanCmd,
                                          pdbId         => pdbId,
                                          cleanSCN      => cleanSCN);
             END IF;
 
             IF (addAction_rc = action_OK) THEN     -- the action was added
                done := TRUE;
                deb(DEB_IN, 'added create datafile action for '||fno);
             ELSE
                deb(DEB_IN, 'failed to add create datafile action for '||fno);
             END IF;
         END IF;
         IF computeRA_available = TRUE THEN
           deb(DEB_IN, 'need different device type channels to restore');
         END IF;
      ELSE
--
--
--
--
--
         deb(DEB_IN, 'trim all actions after savePoint='||
                to_char(greatest(rcvRecStackState.savePoint,
                                 rcvRecStackState.top)));
         rcvRecStack.trim(rcvRecStack.last -
                          greatest(rcvRecStackState.savePoint,
                                   rcvRecStackState.top));
         done := TRUE;
      END IF;
      deb(DEB_PRINT,'computeRecoveryActions2: set rcvRecStackCount='||rcvRecStack.count);
   END IF;                                      -- if doing recover
 
   IF (done) THEN
      deb(DEB_IN, 'done is TRUE');
   ELSE
      deb(DEB_IN, 'done is FALSE');
   END IF;
 
   deb(DEB_EXIT,'computeRecoveryActions2 - 4');
   RETURN isAncestor;
 
END computeRecoveryActions2;
 
--
FUNCTION getParentIncarnation(
   dbinc_key         OUT number
  ,resetlogs_change# OUT number)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'getParentIncarnation');
 
   SELECT resetlogs_change#, parent_dbinc_key
     INTO resetlogs_change#, dbinc_key
     FROM rc_database_incarnation where dbinc_key = getParentIncarnationKey;
   deb(DEB_EXIT, 'with: TRUE#');
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END getParentIncarnation;
 
--
--
--
FUNCTION getPointInTimeInc(
   toscn IN number)
RETURN NUMBER IS
   pitrlgscn  number;
BEGIN
   IF (getPointInTimeInc.toscn >= this_reset_scn) THEN
      RETURN this_reset_scn;
   END IF;
 
   SELECT dbinc.reset_scn
     INTO pitrlgscn
     FROM (SELECT reset_scn, PRIOR reset_scn next_reset_scn
             FROM dbinc
            START WITH dbinc_key = this_dbinc_key
             CONNECT BY PRIOR parent_dbinc_key = dbinc_key) dbinc
    WHERE dbinc.reset_scn <= getPointInTimeInc.toscn
      AND dbinc.next_reset_scn > getPointInTimeInc.toscn;
 
   RETURN pitrlgscn;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
END getPointInTimeInc;
 
--
--
--
--
 
FUNCTION get_cfUntilScn
RETURN number IS
  ret_scn number := untilSCN;
  max_scn number;
  max_tag bp.tag%type;
--
  CURSOR keepscn(scn NUMBER) IS
   SELECT bckscn, tag
   FROM
   (SELECT brl.next_scn bckscn, bp.tag
    FROM bs, brl, bp
    WHERE bs.bs_key = brl.bs_key
      AND bs.bs_key = bp.bs_key
      AND bs.keep_options > 0
      AND bp.status = 'A'
      AND brl.low_scn <= scn
      AND brl.next_scn > scn
      AND this_site_key = bs.site_key
      AND this_dbinc_key = dbinc_key
   UNION
    SELECT xal.next_scn bckscn, xal.tag
    FROM xal
    WHERE xal.keep_options > 0
      AND xal.status = 'A'
      AND xal.low_scn <= scn
      AND xal.next_scn > scn
      AND this_site_key = xal.site_key
      AND this_dbinc_key = dbinc_key
   UNION
    SELECT bdf.ckp_scn bckscn, bp.tag
    FROM bs, bdf, bp
    WHERE bs.bs_key = bdf.bs_key
      AND bs.bs_key = bp.bs_key
      AND bs.keep_options > 0
      AND bp.status = 'A'
      AND bdf.ckp_scn = scn+1
      AND this_site_key = bs.site_key
      AND this_dbinc_key = dbinc_key
   UNION
    SELECT xdf.ckp_scn bckscn, xdf.tag
    FROM xdf
    WHERE xdf.keep_options > 0
      AND xdf.status = 'A'
      AND xdf.ckp_scn = scn+1
      AND this_site_key = xdf.site_key
      AND this_dbinc_key = dbinc_key)
   ORDER BY bckscn DESC;
BEGIN
   IF rpoint_set THEN
--
      OPEN keepscn(untilSCN - 1);
      FETCH keepscn INTO max_scn, max_tag;
      CLOSE keepscn;
 
--
      SELECT NVL(MIN(cfscn)+1, untilSCN) INTO ret_scn
      FROM
       (SELECT bcf.ckp_scn cfscn
        FROM bcf, bs, bp
        WHERE bcf.bs_key = bs.bs_key
          AND bs.bs_key = bp.bs_key
          AND bp.status = 'A'
          AND this_site_key = bs.site_key
          AND this_dbinc_key = dbinc_key
          AND bp.tag = max_tag
          AND bcf.ckp_scn > max_scn
       UNION ALL
        SELECT ckp_scn
        FROM ccf
        WHERE this_site_key = site_key
          AND this_dbinc_key = dbinc_key
          AND status = 'A'
          AND tag = max_tag
          AND ckp_scn > max_scn
       UNION ALL
        SELECT ckp_scn
        FROM xcf
        WHERE this_site_key = site_key
          AND this_dbinc_key = dbinc_key
          AND status = 'A'
          AND tag = max_tag
          AND ckp_scn > max_scn);
   deb(DEB_PRINT, 'new scn is ' || ret_scn);
   END IF;
 
   RETURN ret_scn;
END get_cfUntilScn;
 
--
--
 
FUNCTION IsDuplicateAlName(samelog IN number, filename varchar2)
RETURN BOOLEAN IS
  duplicate number;
BEGIN
--
--
--
--
   duplicate := FALSE#;
   IF (samelog = TRUE#) THEN
       FOR log_idx in 0..max_lognames_idx-1 LOOP
          IF lognames_list(log_idx) = filename THEN
            duplicate := TRUE#;
            EXIT;
          END IF;
       END LOOP;
       lognames_list(max_lognames_idx) := filename;
       max_lognames_idx := max_lognames_idx + 1;
   ELSE
     lognames_list(0) := filename;
     max_lognames_idx := 1;
   END IF;
 
   IF duplicate = TRUE# THEN
     deb(DEB_PRINT, 'Filter duplicate log name' || filename);
     RETURN TRUE;
   ELSE
     RETURN FALSE;
   END IF;
 
END IsDuplicateAlName;
 
--
--
--
 
--
--
--
PROCEDURE getCurrentIncarnation(
   db_id          IN  number
  ,reset_scn      OUT number
  ,reset_time     OUT date) IS
BEGIN
   deb(DEB_ENTER, ' getCurrentIncarnation');
   deb(DEB_IN, ' db_id=' || to_char(db_id));
   SELECT  dbinc.reset_scn, dbinc.reset_time
      INTO reset_scn, reset_time
      FROM db, dbinc
      WHERE db_id = getCurrentIncarnation.db_id       -- should return 1 row
      AND dbinc.dbinc_key = db.curr_dbinc_key;
   deb(DEB_EXIT, 'reset_scn='||reset_scn||' reset_time='||reset_time);
 EXCEPTION
    WHEN no_data_found THEN
       deb(DEB_EXIT, 'with error 20001');
       raise_application_error(-20001, 'Database not found');
END;
 
--
--
--
FUNCTION getPrimaryDfName(
     fno IN number)
RETURN varchar2 IS
  local_fname  varchar2(513);
BEGIN
  SELECT fname INTO local_fname
  FROM site_dfatt s, df, node
  WHERE node.database_role = 'PRIMARY'
    AND node.db_key = this_db_key
    AND node.site_key = s.site_key
    AND s.df_key = df.df_key
    AND df.dbinc_key = node.dbinc_key
    AND df.file# = fno
    AND df.dbinc_key = this_dbinc_key
    AND df.drop_scn is NULL
    AND ROWNUM=1;
  RETURN local_fname;
END getPrimaryDfName;
 
--
PROCEDURE setDbincLst
IS
   CURSOR inc_record_c IS
     SELECT * from rc_database_incarnation
       WHERE db_key=this_db_key
         START WITH dbinc_key=this_dbinc_key
         CONNECT BY PRIOR parent_dbinc_key = dbinc_key
       ORDER BY resetlogs_change# DESC;
 
   CURSOR pdb_inc_record_c IS
      SELECT pdbinc.con_id con_id, pdbinc.pdbinc_key,
             pdbinc.inc_scn incscn, pdbinc.end_reset_scn erscn,
             pdbinc_status status
        FROM rci_pdbinc_this_dbinc pdbinc
       WHERE pdbinc.dbinc_key = this_dbinc_key
         AND pdbinc.con_id > 1
       ORDER BY pdbinc.con_id, pdbinc.end_reset_scn DESC;
 
   inc_rec       rc_database_incarnation%ROWTYPE;
   inc_idx       binary_integer;
   pdb_inc_set   pdb_incarnation_set_t;
   pdb_inc_rec   pdb_incarnation_t;
 
BEGIN
   deb(DEB_ENTER, 'setDbincLst');
   IF this_dbinc_key is  NULL OR this_db_key is  NULL THEN
      raise_application_error(-20999, 'internal err: setDbincLst-1');
   END IF;
 
   deb(DEB_PRINT, 'Setting incarnation records as per this_dbinc_key');
   inc_idx := 0;
   FOR inc_rec IN inc_record_c LOOP
      inc_list(inc_idx) := inc_rec;
      deb(DEB_PRINT, 'incarnation record id=' || inc_idx);
      deb(DEB_PRINT, 'icprs=' ||inc_list(inc_idx).prior_resetlogs_change# ||
                     ',icprc='|| inc_list(inc_idx).prior_resetlogs_time);
      deb(DEB_PRINT, 'icrls=' || inc_list(inc_idx).resetlogs_change# ||
                     ',icrlc='|| inc_list(inc_idx).resetlogs_time);
      deb(DEB_PRINT, 'icpinc=' || inc_list(inc_idx).parent_dbinc_key);
      deb(DEB_PRINT, 'icflg=' || inc_list(inc_idx).status);
      inc_idx := inc_idx + 1;
   END LOOP;
 
   max_inc_idx := inc_idx;
   deb(DEB_PRINT, 'number of incarnation=' || max_inc_idx);
 
--
   deb(DEB_PRINT, 'Fetching pdb sub incarnation records');
   pdb_inc_list.delete;
   FOR pdb_inc_rec in pdb_inc_record_c LOOP
      IF (NOT pdb_inc_list.exists(pdb_inc_rec.con_id)) THEN
         pdb_inc_list(pdb_inc_rec.con_id) := pdb_inc_set;
      END IF;
      inc_idx := pdb_inc_list(pdb_inc_rec.con_id).count;
      pdb_inc_list(pdb_inc_rec.con_id)(inc_idx) := pdb_inc_rec;
      deb(DEB_PRINT, 'incarnation record id=' || inc_idx);
      deb(DEB_PRINT, 'con_id='     || pdb_inc_rec.con_id ||  
                    ',pdbinc_key=' || pdb_inc_rec.pdbinc_key);
      deb(DEB_PRINT, 'incscn='     || pdb_inc_rec.incscn ||  
                    ',erscn='      || pdb_inc_rec.erscn);    
      deb(DEB_PRINT, 'status='     || pdb_inc_rec.status);
   END LOOP;
 
   deb(DEB_EXIT);
END setDbincLst;
 
--
--
--
 
--
PROCEDURE setDatabase(
   db_name        IN varchar2
  ,reset_scn      IN number
  ,reset_time     IN date
  ,db_id          IN number
  ,db_unique_name IN varchar2 default NULL
  ,site_aware     IN boolean default FALSE
  ,dummy_instance IN boolean default FALSE
  ,ors_instance   IN boolean default FALSE)
IS
   local        dbinc%rowtype;                    -- local variables
   dbnm         dbinc.db_name%TYPE;
   dbnm_in      dbinc.db_name%TYPE;
   current_inc  varchar2(3);
   rid          varchar2(18);
   ever_resynced number;
BEGIN
   deb(DEB_ENTER, 'setDatabase');
   this_db_key := NULL;                  -- clear in case exception raised
   this_dbinc_key := NULL;
   this_reset_scn := NULL;
   this_reset_time := NULL;
   this_db_unique_name := NULL;
   translation_site_key := NULL;
   this_site_key := NULL;
   dbnm_in := upper(db_name);
 
--
   BEGIN
      SELECT null
        INTO local.db_key
        FROM rcver
       WHERE version = catalogVersion;
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_EXIT, 'with error 20299');
         raise_application_error(-20299, 'Recovery catalog version mismatch');
   END;
 
--
--
--
--
 
   IF (db_id is not NULL) THEN
      deb(DEB_IN, ' db_id=' || to_char(db_id));
      IF dbms_rcvcat.registerDbPending.dbid = db_id THEN
        dbms_rcvcat.registerDatabase(
          db_id, dbnm_in, reset_scn, reset_time, db_unique_name,
          dbms_rcvcat.registerDbPending.con_id,
          dbms_rcvcat.registerDbPending.guid);
      END IF;  
      BEGIN
         SELECT db.db_key, curr_dbinc_key,
                dbinc.reset_scn, dbinc.reset_time, dbinc.db_name
           INTO local.db_key, local.dbinc_key,
                local.reset_scn, local.reset_time, local.db_name
           FROM db, dbinc
          WHERE db_id = setDatabase.db_id       -- should return 1 row
            AND dbinc.dbinc_key = db.curr_dbinc_key;
      EXCEPTION
         WHEN no_data_found THEN
            deb(DEB_EXIT, 'with error 20001');
            raise_application_error(-20001, 'Database not found');
      END;
 
--
      IF (dbnm_in is NOT NULL) THEN
--
--
--
--
         BEGIN
            SELECT decode(dbinc.dbinc_key, db.curr_dbinc_key, 'YES', 'NO'),
                   dbinc.db_name, dbinc.rowid
              INTO current_inc,
                   dbnm,
                   rid
              FROM db, dbinc
             WHERE db.db_key = dbinc.db_key
               AND db.db_id = setDatabase.db_id
               AND dbinc.reset_scn = setDatabase.reset_scn
               AND dbinc.reset_time = setDatabase.reset_time;
         EXCEPTION
            WHEN no_data_found THEN
               deb(DEB_EXIT, 'with error 20003');
               raise_application_error(-20003,
                                       'Database incarnation not found');
         END;
 
         IF (current_inc = 'NO') THEN
            deb(DEB_EXIT, 'with error 20011');
            raise_application_error(-20011,
                                    'Database incarnation not current');
         END IF;
         IF (dbnm != dbnm_in) THEN
            deb(DEB_PRINT, 'DB_NAME changed from '||dbnm||' to '|| dbnm_in);
            UPDATE dbinc
               SET dbinc.db_name = dbnm_in
             WHERE rowid = rid;
            COMMIT;
         END IF;
      END IF;
   ELSIF (dbnm_in is NOT NULL) THEN
--
      deb(DEB_IN, 'db_id is null');
      BEGIN
         SELECT db.db_key, db.curr_dbinc_key, dbinc.reset_scn, dbinc.reset_time
           INTO local.db_key, local.dbinc_key,
                local.reset_scn, local.reset_time
           FROM db, dbinc
          WHERE db.curr_dbinc_key = dbinc.dbinc_key
            AND dbinc.db_name = dbnm_in;
      EXCEPTION
         WHEN no_data_found THEN
            deb(DEB_EXIT, 'with error 20001');
            raise_application_error(-20001, 'Database not found');
         WHEN too_many_rows THEN
            deb(DEB_EXIT, 'with error 20005');
            raise_application_error(-20005, 'Database name is ambiguous');
      END;
   ELSE
      deb(DEB_EXIT, 'with error 20006');
      raise_application_error(-20006, 'Database name is missing');
   END IF;
 
--
--
   IF dummy_instance THEN
      deb(DEB_PRINT, 'dummy_instance is TRUE');
      this_dummy_instance := TRUE;
   END IF;
   this_db_unique_name := upper(db_unique_name);
   this_db_key         := local.db_key;
   this_dbinc_key      := local.dbinc_key;
   this_reset_scn      := local.reset_scn;
   this_reset_time     := local.reset_time;
 
--
--
--
   IF ors_instance THEN
      IF db_unique_name IS NULL THEN
         raise_application_error(-20999,
           'internal error:db_unique_name must be specified for ORS instance');
      END IF;
      IF db_id IS NULL THEN
         raise_application_error(-20999,
           'internal error: db_id must be specified for ORS instance');
      END IF;
      IF instr(this_db_unique_name, '$'|| db_id) = 0 THEN
         this_db_unique_name := this_db_unique_name || '$' || db_id;
      END IF;
      IF substr(this_db_unique_name, 1, 1) <> '$' THEN
         this_db_unique_name := '$' || this_db_unique_name;
      END IF;
   END IF;
 
 
   deb(DEB_PRINT, 'this_db_unique_name= ' || this_db_unique_name);
   deb(DEB_PRINT, 'this_site_key= ' || this_site_key);
   deb(DEB_PRINT, 'this_db_key='||this_db_key);
   deb(DEB_PRINT, 'this_dbinc_key='||this_dbinc_key);
 
   setDbincLst;
 
   BEGIN
      SELECT site_key into this_site_key FROM node
         where db_unique_name=upper(this_db_unique_name)
           AND db_key = this_db_key;
      deb(DEB_PRINT, 'this_site_key=' || this_site_key);
   EXCEPTION
      WHEN no_data_found THEN
        deb(DEB_PRINT, 'this_site_key is NULL');
   END;
 
   BEGIN
      IF site_aware THEN
         client_site_aware := 1;
         deb(DEB_PRINT, 'client_site_aware=' || client_site_aware);
      END IF;
 
      IF NOT ors_instance AND site_aware AND this_site_key is not NULL THEN
        translation_site_key := this_site_key;
        deb(DEB_PRINT, 'translation_site_key=' || translation_site_key);
      ELSE
        BEGIN
           SELECT site_key into translation_site_key FROM node
              WHERE database_role='PRIMARY'
                AND db_key = this_db_key;
           deb(DEB_PRINT, 'translation_site_key(primary)=' ||
                          translation_site_key);
        EXCEPTION
           WHEN no_data_found THEN
--
--
--
--
--
--
--
--
              select count(*) into ever_resynced from rci_datafile
                 where site_key = this_site_key;
              IF ever_resynced > 0 THEN
                 translation_site_key := this_site_key;
              ELSE
                 select max(site_key) into translation_site_key from node
                    where db_key=this_db_key;
              END IF;
              deb(DEB_PRINT, 'translation_site_key(no_data_found)=' ||
                          translation_site_key);
           WHEN too_many_rows THEN
--
--
--
--
              select max(site_key) into translation_site_key from node
                 where db_key=this_db_key
                   and database_role ='PRIMARY';
              deb(DEB_PRINT, 'translation_site_key(too_many_rows)=' ||
                          translation_site_key);
        END;
      END IF;
   EXCEPTION
      WHEN no_data_found THEN
        deb(DEB_PRINT, 'translation_site_key is NULL');
   END;
 
   IF site_aware AND this_site_key is NULL THEN
      this_site_key := translation_site_key;
      deb(DEB_PRINT, 'this_site_key is set to same  as translation_site_key');
   END IF;
 
   IF site_aware THEN
      setArchiveFileScopeAttributes(logs_shared => 0);
      setBackupFileScopeAttributes (disk_backups_shared => 0,
                                    tape_backups_shared => 1);
   END IF;
   deb(DEB_EXIT);
END setDatabase;
 
--
FUNCTION getDbUniqueName(
   db_id IN number)
RETURN varchar2
IS
   dbunqnm  node.db_unique_name%TYPE;
   CURSOR dbunqnm_c IS
      SELECT node.db_unique_name
        FROM node, db
       WHERE db.db_id  = getDbUniqueName.db_id
         AND db.db_key = node.db_key;
BEGIN
   SELECT node.db_unique_name
     INTO dbunqnm
     FROM node, db
    WHERE db.db_id  = getDbUniqueName.db_id
      AND db.db_key = node.db_key;
 
   RETURN dbunqnm;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
END getDbUniqueName;
 
--
FUNCTION getDbKey RETURN NUMBER IS
BEGIN
   return this_db_key;
END;
 
--
FUNCTION getMinRcvStartScn RETURN NUMBER IS
   minrcvstartScn   NUMBER;
BEGIN
   SELECT NVL(min(LOW_SCN), 0)
     INTO minrcvstartScn
     FROM rrcache
    WHERE range_type = 'RA$DISK'
    AND db_key = this_db_key;
   RETURN minrcvstartScn;
END;
 
--
PROCEDURE resetDbKey IS
BEGIN 
  this_db_key := NULL;
END;
 
--
PROCEDURE setDbincKey(
   key IN number)
IS
BEGIN
   deb(DEB_ENTER, 'setDbincKey');
   IF (key is not null) THEN
      this_dbinc_key := key;
   ELSE
--
      SELECT curr_dbinc_key
        INTO this_dbinc_key
        FROM db;
   END IF;
 
   SELECT db_key, reset_scn, reset_time
     INTO this_db_key, this_reset_scn, this_reset_time
     FROM dbinc
    WHERE dbinc_key = this_dbinc_key;
 
   setDbincLst;
 
   deb(DEB_EXIT);
END setDbincKey;
 
--
FUNCTION getParentIncarnation(
   resetlogs_change# IN OUT number
  ,resetlogs_time    IN OUT date)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'getParentIncarnation');
--
--
   IF (resetlogs_change# is null) THEN
      getParentIncarnationKey := this_dbinc_key;
   END IF;
   SELECT resetlogs_change#, resetlogs_time, parent_dbinc_key
     INTO resetlogs_change#, resetlogs_time, getParentIncarnationKey
     FROM rc_database_incarnation where dbinc_key = getParentIncarnationKey;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END getParentIncarnation;
 
--
PROCEDURE getCheckpoint(
   scn OUT number
  ,seq OUT number
  ,ckp_key_1 OUT number
  ,ckp_key_2 OUT number)
 
IS
  full_row   ckp%ROWTYPE;
  either_row ckp%ROWTYPE;
BEGIN
   deb(DEB_ENTER, 'getCheckpoint');
   IF (this_dbinc_key is NULL) THEN
     deb(DEB_EXIT, 'with error 20020');
     raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
--
--
 
--
--
--
 
--
--
--
--
--
--
--
 
   FOR r IN (SELECT /*+ first_rows */ * FROM ckp
             WHERE dbinc_key = this_dbinc_key AND
                   ckp_type  = 'FULL' AND
                   site_key = this_site_key
             ORDER BY ckp_scn DESC, cf_create_time DESC, ckp_cf_seq DESC)
   LOOP
     full_row := r;
     EXIT;
   END LOOP;
 
   FOR r IN (SELECT /*+ first_rows */ * FROM ckp
             WHERE dbinc_key      = this_dbinc_key AND
                   cf_create_time = full_row.cf_create_time AND
                   site_key       = this_site_key
             ORDER BY ckp_scn DESC, ckp_cf_seq DESC, ckp_type DESC)
   LOOP
     either_row := r;
     EXIT;
   END LOOP;
 
   IF either_row.ckp_key IS NOT NULL THEN
      scn       := either_row.ckp_scn;
      seq       := either_row.ckp_cf_seq;
      ckp_key_1 := full_row.ckp_key;
      ckp_key_2 := either_row.ckp_key;
   ELSE
      scn       := 0;
      seq       := 0;
      ckp_key_1 := 0;
      ckp_key_2 := 0;
   END IF;
 
   deb(DEB_EXIT);
END getCheckpoint;
 
PROCEDURE getCheckpoint(
   scn OUT number
  ,seq OUT number)
 
IS
   ckp_key_1 number;
   ckp_key_2 number;
BEGIN
   getCheckpoint(scn, seq, ckp_key_1, ckp_key_2);
END getCheckpoint;
 
--
--
--
 
--
PROCEDURE setUntilTime(
   unttime IN date)
IS
    walk_dbinc_key  number := NULL;
    parent_dbinc_key  number := NULL;
BEGIN
   deb(DEB_ENTER, 'setUntilTime');
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   walk_dbinc_key := this_dbinc_key;
 
<<parent_inc>>
   untilSCN  := NULL;
   untilTime := unttime;
   rpoint_set := FALSE;
 
   BEGIN
      SELECT resetlogs_change#
         INTO untilSCN
         FROM rc_database_incarnation
      WHERE dbinc_key = walk_dbinc_key
         AND resetlogs_time < untilTime;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
            IF (allIncarnations = TRUE#) THEN
               SELECT parent_dbinc_key
                  INTO parent_dbinc_key
                  FROM dbinc
               WHERE dbinc.dbinc_key = walk_dbinc_key;
 
               walk_dbinc_key := parent_dbinc_key;
               IF (walk_dbinc_key IS NULL) THEN
                  deb(DEB_IN, 'parent_dbinc_key=NULL -> exiting');
                  untilSCN := 0;                         -- begining of world
               ELSE
                  deb(DEB_IN, 'parent_dbinc_key=' ||
                     to_char(parent_dbinc_key));
                  GOTO parent_inc;           -- get scn of parent incarnation
               END IF;
            ELSE
               deb(DEB_EXIT, 'with error 20207');
               raise_application_error(-20207,
                                 'until time is before resetlogs time');
            END IF;
         END;
   END;
 
   IF walk_dbinc_key != this_dbinc_key THEN
      actual_dbinc_key := walk_dbinc_key;
      deb(DEB_IN, 'actual_dbinc_key set to:  '||to_char(actual_dbinc_key));
   END IF;
 
--
--
--
--
--
   deb(DEB_IN, 'calling computeUntilSCN. untilSCN=  '||to_char(untilSCN));
   deb(DEB_IN, 'calling computeUntilSCN. untilTime= '||to_char(untilTime));
   computeUntilSCN(untilTime, untilSCN, allIncarnations);
   deb(DEB_IN, 'untilSCN= '||to_char(untilSCN));
   deb(DEB_EXIT, 'untilTime='||to_char(untilTime));
   IF (untilSCN IS NULL) THEN
      raise_application_error(-20213, 'UNTIL TIME could not be translated to 
                                       an UNTIL CHANGE');
   END IF;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with error 20207');
      raise_application_error(-20207, 'until time is before resetlogs time');
END setUntilTime;
 
--
PROCEDURE setUntilScn(
   scn     IN number
  ,rlgscn  IN number  DEFAULT NULL
  ,rlgtime IN date    DEFAULT NULL
  ,flbrp   IN boolean DEFAULT FALSE
  ,rpoint  IN boolean DEFAULT FALSE)
IS
   walk_dbinc_key    number := NULL;
   walk_dbinc_scn    number := NULL;
   walk_dbinc_time   date   := NULL;
   parent_dbinc_key  number := NULL;
BEGIN
   deb(DEB_ENTER, 'setUntilSCN');
 
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   IF (flbrp AND rlgscn IS NOT NULL AND rlgtime IS NOT NULL) THEN
--
--
      BEGIN
         SELECT dbinc_key
           INTO walk_dbinc_key
           FROM rc_database_incarnation
          WHERE resetlogs_change# = rlgscn
            AND resetlogs_time = rlgtime
            AND db_key = this_db_key;
      EXCEPTION
         WHEN no_data_found THEN
            deb(DEB_EXIT, 'with error 20212');
            raise_application_error(-20212,
                                    'until SCN is an orphan incarnation');
      END;
   ELSE
      walk_dbinc_Key := this_dbinc_key;
   END IF;
 
<<parent_inc>>
   untilSCN := scn;
   untilTime := NULL;
 
   BEGIN
      SELECT untilSCN, resetlogs_change#, resetlogs_time
         INTO untilSCN, walk_dbinc_scn, walk_dbinc_time
         FROM rc_database_incarnation
      WHERE dbinc_key = walk_dbinc_key
         AND resetlogs_change# < untilSCN;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
            IF (allIncarnations = TRUE#) THEN
               SELECT parent_dbinc_key
                  INTO parent_dbinc_key
                  FROM dbinc
               WHERE dbinc.dbinc_key = walk_dbinc_key;
 
               walk_dbinc_key := parent_dbinc_key;
               IF (walk_dbinc_key IS NULL) THEN
                  deb(DEB_EXIT, 'parent_dbinc_key=NULL, with error 20208');
                  raise_application_error(-20208,
                                    'until SCN is before resetlogs SCN');
               ELSE
                  deb(DEB_IN, 'parent_dbinc_key=' ||
                     to_char(parent_dbinc_key));
                  GOTO parent_inc;           -- get scn of parent incarnation
               END IF;
            ELSE
               deb(DEB_EXIT, 'with error 20208');
               raise_application_error(-20208,
                                 'until SCN is before resetlogs SCN');
            END IF;
         END;
   END;
 
   IF (rlgscn != walk_dbinc_scn OR rlgtime != walk_dbinc_time) THEN
      deb(DEB_EXIT, 'with error 20212');
      raise_application_error(-20212, 'until SCN is an orphan incarnation');
   END IF;
 
--
   rpoint_set := rpoint and not flbrp;
 
   IF walk_dbinc_key != this_dbinc_key THEN
      actual_dbinc_key := walk_dbinc_key;
      deb(DEB_IN, 'actual_dbinc_key set to:  '||to_char(actual_dbinc_key));
   END IF;
 
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with error 20208');
      raise_application_error(-20208,'until SCN is before resetlogs SCN');
END setUntilScn;
 
--
PROCEDURE setUntilLog(
   sequence# IN number
  ,thread#   IN number)
IS
    walk_dbinc_key  number := NULL;
    parent_dbinc_key  number := NULL;
BEGIN
   deb(DEB_ENTER, 'setUntilLog');
   rpoint_set := FALSE;
 
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   IF (sequence# is NULL) THEN
      deb(DEB_EXIT, 'with error 20205');
      raise_application_error(-20205, 'Incomplete UNTIL clause');
   END IF;
 
   walk_dbinc_Key := this_dbinc_key;
 
<<parent_inc>>
   untilTime := NULL;
   untilSCN := NULL;
 
   BEGIN
--
      SELECT first_change#
        INTO untilSCN
        FROM rc_log_history
       WHERE dbinc_key = walk_dbinc_key
         AND thread# = nvl(setUntilLog.thread#, 1)  -- default thread# is 1
         AND sequence# = setUntilLog.sequence#;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
--
--
            SELECT next_change#
              INTO untilSCN
              FROM rc_log_history
             WHERE dbinc_key = this_dbinc_key
--
               AND thread# = nvl(setUntilLog.thread#, 1)
               AND sequence# = setUntilLog.sequence# - 1;
         EXCEPTION
            WHEN no_data_found THEN
               BEGIN
                  IF (allIncarnations = TRUE#) THEN
                     SELECT parent_dbinc_key
                       INTO parent_dbinc_key
                       FROM dbinc
                      WHERE dbinc.dbinc_key = walk_dbinc_key;
 
                     walk_dbinc_key := parent_dbinc_key;
                     IF (walk_dbinc_key IS NULL) THEN
                        deb(DEB_EXIT, 'with error 20206');
                        raise_application_error(-20206,
                                               'Specified log does not exist');
                     ELSE
                        deb(DEB_IN, 'parent_dbinc_key=' ||
                                    to_char(parent_dbinc_key));
                        GOTO parent_inc;     -- get scn of parent incarnation
                     END IF;
                  ELSE
                     deb(DEB_EXIT, 'with error 20206');
                     raise_application_error(-20206,
                                             'Specified log does not exist');
                  END IF;
               END;
         END;
   END;
 
   IF walk_dbinc_key != this_dbinc_key THEN
      actual_dbinc_key := walk_dbinc_key;
      deb(DEB_IN, 'actual_dbinc_key set to:  '||to_char(actual_dbinc_key));
   END IF;
 
   deb(DEB_EXIT);
END setUntilLog;
 
--
PROCEDURE setToLog(
   sequence# IN number
  ,thread#   IN number)
IS
BEGIN
   deb(DEB_ENTER, 'setToLog');
   untilTime := NULL;
   untilSCN := NULL;
   rpoint_set := FALSE;
 
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   IF (sequence# is NULL) THEN
      deb(DEB_EXIT, 'with error 20205');
      raise_application_error(-20205, 'Incomplete TO clause');
   END IF;
 
   BEGIN
--
      SELECT (next_change# - 1)
        INTO untilSCN
        FROM rc_log_history
       WHERE dbinc_key = this_dbinc_key
         AND thread# = nvl(setToLog.thread#, 1)        -- default thread# is 1
         AND sequence# = setToLog.sequence#;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
--
--
            SELECT (first_change# - 1)
              INTO untilSCN
              FROM rc_log_history
             WHERE dbinc_key = this_dbinc_key
--
               AND thread# = nvl(setToLog.thread#, 1)
               AND sequence# = setToLog.sequence# + 1;
         EXCEPTION
            WHEN no_data_found THEN
               deb(DEB_EXIT, 'with error 20206');
               raise_application_error(-20206, 'Specified log does not exist');
         END;
   END;
   deb(DEB_EXIT);
END setToLog;
 
--
PROCEDURE getRedoLogDeletionPolicy(
  policy  OUT varchar2)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getRedoLogDeletionPolicy;
 
--
PROCEDURE setRedoLogDeletionPolicy(
  policy  IN varchar2
 ,alldest IN number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END setRedoLogDeletionPolicy;
 
--
PROCEDURE resetAll(
  transclause IN boolean DEFAULT TRUE)
IS
BEGIN
   deb(DEB_PRINT, 'resetAll');
 
--
   setRAflags(kindMask   => allKind,
              allRecords => FALSE);
   setAllFlag(FALSE);
   setLikePattern(NULL);
   setCompletedRange(after => NULL, before => NULL);
   resetUntil;
   setFrom(NULL);
   resetDeviceType;
   setTag(NULL);                        -- restoreTag := NULL
   setStandby(NULL);
   setGuid(NULL);
   versionCounter := 1;                 -- for getPackageVersion
   getArchivedLogCursor  := NULL;
   getBackupPieceCursor  := NULL;
   getDatafileCopyCursor := NULL;
   getDatafileCursor     := NULL;
   getProxyCopyCursor    := NULL;
   localOrsSiteKey       := NULL;
 
   IF (transclause) THEN
      deb(DEB_PRINT, 'reset transclause');
      resetAlTransClause;                  -- reset AlTransClause
      resetDBTransClause;                  -- reset DBTransClause
      resetDbidTransClause;                -- reset DbidTransClause
      resetPdbIdList;                      -- reset PdbIdList
      resetPdbNameList;                    -- reset PdbNameList
      resetPdbFileList;                    -- reset PdbFileList
   END IF;
   resetBsRecCache(FALSE);              -- reset findvalid backupset cache
 
   setRcvRecBackupAge(0);               -- reset backup age variables
   setRecoveryDestFile(FALSE);          -- reset to all files
   setOrsFile(NULL, NULL);              -- reset to all files
   findSpfileBackupCursor      := FALSE;
   findControlfileBackupCursor := FALSE;
 
--
   rcvRecCursor.currc1.type_con := to_number(null);
   rcvRecCursor.reqfno := to_number(null);
   rcvRecCursor.reqcrescn := to_number(null);
   rcvRecCursor.reqpluginSCN := 0;
   rcvRecCursor.excludeAction := 0;
 
--
   resetrcvRecStack;
 
   pname_i := 0;                        -- reset debuging
 
   IF findControlfileBackup_c%ISOPEN THEN
      CLOSE findControlfileBackup_c;
   END IF;
   IF findSpfileBackup_c%ISOPEN THEN
      CLOSE findSpfileBackup_c;
   END IF;
   IF findControlFileCopyKey%ISOPEN THEN
      CLOSE findControlFileCopyKey;
   END IF;
   IF findDatafileCopyKey%ISOPEN THEN
      CLOSE findDatafileCopyKey;
   END IF;
   IF findDatafileBackup_c%ISOPEN THEN
      CLOSE findDatafileBackup_c;
   END IF;
   IF findProxyCopy%ISOPEN THEN
      CLOSE findProxyCopy;
   END IF;
   IF findProxyCopyKey%ISOPEN THEN
      CLOSE findProxyCopyKey;
   END IF;
   IF findArchivedLogCopy%ISOPEN THEN
      CLOSE findArchivedLogCopy;
   END IF;
   IF findArcLogBackup%ISOPEN THEN
      CLOSE findArcLogBackup;
   END IF;
   IF findRangeArcLogBackup%ISOPEN THEN
      CLOSE findRangeArcLogBackup;
   END IF;
   IF findValidBackupSet_c%ISOPEN THEN
      CLOSE findValidBackupSet_c;
   END IF;
   IF findValidBackupSet1P_c%ISOPEN THEN
      CLOSE findValidBackupSet1P_c;
   END IF;
   IF findBackupPiece_c%ISOPEN THEN
      CLOSE findBackupPiece_c;
   END IF;
   IF findBackupPieceBpKey%ISOPEN THEN
      CLOSE findBackupPieceBpKey;
   END IF;
   IF findBackupPieceBsKey1%ISOPEN THEN
      CLOSE findBackupPieceBsKey1;
   END IF;
   IF findBackupPieceBsKey2%ISOPEN THEN
      CLOSE findBackupPieceBsKey2;
   END IF;
   IF translateDatabase_c%ISOPEN THEN
      CLOSE translateDatabase_c;
   END IF;
   IF translateDatabaseOfPdbId_c%ISOPEN THEN
      CLOSE translateDatabaseOfPdbId_c;
   END IF;
   IF translateDatabaseOfPdbIdL_c%ISOPEN THEN
      CLOSE translateDatabaseOfPdbIdL_c;
   END IF;
   IF translateTablespace_c%ISOPEN THEN
      CLOSE translateTablespace_c;
   END IF;
   IF translateDatafileName%ISOPEN THEN
      CLOSE translateDatafileName;
   END IF;
   IF translateDatafileNumber%ISOPEN THEN
      CLOSE translateDatafileNumber;
   END IF;
   IF translateDatafileCheckpoint%ISOPEN THEN
      CLOSE translateDatafileCheckpoint;
   END IF;
   IF translateAllDf_c%ISOPEN THEN
      CLOSE translateAllDf_c;
   END IF;
   IF translateAllDfOfPdbId_c%ISOPEN THEN
      CLOSE translateAllDfOfPdbId_c;
   END IF;
   IF translateAllDfOfPdbIdL_c%ISOPEN THEN
      CLOSE translateAllDfOfPdbIdL_c;
   END IF;
   IF translateCorruptList_c%ISOPEN THEN
      CLOSE translateCorruptList_c;
   END IF;
   IF translateTempfile_c%ISOPEN THEN
      CLOSE translateTempfile_c;
   END IF;
   IF translateTempfileOfPdbId_c%ISOPEN THEN
      CLOSE translateTempfileOfPdbId_c;
   END IF;
   IF translateTempfileOfPdbIdL_c%ISOPEN THEN
      CLOSE translateTempfileOfPdbIdL_c;
   END IF;
   IF translateTempfileName_c%ISOPEN THEN
      CLOSE translateTempfileName_c;
   END IF;
   IF translateTempfileNumber_c%ISOPEN THEN
      CLOSE translateTempfileNumber_c;
   END IF;
   IF translateOnlineLogs_c%ISOPEN THEN
      CLOSE translateOnlineLogs_c;
   END IF;
   IF translateArcLogKey%ISOPEN THEN
      CLOSE translateArcLogKey;
   END IF;
   IF translateArcLogName%ISOPEN THEN
      CLOSE translateArcLogName;
   END IF;
   IF translateArcLogSeqRange%ISOPEN THEN
      CLOSE translateArcLogSeqRange;
   END IF;
   IF translateArcLogSeqRange2%ISOPEN THEN
      CLOSE translateArcLogSeqRange2;
   END IF;
   IF translateArcLogTimeRange%ISOPEN THEN
      CLOSE translateArcLogTimeRange;
   END IF;
   IF translateArcLogTimeRange2%ISOPEN THEN
      CLOSE translateArcLogTimeRange2;
   END IF;
   IF translateArcLogSCNRange%ISOPEN THEN
      CLOSE translateArcLogSCNRange;
   END IF;
   IF translateArcLogSCNRange2%ISOPEN THEN
      CLOSE translateArcLogSCNRange2;
   END IF;
   IF translateArcLogPattern%ISOPEN THEN
      CLOSE translateArcLogPattern;
   END IF;
   IF lbal2%ISOPEN THEN
      CLOSE lbal2;
   END IF;
   IF ldbi%ISOPEN THEN
      CLOSE ldbi;
   END IF;
   IF lnni%ISOPEN THEN
      CLOSE lnni;
   END IF;
   IF lrtbs%ISOPEN THEN
      CLOSE lrtbs;
   END IF;
   IF getOfflineRangeCopy_c%ISOPEN THEN
      CLOSE getOfflineRangeCopy_c;
   END IF;
   IF rddf%ISOPEN THEN
      CLOSE rddf;
   END IF;
   IF translateDatabaseCorruption_c%ISOPEN THEN
      CLOSE translateDatabaseCorruption_c;
   END IF;
   IF findConfig_c%ISOPEN THEN
      CLOSE findConfig_c;
   END IF;
   IF findBackupsetFiles%ISOPEN THEN
      CLOSE findBackupsetFiles;
   END IF;
   IF findAllBackupPiece%ISOPEN THEN
      CLOSE findAllBackupPiece;
   END IF;
   IF dfBackupHistory_c1%ISOPEN THEN
      CLOSE dfBackupHistory_c1;
   END IF;
   IF dfBackupHistory_c2%ISOPEN THEN
      CLOSE dfBackupHistory_c2;
   END IF;
   IF dcBackupHistory_c%ISOPEN THEN
      CLOSE dcBackupHistory_c;
   END IF;
   IF alBackupHistory_c1%ISOPEN THEN
      CLOSE alBackupHistory_c1;
   END IF;
   IF alBackupHistory_c2%ISOPEN THEN
      CLOSE alBackupHistory_c2;
   END IF;
   IF bsBackupHistory_c1%ISOPEN THEN
      CLOSE bsBackupHistory_c1;
   END IF;
   IF bsBackupHistory_c1%ISOPEN THEN
      CLOSE bsBackupHistory_c1;
   END IF;
   IF getCopyofDatafile_c%ISOPEN THEN
      CLOSE getCopyofDatafile_c;
   END IF;
   IF getCopyofDatafile_c2%ISOPEN THEN
      CLOSE getCopyofDatafile_c2;
   END IF;
   IF rcvRecCursor1_c%ISOPEN THEN
      CLOSE rcvRecCursor1_c;
   END IF;
   IF rcvRecCursor1Filter_c%ISOPEN THEN
      CLOSE rcvRecCursor1Filter_c;
   END IF;
   IF rcvRecCursor2_c%ISOPEN THEN
      CLOSE rcvRecCursor2_c;
   END IF;
   IF listBackup_c%ISOPEN THEN
      CLOSE listBackup_c;
   END IF;
   IF translatePdbName_c%ISOPEN THEN
      CLOSE translatePdbName_c;
   END IF;
   IF translatePdbFile_c%ISOPEN THEN
      CLOSE translatePdbFile_c;
   END IF;
   getArchivedLogLast   := NULL;             -- clear for next time
   getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
   getArchivedLogOnlyrdf := 0;
   lbacked_al_next_scn := NULL;
   standby_became_primary_scn := NULL;
   getrcvRecLast := NULL;
   this_stdby_controlfile_scn := NULL;
END resetAll;
 
--
--
--
 
--
PROCEDURE findValidBackupSet(
   backupSetRec            IN     rcvRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL)  -- for compat.
IS
BEGIN
   deb(DEB_ENTER, 'findValidBackupSet');
   IF (bsRecCacheEnabled) THEN
      cacheFindValidBackupSet(
         bsRec         => backupSetRec,
         deviceType    => deviceType,
         tag           => tag,
         availableMask => NVL(availableMask,
            computeAvailableMask(available, unavailable, deleted, expired)));
   ELSE
      findValidBackupSet(
         bsKey         => backupSetRec.bsKey_con,
         pieceCount    => backupSetRec.pieceCount_con,
         deviceType    => deviceType,
         tag           => tag,
         availableMask => NVL(availableMask,
            computeAvailableMask(available, unavailable, deleted, expired)));
   END IF;
   deb(DEB_EXIT);
END findValidBackupSet;
 
--
--
PROCEDURE findValidBackupSet(
   backupSetRec            IN     bsRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL)  -- for compat.
IS
BEGIN
   deb(DEB_ENTER, 'findValidBackupSet bsRec_t');
   findValidBackupSet(bsKey         => backupSetRec.key,
                      pieceCount    => backupSetRec.pieceCount,
                      deviceType    => deviceType,
                      tag           => tag,
                      availableMask => NVL(availableMask,
                          computeAvailableMask(available, unavailable, deleted,
                                               expired)));
   deb(DEB_EXIT);
END findValidBackupSet;
 
--
 
--
PROCEDURE getDatafile(
   file#                        OUT number
  ,crescn                       OUT number
  ,creation_time                OUT date
  ,fname                        OUT varchar2
  ,ts_name                      OUT varchar2
  ,status                       OUT number
  ,blksize                      OUT number
  ,kbytes                       OUT number
  ,blocks                       OUT number
  ,unrecoverable_change#        OUT number
  ,stop_change#                 OUT number
  ,read_only                    OUT number)
IS
   dfRec        dfRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFile_2');
   getDatafile(dfRec, oldClient => TRUE);
 
   file#                 := dfRec.dfNumber;
   crescn                := dfRec.dfCreationSCN;
   creation_time         := dfRec.dfCreationTime;
   fname                 := dfRec.fileName;
   ts_name               := dfRec.tsName;
   status                := 0; -- this is kccfesta, which we don't have
   blksize               := dfRec.blockSize;
   kbytes                := dfRec.kbytes;
   blocks                := dfRec.blocks;
   unrecoverable_change# := 0; -- this is kccfeurs which isn't kept in rcvcat
   stop_change#          := dfRec.stopSCN;
   read_only             := dfRec.readOnly;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
--
      file# := NULL;
   deb(DEB_EXIT, 'with no more records');
END getDatafile;
 
--
--
--
--
--
--
--
--
 
--
PROCEDURE listTranslateProxyDFRecid(
   recid              IN number
  ,stamp              IN number
  ,xdf_key            OUT number
  ,file#              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateProxyDFRecid');
--
--
--
--
--
 
   IF (recid <> rcvRec_last.recid_con OR
       stamp <> rcvRec_last.stamp_con) THEN
  select d.xdf_key, d.file#, d.status, d.handle, d.completion_time,
         d.checkpoint_change#, d.checkpoint_time
  into xdf_key, file#, status, handle, completion_time, checkpoint_change#,
       checkpoint_time
  from   rc_proxy_datafile d
  where  db_key = this_db_key
    and ((user_site_key  = d.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(d.site_key, this_site_key)))))
    and  d.recid = listTranslateProxyDFRecid.recid
    and  d.stamp = listTranslateProxyDFRecid.stamp
  union all
  select c.xcf_key, 0, c.status, c.handle, c.completion_time,
         c.checkpoint_change#, c.checkpoint_time
  from   rc_proxy_controlfile c
  where  db_key = this_db_key
    and ((user_site_key  = c.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(c.site_key, this_site_key)))))
    and  c.recid = listTranslateProxyDFRecid.recid
    and  c.stamp = listTranslateProxyDFRecid.stamp;
 
   ELSE
      deb(DEB_PRINT, 'listTranslateProxyDFRecid: using cached rcvRec_last');
      xdf_key            := rcvRec_last.key_con;
      file#              := rcvRec_last.dfNumber_obj;
      status             := rcvRec_last.status_con;
      handle             := rcvRec_last.fileName_con;
      completion_time    := rcvRec_last.compTime_con;
      checkpoint_change# := rcvRec_last.toSCN_act;
      checkpoint_time    := rcvRec_last.toTime_act;
   END IF;
   deb(DEB_EXIT);
END listTranslateProxyDFRecid;
 
--
--
--
 
--
--
--
--
--
--
--
--
 
--
PROCEDURE findOfflineRangeCopy(
   offr_recid   IN number
  ,offr_ckpscn  IN number
  ,cf_cretime   IN date
  ,dbinc_key    IN number)
IS
BEGIN
   deb(DEB_ENTER, 'findOfflineRangeCopy');
   validateState(null);
 
   deb(DEB_OPEN, 'getOfflineRangeCopy_c');
   OPEN getOfflineRangeCopy_c(offrRecid  => offr_recid,
                              offrCkpSCN => offr_ckpscn,
                              cfCreTime  => cf_cretime,
                              dbincKey   => dbinc_key);
   deb(DEB_EXIT);
END findOfflineRangeCopy;
 
--
PROCEDURE getOfflineRangeCopy(
   rcvRec  OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'getOfflineRangeCopy');
   IF (NOT getOfflineRangeCopy_c%ISOPEN) THEN
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   FETCH getOfflineRangeCopy_c
    INTO rcvRec;
 
   IF (getOfflineRangeCopy_c%NOTFOUND) THEN
      CLOSE getOfflineRangeCopy_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   CLOSE getOfflineRangeCopy_c;
   deb(DEB_EXIT);
END getOfflineRangeCopy;
 
--
 
--
FUNCTION getOfflineRangeCopy
RETURN varchar2 IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getOfflineRangeCopy815');
   getOfflineRangeCopy(rcvRec);
   deb(DEB_EXIT, 'with: fileName');
   RETURN rcvRec.fileName_con;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: NULL');
      RETURN NULL;
END getOfflineRangeCopy;
 
--
--
--
 
--
FUNCTION computeRecoveryActions(
fno        IN number,   -- Datafile number.
crescn     IN number,   -- Datafile creation SCN.
df_rlgscn  IN number    -- Datafile resetlogs SCN.  Null unless we are doing
   default null,        -- a RECOVER, in which case is the value in the
--
df_rlgtime IN date      -- Datafile resetlogs time.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
df_ckpscn  IN number    -- Datafile checkpoint SCN.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
offlscn    IN number    -- kccfeofs (0 -> no offline range)
   default 0,
onlscn     IN number    -- kccfeonc (0 if offlscn is 0).
   default 0,
onltime    IN date      -- kccfonc_time
   default null,
cleanscn   IN number    -- kccfecps if either SOR or WCC set, else 0.
   default 0,
clean2scn  IN number    -- CF ckpt SCN if WCC set, infinity if SOR bit set
   default 0,           -- else 0.
clean2time IN date      -- controlfile ckpt time if WCC, SYSDATE if SOR, else
   default null,        -- this is ignored if cleanscn is 0
allowfuzzy IN boolean   -- TRUE if can be fuzzy at until SCN/time, FALSE if
  default FALSE,        -- not.  default is FALSE.
partial_rcv IN boolean  -- TRUE if can do partial recovery, FALSE if not.
  default FALSE,        -- A partial recovery would be to recover a datafile
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
cf_scn     IN number    -- controlfile ckpt SCN (NULL if none mounted)
  default NULL,
cf_cretime IN date      -- controlfile creation time (NULL if none mounted)
  default NULL,
cf_offrrid IN number    -- recid of oldest offline range in controlfile
  default NULL,         -- (NULL if none mounted)
allCopies  IN boolean
  default FALSE,
df_cretime IN DATE
  default NULL,
rmanCmd    IN binary_integer
  default unknownCmd_t,
foreignDbid   IN number
  default 0,
pluggedRonly  IN binary_integer
  default 0,
pluginSCN     IN number
  default 0,
pluginRlgSCN  IN number
  default 0,
pluginRlgTime IN date
  default NULL,
creation_thread IN number
  default NULL,
creation_size   IN number
  default NULL,
pdbId IN number
  default 1,
pdbForeignDbid IN number
  default 0)
RETURN binary_integer IS
   rc              boolean;
   last            number;
   this            number;
   succ_flag       boolean;
   thisAct         rcvRec_t;
   doingRecovery   boolean;
   lrmanCmd        binary_integer := rmanCmd;
   target_scn      number         := to_number(null);
BEGIN
   deb(DEB_ENTER, 'computeRecoveryActions');
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   deb(DEB_IN, '  fno:          '||fno);
   deb(DEB_IN, '  crescn:       '||crescn);
   deb(DEB_IN, '  df_rlgscn:    '||df_rlgscn);
   deb(DEB_IN, '  df_ckpscn:    '||to_char(df_ckpscn));
   deb(DEB_IN, '  offlscn:      '||to_char(offlscn));
   deb(DEB_IN, '  onlscn:       '||to_char(onlscn));
   deb(DEB_IN, '  cleanscn:     '||to_char(cleanscn));
   deb(DEB_IN, '  clean2scn:    '||to_char(clean2scn));
   deb(DEB_IN, '  cf_scn:       '||to_char(cf_scn));
   deb(DEB_IN, '  cf_offrrid:   '||to_char(cf_offrrid));
   deb(DEB_IN, '  foreignDbid:  '||to_char(foreignDbid));
   deb(DEB_IN, '  pluggedRonly: '||to_char(pluggedRonly));
   deb(DEB_IN, '  pluginSCN:    '||to_char(pluginSCN));
   deb(DEB_IN, '  pluginRlgSCN: '||to_char(pluginRlgSCN));
   deb(DEB_IN, '  creation_thread: '||to_char(creation_thread));
   deb(DEB_IN, '  creation_size:   '||to_char(creation_size));
   deb(DEB_IN, '  pdbid:           '||to_char(pdbId));
   deb(DEB_IN, '  pdbForeignDbid:  '||to_char(pdbForeignDbid));
 
   resetrcvRecStack;
 
   computeRA_restorable    := FALSE;
   computeRA_available     := FALSE;
   computeRA_rcvCopy_avail := FALSE;
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   IF (df_cretime is null AND  -- pre10g rman client
       lrmanCmd = unknownCmd_t AND
       df_ckpscn is not null) THEN
      deb(DEB_IN, 'rmanCmd set to recoverCmd_t for pre10g rman');
      lrmanCmd := recoverCmd_t;
   END IF;
 
   IF (lrmanCmd = rcvCopyCmd_t) THEN
      deb(DEB_PRINT, 'doing recover copy');
      doingRecovery := TRUE;
   ELSIF (lrmanCmd = recoverCmd_t) THEN
      deb(DEB_PRINT, 'doing recover');
      doingRecovery := TRUE;
   ELSIF (lrmanCmd = obsoleteCmd_t) THEN
      deb(DEB_PRINT, 'doing report obsolete');
      doingRecovery := NULL;
      IF (allCopies) THEN
--
--
--
--
         raise_application_error(-20999,
                                'internal error: computeRecoveryActions ' ||
                                'obsoleteCmd cannot be called with allCopies');
      END IF;
      IF (tc_database = FALSE#) THEN
--
--
         raise_application_error(-20999,
              'internal error: computeRecoveryActions ' ||
              'obsoleteCmd cannot be called for specific files');
      END IF;
   ELSIF (lrmanCmd = restoreCmd_t) THEN
      deb(DEB_PRINT, 'doing restore');
      doingRecovery := NULL;
   ELSIF (lrmanCmd = blkRestoreCmd_t) THEN
      deb(DEB_PRINT, 'doing block restore');
      doingRecovery := FALSE;
      target_scn := df_ckpscn;
   ELSIF (lrmanCmd = unknownCmd_t) THEN
      deb(DEB_PRINT, 'command unknown or called by pre-10i rman');
      doingRecovery := NULL;
   ELSE
      raise_application_error(-20999, 'internal error: computeRecoveryActions'
                              || ' rmanCmd='||nvl(to_char(lrmanCmd), 'NULL'));
   END IF;
 
   deb(DEB_IN, 'this_dbinc_key is:'||to_char(this_dbinc_key));
   rc := computeRecoveryActions2(fno, crescn, df_cretime,
                                df_rlgscn, df_rlgtime, df_ckpscn,
                                offlscn, onlscn, onltime,
                                cleanscn, clean2scn, clean2time,
                                allowfuzzy, partial_rcv,
                                target_scn, this_dbinc_key,
                                cf_scn, cf_cretime, cf_offrrid,
                                FALSE, succ_flag, allCopies, doingRecovery,
                                lrmanCmd, foreignDbid,
                                pluggedRonly, pluginSCN, pluginRlgSCN,
                                pluginRlgTime, creation_thread, creation_size,
                                pdbId, pdbForeignDbid);
 
   IF (succ_flag) THEN
      IF (rcvRecStack.count > 0) THEN
         IF (computeRA_allRecords = FALSE#) THEN
--
--
--
--
 
--
--
 
--
--
 
--
--
--
--
--
--
 
            last := rcvRecStack.count;
            deb(DEB_IN,'computeRecoveryActions: Top of stack='||
                       rcvRecStack.count);
            FOR this IN REVERSE 2..rcvRecStack.count - 1 LOOP
               IF ((rcvRecStack(last).toSCN_act >=
                    rcvRecStack(this-1).fromSCN_act)
                   AND NOT
--
                   (allCopies                       AND
                    ((rcvRecStack(last).key_con =
                      rcvRecStack(this).key_con   AND
                      rcvRecStack(last).type_con =
                      rcvRecStack(this).type_con) OR
                     (rcvRecStack(this-1).key_con =
                      rcvRecStack(this).key_con   AND
                      rcvRecStack(this-1).type_con =
                      rcvRecStack(this).type_con))))
                  THEN
                  deb(DEB_PRINT, 
                    'computeRecoveryActions: marking this action deleted:');
                  rcvRecGet(this, thisAct);
                  IF (debug) THEN
                     printRcvRec(thisAct);
                  END IF;
                  rcvRecStack(this).type_con :=
                     rcvRecStack(this).type_con + deleted_con_t;
               ELSE
--
                  last := this;
               END IF;
            END LOOP;
         END IF;                -- computeRA_allRecords = FALSE#
         deb(DEB_EXIT, 'with: SUCCESS');
         RETURN SUCCESS;
      ELSE
         deb(DEB_EXIT, 'with: NO_ACTION');
         RETURN NO_ACTION;      -- a recovery that can only use redo
      END IF;
   ELSIF (computeRA_available) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
      RETURN dbms_rcvman.AVAILABLE;
   ELSIF (computeRA_restorable) THEN
      deb(DEB_EXIT, 'with: RESTORABLE');
      RETURN RESTORABLE;
   ELSE
      deb(DEB_EXIT, 'with: UNAVAILABLE');
      RETURN dbms_rcvman.UNAVAILABLE;
   END IF;
 
END computeRecoveryActions;
 
--
--
--
 
--
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number
  ,key                 OUT number
  ,completion_time     OUT date)
RETURN number IS
   device_type rc_backup_piece.device_type%TYPE;
   mytype      number;
   set_stamp   number;
   set_count   number;
   pref        number;
   bsRec       bsRec_t;
   validRec    validBackupSetRec_t;
   rcvRec      rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'reportGetDFDel');
   FETCH rddf
    INTO pref, file#, mytype, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, incremental_change#, fuzzy_change#,
         recid, stamp, fname, set_stamp, set_count, key, completion_time,
         device_type;
   filetype := mytype;
   IF (rddf%found) THEN
      IF (mytype in (FULL_DF_BACKUP, INCREMENTAL_DF_BACKUP)) THEN
         findBackupSet(recid => recid,
                       stamp => stamp,
                       bsRec => bsRec);
--
--
         rcvRec.bsKey_con      := bsRec.key;
         rcvRec.elapseSecs_con := bsRec.elapseSecs;
         rcvRec.pieceCount_con := bsRec.pieceCount;
         restorable := validateBackupSet(
            backupSetRec           => rcvRec,
            checkDeviceIsAllocated => TRUE,
            availableMask          => dbms_rcvman.BSavailable,
            validRec               => validRec);
      ELSIF (mytype = OFFLINE_RANGE) THEN
         restorable := SUCCESS;
      ELSE
         IF (anyDevice = TRUE# OR
             isDeviceTypeAllocated(device_type) = TRUE#) THEN
            restorable := SUCCESS;
         ELSE
            restorable := dbms_rcvman.AVAILABLE;
         END IF;
      END IF;
      deb(DEB_EXIT, 'with: '||TRUE#);
      RETURN TRUE#;
   ELSE
      CLOSE rddf;
      deb(DEB_EXIT, 'with: '||FALSE#);
      RETURN FALSE#;
   END IF;
END reportGetDFDel;
 
--
--
--
 
--
FUNCTION getCloneName(
   fno    IN number
  ,crescn IN number
  ,pluscn IN number DEFAULT 0)
RETURN varchar2 IS
   fname rci_datafile.aux_name%TYPE;
BEGIN
   deb(DEB_ENTER, 'getCloneName');
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   SELECT aux_name
     INTO fname
     FROM rci_datafile_this_dbinc
    WHERE dbinc_key = this_dbinc_key
      AND (nvl(realf_site_key, translation_site_key) = site_key)
      AND file# = fno
      AND creation_change# = crescn
      AND plugin_change# = pluscn
      AND drop_change# IS NULL;
 
   deb(DEB_EXIT, 'with: '||fname);
   RETURN fname;
EXCEPTION
   WHEN no_data_found THEN
--
--
      deb(DEB_EXIT, 'with error 20218');
      raise_application_error(-20218,
                              'Datafile not found in recovery catalog');
   WHEN others THEN
      deb(DEB_EXIT, 'Just raising error');
      raise;
END getCloneName;
 
--
--
--
 
--
FUNCTION wasFileOffline(
   fno    IN number
  ,untilscn IN number)
RETURN number IS
   x     number;
BEGIN
   deb(DEB_ENTER, 'wasFileOffline');
  select 1
    into x
    from rc_offline_range ofr, rc_database_incarnation di
   where ofr.db_key = this_db_key
     and di.db_key = this_db_key
     and ofr.dbinc_key = di.dbinc_key
     and untilscn >= offline_change#
     and untilscn < online_change#
     and file# = fno;
 
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
 
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END wasFileOffline;
 
--
--
--
--
 
FUNCTION getmaxcopyno(
   bsstamp         IN    number
  ,bscount         IN    number)
RETURN number IS
   maxcopy number;
BEGIN
   select max(copy#)
      into maxcopy
      from rc_backup_piece  bp
      where bp.set_stamp = bsstamp
      and   bp.set_count = bscount
--
--
--
--
--
--
      and   bp.db_key = this_db_key;
   return maxcopy;
END getmaxcopyno;
 
--
FUNCTION getMaxDfNumber
RETURN number IS
   maxfile# number;
BEGIN
   select max(file#) into maxfile# from df;
   return maxfile#;
END getMaxDfNumber;
 
--
PROCEDURE getdropOSFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getdropOSFiles;
 
--
PROCEDURE getBackedUpFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getBackedUpFiles;
 
--
FUNCTION validateStandbyConfig(
   policy  IN  varchar2
  ,alldest IN  number)
RETURN NUMBER IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
   return dbms_rcvman.FALSE#;
END validateStandbyConfig;
 
--
PROCEDURE getSCNForAppliedPolicy(
   minscn    OUT  number
  ,rlgscn    OUT  number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getSCNForAppliedPolicy;
 
--
PROCEDURE getAppliedAl(
   first           IN   boolean
  ,agedFileRec     OUT  NOCOPY agedFileRec_t)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getAppliedAl;
 
--
PROCEDURE getRequiredSCN(
   reqscn   OUT  number
  ,rlgscn   OUT  number
  ,streams  IN   number DEFAULT 0
  ,alldest  IN   number DEFAULT 0)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getRequiredSCN;
 
--
PROCEDURE getAppliedSCN(
   appscn   OUT  number
  ,rlgscn   OUT  number
  ,alldest  IN   number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getAppliedSCN;
 
--
FUNCTION isBsRecCacheMatch(
   key         IN   number
  ,deviceType  IN   varchar2
  ,tag         IN   varchar2
  ,status      IN   varchar2)
RETURN NUMBER IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
   bucket := mod(key, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      RETURN FALSE#;
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = key) THEN
--
         IF (cacheBsRecTable.mask = BSavailable) THEN
            IF (status != 'A') THEN
               RETURN FALSE#;
            END IF;
         ELSIF (isStatusMatch(status, cacheBsRecTable.mask) = FALSE#) THEN
            RETURN FALSE#;
         END IF;
 
--
         IF (deviceType != cacheBsRecTable.deviceType) THEN
            RETURN FALSE#;
         END IF;
 
--
         IF (nvl(tag, '  ') != nvl(cacheBsRecTable.tag, nvl(tag, '  '))) THEN
            RETURN FALSE#;
         END IF;
 
--
         cacheBsRecTable.bsRec(sb4_bucket).bslist(i).mixcopy := TRUE;
 
         RETURN TRUE#;
      END IF;
   END LOOP;
   RETURN FALSE#;
END isBsRecCacheMatch;
 
--
PROCEDURE resetReclRecid
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END resetReclRecid;
 
--
PROCEDURE setReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END setReclRecid;
 
--
FUNCTION IsReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number)
RETURN NUMBER IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END IsReclRecid;
 
--
FUNCTION getSpaceRecl(ceilAsm IN binary_integer default 0)
RETURN NUMBER IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getSpaceRecl;
 
--
--
--
PROCEDURE getFlashbackInfo(
   fbUntilTime   OUT DATE
  ,minGrsp       OUT NUMBER)
IS
   clean_grsp   number;
   count_grsp   number;
BEGIN
   BEGIN
      SELECT nvl(oldest_flashback_time, MAXDATEVAL)
        INTO fbUntiltime
        FROM fb
       WHERE dbinc_key = this_dbinc_key
         AND db_unique_name = this_db_unique_name;
   EXCEPTION
      WHEN no_data_found THEN
         fbUntilTime := MAXDATEVAL;
   END;
 
   BEGIN
      SELECT min(to_scn),
             count(*),
             count(case when from_scn <= to_scn then 1 else 0 end)
        INTO minGrsp, count_grsp, clean_grsp
        FROM grsp, dbinc
       WHERE grsp.dbinc_key = dbinc.dbinc_key
         AND dbinc.db_key = this_db_key
         AND grsp.site_key = this_site_key
         AND grsp.guaranteed = 'YES'
         AND from_scn != 0;
 
--
--
      IF (clean_grsp = 1 AND count_grsp = 1) THEN
         minGrsp := MAXSCNVAL;
      END IF;
   EXCEPTION
      WHEN no_data_found THEN
         minGrsp := MAXSCNVAL;
   END;
 
   deb(DEB_PRINT, 'getFlashbackInfo: fbUntilTime=' || to_char(fbUntilTime) ||
                  ' minGrsp=' || minGrsp);
END getFlashbackInfo;
 
--
PROCEDURE openLbCursor(lbc  OUT NOCOPY lbCursor_t) IS
BEGIN
 
   IF (lbc%ISOPEN)
   THEN
     CLOSE lbc;
   END IF;
 
   OPEN lbc FOR
 
   SELECT
--
           bs.bs_key               list_order1,
           0                       list_order2,
           bs.bs_key               pkey,
           backupset_txt           backup_type,
           backupset_txt           file_type,
           decode(bs.keep_options,
                  0, 'NO',
                     'YES')        keep,
           bs.keep_until           keep_until,
           decode(bs.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         null)     keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bs.bs_recid             recid,
           bs.bs_stamp             stamp,
           null                    device_type,
           0                       block_size,
           bs.completion_time      completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           bs.bs_key               bs_key,
           bs.set_count            bs_count,
           bs.set_stamp            bs_stamp,
           decode(bs.bck_type,
                  'L', archivedlog_txt,
                       datafile_txt)
                                   bs_type,
           decode(bs.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(bs.bck_type, 'I', incr_txt, full_txt))
                                   bs_incr_type,
           bs.pieces               bs_pieces,
           null                    bs_copies,
           bs.completion_time      bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM  bs
    WHERE bs.db_key     = this_db_key
 
   UNION ALL
   SELECT
--
           bp.bs_key               list_order1,
           1                       list_order2,
           bp.bp_key               pkey,
           backupset_txt           backup_type,
           piece_txt               file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(bp.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           bp.handle               fname,
           bp.tag                  tag,
           bp.media                media,
           bp.bp_recid             recid,
           bp.bp_stamp             stamp,
           bp.device_type          device_type,
           0                       block_size,
           bp.completion_time      completion_time,
           bp.is_recovery_dest_file
                                   is_rdf,
           bp.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bp.bytes                bytes,
           bp.bs_key               bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           bp.piece#               bp_piece#,
           bp.copy#                bp_copy#,
           bp.vb_key               bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bp
    WHERE bp.db_key = this_db_key
      AND bp.status != 'D'
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           bdf.bs_key              list_order1,
           2                       list_order2,
           bdf.bdf_key             pkey,
           backupset_txt           backup_type,
           datafile_txt            file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bdf.bdf_recid           recid,
           bdf.bdf_stamp           stamp,
           null                    device_type,
           bdf.block_size          block_size,
           bdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bdf.block_size * bdf.blocks
                                   bytes,
           bdf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           decode(bdf.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(greatest(bdf.create_scn, bdf.incr_scn),
                         bdf.create_scn, full_txt, incr_txt))
                                   bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           bdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           bdf.create_scn          df_creation_change#,
           bdf.ckp_scn             df_checkpoint_change#,
           bdf.ckp_time            df_ckp_mod_time,
           bdf.incr_scn            df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bdf.dbinc_key
 
   UNION ALL
   SELECT
--
           bcf.bs_key              list_order1,
           2                       list_order2,
           bcf.bcf_key             pkey,
           backupset_txt           backup_type,
           controlfile_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bcf.bcf_recid           recid,
           bcf.bcf_stamp           stamp,
           null                    device_type,
           bcf.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bcf.block_size * bcf.blocks
                                   bytes,
           bcf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           bcf.ckp_scn             df_checkpoint_change#,
           bcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bcf.dbinc_key
 
   UNION ALL
   SELECT
--
           brl.bs_key              list_order1,
           2                       list_order2,
           brl.brl_key             pkey,
           backupset_txt           backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           brl.brl_recid           recid,
           brl.brl_stamp           stamp,
           null                    device_type,
           brl.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           brl.block_size * brl.blocks
                                   bytes,
           brl.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           brl.thread#             rl_thread#,
           brl.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           brl.low_scn             rl_first_change#,
           brl.low_time            rl_first_time,
           brl.next_scn            rl_next_change#,
           brl.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM brl, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = brl.dbinc_key
 
   UNION ALL
   SELECT
--
           bsf.bs_key              list_order1,
           2                       list_order2,
           bsf.bsf_key             pkey,
           backupset_txt           backup_type,
           spfile_txt              file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bsf.bsf_recid           recid,
           bsf.bsf_stamp           stamp,
           null                    device_type,
           0                       block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bsf.bytes               bytes,
           bsf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           0                       df_resetlogs_change#,
           0                       df_creation_change#,
           0                       df_checkpoint_change#,
           bsf.modification_time   df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           db_unique_name          sf_db_unique_name,
           null                    con_id
     FROM bsf
    WHERE bsf.db_key     = this_db_key
 
   UNION ALL
   SELECT
--
           cdf.cdf_key             list_order1,
           -1                      list_order2,
           cdf.cdf_key             pkey,
           copy_txt                backup_type,
           datafile_txt            file_type,
           decode(cdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           cdf.keep_until          keep_until,
           decode(cdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(cdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           cdf.fname               fname,
           cdf.tag                 tag,
           null                    media,
           cdf.cdf_recid           recid,
           cdf.cdf_stamp           stamp,
           'DISK'                  device_type,
           cdf.block_size          block_size,
           cdf.completion_time     completion_time,
           cdf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           cdf.block_size * cdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           cdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           cdf.create_scn          df_creation_change#,
           cdf.ckp_scn             df_checkpoint_change#,
           cdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM cdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = cdf.dbinc_key
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           ccf.ccf_key             list_order1,
           -1                      list_order2,
           ccf.ccf_key             pkey,
           copy_txt                backup_type,
           controlfile_txt         file_type,
           decode(ccf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           ccf.keep_until          keep_until,
           decode(ccf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(ccf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           ccf.fname               fname,
           ccf.tag                 tag,
           null                    media,
           ccf.ccf_recid           recid,
           ccf.ccf_stamp           stamp,
           'DISK'                  device_type,
           ccf.block_size          block_size,
           ccf.completion_time     completion_time,
           ccf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           ccf.ckp_scn             df_checkpoint_change#,
           ccf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM ccf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = ccf.dbinc_key
      AND ((user_site_key  = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
   UNION ALL
 
   SELECT
--
           al.al_key               list_order1,
           -1                      list_order2,
           al.al_key               pkey,
           copy_txt                backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(al.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           al.fname                fname,
           null                    tag,
           null                    media,
           al.al_recid             recid,
           al.al_stamp             stamp,
           'DISK'                  device_type,
           al.block_size           block_size,
           al.completion_time      completion_time,
           al.is_recovery_dest_file
                                   is_rdf,
           al.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           al.block_size * al.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           al.thread#              rl_thread#,
           al.sequence#            rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           al.low_scn              rl_first_change#,
           al.low_time             rl_first_time,
           al.next_scn             rl_next_change#,
           al.next_time            rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM dbinc,
          al
          LEFT OUTER JOIN
          grsp
          ON al.next_scn   >= grsp.from_scn
         AND al.low_scn    <= (grsp.to_scn + 1)
         AND al.dbinc_key   = grsp.dbinc_key
         AND grsp.from_scn <= grsp.to_scn   -- filter clean grp
         AND grsp.from_scn != 0
         AND grsp.guaranteed = 'YES'
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = al.dbinc_key
      AND al.archived       = 'Y'
      AND grsp.from_scn is null
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = al.site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(al.site_key, this_site_key)))))) OR
           (client_site_aware = FALSE#))
 
   UNION ALL
 
   SELECT
--
           xdf.xdf_key             list_order1,
           -1                      list_order2,
           xdf.xdf_key             pkey,
           proxycopy_txt           backup_type,
           datafile_txt            file_type,
           decode(xdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xdf.keep_until          keep_until,
           decode(xdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xdf.handle              fname,
           xdf.tag                 tag,
           xdf.media               media,
           xdf.xdf_recid           recid,
           xdf.xdf_stamp           stamp,
           xdf.device_type         device_type,
           xdf.block_size          block_size,
           xdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xdf.block_size * xdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           xdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           xdf.create_scn          df_creation_change#,
           xdf.ckp_scn             df_checkpoint_change#,
           xdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xdf.dbinc_key
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           xcf.xcf_key             list_order1,
           -1                      list_order2,
           xcf.xcf_key             pkey,
           proxycopy_txt           backup_type,
           controlfile_txt         file_type,
           decode(xcf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xcf.keep_until          keep_until,
           decode(xcf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xcf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xcf.handle              fname,
           xcf.tag                 tag,
           xcf.media               media,
           xcf.xcf_recid           recid,
           xcf.xcf_stamp           stamp,
           xcf.device_type         device_type,
           xcf.block_size          block_size,
           xcf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           xcf.ckp_scn             df_checkpoint_change#,
           xcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xcf.dbinc_key
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           xal.xal_key             list_order1,
           -1                      list_order2,
           xal.xal_key             pkey,
           proxycopy_txt           backup_type,
           archivedlog_txt         file_type,
           decode(xal.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xal.keep_until          keep_until,
           decode(xal.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xal.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xal.handle              fname,
           xal.tag                 tag,
           xal.media               media,
           xal.xal_recid           recid,
           xal.xal_stamp           stamp,
           xal.device_type         device_type,
           xal.block_size          block_size,
           xal.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xal.block_size * xal.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           xal.thread#             rl_thread#,
           xal.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           xal.low_scn             rl_first_change#,
           xal.low_time            rl_first_time,
           xal.next_scn            rl_next_change#,
           xal.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xal, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = xal.dbinc_key
      AND ((user_site_key   = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
   ORDER BY list_order1, list_order2, bp_piece#;
 
END openLbCursor;
 
--
--
FUNCTION DbUniqueNameIsStandby
    RETURN NUMBER
IS
   is_standby number;
BEGIN
   deb(DEB_ENTER, 'DbUniqueNameIsStandby');
 
   IF NOT this_dummy_instance THEN
--
--
      SELECT count(*) INTO is_standby FROM node
      WHERE node.db_key = this_db_key
        AND node.db_unique_name = this_db_unique_name
        AND node.database_role = 'STANDBY';
   END IF;
 
   IF is_standby is NULL THEN
      is_standby := 0;
   END IF;
   deb(DEB_EXIT, ' with ' || is_standby);
   return is_standby;
END DbUniqueNameIsStandby;
 
--
--
--
PROCEDURE clrSiteName
IS
BEGIN
  deb(DEB_ENTER, 'clrSiteName, user_site_key, realf_site_key set to null');
  user_site_key := NULL;
  realf_site_key := NULL;
  user_db_unique_name := NULL;
  deb(DEB_EXIT);
END clrSiteName;
 
--
FUNCTION getSiteKey(db_unique_name IN VARCHAR2)
   RETURN NUMBER
IS
   resynced     NUMBER;
   ret_site_key NUMBER;
BEGIN
--
--
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'database not set');
   END IF;
 
--
   SELECT count(*) INTO resynced FROM node
      WHERE node.db_unique_name = upper(getSiteKey.db_unique_name)
        AND node.db_key = this_db_key;
 
   IF resynced = 0 THEN
      raise_application_error(-20243,
                              getSiteKey.db_unique_name ||
                              'site unknown to recovery catalog:');
   END IF;
 
   SELECT site_key into ret_site_key FROM node
      WHERE node.db_unique_name = upper(getSiteKey.db_unique_name)
        AND node.db_key = this_db_key;
 
   RETURN ret_site_key;
END getSiteKey;
 
--
FUNCTION getSiteName(site_key IN NUMBER)
   RETURN VARCHAR2
IS
   ldb_unique_name node.db_unique_name%TYPE;
BEGIN
   deb(DEB_ENTER, 'getSiteName, site_key=' || site_key);
   SELECT db_unique_name INTO ldb_unique_name FROM node
   WHERE site_key = getSiteName.site_key;
   deb(DEB_EXIT, ' with ' || ldb_unique_name);
   RETURN ldb_unique_name;
END getSiteName;
 
--
PROCEDURE setSiteName(db_unique_name IN VARCHAR2,
                      for_realfiles  IN NUMBER)
IS
BEGIN
   deb(DEB_ENTER, 'setSiteName'||db_unique_name);
   If db_unique_name IS NOT NULL THEN
      IF for_realfiles != 0 THEN
        realf_site_key := getSiteKey(db_unique_name);
      ELSE
        user_site_key := getSiteKey(db_unique_name);
        user_db_unique_name := upper(db_unique_name);
      END IF;
      deb(DEB_PRINT, 'user_site_key='|| user_site_key);
      deb(DEB_PRINT, 'realf_site_key='  || realf_site_key);
      deb(DEB_PRINT, 'user_db_unique_name='||user_db_unique_name);
   END IF;
   deb(DEB_EXIT);
END setSiteName;
 
--
--
PROCEDURE setArchiveFileScopeAttributes(logs_shared  IN NUMBER) IS
BEGIN
   deb(DEB_ENTER, 'setArchiveFileScopeAttributes');
 
   IF logs_shared > 0 THEN
      dbms_rcvman.logs_shared := TRUE#;
   ELSE
      dbms_rcvman.logs_shared := FALSE#;
   END IF;
   deb(DEB_PRINT, 'logs_shared = ' || dbms_rcvman.logs_shared);
 
   deb(DEB_EXIT);
END setArchiveFileScopeAttributes;
 
--
--
PROCEDURE setFirstFullBckScopeAttributes(baseline_cap IN NUMBER) IS
BEGIN
   deb(DEB_ENTER, 'setFirstFullBckScopeAttributes');
 
   this_baseline_cap := baseline_cap;
   this_baseline_cap_scn := NULL;
 
   deb(DEB_PRINT, 'baseline_cap = ' || this_baseline_cap);
 
   deb(DEB_EXIT);
END setFirstFullBckScopeAttributes;
 
--
--
PROCEDURE setBackupFileScopeAttributes(
                 disk_backups_shared IN NUMBER,
                 tape_backups_shared IN NUMBER) IS
   lsite_key NUMBER;
BEGIN
   deb(DEB_ENTER, 'setBackupFileScopeAttributes');
 
   IF disk_backups_shared IS NOT NULL THEN
      IF disk_backups_shared > 0 THEN
         dbms_rcvman.disk_backups_shared := TRUE#;
      ELSE
         dbms_rcvman.disk_backups_shared := FALSE#;
      END IF;
   END IF;
 
   IF tape_backups_shared IS NOT NULL THEN
      IF tape_backups_shared > 0 THEN
         dbms_rcvman.tape_backups_shared := TRUE#;
      ELSE
         dbms_rcvman.tape_backups_shared := FALSE#;
      END IF;
   END IF;
 
   deb(DEB_PRINT, 'disk_backups_shared='||dbms_rcvman.disk_backups_shared);
   deb(DEB_PRINT, 'tape_backups_shared='||dbms_rcvman.tape_backups_shared);
 
   deb(DEB_EXIT);
END setBackupFileScopeAttributes;
 
--
PROCEDURE addBackupToMKL(lbMkTab       IN OUT NOCOPY rcvRecTabII_t
                        ,rcvRec        IN rcvRec_t) IS
   nelem       number;              -- number of elements in each bucket
   key         number;              -- key to be added to table
   bucket      number;
   i           binary_integer;
   rcvRecI     rcvRecTabI_t;
BEGIN
   IF (rcvRec.type_con = backupSet_con_t) THEN
      key := rcvRec.bsKey_con;
   ELSIF (rcvRec.type_con = imageCopy_con_t OR
          rcvRec.type_con = proxyCopy_con_t) THEN
      key := rcvRec.key_con;
   ELSE
      raise_application_error(-20999, 'internal error: addBackupToMKL' ||
                              ' type=' || rcvRec.type_con);
   END IF;
 
   bucket := mod(key, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      i := CONST2GVAL - bucket;
   ELSE
      i := bucket;
   END IF;
 
   IF (NOT lbMkTab.exists(i)) THEN
      lbMkTab(i) := rcvRecI;
   END IF;
 
--
   nelem := lbMkTab(i).count;
   IF (nelem > 0) THEN
      FOR j in 0 ..nelem-1 LOOP
         IF (rcvRec.type_con = lbMkTab(i)(j).type_con) THEN
--
            IF (rcvRec.type_con = backupSet_con_t  AND
                (lbMkTab(i)(j).bsKey_con = rcvRec.bsKey_con OR
                (lbMkTab(i)(j).setStamp_con = rcvRec.setStamp_con AND
                 lbMkTab(i)(j).setCount_con = rcvRec.setCount_con))) THEN
               RETURN;
            ELSIF ((rcvRec.type_con = imageCopy_con_t    AND
                    rcvRec.type_con = proxyCopy_con_t) OR
                   lbMkTab(i)(j).recid_con = rcvRec.recid_con AND
                   lbMkTab(i)(j).stamp_con = rcvRec.stamp_con AND
                   lbMkTab(i)(j).key_con   = rcvRec.key_con) THEN
               RETURN;
            END IF;
         END IF;
      END LOOP;
   END IF;
 
   lbMkTab(i)(nelem) := rcvRec;
END addBackupToMKL;
 
--
--
FUNCTION listBackupInMKL(lbMkTab       IN rcvRecTabII_t
                        ,lbRec         IN lbRec_t)
RETURN BOOLEAN IS
   nelem       number;               -- number of elements in each bucket
   key         number;               -- key in question?
   bucket      number;
   i           binary_integer;
BEGIN
   IF (lbRec.backup_type = backupset_txt) THEN
      key := lbRec.bs_key;
   ELSIF (lbRec.backup_type = copy_txt OR
          lbRec.backup_type = proxycopy_txt) THEN
      key := lbRec.pkey;
   ELSE
      raise_application_error(-20999, 'internal error: listBackupToMKL' ||
                              ' type=' || lbRec.backup_type);
   END IF;
 
   bucket := mod(key, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      i := CONST2GVAL - bucket;
   ELSE
      i := bucket;
   END IF;
 
   IF (NOT lbMkTab.exists(i)) THEN
      RETURN FALSE;
   END IF;
 
   nelem := lbMkTab(i).count;
   FOR j in 0 ..nelem-1 LOOP
--
      IF (lbMkTab(i)(j).type_con = backupSet_con_t  AND
          lbRec.backup_type = backupset_txt      AND
          (lbMkTab(i)(j).bsKey_con = lbRec.bs_key OR
           (lbMkTab(i)(j).setStamp_con = lbRec.bs_stamp AND
            lbMkTab(i)(j).setCount_con = lbRec.bs_count))) THEN
         RETURN TRUE;
      ELSIF (((lbMkTab(i)(j).type_con = imageCopy_con_t    AND
               lbRec.backup_type = copy_txt) OR
              (lbMkTab(i)(j).type_con = proxyCopy_con_t    AND
               lbRec.backup_type = proxycopy_txt))  AND
              lbMkTab(i)(j).recid_con = lbRec.recid AND
              lbMkTab(i)(j).stamp_con = lbRec.stamp AND
              lbMkTab(i)(j).key_con   = lbRec.pkey) THEN
         RETURN TRUE;
      END IF;
   END LOOP;
 
   RETURN FALSE;
END listBackupInMKL;
 
--
--
--
PROCEDURE SetGetSinceLastBackedAL(ntimes  IN number DEFAULT 1,
                                  devtype IN varchar2 DEFAULT NULL,
                                  sbpscn  IN number) IS
  last_alrec sinceLastBackedAL_c%ROWTYPE;
BEGIN
  deb(DEB_ENTER, 'SetGetSinceLastBackedAl');
 
--
  lbacked_al_next_scn        := 0;
  standby_became_primary_scn := 0;
 
  IF client_site_aware = TRUE# or sbpscn IS NULL or sbpscn = 0 THEN
    deb(DEB_IN, 'SetGetSinceLastBackedAl: lbacked_al_next_scn is 0');
  ELSE
--
--
--
--
    standby_became_primary_scn := sbpscn + 1;
 
    OPEN sinceLastBackedAL_c(devtype, ntimes);
    FETCH sinceLastBackedAL_c into last_alrec;
    IF NOT sinceLastBackedAL_c%NOTFOUND  THEN
      lbacked_al_next_scn := nvl(last_alrec.next_scn,
                                 last_alrec.low_scn);
    END IF;
    CLOSE sinceLastBackedAL_c;
  END IF;
  deb(DEB_IN, 'SetGetSinceLastBackedAl: al_next_scn=' || lbacked_al_next_scn ||
              ' sbpscn=' || standby_became_primary_scn);
  deb(DEB_EXIT, 'SetGetSinceLastBackedAl');
END SetGetSinceLastBackedAL;
 
--
FUNCTION getEncryptTSCount RETURN BINARY_INTEGER IS
   encrypt_ts_count NUMBER;
BEGIN
   SELECT  count(*) into encrypt_ts_count FROM rc_tablespace
      WHERE dbinc_key=this_dbinc_key AND
            encrypt_in_backup = 'ON';
 
   RETURN encrypt_ts_count;
END getEncryptTSCount;
 
--
--
--
--
--
FUNCTION getArchivedNextSCN
RETURN NUMBER IS
   mySCN        number;
BEGIN
   deb(DEB_ENTER, 'getArchivedNextSCN');
   SELECT nvl(max(al.next_scn),0)
     INTO mySCN
     FROM al,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE al.archived = 'Y'
      AND al.dbinc_key = d2.dbinc_key
      AND (d2.next_reset_scn IS NULL OR
           (al.low_scn >= d2.reset_scn AND
            al.low_scn < d2.next_reset_scn));
 
   SELECT greatest(nvl(max(brl.next_scn), 0), mySCN)
     INTO mySCN
     FROM brl,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE brl.dbinc_key = d2.dbinc_key
      AND (d2.next_reset_scn IS NULL OR
           (brl.low_scn >= d2.reset_scn AND
            brl.low_scn <  d2.next_reset_scn));
 
   SELECT greatest(nvl(max(xal.next_scn), 0), mySCN)
     INTO mySCN
     FROM xal,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE xal.dbinc_key = d2.dbinc_key
      AND (d2.next_reset_scn IS NULL OR
           (xal.low_scn  >= d2.reset_scn AND
            xal.low_scn  <  d2.next_reset_scn));
 
   deb(DEB_EXIT, 'with '||to_char(mySCN));
   RETURN mySCN;
END getArchivedNextSCN;
 
--
FUNCTION isArchivedLogMissing(fromSCN IN NUMBER, untilSCN IN NUMBER)
RETURN number IS
   thread    number;
   sequence  number;
   dbinc_key number;
BEGIN
   deb(DEB_ENTER, 'isArchivedLogMissing');
   deb(DEB_IN, 'fromSCN ='  || nvl(to_char(fromSCN), 'NULL') ||
               ' untilSCN=' || nvl(to_char(untilSCN), 'NULL'));
 
--
--
   SELECT thread#, sequence#, dbinc_key
     INTO thread, sequence, dbinc_key
     FROM (SELECT dbinc_key, thread#, sequence#, lead(sequence#, 1, sequence#+1)
             OVER (PARTITION BY thread#, dbinc_key
                       ORDER BY sequence#) nextseq
             FROM (SELECT al.thread#, al.sequence#, al.dbinc_key
                     FROM al,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                    WHERE al.dbinc_key = d2.dbinc_key
                      AND (d2.next_reset_scn IS NULL OR
                           (al.low_scn  >= d2.reset_scn AND
                            al.low_scn  <  d2.next_reset_scn))
                      AND low_scn >= fromSCN
                      AND (untilSCN IS NULL OR low_scn < untilSCN)
 
                   UNION ALL
 
                   SELECT brl.thread#, brl.sequence#, brl.dbinc_key
                     FROM brl,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                    WHERE brl.dbinc_key = d2.dbinc_key
                      AND (d2.next_reset_scn IS NULL OR
                           (brl.low_scn  >= d2.reset_scn AND
                            brl.low_scn  <  d2.next_reset_scn))
                      AND low_scn >= fromSCN
                      AND (untilSCN IS NULL OR low_scn < untilSCN)
 
                   UNION ALL
 
                   SELECT xal.thread#, xal.sequence#, xal.dbinc_key
                     FROM xal,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                    WHERE xal.dbinc_key = d2.dbinc_key
                      AND (d2.next_reset_scn IS NULL OR
                           (xal.low_scn  >= d2.reset_scn AND
                            xal.low_scn  <  d2.next_reset_scn))
                      AND low_scn >= fromSCN
                      AND (untilSCN IS NULL OR low_scn < untilSCN))
          )
   WHERE nextseq NOT IN (sequence#, sequence#+1)
     AND rownum = 1;
 
   deb(DEB_IN, 'missing sequence is (dbinc_key, thread, sequence)=('||
               to_char(dbinc_key)  || ',' ||
               to_char(thread)     || ',' ||
               to_char(sequence+1) || ')');
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE#;
END isArchivedLogMissing;
 
--
FUNCTION getMaxRedoSCN(maxScn      OUT NUMBER,
                       maxTime     OUT DATE,
                       maxDbIncKey OUT NUMBER,
                       maxRlgScn   OUT NUMBER,
                       maxRlgTime  OUT DATE,
                       isOrs       IN  NUMBER)
RETURN boolean IS
 
highScn  number;
highTime date;
dbIncKey number;
rlgscn   number;
 
BEGIN
  deb(DEB_ENTER,'getMaxRedoSCN');
 
  SELECT next_scn, next_time, dbinc_key, reset_scn
    INTO highScn, highTime, dbIncKey, rlgscn
  FROM
    (SELECT next_scn, next_time, dbinc_key, reset_scn
       FROM (SELECT (CASE 
                 WHEN al.next_scn > d2.next_reset_scn THEN d2.next_reset_scn 
                 ELSE al.next_scn END) next_scn,
                 al.next_time, al.dbinc_key, d2.reset_scn
              FROM al,
                   (SELECT dbinc_key,
                           reset_scn,
                           PRIOR reset_scn next_reset_scn
                      FROM dbinc
                      START WITH dbinc_key = this_dbinc_key
                      CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                      UNION ALL
                      SELECT this_dbinc_key dbinc_key,
                             null           reset_scn,
                             null           next_reset_scn
                        FROM dual) d2
              WHERE al.dbinc_key = d2.dbinc_key
                AND (d2.next_reset_scn IS NULL OR
                     (al.low_scn  >= d2.reset_scn AND
                      al.low_scn  <  d2.next_reset_scn))
                AND (isOrs = TRUE# OR 
                     (restoreRangeDevTyp IN ('RC$DISK', 'RC$ANY')))
                AND (localOrsSiteKey IS NULL OR localOrsSiteKey = al.site_key) 
                AND ((client_site_aware = TRUE# AND
                      ((user_site_key = al.site_key) OR
                       (user_site_key IS NULL AND
                        (logs_shared = TRUE# OR
                         this_site_key = nvl(al.site_key, this_site_key))))) OR
                     (client_site_aware = FALSE#))
 
             UNION ALL
 
             SELECT (CASE
                 WHEN brl.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                 ELSE brl.next_scn END) next_scn, 
                 brl.next_time, brl.dbinc_key, d2.reset_scn
               FROM brl, bp,
                    (SELECT dbinc_key,
                            reset_scn,
                            PRIOR reset_scn next_reset_scn
                       FROM dbinc
                       START WITH dbinc_key = this_dbinc_key
                       CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                       UNION ALL
                       SELECT this_dbinc_key dbinc_key,
                              null           reset_scn,
                              null           next_reset_scn
                         FROM dual) d2
               WHERE brl.bs_key = bp.bs_key
                 AND brl.dbinc_key = d2.dbinc_key
                 AND (d2.next_reset_scn IS NULL OR
                       (brl.low_scn  >= d2.reset_scn AND
                          brl.low_scn  <  d2.next_reset_scn))
                 AND (isOrs = TRUE# OR 
                      ((restoreRangeDevTyp = 'RC$DISK' AND 
                        bp.device_type = 'DISK') OR 
                       (restoreRangeDevTyp = 'RC$SBT' AND
                        bp.device_type = 'SBT_TAPE') OR 
                       restoreRangeDevTyp = 'RC$ANY'))
                 AND (localOrsSiteKey IS NULL OR 
                      (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
                       bp.ba_access IN ('D', 'L')) OR
                      (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
                       (bp.ba_access IN ('T', 'R') AND 
                        localOrsSiteKey = bp.site_key)))
                 AND bp.db_key = this_db_key
                 AND bp.status != 'D'
                 AND ((user_site_key = bp.site_key) OR
                      (user_site_key IS NULL AND
                       ((disk_backups_shared = TRUE# AND 
                         bp.device_type = 'DISK') OR
                        (tape_backups_shared = TRUE# AND 
                         bp.device_type <> 'DISK') OR
                        (this_site_key = nvl(bp.site_key, this_site_key)))))
 
             UNION ALL
 
             SELECT (CASE
                 WHEN xal.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                 ELSE xal.next_scn END) next_scn, 
                 xal.next_time, xal.dbinc_key, d2.reset_scn
               FROM xal,
                    (SELECT dbinc_key,
                            reset_scn,
                            PRIOR reset_scn next_reset_scn
                       FROM dbinc
                       START WITH dbinc_key = this_dbinc_key
                       CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                       UNION ALL
                       SELECT this_dbinc_key dbinc_key,
                              null           reset_scn,
                              null           next_reset_scn
                         FROM dual) d2
               WHERE xal.dbinc_key = d2.dbinc_key
                 AND (d2.next_reset_scn IS NULL OR
                       (xal.low_scn  >= d2.reset_scn AND
                          xal.low_scn  <  d2.next_reset_scn))
                 AND (isOrs = TRUE# OR 
                      (restoreRangeDevTyp IN ('RC$SBT', 'RC$ANY')))
                 AND (localOrsSiteKey IS NULL OR localOrsSiteKey = xal.site_key)
                 AND ((user_site_key  = xal.site_key) OR
                      (user_site_key IS NULL AND
                       ((tape_backups_shared = TRUE#) OR
                        (this_site_key = NVL(xal.site_key, this_site_key)))))
            ) ORDER BY next_scn DESC) 
  WHERE rownum = 1;
 
  maxScn      := highScn;
  maxTime     := highTime;
  maxDbIncKey := dbIncKey;
  maxRlgScn   := rlgscn;
  deb(DEB_IN, 'Max scn is = '||to_char(maxScn));
  deb(DEB_EXIT, 'with TRUE');
  RETURN TRUE;
EXCEPTION
  WHEN no_data_found THEN
     deb(DEB_EXIT, 'with FALSE');
     RETURN FALSE;
END getMaxRedoSCN;
 
--
FUNCTION getNextAvailableSCN(fromScn           IN   NUMBER,
                             nextAvailableSCN  OUT  NUMBER,
                             isOrs             IN   NUMBER)
RETURN boolean IS
 
lowScn number;
 
BEGIN
  deb(DEB_ENTER,'getNextAvailableSCN');
  deb(DEB_IN, 'finding next avilable scn after '
               || nvl(to_char(fromSCN), 'NULL'));
 
 
  SELECT min(low_scn) INTO lowScn
    FROM (SELECT  al.low_scn
            FROM al,
                 (SELECT dbinc_key,
                         reset_scn,
                         PRIOR reset_scn next_reset_scn
                    FROM dbinc
                    START WITH dbinc_key = this_dbinc_key
                    CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                    UNION ALL
                    SELECT this_dbinc_key dbinc_key,
                           null           reset_scn,
                           null           next_reset_scn
                      FROM dual) d2
            WHERE al.dbinc_key = d2.dbinc_key
              AND (d2.next_reset_scn IS NULL OR
                   (al.low_scn  >= d2.reset_scn AND
                    al.low_scn  <  d2.next_reset_scn))
              AND al.low_scn > fromScn
              AND (isOrs = TRUE# OR 
                   (restoreRangeDevTyp IN ('RC$DISK', 'RC$ANY')))
              AND (localOrsSiteKey IS NULL OR localOrsSiteKey = al.site_key)
              AND ((client_site_aware = TRUE# AND
                    ((user_site_key = al.site_key) OR
                     (user_site_key IS NULL AND
                      (logs_shared = TRUE# OR
                       this_site_key = nvl(al.site_key, this_site_key))))) OR
                   (client_site_aware = FALSE#))
 
          UNION ALL
 
          SELECT  brl.low_scn
            FROM brl, bp,
                 (SELECT dbinc_key,
                         reset_scn,
                         PRIOR reset_scn next_reset_scn
                    FROM dbinc
                    START WITH dbinc_key = this_dbinc_key
                    CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                    UNION ALL
                    SELECT this_dbinc_key dbinc_key,
                           null           reset_scn,
                           null           next_reset_scn
                      FROM dual) d2
            WHERE brl.bs_key = bp.bs_key
              AND brl.dbinc_key = d2.dbinc_key
              AND (d2.next_reset_scn IS NULL OR
                    (brl.low_scn  >= d2.reset_scn AND
                       brl.low_scn  <  d2.next_reset_scn))
              AND brl.low_scn > fromScn
              AND (isOrs = TRUE# OR 
                   ((restoreRangeDevTyp = 'RC$DISK' AND
                     bp.device_type = 'DISK') OR  
                    (restoreRangeDevTyp = 'RC$SBT' AND
                     bp.device_type = 'SBT_TAPE') OR
                    restoreRangeDevTyp = 'RC$ANY'))
              AND (localOrsSiteKey IS NULL OR 
                   (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND
                    bp.ba_access IN ('D', 'L')) OR
                   (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND
                    (bp.ba_access IN ('T', 'R') AND
                     localOrsSiteKey = bp.site_key)))
              AND bp.db_key = this_db_key
              AND bp.status != 'D'
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared = TRUE# AND 
                      bp.device_type = 'DISK') OR
                     (tape_backups_shared = TRUE# AND 
                      bp.device_type <> 'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
    
          UNION ALL
 
          SELECT  xal.low_scn
            FROM xal,
                 (SELECT dbinc_key,
                         reset_scn,
                         PRIOR reset_scn next_reset_scn
                    FROM dbinc
                    START WITH dbinc_key = this_dbinc_key
                    CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                    UNION ALL
                    SELECT this_dbinc_key dbinc_key,
                           null           reset_scn,
                           null           next_reset_scn
                      FROM dual) d2
            WHERE xal.dbinc_key = d2.dbinc_key
              AND (d2.next_reset_scn IS NULL OR
                    (xal.low_scn  >= d2.reset_scn AND
                       xal.low_scn  <  d2.next_reset_scn))
              AND xal.low_scn > fromScn
              AND (isOrs = TRUE# OR 
                   (restoreRangeDevTyp IN ('RC$SBT', 'RC$ANY')))
              AND (localOrsSiteKey IS NULL OR localOrsSiteKey = xal.site_key)
              AND ((user_site_key  = xal.site_key) OR
                   (user_site_key IS NULL AND
                    ((tape_backups_shared = TRUE#) OR
                     (this_site_key = NVL(xal.site_key, this_site_key))))));
 
   nextAvailableSCN := lowScn;
   deb(DEB_IN, 'next available scn is = '||to_char(nextAvailableSCN));
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
END getNextAvailableSCN;
 
--
FUNCTION findLogBreakPoint(logBreakPointScn       OUT NUMBER,
                           logBreakPointTime      OUT DATE,
                           logBreakPointDbIncKey  OUT NUMBER,
                           logBreakPointRlgScn    OUT NUMBER,
                           logBreakPointRlgTime   OUT DATE,
                           fromSCN                IN  NUMBER,
                           untilSCN               IN  NUMBER,
                           isOrs                  IN  NUMBER)
RETURN boolean IS
   thread    number;
   sequence  number;
   dbinc_key number;
   nxtscn    number;
   nxttime   date;
   rlgscn    number;
BEGIN
   deb(DEB_ENTER, 'findLogBreakPoint');
   deb(DEB_IN, 'fromSCN ='  || nvl(to_char(fromSCN), 'NULL') ||
               ' untilSCN=' || nvl(to_char(untilSCN), 'NULL'));
 
--
--
 
   SELECT thread#, sequence#, dbinc_key, next_scn, next_time, reset_scn
     INTO thread, sequence, dbinc_key, nxtscn, nxttime, rlgscn
     FROM (SELECT dbinc_key, thread#, sequence#, next_scn, next_time,
                   reset_scn, lead(sequence#, 1, sequence#+1)
             OVER (PARTITION BY thread#, dbinc_key
                       ORDER BY sequence#) nextseq
           FROM (
                   SELECT al.thread#, al.sequence#, al.dbinc_key,       
                   (CASE
                   WHEN al.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                     ELSE al.next_scn END) next_scn,
                     al.next_time, d2.reset_scn
                     FROM al,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                     WHERE al.dbinc_key = d2.dbinc_key
                       AND (d2.next_reset_scn IS NULL OR
                            (al.low_scn  >= d2.reset_scn AND
                             al.low_scn  <  d2.next_reset_scn))
                       AND next_scn >= fromSCN
                       AND (untilSCN IS NULL OR low_scn < untilSCN)
                       AND (isOrs = TRUE# OR (restoreRangeDevTyp IN
                           ('RC$DISK', 'RC$ANY')))
                       AND (localOrsSiteKey IS NULL OR 
                            localOrsSiteKey = al.site_key)
                       AND ((client_site_aware = TRUE# AND
                             ((user_site_key = al.site_key) OR
                              (user_site_key IS NULL AND
                               (logs_shared = TRUE# OR
                                this_site_key = 
                                nvl(al.site_key, this_site_key))))) OR
                            (client_site_aware = FALSE#))
 
                 UNION ALL
 
                   SELECT brl.thread#, brl.sequence#, brl.dbinc_key,
                   (CASE
                   WHEN brl.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                     ELSE brl.next_scn END) next_scn,
                      brl.next_time, d2.reset_scn
                     FROM brl, bp,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                     WHERE brl.bs_key = bp.bs_key
                       AND brl.dbinc_key = d2.dbinc_key
                       AND (d2.next_reset_scn IS NULL OR
                            (brl.low_scn  >= d2.reset_scn AND
                             brl.low_scn  <  d2.next_reset_scn))
--
--
--
                       AND next_scn >= fromSCN
                       AND (untilSCN IS NULL OR low_scn < untilSCN)
                       AND (isOrs = TRUE# OR 
                            ((restoreRangeDevTyp = 'RC$DISK' AND
                              bp.device_type = 'DISK') OR 
                             (restoreRangeDevTyp = 'RC$SBT' AND
                              bp.device_type = 'SBT_TAPE') OR
                             restoreRangeDevTyp = 'RC$ANY'))
                       AND (localOrsSiteKey IS NULL OR 
                            (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
                             bp.ba_access IN ('D', 'L')) OR
                            (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
                             (bp.ba_access IN ('T', 'R') AND 
                              localOrsSiteKey = bp.site_key)))
                       AND bp.db_key = this_db_key
                       AND bp.status != 'D'
                       AND ((user_site_key = bp.site_key) OR
                            (user_site_key IS NULL AND
                             ((disk_backups_shared = TRUE# AND 
                               bp.device_type = 'DISK') OR
                              (tape_backups_shared = TRUE# AND 
                               bp.device_type <> 'DISK') OR
                              (this_site_key = 
                               nvl(bp.site_key, this_site_key)))))
 
                UNION ALL
 
                SELECT xal.thread#, xal.sequence#, xal.dbinc_key,
                   (CASE
                   WHEN xal.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                     ELSE xal.next_scn END) next_scn,
                      xal.next_time, d2.reset_scn
                     FROM xal,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                     WHERE xal.dbinc_key = d2.dbinc_key
                       AND (d2.next_reset_scn IS NULL OR
                            (xal.low_scn  >= d2.reset_scn AND
                             xal.low_scn  <  d2.next_reset_scn))
                       AND next_scn >= fromSCN
                       AND (untilSCN IS NULL OR low_scn < untilSCN)
                       AND (isOrs = TRUE# OR (restoreRangeDevTyp IN
                           ('RC$SBT', 'RC$ANY')))
                       AND (localOrsSiteKey IS NULL OR 
                           localOrsSiteKey = xal.site_key)
                       AND ((user_site_key  = xal.site_key) OR
                            (user_site_key IS NULL AND
                             ((tape_backups_shared = TRUE#) OR
                              (this_site_key = 
                               NVL(xal.site_key, this_site_key))))))
            )
     WHERE nextseq NOT IN (sequence#, sequence#+1)
       AND rownum = 1;
 
   logBreakPointScn      := nxtscn;
   logBreakPointTime     := nxttime;
   logBreakPointDbIncKey := dbinc_key;
   logBreakPointRlgScn   := rlgscn;
   deb(DEB_IN, 'missing sequence is 
               (dbinc_key, thread, sequence, nextscn)=('||
               to_char(dbinc_key)  || ',' ||
               to_char(thread)     || ',' ||
               to_char(sequence+1) || ',' ||
               to_char(nxtscn)    || ')');
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
END findLogBreakPoint;
 
--
FUNCTION getDropSCN(dfNum        IN  NUMBER,
                    creScn       IN  NUMBER,
                    creTime      IN  DATE,
                    plugScn      IN  NUMBER,
                    foreignDbId  IN  NUMBER,
                    dropScn      OUT NUMBER,
                    dropTime     OUT DATE,
                    dropDbIncKey OUT NUMBER,
                    dropRlgScn   OUT NUMBER,
                    dropRlgTime  OUT DATE)
RETURN boolean IS
BEGIN
 
  deb(DEB_ENTER, 'getDropSCN');
 
  SELECT drop_scn, drop_time, dbinc_key, reset_scn, reset_time
    INTO dropScn, dropTime, dropDbIncKey, dropRlgScn, dropRlgTime
    FROM (SELECT drop_scn, drop_time, df.dbinc_key, reset_scn, reset_time
            FROM df, dbinc
           WHERE df.dbinc_key  = dbinc.dbinc_key
             AND dbinc.db_key  = this_db_key
             AND file#         = dfNum
             AND create_scn    = creScn
             AND create_time   = creTime
             AND plugin_scn    = plugScn
             AND foreign_dbid  = foreignDbId
             AND (dbinc_status = 'PARENT' OR
                  dbinc_status = 'CURRENT')
           ORDER BY reset_scn desc)
   WHERE rownum = 1;
 
  IF (dropScn IS NULL) THEN
     deb(DEB_EXIT, 'with FALSE');
     RETURN FALSE;
  ELSE
    deb(DEB_EXIT, 'with TRUE');
    RETURN TRUE;
  END IF;
EXCEPTION
    WHEN OTHERS THEN
      deb(DEB_IN, 'found exception: ' || substr(sqlerrm, 1, 512));
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
END getDropSCN;
 
--
FUNCTION setLocalOrsSiteKey(db_id IN NUMBER)
RETURN boolean IS
  dbUnqName               node.db_unique_name%TYPE;
  l_db_id                 NUMBER;
BEGIN
 
  deb(DEB_ENTER, 'setLocalOrsSiteKey ' || db_id);
  l_db_id := db_id;
 
  localOrsSiteKey := NULL;
 
  IF (user_site_key IS NOT NULL) THEN
    deb(DEB_IN, 'user_site_key is set');
    deb(DEB_EXIT, 'with TRUE');
    return TRUE;
  END IF;
 
  BEGIN
    EXECUTE IMMEDIATE 'select rtrim(ltrim(value)) 
       from sys.v_$parameter where lower(name)=''db_unique_name'''
       into dbUnqName;
 
  EXCEPTION
    WHEN OTHERS THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
  END;
 
  deb(DEB_IN, 'ORS db_uniqune_name is ' || dbUnqName); 
 
  IF l_db_id IS NULL THEN
     SELECT db_id INTO l_db_id from db where db_key = this_db_key;
     deb(DEB_IN, 'using default db_id from setDatabase ' || l_db_id);
  END IF;
 
  BEGIN
    SELECT SITE_KEY INTO localOrsSiteKey FROM node
      WHERE UPPER(DB_UNIQUE_NAME) = 
            UPPER('$'||dbUnqName||'$'||to_char(l_db_id));
 
  EXCEPTION
    WHEN OTHERS THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
  END;
 
  deb(DEB_IN, 'Local Ors site key ' || to_char(localOrsSiteKey));
  deb(DEB_EXIT, 'with TRUE');
  return TRUE;
 
END setLocalOrsSiteKey;
 
--
PROCEDURE resetLocalOrsSiteKey IS
BEGIN
   deb(DEB_ENTER, 'resetLocalOrsSiteKey');
   localOrsSiteKey := NULL;
   deb(DEB_EXIT);
END resetLocalOrsSiteKey;
 
--
FUNCTION getIncarnationKey(untilSCN IN NUMBER)
RETURN number IS
   myInc number;
BEGIN
   deb(DEB_ENTER, 'getIncarnationKey');
 
   IF (untilSCN <= this_reset_scn) THEN
      SELECT dbinc.dbinc_key
        INTO myInc
        FROM (SELECT dbinc_key, reset_scn, PRIOR reset_scn next_reset_scn
                FROM dbinc
          START WITH dbinc_key = this_dbinc_key
          CONNECT BY PRIOR parent_dbinc_key = dbinc_key) dbinc
       WHERE dbinc.reset_scn < untilSCN
         AND dbinc.next_reset_scn >= untilSCN;
   ELSE
      myInc := 0;
   END IF;
 
   deb(DEB_EXIT, 'with incKey=' || to_char(myInc));
   RETURN myInc;
END getIncarnationKey;
 
 
--
FUNCTION getMaxScn
RETURN number IS
   logmaxnt  date;
BEGIN
   return getMaxScn(logmaxnt);
END;
 
FUNCTION getMaxScn(logmaxnt OUT date) return number IS
   minmaxnc  number;
   minmaxnt  date;
BEGIN
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   /* Bug 2377581: Find SCN from enabled threads only. */
   select min(maxnc), min(maxnt)
     into minmaxnc, minmaxnt
     from (select max(next_scn) maxnc, max(NEXT_TIME) maxnt
             from (select a.next_scn, a.next_time, a.thread# tno
                     from al a, rt t
                    where a.THREAD#            = t.THREAD#
                      and a.ARCHIVED           = 'Y'
                      and t.status             not in ('D', 'I')
                      and t.dbinc_key          = this_dbinc_key
                      and a.dbinc_key          = this_dbinc_key
                    union
                   select b.next_scn, b.next_time, b.thread# tno
                     from brl b, rt t
                    where b.THREAD#            = t.THREAD#
                      and t.status             not in ('D', 'I')
                      and t.dbinc_key          = this_dbinc_key
                      and b.dbinc_key          = this_dbinc_key)
             group by tno);
   logmaxnt := minmaxnt;
   return minmaxnc;
END getMaxScn;
 
--
FUNCTION getActualDbinc RETURN NUMBER
IS
BEGIN
   return actual_dbinc_key;
END getActualDbinc;
 
--
PROCEDURE setStdbyCtrlScn(
   ctrlSCN IN NUMBER)
IS
BEGIN
   deb(DEB_PRINT, 'Setting this_stdby_controlfile_scn' || ctrlSCN);
   this_stdby_controlfile_scn := ctrlSCN;
END setStdbyCtrlScn;
 
--
FUNCTION guidToPdbKey(guid IN VARCHAR2) RETURN NUMBER IS
   pdbKey NUMBER;
BEGIN
   IF (guid IS NULL) THEN
      RETURN NULL;
   END IF;
 
   SELECT max(pdb_key) INTO pdbKey
     FROM pdb
    WHERE pdb.guid = guidToPdbKey.guid
      AND pdb.db_key = this_db_key;
 
   RETURN pdbKey;
END guidToPdbKey;
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
--
FUNCTION dumpState(
   lineno IN number)
RETURN varchar2 IS
BEGIN
   IF    lineno =  1 THEN RETURN 'this_db_key=' || 
                                 nvl(to_char(this_db_key), 'NULL');
   ELSIF lineno =  2 THEN RETURN 'this_dbinc_key=' ||
                                 nvl(to_char(this_dbinc_key), 'NULL');
   ELSIF lineno =  3 THEN RETURN 'this_reset_scn=' ||
                                 nvl(to_char(this_reset_scn), 'NULL');
   ELSIF lineno =  4 THEN RETURN 'this_reset_time=' ||
                                 nvl(to_char(this_reset_time), 'NULL');
   ELSIF lineno =  5 THEN RETURN 'untilSCN=' ||
                                 nvl(to_char(untilSCN), 'NULL');
   ELSIF lineno =  6 THEN RETURN 'untilTime=' ||
                                 nvl(to_char(untilTime), 'NULL');
   ELSIF lineno =  7 THEN RETURN 'getRA_completedAfter=' ||
                                 nvl(to_char(getRA_completedAfter), 'NULL');
   ELSIF lineno =  8 THEN RETURN 'getRA_completedBefore=' ||
                                 nvl(to_char(getRA_completedBefore), 'NULL');
   ELSIF lineno =  9 THEN RETURN 'getRA_likePattern=' ||
                                 nvl(getRA_likePattern, 'NULL');
   ELSIF lineno = 10 THEN RETURN 'getRA_containerMask=' ||
                                 nvl(to_char(getRA_containerMask), 'NULL');
   ELSIF lineno = 11 THEN RETURN 'getRA_actionMask=' ||
                                 nvl(to_char(getRA_actionMask), 'NULL');
   ELSIF lineno = 12 THEN RETURN 'computeRA_allRecords=' ||
                                 nvl(to_char(computeRA_allRecords), 'NULL');
   ELSIF lineno = 13 THEN RETURN 'computeRA_fullBackups=' ||
                                 nvl(to_char(computeRA_fullBackups), 'NULL');
   ELSIF lineno = 14 THEN RETURN 'allIncarnations=' ||
                                 nvl(to_char(allIncarnations), 'NULL');
   ELSE RETURN NULL;
   END IF;
END dumpState;
 
--
PROCEDURE dumpPkgState(msg in varchar2 default null) IS
   line varchar2(132);
   lno number := 1;
BEGIN
   deb(DEB_ENTER, 'dumpPkgState ' || nvl(msg, ' '));
   loop
       line := dumpState(lno);
       if line is NULL then
          exit;
       else
          deb(DEB_PRINT, line);
          lno := lno + 1;
       end if;
   end loop;
   deb(DEB_EXIT);
END dumpPkgState;
 
--
PROCEDURE setDebugOn
IS
BEGIN
   if debug is null or not debug then
--
--
--
--
      dbms_output.enable(buffer_size => null);
      debug := TRUE;
   else
      deb(DEB_PRINT, 'Debug on - debug lready enabled');
   end if;
END setDebugOn;
 
--
PROCEDURE setDebugOff
IS
BEGIN
   dumpPkgState('Debug Off');
   dbms_output.disable;  -- free memory
   debug := FALSE;
END setDebugOff;
 
--
--
--
 
--
--
--
--
 
--
PROCEDURE initialize(
   rman_vsn IN number)
IS
BEGIN
   NULL;
END initialize;
 
--
PROCEDURE set_package_constants
IS
BEGIN
--
--
--
--
   NULL;
END set_package_constants;
 
--
--
--
 
--
FUNCTION stamp2date(
   stamp IN number)
RETURN date
IS
   x    number;
   dt   varchar2(19);
BEGIN
   x := stamp;
 
   dt := to_char(mod(x,60), 'FM09'); -- seconds
   x := floor(x/60);
 
   dt := to_char(mod(x,60), 'FM09') || ':' || dt; -- minutes
   x := floor(x/60);
 
   dt := to_char(mod(x,24), 'FM09') || ':' || dt; -- hours
   x := floor(x/24);
 
   dt := to_char(mod(x,31)+1, 'FM09') || ' ' || dt; -- days
   x := floor(x/31);
 
   dt := to_char(mod(x,12)+1, 'FM09') || '/' || dt; -- months
 
   dt := to_char(floor(x/12)+1988)   || '/' || dt;
 
   RETURN to_date(dt, 'YYYY/MM/DD HH24:MI:SS');
END stamp2date;
 
--
--
--
 
--
--
PROCEDURE setAllFlag(
   flag IN boolean)
IS
BEGIN
   setAllIncarnations(flag);
   IF (flag) THEN
      ignoreCreationSCN := TRUE#;
   ELSE
      ignoreCreationSCN := FALSE#;
   END IF;
END setAllFlag;
 
--
FUNCTION getUntilTime
RETURN date IS
BEGIN
   RETURN untilTime;
END getUntilTime;
 
--
FUNCTION getUntilScn
RETURN number IS
BEGIN
   RETURN untilScn;
END getUntilScn;
 
--
PROCEDURE resetUntil
IS
BEGIN
   untilSCN := NULL;
   untilTime := NULL;
   rpoint_set := FALSE;
END resetUntil;
 
--
PROCEDURE setFrom(
   restorefrom IN number DEFAULT NULL)
IS
BEGIN
   IF (restorefrom = BACKUP) THEN
      restoreSource := backupSet_con_t + proxyCopy_con_t;
   ELSIF (restorefrom = COPY) THEN
      restoreSource := imageCopy_con_t;
   ELSIF (restorefrom = NONPROXY) THEN
      restoreSource := imageCopy_con_t + backupSet_con_t;
   ELSIF (restorefrom = AVMCOPY) THEN
--
      IF (dbms_rcvcat.isAMSchema) THEN
         restoreSource := avmImageCopy_con_t;
      END IF;
--
      IF (bitand(nvl(restoreSource, 0), avmImageCopy_con_t) = 0) THEN
         raise_application_error(-20514,
            'feature requires Availability Machine recovery catalog');
      END IF;
   ELSIF (restorefrom is NULL) THEN
      restoreSource := NULL;
   ELSE
      raise_application_error(-20200, 'Invalid restore source');
   END IF;
 
END setFrom;
 
--
PROCEDURE setSparseness(
   sparseness IN number DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'setSparseness');
   deb(DEB_IN, 'restoreSparse='|| restoreSparse);
   IF (sparseness = SPARSE) THEN
      restoreSparse := BACKUP_SPARSENESS_SPARSE;
   ELSIF (sparseness = NONSPARSE) THEN
      restoreSparse := BACKUP_SPARSENESS_NONSPARSE;
   ELSE
      restoreSparse := BACKUP_SPARSENESS_UNSPECIFIED;
   END IF;
   deb(DEB_IN, 'restoreSparse='|| restoreSparse);
   deb(DEB_EXIT);
END setSparseness;
 
--
PROCEDURE setDeviceType(
   type IN varchar2)
IS
BEGIN
   IF (deviceCount >= 8) THEN
      raise_application_error(-20280, 'Too many device types');
   END IF;
   deviceCount := deviceCount + 1;
   deviceList(deviceCount) := type;
   IF (type = 'DISK') THEN
      diskDevice := TRUE;
   END IF;
END setDeviceType;
 
--
PROCEDURE setStandby(
   stby IN boolean)
IS
BEGIN
   if stby is NULL then
      onlyStandby := NULL;
   elsif stby then
      onlyStandby := TRUE#;
   else
      onlyStandby := FALSE#;
   end if;
END setStandby;
 
--
PROCEDURE setDeviceTypeAny
IS
BEGIN
   diskDevice  := TRUE;
   anyDevice   := TRUE#;
   deviceCount := 0;
END setDeviceTypeAny;
 
--
PROCEDURE resetDeviceType
IS
BEGIN
   FOR i in 1..8 LOOP
      deviceList(i) := NULL;
   END LOOP;
   deviceCount := 0;
   diskDevice  := FALSE;
   anyDevice   := FALSE#;
END resetDeviceType;
 
--
PROCEDURE setTag(
   tag IN varchar2 DEFAULT NULL)
IS
BEGIN
   restoreTag := tag;
END setTag;
 
--
PROCEDURE setRecoveryDestFile(onlyrdf IN BOOLEAN)
IS
BEGIN
  if onlyrdf then
     recoveryDestFile := TRUE;
  else
     recoveryDestFile := FALSE;
  end if;
END setRecoveryDestFile;
 
--
PROCEDURE setOrsFile(localOnly IN BOOLEAN, libKey IN NUMBER)
IS
BEGIN
  orsLocalFile := localOnly;
  orsLibKey    := libKey;
  orsAnyFile   := (NOT localOnly AND libKey IS NULL);
END setOrsFile;
 
--
--
--
 
--
FUNCTION getValidBackupSet(
   validBackupSetRec            OUT NOCOPY validBackupSetRec_t
  ,checkDeviceIsAllocated       IN  number DEFAULT FALSE#)
RETURN number IS
   lastCode     number;
   checkRc      number;
   local        validBackupSetRec_t;
BEGIN
   IF (bsRecCacheEnabled) THEN
      RETURN cacheGetValidBackupSet(
                          validBackupSetRec      => validBackupSetRec,
                          checkDeviceIsAllocated => checkDeviceIsAllocated);
   END IF;
 
   deb(DEB_ENTER, 'getValidBackupSet');
 
--
   IF (getValidBackupSetCursor = 'findValidBackupSet1P_c') THEN
      IF (NOT findValidBackupSet1P_c%ISOPEN) THEN
         RETURN FALSE#;
      END IF;
   ELSIF (getValidBackupSetCursor = 'findValidBackupSet_c') THEN
      IF (NOT findValidBackupSet_c%ISOPEN) THEN
         RETURN FALSE#;
      END IF;
   ELSE
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
<<nextRow>>
   IF (getValidBackupSetCursor = 'findValidBackupSet1P_c') THEN
      FETCH findValidBackupSet1P_c
         INTO local;
 
      IF (findValidBackupSet1P_c%NOTFOUND) THEN
         CLOSE findValidBackupSet1P_c;
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
      END IF;
   ELSIF (getValidBackupSetCursor = 'findValidBackupSet_c') THEN
      FETCH findValidBackupSet_c
         INTO local;
 
      IF (findValidBackupSet_c%NOTFOUND) THEN
         CLOSE findValidBackupSet_c;
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
      END IF;
   END IF;
 
   lastCode := getValidBackupSetLast.code;      -- save for test below
   getValidBackupSetLast := local;              -- save for next time here
 
   IF (local.code <= lastCode) THEN
--
--
--
--
--
--
--
 
--
--
--
--
 
--
--
--
--
--
 
--
--
--
--
 
      IF (checkDeviceIsAllocated = TRUE#) THEN
         IF (anyDevice = FALSE# AND
             isDeviceTypeAllocated(local.deviceType) = FALSE#) THEN
            deb(DEB_IN, 'device type not allocated: ' ||
                local.deviceType);
            GOTO nextRow;
         END IF;
      END IF;
      validBackupSetRec := local;               -- set OUT mode arg
      deb(DEB_IN, 'returning valid rec deviceType=' ||
          local.deviceType || ' tag=' || local.tag || ' copyNumber=' ||
          to_char(local.copyNumber));
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      deb(DEB_IN, ' local.code=' || to_char(local.code) ||
          ' lastCode=' || to_char(lastCode));
      GOTO nextRow;
   END IF;
   deb(DEB_EXIT);
END getValidBackupSet;
 
--
--
--
 
--
FUNCTION getRcvRec(
   funCode      IN number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,callAgain    OUT number)
RETURN number IS
   rc           number;
BEGIN
   deb(DEB_ENTER, 'getRcvRec');
   rc := 0;                                     -- init for procedures
   callAgain := TRUE#;
 
   deb(DEB_IN, ' funCode=' || to_char(funCode));
 
   IF (funCode = getCfCopy) THEN
      getControlfileCopy(rcvRec);
   ELSIF (funCode = getDfCopy) THEN
      getDatafileCopy(rcvRec);
   ELSIF (funCode = getAnyProxy) THEN
      getProxyCopy(rcvRec);
   ELSIF (funCode = getCfBackup) THEN
      rc := getControlfileBackup(rcvRec);
      IF (rc != SUCCESS OR NOT findControlfileBackupCursor) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = getSfBackup) THEN
      rc := getSpfileBackup(rcvRec => rcvRec);
      IF (rc != SUCCESS OR NOT findSpfileBackupCursor) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = listCfCopy) THEN
      listGetControlfileCopy(rcvRec);
   ELSIF (funCode = listDfCopy) THEN
      listGetDatafileCopy(rcvRec);
   ELSIF (funCode = listCfBackup) THEN
      listGetControlfileBackup(rcvRec);
   ELSIF (funCode = listSfBackup) THEN
      listGetSpfileBackup(rcvRec);
   ELSIF (funCode = listDfBackup) THEN
      listGetDatafileBackup(rcvRec);
   ELSIF (funCode = listAlBackup) THEN
      listGetArchivedLogBackup(rcvRec);
   ELSIF (funCode = listDfProxy) THEN
      listGetProxyDatafile(rcvRec);
   ELSIF (funCode = listAlProxy) THEN
      listGetProxyArchivedLog(rcvRec);
   ELSIF (funCode = getRecovAction) THEN
      callAgain := getRecoveryAction(rcvRec);
   ELSIF (funCode = getAlBackup) THEN
      rc := getArchivedLogBackup(rcvRec);
      IF (rc != SUCCESS) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = getRangeAlBackup) THEN
      rc := getRangeArchivedLogBackup(rcvRec);
      IF (rc = UNAVAILABLE) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = listAlCopy) THEN
      listGetArchivedLogCopy(rcvRec);
   ELSIF (funCode = listBSet) THEN
      listGetBackupsetFiles(rcvRec);
   ELSIF (funCode = getAllBSet) THEN
      getAllBackupSet(rcvRec);
   ELSE
      deb(DEB_EXIT, 'with error 20999');
      raise_application_error(-20999, 'getRcvRec: unknown funCode: ' ||
                              to_char(funCode));
   END IF;
 
   IF (debug) THEN
      printRcvRec(rcvRec);
      deb(DEB_EXIT, 'with rc:'||TO_CHAR(rc));
   END IF;
 
--
--
--
 
   RETURN rc;
 
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
END getRcvRec;
 
--
--
--
 
--
PROCEDURE translateDatabase(
   sinceUntilSCN IN number DEFAULT NULL)
IS
   fromSCN      number;
   toSCN        number;
BEGIN
   deb(DEB_ENTER, 'translateDatabase');
   validateState(getDatafileCursor);
 
   IF (untilSCN is NULL) THEN
--
      fromSCN := MAXSCNVAL;
      toSCN   := MAXSCNVAL;
   ELSE                                 -- an until clause is in effect
      fromSCN := untilSCN;
      IF (sinceUntilSCN = TRUE#) THEN
--
--
--
         toSCN := MAXSCNVAL;
      ELSE
--
--
--
         toSCN := fromSCN;
      END IF;
   END IF;
 
   IF (pdbIdList.count = 0) THEN
      deb(DEB_OPEN, 'translateDatabase_c');
      OPEN translateDatabase_c(fromSCN, toSCN);
      getDatafileCursor := 'translateDatabase';
      getDatafileNoRows.error := NULL;             -- error not possible
   ELSIF (pdbIdList.count = 1) THEN
      deb(DEB_OPEN, 'translateDatabaseOfPdbId_c');
      OPEN translateDatabaseOfPdbId_c
              (fromSCN, toSCN, pdbIdList.first + CONST2GVAL);
      getDatafileCursor := 'translateDatabaseOfPdbId';
   ELSE
      deb(DEB_OPEN, 'translateDatabaseOfPdbIdL_c');
      OPEN translateDatabaseOfPdbIdL_c(fromSCN, toSCN);
      getDatafileCursor := 'translateDatabaseOfPdbIdL';
   END IF;
 
   IF (untilSCN IS NOT NULL AND pdbIdList.count != 0) THEN
      getDatafileNoRows.error := -20513;
      getDatafileNoRows.msg   :=
         'UNTIL TIME or SCN is before plugggable database CREATION SCN';
   END IF;
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDBTransClause;
   deb(DEB_EXIT);
END translateDatabase;
 
--
 
--
PROCEDURE skipTableSpace(
   tsName  IN varchar2
  ,pdbId   IN number DEFAULT 0)
IS
  tsRec tablespace_t;
BEGIN
   tsRec.name    := tsName;
   tsRec.pdbId   := pdbId;
   skipTablespaceList(skipTablespaceList.count + 1) := tsRec;
END skipTableSpace;
 
--
PROCEDURE translateTablespace(
   ts_name  IN varchar2
  ,pdb_id   IN number DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateTablespace');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateTablespace_c');
   OPEN translateTablespace_c(tsName => ts_name, pdbId => pdb_id);
 
   getDatafileCursor       := 'translateTablespace';
   getDatafileNoRows.error := -20202;
   getDatafileNoRows.msg   := 'Tablespace does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   deb(DEB_EXIT);
END translateTablespace;
 
--
PROCEDURE translateDataFile(
   fname IN varchar2)
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFile_1');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateDatafileName');
   OPEN translateDatafileName(fileName => fname);
 
   IF (untilSCN is NULL and untilTime is NULL) THEN
      getDatafileNoRows.error := -20201;
      getDatafileNoRows.msg   := 'Datafile does not exist';
   ELSE
      getDatafileNoRows.error := -20222;
      getDatafileNoRows.msg   :=
         'Datafile name does not exist or is ambiguous';
   END IF;
 
   getDatafileCursor   := 'translateDatafileName';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   deb(DEB_EXIT);
END translateDatafile;
 
--
PROCEDURE translateDataFile(
   fno IN number)
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFile_2');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateDatafileNumber');
   OPEN translateDatafileNumber(fno => fno);
 
   getDatafileCursor       := 'translateDatafileNumber';
   getDatafileNoRows.error :=  -20201;
   getDatafileNoRows.msg   := 'Datafile does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDfTransClause(fno => fno);
   deb(DEB_EXIT);
END translateDatafile;
 
--
PROCEDURE translateDataFile(
   fno    IN number
  ,ckpscn IN number)
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFile_3');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateDatafileCheckpoint');
   OPEN translateDatafileCheckpoint(fno    => fno,
                                    ckpSCN => ckpscn);
 
   getDatafileCursor       := 'translateDatafileCheckpoint';
   getDatafileNoRows.error :=  -20201;
   getDatafileNoRows.msg   := 'Datafile does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDfTransClause(fno => fno);
   deb(DEB_EXIT);
END translateDatafile;
 
--
PROCEDURE translateAllDatafile
IS
BEGIN
   deb(DEB_ENTER, 'translateAllDataFile');
   validateState(getDatafileCursor);
 
   IF (pdbIdList.count = 0) THEN
      deb(DEB_OPEN, 'translateAllDf_c');
      OPEN translateAllDf_c;
      getDatafileCursor := 'translateAllDf';
   ELSIF (pdbIdList.count = 1) THEN
      deb(DEB_OPEN, 'translateAllDfOfPdbId_c');
      OPEN translateAllDfOfPdbId_c(pdbIdList.first + CONST2GVAL);
      getDatafileCursor := 'translateAllDfOfPdbId';
   ELSE
      deb(DEB_OPEN, 'translateAllDfOfPdbIdL_c');
      OPEN translateAllDfOfPdbIdL_c;
      getDatafileCursor := 'translateAllDfOfPdbIdList';
   END IF;
 
   getDatafileNoRows.error := NULL;             -- error not possible
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDBTransClause;
   deb(DEB_EXIT);
END;
 
--
PROCEDURE translateCorruptList
IS
BEGIN
   validateState(getDatafileCursor);
 
   OPEN translateCorruptList_c;
 
   getDatafileCursor       := 'translateCorruptList';
   getDatafileNoRows.error :=  -20504;
   getDatafileNoRows.msg   := 'Corruption List does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
END translateCorruptList;
 
--
 
--
PROCEDURE getDatafile(
   dfRec     OUT NOCOPY dfRec_t
  ,oldClient IN  boolean DEFAULT FALSE)
IS
   getDatafileRowcount  number;
   local                dfRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFile_1');
<<nextRow>>
   IF (getDatafileCursor = 'translateDatabase') THEN
      FETCH translateDatabase_c
       INTO local;
 
      IF (translateDatabase_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatabase_c%ROWCOUNT;
         CLOSE translateDatabase_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatabaseOfPdbId') THEN
      FETCH translateDatabaseOfPdbId_c
       INTO local;
 
      IF (translateDatabaseOfPdbId_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatabaseOfPdbId_c%ROWCOUNT;
         CLOSE translateDatabaseOfPdbId_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatabaseOfPdbIdL') THEN
      FETCH translateDatabaseOfPdbIdL_c
       INTO local;
 
      IF (translateDatabaseOfPdbIdL_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatabaseOfPdbIdL_c%ROWCOUNT;
         CLOSE translateDatabaseOfPdbIdL_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateAllDf') THEN
      FETCH translateAllDf_c
       INTO local;
 
      IF (translateAllDf_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateAllDf_c%ROWCOUNT;
         CLOSE translateAllDf_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateAllDfOfPdbId') THEN
      FETCH translateAllDfOfPdbId_c
       INTO local;
 
      IF (translateAllDfOfPdbId_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateAllDfOfPdbId_c%ROWCOUNT;
         CLOSE translateAllDfOfPdbId_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateAllDfOfPdbIdList') THEN
      FETCH translateAllDfOfPdbIdL_c
       INTO local;
 
      IF (translateAllDfOfPdbIdL_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateAllDfOfPdbIdL_c%ROWCOUNT;
         CLOSE translateAllDfOfPdbIdL_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateTablespace') THEN
      FETCH translateTablespace_c
       INTO local;
 
      IF (translateTablespace_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateTablespace_c%ROWCOUNT;
         CLOSE translateTablespace_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatafileName') THEN
      FETCH translateDatafileName
       INTO local;
 
      IF (translateDatafileName%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatafileName%ROWCOUNT;
         CLOSE translateDatafileName;
      END IF;
 
      IF (oldClient) THEN
--
         IF (translateDatafileName%ISOPEN) THEN
            CLOSE translateDatafileName;
         END IF;
         getDatafileCursor := NULL;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatafileNumber') THEN
      FETCH translateDatafileNumber
       INTO local;
 
      IF (translateDatafileNumber%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatafileNumber%ROWCOUNT;
         CLOSE translateDatafileNumber;
      END IF;
 
      IF (oldClient) THEN
--
         IF (translateDatafileNumber%ISOPEN) THEN
            CLOSE translateDatafileNumber;
         END IF;
         getDatafileCursor := NULL;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatafileCheckpoint') THEN
      FETCH translateDatafileCheckpoint
       INTO local;
 
      IF (translateDatafileCheckpoint%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatafileCheckpoint%ROWCOUNT;
         CLOSE translateDatafileCheckpoint;
      END IF;
 
      IF (oldClient) THEN
--
         IF (translateDatafileCheckpoint%ISOPEN) THEN
            CLOSE translateDatafileCheckpoint;
         END IF;
         getDatafileCursor := NULL;
      END IF;
   ELSIF (getDatafileCursor = 'translateCorruptList') THEN
      FETCH translateCorruptList_c
       INTO local;
 
      IF (translateCorruptList_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateCorruptList_c%ROWCOUNT;
         CLOSE translateCorruptList_c;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (getDatafileRowcount IS NOT NULL) THEN    -- if %NOTFOUND
      getDatafileCursor := NULL;                -- we closed it above
      IF (getDatafileRowcount = 0 AND
          getDatafileNoRows.error IS NOT NULL) THEN
--
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getDatafileNoRows.error,
                                 getDatafileNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
 
   IF (skipTablespace(local.tsName, local.pdbId)) THEN
      GOTO nextRow;
   END IF;
 
--
   IF (getDatafileLast.dfNumber = local.dfNumber) THEN
      IF (getDatafileLast.pluginSCN != 0) THEN
         IF (getDatafileLast.pluginSCN = local.pluginSCN) THEN
            deb(DEB_PRINT, 'not returning' || local.fileName);
            GOTO nextRow;
         END IF;
      ELSIF (getDatafileLast.dfCreationSCN = local.dfCreationSCN) THEN
         deb(DEB_PRINT, 'not returning' || local.fileName);
         GOTO nextRow;
      END IF;
   END IF;
 
--
--
--
   IF (local.pdbName IS NULL) THEN
      local.pdbName := translatePdb2Name(local.pdbId);
   END IF;
 
   getDatafileLast := local;
 
   setDfTransClause(fno => local.dfNumber);
 
   dfRec := local;                              -- set OUT mode arg
   deb(DEB_EXIT);
END getDatafile;
 
--
--
--
 
--
PROCEDURE translateOnlineLogs(srls IN number DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateOnlineLogs');
   IF (translateOnlineLogs_c%ISOPEN) THEN
      validateState('translateOnlineLogs_c');                -- raise the error
   END IF;
 
   deb(DEB_OPEN, 'translateOnlineLogs_c, srls='||srls);
   OPEN translateOnlineLogs_c(srls);
   deb(DEB_EXIT);
 
END translateOnlineLogs;
 
--
PROCEDURE getOnlineLog(
   fname        OUT varchar2
  ,thread#      OUT number
  ,group#       OUT number)
IS
BEGIN
   deb(DEB_ENTER, 'getOnlineLog');
   FETCH translateOnlineLogs_c
    INTO thread#, group#, fname;
   IF (translateOnlineLogs_c%NOTFOUND) THEN
      CLOSE translateOnlineLogs_c;
      deb(DEB_EXIT, 'with NULL (no archivelog found)'||fname);
      fname := NULL;                            -- indicate end-of-fetch
      RETURN;
   END IF;
   deb(DEB_EXIT, 'with archivelog:'||fname);
END getOnlineLog;
 
 
--
--
--
 
--
PROCEDURE getArchivedLog(
   alRec       OUT NOCOPY alRec_t,
   closeCursor IN  boolean DEFAULT FALSE)
IS
   getArchivedLogRowcount       number;
   local                        alRec_t;
BEGIN
   deb(DEB_ENTER, 'getArchivedLog');
 
<<nextRow>>
 
   IF (getArchivedLogCursor = 'translateArcLogKey') THEN
      FETCH translateArcLogKey
       INTO local;
      IF (translateArcLogKey%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogKey%ROWCOUNT;
         CLOSE translateArcLogKey;
      END IF;
      IF (closeCursor AND translateArcLogKey%ISOPEN) THEN
         CLOSE translateArcLogKey;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogName') THEN
      FETCH translateArcLogName
       INTO local;
      IF (translateArcLogName%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogName%ROWCOUNT;
         CLOSE translateArcLogName;
      END IF;
      IF (closeCursor AND translateArcLogName%ISOPEN) THEN
         CLOSE translateArcLogName;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange') THEN
      FETCH translateArcLogSeqRange
       INTO local;
      IF (translateArcLogSeqRange%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSeqRange%ROWCOUNT;
         CLOSE translateArcLogSeqRange;
      END IF;
      IF (closeCursor AND translateArcLogSeqRange%ISOPEN) THEN
         CLOSE translateArcLogSeqRange;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSeqRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange2') THEN
      FETCH translateArcLogSeqRange2
       INTO local;
      IF (translateArcLogSeqRange2%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSeqRange2%ROWCOUNT;
         CLOSE translateArcLogSeqRange2;
      END IF;
      IF (closeCursor AND translateArcLogSeqRange2%ISOPEN) THEN
         CLOSE translateArcLogSeqRange2;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange') THEN
      FETCH translateArcLogTimeRange
       INTO local;
      IF (translateArcLogTimeRange%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogTimeRange%ROWCOUNT;
         CLOSE translateArcLogTimeRange;
      END IF;
      IF (closeCursor AND translateArcLogTimeRange%ISOPEN) THEN
         CLOSE translateArcLogTimeRange;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogTimeRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange2') THEN
      FETCH translateArcLogTimeRange2
       INTO local;
      IF (translateArcLogTimeRange2%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogTimeRange2%ROWCOUNT;
         CLOSE translateArcLogTimeRange2;
      END IF;
      IF (closeCursor AND translateArcLogTimeRange2%ISOPEN) THEN
         CLOSE translateArcLogTimeRange2;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange') THEN
      FETCH translateArcLogSCNRange
       INTO local;
      IF (translateArcLogSCNRange%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSCNRange%ROWCOUNT;
         CLOSE translateArcLogSCNRange;
      END IF;
      IF (closeCursor AND translateArcLogSCNRange%ISOPEN) THEN
         CLOSE translateArcLogSCNRange;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSCNRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange2') THEN
      FETCH translateArcLogSCNRange2
       INTO local;
      IF (translateArcLogSCNRange2%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSCNRange2%ROWCOUNT;
         CLOSE translateArcLogSCNRange2;
      END IF;
      IF (closeCursor AND translateArcLogSCNRange2%ISOPEN) THEN
         CLOSE translateArcLogSCNRange2;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogPattern') THEN
      FETCH translateArcLogPattern
       INTO local;
      IF (translateArcLogPattern%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogPattern%ROWCOUNT;
         CLOSE translateArcLogPattern;
      END IF;
      IF (closeCursor AND translateArcLogPattern%ISOPEN) THEN
         CLOSE translateArcLogPattern;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogPattern') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor) THEN
      getArchivedLogCursor := NULL;
   END IF;
 
   IF (getArchivedLogRowcount IS NOT NULL) THEN
      getArchivedLogCursor := NULL;             -- we closed it above
      getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
      getArchivedLogOnlyrdf := 0;               -- clear for next time
      currInc := -1;
      deb(DEB_PRINT, 'getArchivedLogDoingRecovery cleared');
--
--
      IF ((getArchivedLogRowcount = 0 OR
           getArchivedLogLast.thread is NULL) AND
          getArchivedLogNoRows.error IS NOT NULL) THEN
--
         getArchivedLogLast   := NULL;          -- clear for next time
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getArchivedLogNoRows.error,
                                 getArchivedLogNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         getArchivedLogLast   := NULL;          -- clear for next time
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
 
   deb(DEB_PRINT, 'getArchivedLog - resetscn='||local.rlgSCN||
                  ' thread='||local.thread||
                  ' seq='||local.sequence||
                  ' lowscn='||local.lowSCN||
                  ' nextscn='||local.nextSCN||
                  ' terminal='||local.terminal||
                  ' site_key_order_col='||local.site_key_order_col||
                  ' isrdf='||local.isrdf||
                  ' stamp='||local.stamp);
 
--
   IF (getArchivedLogDoingRecovery = TRUE#) THEN
--
     IF (getArchivedLogLast.rlgSCN = local.rlgSCN AND
         getArchivedLogLast.rlgTime = local.rlgTime AND currInc <> -1) THEN
       deb(DEB_PRINT,
               'getArchivedLog - currInc =' || currInc);
--
       IF (currInc > 0 AND
           local.lowSCN >= inc_list(currInc-1).resetlogs_change#-1) THEN
           deb(DEB_PRINT,
               'getArchivedLog - Skip log - belongs to orphan branch');
           GOTO nextRow;
       END IF;
     ELSE
--
       currInc := -1;
       FOR inc_idx in 0..max_inc_idx-1 LOOP
 
--
--
         IF tc_fromSCN > inc_list(inc_idx).resetlogs_change# AND
            local.rlgSCN < inc_list(inc_idx).resetlogs_change#  THEN
            deb(DEB_PRINT,
                'getArchivedLog -Skip log precedes recovery SCN - '||inc_idx);
            EXIT;
         END IF;
 
--
--
--
--
         IF (local.rlgSCN = inc_list(inc_idx).resetlogs_change# AND
             local.rlgTime = inc_list(inc_idx).resetlogs_time) THEN
 
--
--
            IF inc_idx > 0 THEN
              IF local.lowSCN < inc_list(inc_idx-1).resetlogs_change# - 1 THEN
                  currInc := inc_idx;
                  deb(DEB_PRINT, 'getArchivedLog - currInc2 set to '||currInc);
               END IF;
            ELSE
               currInc := inc_idx;
               deb(DEB_PRINT, 'getArchivedLog - currIn3 set to '||currInc);
            END IF;
            EXIT;
         END IF;
       END LOOP;
       IF (currInc = -1) THEN
         deb(DEB_PRINT,'getArchivedLog - Skip log - not required by recovery');
         GOTO nextRow;
       END IF;
     END IF;
   END IF;
 
--
   IF (local.thread   = getArchivedLogLast.thread AND
       local.sequence = getArchivedLogLast.sequence AND
       local.terminal = getArchivedLogLast.terminal AND
       local.lowSCN   = getArchivedLogLast.lowSCN AND
       local.rlgSCN   = getArchivedLogLast.rlgSCN AND
       local.rlgTime  = getArchivedLogLast.rlgTime) THEN
     local.duplicate := TRUE#;
   END IF;
 
   IF (getArchivedLogDuplicates = FALSE# AND    -- if don't want duplicates
       local.duplicate = TRUE#) THEN
      deb(DEB_PRINT, 'getArchivedLog - dont want duplicates');
      GOTO nextRow;
   END IF;
 
--
--
--
--
--
--
--
--
--
--
--
   IF (getArchivedLogOnlyrdf = 1 AND
       local.duplicate = FALSE# AND
       local.isrdf = 'NO') THEN
      deb(DEB_PRINT, 'getArchiveLog - dont want non-recovery area log ');
      GOTO nextRow;
   END IF;
 
--
--
--
   IF IsDuplicateAlName(local.duplicate, local.filename) THEN
     GOTO nextRow;
   END IF;
 
--
--
   IF (local.thread   = getArchivedLogLast.thread AND
       local.sequence = getArchivedLogLast.sequence AND
       local.lowSCN   = getArchivedLogLast.lowSCN AND
       local.rlgSCN   = getArchivedLogLast.rlgSCN AND
       local.rlgTime  = getArchivedLogLast.rlgTime AND
       getArchivedLogLast.terminal = 'YES' AND
       local.terminal = 'NO') THEN
     deb(DEB_PRINT, 'getArchivedLog - Skip log - not an EOR log');
     GOTO nextRow;
   END IF;
--
 
--
   IF (getArchivedLogDoingRecovery = TRUE#) THEN
     IF (local.thread = getArchivedLogLast.thread AND
         local.lowSCN <> getArchivedLogLast.lowSCN AND
         local.sequence = getArchivedLogLast.sequence) THEN
        deb(DEB_PRINT, 'getArchivedLog - Skip log - filter bad sequence log');
        GOTO nextRow;
     END IF;
   END IF;
 
--
--
   IF (local.stamp <= 0) THEN
      local.stamp := NULL;
   END IF;
 
   IF getArchivedLogCursor IS NULL THEN
      getArchivedLogLast := NULL;               -- clear for next time
      getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
      getArchivedLogOnlyrdf := 0;
      currInc := -1;
      deb(DEB_PRINT, 'getArchivedLogDoingRecovery cleared');
      deb(DEB_PRINT, 'getArchivedLogLast := NULL');
   ELSE
      getArchivedLogLast := local;
      deb(DEB_PRINT,'getArchivedLogLast('||getArchivedLogCursor||') := local');
      deb(DEB_PRINT, 'getArchivedLogLast := local');
   END IF;
   alRec := local;                              -- set OUT mode arg
   deb(DEB_EXIT);
END getArchivedLog;
 
--
PROCEDURE translateArchivedLogKey(
   alKey        IN number
  ,needstby     IN number DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogKey');
   validateState(getArchivedLogCursor);
 
   deb(DEB_OPEN, 'translateArcLogKey');
   OPEN translateArcLogKey(alKey => alKey);
 
   getArchivedLogCursor       := 'translateArcLogKey';
   getArchivedLogDuplicates   := NULL;
   getArchivedLogNoRows.error := -20240;
   getArchivedLogNoRows.msg   := 'Archived log does not exist';
   deb(DEB_EXIT);
END translateArchivedLogKey;
 
--
PROCEDURE translateArchivedLogKey(
   al_key       IN  number
  ,available    IN  number DEFAULT 1     -- ignored (for compatability)
  ,unavailable  IN  number DEFAULT 1     -- ignored (for compatability)
  ,deleted      IN  number DEFAULT 1     -- ignored (for compatability)
  ,online       IN  number DEFAULT 1     -- ignored (for compatability)
  ,recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,fname        OUT varchar2
  ,needstby     IN number DEFAULT NULL)
IS
   alRec        alRec_t;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogKey816');
   translateArchivedLogKey(alKey => al_key, needstby => needstby);
 
   getArchivedLog(alRec       => alRec,
                  closeCursor => TRUE);
 
   recid        := alRec.recid;
   stamp        := alRec.stamp;
   thread#      := alRec.thread;
   sequence#    := alRec.sequence;
   low_scn      := alRec.lowSCN;
   reset_scn    := alRec.rlgSCN;
   block_size   := alRec.blockSize;
   fname        := alRec.fileName;
   deb(DEB_EXIT);
END translateArchivedLogKey;
 
--
--
--
--
 
--
PROCEDURE translateArchivedLogName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,deleted      IN number         DEFAULT NULL   -- for compatability
  ,online       IN number                        -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,needstby     IN number         DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogName');
   validateState(getArchivedLogCursor);
 
   deb(DEB_OPEN, 'translateArcLogName');
   OPEN translateArcLogName(fname       => fname,
                            online      => online,
                            statusMask  => NVL(statusMask,
                                   computeAvailableMask(available, unavailable,
                                                        deleted, 0)),
                            needstby    => needstby);
 
   getARchivedLogCursor       := 'translateArcLogName';
   getArchivedLogDuplicates   := duplicates;
   getArchivedLogNoRows.error := -20240;
   getArchivedLogNoRows.msg   := 'Archived log does not exist';
   deb(DEB_EXIT);
END translateArchivedLogName;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE translateArchivedLogSeqRange(
   thread#      IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,deleted      IN number         DEFAULT NULL   -- for compatability
  ,online       IN number                        -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,needstby     IN number         DEFAULT NULL   -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0      -- for compatability
  ,incarn       IN number         DEFAULT NULL)  -- for compatibility
IS
   mask    number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
   lincarn number := incarn;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogSeqRange');
   validateState(getArchivedLogCursor);
 
   IF (thread# is NULL) THEN
      deb(DEB_EXIT, 'with error 20210');
      raise_application_error(-20210, 'Thread# is missing');
   END IF;
 
   setAlTransClause(thread     => thread#,
                    fromSeq    => fromseq#,
                    toSeq      => toseq#,
                    pattern    => pattern);
 
--
--
--
--
 
   IF (foreignal != 0) THEN
      IF (tc_dbid.count = 0) THEN
         tc_anydbid := TRUE#;
      END IF;
      deb(DEB_OPEN, 'translateFrgnArcLogSeqRange');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
         deb(DEB_OPEN, 'translateArcLogSeqRange2');
         OPEN translateArcLogSeqRange2(thread#     => thread#,
                                       incarn      => NVL(lincarn,-1),
                                       fromseq#    => fromseq#,
                                       toseq#      => toseq#,
                                       statusMask  => mask,
                                       online      => online,
                                       needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogSeqRange2';
      ELSE
         deb(DEB_OPEN, 'translateArcLogSeqRange');
         OPEN translateArcLogSeqRange(thread#     => thread#,
                                      incarn      => NVL(lincarn,-1),
                                      fromseq#    => fromseq#,
                                      toseq#      => toseq#,
                                      pattern     => pattern,
                                      statusMask  => mask,
                                      online      => online,
                                      needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogSeqRange';
      END IF;
      getArchivedLogNoRows.error := -20242;
      getArchivedLogNoRows.msg   := 'No archived logs in the range specified';
   END IF;
   getArchivedLogDuplicates   := duplicates;
   deb(DEB_EXIT);
END translateArchivedLogSeqRange;
 
--
--
--
--
--
--
--
--
PROCEDURE translateArchivedLogTimeRange(
   thread#      IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,deleted      IN number         DEFAULT NULL    -- for compatability
  ,online       IN number                         -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatability
  ,needstby     IN number         DEFAULT NULL    -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0       -- for compatability
  ,incarn       IN number         DEFAULT NULL)   -- for compatibility
IS
   mask    number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
   lincarn number := incarn;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogTimeRange');
   validateState(getArchivedLogCursor);
 
   setAlTransClause(thread   => thread#,
                    fromTime => fromTime,
                    toTime   => toTime,
                    pattern  => pattern);
 
--
--
--
--
 
   IF (foreignal != 0) THEN
      IF (tc_dbid.count = 0) THEN
         tc_anydbid := TRUE#;
      END IF;
      deb(DEB_OPEN, 'translateFrgnArcLogTimeRange');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
         deb(DEB_OPEN, 'translateArcLogTimeRange2');
         OPEN translateArcLogTimeRange2(thread#     => thread#,
                                        incarn      => NVL(lincarn,0),
                                        fromTime    => fromTime,
                                        toTime      => toTime,
                                        statusMask  => mask,
                                        online      => online,
                                        needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogTimeRange2';
      ELSE
         deb(DEB_OPEN, 'translateArcLogTimeRange');
         OPEN translateArcLogTimeRange(thread#     => thread#,
                                       incarn      => NVL(lincarn,0),
                                       fromTime    => fromTime,
                                       toTime      => toTime,
                                       pattern     => pattern,
                                       statusMask  => mask,
                                       online      => online,
                                       needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogTimeRange';
      END IF;
      getArchivedLogNoRows.error := -20242;
      getArchivedLogNoRows.msg   := 'No archived logs in the range specified';
   END IF;
   getArchivedLogDuplicates   := duplicates;
   deb(DEB_EXIT);
END translateArchivedLogTimeRange;
 
--
--
--
--
--
--
--
 
--
PROCEDURE translateArchivedLogSCNRange(
   thread#      IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,deleted      IN number         DEFAULT NULL    -- for compatability
  ,online       IN number
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatability
  ,needstby     IN number         DEFAULT NULL
  ,doingRecovery IN  number DEFAULT FALSE#
  ,onlyrdf      IN binary_integer DEFAULT 0
  ,reset_scn    IN number         DEFAULT NULL    -- for compatibility
  ,reset_time   IN date           DEFAULT NULL    -- for compatibility
  ,sequence#    IN number         DEFAULT NULL    -- for compatibility
  ,foreignal    IN binary_integer DEFAULT 0       -- for compatability
  ,incarn       IN number         DEFAULT NULL)   -- for compatibility
IS
   adjusted_toSCN number;
   mask           number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
   lincarn        number := incarn;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogSCNRange');
   validateState(getArchivedLogCursor);
 
   IF (untilTime IS NULL) THEN
--
--
--
--
      adjusted_toSCN := least(nvl(toSCN, untilSCN), nvl(untilSCN, toSCN));
   ELSE
--
--
--
--
--
--
      adjusted_toSCN := toSCN;
   END IF;
 
--
--
--
--
--
   IF (adjusted_toSCN <= fromSCN) THEN
      adjusted_toSCN := fromSCN+1;
   END IF;
 
   setAlTransClause(thread  => thread#,
                    fromSCN => fromSCN,
                    toSCN   => adjusted_toSCN,
                    pattern => pattern);
 
--
--
--
--
 
  IF (foreignal != 0) THEN
      IF (tc_dbid.count = 0) THEN
         tc_anydbid := TRUE#;
      END IF;
      deb(DEB_OPEN, 'translateFrgnArcLogSCNRange');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
         deb(DEB_OPEN, 'translateArcLogSCNRange2');
         OPEN translateArcLogSCNRange2(thread#     => thread#,
                                       incarn      => NVL(lincarn,0),
                                       sequence#   => sequence#,
                                       fromSCN     => fromSCN,
                                       toSCN       => adjusted_toSCN,
                                       toTime      => untilTime,
                                       statusMask  => mask,
                                       online      => online,
                                       needstby    => needstby,
                                       reset_scn   => reset_scn,
                                       reset_time  => reset_time);
         getArchivedLogCursor       := 'translateArcLogSCNRange2';
         deb(DEB_IN, ' using cursor 2 fromSCN=' ||
             to_char(fromSCN) || ' toSCN=' || to_char(adjusted_toSCN));
      ELSE
         deb(DEB_OPEN, 'translateArcLogSCNRange');
         OPEN translateArcLogSCNRange(thread#     => thread#,
                                      incarn      => NVL(lincarn,0),
                                      sequence#   => sequence#,
                                      fromSCN     => fromSCN,
                                      toSCN       => adjusted_toSCN,
                                      pattern     => pattern,
                                      statusMask  => mask,
                                      online      => online,
                                      needstby    => needstby,
                                      reset_scn   => reset_scn,
                                      reset_time  => reset_time);
         getArchivedLogCursor       := 'translateArcLogSCNRange';
      END IF;
      getArchivedLogNoRows.error := -20242;
      getArchivedLogNoRows.msg   := 'No archived logs in the range specified';
   END IF;
   getArchivedLogDuplicates   := duplicates;
   getArchivedLogDoingRecovery := DoingRecovery;
   IF (DoingRecovery = TRUE#) THEN
     deb(DEB_PRINT, 'getArchivedLogDoingRecovery set to TRUE');
   END IF;
   getArchivedLogOnlyrdf := onlyrdf;
   deb(DEB_EXIT);
END translateArchivedLogSCNRange;
 
--
--
 
--
PROCEDURE translateArchivedLogPattern(
   pattern      IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,deleted      IN number         DEFAULT NULL    -- for compatability
  ,online       IN number
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatability
  ,needstby     IN number         DEFAULT NULL    -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0)      -- for compatability
IS
   mask           number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogPattern');
   IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
--
     translateArchivedLogSCNRange(
        thread#     => NULL,
        fromscn     => 0,
        toscn       => highscnval+1,
        pattern     => NULL,
        statusMask  => mask,
        online      => online,
        duplicates  => duplicates,
        foreignal   => foreignal);
   ELSE
     validateState(getArchivedLogCursor);
     setAlTransClause(pattern => pattern);
     IF (foreignal != 0) THEN
        IF (tc_dbid.count = 0) THEN
           tc_anydbid := TRUE#;
        END IF;
        deb(DEB_OPEN, 'translateFrgnArcLogPattern');
--
        raise_application_error(-20999, 'Not supported in recovery catalog');
--
     ELSE
        deb(DEB_OPEN, 'translateArcLogPattern');
        OPEN translateArcLogPattern(pattern     => pattern,
                                    statusMask  => mask,
                                    online      => online);
        getArchivedLogCursor       := 'translateArcLogPattern';
        getArchivedLogNoRows.error := -20242;
        getArchivedLogNoRows.msg   :=
           'No archived logs in the range specified';
     END IF;
     getArchivedLogDuplicates   := duplicates;
   END IF;
   deb(DEB_EXIT);
END translateArchivedLogPattern;
 
--
PROCEDURE translateArchivedLogCancel
IS
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogCancel');
   IF (getArchivedLogCursor = 'translateArcLogKey') THEN
      CLOSE translateArcLogKey;
   ELSIF (getArchivedLogCursor = 'translateArcLogName') THEN
      CLOSE translateArcLogName;
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange') THEN
      CLOSE translateArcLogSeqRange;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSeqRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange2') THEN
      CLOSE translateArcLogSeqRange2;
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange') THEN
      CLOSE translateArcLogTimeRange;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogTimeRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange2') THEN
      CLOSE translateArcLogTimeRange2;
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange') THEN
      CLOSE translateArcLogSCNRange;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSCNRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange2') THEN
      CLOSE translateArcLogSCNRange2;
   ELSIF (getArchivedLogCursor = 'translateArcLogPattern') THEN
      CLOSE translateArcLogPattern;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogPattern') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   END IF;
   getArchivedLogCursor := NULL;                -- we closed it above
   getArchivedLogLast   := NULL;                -- clear for next time
   getArchivedLogDoingRecovery := FALSE#;       -- clear for next time
   resetAlTransClause;
   deb(DEB_EXIT);
END translateArchivedLogCancel;
 
--
--
--
 
--
PROCEDURE getArchivedLog(
   recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,nxt_scn      OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,blocks       OUT number)
IS
   alRec alRec_t;
BEGIN
   deb(DEB_ENTER, 'getArchivedLog');
<<retry>>
   getArchivedLog(alRec);
 
--
--
--
 
--
   recid      := nvl(alRec.recid,0);    -- no null indicator before 8.1.6
   stamp      := nvl(alRec.stamp, 0);   -- no null indicator before 8.1.6
   thread#    := alRec.thread;
   sequence#  := alRec.sequence;
   low_scn    := alRec.lowSCN;
   nxt_scn    := alRec.nextSCN;
   fname      := nvl(alRec.fileName, 'null');   -- no null indicator
   reset_scn  := alRec.rlgSCN;
   block_size := alRec.blockSize;
   blocks     := alRec.blocks;
   deb(DEB_EXIT);
 
EXCEPTION
   WHEN no_data_found THEN
      recid := NULL;                    -- indicate end-of-fetch
      stamp := NULL;
      deb(DEB_EXIT, 'with no more records');
END getArchivedLog;
 
--
--
--
 
--
 
--
PROCEDURE translateControlFileCopyName(
   fname        IN varchar2
  ,available    IN number           DEFAULT NULL  -- for compatability
  ,unavailable  IN number           DEFAULT NULL  -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer   DEFAULT NULL  -- for compatability
  ,onlyone      IN number           DEFAULT 1) IS
BEGIN
   deb(DEB_ENTER, 'translateControlFileCopyName');
--
   getControlFileCopyCursor := 'findControlfileBackup_c';
   deb(DEB_OPEN, 'findControlfileBackup_c');
   OPEN findControlfileBackup_c(sourcemask         => imageCopy_con_t,
                                pattern            => fname,
                                currentIncarnation => FALSE#,
                                statusMask         => NVL(statusMask,
                                computeAvailableMask(available,unavailable,0,0)));
 
--
   IF (duplicates = FALSE# and onlyone is NOT NULL) THEN
      getControlFileCopySingleRow := TRUE;
   ELSE
      getControlFileCopySingleRow := FALSE;
   END IF;
   deb(DEB_EXIT);
END translateControlFileCopyName;
 
 
--
 
--
PROCEDURE translateControlFileCopyTag(
   cftag        IN varchar2
  ,available    IN number           DEFAULT NULL -- for compatability
  ,unavailable  IN number           DEFAULT NULL -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer   DEFAULT NULL
  ,onlyone      IN number           DEFAULT 1) IS
BEGIN
   deb(DEB_ENTER, 'translateControlFileCopyTag');
--
   deb(DEB_OPEN, 'findControlfileBackup_c');
   getControlFileCopyCursor := 'findControlfileBackup_c';
   OPEN findControlfileBackup_c(
                            sourcemask         => imageCopy_con_t,
                            tag                => cftag,
                            currentIncarnation => FALSE#,
                            statusMask         => NVL(statusMask,
                            computeAvailableMask(available,unavailable,0,0)));
 
--
   IF (duplicates = FALSE# and onlyone is NOT NULL) THEN
      getControlFileCopySingleRow := TRUE;
   ELSE
      getControlFileCopySingleRow := FALSE;
   END IF;
   deb(DEB_EXIT);
END translateControlFileCopyTag;
 
 
--
 
--
PROCEDURE translateControlFileCopyKey(
   key          IN number
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL) IS -- for compatability
BEGIN
   deb(DEB_ENTER, 'translateControlFileCopyKey');
 
--
   deb(DEB_OPEN, 'findControlFileCopyKey');
 
--
--
   getControlFileCopyCursor := 'findControlFileCopyKey';
   OPEN findControlFileCopyKey(
                            copyKey            => key,
                            statusMask         => NVL(statusMask,
                            computeAvailableMask(available,unavailable,0,0)));
 
   deb(DEB_EXIT);
 
END translateControlFileCopyKey;
 
 
--
PROCEDURE getControlFileCopy(
   rcvRec       IN OUT NOCOPY rcvRec_t)
IS
   getControlFileCopyRowcount   number;
BEGIN
   deb(DEB_ENTER, 'getControlFileCopy');
   IF (getControlFileCopyCursor = 'findControlFileCopyKey'
       AND findControlFileCopyKey%ISOPEN) THEN
      FETCH findControlFileCopyKey
       INTO rcvRec;
 
<<NextRow>>
      IF (findControlFileCopyKey%NOTFOUND) THEN
 
--
         getControlFileCopyRowcount := findControlFileCopyKey%ROWCOUNT;
         CLOSE findControlFileCopyKey;
 
         IF (getControlFileCopyRowcount = 0) THEN
            deb(DEB_EXIT, 'with error 20220');
            raise_application_error(-20220, 'Controlfile copy does not exist');
         ELSE
            deb(DEB_EXIT, 'with no more records');
            RAISE no_data_found;                   -- signal end-of-fetch
         END IF;
      END IF;
      IF (getControlFileCopySingleRow = TRUE AND
          findControlFileCopyKey%ROWCOUNT > 1) THEN
--
--
         CLOSE findControlFileCopyKey;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSIF (getControlFileCopyCursor = 'findControlfileBackup_c'
          AND findControlfileBackup_c%ISOPEN) THEN
      FETCH findControlfileBackup_c
       INTO rcvRec;
 
      IF (findControlfileBackup_c%NOTFOUND) THEN
 
--
         getControlFileCopyRowcount := findControlfileBackup_c%ROWCOUNT;
         CLOSE findControlfileBackup_c;
 
         IF (getControlFileCopyRowcount = 0) THEN
            deb(DEB_EXIT, 'with error 20220');
            raise_application_error(-20220, 'Controlfile copy does not exist');
         ELSE
            deb(DEB_EXIT, 'with no more records');
            RAISE no_data_found;                   -- signal end-of-fetch
         END IF;
      END IF;
      IF (getControlFileCopySingleRow = TRUE AND
          findControlfileBackup_c%ROWCOUNT > 1) THEN
--
--
         CLOSE findControlfileBackup_c;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started (' ||
                                       getControlFileCopyCursor || ')');
   END IF;
   deb(DEB_EXIT);
END getControlFileCopy;
 
--
 
--
PROCEDURE getControlFileCopy(
   recid        OUT number
  ,stamp        OUT number
  ,reset_scn    OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getControlFileCopy');
   getControlFileCopy(rcvRec);
 
   recid      := rcvRec.recid_con;
   stamp      := rcvRec.stamp_con;
   reset_scn  := rcvRec.rlgSCN_act;
   ckp_scn    := rcvRec.toSCN_act;
   block_size := rcvRec.blockSize_con;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with no more records');
--
      recid := NULL;                    -- signal end-of-fetch to caller
END getControlFileCopy;
 
--
--
--
 
--
PROCEDURE getDataFileCopy(
   rcvRec      OUT NOCOPY rcvRec_t
  ,closeCursor IN  boolean DEFAULT FALSE)
IS
   getDataFileCopyRowcount      number;
   local                        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFileCopy');
 
<<nextRow>>
   IF (getDatafileCopyCursor = 'findDatafileCopyKey') THEN
      FETCH findDatafileCopyKey
       INTO local;
 
      IF (findDatafileCopyKey%NOTFOUND) THEN
         getDataFileCopyRowcount := findDatafileCopyKey%ROWCOUNT;
         CLOSE findDatafileCopyKey;
      END IF;
 
      IF (closeCursor AND findDatafileCopyKey%ISOPEN) THEN
         CLOSE findDatafileCopyKey;
      END IF;
   ELSIF (getDatafileCopyCursor = 'findDatafileBackup_c') THEN
      IF (getDataFileCopySingleRow = TRUE AND
          findDatafileBackup_c%ROWCOUNT > 1) THEN
--
--
         CLOSE findDatafileBackup_c;
         getDatafileCopyCursor := NULL;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
 
      FETCH findDatafileBackup_c
       INTO local;
 
      IF (findDatafileBackup_c%NOTFOUND) THEN
         getDataFileCopyRowcount := findDatafileBackup_c%ROWCOUNT;
         CLOSE findDatafileBackup_c;
      END IF;
 
      IF (closeCursor AND findDatafileBackup_c%ISOPEN) THEN
         CLOSE findDatafileBackup_c;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor) THEN
      getDatafileCopyCursor := NULL;
   END IF;
 
   IF (getDataFileCopyRowcount IS NOT NULL) THEN
      getDatafileCopyCursor := NULL;
      IF (getDataFileCopyRowcount = 0 AND
          getDatafileCopyNoRows.error IS NOT NULL) THEN
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getDatafileCopyNoRows.error,
                                 getDatafileCopyNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
 
   IF (getDataFileCopyLatestOnly = TRUE AND
       getDataFileCopyLast.dfNumber_obj = local.dfNumber_obj) THEN
      GOTO nextRow;
   END IF;
 
   getDataFileCopyLast := local;                -- save for duplicate filtering
   rcvRec := local;                             -- set OUT mode arg
   setDfTransClause(fno => local.dfNumber_obj);
   deb(DEB_EXIT);
END getDataFileCopy;
 
--
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFileCopyKey');
   validateState(getDatafileCopyCursor);
 
--
   deb(DEB_OPEN, 'findDataFileCopyKey');
   OPEN findDataFileCopyKey(copyKey            => cdf_key,
                            statusMask         => NVL(statusMask,
                               computeAvailableMask(available, unavailable,
                                                    0, 0)));
 
   getDatafileCopyCursor       := 'findDatafileCopyKey';
   getDataFileCopyNoRows.error := -20230;
   getDataFileCopyNoRows.msg   := 'Datafile copy does not exist';
   getDataFileCopyDuplicates   := NULL;
   getDataFileCopySingleRow    := NULL;
   deb(DEB_EXIT);
END translateDatafileCopyKey;
 
--
--
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,file#        OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,create_scn   OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number
  ,blocks       OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'translateDataFileCopyKey815');
   translateDataFileCopyKey(cdf_key     => cdf_key,
                            available   => available,
                            unavailable => unavailable);
 
   getDataFileCopy(rcvRec      => rcvRec,
                   closeCursor => TRUE);
 
   recid        := rcvRec.recid_con;
   stamp        := rcvRec.stamp_con;
   file#        := rcvRec.dfNumber_obj;
   fname        := rcvRec.fileName_con;
   reset_scn    := rcvRec.rlgSCN_act;
   create_scn   := rcvRec.dfCreationSCN_obj;
   ckp_scn      := rcvRec.toSCN_act;
   block_size   := rcvRec.blockSize_con;
   blocks       := rcvRec.blocks_con;
   deb(DEB_EXIT);
END translateDataFileCopyKey;
 
--
--
--
--
 
--
PROCEDURE translateDatafileCopyName(
   fname       IN varchar2
  ,available   IN number         DEFAULT NULL   -- for compatability
  ,unavailable IN number         DEFAULT NULL   -- for compatability
  ,duplicates  IN number
  ,statusMask  IN binary_integer DEFAULT NULL   -- for compatability
  ,onlyone     IN number         DEFAULT 1
  ,pluginSCN   IN number         DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateDatafileCopyName');
   validateState(getDatafileCopyCursor);
 
--
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(
                        sourcemask   => imageCopy_con_t,
                        pattern      => fname,
                        statusMask   => nvl(statusMask,
                                            computeAvailableMask(available,
                                                                 unavailable,
                                                                 0, 0)),
                        duplicates   => duplicates,
                        pluginSCN    => pluginSCN
                        );
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDatafileCopyNoRows.error      := -20230;
   getDatafileCopyNoRows.msg        := 'Datafile copy does not exist';
   getDatafileCopyDuplicates        := duplicates;
   getDatafileCopyLast.dfNumber_obj := NULL;
   getDatafileCopyLatestOnly        := FALSE;
   IF (duplicates = FALSE# and onlyone is NOT NULL) THEN
      getDatafileCopySingleRow := TRUE;
   ELSE
      getDatafileCopySingleRow := FALSE;
   END IF;
   deb(DEB_EXIT);
END translateDatafileCopyName;
 
--
--
--
--
--
--
--
--
 
--
PROCEDURE translateDataFileCopyTag(
   tag          IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatibility
  ,unavailable  IN number         DEFAULT NULL    -- for compatibility
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatibility
  ,pluginSCN    IN number         DEFAULT 0
  ,onlytc       IN binary_integer DEFAULT FALSE#) -- for compatibility
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFileCopyTag');
   validateState(getDatafileCopyCursor);
 
--
--
--
--
   deb(DEB_OPEN, 'findDataFileBackup_c');
 
   if (onlytc != FALSE#) THEN
      deb(DEB_PRINT, 'onytc is TRUE#');
   end if;
 
   OPEN findDatafileBackup_c(
                         sourcemask   => imageCopy_con_t,
                         tag          => tag,
                         reset_scn    => this_reset_scn,
                         reset_time   => this_reset_time,
                         statusMask   => nvl(statusMask,
                                             computeAvailableMask(available,
                                                                  unavailable,
                                                                  0, 0)),
                         duplicates   => duplicates,
                         pluginSCN    => pluginSCN,
                         onlytc       => onlytc
                         );
 
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDataFileCopyNoRows.error      := -20232;
   getDataFileCopyNoRows.msg        := 'Datafile copy tag does not match';
   getDataFileCopyDuplicates        := duplicates;
   getDataFileCopyLast.dfNumber_obj := NULL;
   getDataFileCopySingleRow         := FALSE;
   getDataFileCopyLatestOnly        := FALSE;
   deb(DEB_EXIT);
END translateDataFileCopyTag;
 
--
--
--
--
 
--
PROCEDURE translateDatafileCopyFno(
   fno         IN number
  ,available   IN number         DEFAULT NULL
  ,unavailable IN number         DEFAULT NULL
  ,duplicates  IN number
  ,statusMask  IN binary_integer DEFAULT NULL
  ,pluginSCN   IN number         DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateDatafileCopyFno');
   validateState(getDatafileCopyCursor);
 
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(
                         duplicates   => duplicates,
                         sourcemask   => imageCopy_con_t,
                         fno          => fno,
                         statusMask   =>  NVL(statusMask,
                                              computeAvailableMask(available,
                                                                   unavailable,
                                                                   0, 0)),
                         pluginSCN    => pluginSCN
                         );
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDatafileCopyNoRows.error      := -20230;
   getDatafileCopyNoRows.msg        := 'Datafile copy does not exist';
   getDatafileCopyDuplicates        := duplicates;
   getDatafileCopyLatestOnly        := FALSE;
   getDatafileCopyLast.dfNumber_obj := NULL;
   IF (duplicates = FALSE#) THEN
      getDatafileCopySingleRow := TRUE;
   ELSE
      getDatafileCopySingleRow := FALSE;
   END IF;
   setDfTransClause(fno => fno);
   deb(DEB_EXIT);
END translateDatafileCopyFno;
 
--
--
PROCEDURE getDataFileCopy(
   recid OUT number
  ,stamp OUT number
  ,file# OUT number
  ,fname OUT varchar2
  ,reset_scn OUT number
  ,create_scn OUT number
  ,ckp_scn OUT number
  ,block_size OUT number
  ,blocks OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFileCopy');
   getDataFileCopy(rcvRec);
 
   recid        := rcvRec.recid_con;
   stamp        := rcvRec.stamp_con;
   file#        := rcvRec.dfNumber_obj;
   fname        := rcvRec.fileName_con;
   reset_scn    := rcvRec.rlgSCN_act;
   create_scn   := rcvRec.dfCreationSCN_obj;
   ckp_scn      := rcvRec.toSCN_act;
   block_size   := rcvRec.blockSize_con;
   blocks       := rcvRec.blocks_con;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      recid := NULL;                    -- signal end-of-fetch to client
      deb(DEB_EXIT, 'with no more records');
END getDataFileCopy;
 
--
--
--
 
--
PROCEDURE getProxyCopy(
   rcvRec      OUT NOCOPY rcvRec_t
  ,closeCursor IN  boolean DEFAULT FALSE)
IS
   getProxyCopyRowcount number;
   dummy                rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getProxyCopy');
   IF (getProxyCopyCursor = 'findProxyCopy') THEN
      FETCH findProxyCopy
       INTO rcvRec;
 
      IF (findProxyCopy%NOTFOUND) THEN
         getProxyCopyRowcount := findProxyCopy%ROWCOUNT;
         CLOSE findProxyCopy;
      ELSE
         IF (getProxyCopyByHandle) THEN
--
            FETCH findProxyCopy
             INTO dummy;
            IF (NOT findProxyCopy%NOTFOUND) THEN
               CLOSE findProxyCopy;
               deb(DEB_EXIT, 'with error 20311');
               raise_application_error(-20311, 'Ambiguous proxy copy handle');
            END IF;
         END IF;
      END IF;
 
      IF (closeCursor AND findProxyCopy%ISOPEN) THEN
         CLOSE findProxyCopy;
      END IF;
   ELSIF (getProxyCopyCursor = 'findProxyCopyKey') THEN
      FETCH findProxyCopyKey
       INTO rcvRec;
 
      IF (findProxyCopyKey%NOTFOUND) THEN
         getProxyCopyRowcount := findProxyCopyKey%ROWCOUNT;
         CLOSE findProxyCopyKey;
      END IF;
 
      IF (closeCursor AND findProxyCopyKey%ISOPEN) THEN
         CLOSE findProxyCopyKey;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with errors 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor) THEN
      getProxyCopyCursor := NULL;
   END IF;
 
   IF (getProxyCopyRowcount IS NOT NULL) THEN
      getProxyCopyCursor := NULL;
      IF (getProxyCopyRowcount = 0 AND
          getProxyCopyNoRows.error IS NOT NULL) THEN
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getProxyCopyNoRows.error,
                                 getProxyCopyNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
   deb(DEB_EXIT);
 
END getProxyCopy;
 
--
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyKey');
   validateState(getProxyCopyCursor);
 
   deb(DEB_OPEN, 'findProxyCopyKey');
   OPEN findProxyCopyKey(key            => pc_key,
                         deviceType     => deviceType,
                         statusMask     => NVL(statusMask,
                  computeAvailableMask(available, unavailable, deleted,
                                       expired)));
   getProxyCopyCursor       := 'findProxyCopyKey';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'proxy copy is missing';
   getProxyCopyByHandle     := FALSE;
   deb(DEB_EXIT);
END translateProxyCopyKey;
 
--
 
--
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyKey815');
   translateProxyCopyKey(pc_key         => pc_key,
                         deviceType     => device_type,
                         available      => available,
                         unavailable    => unavailable,
                         deleted        => deleted,
                         expired        => unavailable);
 
   getProxyCopy(rcvRec      => rcvRec,
                closeCursor => TRUE);
 
   recid  := rcvRec.recid_con;
   stamp  := rcvRec.stamp_con;
   handle := rcvRec.fileName_con;
   deb(DEB_EXIT);
END translateProxyCopyKey;
 
--
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyHandle');
   validateState(getProxyCopyCursor);
 
   deb(DEB_OPEN, 'findProxyCopy');
   OPEN findProxyCopy(handle      => handle,
                      deviceType  => deviceType,
                      statusMask  => NVL(statusMask,
                          computeAvailableMask(available, unavailable, deleted,
                                               expired)));
   getProxyCopyCursor       := 'findProxyCopy';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'proxy copy is missing';
   getProxyCopyByHandle     := TRUE;
   deb(DEB_EXIT);
END translateProxyCopyHandle;
 
--
 
--
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyHandle815');
   translateProxyCopyHandle(handle      => handle,
                            deviceType  => device_type,
                            available   => available,
                            unavailable => unavailable,
                            deleted     => deleted,
                            expired     => unavailable);
 
   getProxyCopy(rcvRec      => rcvRec,
                closeCursor => TRUE);
 
   recid  := rcvRec.recid_con;
   stamp  := rcvRec.stamp_con;
   deb(DEB_EXIT);
END translateProxyCopyHandle;
 
--
 
--
PROCEDURE translateProxyCopyTag(
   tag         IN varchar2
  ,device_type IN varchar2
  ,available   IN number           DEFAULT NULL   -- for compatability
  ,unavailable IN number           DEFAULT NULL   -- for compatability
  ,deleted     IN number           DEFAULT NULL   -- for compatability
  ,statusMask  IN binary_integer   DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyTag');
   validateState(getProxyCopyCursor);
   deb(DEB_OPEN, 'findProxyCopy');
   OPEN findProxyCopy(tag            => tag,
                      deviceType     => device_type,
                      statusMask     => NVL(statusMask,
                          computeAvailableMask(available, unavailable, deleted,
                                               unavailable/*expired*/)));
   getProxyCopyCursor       := 'findProxyCopy';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'no matching proxy copy found';
   getProxyCopyByHandle     := FALSE;
   deb(DEB_EXIT);
END translateProxyCopyTag;
 
--
PROCEDURE translateProxyCopyGuid(
   guid        IN varchar2
  ,device_type IN varchar2
  ,statusMask  IN binary_integer)
IS
   pdbKey number := NULL;
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyGuid');
   validateState(getProxyCopyCursor);
   deb(DEB_OPEN, 'findProxyCopy');
 
--
   pdbKey := guidToPdbKey(guid);
--
 
   OPEN findProxyCopy(pdbKey         => pdbKey,
                      guid           => guid,
                      deviceType     => device_type,
                      statusMask     => NVL(statusMask, 0));
   getProxyCopyCursor       := 'findProxyCopy';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'no matching proxy copy found';
   getProxyCopyByHandle     := FALSE;
   deb(DEB_EXIT);
END translateProxyCopyGuid;
 
 
--
 
--
PROCEDURE getProxyCopy(
   recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getProxyCopyHandle');
   getProxyCopy(rcvRec);
   recid  := rcvRec.recid_con;
   stamp  := rcvRec.stamp_con;
   handle := rcvRec.fileName_con;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      recid := NULL;                    -- indicate end-of-fetch
      deb(DEB_EXIT, 'with no more records');
END getProxyCopy;
 
--
--
--
 
--
PROCEDURE getBackupPiece(
   bpRec        OUT NOCOPY bpRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE)
IS
   dummy        bpRec_t;
   local        bpRec_t;
   eof          boolean := FALSE;
   eob          boolean := FALSE;
   raiseError   boolean := FALSE;
BEGIN
   deb(DEB_ENTER, 'getBackupPiece');
   IF (getBackupPieceDuplicates = FALSE# AND
       getBackupPieceDeviceType IS NULL) THEN
--
--
--
      deb(DEB_EXIT, 'with error 20999');
      raise_application_error(-20999, 'deviceType must be specified');
   END IF;
 
<<nextRow>>
 
   IF (getBackupPieceCursor = 'findBackupPieceBpKey') THEN
      FETCH findBackupPieceBpKey
       INTO local;
 
      IF (findBackupPieceBpKey%NOTFOUND) THEN
         eof := TRUE;
         CLOSE findBackupPieceBpKey;
      END IF;
 
      IF (closeCursor AND findBackupPieceBpKey%ISOPEN) THEN
         CLOSE findBackupPieceBpKey;
      END IF;
   ELSIF (getBackupPieceCursor = 'findBackupPieceBsKey1') THEN
      FETCH findBackupPieceBsKey1
       INTO local;
 
      IF (findBackupPieceBsKey1%NOTFOUND) THEN
         eof := TRUE;
         CLOSE findBackupPieceBsKey1;
      END IF;
 
      IF (closeCursor AND findBackupPieceBsKey1%ISOPEN) THEN
         CLOSE findBackupPieceBsKey1;
      END IF;
   ELSIF (getBackupPieceCursor = 'findBackupPieceBsKey2') THEN
--
      local := getBackupPieceSeekLast;
      deb(DEB_PRINT, 'bskey = ' || local.bskey);
 
--
      IF (local.bskey != getBackupPieceBsKey              OR
          local.deviceType != getBackupPieceDeviceType    OR
          (getBackupPieceCopyNumber IS NOT NULL AND
           local.copyNumber != getBackupPieceCopyNumber)) THEN
         eob := TRUE;
         deb(DEB_PRINT, 'end of backupset');
      ELSE
         <<checkAgain>>
         LOOP
--
            FETCH findBackupPieceBsKey2
             INTO dummy;
 
            IF (findBackupPieceBsKey2%NOTFOUND) THEN
               CLOSE findBackupPieceBsKey2;
               dummy.bskey := 0;
            END IF;
 
            IF (dummy.bskey != getBackupPieceBsKey               OR
                dummy.deviceType != getBackupPieceDeviceType     OR
                getBackupPieceCopyNumber IS NULL                 OR
                dummy.copyNumber = getBackupPieceCopyNumber) THEN
               getBackupPieceSeekLast := dummy;
               EXIT checkAgain;
            END IF;
         END LOOP;
         deb(DEB_PRINT, 'next bskey=' || getBackupPieceSeekLast.bskey);
      END IF;
   ELSIF (getBackupPieceCursor = 'findBackupPiece_c') THEN
      FETCH findBackupPiece_c
       INTO local;
 
      IF (findBackupPiece_c%NOTFOUND) THEN
         eof := TRUE;
         CLOSE findBackupPiece_c;
      ELSE
         IF (getBackupPieceByHandle) THEN
--
            FETCH findBackupPiece_c
             INTO dummy;
            IF (NOT findBackupPiece_c%NOTFOUND) THEN
               raiseError := TRUE;
--
--
--
--
--
--
--
--
 
 
               
               IF (raiseError) THEN
                  CLOSE findBackupPiece_c;
                  deb(DEB_EXIT, 'with error 20261');
                  raise_application_error(-20261,
                                          'Ambiguous backup piece handle');
               END IF;
            END IF;
         END IF;
      END IF;
 
      IF (closeCursor AND findBackupPiece_c%ISOPEN) THEN
         CLOSE findBackupPiece_c;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor OR eof) THEN
      getBackupPieceCursor := NULL;
   END IF;
 
   IF (eof OR eob) THEN           -- if end of fetch or end of backupset
--
--
      IF (getBackupPieceDuplicates = FALSE#) THEN
--
--
--
         IF (getBackupPieceExpectedPieces IS NOT NULL AND
             (getBackupPieceAvailableMask IS NULL  OR
              bitand(getBackupPieceAvailableMask,
                     dbms_rcvman.BSpartial_avail) = 0) AND
             getBackupPieceExpectedPieces <> getBackupPiecePieceCount) THEN
             deb(DEB_EXIT, 'with error 20216');
             raise_application_error(-20216, 'Backup piece is missing');
         END IF;
      END IF;
      IF (getBackupPiecePieceCount = 0 AND
          getBackupPieceNoRows.error IS NOT NULL) THEN
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getBackupPieceNoRows.error,
                                 getBackupPieceNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'no more records');
         RAISE no_data_found;
      END IF;
   END IF;
 
   IF (getBackupPieceDuplicates = FALSE#) THEN
--
--
      IF (local.pieceNumber = getBackupPieceLast.pieceNumber) THEN
--
         GOTO nextRow;
      END IF;
   END IF;
 
   getBackupPieceLast := local;
   bpRec := local;                              -- set OUT mode arg
 
   getBackupPiecePieceCount := getBackupPiecePieceCount + 1;
   deb(DEB_EXIT);
END getBackupPiece;
 
--
PROCEDURE translateBackupPieceKey(
   key          IN number
  ,available    IN number             DEFAULT TRUE#
  ,unavailable  IN number             DEFAULT TRUE#
  ,expired      IN number             DEFAULT TRUE#
  ,statusMask   IN binary_integer     DEFAULT NULL)  -- for compatability
IS
BEGIN
--
--
--
--
--
 
   deb(DEB_ENTER, 'translateBackupPieceKey');
   findBackupPiece(bpKey       => key,
                   statusMask  => NVL(statusMask,
                computeAvailableMask(available, unavailable, 0, unavailable)));
 
   getBackupPieceNoRows.error   := -20260;
   getBackupPieceNoRows.msg     := 'Backup piece is missing';
   getBackupPieceAvailableMask  := statusMask;
   deb(DEB_EXIT);
END translateBackupPieceKey;
 
--
PROCEDURE translateBackupPieceKey(
   bp_key       IN number
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number)
IS
   bpRec        bpRec_t;
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceKey');
--
--
--
--
--
--
--
 
   translateBackupPieceKey(key => bp_key,
                   statusMask  =>
                computeAvailableMask(available, unavailable, 0,
                                     unavailable/*expired*/));
 
   getBackupPiece(bpRec       => bpRec,
                  closeCursor => TRUE);
 
   recid     := bpRec.recid;
   stamp     := bpRec.stamp;
   handle    := bpRec.handle;
   set_stamp := bpRec.setStamp;
   set_count := bpRec.setCount;
   piece#    := bpRec.pieceNumber;
   deb(DEB_EXIT);
 
END translateBackupPieceKey;
 
--
PROCEDURE translateBackupPieceHandle(
   handle       IN varchar2
  ,deviceType   IN varchar2
  ,available    IN number             DEFAULT NULL   -- for compatability
  ,unavailable  IN number             DEFAULT NULL   -- for compatability
  ,expired      IN number             DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer     DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceHandle');
   findBackupPiece(handle      => handle,
                   deviceType  => deviceType,
                   statusMask  => NVL(statusMask,
                  computeAvailableMask(available, unavailable, 0, expired)));
 
   getBackupPieceNoRows.error   := -20260;
   getBackupPieceNoRows.msg     := 'Backup piece is missing';
   getBackupPieceByHandle       := TRUE;
   getBackupPieceAvailableMask  := statusMask;
   deb(DEB_EXIT);
END translateBackupPieceHandle;
 
--
PROCEDURE translateBackupPieceHandle(                     -- only used in 8.1.6
   handle       IN varchar2
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number)
IS
   bpRec        bpRec_t;
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceHandle816');
   translateBackupPieceHandle(handle      => handle,
                              deviceType  => device_type,
                              statusMask  =>
                             computeAvailableMask(available, unavailable, 0,
                                                  unavailable/*expired*/));
 
   getBackupPiece(bpRec       => bpRec,
                  closeCursor => TRUE);
 
   recid     := bpRec.recid;
   stamp     := bpRec.stamp;
   set_stamp := bpRec.setStamp;
   set_count := bpRec.setCount;
   piece#    := bpRec.pieceNumber;
   deb(DEB_EXIT);
END translateBackupPieceHandle;
 
--
--
PROCEDURE translateBackupPieceTag(
   tag         IN varchar2
  ,available   IN number             DEFAULT NULL     -- for compatability
  ,unavailable IN number             DEFAULT NULL     -- for compatability
  ,statusMask  IN binary_integer     DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceTag');
 
   findBackupPiece(tag         => tag,
                   statusMask  => NVL(statusMask,
                  computeAvailableMask(available, unavailable, 0,
                                       /* expired = */unavailable)));
   deb(DEB_EXIT);
END translateBackupPieceTag;
 
--
--
PROCEDURE translateBackupPieceGuid(
   guid        IN varchar2
  ,statusMask  IN binary_integer)
IS
   pdbKey  number := NULL;
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceGuid');
 
--
   pdbKey := guidToPdbKey(guid);
--
 
   findBackupPiece(pdbKey      => pdbKey,
                   guid        => guid,
                   statusMask  => NVL(statusMask, 0));
   deb(DEB_EXIT);
END translateBackupPieceGuid;
 
--
PROCEDURE translateBackupPieceBSKey(
   key          IN number
  ,tag          IN varchar2        DEFAULT NULL
  ,deviceType   IN varchar2        DEFAULT NULL
  ,pieceCount   IN number
  ,duplicates   IN number          DEFAULT TRUE#
  ,copyNumber   IN number          DEFAULT NULL
  ,available    IN number          DEFAULT TRUE#
  ,unavailable  IN number          DEFAULT FALSE#
  ,deleted      IN number          DEFAULT FALSE#
  ,expired      IN number          DEFAULT FALSE#
  ,statusMask   IN binary_integer  DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceBSKey');
   findBackupPiece(bsKey       => key,
                   tag         => tag,
                   deviceType  => deviceType,
                   copyNumber  => copyNumber,
                   statusMask  => NVL(statusMask,
              computeAvailableMask(available, unavailable, deleted, expired)));
 
   getBackupPieceDuplicates     := duplicates;
   getBackupPieceExpectedPieces := pieceCount;
   getBackupPieceAvailableMask  := statusMask;
   deb(DEB_EXIT);
END translateBackupPieceBSKey;
 
--
PROCEDURE translateBackupPieceBsKey(
   startBsKey   IN number
  ,tag          IN varchar2           DEFAULT NULL
  ,statusMask   IN binary_integer     DEFAULT NULL)
IS
BEGIN
   findBackupPiece(startBsKey  => startBskey,
                   tag         => tag,
                   statusMask  => NVL(statusMask,
                computeAvailableMask(TRUE#    /* available */,
                                     FALSE# /* unavailable */,
                                     FALSE#     /* deleted */,
                                     FALSE#     /* expired */)));
   getBackupPieceAvailableMask  := statusMask;
END translateBackupPieceBsKey;
 
--
PROCEDURE translateSeekBpBsKey(
   bsKey        IN number
  ,deviceType   IN varchar2
  ,pieceCount   IN number
  ,duplicates   IN number    DEFAULT TRUE#
  ,copyNumber   IN number    DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateSeekBpBsKey');
   deb(DEB_IN, 'bskey=' || bsKey);
 
   IF (getBackupPieceCursor IS NULL OR
       getBackupPieceCursor != 'findBackupPieceBsKey2') THEN
      raise_application_error(-20204, 'Translation not started');
   ELSIF (deviceType IS NULL) THEN
      raise_application_error(-20999, 'deviceType must be specified');
   END IF;
 
--
--
   getBackupPieceNoRows.error     := NULL;
   getBackupPieceDuplicates       := duplicates;
   getBackupPieceLast.pieceNumber := NULL;
   getBackupPieceDeviceType       := deviceType;
   getBackupPieceExpectedPieces   := pieceCount;
   getBackupPiecePieceCount       := 0;
   getBackupPieceByHandle         := FALSE;
   getBackupPieceCopyNumber       := copyNumber;
   getBackupPieceBskey            := bsKey;
 
<<checkAgain>>
   LOOP
      IF (NOT findBackupPieceBsKey2%ISOPEN) THEN      -- all done
         deb(DEB_EXIT, 'cursor not open');
         RAISE no_data_found;
      END IF;
 
      IF (getBackupPieceSeekLast.bskey > bsKey) THEN  -- gone over the key
         deb(DEB_EXIT, 'gone over key seek=' || getBackupPieceSeekLast.bskey
                       || ' key=' || bsKey);
         RAISE no_data_found;
      END IF;
 
--
      IF (getBackupPieceSeekLast.bskey = bsKey              AND
          getBackupPieceSeekLast.deviceType = deviceType    AND
          (copyNumber IS NULL OR
           getBackupPieceSeekLast.copyNumber = copyNumber)) THEN
         EXIT checkAgain;
      END IF;
 
      FETCH findBackupPieceBsKey2
       INTO getBackupPieceSeekLast;
 
      IF (findBackupPieceBsKey2%NOTFOUND) THEN       -- all done
        CLOSE findBackupPieceBsKey2;
        deb(DEB_EXIT, 'no more data');
        RAISE no_data_found;
      END IF;
   END LOOP;
   deb(DEB_EXIT, 'got key=' || bsKey);
END translateSeekBpBsKey;
 
--
PROCEDURE translateBpBsKeyCancel
IS
BEGIN
   IF (findBackupPieceBsKey1%ISOPEN) THEN
      CLOSE findBackupPieceBsKey1;
   END IF;
   IF (findBackupPieceBsKey2%ISOPEN) THEN
      CLOSE findBackupPieceBsKey2;
   END IF;
   getBackupPieceCursor := NULL;
END translateBpBsKeyCancel;
 
--
--
PROCEDURE translateBackupSetKey(
   bs_key          IN  number
  ,device_type     IN  varchar2
  ,available       IN  number
  ,unavailable     IN  number
  ,deleted         IN  number
  ,duplicates      IN  number
  ,backup_type     OUT varchar2
  ,recid           OUT number
  ,stamp           OUT number
  ,set_stamp       OUT number
  ,set_count       OUT number
  ,bslevel         OUT number
  ,completion_time OUT date)
IS
   bsRec           bsRec_t;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetKey815');
   findBackupSet(bsKey => bs_key,               -- Lookup backset by key
                 bsRec => bsRec);
 
   backup_type     := bsRec.bsType;
   recid           := bsRec.recid;
   stamp           := bsRec.stamp;
   set_stamp       := bsRec.setStamp;
   set_count       := bsRec.setCount;
   bslevel         := bsRec.level;
   completion_time := bsRec.compTime;
 
--
--
--
--
--
--
 
--
   translateBackupPieceBSKey(key         => bs_key,
                             deviceType  => device_type,
                             pieceCount  => bsRec.pieceCount,
                             available   => available,
                             unavailable => unavailable,
                             deleted     => deleted,
                             expired     => unavailable);
 
   getBackupPieceDuplicates := duplicates;
 
   IF (device_type IS NULL) THEN
--
--
--
--
--
--
--
--
--
      getBackupPieceDuplicates := TRUE#;        -- yes, we want duplicates
   END IF;
 
   IF (getBackupPieceDuplicates = FALSE#) THEN
--
--
--
      getBackupPieceExpectedPieces := bsRec.pieceCount;
   END IF;
   deb(DEB_EXIT);
END translateBackupSetKey;
 
--
--
PROCEDURE translateBackupSetKey(
   bs_key          IN  number
  ,device_type     IN  varchar2
  ,available       IN  number
  ,unavailable     IN  number
  ,deleted         IN  number
  ,duplicates      IN  number
  ,backup_type     OUT varchar2
  ,recid           OUT number
  ,stamp           OUT number)
IS
   set_stamp       number;
   set_count       number;
   bslevel         number;
   completion_time date;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetKey80');
   translateBackupSetKey(bs_key, device_type, available, unavailable, deleted,
                         duplicates, backup_type, recid, stamp, set_stamp,
                         set_count, bslevel, completion_time);
   deb(DEB_EXIT);
END translateBackupSetKey;
 
--
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2
  ,bs_key      OUT number
  ,bslevel     OUT number
  ,completed   OUT date)
IS
   bsRec                bsRec_t;
   pieceCount           number;
   validationRec        validBackupSetRec_t;
   gotRecord            number;
   duplicates_flag      number;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetRecid815');
   findBackupSet(recid => recid,
                 stamp => stamp,
                 bsRec => bsRec);
 
   bs_key    := bsRec.key;
   bslevel   := bsRec.level;
   completed := bsRec.compTime;
 
--
--
--
--
 
   findValidBackupSet(backupSetRec              => bsRec,
                      tag                       => restoreTag,
                      deviceType                => device_type,
                      available                 => TRUE#);
 
   gotRecord := getValidBackupSet(validBackupSetRec => validationRec);
 
   IF (getValidBackupSetCursor = 'findValidBackupSet_c') THEN
      CLOSE findValidBackupSet_c;
   ELSIF (getValidBackupSetCursor = 'findValidBackupSet1P_c') THEN
      CLOSE findValidBackupSet1P_c;
   END IF;
 
   IF (gotRecord = FALSE#) THEN
--
--
--
--
      validationRec.copyNumber := NULL;
   END IF;
 
   IF (device_type IS NULL) THEN
--
      duplicates_flag := TRUE#;
   ELSE
--
      duplicates_flag := FALSE#;
   END IF;
 
   translateBackupPieceBSKey(key         => bsRec.key,
                             tag         => validationRec.tag,
                             deviceType  => device_type,
                             pieceCount  => bsRec.pieceCount,
                             duplicates  => duplicates_flag,
                             copyNumber  => validationRec.copyNumber,
                             available   => TRUE#);
   deb(DEB_EXIT);
END translateBackupSetRecid;
 
--
 
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2)
IS
   bs_key    number;
   bslevel   number;
   completed date;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetRecid80');
   translateBackupSetRecid(recid, stamp, device_type, bs_key, bslevel,
                          completed);
   deb(DEB_EXIT);
END translateBackupSetRecid;
 
--
--
PROCEDURE getBackupPiece(
   recid      OUT number
  ,stamp      OUT number
  ,bpkey      OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,piece#     OUT number
  ,copy#      OUT number
  ,status     OUT varchar2
  ,completion OUT date
  ,handle     OUT varchar2)
IS
   bpRec      bpRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupPiece815');
   getBackupPiece(bpRec);
 
   recid        := bpRec.recid;
   stamp        := bpRec.stamp;
   bpkey        := bpRec.key;
   set_stamp    := bpRec.setStamp;
   set_count    := bpRec.setCount;
   piece#       := bpRec.pieceNumber;
   copy#        := bpRec.copyNumber;
   status       := bpRec.status;
   completion   := bpRec.compTime;
   handle       := bpRec.handle;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with no more records');
      bpRec.recid := NULL;              -- indicate end-of-fetch to client
END getBackupPiece;
 
--
--
PROCEDURE getBackupPiece(
   recid     OUT number
  ,stamp     OUT number
  ,set_stamp OUT number
  ,set_count OUT number
  ,piece#    OUT number
  ,handle    OUT varchar2)
IS
   bpRec     bpRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupPiece80');
   getBackupPiece(bpRec);
 
   recid        := bpRec.recid;
   stamp        := bpRec.stamp;
   set_stamp    := bpRec.setStamp;
   set_count    := bpRec.setCount;
   piece#       := bpRec.pieceNumber;
   handle       := bpRec.handle;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      bpRec.recid := NULL;              -- indicate end-of-fetch to client
      deb(DEB_EXIT, 'with no more records');
END getBackupPiece;
 
--
--
--
 
--
PROCEDURE translateBackupSetKey(
   key        IN  number
  ,bsRec      OUT NOCOPY bsRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupSetKey');
   findBackupSet(bsKey => key,
                 bsRec => bsRec);
   deb(DEB_EXIT);
END translateBackupSetKey;
 
--
--
--
 
--
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number)
RETURN number IS
   rcvRec       rcvRec_t;
   rc           number;
BEGIN
   deb(DEB_ENTER, 'findControlFileBackup804');
   rc := getControlfileBackup(rcvRec);
 
   IF (rc = SUCCESS) THEN
      IF (rcvRec.type_con = imageCopy_con_t) THEN
         type := COPY;
      ELSIF (rcvRec.type_con = backupSet_con_t) THEN
         type := BACKUP;
      ELSIF (rcvRec.type_con = proxyCopy_con_t) THEN
         type := PROXY;
      ELSE
--
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN dbms_rcvman.UNAVAILABLE;
      END IF;
 
      IF (type = BACKUP) THEN
         recid := rcvRec.bsRecid_con;
         stamp := rcvRec.bsStamp_con;
      ELSE
         recid := rcvRec.recid_con;
         stamp := rcvRec.stamp_con;
      END IF;
      fname       := rcvRec.fileName_con;
      device_type := rcvRec.deviceType_con;
      ckp_scn     := rcvRec.toSCN_act;
      deb(DEB_EXIT, 'with: SUCCESS');
      RETURN SUCCESS;
   ELSE
      deb(DEB_EXIT, 'with: '||to_char(rc));
      RETURN rc;
   END IF;
   deb(DEB_EXIT);
 
END findControlFileBackup;
 
--
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number
  ,rlg_scn      OUT number
  ,blksize      OUT number)
RETURN number IS
   rcvRec       rcvRec_t;
   rc           number;
BEGIN
   deb(DEB_ENTER, 'findControlFileBackup815');
   rc := getControlfileBackup(rcvRec);
 
   IF (rc = SUCCESS) THEN
      IF (rcvRec.type_con = imageCopy_con_t) THEN
         type := COPY;
      ELSIF (rcvRec.type_con = backupSet_con_t) THEN
         type := BACKUP;
      ELSIF (rcvRec.type_con = proxyCopy_con_t) THEN
         type := PROXY;
         rcvRec_last := rcvRec;         -- save for translateProxyDFRecid
      ELSE
--
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN dbms_rcvman.UNAVAILABLE;
      END IF;
 
      IF (type = BACKUP) THEN
         recid := rcvRec.bsRecid_con;
         stamp := rcvRec.bsStamp_con;
      ELSE
         recid := rcvRec.recid_con;
         stamp := rcvRec.stamp_con;
      END IF;
      fname       := rcvRec.fileName_con;
      device_type := rcvRec.deviceType_con;
      ckp_scn     := rcvRec.toSCN_act;
      rlg_scn     := rcvRec.rlgSCN_act;
      blksize     := rcvRec.blockSize_con;
      deb(DEB_EXIT, 'with: SUCCESS');
      RETURN SUCCESS;
   ELSE
      deb(DEB_EXIT, 'with: '||to_char(rc));
      RETURN rc;
   END IF;
END findControlFileBackup;
 
--
--
--
--
--
FUNCTION findArchivedLogBackup(
   thread#      IN number
  ,sequence#    IN number
  ,low_scn      IN number
  ,type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,device_type  OUT varchar2)
RETURN number IS
   rcvRec       rcvRec_t;
   RC           binary_integer;
BEGIN
   deb(DEB_ENTER, 'findArchivedLogBackup');
--
--
--
 
   findArchivedLogBackup(thread#, sequence#, low_scn);
 
   RC := getArchivedLogbackup(rcvRec);
 
   IF (RC = SUCCESS) THEN
      type        := BACKUP;
      recid       := rcvRec.bsRecid_con;
      stamp       := rcvRec.bsStamp_con;
      device_type := rcvRec.deviceType_con;
   END IF;
 
   deb(DEB_EXIT, 'with: '||to_char(RC));
   RETURN RC;
END findArchivedLogBackup;
 
--
--
--
 
--
PROCEDURE listTranslateControlfileCopy(
   tag             IN varchar2
  ,completedAfter  IN date
  ,completedBefore IN date
  ,statusMask      IN binary_integer DEFAULT
                        BSavailable+BSunavailable+BSexpired
  ,liststby        IN binary_integer DEFAULT NULL -- default for 8.1
  ,file_pattern    IN varchar2       DEFAULT NULL)
IS
  currentIncarnation number;
BEGIN
   deb(DEB_ENTER, 'listTranslateControlfileCopy');
   IF (findControlfileBackup_c%ISOPEN) THEN -- should not be open
      CLOSE findControlfileBackup_c;
   END IF;
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
--
   deb(DEB_OPEN, 'findControlfileBackup_c');
   OPEN findControlfileBackup_c(
                            sourcemask         => imageCopy_con_t,
                            currentIncarnation => currentIncarnation,
                            tag                => tag,
                            completedAfter     => completedAfter,
                            completedBefore    => completedBefore,
                            statusMask         => statusMask,
                            pattern            => file_pattern,
                            needstby           => liststby);
 
   deb(DEB_EXIT);
END listTranslateControlfileCopy;
 
--
PROCEDURE listGetControlfileCopy(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetControlfileCopy');
   FETCH findControlfileBackup_c
    INTO rcvRec;
 
   IF (findControlfileBackup_c%NOTFOUND) THEN
      CLOSE findControlfileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
--
   deb(DEB_EXIT);
END listGetControlfileCopy;
 
--
 
--
FUNCTION listGetControlfileCopy(
   bcfkey     OUT number,
   ckpscn     OUT number,
   ckptime    OUT date,
   status     OUT varchar2,
   completion OUT date,
   fname      OUT varchar2) RETURN number
IS
   rcvRec     rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetControlfileCopy');
   listGetControlfileCopy(rcvRec);
 
   bcfkey     := rcvRec.key_con;
   ckpscn     := rcvRec.toSCN_act;
   ckptime    := rcvRec.toTime_act;
   status     := rcvRec.status_con;
   completion := rcvRec.compTime_con;
   fname      := rcvRec.fileName_con;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetControlfileCopy;
 
--
PROCEDURE listTranslateDataFileCopy(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT BSavailable+BSunavailable
--
  ,pluginSCN         IN number          DEFAULT 0)
IS
   creationSCN        number;
   reset_scn          number := NULL;
   reset_time         date   := NULL;
BEGIN
   deb(DEB_ENTER, 'listTranslateDataFileCopy');
   IF (allIncarnations = TRUE#) THEN
      reset_scn  := NULL;
      reset_time := NULL;
      IF (ignoreCreationSCN = TRUE#) THEN
--
--
--
--
         creationSCN := NULL;
      ELSE
         creationSCN := creation_change#;
      END IF;
   ELSE
      reset_scn   := this_reset_scn;
      reset_time  := this_reset_time;
      creationSCN := creation_change#;
   END IF;
 
--
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(sourcemask         => imageCopy_con_t,
                             fno                => file#,
                             crescn             => creationSCN,
                             reset_scn          => reset_scn,
                             reset_time         => reset_time,
                             tag                => tag,
                             pattern            => file_name_pattern,
                             completedAfter     => completedAfter,
                             completedBefore    => completedBefore,
                             statusMask         => statusMask,
                             pluginSCN          => pluginSCN);
   deb(DEB_EXIT);
END listTranslateDataFileCopy;
 
--
PROCEDURE listGetDataFileCopy(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetDataFileCopy');
   FETCH findDatafileBackup_c
    INTO rcvRec;
 
   IF (findDatafileBackup_c%NOTFOUND) THEN
      CLOSE findDatafileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
--
   deb(DEB_EXIT);
END listGetDatafileCopy;
 
--
 
--
FUNCTION listGetDataFileCopy(
   cdf_key            OUT number
  ,status             OUT varchar2
  ,fname              OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number IS
   rcvRec             rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetDataFileCopy815');
   listGetDatafileCopy(rcvRec);
 
   cdf_key            := rcvRec.key_con;
   status             := rcvRec.status_con;
   fname              := rcvRec.fileName_con;
   completion_time    := rcvRec.compTime_con;
   checkpoint_change# := rcvRec.toSCN_act;
   checkpoint_time    := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetDataFileCopy;
 
--
PROCEDURE listTranslateArchivedLogCopy(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                       BSavailable+BSunavailable+BSexpired  -- 8.0/8.1 defaults
  ,needstby          IN number          DEFAULT NULL)
IS
   currentIncarnation number;
BEGIN
 
   deb(DEB_ENTER, 'listTranslateArchivedLogCopy');
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
   deb(DEB_OPEN, 'findArchivedLogCopy');
   OPEN findArchivedLogCopy(currentIncarnation => currentIncarnation,
                            thread             => thread#,
                            sequence           => sequence#,
                            lowSCN             => first_change#,
                            pattern            => file_name_pattern,
                            completedAfter     => completedAfter,
                            completedBefore    => completedBefore,
                            statusMask         => statusMask,
--
                            needstby           => NULL);
   getrcvRecLast := NULL;
   deb(DEB_EXIT);
END listTranslateArchivedLogCopy;
 
--
PROCEDURE listGetArchivedLogCopy(
   rcvRec OUT NOCOPY rcvRec_t)
IS
duplicate           number;              -- used for filtering duplicate names
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogCopy');
 
--
--
--
   IF (restoreTag is not NULL OR
       not diskDevice)            THEN
      CLOSE findArchivedLogCopy;
      deb(DEB_EXIT, 'tag specified or no diskDevice allocated');
      RAISE no_data_found;
   END IF;
 
--
   IF (guidQualifier IS NOT NULL) THEN
      IF (findArchivedLogCopy%ISOPEN) THEN
         CLOSE findArchivedLogCopy;
      END IF;
      deb(DEB_EXIT, 'guid not valid for archivelog');
      RAISE no_data_found;
   END IF;
 
<<nextRow>>
   FETCH findArchivedLogCopy
    INTO rcvRec;
 
   IF (findArchivedLogCopy%NOTFOUND) THEN
      CLOSE findArchivedLogCopy;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
--
   IF (rcvRec.logThread_obj   = getrcvRecLast.logThread_obj AND
       rcvRec.logSequence_obj = getrcvRecLast.logSequence_obj AND
       rcvRec.loglowSCN_obj   = getrcvRecLast.loglowSCN_obj AND
       rcvRec.logrlgSCN_obj   = getrcvRecLast.logrlgSCN_obj AND
       rcvRec.logrlgTime_obj  = getrcvRecLast.logrlgTime_obj ) THEN
       duplicate := TRUE#;
   ELSE
       duplicate := FALSE#;
   END IF;
 
   IF IsDuplicateAlName(duplicate, rcvRec.filename_con) THEN
     GOTO nextRow;
   END IF;
 
   getrcvRecLast := rcvRec;
--
 
   deb(DEB_EXIT);
END listGetArchivedLogCopy;
 
--
 
--
FUNCTION listGetArchivedLogCopy(
   al_key          OUT number
  ,status          OUT varchar2
  ,fname           OUT varchar2
  ,completion_time OUT date)
RETURN number IS
   rcvRec          rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogCopy');
   listGetArchivedLogCopy(rcvRec);
 
   al_key          := rcvRec.key_con;
   status          := rcvRec.status_con;
   fname           := rcvRec.fileName_con;
   completion_time := rcvRec.compTime_con;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetArchivedLogCopy;
 
--
--
--
 
--
PROCEDURE listTranslateControlfileBackup(
   tag             IN  varchar2
  ,completedAfter  IN  date
  ,completedBefore IN  date
  ,statusMask      IN  binary_integer   DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,autobackup      IN  binary_integer   DEFAULT BScfile_all
  ,liststby        IN  binary_integer   DEFAULT NULL)
IS
   currentIncarnation number;
BEGIN
   deb(DEB_ENTER, 'listTranslateControlfileBackup');
   IF (findControlfileBackup_c%ISOPEN) THEN     -- should not be open
      CLOSE findControlfileBackup_c;
   END IF;
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
--
--
   deb(DEB_OPEN, 'findControlfileBackup_c');
   OPEN findControlfileBackup_c(sourcemask         => backupSet_con_t,
                                currentIncarnation => currentIncarnation,
                                completedAfter     => completedAfter,
                                completedBefore    => completedBefore,
                                typemask           => autobackup,
                                needstby           => liststby);
 
--
--
--
--
--
 
   listGetBackupTag           := tag;
   listGetBackupAvailableMask := statusMask;
   deb(DEB_EXIT);
END listTranslateControlfileBackup;
 
--
PROCEDURE listGetControlfileBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetControlfileBackup');
   FETCH findControlfileBackup_c
    INTO rcvRec;
 
--
--
 
   IF (findControlfileBackup_c%NOTFOUND) THEN
      CLOSE findControlfileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   deb(DEB_EXIT);
END listGetControlfileBackup;
 
--
--
FUNCTION listGetControlfileBackup(
   bskey      OUT number,
   ckpscn     OUT number,
   ckptime    OUT date)
RETURN number IS
   rcvRec               rcvRec_t;
   validationRec        validBackupSetRec_t;
   validationRC         binary_integer;
BEGIN
   deb(DEB_ENTER, 'listGetControlfileBackup815');
   <<nextRow>>
   BEGIN
      listGetControlfileBackup(rcvRec);
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
   END;
 
   validationRC :=
      validateBackupSet(backupSetRec           => rcvRec,
                        tag                    => listGetBackupTag,
                        tagMatchRequired       => TRUE,
                        checkDeviceIsAllocated => TRUE,
                        availableMask          => listGetBackupAvailableMask,
                        validRec               => validationRec);
 
   IF (validationRC <> SUCCESS) THEN
      GOTO nextRow;
   END IF;
 
   bskey      := rcvRec.bsKey_con;
   ckpscn     := rcvRec.toSCN_act;
   ckptime    := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
    WHEN no_data_found THEN
       deb(DEB_EXIT, 'with: FALSE#');
       RETURN FALSE#;
END listGetControlfileBackup;
 
--
PROCEDURE listTranslateSpfileBackup(
   completedAfter  IN  date
  ,completedBefore IN  date)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateSpfileBackup');
   IF (findSpfileBackup_c%ISOPEN) THEN                   -- should not be open
      CLOSE findSpfileBackup_c;
   END IF;
 
   deb(DEB_OPEN, 'findSpfileBackup_c');
   OPEN findSpfileBackup_c(completedAfter     => completedAfter,
                           completedBefore    => completedBefore);
 
   deb(DEB_EXIT);
END listTranslateSpfileBackup;
 
--
PROCEDURE listGetSpfileBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetSpfileBackup');
   FETCH findSpfileBackup_c
    INTO rcvRec;
 
--
--
 
   IF (findSpfileBackup_c%NOTFOUND) THEN
      CLOSE findSpfileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
   deb(DEB_EXIT);
END listGetSpfileBackup;
 
--
PROCEDURE listTranslateDataFileBackup(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,pluginSCN         IN number          DEFAULT 0)
IS
   rlgSCN       number;
   rlgTime      date;
   crescn       number;
BEGIN
   deb(DEB_ENTER, 'listTranslateDataFileBackup');
   IF (findDatafileBackup_c%ISOPEN) THEN
      CLOSE findDatafileBackup_c;
   END IF;
 
   IF (allIncarnations = TRUE#) THEN
      IF (ignoreCreationSCN = TRUE#) THEN
--
--
--
--
--
         crescn := NULL;
      ELSE
         crescn := creation_change#;
      END IF;
   ELSE
--
--
      rlgSCN  := this_reset_scn;
      rlgTime := this_reset_time;
      crescn  := creation_change#;
   END IF;
 
--
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(sourceMask         => backupSet_con_t,
                             fno                => file#,
                             crescn             => crescn,
                             reset_scn          => rlgSCN,
                             reset_time         => rlgTime,
                             completedAfter     => completedAfter,
                             completedBefore    => completedBefore,
                             pluginSCN          => pluginSCN);
 
--
--
--
--
--
 
   listGetBackupTag           := tag;
   listGetBackupAvailableMask := statusMask;
   deb(DEB_EXIT);
END listTranslateDataFileBackup;
 
--
PROCEDURE listGetDataFileBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetDataFileBackup');
   FETCH findDatafileBackup_c
    INTO rcvRec;
 
   IF (findDatafileBackup_c%NOTFOUND) THEN
      CLOSE findDatafileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   deb(DEB_EXIT);
END listGetDataFileBackup;
 
--
 
--
FUNCTION listGetDataFileBackup(
   bs_key             OUT number
  ,backup_type        OUT varchar2
  ,incremental_level  OUT number
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number IS
   rcvRec             rcvRec_t;
   valRC              binary_integer;
   validationRec      validBackupSetRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetDataFileBackup815');
<<nextRow>>
   BEGIN
      listGetDataFileBackup(rcvRec => rcvRec);
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
   END;
 
   valRC :=
      validateBackupSet(backupSetRec           => rcvRec,
                        tag                    => listGetBackupTag,
                        tagMatchRequired       => TRUE,
                        checkDeviceIsAllocated => TRUE,
                        availableMask          => listGetBackupAvailableMask,
                        validRec               => validationRec);
 
   IF (valRC <> SUCCESS) THEN
      GOTO nextRow;
   END IF;
 
   bs_key             := rcvRec.bsKey_con;
   IF (rcvRec.fromSCN_act = 0) THEN
      backup_type := 'Full';
   ELSE
      backup_type := 'Incremental';
   END IF;
   incremental_level  := rcvRec.level_act;
   completion_time    := rcvRec.compTime_con;           -- somewhat bogus
   checkpoint_change# := rcvRec.toSCN_act;
   checkpoint_time    := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
END listGetDataFileBackup;
 
--
 
--
PROCEDURE translateBackupFile(
   bs_recid    IN  number
  ,bs_stamp    IN  number
  ,fno         IN  number
  ,bskey       OUT number
  ,inclevel    OUT number
  ,backup_type OUT varchar2
  ,completed   OUT date)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupFile');
--
--
--
--
--
--
--
   IF (rcvRec_last.type_con <> backupSet_con_t OR
       rcvRec_last.bsRecid_con <> bs_recid OR
       rcvRec_last.bsStamp_con <> bs_stamp) THEN
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   bskey     := rcvRec_last.bsKey_con;
   inclevel  := rcvRec_last.level_act;
   completed := rcvRec_last.compTime_con;
 
   IF (rcvRec_last.logSequence_obj IS NOT NULL) THEN
      backup_type := 'Archived Log';
   ELSE
      IF (rcvRec_last.fromSCN_act = 0) THEN
         backup_type := 'Full';
      ELSE
         backup_type := 'Incremental';
      END IF;
   END IF;
   deb(DEB_EXIT);
END translateBackupFile;
 
--
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#              IN number
  ,sequence#            IN number
  ,first_change#        IN number
  ,completedAfter       IN date           DEFAULT NULL
  ,completedBefore      IN date           DEFAULT NULL
  ,statusMask           IN binary_integer DEFAULT
                      BSavailable+BSunavailable+BSexpired)  -- 8.0/8.1 defaults
IS
   currentInc number;
BEGIN
   deb(DEB_ENTER, 'listTranslateArchivedLogBackup');
 
   IF (allIncarnations = TRUE#) THEN
      currentInc := FALSE#;                      -- don't care about dbinc_key
   ELSE
      currentInc := TRUE#;
   END IF;
 
   deb(DEB_OPEN, 'findArcLogBackup');
   OPEN findArcLogBackup(sourcemask         => backupSet_con_t,
                         currentIncarnation => currentInc,
                         thread             => thread#,
                         sequence           => sequence#,
                         lowSCN             => first_change#,
                         completedAfter     => completedAfter,
                         completedBefore    => completedBefore);
   listGetBackupAvailableMask := statusMask;
   deb(DEB_EXIT);
END listTranslateArchivedLogBackup;
 
--
PROCEDURE listGetArchivedLogBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogBackup');
 
--
   IF (guidQualifier IS NOT NULL) THEN
      IF (findArcLogBackup%ISOPEN) THEN
         CLOSE findArcLogBackup;
      END IF;
      deb(DEB_EXIT, 'guid not valid for archivelog');
      RAISE no_data_found;
   END IF;
 
   FETCH findArcLogBackup
    INTO rcvRec;
 
   IF (findArcLogBackup%NOTFOUND) THEN
      CLOSE findArcLogBackup;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   deb(DEB_EXIT);
END listGetArchivedLogBackup;
 
--
 
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,completion_time OUT date)
RETURN number IS
   rcvRec       rcvRec_t;
   validRec     validBackupSetRec_t;
   valRC        binary_integer;
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogBackup');
<<get_next>>
   listGetArchivedLogBackup(rcvRec);
 
   valRC :=
      validateBackupSet(backupSetRec           => rcvRec,
                        checkDeviceIsAllocated => TRUE,
                        availableMask          => listGetBackupAvailableMask,
                        validRec               => validRec);
   IF (valRC <> SUCCESS) THEN
      GOTO get_next;
   END IF;
 
   bs_key          := rcvRec.bsKey_con;
   completion_time := rcvRec.compTime_con;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetArchivedLogBackup;
 
--
--
--
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#      IN number   DEFAULT NULL
  ,lowseq       IN number   DEFAULT NULL
  ,highseq      IN number   DEFAULT NULL
  ,lowscn       IN number   DEFAULT NULL
  ,highscn      IN number   DEFAULT NULL
  ,from_time    IN date     DEFAULT NULL
  ,until_time   IN date     DEFAULT NULL
  ,pattern      IN varchar2 DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateArchivedLogBackup815');
   if lbal2%isopen then
      close lbal2;
   end if;
   deb(DEB_OPEN, 'lbal2');
   open lbal2(thread#, lowseq, highseq, lowscn, highscn, from_time, until_time);
   deb(DEB_EXIT);
END listTranslateArchivedLogBackup;
 
--
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,thread#         OUT number
  ,sequence#       OUT number
  ,first_change#   OUT number
  ,next_change#    OUT number
  ,first_time      OUT date
  ,next_time       OUT date)
RETURN number IS
   rcvRec          rcvRec_t;
   validRec        validBackupSetRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogBackup815');
<<get_next>>
  fetch lbal2 into rcvRec;
  if lbal2%found then
    IF (debug) THEN
       deb(DEB_PRINT, 'listGetArchivedLogBackup: got a backupset:');
       printRcvRec(rcvRec);
    END IF;
 
    if validateBackupSet(backupSetRec           => rcvRec,
                         checkDeviceIsAllocated => TRUE,
                         availableMask          => dbms_rcvman.BSavailable +
                                                   dbms_rcvman.BSunavailable +
                                                   dbms_rcvman.BSexpired,
                         validRec               => validRec) <> SUCCESS then
       goto get_next;
    end if;
    bs_key          := rcvRec.bsKey_con;
    thread#         := rcvRec.logThread_obj;
    sequence#       := rcvRec.logSequence_obj;
    first_change#   := rcvRec.logLowSCN_obj;
    next_change#    := rcvRec.logNextSCN_obj;
    first_time      := rcvRec.logLowTime_obj;
    next_time       := rcvRec.logNextTime_obj;
    deb(DEB_EXIT, 'with: TRUE#');
    RETURN TRUE#;
  else
    close lbal2;
    deb(DEB_EXIT, 'with: FALSE#');
    RETURN FALSE#;
  end if;
END listGetArchivedLogBackup;
 
--
--
--
 
PROCEDURE listTranslateBackupsetFiles(
   bs_key          IN  number)
IS
BEGIN
   IF findBackupsetFiles%ISOPEN THEN
      CLOSE findBackupsetFiles;
   END IF;
   OPEN findBackupsetFiles(bs_key);
END;
 
PROCEDURE listGetBackupsetFiles(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   FETCH findBackupsetFiles
    INTO rcvRec;
 
   IF (findBackupsetFiles%NOTFOUND) THEN
      CLOSE findBackupsetFiles;
      RAISE no_data_found;
   END IF;
END;
 
--
--
--
 
PROCEDURE translateAllBackupSet(
   backupType            IN  binary_integer
  ,tag                   IN  varchar2
  ,statusMask            IN  binary_integer
  ,completedAfter        IN  date
  ,completedBefore       IN  date
  ,onlyrdf               IN  binary_integer DEFAULT 0)
IS
BEGIN
   IF findAllBackupPiece%ISOPEN THEN
      CLOSE findAllBackupPiece;
   END IF;
   OPEN findAllBackupPiece(backupType       => backupType
                           ,tag              => tag
                           ,statusMask       => statusMask
                           ,completedAfter   => completedAfter
                           ,completedBefore  => completedBefore
                           ,onlyrdf          => onlyrdf);
END;
 
PROCEDURE getAllBackupSet(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   FETCH findAllBackupPiece
    INTO rcvRec;
 
   IF (findAllBackupPiece%NOTFOUND) THEN
      CLOSE findAllBackupPiece;
      RAISE no_data_found;
   END IF;
END;
 
--
--
--
 
--
 
--
PROCEDURE listTranslateProxyDataFile(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer
                           DEFAULT BSavailable+BSunavailable+BSexpired
  ,liststby          IN binary_integer  DEFAULT NULL
  ,pluginSCN         IN number          DEFAULT 0)
IS
   currentInc   number;
   crescn       number;
   reset_scn    number := NULL;
   reset_time   date   := NULL;
BEGIN
   deb(DEB_ENTER, 'listTranslateProxyDataFile');
   validateState(null);
 
   IF (allIncarnations = TRUE#) THEN
      currentInc := FALSE#;                     -- don't care about dbinc_key
      IF (ignoreCreationSCN = TRUE#) THEN
--
--
--
--
         crescn := NULL;
      ELSE
         crescn := creation_change#;
      END IF;
   ELSE
      currentInc := TRUE#;
      crescn     := creation_change#;
   END IF;
 
   IF (currentInc = TRUE#) THEN
      reset_scn  := this_reset_scn;
      reset_time := this_reset_time;
   END IF;
 
   IF (file# = 0) THEN
      IF (findControlfileBackup_c%ISOPEN) THEN
         CLOSE findControlfileBackup_c;
      END IF;
 
--
      deb(DEB_OPEN, 'findControlfileBackup_c');
      OPEN findControlfileBackup_c( sourcemask         => proxyCopy_con_t,
                                    currentIncarnation => currentInc,
                                    tag                => tag,
                                    pattern            => handle_pattern,
                                    completedAfter     => completedAfter,
                                    completedBefore    => completedBefore,
                                    statusMask         => statusMask,
                                    needstby           => liststby);
      listGetProxyDatafileCursor := 'findControlfileBackup_c';
   ELSE
      IF (findDatafileBackup_c%ISOPEN) THEN
         CLOSE findDatafileBackup_c;
      END IF;
 
--
      OPEN findDatafileBackup_c(sourcemask         => proxyCopy_con_t,
                                fno                => file#,
                                crescn             => crescn,
                                reset_scn          => reset_scn,
                                reset_time         => reset_time,
                                tag                => tag,
                                pattern            => handle_pattern,
                                completedAfter     => completedAfter,
                                completedBefore    => completedBefore,
                                statusMask         => statusMask,
                                pluginSCN          => pluginSCN);
      listGetProxyDatafileCursor := 'findDatafileBackup_c';
   END IF;
   deb(DEB_EXIT);
END listTranslateProxyDataFile;
 
--
PROCEDURE listGetProxyDataFile(
   rcvRec OUT NOCOPY rcvRec_t)
IS
   local rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetProxyDataFile');
 
<<nextRow>>
 
   IF (listGetProxyDatafileCursor = 'findControlfileBackup_c') THEN
      FETCH findControlfileBackup_c
       INTO local;
      IF (findControlfileBackup_c%NOTFOUND) THEN
         CLOSE findControlfileBackup_c;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSIF (listGetProxyDatafileCursor = 'findDatafileBackup_c') THEN
      FETCH findDatafileBackup_c
       INTO local;
      IF (findDatafileBackup_c%NOTFOUND) THEN
         CLOSE findDatafileBackup_c;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
--
--
   IF (anyDevice = FALSE# AND
       isDeviceTypeAllocated(local.deviceType_con) = FALSE#) THEN
      GOTO nextRow;
   END IF;
 
   rcvRec := local;                             -- set OUT mode arg
   deb(DEB_EXIT);
END listGetProxyDataFile;
 
--
 
--
FUNCTION listGetProxyDataFile(
   xdf_key            OUT number
  ,recid              OUT number
  ,stamp              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number IS
   rcvRec             rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetProxyDataFile815');
   listGetProxyDataFile(rcvRec);
 
   xdf_key              := rcvRec.key_con;
   recid                := rcvRec.recid_con;
   stamp                := rcvRec.stamp_con;
   status               := rcvRec.status_con;
   handle               := rcvRec.fileName_con;
   completion_time      := rcvRec.compTime_con;
   checkpoint_change#   := rcvRec.toSCN_act;
   checkpoint_time      := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetProxyDataFile;
 
--
PROCEDURE listTranslateProxyArchivedLog(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                                        BSavailable+BSunavailable+BSexpired)
IS
   currentIncarnation number;
BEGIN
   deb(DEB_ENTER, 'listTranslateProxyArchivedLog');
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
   deb(DEB_OPEN, 'findArcLogBackup');
   OPEN findArcLogBackup(sourcemask         => proxyCopy_con_t,
                         currentIncarnation => currentIncarnation,
                         thread             => thread#,
                         sequence           => sequence#,
                         lowSCN             => first_change#,
                         tag                => tag,
                         pattern            => handle_pattern,
                         completedAfter     => completedAfter,
                         completedBefore    => completedBefore,
                         statusMask         => statusMask);
   deb(DEB_EXIT);
END listTranslateProxyArchivedLog;
 
--
PROCEDURE listGetProxyArchivedLog(
   rcvRec OUT NOCOPY rcvRec_t)
IS
   local rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetProxyArchivedLog');
 
--
   IF (guidQualifier IS NOT NULL) THEN
      IF (findArcLogBackup%ISOPEN) THEN
         CLOSE findArcLogBackup;
      END IF;
      deb(DEB_EXIT, 'guid not valid for archivelog');
      RAISE no_data_found;
   END IF;
 
<<nextRow>>
 
   FETCH findArcLogBackup
   INTO local;
   IF (findArcLogBackup%NOTFOUND) THEN
      CLOSE findArcLogBackup;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
   IF (anyDevice = FALSE# AND
       isDeviceTypeAllocated(local.deviceType_con) = FALSE#) THEN
      GOTO nextRow;
   END IF;
 
   rcvRec := local;                             -- set OUT mode arg
   deb(DEB_EXIT);
END listGetProxyArchivedLog;
 
--
--
--
 
--
PROCEDURE listTranslateDBIncarnation(
   db_name       IN varchar2 DEFAULT NULL,
   all_databases IN number DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateDBIncarnation');
   IF (ldbi%isopen) THEN
      CLOSE ldbi;
   END IF;
   deb(DEB_OPEN, 'ldbi');
   OPEN ldbi(upper(db_name), all_databases);
   deb(DEB_EXIT);
END listTranslateDBIncarnation;
 
--
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date
  ,dbinc_status      OUT varchar2)
RETURN number
IS
BEGIN
   deb(DEB_ENTER, 'listGetDBIncarnation');
   FETCH ldbi
    INTO db_key, dbinc_key, db_name, db_id, current_inc,
         resetlogs_change#, resetlogs_time, dbinc_status;
   IF (ldbi%found) THEN
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      CLOSE ldbi;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
   END IF;
   deb(DEB_EXIT);
END listGetDBIncarnation;
 
--
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date)
RETURN number
IS
  dbinc_status varchar2(9);
BEGIN
  RETURN listGetDBIncarnation(db_key, dbinc_key, db_name, db_id, current_inc,
                              resetlogs_change#, resetlogs_time, dbinc_status);
END listGetDBIncarnation;
 
 
--
--
--
 
--
PROCEDURE listTranslateDBSite(
   db_name      IN varchar2 DEFAULT NULL,
   alldbs       IN binary_integer DEFAULT 1)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateDBSite');
   IF (lnni%isopen) THEN
      CLOSE lnni;
   END IF;
   deb(DEB_OPEN, 'lnni');
   OPEN lnni(db_name, alldbs);
   deb(DEB_EXIT);
END listTranslateDBSite;
 
--
FUNCTION listGetDBSite(
   db_key            OUT number
  ,db_id             OUT number
  ,db_name           OUT varchar2
  ,db_role           OUT varchar2
  ,db_unique_name    OUT varchar2)
RETURN number
IS
BEGIN
   deb(DEB_ENTER, 'listGetDBSite');
   FETCH lnni
    INTO db_key, db_id, db_name, db_role, db_unique_name;
 
   deb(DEB_PRINT, 'site name =['||db_unique_name||']');
   IF (lnni%found) THEN
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      CLOSE lnni;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
   END IF;
   deb(DEB_EXIT);
END listGetDBSite;
 
--
--
--
 
--
PROCEDURE listRollbackSegTableSpace
IS
BEGIN
   deb(DEB_ENTER, 'listRollbackSegTableSpace');
--
   IF (lrtbs%ISOPEN) THEN
      CLOSE lrtbs;
   END IF;
 
   deb(DEB_OPEN, 'lrtbs');
   OPEN lrtbs;
--
--
   deb(DEB_EXIT);
END listRollbackSegTableSpace;
 
--
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2)
RETURN number IS
  pdbname  varchar2(128);
BEGIN
  RETURN listGetTableSpace(ts#, ts_name, pdbname);
END listGetTableSpace;
 
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2
  ,pdbname          OUT varchar2)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'listGetTableSpace');
--
   FETCH lrtbs
    INTO ts#, ts_name, pdbname;
 
   IF (lrtbs%FOUND) THEN
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      CLOSE lrtbs;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
   END IF;
--
--
   deb(DEB_EXIT);
END listGetTableSpace;
 
--
--
--
 
--
PROCEDURE getIncrementalScn(
   first        IN  boolean                  -- open the cursor if this is TRUE
  ,file#        IN  number
  ,create_scn   IN  number
  ,reset_scn    IN  number
  ,reset_time   IN  date
  ,incr_level   IN  number
  ,cumulative   IN  number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,sourcemask   IN  number    DEFAULT NULL
  ,tag          IN  varchar2  DEFAULT NULL
  ,pluginSCN    IN  number    DEFAULT 0
  ,keep         IN  boolean   DEFAULT NULL)
IS
   ilevel                number;
   local                 rcvRec_t;
   validRec              validBackupSetRec_t;
   usable_incr           rcvRec_t;
   available_fromSCN_act number;
   pdbId                 number;
   cleanSCN              number;
BEGIN
   deb(DEB_ENTER, 'getIncrementalScn');
 
   IF (incr_level not in (1,2,3,4) OR incr_level is NULL) THEN
      raise_application_error(-20270, 'invalid incremental level');
   END IF;
   IF (cumulative not in (0,1) OR cumulative is NULL) THEN
      raise_application_error(-20271, 'invalid cumulative option');
   END IF;
 
--
 
--
--
--
--
--
 
--
--
--
 
   IF (cumulative = TRUE#) THEN
      ilevel := incr_level - 1;         -- Consider only higher level backups
   ELSE
      ilevel := incr_level;
   END IF;
 
--
   IF (file# IS NOT NULL) THEN
      setDfTransClause(fno => file#);
   END IF;
 
   IF first THEN
      IF (findDatafileBackup_c%ISOPEN) THEN
         CLOSE findDatafileBackup_c;
      END IF;
 
      getDatafileBackupLast.type_con := NULL; -- clear the last backup record
 
--
      cacheBsRecTable.hint := redundantHint;
 
--
      OPEN findDatafileBackup_c(
        sourcemask      => sourcemask,
        fno             => file#,
        crescn          => create_scn,
        reset_scn       => nvl(reset_scn, this_reset_scn),
        reset_time      => nvl(reset_time, this_reset_time),
        level           => ilevel,
        statusMask      => BSavailable,
        tag             => tag,
        onlytc          => TRUE#,
        pluginSCN       => pluginSCN,
        allowCumuLevelN => TRUE#);
   END IF;
 
   IF (NOT findDatafileBackup_c%ISOPEN) THEN
      raise_application_error(-20272, 'cannot take incremental backup');
   END IF;
 
   LOOP
   <<nextRow>>
      FETCH findDatafileBackup_c
       INTO local;
 
      IF (findDatafileBackup_c%NOTFOUND) THEN
         deb(DEB_PRINT, 'closing cursor');
         CLOSE findDatafileBackup_c;
         cacheBsRecTable.hint := noHint;
         IF (file# is NOT NULL) THEN
--
            deb(DEB_EXIT, 'with: cannot take incr backup');
            raise_application_error(-20272, 'cannot take incremental backup');
         ELSE
            deb(DEB_EXIT, 'with: no data found');
            raise no_data_found;        -- no more datafile backups
         END IF;
      END IF;
 
--
--
--
--
--
      IF (keep IS NOT NULL AND                       -- NULL means 10g client
          ((local.keep_options != 0 AND NOT keep) OR -- local_keep and not keep
           (local.keep_options = 0 AND keep))) THEN  -- not local_keep and keep
         deb(DEB_PRINT, 'Keep does not match for ' || local.key_con ||
                        ' completed at ' ||
                        to_char(local.compTime_con, 'DD-MON-YY HH24:MI:SS'));
         GOTO nextRow;                          -- keep attributes do not match
      END IF;
 
      IF (available_fromSCN_act IS NULL AND
          getDatafileBackupLast.type_con IS NOT NULL AND
          getDatafileBackupLast.dfNumber_obj = local.dfNumber_obj) THEN
        deb(DEB_PRINT, 'already returned incremental scn for file# ' ||
                        local.dfNumber_obj);
        GOTO nextRow;    -- this is a duplicate of what we returned earlier
      END IF;
 
--
--
--
      IF (available_fromSCN_act IS NOT NULL AND
          (usable_incr.dfNumber_obj <> local.dfNumber_obj OR
           (usable_incr.dfNumber_obj = local.dfNumber_obj AND
            usable_incr.dfCreationSCN_obj <> local.dfCreationSCN_obj))) THEN
          deb(DEB_PRINT, 'no level 0 found for this file# ' ||
                         usable_incr.dfNumber_obj || ', creation_scn '||
                         usable_incr.dfCreationSCN_obj);
          usable_incr := NULL;
          available_fromSCN_act := NULL;
      END IF;
 
      pdbId := translatePdbFile(local.dfNumber_obj, cleanSCN);
      IF (CheckRecAction(local, pdbId, cleanSCN) = action_SKIP) THEN
        deb(DEB_PRINT, 'on orphan branch');
        GOTO nextRow;    -- this action belongs to orphan branch
      END IF;
 
      IF (usable_incr.dfNumber_obj = local.dfNumber_obj AND
          usable_incr.dfCreationSCN_obj = local.dfCreationSCN_obj AND
          local.fromSCN_act > 0 AND
          available_fromSCN_act < local.fromSCN_act) THEN
          deb(DEB_PRINT, 'overlapping incremental found for file# ' ||
                         usable_incr.dfNumber_obj || ', creation_scn '||
                         usable_incr.dfCreationSCN_obj);
          GOTO nextRow;                            -- overlapping incremental
      END IF;
 
      IF (local.type_con = backupSet_con_t) THEN
--
--
         IF (validateBackupSet(backupSetRec           => local,
                               tag                    => tag,
                               tagMatchRequired       => TRUE,
                               checkDeviceIsAllocated => FALSE,
                               availableMask          => BSavailable,
                               validRec               => validRec)
                = dbms_rcvman.UNAVAILABLE) THEN
            deb(DEB_PRINT, 'incremental is unavailable');
            GOTO nextRow; -- can't create an incr based on unavail backup
         END IF;
 
--
--
--
--
--
--
--
         IF (available_fromSCN_act IS NULL OR
             (usable_incr.dfNumber_obj = local.dfNumber_obj AND
              usable_incr.dfCreationSCN_obj = local.dfCreationSCN_obj AND
              local.toSCN_act < available_fromSCN_act)) THEN
            IF (available_fromSCN_act IS NULL) THEN
               deb(DEB_PRINT, 'available_fromSCN_act set to ' ||
                              available_fromSCN_act || ' for file# ' ||
                              local.dfNumber_obj || ', creation_scn '||
                              local.dfCreationSCN_obj);
            ELSE
               deb(DEB_PRINT, 'broken chain, available_fromSCN_act set to ' ||
                              available_fromSCN_act || ' for file ' ||
                              local.dfNumber_obj || ', creation_scn '||
                              local.dfCreationSCN_obj);
            END IF;
            usable_incr := local;
            available_fromSCN_act := local.fromSCN_act;
         END IF;
      END IF;
 
--
--
--
      IF (usable_incr.dfNumber_obj = local.dfNumber_obj AND
          usable_incr.dfCreationSCN_obj = local.dfCreationSCN_obj AND
          local.toSCN_act >= available_fromSCN_act AND
          local.fromSCN_act < available_fromSCN_act) THEN
         available_fromSCN_act := local.fromSCN_act;
         deb(DEB_PRINT, 'available_fromSCN_act moved to ' ||
                        available_fromSCN_act || ' for file# ' ||
                        local.dfNumber_obj || ', creation_scn '||
                        local.dfCreationSCN_obj);
      END IF;
 
--
--
      IF (available_fromSCN_act != usable_incr.dfCreationSCN_obj AND
          available_fromSCN_act > 0) THEN
         deb(DEB_PRINT, 'need more incrementals to validate chain');
         GOTO nextRow;
      END IF;
 
 
      If (available_fromSCN_act = usable_incr.dfCreationSCN_obj OR
          available_fromSCN_act = 0) THEN
         deb(DEB_PRINT, 'validated incremental to level 0, incremental scn=' ||
                        usable_incr.toSCN_act || 'for file ' ||
                        usable_incr.dfNumber_obj);
         rcvRec := usable_incr;
      ELSE
         rcvRec := local;
         deb(DEB_PRINT, 'using level0 proxy/copy, incremental scn=' ||
                        local.toSCN_act || ' for file ' ||
                        local.dfNumber_obj);
      END IF;
 
      getDatafileBackupLast := rcvRec;   -- remember the last record returned
 
      deb(DEB_EXIT, 'with: valid record ');
      EXIT;   -- valid record. Create Incremental based on this SCN
   END LOOP;
EXCEPTION
   WHEN others THEN
      cacheBsRecTable.hint := noHint;
      deb(DEB_PRINT, 'caught an exception during getIncrementalScn');
      deb(DEB_EXIT, substr(sqlerrm, 1, 512));
      raise;
END getIncrementalScn;
 
--
FUNCTION getIncrementalScn(
   file#        IN number
  ,create_scn   IN number
  ,reset_scn    IN number
  ,reset_time   IN date
  ,incr_level   IN number
  ,cumulative   IN number
  ,sourcemask   IN number    DEFAULT NULL
  ,tag          IN varchar2  DEFAULT NULL
  ,pluginSCN    IN number    DEFAULT 0)
RETURN number IS
  rcvRec    rcvRec_t;
BEGIN
   getIncrementalScn(
      first        => TRUE
     ,file#        => file#
     ,create_scn   => create_scn
     ,reset_scn    => reset_scn
     ,reset_time   => reset_time
     ,incr_level   => incr_level
     ,cumulative   => cumulative
     ,rcvRec       => rcvRec
     ,sourcemask   => sourcemask
     ,tag          => tag
     ,pluginSCN    => pluginSCN);
 
   IF (findDatafileBackup_c%ISOPEN) THEN
      CLOSE findDatafileBackup_c; -- close the one opened in getIncrementalScn
   END IF;
 
   RETURN rcvRec.toSCN_act;
END getIncrementalScn;
 
--
--
--
 
--
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number
  ,availableMask        IN binary_integer
  ,fullBackups          IN number DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'setComputeRecoveryActionMasks');
   IF (allRecords = FALSE# AND fullBackups IS NULL) THEN
      computeRA_fullBackups := 1;
   ELSE
      computeRA_fullBackups := fullBackups;
   END IF;
   getRA_containerMask      := containerMask;
   getRA_actionMask         := actionMask;
   computeRA_allRecords     := allRecords;
   computeRA_availableMask  := availableMask;
 
--
--
--
--
   IF (restoreSource IS NULL) THEN
      restoreSource := proxyCopy_con_t + imageCopy_con_t + backupSet_con_t;
 
      IF (bitand(getRA_containerMask, proxyCopy_con_t) = 0) THEN
         restoreSource := restoreSource - proxyCopy_con_t;
      END IF;
      IF (bitand(getRA_containerMask, imageCopy_con_t) = 0) THEN
         restoreSource := restoreSource - imageCopy_con_t;
      END IF;
      IF (bitand(getRA_containerMask, backupSet_con_t) = 0) THEn
         restoreSource := restoreSource - backupSet_con_t;
      END IF;
 
      IF (restoreSource = 0) THEN
         restoreSource := NULL;
      END IF;
   END IF;
 
   deb(DEB_EXIT);
END setComputeRecoveryActionMasks;
 
--
--
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number)
IS
BEGIN
   deb(DEB_ENTER, 'setComputeRecoveryActionMasks816');
   setComputeRecoveryActionMasks(
      containerMask  => containerMask,
      actionMask     => actionMask,
      allRecords     => allRecords,
      availableMask  => dbms_rcvman.BSavailable,
      fullBackups    => to_number(null));
   deb(DEB_EXIT);
END setComputeRecoveryActionMasks;
 
--
--
PROCEDURE setRAflags(
   kindMask    IN number
  ,allRecords  IN boolean)
IS
   containerMask        number;
   actionMask           number;
   allRecs              number;
BEGIN
   deb(DEB_ENTER, 'setRAflags');
 
--
 
   containerMask := 0;
 
   IF (bitand(kindMask, implicitOfflRange + cleanRange + applyOfflRange) > 0)
   THEN
      containerMask := containerMask + offlineRangeRec_con_t;
   END IF;
 
   IF (bitand(kindMask, dfCopy) > 0) THEN
      containerMask := containerMask + imageCopy_con_t;
   END IF;
 
   IF (bitand(kindMask, buSet + applyIncremental) > 0) THEN
      containerMask := containerMask + backupSet_con_t;
   END IF;
 
   IF (bitand(kindMask, proxyFull) > 0) THEN
      containerMask := containerMask + proxyCopy_con_t;
   END IF;
 
--
 
   actionMask := 0;
 
   IF (bitand(kindMask, dfCopy + ProxyFull + buSet) > 0) THEN
      actionMask := actionMask + full_act_t;
   END IF;
 
   IF (bitand(kindMask, applyIncremental) > 0) THEN
      actionMask := actionMask + incremental_act_t;
   END IF;
 
   IF (bitand(kindMask, redo) > 0) THEN
      actionMask := actionMask + redo_act_t;
   END IF;
 
   IF (bitand(kindMask, implicitOfflRange) > 0) THEN
      actionMask := actionMask + implicitRange_act_t;
   END IF;
 
   IF (bitand(kindMask, cleanRange) > 0) THEN
      actionMask := actionMask + cleanRange_act_t;
   END IF;
 
   IF (bitand(kindMask, applyOfflRange) > 0) THEN
      actionMask := actionMask + offlineRange_act_t;
   END IF;
 
   IF (allRecords) THEN
      allRecs := TRUE#;
   ELSE
      allRecs := FALSE#;
   END IF;
 
   deb(DEB_PRINT, 'setRAflags kindMask=' || to_char(kindMask) ||
       ' containerMask=' || to_char(containerMask) ||
       ' actionMask=' || to_char(actionMask));
 
   setComputeRecoveryActionMasks(containerMask, actionMask, allRecs);
   deb(DEB_EXIT);
END setRAflags;
 
--
FUNCTION getRecoveryAction(
   action OUT NOCOPY rcvRec_t)
RETURN binary_integer IS
   redoAction rcvRec_t;
   local      rcvRec_t;
   top        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getRecoveryAction');
<<getNext>>
   IF (rcvRecStack.count = 0) THEN
--
--
--
--
--
--
--
--
--
--
--
      deb(DEB_EXIT, 'with no more records');
      raise no_data_found;
   END IF;
 
   rcvRecPop(local);
 
--
   IF (not isValidAction(local)) THEN
     IF (debug) THEN
       printRcvRec(local);
     END IF;
     goto getNext;
   END IF;
 
<<merge_actions>>
   IF (rcvRecStack.count > 0) THEN
--
--
--
      rcvRecTop(top);
      IF (local.type_act = redo_act_t AND
          top.type_act = redo_act_t) THEN
--
--
--
         redoAction := local;
         rcvRecPop(local);
         local.fromSCN_act := redoAction.fromSCN_act;
         GOTO merge_actions;
      END IF;
      action := local;
      rcvRec_last := local;
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;                     -- more actions to return yet
   ELSE
      action := local;
      rcvRec_last := local;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;                    -- this is the last action
   END IF;
 
END getRecoveryAction;
 
--
 
--
FUNCTION getRecoveryAction(
   kind       OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,recid      OUT number
  ,stamp      OUT number
  ,fname      OUT varchar2
  ,blocksize  OUT number
  ,blocks     OUT number
  ,devtype    OUT varchar2
  ,from_scn   OUT number
  ,to_scn     OUT number
  ,to_time    OUT date
  ,rlgscn     OUT number
  ,rlgtime    OUT date
  ,cfcretime  OUT date
  ,dbinc_key  OUT number)
RETURN binary_integer IS
   rcvRec     rcvRec_t;
   rc         binary_integer;
BEGIN
   deb(DEB_ENTER, 'getRecoveryAction815');
   rc := getRecoveryAction(rcvRec);
 
   IF (rcvRec.type_con = offlineRangeRec_con_t) THEN
      IF (rcvRec.type_act = offlineRange_act_t) THEN
         kind := applyOfflRange;
      ELSIF (rcvRec.type_act = cleanRange_act_t) THEN
         kind := cleanRange;
      ELSIF (rcvRec.type_act = implicitRange_act_t) THEN
         kind := implicitOfflRange;
      ELSE
         deb(DEB_PRINT, 'cannot convert type_con=' || to_char(rcvRec.type_con) ||
             ' type_act=' || to_char(rcvRec.type_act) ||
             ' to recovery action kind');
         deb(DEB_EXIT, 'with error 20999');
         raise_application_error(-20999, 'internal error: getRecoveryAction');
      END IF;
   ELSIF (rcvRec.type_con = backupSet_con_t) THEN
      IF (rcvRec.type_act = full_act_t) THEN
         kind := buSet;
      ELSE
         kind := applyIncremental;
      END IF;
   ELSIF (rcvRec.type_con = proxyCopy_con_t) THEN
      kind := proxyFull;
   ELSIF (rcvRec.type_con = imageCopy_con_t) THEN
      kind := dfCopy;
   ELSIF (rcvRec.type_con IS NULL) THEN
      IF (rcvRec.type_act = redo_act_t) THEN
         kind := redo;
      END IF;
   END IF;
 
   deb(DEB_PRINT, 'getRecoveryAction: kind=' || nvl(to_char(kind), 'null'));
   rcvRecConvert(rcvRec);                       -- get rid of nulls
   IF (debug) THEN
      printRcvRec(rcvRec);
   END IF;
 
   set_stamp := rcvRec.setStamp_con;
   set_count := rcvRec.setCount_con;
   IF (rcvRec.type_con = backupSet_con_t) THEN
      recid     := rcvRec.bsRecid_con;
      stamp     := rcvRec.bsStamp_con;
   ELSE
      recid     := rcvRec.recid_con;
      stamp     := rcvRec.stamp_con;
   END IF;
   fname     := rcvRec.fileName_con;
   blocksize := rcvRec.blockSize_con;
   blocks    := rcvRec.blocks_con;
   devtype   := rcvRec.deviceType_con;
   from_scn  := rcvRec.fromSCN_act;
   to_scn    := rcvRec.toSCN_act;
   to_time   := rcvRec.toTime_act;              -- null OK
   rlgscn    := rcvRec.rlgSCN_act;
   rlgtime   := rcvRec.rlgTime_act;
   cfcretime := rcvRec.cfCreationTime_con;      -- null OK
   dbinc_key := rcvRec.dbincKey_act;            -- null OK
 
   deb(DEB_EXIT, 'with: '||to_char(rc));
   RETURN rc;
END;
 
--
PROCEDURE printRecoveryActions
IS
   action rcvRec_t;
   rc     number;
BEGIN
   IF (not debug) THEN
      return;
   END IF;
 
   deb(DEB_PRINT, '===== ' || to_char(rcvRecStack.count) ||
       ' actions stacked =====');
 
   IF (rcvRecStack.count = 0) THEN
      return;
   END IF;
 
   LOOP
      rc := getRecoveryAction(action);
      printRcvRec(action);
      EXIT WHEN rc = FALSE#;
   END LOOP;
END printRecoveryActions;
 
--
PROCEDURE trimRecoveryActions(
   maxActions           IN number
  ,containerMask        IN number
  ,actionMask           IN number)
IS
   n                    number;
BEGIN
   deb(DEB_ENTER, 'trimRecoveryActions[procedure]');
   n := trimRecoveryActions(maxActions, containerMask, actionMask);
   deb(DEB_PRINT, 'trimRecoveryActions[procedure] returned '||n);
   deb(DEB_EXIT);
END trimRecoveryActions;
 
--
--
--
 
--
PROCEDURE reportTranslateDFDel
IS
BEGIN
   deb(DEB_ENTER, 'reportTranslateDFDel');
   IF (rddf%isopen) THEN
      CLOSE rddf;
   END IF;
   deb(DEB_OPEN, 'rddf');
   OPEN rddf;
   deb(DEB_EXIT);
END reportTranslateDFDel;
 
--
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number)
RETURN number IS
   rc              number;
   mytype          number;
   key             number;
   completion_time date;
BEGIN
   deb(DEB_ENTER, 'reportGetDFDel80');
   <<get_next>>
   rc := reportGetDFDel( file#
                        ,mytype
                        ,checkpoint_change#
                        ,checkpoint_time
                        ,resetlogs_change#
                        ,resetlogs_time
                        ,incremental_change#
                        ,fuzzy_change#
                        ,recid
                        ,stamp
                        ,fname
                        ,restorable
                        ,key
                        ,completion_time);
   IF (rc = TRUE#) THEN
      IF (mytype = PROXY) THEN
         GOTO get_next;
      END IF;
      filetype := mytype;
   END IF;
   deb(DEB_EXIT, 'with: '||to_char(rc));
   RETURN rc;
END reportGetDFDel;
 
--
--
--
--
PROCEDURE getConfig(
   conf#          OUT    number
  ,name           IN OUT varchar2
  ,value          IN OUT varchar2
  ,first          IN     boolean)
IS
   eof          boolean := FALSE;
   conf_exist   number  := 0;
   primary_db_unique_name varchar2(512); /* node.db_unique_name%TYPE */
BEGIN
 
   IF (first) THEN
      IF (findConfig_c%ISOPEN) THEN
         CLOSE findConfig_c;
      END IF;
 
      OPEN cntConfig_c;
      FETCH cntConfig_c INTO conf_exist;
      CLOSE cntConfig_c;
      IF conf_exist > 0 THEN
         IF user_db_unique_name is not null THEN
            deb(DEB_PRINT, 'getConfig: configurations exists for user site');
            OPEN findConfig_c(name, value, user_db_unique_name);
         ELSE
            deb(DEB_PRINT, 'getConfig: configurations exists for this site');
            OPEN findConfig_c(name, value, this_db_unique_name);
         END IF;
      ELSE
         OPEN getPrimarySite_c;
         FETCH getPrimarySite_c INTO primary_db_unique_name;
         IF getPrimarySite_c%NOTFOUND THEN
            deb(DEB_PRINT, 'getConfig: no/multiple primary/site conf');
            OPEN findConfig_c(name, value, NULL);
         ELSE
            deb(DEB_PRINT, 'getConfig: using primary configurations');
            OPEN findConfig_c(name, value, primary_db_unique_name);
         END IF;
         CLOSE getPrimarySite_c;
      END IF;
   END IF;
 
   FETCH findConfig_c INTO conf#, name, value;
 
   IF (findConfig_c%NOTFOUND) THEN
      eof := TRUE;
      CLOSE findConfig_c;
   END IF;
 
   IF (eof) THEN                                --- if end of fetch
     RAISE no_data_found;
   END IF;
 
END getConfig;
 
--
--
--
--
 
PROCEDURE bmrAddCorruptTable(
   dfnumber    OUT number
  ,blknumber   OUT number
  ,range       OUT number
  ,first       IN  boolean)
IS
   eof    boolean := FALSE;
BEGIN
 
   IF (first) THEN
      IF (translateDatabaseCorruption_c%ISOPEN) THEN
         CLOSE translateDatabaseCorruption_c;
      END IF;
      OPEN translateDatabaseCorruption_c(dfnumber => NULL);
   END IF;
 
   FETCH translateDatabaseCorruption_c INTO dfnumber, blknumber, range;
 
   IF (translateDatabaseCorruption_c%NOTFOUND) THEN
      eof := TRUE;
      CLOSE translateDatabaseCorruption_c;
   END IF;
 
   IF (eof) THEN                                --- if end of fetch
     RAISE no_data_found;
   END IF;
 
END bmrAddCorruptTable;
 
--
 
--
--
--
 
--
--
 
--
FUNCTION getPackageVersion
RETURN varchar2 IS
BEGIN
   deb(DEB_ENTER, 'getPackageVersion');
   IF (versionCounter > versionMaxIndex) THEN
      versionCounter := 1;
      deb(DEB_EXIT, 'with: NULL');
      RETURN NULL;
   END IF;
   versionCounter := versionCounter + 1;
   deb(DEB_EXIT, 'with: '||versionList(versionCounter - 1));
   RETURN versionList(versionCounter - 1);
END getPackageVersion;
 
FUNCTION isStatusMatch(status      IN VARCHAR2,
                       mask        IN NUMBER) RETURN NUMBER IS
BEGIN
--
--
--
--
   IF (bitand(mask, BSavailable)     != 0 AND status = 'A') OR
      (bitand(mask, BSunavailable)   != 0 AND status = 'U') OR
      (bitand(mask, BSdeleted)       != 0 AND status = 'D') OR
      (bitand(mask, BSexpired)       != 0 AND status = 'X') THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isStatusMatch;
 
--
FUNCTION isBackupTypeMatch(btype       IN VARCHAR2,
                           mask        IN binary_integer) RETURN NUMBER IS
BEGIN
   IF (bitand(mask, BSdatafile_full) !=0  AND  btype = 'D') OR
      (bitand(mask, BSdatafile_incr) !=0  AND  btype = 'I') OR
      (bitand(mask, BSarchivelog)    !=0  AND  btype = 'L') THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isBackupTypeMatch;
 
--
PROCEDURE setRcvRecBackupAge(age IN number)
IS
BEGIN
   rcvRecBackupAge := age;
   deb(DEB_PRINT, 'rcvRecBackupAge= '  || rcvRecBackupAge);
   resetthisBackupAge;
END setRcvRecBackupAge;
 
--
PROCEDURE resetthisBackupAge
IS
BEGIN
   thisBackupAge := 0;
   deb(DEB_PRINT, 'thisBackupAge= '  || thisBackupAge);
END resetthisBackupAge;
 
--
PROCEDURE printLbRec(
   lbRec IN lbRec_t)
IS
BEGIN
 
  deb(DEB_ENTER, 'printLbRec');
  deb(DEB_IN, 'fetch backup_type:  '||lbRec.backup_type);
  deb(DEB_IN, '      file_type:    '||lbRec.file_type);
  deb(DEB_IN, '      pkey:         '||lbRec.pkey);
  deb(DEB_IN, '      recid:        '||lbRec.recid);
  deb(DEB_IN, '      stamp:        '||lbRec.stamp);
  deb(DEB_IN, '      is_rdf:       '||lbRec.is_rdf);
  IF (lbRec.file_type = datafile_txt)
  THEN
    deb(DEB_IN, '      df_file#:     '||lbRec.df_file#);
    deb(DEB_IN, '      df_ts#:       '||lbRec.df_ts#);
    deb(DEB_IN, '      df_plugin_change#: '||lbRec.df_plugin_change#);
    deb(DEB_IN, '      df_foreidn_dbid:   '||lbRec.df_foreign_dbid);
    deb(DEB_IN, '      df_creation_change#:'||lbRec.df_creation_change#);
    deb(DEB_IN, '      df_checkpoint_change#:'||lbRec.df_checkpoint_change#);
    deb(DEB_IN, '      df_incremental_change#:'||
                       nvl(to_char(lbRec.df_incremental_change#), 'NULL'));
  END IF;
  IF (lbRec.file_type = archivedlog_txt)
  THEN
    deb(DEB_IN, '      rl_thread#:   '||lbRec.rl_thread#);
    deb(DEB_IN, '      rl_sequence#: '||lbRec.rl_sequence#);
    deb(DEB_IN, '      rl_next_change#:'||lbRec.rl_next_change#);
  END IF;
  IF (lbRec.backup_type = backupset_txt)
  THEN
    deb(DEB_IN, '      bs_key:       '||lbRec.bs_key);
    deb(DEB_IN, '      bs_stamp:     '||lbRec.bs_stamp);
    deb(DEB_IN, '      bs_count:     '||lbRec.bs_count);
    deb(DEB_IN, '      bs_incr_type: '||lbRec.bs_incr_type);
  END IF;
  IF (lbRec.file_type = piece_txt)
  THEN
    deb(DEB_IN, '      bp_piece#:    '||lbRec.bp_piece#);
    deb(DEB_IN, '      bp_copy#:     '||lbRec.bp_copy#);
    deb(DEB_IN, '      status:       '||lbRec.status);
    deb(DEB_IN, '      device_type:  '||lbRec.device_type);
    deb(DEB_IN, '      tag:          '||lbRec.tag);
  END IF;
  deb(DEB_EXIT, 'ok');
 
EXCEPTION
  WHEN OTHERS THEN
    deb(DEB_EXIT, 'with exception: '||substr(sqlerrm, 1, 512));
    RETURN;
END printLbRec;
 
--
--
FUNCTION listBackupInMKS(lbDfRecTabUs      IN lbDfRecTab_t
                        ,lbRec             IN lbRec_t
                        ,maxDfNumber       IN number
                        ,forIncr           IN boolean)
RETURN BOOLEAN IS
   i          number;
   min_scn    number;
   min_rlgscn number;
BEGIN
--
--
--
   i := lbRec.df_file#;
   <<loop_dfRecTab>>
   LOOP
      IF (NOT lbDfRecTabUs.exists(i)) THEN
         deb(DEB_PRINT,'Dropped datafile: df_file#=' || lbRec.df_file#);
         IF (lbRec.df_ckp_mod_time < untilTime OR
             (untilTime IS NULL AND
              lbRec.df_checkpoint_change# <= untilSCN)) THEN
            deb(DEB_PRINT,'Outside untilTime/untilSCN');
            RETURN FALSE;
         ELSE
            deb(DEB_PRINT,'Inside untilTime/untilSCN');
            RETURN TRUE;
         END IF;
      END IF;
      IF (lbDfRecTabUs(i).dfRec.dfNumber = lbRec.df_file# AND
          (lbRec.df_file# = 0 OR
           lbDfRecTabUs(i).dfRec.dfCreationSCN =
              lbRec.df_creation_change#)) THEN
         IF (forIncr) THEN
            min_scn    := lbDfRecTabUs(i).incrmin_scn;
            min_rlgscn := lbDfRecTabUs(i).incrmin_rlgscn;
         ELSE
            min_scn    := lbDfRecTabUs(i).fullmin_scn;
            min_rlgscn := lbDfRecTabUs(i).fullmin_rlgscn;
         END IF;
 
         IF (min_scn < lbRec.df_checkpoint_change# AND
             (min_rlgscn IS NULL                      OR
              min_rlgscn = lbRec.df_resetlogs_change# OR
              min_scn <= lbRec.df_resetlogs_change#)) THEN
            RETURN TRUE;
         ELSE
            RETURN FALSE;
         END IF;
      END IF;
      i := i + maxDfNumber;
   END LOOP;
 
   RETURN FALSE;
END listBackupInMKS;
 
--
PROCEDURE listBackupProcessPiece(lbRec         IN            lbRec_t
                                ,lbRecOut      OUT    NOCOPY lbRec_t
                                ,lbState       IN OUT NOCOPY lbState_t)
IS
BEGIN
  IF (debug) THEN -- protect for performance
     deb(DEB_ENTER, 'listBackupProcessPiece');
  END IF;
--
--
--
--
--
--
  IF (anyDevice = TRUE# OR isDeviceTypeAllocated(lbRec.device_type) = TRUE#)
  THEN
    IF (recoveryDestFile AND lbRec.is_rdf = 'NO')
    OR (orsAnyFile AND lbRec.bp_ba_access IN ('U','D'))
    OR ((orsLocalFile OR orsLibKey IS NOT NULL) AND
        (lbRec.bp_ba_access IN ('U','D') OR
         nvl(lbRec.bp_lib_key, 0) != nvl(orsLibKey, 0)))
    THEN
      IF (debug) THEN -- protect for performance
        deb(DEB_IN, 'file_type: ' || lbRec.file_type ||
                    ' not a recovery area or ors file pkey: ' || lbRec.pkey);
      END IF;
    ELSE
--
       IF (lbRec.bp_copy# > lbState.lbCopyCount)
       THEN
         lbState.lbCopyCount := lbRec.bp_copy#;
       END IF;
--
--
       BEGIN
         lbState.lbPieceCountTab(lbRec.bp_copy#-1) :=
                 lbState.lbPieceCountTab(lbRec.bp_copy#-1) + 1;
       EXCEPTION
         WHEN no_data_found THEN   -- lbPieceCountTab(i) uninitialized
           lbState.lbPieceCountTab(lbRec.bp_copy#-1) := 1;
--
--
           lbState.lbRecCmn.bs_copies := lbState.lbRecCmn.bs_copies + 1;
       END;
 
--
--
       IF (lbState.lbRecCmn.bs_status is NULL)
       THEN
         lbState.lbRecCmn.bs_status := lbRec.status;
       ELSIF (lbRec.status <> lbState.lbRecCmn.bs_status)
       THEN
--
--
         lbState.lbRecCmn.bs_status := other_txt;
       END IF;
 
--
--
--
--
       lbState.lbRecCmn.bs_bytes := lbState.lbRecCmn.bs_bytes +
                                    lbRec.bytes;
 
--
--
       IF (lbState.lbRecCmn.bs_device_type is NULL)
       THEN
         lbState.lbRecCmn.bs_device_type := lbRec.device_type;
       ELSIF (instr(lbState.lbRecCmn.bs_device_type, lbRec.device_type) = 0)
       THEN
         BEGIN
            lbState.lbRecCmn.bs_device_type :=
               lbState.lbRecCmn.bs_device_type||','||lbRec.device_type;
         EXCEPTION
            WHEN value_error THEN
               deb(DEB_IN, 'dev buffer overflow length=' ||
                   lengthb(lbState.lbRecCmn.bs_device_type));
         END;
       END IF;
 
--
--
       IF (lbState.lbRecCmn.bs_compressed is NULL)
       THEN
         lbState.lbRecCmn.bs_compressed := lbRec.compressed;
       ELSIF (lbState.lbRecCmn.bs_compressed != lbRec.compressed)
       THEN
          lbState.lbRecCmn.bs_compressed := '###';
       END IF;
 
--
--
       IF (lbRec.tag IS NOT NULL) THEN
         IF (lbState.lbRecCmn.bs_tag is NULL) THEN
           lbState.lbRecCmn.bs_tag := lbRec.tag;
         ELSIF (instr(lbState.lbRecCmn.bs_tag, lbRec.tag) = 0) THEN
           BEGIN
              lbState.lbRecCmn.bs_tag :=
                 lbState.lbRecCmn.bs_tag||','||lbRec.tag;
           EXCEPTION
              WHEN value_error THEN
                 deb(DEB_IN, 'tag buffer overflow length=' ||
                     lengthb(lbState.lbRecCmn.bs_tag));
           eND;
         END IF;
       END IF;
    END IF;
  ELSE
    IF (debug) THEN
      deb(DEB_IN, 'device type not allocated');
    END IF;
  END IF;
 
  IF (debug) THEN  -- protect for performance
     deb(DEB_EXIT, 'OK');
  END IF;
END listBackupProcessPiece;
 
PROCEDURE setNeedObsoleteData(NeedObsoleteData IN boolean DEFAULT TRUE) IS
BEGIN
  IF NeedObsoleteData THEN
     lb_NeedObsoleteData := TRUE#;
  ELSE
     lb_NeedObsoleteData := FALSE#;
  END IF;
END;
 
--
FUNCTION listBackup(lbRecOut      OUT    NOCOPY lbRec_t
                   ,firstCall     IN     boolean
                   ,only_obsolete IN     boolean
                   ,redundancy    IN     number
                   ,piped_call    IN     boolean  -- not called by RMAN client
                   ,lbCursor      IN OUT NOCOPY lbCursor_t
                   ,lbState       IN OUT NOCOPY lbState_t
                   ,extRlKeepSCN  IN     number DEFAULT NULL)
RETURN boolean IS
  lbRec                lbRec_t;
  null_lbRec           lbRec_t := NULL;
  i                    binary_integer;
  j                    binary_integer;
  tmp                  binary_integer;
  rc                   binary_integer;
  found                boolean;
  lbCursor_notfound    boolean := FALSE;
  numBackups           number;
  oldest_flashback_scn number;
  fullBackups          number;
  actionMask           number;
  containerMask        number;
 
--
  full_df_backup       boolean;
  incr_df_backup       boolean;
  arc_log_backup       boolean;
  keep                 varchar2(3);
  keep_until           date;
 
--
  save_dbinc_key       number;
  save_reset_scn       number;
  dfRec                dfRec_t;
  rcvRecNxt            rcvRec_t;
  rcvRec               rcvRec_t;
  rcvRecStack_count    binary_integer;
  extendMask           binary_integer;
BEGIN
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
  IF (debug) THEN -- protect for performance
     deb(DEB_ENTER, 'listBackup');
  END IF;
 
--
  lbRecOut := NULL;
 
  IF (firstCall)
  THEN
    IF (debug) THEN -- protect for performance
       deb(DEB_IN, 'FIRST');
    END IF;
 
--
    validateState(NULL);
 
--
    setAllIncarnations(TRUE);
 
--
--
--
--
    setCanApplyAnyRedo(TRUE);
 
    setCanHandleTransportableTbs(TRUE);
 
--
    cacheBsRecTable.hint := redundantHint;
 
--
    lbState.lbRecOutTab.delete;
    lbState.lbRecOutTab_count := 0;
 
--
    lbState.lbRecTmpTab.delete;
 
--
--
    lbState.lbDfRecTabUs.delete;
 
--
    lbState.lbDfRecTab.delete;
 
--
--
--
    lbState.lbPieceCountTab.delete;
    lbState.lbCopyCount       := 0;
 
--
    lbState.lbMkTab.delete;
 
--
    lbState.lbMkITab.delete;
 
--
--
    SELECT SYSDATE INTO lbState.lbNowTime from dual;
 
--
--
--
--
--
--
--
    dfRec.dfNumber      := 0;
    dfRec.dfCreationSCN := 0;
    dfRec.inBackup      := 1;
    dfRec.noBackupPdb   := 0;
    dfRec.foreignDbid   := 0;
    dfRec.pluggedRonly  := 0;
    dfRec.pluginSCN     := 0;
 
    lbState.lbDfRecTabUs(0).dfRec          := dfRec;
    lbState.lbDfRecTabUs(0).fullmin_scn    := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).fullmin_rlgscn := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).incrmin_scn    := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).incrmin_rlgscn := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).logmin_scn     := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).logmin_rlgscn  := MAXSCNVAL;
 
    IF lb_NeedObsoleteData = TRUE# THEN
      lbState.lbNeedObsoleteData  := TRUE;
    ELSE
      lbState.lbNeedObsoleteData  := FALSE;
      deb(DEB_PRINT,'listBackup:caller not interested in Obsolete Data');
    END IF;
--
    save_dbinc_key := this_dbinc_key;
    save_reset_scn := this_reset_scn;
--
    lbState.lbMaxDfNumber := getMaxDfNumber;
    <<loop_travelinc>>
    LOOP
      translateDatabase(TRUE#);
      <<loop_genDfRecTab>>
      LOOP
        BEGIN
          getDatafile(dfRec);
        EXCEPTION
          WHEN no_data_found THEN EXIT loop_genDfRecTab;
        END;
--
--
--
--
--
        j := dfRec.dfNumber;
        <<loop_scanDfRecTab>>
        LOOP
          BEGIN
--
--
--
--
--
            IF (lbState.lbDfRecTabUs(j).dfRec.dfNumber = 0)
            THEN
              RAISE no_data_found;
            END IF;
            IF (dfRec.dfNumber =
                   lbState.lbDfRecTabUs(j).dfRec.dfNumber  AND
                dfRec.dfCreationSCN =
                   lbState.lbDfRecTabUs(j).dfRec.dfCreationSCN)
            THEN
--
              EXIT loop_scanDfRecTab;
            ELSE
--
--
              j := j + lbState.lbMaxDfNumber;
            END IF;
          EXCEPTION
            WHEN no_data_found
            THEN
              lbState.lbDfRecTabUs(j).dfRec          := dfRec;
              lbState.lbDfRecTabUs(j).fullmin_scn    := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).fullmin_rlgscn := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).logmin_scn     := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).logmin_rlgscn  := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).incrmin_scn    := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).incrmin_rlgscn := MAXSCNVAL;
          END;
        END LOOP;
      END LOOP;
--
--
--
--
      IF (untilSCN IS NOT NULL AND untilSCN < this_reset_scn)
      THEN
        rc := getParentIncarnation(this_dbinc_key, this_reset_scn);
        EXIT loop_travelinc WHEN rc = FALSE#;
      ELSE
        EXIT loop_travelinc;
      END IF;
    END LOOP;
--
    this_dbinc_key := save_dbinc_key;
    this_reset_scn := save_reset_scn;
 
--
    getFlashbackInfo(lbState.lbFbUntilTime, lbState.lbMinGrsp);
    IF (debug) THEN
       deb(DEB_IN, 'lbFbUntilTime= ' || to_char(lbState.lbFbUntilTime) ||
                   ' lbMinGrsp=' || to_char(lbState.lbMinGrsp));
    END IF;
 
    lbState.lbRlKeepRlgSCN  := MAXSCNVAL;
    lbState.lbRlKeepSCN     := MAXSCNVAL;
    IF (extRlKeepSCN IS NOT NULL) THEN
       lbState.lbRlKeepSCN     := extRlKeepSCN;
       lbState.lbRlKeepRlgSCN  := getPointInTimeInc(extRlKeepSCN);
       IF (debug) THEN
           deb(DEB_IN, 'Extending lbRlKeepSCN for external keepscn to '||
               to_char(lbState.lbRlKeepSCN));
           deb(DEB_IN, 'Extending lbRlKeepRlgSCN for external keepscn to '||
               to_char(lbState.lbRlKeepRlgSCN));
       END IF;
    END IF;
 
    IF (this_baseline_cap >= 0) THEN
       this_baseline_cap_scn := untilSCN;
       deb(DEB_IN, 'baseline_cap_scn = ' || this_baseline_cap_scn);
--
--
--
       resetUntil;
--
--
       setDeviceType('SBT_TAPE');
       containerMask := backupSet_con_t +
                        imageCopy_con_t +
                        offlineRangeRec_con_t;
    ELSE
       containerMask := backupSet_con_t +
                        proxyCopy_con_t +
                        imageCopy_con_t +
                        offlineRangeRec_con_t;
    END IF;
 
--
--
--
    actionMask := full_act_t + offlineRange_act_t + implicitRange_act_t +
                  cleanRange_act_t;
    IF (untilTime IS NOT NULL OR untilSCN IS NOT NULL) THEN
       actionMask := actionMask + incremental_act_t;
    END IF;
 
--
--
--
    setComputeRecoveryActionMasks(containerMask   => containerMask,
                                  actionMask      => actionMask,
                                  allRecords      => TRUE#,
                                  availableMask   => BSavailable,
                                  fullBackups     => redundancy);
 
--
--
--
    setCraGetAllCfBackups(TRUE);
 
--
--
--
--
    IF NOT (lbState.lbNeedObsoleteData OR this_baseline_cap >= 0) THEN
      goto ObsoleteDataSkip;
    END IF;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
    i := to_number(null);
    LOOP
      IF (i is null) THEN
         i := lbState.lbDfRecTabUs.first;
      ELSE
         i := lbState.lbDfRecTabUs.next(i);
      END IF;
      EXIT WHEN i IS NULL;
      dfRec := lbState.lbDfRecTabUs(i).dfRec;
 
      IF (this_baseline_cap >= 0) AND 
         NOT setLocalOrsSiteKey(db_id => NULL) THEN
         deb(DEB_IN, 'local ORS site_key not set, no backups yet recieved');
      ELSE
--
--
--
--
--
--
--
         rc := computeRecoveryActions(
                                   fno           => dfRec.dfNumber,
                                   crescn        => dfRec.dfCreationSCN,
                                   allowfuzzy    => FALSE,
                                   partial_rcv   => FALSE,
                                   allCopies     => FALSE,
                                   cleanscn      => dfRec.stopSCN,
                                   clean2scn     => highscnval,
                                   clean2time    => lbState.lbNowTime,
                                   onlscn        => dfRec.dfOnlineSCN,
                                   offlscn       => dfRec.dfOfflineSCN,
                                   onltime       => dfRec.dfOnlineTime,
                                   rmanCmd       => obsoleteCmd_t,
                                   foreignDbid   => dfRec.foreignDbid,
                                   pluggedRonly  => dfRec.pluggedRonly,
                                   pluginSCN     => dfRec.pluginSCN,
                                   pluginRlgSCN  => dfRec.pluginRlgSCN,
                                   pluginRlgTime => dfRec.pluginRlgTime,
                                   creation_thread  => dfRec.creation_thread,
                                   creation_size    => dfRec.creation_size,
                                   pdbId            => dfRec.pdbId,
                                   pdbForeignDbid   => dfRec.pdbForeignDbid);
      END IF;
 
      IF (this_baseline_cap >= 0) THEN
         deb(DEB_IN, 'Found a new datafile ' || dfRec.dfNumber);
         lbRec.df_file#            := dfRec.dfNumber;
         lbRec.df_ts#              := dfRec.tsNumber;
         lbRec.df_plugin_change#   := dfRec.pluginSCN;
         lbRec.df_foreign_dbid     := dfRec.foreignDbid;
         lbRec.df_tablespace       := dfRec.tsName;
         lbRec.df_creation_change# := dfRec.dfCreationSCN;
 
         lbRec.file_type             := NULL;
         lbRec.backup_type           := NULL;
         lbRec.bs_key                := NULL;
         lbRec.df_checkpoint_change# := NULL;
      END IF;
 
      numBackups := 0;
      fullBackups := getRecFullCount;
      LOOP
        EXIT WHEN (getRecStackCount = 0 OR
                   (this_baseline_cap >= 0 AND lbRec.bs_key IS NOT NULL));
--
--
        IF (this_baseline_cap >= 0) THEN
          IF getRecStackCount = 1 THEN
             rcvRecPop(rcvRec);
          ELSIF getRecStackCount > 1 THEN
             rcvRecGet(1, rcvRec);
             rcvRecGet(2, rcvRecNxt);
          END IF;
          deb(DEB_IN, 'Newest RcvRec record');
          printRcvRec(rcvRec, TRUE);
          deb(DEB_IN, 'Next to New RcvRec record');
          printRcvRec(rcvRecNxt, TRUE);
        ELSE
          rcvRecPop(rcvRec);
        END IF;
 
        IF (this_baseline_cap >= 0) THEN
          IF (rcvRec.type_act = full_act_t AND
              (rcvRec.toSCN_act > this_baseline_cap_scn OR
               this_baseline_cap_scn IS NULL)) THEN
             lbRec.bs_key := rcvRec.bsKey_con;
             lbRec.df_checkpoint_change# := rcvRec.toSCN_act;
             deb(DEB_IN, 'Found-1 newest backup within baseline_cap for ' ||
                 lbRec.df_file# || ' as ' || lbRec.bs_key);
          ELSE 
             IF (rcvRecNxt.type_act = full_act_t AND
                 ((rcvRec.type_act = offlineRange_act_t OR
                   rcvRec.type_act = cleanRange_act_t   OR
                   rcvRec.type_act = implicitRange_act_t) AND
                  (rcvRec.toSCN_act >= this_baseline_cap_scn OR
                   rcvRec.toSCN_act = MAXSCNVAL))) THEN
                  lbRec.bs_key := rcvRecNxt.bsKey_con;
                  lbRec.df_checkpoint_change# := rcvRec.toSCN_act;
                  deb(DEB_IN, 'Found-2 newest backup with baseline_cap for '
                              || lbRec.df_file# || ' as ' || lbRec.bs_key);
             END IF;
          END IF;
          EXIT;
        END IF;
 
        IF (rcvRec.type_act = full_act_t)
        THEN
          IF (rcvRec.keep_options = KEEP_NO)                  -- nokeep backup
          THEN
            addBackupToMKL(lbState.lbMkTab, rcvRec);
            extendKeepSCN(lbState.lbDfRecTabUs(i),
                          rcvRec.toSCN_act,
                          rcvRec.rlgSCN_act,
                          extendAllSCN,
                          FALSE,
                          'extendFullBackup (NoKeep)');
            numBackups := numBackups+1;          -- bump the number of backups
          ELSIF (NVL(rcvRec.keep_until,MAXDATEVAL) > lbState.lbNowTime)
--
          THEN
--
--
            IF (rcvRec.keep_options =  KEEP_LOGS)                 -- keep logs?
            THEN
              extendKeepSCN(lbState.lbDfRecTabUs(i),
                            rcvRec.toSCN_act,
                            rcvRec.rlgSCN_act,
                            extendLogSCN + extendIncrSCN,
                            FALSE,
                            'extendFullBackup (Keep)');
            END IF;
          END IF;
 
        ELSIF (rcvRec.type_act = offlineRange_act_t OR
               rcvRec.type_act = cleanRange_act_t   OR
               rcvRec.type_act = implicitRange_act_t)
        THEN
           extendMask := 0;
           IF (lbState.lbDfRecTabUs(i).fullmin_scn = rcvRec.fromSCN_act) THEN
              extendMask := extendMask + extendFullSCN;
           END IF;
 
           IF (lbState.lbDfRecTabUs(i).incrmin_scn = rcvRec.fromSCN_act) THEN
              extendMask := extendMask + extendIncrSCN;
           END IF;
 
           IF (lbState.lbDfRecTabUs(i).logmin_scn = rcvRec.fromSCN_act) THEN
              extendMask := extendMask + extendLogSCN;
           END IF;
 
           extendKeepSCN(lbState.lbDfRecTabUs(i), 
                         rcvRec.toSCN_act,
                         rcvRec.rlgSCN_act,
                         extendMask,
                         TRUE,
                         'extendMiscRange');
        ELSIF (rcvRec.type_act = incremental_act_t)
        THEN
          IF (lbState.lbDfRecTabUs(i).incrmin_scn >= rcvRec.fromSCN_act AND
              lbState.lbDfRecTabUs(i).incrmin_scn < rcvRec.toSCN_act)
          THEN
            addBackupToMKL(lbState.lbMkITab, rcvRec);
            extendKeepSCN(lbState.lbDfRecTabUs(i),
                          rcvRec.toSCN_act,
                          rcvRec.rlgSCN_act,
                          extendIncrSCN,
                          TRUE,
                          'extendIncrBackup');
          END IF;
        END IF;
      END LOOP;
 
--
--
--
--
 
--
--
--
      IF ((lbState.lbDfRecTabUs(i).fullmin_scn = MAXSCNVAL OR -- no bkp
           numBackups < redundancy) AND             -- not enough backups
          dfRec.inBackup = 1 AND                    -- file not excluded
          dfRec.noBackupPdb = 0 AND                 -- not a excluded PDB
          dfRec.pluggedRonly = 0)                   -- not a plugged readonly
 
      THEN
        extendKeepSCN(lbState.lbDfRecTabUs(i),
                      dfRec.dfCreationSCN,
                      getPointInTimeInc(dfRec.dfCreationSCN),
                      extendAllSCN,
                      TRUE,
                      'extendNoBackup');
      END IF;
 
--
--
      IF (lbState.lbRlKeepSCN > lbState.lbDfRecTabUs(i).logmin_scn)
      THEN
        lbState.lbRlKeepSCN    := lbState.lbDfRecTabUs(i).logmin_scn;
        lbState.lbRlKeepRlgSCN := lbState.lbDfRecTabUs(i).logmin_rlgscn;
        IF (debug) THEN -- protect for performance
           deb(DEB_IN, 'Extending lbRlKeepSCN to '||
               to_char(lbState.lbRlKeepSCN));
           deb(DEB_IN, 'Extending lbRlKeepRlgSCN to '||
               nvl(to_char(lbState.lbRlKeepRlgSCN), 'null'));
        END IF;
      END IF;
 
      IF (this_baseline_cap >= 0) THEN
         lbState.lbRecOutTab(lbState.lbRecOutTab_count) := lbRec;
         lbState.lbRecOutTab_count := lbState.lbRecOutTab_count + 1;
      END IF;
    END LOOP;
 
--
    LOOP
      BEGIN
--
        IF (getSpfileBackup(rcvRec     => rcvRec,
                            redundancy => redundancy,
                            rmanCmd    => obsoleteCmd_t) = SUCCESS) THEN
          addBackupToMKL(lbState.lbMkTab, rcvRec);
        ELSE
          EXIT;
        END IF;
      EXCEPTION
        WHEN no_data_found THEN EXIT;
      END;
    END LOOP;
 
<<ObsoleteDataSkip>>
 
--
--
    translateAllDatafile;
    LOOP
      BEGIN
        getDatafile(dfRec);
      EXCEPTION
        WHEN no_data_found THEN EXIT;
      END;
      lbState.lbDfRecTab(lbState.lbDfRecTab.count) := dfRec;
    END LOOP;
 
--
--
    IF (piped_call)
    THEN
      openLbCursor(lbCursor);
    ELSE
      IF (listBackup_c%ISOPEN)
      THEN
        CLOSE listBackup_c;
      END IF;
      OPEN listBackup_c;
    END IF;
 
--
--
--
--
--
--
    lbState.lbObsoleteRetention := FALSE;
    lbState.lbKeepForDbpitr     := FALSE;
 
--
--
    lbState.lbObsoleteKeep := FALSE;
--
    lbState.lbRecTmpTab.delete;
    lbState.lbCopyCount := 0;
    lbState.lbPieceCountTab.delete;
    lbState.lbRecCmn := null_lbRec;
 
    IF (debug) THEN
      deb(DEB_IN, 'Must Keep List:');
      i := lbState.lbMkTab.first;
      LOOP
        EXIT WHEN i IS NULL;
        FOR j in 0..lbState.lbMkTab(i).count-1 LOOP
          IF (lbState.lbMkTab(i)(j).type_con = backupSet_con_t) THEN
            deb(DEB_PRINT, 'Backup Set bskey=' ||
                lbState.lbMkTab(i)(j).bsKey_con || ' set_stamp=' ||
                lbState.lbMkTab(i)(j).setStamp_con || ' set_count=' ||
                lbState.lbMkTab(i)(j).setCount_con);
          ELSIF (lbState.lbMkTab(i)(j).type_con = imageCopy_con_t) THEN
            deb(DEB_PRINT, 'Datafile Copy key=' ||
                lbState.lbMkTab(i)(j).key_con || ' recid=' ||
                lbState.lbMkTab(i)(j).recid_con || ' stamp=' ||
                lbState.lbMkTab(i)(j).stamp_con);
          ELSIF (lbState.lbMkTab(i)(j).type_con = proxyCopy_con_t) THEN
            deb(DEB_PRINT, 'Proxy Backup key=' ||
                lbState.lbMkTab(i)(j).key_con || ' recid=' ||
                lbState.lbMkTab(i)(j).recid_con || ' stamp=' ||
                lbState.lbMkTab(i)(j).stamp_con);
          ELSE
            deb(DEB_PRINT, 'Unknown Type=' || lbState.lbMkTab(i)(j).type_con);
          END IF;
        END LOOP;
        i := lbState.lbMkTab.next(i);
     END LOOP;
    END IF;
 
--
--
    cacheBsRecTable.hint := noHint;
  END IF; -- first call
 
  IF (this_baseline_cap >= 0) THEN
     goto listBackup_returnRec; 
  END IF;
 
  <<main_loop>>
 
 
  WHILE (lbState.lbRecOutTab_count = 0)     -- while there is nothing to return
  LOOP
 
    IF (piped_call)
    THEN
      FETCH lbCursor INTO lbRec;
      IF (lbCursor%NOTFOUND)
      THEN
        lbCursor_notfound := TRUE;
      END IF;
    ELSE
      FETCH listBackup_c INTO lbRec;
      IF (listBackup_c%NOTFOUND)
      THEN
        lbCursor_notfound := TRUE;
      END IF;
    END IF;
 
    IF (lbCursor_notfound OR
        (lbRec.file_type = backupset_txt) OR
        (lbRec.backup_type IN (copy_txt, proxycopy_txt)) OR
        (lbRec.backup_type = backupset_txt AND
         lbRec.file_type <> backupset_txt AND
         (lbState.lbRecCmn.recid IS NULL OR
          lbState.lbRecCmn.bs_stamp <> lbRec.bs_stamp OR
          lbState.lbRecCmn.bs_count <> lbRec.bs_count)))
    THEN
--
--
--
--
--
--
--
--
      IF (lbState.lbRecTmpTab.count > 0 AND lbState.lbCopyCount > 0 AND
          (NOT only_obsolete OR lbState.lbObsoleteRetention OR
           lbState.lbObsoleteKeep))
      THEN
--
--
--
        IF lbState.lbNeedObsoleteData THEN
          IF (lbState.lbObsoleteRetention OR lbState.lbObsoleteKeep)
          THEN
            IF (debug) THEN -- protect for performance
               deb(DEB_IN, 'E: Obsolete!!!');
            END IF;
            lbState.lbRecCmn.obsolete := 'YES';
            lbState.lbRecCmn.keep_for_dbpitr := 'NO';
          ELSE
            IF (debug) THEN -- protect for performance
               deb(DEB_IN, 'E: Not obsolete!!!');
            END IF;
            lbState.lbRecCmn.obsolete := 'NO';
            IF (lbState.lbKeepForDbpitr) THEN
               lbState.lbRecCmn.keep_for_dbpitr := 'YES';
            ELSE
               lbState.lbRecCmn.keep_for_dbpitr := 'NO';
            END IF;
          END IF;
        END IF;
 
--
--
        IF (lbState.lbRecCmn.status <> other_txt)
        THEN
          <<loop_copy>>
          FOR i IN 0..lbState.lbCopyCount-1
          LOOP
            BEGIN
              IF (lbState.lbRecCmn.bs_pieces != lbState.lbPieceCountTab(i))
              THEN
                lbState.lbRecCmn.status := other_txt;
                EXIT loop_copy;
              END IF;
            EXCEPTION
              WHEN no_data_found THEN  -- lbPieceCountTab(i) uninitialized
                EXIT loop_copy;
            END;
          END LOOP;
        END IF;
 
--
        IF (debug) THEN -- protect for performance
           deb(DEB_IN, 'pipelineing backup set '||lbState.lbRecCmn.bs_key);
        END IF;
 
        FOR i IN 0..lbState.lbRecTmpTab.count-1
        LOOP
--
          IF (recoveryDestFile AND lbState.lbRecTmpTab(i).is_rdf = 'NO')
          OR (orsAnyFile     AND
              lbState.lbRecTmpTab(i).bp_ba_access IN ('U','D'))
          OR (orsLocalFile   AND
              lbState.lbRecTmpTab(i).bp_ba_access IN ('U','D','T','R'))
          OR (orsLibKey IS NOT NULL AND
              nvl(lbState.lbRecTmpTab(i).bp_lib_key, 0) != orsLibKey)
          THEN
--
             IF (debug) THEN -- protect for performance
                deb(DEB_IN, 'not a recovery area or ors file type');
             END IF;
          ELSIF (anyDevice = FALSE# AND         -- not all device is allocated
                 lbState.lbRecTmpTab(i).file_type = piece_txt AND
                 isDevicetypeAllocated(lbState.lbRecTmpTab(i).device_type) =
                   FALSE#) THEN
--
--
--
             IF (debug) THEN -- protect for performance
                deb(DEB_IN, 'device type not allocated');
             END IF;
          ELSE
--
--
--
 
             tmp := lbState.lbRecOutTab_count;
             lbState.lbRecOutTab(tmp) :=
                lbState.lbRecTmpTab(i);
             lbState.lbRecOutTab(tmp).obsolete :=
                lbState.lbRecCmn.obsolete;
             lbState.lbRecOutTab(tmp).keep_for_dbpitr :=
                lbState.lbRecCmn.keep_for_dbpitr;
             lbState.lbRecOutTab(tmp).bs_status :=
                lbState.lbRecCmn.bs_status;
             lbState.lbRecOutTab(tmp).bs_copies :=
                lbState.lbRecCmn.bs_copies;
             lbState.lbRecOutTab(tmp).bs_bytes :=
                lbState.lbRecCmn.bs_bytes / lbState.lbRecCmn.bs_copies;
             lbState.lbRecOutTab(tmp).bs_compressed :=
                lbState.lbRecCmn.bs_compressed;
             lbState.lbRecOutTab(tmp).bs_tag :=
                lbState.lbRecCmn.bs_tag;
             lbState.lbRecOutTab(tmp).bs_device_type :=
                lbState.lbRecCmn.bs_device_type;
             IF (lbState.lbRecCmn.recid IS NOT NULL) THEN
--
--
                lbState.lbRecOutTab(tmp).backup_type :=
                   lbState.lbRecCmn.backup_type;
                lbState.lbRecOutTab(tmp).keep :=
                   lbState.lbRecCmn.keep;
                lbState.lbRecOutTab(tmp).keep_options:=
                   lbState.lbRecCmn.keep_options;
                lbState.lbRecOutTab(tmp).keep_until :=
                   lbState.lbRecCmn.keep_until;
                lbState.lbRecOutTab(tmp).bs_key :=
                   lbState.lbRecCmn.bs_key;
                lbState.lbRecOutTab(tmp).bs_count :=
                   lbState.lbRecCmn.bs_count;
                lbState.lbRecOutTab(tmp).bs_stamp :=
                   lbState.lbRecCmn.bs_stamp;
                lbState.lbRecOutTab(tmp).bs_type :=
                   lbState.lbRecCmn.bs_type;
                lbState.lbRecOutTab(tmp).bs_incr_type :=
                   lbState.lbRecCmn.bs_incr_type;
                lbState.lbRecOutTab(tmp).bs_pieces :=
                   lbState.lbRecCmn.bs_pieces;
                lbState.lbRecOutTab(tmp).bs_completion_time :=
                   lbState.lbRecCmn.bs_completion_time;
             END IF;
             lbState.lbRecOutTab_count := tmp + 1;
          END IF;
        END LOOP;
      END IF;
 
--
      IF (lbCursor_notfound)
      THEN
        exit main_loop;
      END IF;
 
--
--
--
--
--
      IF (lbRec.file_type <> backupset_txt AND
          lbRec.backup_type = backupset_txt)
      THEN
        IF (debug) THEN
          deb(DEB_IN, 'setting lbObsoleteRetention to FALSE');
        END IF;
        lbState.lbObsoleteRetention := FALSE;
      ELSE
        IF (debug) THEN
          deb(DEB_IN, 'setting lbObsoleteRetention to TRUE');
        END IF;
        lbState.lbObsoleteRetention := TRUE;
      END IF;
 
--
--
      lbState.lbObsoleteKeep  := FALSE;
      lbState.lbKeepForDbpitr := FALSE;
 
--
      lbState.lbRecTmpTab.delete;
      lbState.lbCopyCount := 0;
      lbState.lbPieceCountTab.delete;
      lbState.lbRecCmn := null_lbRec;
    END IF;
 
    IF (debug) THEN  -- protect for performance
       printLbRec(lbRec);
 
--
--
       IF (lbRec.backup_type = backupset_txt AND
           lbRec.file_type <> backupset_txt) THEN
          IF ((lbState.lbRecCmn.bs_stamp = lbRec.bs_stamp AND
               lbState.lbRecCmn.bs_count = lbRec.bs_count) OR
              lbState.lbRecCmn.bs_key = lbRec.bs_key) THEN
             deb(DEB_IN, 'bs->bp->bdf/bsf/brl same bs');
          ELSE
             deb(DEB_IN, 'bs->bp->bdf/bsf/brl **no** bs (or) **not** same bs');
          END IF;
       END IF;
    END IF;
 
--
--
--
--
 
    If lbState.lbNeedObsoleteData THEN
      lbRec.obsolete := 'YES';                -- assume that backup is obsolete
      lbRec.keep_for_dbpitr := 'NO';
    END IF;
 
    IF (lbState.lbObsoleteRetention AND NOT lbState.lbObsoleteKeep AND
        lbState.lbNeedObsoleteData) THEN
--
       full_df_backup := FALSE;
       incr_df_backup := FALSE;
       arc_log_backup := FALSE;
 
       IF (lbRec.backup_type = backupset_txt) THEN
          IF (lbRec.file_type = archivedlog_txt) THEN
             arc_log_backup := TRUE;
          ELSIF (lbRec.file_type IN (spfile_txt, controlfile_txt)) THEN
             full_df_backup := TRUE;
          ELSIF (lbRec.file_type = datafile_txt) THEN
             IF (lbRec.df_incremental_change# = lbRec.df_creation_change# OR
                 lbRec.bs_incr_type = full_txt) THEN
                full_df_backup := TRUE;
             ELSIF (lbRec.bs_incr_type <> full_txt) THEN
                incr_df_backup := TRUE;
             END IF;
          END IF;
       ELSIF (lbRec.backup_type IN (copy_txt, proxycopy_txt) AND
              lbRec.file_type   IN (datafile_txt, controlfile_txt)) THEN
          full_df_backup := TRUE;
       END IF;
 
--
       keep := NVL(lbRec.keep, 'NO');
       keep_until := NVL(lbRec.keep_until, MAXDATEVAL);
       IF ((full_df_backup OR arc_log_backup OR incr_df_backup) AND
           lbRec.backup_type = backupset_txt)
       THEN
          keep := NVL(lbState.lbRecCmn.keep, 'NO');
          keep_until := NVL(lbState.lbRecCmn.keep_until, MAXDATEVAL);
       END IF;
 
--
       IF (keep = 'YES') THEN
          IF (debug) THEN -- protect for performance
             deb(DEB_IN, 'Keep backup until ' || keep_until ||
                         ' - Checking ...');
          END IF;
          IF (keep_until < lbState.lbNowtime) THEN
             IF (debug) THEN  -- protect for performance
               deb(DEB_IN, 'expired -> obsolete by keep');
             END IF;
             lbState.lbObsoleteKeep := TRUE;
          ELSE
             IF (debug) THEN  -- protect for performance
               deb(DEB_IN, 'not expired -> no obsolete');
             END IF;
             lbState.lbObsoleteRetention := FALSE;
          END IF;
       END IF;
 
--
       IF (full_df_backup) THEN
          IF (keep != 'YES') THEN                             -- nokeep backup
             IF (debug) THEN  -- protect for performance
                deb(DEB_IN, 'Full backup - Checking ...');
             END IF;
             IF ((lbRec.file_type = spfile_txt AND
                  lbRec.df_ckp_mod_time <            -- it is SPFILE outside RW
                     NVL(untilTime, MAXDATEVAL))   OR
                 (lbRec.file_type <> spfile_txt AND  -- other file outside RW
                  ((untilTime IS NULL AND untilSCN IS NULL) OR
                   lbRec.df_ckp_mod_time < untilTime        OR
                   (untilTime IS NULL AND
                    lbRec.df_checkpoint_change# <= untilSCN)))) THEN
                IF (debug) THEN  -- protect for performance
                   deb(DEB_IN, 'nokeep backup outside RW');
                END IF;
                IF (listBackupInMKL(lbState.lbMkTab, lbRec)) THEN
                   IF (debug) THEN -- protect for performance
                      deb(DEB_IN, 'inside MKL -> no obsolete');
                      deb(DEB_IN, 'keep_for_dbpitr = YES');
                   END IF;
                   lbState.lbObsoleteRetention := FALSE;
                   lbState.lbKeepForDbpitr     := TRUE;
                ELSIF (listBackupInMKS(lbState.lbDfRecTabUs, lbRec,
                                       lbState.lbMaxDfNumber, FALSE)) THEN
--
--
--
--
                   IF (debug) THEN -- protect for performance
                      deb(DEB_IN, 'inside MKS -> no obsolete');
                   END IF;
                   lbState.lbObsoleteRetention := FALSE;
                   lbState.lbKeepForDbpitr     := FALSE;
                END IF;
             ELSE                          -- inside Recovery Win, not obsolete
                IF (debug) THEN -- protect for performance
                   deb(DEB_IN, 'nokeep backup: inside RW -> no obsolete');
                END IF;
                lbState.lbObsoleteRetention := FALSE;
             END IF;
          END IF;
       ELSIF (incr_df_backup) THEN
          IF (debug) THEN -- protect for performance
             deb(DEB_IN, 'Incremental backup - Checking ...');
          END IF;
          IF (listBackupInMKL(lbState.lbMkITab, lbRec)) THEN
             IF (debug) THEN -- protect for performance
                deb(DEB_IN, 'inside MKL -> no obsolete');
                deb(DEB_IN, 'keep_for_dbpitr = YES');
             END IF;
             lbState.lbObsoleteRetention := FALSE;
             lbState.lbKeepForDbpitr     := TRUE;
          ELSIF (listBackupInMKS(lbState.lbDfRecTabUs, lbRec,
                                 lbState.lbMaxDfNumber, TRUE)) THEN
            IF (debug) THEN -- protect for performance
               deb(DEB_IN, 'inside MKS -> no obsolete');
            END IF;
            lbState.lbObsoleteRetention := FALSE;      -- need this incremental
            lbState.lbKeepForDbpitr     := FALSE;
          END IF;
       ELSIF (lbRec.file_type = archivedlog_txt) THEN              --- redo log
--
--
--
--
          IF ((lbRec.rl_next_change# >= lbState.lbMinGrsp AND
               lbRec.backup_type != copy_txt)                      OR  -- (a)
              lbRec.rl_next_time >= lbState.lbFbUntilTime          OR  -- (b)
              (lbRec.rl_next_change# >= lbState.lbRlKeepSCN AND        -- (c)
               (lbState.lbRlKeepRlgSCN IS NULL                          OR
                lbRec.rl_resetlogs_change# = lbState.lbRlKeepRlgSCN     OR
                lbRec.rl_resetlogs_change# >= lbState.lbRlKeepSCN))) THEN
             IF (debug) THEN -- protect for performance
                IF (lbRec.rl_next_time >= lbState.lbFbUntilTime) THEN
                   deb(DEB_IN, 'Redolog after lbFbUntilTime -> no obsolete');
                ELSIF (lbRec.rl_next_change# >= lbState.lbMinGrsp AND
                       lbRec.backup_type != copy_txt) THEN
                   deb(DEB_IN, 'Redolog after lbMinGrsp -> no obsolete');
                ELSE
                   deb(DEB_IN, 'Redolog after lbRlkeepSCN -> no obsolete');
                END IF;
             END IF;
             lbState.lbObsoleteRetention := FALSE;    -- this redo must be kept
          END IF;
       END IF;
    END IF;
 
    IF (NOT lbState.lbKeepForDbpitr AND lbRec.file_type = archivedlog_txt) THEN
       IF (lbRec.rl_next_change# >= lbState.lbRlKeepSCN AND
           (lbRec.rl_first_change# <= untilSCN OR
            lbRec.rl_first_time <= untilTime)           AND
           (lbState.lbRlKeepRlgSCN IS NULL                      OR
            lbRec.rl_resetlogs_change# = lbState.lbRlKeepRlgSCN OR
            lbRec.rl_resetlogs_change# >= lbState.lbRlKeepSCN)) THEN
          IF (debug) THEN
             deb(DEB_IN, 'keep_for_dbpitr = YES');
          END IF;
          lbState.lbKeepForDbpitr := TRUE;
       END IF;
    END IF;
 
--
--
    IF (NOT lbState.lbObsoleteRetention AND NOT lbState.lbObsoleteKeep AND
        lbState.lbNeedObsoleteData)
    THEN
      IF (debug) THEN
         deb(DEB_IN, 'Not obsolete');
      END IF;
      lbRec.obsolete := 'NO';
      lbState.lbRecCmn.obsolete := 'NO';
      IF (lbState.lbKeepForDbpitr) THEN
         lbState.lbRecCmn.keep_for_dbpitr := 'YES';
         lbRec.keep_for_dbpitr := 'YES';
      ELSE
         lbState.lbRecCmn.keep_for_dbpitr := 'NO';
         lbRec.keep_for_dbpitr := 'NO';
      END IF;
      IF (only_obsolete)
      THEN
        GOTO listBackup_end;
      END IF;
    END IF;
 
--
--
--
    IF (lbRec.backup_type IN (backupset_txt, copy_txt) AND
        lbRec.file_type   = datafile_txt)
    THEN
      found := FALSE;
 
--
--
      <<loop_lbDfRecTab>>
      FOR i in lbRec.df_file#-1..lbState.lbDfRecTab.count-1
      LOOP
        IF (lbState.lbDfRecTab(i).dfNumber = lbRec.df_file# AND
            lbState.lbDfRecTab(i).dfCreationSCN = lbRec.df_creation_change#)
        THEN
          IF (lbRec.backup_type = backupset_txt)
          THEN
            lbRec.fname := lbState.lbDfRecTab(i).fileName;
          END IF;
          lbRec.df_tablespace := lbState.lbDfRecTab(i).tsName;
          found := TRUE;
          EXIT loop_lbDfRecTab;
        ELSIF (lbState.lbDfRecTab(i).dfNumber > lbRec.df_file#) THEN
          EXIT loop_lbDfRecTab;
        END IF;
      END LOOP;
 
      IF (NOT found) THEN
--
        <<reverse_loop_lbDfRecTab>>
        FOR i in REVERSE 0..least(lbRec.df_file#-1, lbState.lbDfRecTab.count-1)
        LOOP
          IF (lbState.lbDfRecTab(i).dfNumber = lbRec.df_file# AND
              lbState.lbDfRecTab(i).dfCreationSCN = lbRec.df_creation_change#)
          THEN
            IF (lbRec.backup_type = backupset_txt)
            THEN
              lbRec.fname := lbState.lbDfRecTab(i).fileName;
            END IF;
            lbRec.df_tablespace := lbState.lbDfRecTab(i).tsName;
            found := TRUE;
            EXIT reverse_loop_lbDfRecTab;
          ELSIF (lbState.lbDfRecTab(i).dfNumber < lbRec.df_file#) THEN
            EXIT reverse_loop_lbDfRecTab;
          END IF;
        END LOOP;
      END IF;
    END IF;
 
--
--
--
--
--
    IF (lbRec.backup_type = backupset_txt)
    THEN
      IF (lbRec.file_type = backupset_txt)
      THEN
--
--
--
 
--
        lbState.lbRecTmpTab.delete;
        lbState.lbCopyCount := 0;
        lbState.lbPieceCountTab.delete;
 
--
--
        lbState.lbRecCmn := lbRec;
        lbState.lbRecCmn.bs_copies := 0;
        lbState.lbRecCmn.bs_bytes  := 0;
      ELSIF lbRec.file_type in (datafile_txt, controlfile_txt,
                                spfile_txt  , archivedlog_txt,
                                piece_txt)
      THEN
        IF (NOT only_obsolete OR lbRec.file_type = piece_txt)
        THEN
--
           lbState.lbRecTmpTab(lbState.lbRecTmpTab.count) := lbRec;
           IF (lbRec.file_type = piece_txt)
           THEN
              listBackupProcessPiece(lbRec, lbRecOut, lbState);
           END IF;
        END IF;
      ELSE
--
        deb(DEB_EXIT, 'with error 20999');
        raise_application_error(-20999, 'internal error: listBackup_2');
      END IF;
    ELSIF (lbRec.backup_type = copy_txt)
    THEN
--
--
 
--
--
--
--
--
      IF (diskDevice)
      THEN
        IF (recoveryDestFile AND lbRec.is_rdf = 'NO') THEN
           IF (debug) THEN  -- protect for performance
              deb(DEB_IN,
                  'copy not recovery area or ors file pkey: ' || lbRec.pkey);
           END IF;
        ELSE
           IF (debug) THEN -- protect for performance
              deb(DEB_IN, 'device allocated: pipelineing copy '||lbRec.pkey);
           END IF;
           lbState.lbRecOutTab(lbState.lbRecOutTab_count) := lbRec;
           lbState.lbRecOutTab_count := lbState.lbRecOutTab_count+1;
        END IF;
      ELSE
        IF (debug) THEN -- protect for performance
           deb(DEB_IN, 'device not allocated: skiping copy '||lbRec.pkey);
        END IF;
      END IF;
    ELSIF (lbRec.backup_type = proxycopy_txt)
      THEN
--
--
 
--
--
--
--
--
      IF (anyDevice = TRUE# OR
          isDeviceTypeAllocated(lbRec.device_type) = TRUE#)
      THEN
        IF (recoveryDestFile AND lbRec.is_rdf = 'NO') THEN
           IF (debug) THEN -- protect for performance
              deb(DEB_IN, 'proxycopy not a recovery area file pkey: ' ||
                  lbRec.pkey);
           END IF;
        ELSE
          IF (debug) THEN -- protect for performance
             deb(DEB_IN, 'device allocated: pipelineing proxycopy '||
                 lbRec.pkey);
          END IF;
          lbState.lbRecOutTab(lbState.lbRecOutTab_count) := lbRec;
          lbState.lbRecOutTab_count := lbState.lbRecOutTab_count+1;
        END IF;
      ELSE
        IF (debug) THEN  -- protect for performance
           deb(DEB_IN, 'device not allocated: skiping proxycopy '||lbRec.pkey);
        END IF;
      END IF;
    ELSE
      deb(DEB_EXIT, 'with error 20999');
      raise_application_error(-20999, 'internal error: listBackup_3');
    END IF;
  END LOOP;
 
<<listBackup_returnRec>>
--
  IF (lbState.lbRecOutTab_count > 0)
  THEN
    lbState.lbRecOutTab_count := lbState.lbRecOutTab_count - 1;
    lbRecOut := lbState.lbRecOutTab(lbState.lbRecOutTab_count);
  END IF;
 
<<listBackup_end>>
--
--
 
  IF (lbState.lbRecOutTab_count = 0)
  THEN
    IF (this_baseline_cap >= 0) THEN
      deb(DEB_EXIT, 'FALSE');
      RETURN FALSE;
    END IF;
 
    IF (piped_call)
    THEN
      IF (lbCursor%NOTFOUND)
      THEN
        CLOSE lbCursor;
        cacheBsRecTable.hint := noHint;
        IF (debug) THEN -- protect for performance
           deb(DEB_EXIT, 'FALSE');
        END IF;
        RETURN FALSE;
      END IF;
    ELSE
      IF (listBackup_c%NOTFOUND)
      THEN
        CLOSE listBackup_c;
        cacheBsRecTable.hint := noHint;
        IF (debug) THEN -- protect for performance
           deb(DEB_EXIT, 'FALSE');
        END IF;
        RETURN FALSE;
      END IF;
    END IF;
  END IF;
 
  deb(DEB_EXIT, 'TRUE');
  RETURN TRUE;
 
EXCEPTION
  WHEN OTHERS THEN
    IF (piped_call)
    THEN
      IF (lbCursor%ISOPEN) THEN
        CLOSE lbCursor;
      END IF;
    ELSE
      IF (listBackup_c%ISOPEN) THEN
        CLOSE listBackup_c;
      END IF;
    END IF;
    deb(DEB_EXIT, 'with exception: '||substr(sqlerrm, 1, 512));
    RAISE;
 
END listBackup;
 
--
FUNCTION getRestoreRangeSet(restoreRangeTab OUT restoreRangeTab_t,
                            opCode          IN  varchar2,
                            db_id           IN  number)
 
RETURN boolean IS
 
  i                       number;
  j                       number;
  ret                     boolean;
  rc                      binary_integer;
  restoreRange            restoreRange_t;
  dfRecTab                dfRecTab_t;
  dfRec                   dfRec_t;
  rcvRec                  rcvRec_t;
  maxScn                  number;
  maxRlgScn               number;
  maxRlgTime              date;
  minScn                  number;          
  fromScn                 number;
  tmpScn                  number;
  dropScn                 number;
  dropTime                date;
  dropDbIncKey            number;
  dropRlgScn              number;
  dropRlgTime             date;
  lastBkupScn             number;
  cfcrescn                number;
  cfcretime               date;
  tmpDbIncKey             number;
  tmpRlgScn               number;
  tmpRlgTime              date;
  actionMask              number;
  dfBackupFound           number;
  offlnRngFound           number;
  dfCreation              number;
  logBreakPointScn        number;
  logBreakPointTime       date;
  logBreakDbIncKey        number;
  logBreakRlgScn          number;
  logBreakRlgTime         date;
  nextAvailableScn        number;
  logMissing              boolean;
  nxtScnExist             boolean;
  maxScnExist             boolean;
  dropScnExist            boolean;
  maxTime                 date;
  maxDbIncKey             number;
  tmpTime                 date;
  nowTime                 date;
  logRangeCount           number;
  isOrs                   number;
  type isActnFoundTab is table of boolean index by binary_integer;  
  isActnFound             isActnFoundTab;
  con_id                  number;
  canCreateDf             boolean;
  dfCreateSCN             number;
BEGIN
 
  deb(DEB_ENTER, 'getRestoreRangeSet');
  deb(DEB_IN, 'backupLocation = ' || opCode);
  if (substr(opCode,  4, 3) = 'ANY') then
     restoreRangeDevTyp := substr(opCode, 1, 6);
  elsif (substr(opCode,  4, 4) = 'DISK') then
     restoreRangeDevTyp := substr(opCode, 1, 7);
  elsif (substr(opCode,  4, 3) = 'SBT') then
     restoreRangeDevTyp := substr(opCode, 1, 6);
  elsif (substr(opCode,  1, 5) = 'V$ANY') then
     restoreRangeDevTyp := substr(opCode, 3, 3);
  elsif (substr(opCode,  1, 6) = 'V$DISK') then
     restoreRangeDevTyp := substr(opCode, 3, 4);
  elsif (substr(opCode,  1, 5) = 'V$SBT') then
     restoreRangeDevTyp := substr(opCode, 3, 3);
  end if;
 
--
  IF (opCode = 'RA$ANY' OR opCode = 'RA$DISK' OR opCode = 'RA$SBT') THEN
     IF user_site_key IS NULL THEN
        ret := setLocalOrsSiteKey(db_id);
        IF ret = FALSE THEN
           resetLocalOrsSiteKey;
           deb(DEB_EXIT, 'with FALSE');
           return FALSE;
        END IF;
     END IF;
     isOrs := TRUE#;
  ELSE
     isOrs := FALSE#;
  END IF;
 
  restoreRangeTab.delete;
 
  setCraGetAllCfBackups(TRUE);
  setAllIncarnations(TRUE);
  canApplyAnyRedo := TRUE#;
 
--
  maxScnExist  := getMaxRedoSCN(maxScn, maxTime, maxDbIncKey, maxRlgScn, 
                                maxRlgTime, isOrs);
  IF (maxScnExist = FALSE) THEN
    resetLocalOrsSiteKey;
    deb(DEB_EXIT, 'with FALSE');
    return FALSE;
  END IF;
  deb(DEB_IN, 'Max scn is ' || to_char(maxScn));
 
--
  nxtScnExist := getNextAvailableSCN(0, minScn, isOrs);
  IF (nxtScnExist = FALSE) THEN
    resetLocalOrsSiteKey;
    deb(DEB_EXIT, 'with FALSE');
    return FALSE;
  END IF;
  fromScn := minScn;
 
 
--
--
--
--
--
--
--
--
--
  i := 0; 
  LOOP
    EXIT WHEN fromScn >= maxScn;
    logMissing := findLogBreakPoint(logBreakPointScn, logBreakPointTime, 
                                    logBreakDbIncKey, logBreakRlgScn, 
                                    logBreakRlgTime, fromScn, maxScn, isOrs);
--
    IF (logMissing = FALSE) THEN
      restoreRangeTab(i).startScn     := fromScn;
      restoreRangeTab(i).highScn      := maxScn;
      restoreRangeTab(i).highTime     := maxTime;
      restoreRangeTab(i).highDbIncKey := maxDbIncKey;
      restoreRangeTab(i).highRlgScn   := maxRlgScn;
      restoreRangeTab(i).highRlgTime  := maxRlgTime;
      restoreRangeTab(i).con_id       := con_id;
      EXIT;
--
--
    ELSE 
      restoreRangeTab(i).startScn     := fromScn;
      restoreRangeTab(i).highScn      := logBreakPointScn;
      restoreRangeTab(i).highTime     := logBreakPointTime;
      restoreRangeTab(i).highDbIncKey := logBreakDbIncKey;
      restoreRangeTab(i).highRlgScn   := logBreakRlgScn;
      restoreRangeTab(i).highRlgTime  := logBreakRlgTime;
      restoreRangeTab(i).con_id       := con_id;
 
--
      nxtScnExist := getNextAvailableSCN(logBreakPointScn, nextAvailableScn, 
                                         isOrs);
      IF (nxtScnExist = TRUE) THEN
        fromScn := nextAvailableScn;
      ELSE
        EXIT;
      END IF;
    END IF;
    i := i + 1;
  END LOOP;
 
--
  logRangeCount := i + 1;
 
--
  i := 0;
  WHILE i < logRangeCount LOOP
    restoreRangeTab(i).isValidRange := FALSE;
    restoreRangeTab(i).cfBkupFound  := FALSE;
    i := i + 1;
  END LOOP;
 
  deb(DEB_IN, 'Printing continuous log-ranges');
  i := 0;
  WHILE i < logRangeCount LOOP
    deb(DEB_IN, 'Range '||to_char(i+1)||' lowscn = '||
                 to_char(restoreRangeTab(i).startScn) ||' highscn = '||
                 to_char(restoreRangeTab(i).highScn));
    i := i + 1;
  END LOOP;
 
--
  dfRecTab.delete;
  translateAllDatafile;
  LOOP
    BEGIN
      getDatafile(dfRec);
    EXCEPTION
      WHEN no_data_found THEN EXIT;
    END;
      dfRecTab(dfRecTab.count) := dfRec;
  END LOOP;
 
  SELECT SYSDATE INTO nowTime from dual;
 
--
--
  actionMask := full_act_t + offlineRange_act_t + implicitRange_act_t + 
                cleanRange_act_t + incremental_act_t + createdatafile_act_t;
 
--
--
--
  setComputeRecoveryActionMasks(containerMask   => backupSet_con_t +
                                                   offlineRangeRec_con_t +
                                                   imageCopy_con_t,
                                actionMask      => actionMask,
                                allRecords      => TRUE#,
                                availableMask   => BSavailable,
                                fullBackups     => NULL);
 
--
--
  findControlfileBackup(FALSE, FALSE, TRUE, 0, 0);
 
  IF getRecStackCount <> 0 THEN
     rcvRecPop(rcvRec);
     cfcrescn := 0;
     cfcretime := rcvRec.cfCreationTime_con;
  END IF;
 
--
--
  j := to_number(null);
  LOOP
    IF (j is null) THEN
       j := dfRecTab.first;
    ELSE
       j := dfRecTab.next(j);
    END IF;
    EXIT WHEN j IS NULL;
    dfRec := dfRecTab(j);
 
--
--
    IF (dfRec.pluginSCN       = 0  AND 
        dfRec.foreignDbid     = 0  AND
        dfRec.pdbForeignDbid  = 0  AND
        dfRec.creation_thread > 0  AND
        dfRec.creation_size   > 0)   
    THEN
       canCreateDf := TRUE; 
    ELSE
       canCreateDf := FALSE;
    END IF;
    dfCreateSCN := dfRec.dfCreationSCN;
 
    dropScnExist := getDropSCN(dfRec.dfNumber, dfRec.dfCreationSCN, 
                               dfRec.dfCreationTime, dfRec.pluginSCN, 
                               dfRec.foreignDbid, dropScn, dropTime,
                               dropDbIncKey, dropRlgScn, dropRlgTime);
 
    IF (dropScnExist = TRUE) THEN
       deb(DEB_IN, 'Datafile belongs to tablespace# ' || 
                    to_char(dfRec.dfNumber) || 'which has a dropscn' ||
                    dropScn);
    END IF;
 
--
    rc := computeRecoveryActions(fno              => dfRec.dfNumber,
                                 crescn           => dfRec.dfCreationSCN,
                                 df_cretime       => dfRec.dfCreationTime,
                                 cf_scn           => cfcrescn,
                                 cf_cretime       => cfcretime,
                                 allowfuzzy       => FALSE,
                                 partial_rcv      => FALSE,
                                 allCopies        => FALSE,
                                 cleanscn         => dfRec.stopSCN,
                                 clean2scn        => highscnval,
                                 clean2time       => nowTime,
                                 onlscn           => dfRec.dfOnlineSCN,
                                 offlscn          => dfRec.dfOfflineSCN,
                                 onltime          => dfRec.dfOnlineTime,
                                 rmanCmd          => restoreCmd_t,
                                 foreignDbid      => dfRec.foreignDbid,
                                 pluggedRonly     => dfRec.pluggedRonly,
                                 pluginSCN        => dfRec.pluginSCN,
                                 pluginRlgSCN     => dfRec.pluginRlgSCN,
                                 pluginRlgTime    => dfRec.pluginRlgTime,
                                 creation_thread  => dfRec.creation_thread,
                                 creation_size    => dfRec.creation_size,
                                 pdbId            => dfRec.pdbId,
                                 pdbForeignDbid   => dfRec.pdbForeignDbid);
 
--
    deb(DEB_IN, 'Considering backups for the datafile ' 
                 ||to_char(dfRec.dfNumber));
        
--
--
--
--
    i := 0;
    WHILE i < logRangeCount LOOP
      isActnFound(i) := FALSE;
      i := i + 1;
    END LOOP;
 
--
    IF (rc = SUCCESS)
    THEN
      LOOP
          EXIT WHEN getRecStackCount = 0;
          rcvRecPop(rcvRec);
          dfBackupFound := FALSE#;
          offlnRngFound := FALSE#;
          dfCreation    := FALSE#;
--
          IF (rcvRec.type_act = full_act_t) THEN
--
             tmpScn := rcvRec.toSCN_act;
             tmpTime := rcvRec.toTime_act;
             tmpDbIncKey := rcvRec.dbincKey_act;
             tmpRlgScn   := rcvRec.rlgSCN_act;
             tmpRlgTime  := rcvRec.rlgTime_act;
             dfBackupFound := TRUE#;
--
          ELSIF (rcvRec.type_act = createdatafile_act_t) THEN
             dfCreation  := TRUE#;
             deb(DEB_IN, 'The df can be created');
--
          ELSIF (rcvRec.type_act = cleanRange_act_t) THEN
             deb(DEB_IN, 'A clean range found');
             lastBkupScn := tmpScn; 
             offlnRngFound := TRUE#; 
          END IF;
 
--
          IF (dfRec.dfNumber = 1 and dfBackupFound = TRUE#) THEN
             deb(DEB_IN, 'backup scn = ' || to_char(tmpScn));
--
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= tmpScn AND 
                    restoreRangeTab(i).highScn >= tmpScn AND 
                    isActnFound(i) = FALSE) THEN
--
--
                   restoreRangeTab(i).lowScn        := tmpScn;
                   restoreRangeTab(i).lowTime       := tmpTime;
                   restoreRangeTab(i).lowDbIncKey   := tmpDbIncKey;
                   restoreRangeTab(i).lowRlgScn     := tmpRlgScn;
                   restoreRangeTab(i).lowRlgTime    := tmpRlgTime;
                   restoreRangeTab(i).rcvStartScn   := tmpScn;
                   restoreRangeTab(i).rcvStartTime  := tmpTime;
                   isActnFound(i)          := TRUE;
                   restoreRangeTab(i).isValidRange  := TRUE;
                   deb(DEB_IN, 'backup belongs to ' || to_char(i+1) || 
                               '-th range' );
                END IF;
                i := i + 1;
             END LOOP;
 
--
--
          ELSIF (dfRec.dfNumber > 1 and dfBackupFound = TRUE#) THEN
             deb(DEB_IN, 'backup scn = ' || to_char(tmpScn));
--
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= tmpScn AND 
                    restoreRangeTab(i).highScn >= tmpScn AND 
                    restoreRangeTab(i).isValidRange = TRUE AND 
                    isActnFound(i) = FALSE) THEN
 
                   deb(DEB_IN, 'backup belongs to ' || to_char(i+1) ||
                               '-th range' );
                   isActnFound(i) := TRUE;
--
--
--
--
--
                   IF (tmpScn >= restoreRangeTab(i).lowScn AND
                       (NOT (canCreateDf    AND 
                             restoreRangeTab(i).startScn <= dfCreateSCN AND
                             restoreRangeTab(i).highScn  >= dfCreateSCN))) THEN
                      restoreRangeTab(i).lowScn := tmpScn;
                      restoreRangeTab(i).lowTime := tmpTime;
                      restoreRangeTab(i).lowDbIncKey   := tmpDbIncKey;
                      restoreRangeTab(i).lowRlgScn     := tmpRlgScn;
                      restoreRangeTab(i).lowRlgTime    := tmpRlgTime;
                      deb(DEB_IN, 'updating lowscn to ' || to_char(tmpScn));
                   ELSE
                      deb(DEB_IN, 'not updating lowscn');
                   END IF;
 
                   IF (tmpScn < restoreRangeTab(i).rcvStartScn) THEN
                      restoreRangeTab(i).rcvStartScn   := tmpScn;
                      restoreRangeTab(i).rcvStartTime  := tmpTime;
                      deb(DEB_IN, 'updating media rcv scn to ' || 
                                  to_char(tmpScn));
                   ELSE
                      deb(DEB_IN, 'not updating media rcv scn');
                   END IF;
                END IF;
               
--
--
--
--
--
--
 
                IF (canCreateDf  AND
                    restoreRangeTab(i).startScn <= dfCreateSCN AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE) THEN
                   deb(DEB_IN, 'creation scn belongs to ' || to_char(i+1) || 
                               '-th range. Marking the action to True');
                   isActnFound(i) := TRUE;
                   
                   IF (dfCreateSCN < restoreRangeTab(i).rcvStartScn AND
                       restoreRangeTab(i).highScn  >= dfCreateSCN) THEN
                      restoreRangeTab(i).rcvStartScn   := dfCreateSCN;
                      restoreRangeTab(i).rcvStartTime  := dfRec.dfCreationTime;
                      deb(DEB_IN, 'updating media rcv scn to DF createscn ' || 
                                  to_char(dfCreateSCN));
                   END IF;
                ELSIF ( NOT canCreateDf AND 
                        restoreRangeTab(i).highScn <  dfCreateSCN AND
                        restoreRangeTab(i).isValidRange = TRUE AND
                        isActnFound(i) = FALSE) THEN
                   deb(DEB_IN, 'Df non-creatable. Restore range highscn '||
                               restoreRangeTab(i).highScn || ' less than df' ||
                               'creation scn ' || dfCreateSCN || '.Marking ' ||
                               to_char(i+1) || '-th range to true');
                   isActnFound(i) := TRUE;
                END IF;
                i := i + 1;
             END LOOP;
 
--
--
          ELSIF (dfCreation = TRUE#) THEN
             tmpScn  := dfRec.dfCreationSCN;
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= tmpScn AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE) THEN
 
                   deb(DEB_IN, 'creation scn belongs to ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
 
                END IF;
                i := i + 1;
             END LOOP;
 
--
--
--
          ELSIF (dfRec.dfNumber > 1 and offlnRngFound = TRUE#) THEN
             deb(DEB_IN, 'offline range from scn = ' || 
                         to_char(rcvRec.fromSCN_act) ||
                         'to scn = ' || to_char(rcvRec.toSCN_act));
--
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= rcvRec.toSCN_act AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE AND
                    rcvRec.fromSCN_act <= lastBkupScn) THEN
 
                   deb(DEB_IN, 'offline range belongs to ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
 
                END IF;
                i := i + 1;
             END LOOP;
          END IF;
 
--
          IF (dropScnExist = TRUE) THEN
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn >= dropScn AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE) THEN
 
                   deb(DEB_IN, 'file has been dropped before ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
 
                ELSIF (restoreRangeTab(i).startScn < dropScn AND
                       restoreRangeTab(i).highScn > dropScn AND
                       restoreRangeTab(i).isValidRange = TRUE AND
                       isActnFound(i) = FALSE) THEN
                   deb(DEB_IN, 'file has been dropped in ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
                   restoreRangeTab(i).lowScn        := dropScn; 
                   restoreRangeTab(i).lowTime       := dropTime;
                   restoreRangeTab(i).lowDbIncKey   := dropDbIncKey;
                   restoreRangeTab(i).lowRlgScn     := dropRlgScn;
                   restoreRangeTab(i).lowRlgTime    := dropRlgTime;
                   deb(DEB_IN, 'updating media low scn to ' || dropScn);
                END IF;
                i := i + 1;
             END LOOP;
          END IF;
      END LOOP;
 
--
--
      i := 0;
      WHILE i < logRangeCount 
      LOOP
         IF (isActnFound(i) = FALSE) THEN
            restoreRangeTab(i).isValidRange := FALSE;
         END IF;
         i := i + 1;
      END LOOP;
 
--
--
    ELSE
      i := 0;
      WHILE i < logRangeCount LOOP
          restoreRangeTab(i).isValidRange := FALSE;
          i := i + 1;
      END LOOP;
      EXIT;
    END IF;
--
  END LOOP;
 
--
  findControlfileBackup(FALSE, TRUE, TRUE, 0, 0);
 
  IF (getBS_status = SUCCESS) THEN
  LOOP
     EXIT WHEN getRecStackCount = 0;
     rcvRecPop(rcvRec);
       
--
     tmpScn := rcvRec.toSCN_act;
     deb(DEB_IN, 'cf backup scn = ' || to_char(tmpScn));
 
--
     i := 0;
     WHILE i < logRangeCount
     LOOP
        IF (restoreRangeTab(i).startScn <= tmpScn AND
             restoreRangeTab(i).highScn >= tmpScn AND 
               restoreRangeTab(i).cfBkupFound = FALSE AND
                restoreRangeTab(i).isValidRange = TRUE) THEN
 
            deb(DEB_IN, 'cf backup belongs to ' || to_char(i+1) ||
                        '-th range' );
            restoreRangeTab(i).cfBkupFound := TRUE;
--
--
            IF (restoreRangeTab(i).lowScn < tmpScn) THEN
                restoreRangeTab(i).lowScn := tmpScn;
                deb(DEB_IN, 'updating lowscn to ' || to_char(tmpScn));
            END IF;
--
--
        END IF;
        i := i + 1;
     END LOOP;
  END LOOP;       
  END IF;
 
--
--
  i := 0;
  WHILE i < logRangeCount
  LOOP
     IF (restoreRangeTab(i).cfBkupFound = FALSE) THEN
        restoreRangeTab(i).isValidRange := FALSE;
     END IF;
     i := i + 1;
  END LOOP;
 
  resetLocalOrsSiteKey;
  deb(DEB_EXIT, 'with TRUE');
  RETURN TRUE;
 
EXCEPTION
  WHEN OTHERS THEN
    resetLocalOrsSiteKey;
    deb(DEB_EXIT, 'with FALSE');
    RETURN FALSE;
 
END getRestoreRangeSet;
 
--
PROCEDURE sv_setSessionKey(skey IN NUMBER) IS
BEGIN
   session_key := skey;
   deb(DEB_PRINT, 'Session Key Filter='|| session_key);
END;
FUNCTION sv_getSessionKey RETURN NUMBER IS
BEGIN
   return session_key;
END;
 
--
PROCEDURE sv_setSessionTimeRange(fromTime IN DATE, untilTime IN DATE) IS
BEGIN
  session_fromTime := fromTime;
  session_untilTime := untilTime;
  deb(DEB_PRINT, 'Session Time range Filter='||
                 to_char(session_fromTime, 'MM/DD/YYYY HH24:MI:SS')  ||
                 ' To ' ||
                 to_char(session_untilTime, 'MM/DD/YYYY HH24:MI:SS'));
END;
FUNCTION sv_getSessionfromTimeRange RETURN DATE IS
BEGIN
   return session_fromtime;
END;
FUNCTION sv_getSessionUntilTimeRange RETURN DATE IS
BEGIN
   return session_untilTime;
END;
 
--
PROCEDURE getRetentionPolicy(recovery_window OUT number
                            ,redundancy      OUT number)
IS
  conf_value             varchar2(512);
  conf_name              varchar2(512) := 'RETENTION POLICY';
  conf#                  binary_integer;
  l1                     binary_integer;
  l2                     binary_integer;
  l3                     binary_integer;
BEGIN
 
  deb(DEB_ENTER, 'getRetentionPolicy');
 
  recovery_window := 0;
  redundancy      := 1;
 
  IF (findConfig_c%ISOPEN) THEN
    CLOSE findConfig_c;
  END IF;
  OPEN findConfig_c(conf_name, conf_value, null);
  FETCH findConfig_c INTO conf#, conf_name, conf_value;
  IF (NOT findConfig_c%NOTFOUND) THEN
    IF (conf_value like '%RECOVERY WINDOW%')
    THEN
      l1 := length('TO RECOVERY WINDOW OF ');
      l2 := length(' DAYS');
      l3 := length(conf_value);
      recovery_window := to_number(substr(conf_value, l1, l3-l2-l1+1));
    END IF;
    IF (conf_value like '%REDUNDANCY%')
    THEN
      l1 := length('TO REDUNDANCY ');
      l2 := length(conf_value);
      redundancy := to_number(substr(conf_value, l1, l2-l1+1));
    END IF;
    IF (conf_value like '%NONE%')
    THEN
--
--
      redundancy := 0;
      recovery_window := 0;
    END IF;
  END IF;
  CLOSE findConfig_c;
 
  deb(DEB_IN, 'recovery window = '||recovery_window);
  deb(DEB_IN, 'redundancy      = '||redundancy);
 
  deb(DEB_EXIT, 'getRetentionPolicy');
 
END getRetentionPolicy;
 
--
PROCEDURE translateDataFileCopy(
   duplicates   IN number
  ,statusMask   IN binary_integer
  ,onlyrdf      IN binary_integer
  ,pluginSCN    IN number DEFAULT 0)
IS
BEGIN
   validateState(getDatafileCopyCursor);
 
--
--
--
--
   OPEN findDatafileBackup_c(
                         sourcemask   => imageCopy_con_t,
                         reset_scn    => this_reset_scn,
                         reset_time   => this_reset_time,
                         statusMask   => statusMask,
                         duplicates   => duplicates,
                         onlyrdf      => onlyrdf,
                         pluginSCN    => pluginSCN
                         );
 
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDataFileCopyNoRows.error      := NULL;
   getDataFileCopyNoRows.msg        := 'Datafile copy does not exists';
   getDataFileCopyDuplicates        := duplicates;
   getDataFileCopyLast.dfNumber_obj := NULL;
   getDataFileCopySingleRow         := FALSE;
END translateDataFileCopy;
 
--
--
--
PROCEDURE getDfBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,recentbackup    IN   boolean  DEFAULT FALSE
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof         boolean := FALSE;
   local       bhistoryRec_t;
   icount      number  := 0;
   locCreSCN   number;
   lastCreSCN  number;
   locRlgSCN   number;
   lastRlgSCN  number;
   locRlgTime  date;
   lastRlgTime date;
   locCkpSCN   number;
   lastCkpSCN  number;
BEGIN
   deb(DEB_ENTER, 'getDfBackupHistory');
 
   IF (first) THEN
      getLastBackupHistory.dfNumber := NULL;
      IF (dfBackupHistory_c2%ISOPEN) THEN
         CLOSE dfBackupHistory_c2;
      END IF;
      deb(DEB_OPEN, 'dfBackupHistory_c2');
      OPEN dfBackupHistory_c2(device_type => backedUpDev,
                              cmd         => doingCmd,
                              ktag        => keepTag,
                              pattern1    => startWithPattern(toDest1),
                              pattern2    => startWithPattern(toDest2),
                              pattern3    => startWithPattern(toDest3),
                              pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL AND
       (recentbackup OR
        getLastBackupHistory.ckp_scn = getLastBackupHistory.stop_scn)) THEN
--
      icount := 1;
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL) THEN
      deb(DEB_IN, 'with file# = ' || to_char(getLastBackupHistory.dfNumber) ||
                  ' icount= '     || to_char(icount) ||
                  ' ckp_scn= '    || to_char(getLastBackupHistory.ckp_scn) ||
                  ' compTime= '   || to_char(getLastBackupHistory.compTime,
                                            'DD-MON-RR HH24:MI:SS'));
   END IF;
 
   IF (NOT dfBackupHistory_c2%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
<<nextRow>>
   FETCH dfBackupHistory_c2 INTO local;
 
   IF (dfBackupHistory_c2%NOTFOUND) THEN
      CLOSE dfBackupHistory_c2;
      eof := TRUE;
   ELSE
      IF (local.pluginSCN != 0) THEN
         locCreSCN   := local.pluginSCN;
         locRlgSCN   := local.pluginRlgSCN;
         locRlgTime  := local.pluginRlgTime;
         lastCreSCN  := getLastBackupHistory.pluginSCN;
         lastRlgSCN  := getLastBackupHistory.pluginRlgSCN;
         lastRlgTime := getLastBackupHistory.pluginRlgTime;
      ELSE
         locCreSCN   := local.create_scn;
         locRlgSCN   := local.reset_scn;
         locRlgTime  := local.reset_time;
         lastCreSCN  := getLastBackupHistory.create_scn;
         lastRlgSCN  := getLastBackupHistory.reset_scn;
         lastRlgTime := getLastBackupHistory.reset_time;
      END IF;
 
      IF (local.pluggedRonly = 1) THEN
         locCkpSCN  := local.pluginSCN;
         lastCkpSCN := getLastBackupHistory.pluginSCN;
      ELSE
         locCkpSCN  := local.ckp_scn;
         lastCkpSCN := getLastBackupHistory.ckp_scn;
      END IF;
 
      IF (getLastBackupHistory.dfNumber IS NULL OR
          (getLastBackupHistory.dfNumber = local.dfNumber AND
           lastCreSCN                    = locCreSCN      AND
           lastRlgSCN                    = locRlgSCN      AND
           lastRlgTime                   = locRlgTime)) THEN
         IF (recentbackup) THEN
            IF (getLastBackupHistory.dfNumber IS NULL OR
                locCkpSCN = lastCkpSCN) THEN
--
               icount := icount + 1;
            END IF;
         ELSIF (local.ckp_scn = local.stop_scn OR local.pluggedRonly = 1) THEN
--
--
            icount := icount + 1;          -- bump the number of copies
         END IF;
 
         IF (getLastBackupHistory.dfNumber IS NULL) THEN
            getLastBackupHistory := local;     -- remember the recent backup
         END IF;
         deb(DEB_IN, 'with file# = ' || to_char(local.dfNumber) ||
                     ' icount= '     || to_char(icount) ||
                     ' ckp_scn= '    || to_char(local.ckp_scn) ||
                     ' compTime= '   || to_char(local.compTime,
                                               'DD-MON-RR HH24:MI:SS'));
         goto nextRow;
      END IF;
   END IF;
 
--
--
 
<<lastRow>>
   IF (eof AND getLastBackupHistory.dfNumber IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec             := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.dfNumber := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT, 'with file# = ' || to_char(bhistoryRec.dfNumber) ||
                 ' nbackups= '   || to_char(bhistoryRec.nbackups) ||
                 ' ckp_scn= '    || to_char(bhistoryRec.ckp_scn) ||
                 ' compTime= '   || to_char(bhistoryRec.compTime,
                                           'DD-MON-RR HH24:MI:SS'));
END getDfBackupHistory;
 
PROCEDURE getDcBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof         boolean := FALSE;
   local       bhistoryRec_t;
   icount      number  := 0;
   locCreSCN   number;
   lastCreSCN  number;
   locRlgSCN   number;
   lastRlgSCN  number;
   locRlgTime  date;
   lastRlgTime date;
   locCkpSCN   number;
   lastCkpSCN  number;
BEGIN
   deb(DEB_ENTER, 'getDcBackupHistory');
 
   IF (first) THEN
      getLastBackupHistory.dfNumber := NULL;
      IF (dcBackupHistory_c%ISOPEN) THEN
         CLOSE dcBackupHistory_c;
      END IF;
      deb(DEB_OPEN, 'dcBackupHistory_c');
      OPEN dcBackupHistory_c(device_type => backedUpDev,
                             cmd         => doingCmd,
                             ktag        => keepTag,
                             pattern1    => startWithPattern(toDest1),
                             pattern2    => startWithPattern(toDest2),
                             pattern3    => startWithPattern(toDest3),
                             pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL AND
       getLastBackupHistory.ckp_scn = getLastBackupHistory.stop_scn) THEN
      icount := 1;
   END IF;
 
   IF (NOT dcBackupHistory_c%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL) THEN
      deb(DEB_IN, 'with file# = ' || to_char(getLastBackupHistory.dfNumber) ||
                  ' create_scn= ' || to_char(getLastBackupHistory.create_scn) ||
                  ' reset_scn= '  || to_char(getLastBackupHistory.reset_scn) ||
                  ' reset_time= ' || to_char(getLastBackupHistory.reset_time,
                                            'DD-MON-RR HH24:MI:SS') ||
                  ' ckp_scn= '    || to_char(getLastBackupHistory.ckp_scn) ||
                  ' stop_scn= '   || to_char(getLastBackupHistory.stop_scn) ||
                  ' nbackups= '   || to_char(getLastBackupHistory.nbackups) ||
                  ' compTime= '   || to_char(getLastBackupHistory.compTime,
                                            'DD-MON-RR HH24:MI:SS'));
   END IF;
 
<<nextRow>>
   FETCH dcBackupHistory_c INTO local;
 
   IF (dcBackupHistory_c%NOTFOUND) THEN
      CLOSE dcBackupHistory_c;
      eof := TRUE;
   ELSE
      IF (local.pluginSCN != 0) THEN
         locCreSCN   := local.pluginSCN;
         locRlgSCN   := local.pluginRlgSCN;
         locRlgTime  := local.pluginRlgTime;
         lastCreSCN  := getLastBackupHistory.pluginSCN;
         lastRlgSCN  := getLastBackupHistory.pluginRlgSCN;
         lastRlgTime := getLastBackupHistory.pluginRlgTime;
      ELSE
         locCreSCN   := local.create_scn;
         locRlgSCN   := local.reset_scn;
         locRlgTime  := local.reset_time;
         lastCreSCN  := getLastBackupHistory.create_scn;
         lastRlgSCN  := getLastBackupHistory.reset_scn;
         lastRlgTime := getLastBackupHistory.reset_time;
      END IF;
 
      IF (getLastBackupHistory.dfNumber IS NULL OR
          (getLastBackupHistory.dfNumber     = local.dfNumber     AND
           lastCreSCN                        = locCreSCN          AND
           getLastBackupHistory.ckp_scn      = local.ckp_scn      AND
           getLastBackupHistory.ckp_time     = local.ckp_time     AND
           getLastBackupHistory.pluggedRonly = local.pluggedRonly AND
           lastRlgSCN                        = locRlgSCN          AND
           lastRlgTime                       = locRlgTime)) THEN
         IF (local.ckp_scn = local.stop_scn OR local.pluggedRonly = 1) THEN
--
            icount  := icount + 1;          -- bump the number of copies
         END IF;
         getLastBackupHistory := local;     -- remember the last copy
 
         deb(DEB_IN, 'with file# = ' || to_char(local.dfNumber) ||
                     ' create_scn= ' || to_char(local.create_scn) ||
                     ' reset_scn= '  || to_char(local.reset_scn) ||
                     ' reset_time= ' || to_char(local.reset_time,
                                               'DD-MON-RR HH24:MI:SS') ||
                     ' ckp_scn= '    || to_char(local.ckp_scn) ||
                     ' stop_scn= '   || to_char(local.stop_scn) ||
                     ' nbackups= '   || to_char(local.nbackups) ||
                     ' compTime= '   || to_char(local.compTime,
                                               'DD-MON-RR HH24:MI:SS'));
         goto nextRow;
      END IF;
   END IF;
 
--
--
 
<<lastRow>>
   IF (eof AND getLastBackupHistory.dfNumber IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec             := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.dfNumber := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT, 'with file# = ' || to_char(bhistoryRec.dfNumber) ||
                 ' create_scn= ' || to_char(bhistoryRec.create_scn) ||
                 ' reset_scn= '  || to_char(bhistoryRec.reset_scn) ||
                 ' reset_time= ' || to_char(bhistoryRec.reset_time,
                                           'DD-MON-RR HH24:MI:SS') ||
                 ' ckp_scn= '    || to_char(bhistoryRec.ckp_scn) ||
                 ' stop_scn= '   || to_char(bhistoryRec.stop_scn) ||
                 ' nbackups= '   || to_char(bhistoryRec.nbackups) ||
                 ' compTime= '   || to_char(bhistoryRec.compTime,
                                           'DD-MON-RR HH24:MI:SS'));
END getDcBackupHistory;
 
PROCEDURE getAlBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof       boolean := FALSE;
   local     bhistoryRec_t;
   icount    number  := 0;
BEGIN
   deb(DEB_ENTER, 'getAlBackupHistory');
 
   IF (first) THEN
      getLastBackupHistory.logThread := NULL;
      IF (alBackupHistory_c2%ISOPEN) THEN
         CLOSE alBackupHistory_c2;
      END IF;
      deb(DEB_OPEN, 'alBackupHistory_c2');
      OPEN alBackupHistory_c2(device_type => backedUpDev,
                              cmd         => doingCmd,
                              ktag        => keepTag,
                              pattern1    => startWithPattern(toDest1),
                              pattern2    => startWithPattern(toDest2),
                              pattern3    => startWithPattern(toDest3),
                              pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.logThread IS NOT NULL) THEN
      icount := 1;
   END IF;
 
   IF (NOT alBackupHistory_c2%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
<<nextRow>>
   FETCH alBackupHistory_c2 INTO local;
 
   IF (alBackupHistory_c2%NOTFOUND) THEN
      CLOSE alBackupHistory_c2;
      eof := TRUE;
   ELSIF (getLastBackupHistory.logThread IS NULL OR
          (getLastBackupHistory.logThread = local.logThread AND
           getLastBackupHistory.logSequence = local.logSequence AND
           getLastBackupHistory.logTerminal = local.logTerminal AND
           getLastBackupHistory.next_scn = local.next_scn AND
           getLastBackupHistory.reset_scn = local.reset_scn AND
           getLastBackupHistory.reset_time = local.reset_time)) THEN
      icount  := icount + 1;             -- bump the number of copies
      getLastBackupHistory := local;     -- remember the last copy
 
      deb(DEB_IN,
            'with (reset_scn, reset_time, thread#, sequence#, terminal)=(' ||
            to_char(local.reset_scn)  || ',' ||
            to_char(local.reset_time,'DD-MON-RR HH24:MI:SS')  || ',' ||
            to_char(local.logThread)  || ',' ||
            to_char(local.logSequence) || ',' ||
            to_char(local.logTerminal) || ')' ||
            ' nbackups= ' || local.nbackups||
            ' compTime= '   || to_char(local.compTime,
                                       'DD-MON-RR HH24:MI:SS'));
      goto nextRow;
   END IF;
 
--
--
 
<<lastRow>>
   IF (eof AND getLastBackupHistory.logThread IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.logThread := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT,
            'with (reset_scn, reset_time, thread#, sequence#, terminal)=(' ||
            to_char(bhistoryRec.reset_scn)  || ',' ||
            to_char(bhistoryRec.reset_time,'DD-MON-RR HH24:MI:SS')  || ',' ||
            to_char(bhistoryRec.logThread)  || ',' ||
            to_char(bhistoryRec.logSequence) || ',' ||
            to_char(bhistoryRec.logTerminal) || ')' ||
            ' nbackups= ' || bhistoryRec.nbackups||
            ' compTime= '   || to_char(bhistoryRec.compTime, 
                                       'DD-MON-RR HH24:MI:SS'));
END getAlBackupHistory;
 
PROCEDURE getBsBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,set_stamp       IN   number  DEFAULT NULL
  ,set_count       IN   number  DEFAULT NULL
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof       boolean := FALSE;
   local     bhistoryRec_t;
   icount    number  := 0;
   bpRec     bpRec_t;
BEGIN
   deb(DEB_ENTER, 'getBsBackupHistory');
 
   IF (set_stamp IS NOT NULL AND set_count IS NOT NULL) THEN
      IF (NOT first) THEN
         deb(DEB_EXIT, 'with: no_data_found');
         RAISE no_data_found;
      END IF;
 
      bpRec.setStamp := set_stamp;
      bpRec.setCount := set_count;
      getBackupHistory(bpRec            => bpRec,
                       backedUpDev      => backedUpDev,
                       nbackupsFlag     => 1,
                       bscompletionFlag => 1,
                       nbackups         => bhistoryRec.nbackups,
                       bscompletion     => bhistoryRec.compTime,
                       todest1          => toDest1,
                       todest2          => toDest2,
                       todest3          => todest3,
                       todest4          => todest4);
 
      IF (bhistoryRec.nbackups = 0) THEN
         deb(DEB_EXIT, 'with: no_data_found');
         RAISE no_data_found;
      END IF;
 
      bhistoryRec.setStamp := set_stamp;
      bhistoryRec.setCount := set_count;
      deb(DEB_EXIT, 'with set_stamp = ' || to_char(bhistoryRec.setStamp) ||
                    ' set_count = ' || to_char(bhistoryRec.setCount) ||
                    ' nbackups= '  || to_char(bhistoryRec.nbackups)  ||
                    ' compTime= '  || to_char(bhistoryRec.compTime,
                                              'DD-MON-RR HH24:MI:SS'));
      RETURN;
   END IF;
 
   IF (first) THEN
      getLastBackupHistory.setStamp := NULL;
      IF (bsBackupHistory_c2%ISOPEN) THEN
         CLOSE bsBackupHistory_c2;
      END IF;
      deb(DEB_OPEN, 'bsBackupHistory_c2');
      OPEN bsBackupHistory_c2(device_type => backedUpDev,
                              cmd         => doingCmd,
                              ktag        => keepTag,
                              pattern1    => startWithPattern(toDest1),
                              pattern2    => startWithPattern(toDest2),
                              pattern3    => startWithPattern(toDest3),
                              pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.setStamp IS NOT NULL) THEN
      icount := 1;
   END IF;
 
   IF (NOT bsBackupHistory_c2%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
<<nextRow>>
   FETCH bsBackupHistory_c2 INTO local;
 
   IF (bsBackupHistory_c2%NOTFOUND) THEN
      CLOSE bsBackupHistory_c2;
      eof := TRUE;
   ELSIF (getLastBackupHistory.setStamp IS NULL OR
          (getLastBackupHistory.setStamp = local.setStamp AND
           getLastBackupHistory.setCount = local.setCount)) THEN
      icount := icount + 1;           -- bump the number of copies
      getLastBackupHistory := local;  -- remember the last copy
      goto nextRow;
   END IF;
 
--
--
<<lastRow>>
   IF (eof AND getLastBackupHistory.setStamp IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.setStamp := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT, 'with set_stamp = ' || to_char(bhistoryRec.setStamp) ||
                 'set_count = ' || to_char(bhistoryRec.setCount) ||
                 ' nbackups= '  || to_char(bhistoryRec.nbackups)  ||
                 ' compTime= '  || to_char(bhistoryRec.compTime,
                                           'DD-MON-RR HH24:MI:SS'));
END getBsBackupHistory;
 
--
--
 
PROCEDURE getBackupHistory(
   dfRec            IN  dfRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date)
IS
   local bhistoryRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupHistory');
 
   nbackups := 0;
   bscompletion := NULL;
 
--
   IF ((nbackupsFlag != 1  OR backedUpDev IS NULL) AND
       bscompletionFlag != 1) THEN
      deb(DEB_EXIT, 'with not interested');
      RETURN;
   END IF;
 
   IF (dfBackupHistory_c1%ISOPEN) THEN
      CLOSE dfBackupHistory_c1;
   END IF;
 
   OPEN dfBackupHistory_c1(file#        => dfRec.dfNumber
                          ,crescn       => dfRec.dfCreationSCN
                          ,device_type  => backedUpDev);
<<nextRow>>
   FETCH dfBackupHistory_c1 INTO local;
   IF (dfBackupHistory_c1%NOTFOUND) THEN
      CLOSE dfBackupHistory_c1;
   ELSE
      IF (local.reset_scn  = this_reset_scn AND
          local.reset_time = this_reset_time AND
          local.ckp_scn = dfRec.stopSCN) THEN
         nbackups := nbackups + 1;
      END IF;
      bscompletion := local.compTime;
      goto nextRow;
   END IF;
   deb(DEB_EXIT);
END getBackupHistory;
 
--
--
 
PROCEDURE getBackupHistory(
   alRec            IN  alRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date)
IS
   local bhistoryRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupHistory');
 
   nbackups := 0;
   bscompletion := NULL;
 
--
   IF ((nbackupsFlag != 1  OR backedUpDev IS NULL) AND
       bscompletionFlag != 1) THEN
      deb(DEB_EXIT, 'with not interested');
      RETURN;
   END IF;
 
   IF (alBackupHistory_c1%ISOPEN) THEN
      CLOSE alBackupHistory_c1;
   END IF;
 
   OPEN alBackupHistory_c1(thread#      => alRec.thread
                          ,sequence#    => alRec.sequence
                          ,device_type  => backedUpDev);
<<nextRow>>
   FETCH alBackupHistory_c1 INTO local;
   IF (alBackupHistory_c1%NOTFOUND) THEN
      CLOSE alBackupHistory_c1;
   ELSE
      nbackups := nbackups + 1;
      bscompletion := local.compTime;
      goto nextRow;
   END IF;
 
   deb(DEB_EXIT);
END getBackupHistory;
 
--
PROCEDURE getBackupHistory(
   bpRec            IN  bpRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date
  ,todest1          IN  varchar2 DEFAULT NULL
  ,todest2          IN  varchar2 DEFAULT NULL
  ,todest3          IN  varchar2 DEFAULT NULL
  ,todest4          IN  varchar2 DEFAULT NULL)
IS
   local bhistoryRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupHistory');
 
   nbackups := 0;
   bscompletion := NULL;
 
--
   IF ((nbackupsFlag != 1  OR backedUpDev IS NULL) AND
       bscompletionFlag != 1) THEN
      deb(DEB_EXIT, 'with not interested');
      RETURN;
   END IF;
 
   IF (bsBackupHistory_c1%ISOPEN) THEN
      CLOSE bsBackupHistory_c1;
   END IF;
 
   OPEN bsBackupHistory_c1(set_stamp    => bpRec.setStamp
                          ,set_count    => bpRec.setCount
                          ,device_type  => backedUpDev
                          ,pattern1     => startWithPattern(toDest1)
                          ,pattern2     => startWithPattern(toDest2)
                          ,pattern3     => startWithPattern(toDest3)
                          ,pattern4     => startWithPattern(toDest4));
<<nextRow>>
   FETCH bsBackupHistory_c1 INTO local;
   IF (bsBackupHistory_c1%NOTFOUND) THEN
      CLOSE bsBackupHistory_c1;
   ELSE
      nbackups := nbackups + 1;
      bscompletion := local.compTime;
      goto nextRow;
   END IF;
 
   deb(DEB_EXIT);
END getBackupHistory;
 
--
--
--
--
PROCEDURE findControlfileBackup(
   allCopies      IN boolean default FALSE,
   allBackups     IN boolean default FALSE,
   allIncarnation IN boolean default FALSE,
   fromSCN        IN number  default 0,
   pdbId          IN number  default 0)
IS
   cfrec        rcvRec_t;
   tag          varchar2(32);
   valRC        binary_integer;
   validateRec  validBackupSetRec_t;
   currentInc   number;
   cfUntilScn   number;
   cfRlgScn     number;
BEGIN
   deb(DEB_ENTER, 'findControlfileBackup');
   validateState(null);
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   IF onlyStandby IS NULL THEN
      deb(DEB_IN, 'onlyStandby is set to NULL ');
   ELSIF onlyStandby = TRUE# THEN
      deb(DEB_IN, 'onlyStandby is set to TRUE ');
   ELSE
      deb(DEB_IN, 'onlyStandby is set to FALSE ');
   END IF;
 
   cfUntilScn := get_cfUntilScn();
   deb(DEB_IN, 'cfUntilScn = ' || nvl(to_char(cfUntilScn), 'NULL'));
 
   IF (allIncarnations = TRUE#) THEN
      deb(DEB_IN, 'allIncarnations = TRUE# ');
      currentInc := FALSE#;                       -- don't care about dbinc_key
      cfRlgScn   := getPointInTimeInc(cfUntilScn);
   ELSE
      deb(DEB_IN, 'allIncarnations <> TRUE# ');
      currentInc := TRUE#;
      cfRlgScn   := this_reset_scn;
   END IF;
   deb(DEB_IN, 'cfRlgScn= ' || nvl(to_char(cfRlgScn), 'NULL'));
 
--
   OPEN findControlfileBackup_c(sourcemask         => restoreSource,
                                currentIncarnation => currentInc,
                                tag                => restoreTag,
                                untilSCN           => cfUntilScn,
                                statusMask         => BSavailable,
                                needstby           => onlyStandby,
                                fromSCN            => fromSCN);
 
--
--
--
   findControlfileBackupCursor := TRUE;
 
--
   resetthisBackupAge;
   getBS_status := NULL;
 
   resetrcvRecStack;
 
   LOOP
      valRC := NULL;
 
      FETCH findControlfileBackup_c
         INTO cfrec;
 
      EXIT WHEN findControlfileBackup_c%NOTFOUND ;
 
      IF (cfrec.type_con = imageCopy_con_t) THEN
         deb(DEB_IN, 'findControlfileBackup found a controlfilecopy:');
         IF (diskDevice) THEN
            valRC := SUCCESS;
         ELSE
            valRC := AVAILABLE;
         END IF;
      ELSIF (cfrec.type_con = backupSet_con_t) THEN
         deb(DEB_IN, 'findControlfileBackup found a controlfile backup:');
         valRC := validateBackupSet(
            backupSetRec           => cfrec,
            tag                    => restoreTag,
            tagMatchRequired       => TRUE,
            checkDeviceIsAllocated => TRUE,
            availableMask          => BSavailable,
            validRec               => validateRec);
      ELSIF (cfrec.type_con = proxyCopy_con_t) THEN
         deb(DEB_IN, 'findControlfileBackup found a controlfile proxy copy:');
         IF (restoreTag is not NULL AND cfrec.tag_con != restoreTag) THEN
--
--
--
            deb(DEB_IN, 'tag does not match');
            valRC := UNAVAILABLE;
         ELSIF (anyDevice = TRUE# OR
                isDeviceTypeAllocated(cfrec.deviceType_con) = TRUE#) THEN
            valRC := SUCCESS;
         ELSE
            valRC := AVAILABLE;
         END IF;
      END IF;
 
--
--
--
--
      IF (cfRlgScn != cfrec.rlgSCN_act AND valRC IS NOT NULL) THEN
         deb(DEB_IN, 'rlgSCN_act= ' || nvl(to_char(cfrec.rlgSCN_act), 'NULL'));
         valRC := NULL;
         IF (cfRlgScn > cfrec.rlgSCN_act AND cfRlgScn > cfrec.toSCN_act) THEN
            deb(DEB_IN, 'findControlfileBackup belongs to parent incarnation');
            EXIT;
         ELSE
            deb(DEB_IN, 'findControlfileBackup belongs to orphan incarnation');
         END IF;
      END IF;
 
--
      IF (valRC IS NOT NULL AND pdbId > 1) THEN
         IF (isPdbScnOrphan(0, cfrec.toSCN_act, 0, pdbId)) THEN
            deb(DEB_IN, 'findControlfileBackup in orphan pdb sub inc');
            valRC := NULL;
         END IF;
      END IF;
 
   <<addAnother>>
      IF (getBS_status IS NULL AND valRC = AVAILABLE) THEN
         getBS_status := valRC;
      END IF;
 
      IF (debug) THEN
         printRcvRec(cfrec);
      END IF;
 
      IF (valRC = SUCCESS) THEN
         IF (thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
            thisBackupAge  := thisBackupAge + 1;
         ELSE
            deb(DEB_IN, ' Added cfrec:');
 
            IF (cfrec.type_con = backupSet_con_t) THEN
               cfrec.tag_con        := validateRec.tag;
               cfrec.deviceType_con := validateRec.deviceType;
               cfrec.copyNumber_con := validateRec.copyNumber;
            END IF;
 
            rcvRecPush(cfrec);     -- add record for this action
 
            getBS_status := SUCCESS;
 
            IF (allCopies and cfrec.type_con = backupSet_con_t) THEN
--
--
--
               valRC := validateBackupSet0(
                                      tag                    => restoreTag,
                                      tagMatchRequired       => TRUE,
                                      checkDeviceIsAllocated => TRUE,
                                      validRec               => validateRec);
               IF (valRC = SUCCESS) THEN
                  GOTO addAnother;
               END IF;
            END IF;
            IF (allBackups = FALSE) THEN
                EXIT;
            END IF;
         END IF;
      END IF;
   END LOOP;
 
   CLOSE findControlfileBackup_c;
 
   IF (getBS_status = SUCCESS) THEN
      deb(DEB_EXIT, 'with: SUCCESS');
   ELSIF (getBS_status = AVAILABLE) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
   ELSE
      getBS_status := UNAVAILABLE;
      deb(DEB_EXIT, 'with: UNAVAILABLE');
   END IF;
END findControlfileBackup;
 
--
FUNCTION getControlfileBackup(
   rcvRec  OUT NOCOPY rcvRec_t)
RETURN number IS
   local        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getControlfileBackupBackup');
 
   IF (NOT findControlfileBackupCursor) THEN
--
      findControlfileBackup(FALSE, FALSE, FALSE);
      findControlfileBackupCursor := FALSE;
   END IF;
 
   IF (getRecStackCount = 0) THEN
      IF (getBS_status = SUCCESS) THEN
         deb(DEB_EXIT, 'with no more records');
         raise no_data_found;
      ELSIF (getBS_status = AVAILABLE) THEN
         deb(DEB_EXIT, 'with: AVAILABLE');
         RETURN AVAILABLE;
      ELSE
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN UNAVAILABLE;
      END IF;
   END IF;
 
   rcvRecPop(local);
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   deb(DEB_EXIT, 'with: SUCCESS');
   RETURN SUCCESS;
END getControlfileBackup;
 
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE findRangeArchivedLogBackup(
   minthread    IN number
  ,minsequence  IN number
  ,minlowSCN    IN number
  ,maxthread    IN number
  ,maxsequence  IN number
  ,maxlowSCN    IN number
  ,allCopies    IN boolean default FALSE)
IS
   lastrec      rcvRec_t;
   brlrec       rcvRec_t;
   validateRec  validBackupSetRec_t;
   tapebkp      rcvRecTabI_t;-- stack of tape backups
   valRC        number;
   BSstatus     number;      -- status of current backup
   skipped      boolean;
   FUNCTION dupbs(bs1 in rcvRec_t, bs2 in rcvRec_t)
      RETURN BOOLEAN IS
   BEGIN
      IF (bs1.type_con != backupSet_con_t OR
          bs2.type_con != backupSet_con_t) THEN
         RETURN FALSE;
      END IF;
 
      IF (bs1.setStamp_con != bs2.setStamp_con OR
          bs1.setCount_con != bs2.setCount_con) THEN
         RETURN FALSE;
      END IF;
 
      RETURN TRUE;
   END dupbs;
 
   FUNCTION pushTapeBackup(tapebkp in rcvRecTabI_t)
      RETURN BOOLEAN IS
      found boolean := FALSE;
   BEGIN
      deb(DEB_IN, 'looking for tape backups');
      FOR i IN 1..tapebkp.count LOOP
--
         EXIT when (found AND NOT dupbs(tapebkp(i), tapebkp(i-1)));
         IF (thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
--
            IF (i = 1 OR NOT dupbs(tapebkp(i), tapebkp(i-1))) THEN
               thisBackupAge  := thisBackupAge + 1;
            END IF;
         ELSE
            deb(DEB_IN, 'Added tape backup ' || i);
            rcvRecPush(tapebkp(i));
            found := TRUE;
         END IF;
      END LOOP;
      RETURN found;
   END pushTapeBackup;
BEGIN
   deb(DEB_ENTER, 'findRangeArchivedLogBackup');
 
   validateState(null);
   lastrec.logThread_obj := 0;
 
--
--
--
   deb(DEB_OPEN, 'findRangeArcLogBackup');
   OPEN findRangeArcLogBackup(sourcemask         => to_number(null),
                              minthread          => minthread,
                              minsequence        => minsequence,
                              minlowSCN          => minlowSCN,
                              maxthread          => maxthread,
                              maxsequence        => maxsequence,
                              maxlowSCN          => maxlowSCN);
 
 
   resetrcvRecStack;
   tapebkp.delete;
   BSstatus := NULL;
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   LOOP
   <<nextbrlRec>>
      valRC := NULL;
 
      FETCH findRangeArcLogBackup
       INTO brlrec;
 
      IF (findRangeArcLogBackup%NOTFOUND) THEN
--
--
--
         IF (BSstatus IS NULL OR BSstatus != SUCCESS) THEN
            IF (pushTapeBackup(tapebkp)) THEN
               BSstatus := SUCCESS;
            END IF;
         END IF;
 
--
--
         IF (BSstatus = AVAILABLE AND lastrec.logThread_obj != 0) THEN
            deb(DEB_IN, ' Added lastlrec:');
--
--
--
            lastrec.status_con := '*';
            rcvRecPush(lastrec);
         END IF;
         EXIT;
      END IF;
 
--
--
      IF (brlrec.logSequence_obj != lastrec.logSequence_obj OR
          brlrec.logThread_obj   != lastrec.logThread_obj   OR
          brlrec.logRlgSCN_obj   != lastrec.logRlgSCN_obj   OR
          brlrec.logRlgTime_obj  != lastrec.logRlgTime_obj  OR
          brlrec.logLowSCN_obj   != lastrec.logLowSCN_obj   OR
          brlrec.logNextSCN_obj   != lastrec.logNextSCN_obj) THEN
--
--
--
         IF (BSstatus IS NULL OR BSstatus != SUCCESS) THEN
            IF (pushTapeBackup(tapebkp)) THEN
               BSstatus := SUCCESS;
            END IF;
         END IF;
 
         resetthisBackupAge;            -- init stack, age, status variables
         tapebkp.delete;
         IF (BSstatus = AVAILABLE) THEN
--
--
--
            deb(DEB_IN, ' Added lastlrec:');
            lastrec.status_con := '*';
            rcvRecPush(lastrec);
         END IF;
         BSstatus := NULL;              -- reset backup status for next record
 
--
         IF NOT isTranslatedArchivedLog(
                   thread#   => brlrec.logThread_obj
                  ,sequence# => brlrec.logSequence_obj) THEN
            deb(DEB_IN, 'skip not translated brlrec' ||
                ' thread=' || brlrec.logThread_obj ||
                ' sequence=' || brlrec.logSequence_obj);
            goto nextbrlRec;
         END IF;
 
--
--
         lastrec := brlrec;
         deb(DEB_IN, 'looking backups for' ||
             ' thread=' || brlrec.logThread_obj ||
             ' sequence=' || brlrec.logSequence_obj);
      END IF;
 
      IF (BSstatus = SUCCESS) THEN
         deb(DEB_IN, 'skip already stacked brlrec' ||
             ' thread=' || brlrec.logThread_obj ||
             ' sequence=' || brlrec.logSequence_obj);
         goto nextbrlRec;
      END IF;
 
      IF (brlrec.type_con = backupSet_con_t) THEN
         deb(DEB_IN, 'found a backupset:');
         valRC :=
           validateBackupSet(backupSetRec           => brlrec,
                             checkDeviceIsAllocated => TRUE,
                             tag                    => restoreTag,
                             tagMatchRequired       => TRUE,
                             availableMask          => BSavailable,
                             validRec               => validateRec);
      ELSIF (brlrec.type_con = proxyCopy_con_t) THEN
         deb(DEB_IN, 'found a proxy copy:');
         IF (restoreTag is not NULL AND brlrec.tag_con != restoreTag) THEN
--
--
--
            deb(DEB_EXIT, 'tag does not match');
            valRC := UNAVAILABLE;
         ELSIF (anyDevice = TRUE# OR
                isDeviceTypeAllocated(brlrec.deviceType_con) = TRUE#) THEN
            valRC := SUCCESS;
         ELSE
            valRC := AVAILABLE;
         END IF;
      END IF;
 
      skipped := FALSE;
 
   <<addAnother>>
      IF (BSstatus IS NULL AND valRC = AVAILABLE) THEN
         BSstatus := valRC;
      END IF;
 
      IF (debug) THEN
         printRcvRec(brlrec);
      END IF;
 
      IF (valRC = SUCCESS) THEN
         IF (brlrec.type_con = backupSet_con_t) THEN
            brlrec.tag_con        := validateRec.tag;
            brlrec.deviceType_con := validateRec.deviceType;
            brlrec.copyNumber_con := validateRec.copyNumber;
         END IF;
 
--
--
--
--
         IF (NOT skipped AND
             brlrec.deviceType_con = 'DISK' AND
             thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
--
--
            skipped := TRUE;
            thisBackupAge  := thisBackupAge + 1;
         ELSE
            IF (brlrec.deviceType_con = 'DISK') THEN
               IF (NOT skipped) THEN
                  deb(DEB_IN, ' Added brlrec:');
                  rcvRecPush(brlrec);     -- add record for this action
                  BSstatus := SUCCESS;
               END IF;
            ELSE
--
               deb(DEB_IN, ' Added brlrec to tapebkp stack:' ||
                           to_char(tapebkp.count+1));
               tapebkp(tapebkp.count+1) := brlrec;
            END IF;
         END IF;
 
         IF (allCopies AND brlrec.type_con = backupSet_con_t) THEN
--
--
--
            valRC := validateBackupSet0(
                                  tag                    => restoreTag,
                                  tagMatchRequired       => TRUE,
                                  checkDeviceIsAllocated => TRUE,
                                  validRec               => validateRec);
            IF (valRC = SUCCESS) THEN
               GOTO addAnother;
            END IF;
         END IF;
      END IF;
   END LOOP;
 
   CLOSE findRangeArcLogBackup;
 
   deb(DEB_EXIT);
END findRangeArchivedLogBackup;
 
--
--
PROCEDURE findArchivedLogBackup(
   thread    IN number
  ,sequence  IN number
  ,lowSCN    IN number
  ,allCopies IN boolean default FALSE)
IS
   local        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'findArchivedLogBackup');
 
--
   setArchivedLogRecord(thread#   => thread
                       ,sequence# => sequence
                       ,first     => TRUE);
 
--
--
--
   findRangeArchivedLogBackup(minthread   => thread,
                             minsequence => sequence,
                             minlowSCN   => lowSCN,
                             maxthread   => thread,
                             maxsequence => sequence,
                             maxlowSCN   => lowSCN,
                             allCopies   => allCopies);
   IF (getRecStackCount = 0) THEN
      getBS_status := NULL;
      deb(DEB_EXIT, 'with UNAVAILABLE');
   ELSE
      rcvRecTop(local);
--
--
      IF (local.status_con = '*') THEN
         getBS_status := AVAILABLE;
         resetrcvRecStack;
         deb(DEB_EXIT, 'with AVAILABLE');
      ELSE
         getBS_status := SUCCESS;
         deb(DEB_EXIT, 'with SUCCESS');
      END IF;
   END IF;
END findArchivedLogBackup;
 
--
--
FUNCTION getArchivedLogBackup(
   rcvRec  OUT NOCOPY rcvRec_t)
RETURN binary_integer IS
   local        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getArchivedLogBackup');
 
   IF (getRecStackCount = 0) THEN
      IF (getBS_status = SUCCESS) THEN
         deb(DEB_EXIT, 'with no more records');
         raise no_data_found;
      ELSIF (getBS_status = AVAILABLE) THEN
         deb(DEB_EXIT, 'with: AVAILABLE');
         RETURN AVAILABLE;
      ELSE
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN UNAVAILABLE;
      END IF;
   END IF;
 
   rcvRecPop(local);
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   deb(DEB_EXIT, 'with: SUCCESS');
   RETURN SUCCESS;
END getArchivedLogBackup;
 
--
--
--
 
--
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE         -- duplex copies
  ,redundancy IN number  default NULL          -- number of redundant copies
  ,rmanCmd    IN number  default unknownCmd_t) -- called for what rman command?
IS
  scn_warn number;
BEGIN
  findSpfileBackup(allCopies, redundancy, rmanCmd, scn_warn);
END findSpfileBackup;
 
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE         -- duplex copies
  ,redundancy IN number  default NULL          -- number of redundant copies
  ,rmanCmd    IN number  default unknownCmd_t  -- called for what rman command?
  ,scn_warn  OUT number)
IS
   bsfrec       rcvRec_t;
   tag          varchar2(32);
   valRC        binary_integer;
   validateRec  validBackupSetRec_t;
   lcopies      number;
   findtime     date;
   estimated    boolean := TRUE;
BEGIN
   deb(DEB_ENTER, 'findSpfileBackup');
   validateState(null);
 
--
   scn_warn := 0;
   IF (untilScn IS NOT NULL AND untilTime IS NULL) THEN
      computeSpfileTime(untilScn, findtime, allIncarnations, estimated);
      IF estimated THEN scn_warn := 1; END IF;
   ELSE
      findtime := untilTime;
   END IF;
 
--
   deb(DEB_OPEN, 'findSpfileBackup_c,rmanCmd=' || rmanCmd);
 
   OPEN findSpfileBackup_c(untilTime => findTime,
                           rmanCmd   => rmanCmd);
 
--
--
--
   findSpfileBackupCursor := TRUE;
 
--
   resetthisBackupAge;
   getBS_status := NULL;
 
   resetrcvRecStack;
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   lcopies := redundancy;
 
--
   IF (rmanCmd = obsoleteCmd_t AND allCopies) THEN
      raise_application_error(-20999, 'internal error: findSpfileBackup_1');
   END IF;
 
   LOOP
      valRC := NULL;
 
      FETCH findSpfileBackup_c
       INTO bsfrec;
 
      EXIT WHEN findSpfileBackup_c%NOTFOUND ;
 
      IF user_site_key is not null and user_db_unique_name is NOT NULL THEN
         user_site_key := null;
         deb(DEB_IN, 'Spfile backups are identified based on db_unique_name');
      END IF;
 
      IF (rmanCmd = obsoleteCmd_t) THEN
--
--
         valRC := SUCCESS;
      ELSE
         valRC := validateBackupSet(
               backupSetRec           => bsfrec,
               tag                    => restoreTag,
               tagMatchRequired       => TRUE,
               checkDeviceIsAllocated => TRUE,
               availableMask          => BSavailable,
               validRec               => validateRec);
      END IF;
 
   <<addAnother>>
      IF (getBS_status IS NULL AND valRC = AVAILABLE) THEN
         getBS_status := valRC;
      END IF;
 
      IF (debug) THEN
         printRcvRec(bsfRec);
      END IF;
 
      IF (valRC = SUCCESS) THEN
         IF (thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
            thisBackupAge  := thisBackupAge + 1;
         ELSIF (rmanCmd = obsoleteCmd_t) THEN
            deb(DEB_IN, ' Added bsfRec:');
 
            rcvRecPush(bsfRec);     -- add record for this action
            getBS_status := SUCCESS;
            IF (lcopies > 1) THEN
               lcopies := lcopies - 1;
            ELSE
               EXIT;              -- we are done
            END IF;
         ELSE
            deb(DEB_IN, ' Added bsfRec:');
 
            bsfrec.tag_con        := validateRec.tag;
            bsfrec.deviceType_con := validateRec.deviceType;
            bsfrec.copyNumber_con := validateRec.copyNumber;
 
            rcvRecPush(bsfRec);     -- add record for this action
 
            getBS_status := SUCCESS;
 
            IF (allCopies) THEN                   -- requested duplex copies
--
--
               valRC :=
                  validateBackupSet0(tag                    => restoreTag,
                                     tagMatchRequired       => TRUE,
                                     checkDeviceIsAllocated => TRUE,
                                     validRec               => validateRec);
               IF (valRC = SUCCESS) THEN
                  GOTO addAnother;
               END IF;
            END IF;
 
            IF (lcopies > 1) THEN
               lcopies := lcopies - 1;
            ELSE
               EXIT;              -- we are done
            END IF;
         END IF;
      END IF;
   END LOOP;
 
   CLOSE findSpfileBackup_c;
 
   IF (getBS_status = AVAILABLE) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
   ELSIF (getBS_status = SUCCESS) THEN
      deb(DEB_EXIT, 'with: SUCCESS');
   ELSE
      getBS_status := UNAVAILABLE;
      deb(DEB_EXIT, 'with: UNAVAILABLE');
   END IF;
END findSpfileBackup;
 
--
FUNCTION getSpfileBackup(
   rcvRec     OUT NOCOPY rcvRec_t
  ,redundancy IN         number default NULL
  ,rmanCmd    IN         number default unknownCmd_t)
RETURN number IS
   local        rcvRec_t;
   dummy        number;
BEGIN
   deb(DEB_ENTER, 'getSpfileBackup');
 
   IF (NOT findSpfileBackupCursor) THEN
--
      findSpfileBackup(allcopies  => FALSE,
                       redundancy => redundancy,
                       rmanCmd    => rmanCmd,
                       scn_warn   => dummy);
   END IF;
 
   IF (getRecStackCount = 0) THEN
      IF (getBS_status = SUCCESS) THEN
         deb(DEB_EXIT, 'with no more records');
         raise no_data_found;
      ELSIF (getBS_status = AVAILABLE) THEN
         deb(DEB_EXIT, 'with: AVAILABLE');
         RETURN AVAILABLE;
      ELSE
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN UNAVAILABLE;
      END IF;
   END IF;
 
   rcvRecPop(local);
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   deb(DEB_EXIT, 'with: SUCCESS');
   RETURN SUCCESS;
END getSpfileBackup;
 
--
PROCEDURE getCopyofDatafile(
   first           IN      boolean
  ,itag            IN      varchar2
  ,fno             OUT     number
  ,crescn          OUT     number
  ,rlogscn         OUT     number
  ,rlgtime         OUT     date
  ,recid           OUT     binary_integer
  ,stamp           OUT     binary_integer
  ,name            OUT     varchar2
  ,otag            OUT     varchar2
  ,status          OUT     varchar2
  ,nblocks         OUT     binary_integer
  ,bsz             OUT     binary_integer
  ,ctime           OUT     date
  ,toscn           OUT     number
  ,totime          OUT     date
  ,pluggedRonly    OUT     binary_integer
  ,pluginSCN       OUT     number
  ,pluginRlgSCN    OUT     number
  ,pluginRlgTime   OUT     date)
IS
   inc_idx     binary_integer;
BEGIN
   deb(DEB_ENTER, 'getCopyofDatafile');
 
   IF first THEN
      IF (getCopyofDatafile_c2%ISOPEN) THEN
         CLOSE getCopyofDatafile_c2;
      END IF;
 
      deb(DEB_PRINT, 'opening cursor');
      OPEN getCopyofDatafile_c2(itag);
   END IF;
 
<<next>>
   FETCH getCopyofDatafile_c2
    INTO fno, crescn, rlogscn, rlgtime, recid, stamp, name, otag, status,
         nblocks, bsz, ctime, toscn, totime, pluggedRonly, pluginSCN,
         pluginRlgSCN, pluginRlgTime;
 
   IF getCopyofDatafile_c2%NOTFOUND THEN
      deb(DEB_PRINT, 'closing cursor');
      CLOSE getCopyofDatafile_c2;
      deb(DEB_EXIT, 'with: no data found');
      RAISE no_data_found;
   END IF;
 
   FOR inc_idx in 0..max_inc_idx-1 LOOP
      IF (rlogscn = inc_list(inc_idx).resetlogs_change#  AND
          rlgtime = inc_list(inc_idx).resetlogs_time ) THEN
         IF (inc_idx = 0 OR
             toscn <= inc_list(inc_idx-1).resetlogs_change#) THEN
            deb(DEB_PRINT, 'matches inc=' ||inc_idx);
--
--
--
--
--
--
--
--
            EXIT;
--
         ELSE
            deb(DEB_PRINT, 'inc='||inc_idx|| ',toscn='||toscn||
                           ' exceeds '||inc_list(inc_idx-1).resetlogs_change#);
            deb(DEB_PRINT, 'belongs to orphan branch of this incarnation:');
            GOTO next;
         END IF;
      END IF;
   END LOOP;
 
   deb(DEB_EXIT, 'with: file found');
END getCopyOfDatafile;
 
--
--
PROCEDURE getCopyofDatafile(
   dfnumber        IN      number
  ,itag            IN      varchar2
  ,crescn          IN  OUT number
  ,rlogscn         IN  OUT number
  ,rlgtime         IN  OUT date
  ,recid           OUT     binary_integer
  ,stamp           OUT     binary_integer
  ,name            OUT     varchar2
  ,otag            OUT     varchar2
  ,status          OUT     varchar2
  ,nblocks         OUT     binary_integer
  ,bsz             OUT     binary_integer
  ,ctime           OUT     date
  ,toscn           OUT     number
  ,totime          OUT     date
  ,pluggedRonly    OUT     binary_integer
  ,pluginSCN       IN      number)
IS
BEGIN
OPEN getCopyofDatafile_c(dfnumber, itag, crescn, rlogscn,
                         rlgtime, pluginSCN);
 
FETCH getCopyofDatafile_c
 INTO recid, stamp, name, otag, status, nblocks,
      bsz, ctime, toscn, totime, crescn,
      rlogscn, rlgtime, pluggedRonly;
 
IF getCopyofDatafile_c%NOTFOUND THEN
   CLOSE getCopyofDatafile_c;
   RAISE no_data_found;
END IF;
 
CLOSE getCopyofDatafile_c;
END getCopyOfDatafile;
 
--
PROCEDURE getCopyofDatafile(
   dfnumber        IN  number
  ,itag            IN  varchar2
  ,crescn          IN  number
  ,rlogscn         IN  number
  ,rlgtime         IN  date
  ,recid           OUT binary_integer
  ,stamp           OUT binary_integer
  ,name            OUT varchar2
  ,otag            OUT varchar2
  ,status          OUT varchar2
  ,nblocks         OUT binary_integer
  ,bsz             OUT binary_integer
  ,ctime           OUT date
  ,toscn           OUT number
  ,totime          OUT date)
IS
   loc_crescn    number := crescn;
   loc_rlogscn   number := rlogscn;
   loc_rlgtime   date   := rlgtime;
   pluggedRonly  binary_integer;
   pluginSCN     number;
BEGIN
   getCopyOfDatafile(dfnumber  => dfnumber
                    ,itag      => itag
                    ,crescn    => loc_crescn
                    ,rlogscn   => loc_rlogscn
                    ,rlgtime   => loc_rlgtime
                    ,recid     => recid
                    ,stamp     => stamp
                    ,name      => name
                    ,otag      => otag
                    ,status    => status
                    ,nblocks   => nblocks
                    ,bsz       => bsz
                    ,ctime     => ctime
                    ,toscn     => toscn
                    ,totime    => totime
                    ,pluggedRonly => pluggedRonly
                    ,pluginSCN => 0);
END getCopyOfDatafile;
 
 
--
--
--
 
--
PROCEDURE setCompletedRange(
   after  IN date
  ,before IN date)
IS
BEGIN
   getRA_completedAfter  := after;
   getRA_completedBefore := before;
END setCompletedRange;
 
--
PROCEDURE setLikePattern(
   pattern IN varchar2)
IS
BEGIN
   getRA_likePattern := pattern;
END setLikePattern;
 
--
PROCEDURE setcanApplyAnyRedo(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'canApplyAnyRedo is set to TRUE');
      canApplyAnyRedo := TRUE#;
   ELSE
      deb(DEB_PRINT, 'canApplyAnyRedo is set to FALSE');
      canApplyAnyRedo := FALSE#;
   END IF;
END setcanApplyAnyRedo;
 
--
PROCEDURE setCanConvertCf(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'canConvert_Cf is set to TRUE');
      canConvert_Cf := TRUE#;
   ELSE
      deb(DEB_PRINT, 'canConvert_Cf is set to FALSE');
      canConvert_Cf := FALSE#;
   END IF;
END setCanConvertCf;
 
--
PROCEDURE setAllIncarnations(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'allIncarnations is set to TRUE');
      allIncarnations := TRUE#;
   ELSE
      deb(DEB_PRINT, 'allIncarnations is set to FALSE');
      allIncarnations := FALSE#;
   END IF;
END setAllIncarnations;
 
--
FUNCTION isTranslatedFno(fno IN NUMBER) RETURN NUMBER IS
BEGIN
   IF (tc_database = TRUE# OR fno = 0 OR tc_fno.exists(fno)) THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isTranslatedFno;
 
--
PROCEDURE setUntilResetlogs
IS
BEGIN
   untilSCN := this_reset_scn;
   untilTime := NULL;
   rpoint_set := FALSE;
 
   IF (this_reset_scn is NULL) THEN
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
END setUntilResetlogs;
 
--
PROCEDURE setGuid(
   guid IN varchar2 DEFAULT NULL)
IS
BEGIN
   guidQualifier := guid;
--
   guid2pdbKeyQualifier := guidToPdbKey(guid);
--
END setGuid;
 
--
--
--
--
PROCEDURE translateTempfile
IS
BEGIN
   IF (translateTempfile_c%ISOPEN) THEN
      validateState('translateTempfile_c');                  -- raise the error
   END IF;
 
   IF (pdbIdList.count = 0) THEN
      OPEN translateTempfile_c;
      getTempfileCursor := 'translateTempfile_c';
   ELSIF (pdbIdList.count = 1) THEN
      OPEN translateTempfileOfPdbId_c(pdbIdList.first + CONST2GVAL);
      getTempfileCursor := 'translateTempfileOfPdbId_c';
   ELSE
      OPEN translateTempfileOfPdbIdL_c;
      getTempfileCursor := 'translateTempfileOfPdbIdL_c';
   END IF;
END translateTempfile;
 
--
PROCEDURE translateTempfile(
   fname IN varchar2)
IS
BEGIN
   IF (translateTempfileName_c%ISOPEN) THEN
      validateState('translateTempfileName_c');              -- raise the error
   END IF;
 
   OPEN translateTempfileName_c(fileName => fname);
   getTempfileCursor := 'translateTempfileName_c';
END translateTempfile;
 
--
PROCEDURE translateTempfile(
   fno IN number)
IS
BEGIN
   IF (translateTempfileNumber_c%ISOPEN) THEN
      validateState('translateTempfileNumber_c');            -- raise the error
   END IF;
 
   OPEN translateTempfileNumber_c(fno => fno);
   getTempfileCursor := 'translateTempfileNumber_c';
END translateTempfile;
 
--
PROCEDURE getTempfile(
   tfRec  OUT NOCOPY tfRec_t)
IS
   eof   boolean := FALSE;
BEGIN
   IF (getTempfileCursor = 'translateTempfile_c') THEN
      FETCH translateTempfile_c
       INTO tfRec;
      IF (translateTempfile_c%NOTFOUND) THEN
         CLOSE translateTempfile_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileOfPdbId_c') THEN
      FETCH translateTempfileOfPdbId_c
       INTO tfRec;
      IF (translateTempfileOfPdbId_c%NOTFOUND) THEN
         CLOSE translateTempfileOfPdbId_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileOfPdbIdL_c') THEN
      FETCH translateTempfileOfPdbIdL_c
       INTO tfRec;
      IF (translateTempfileOfPdbIdL_c%NOTFOUND) THEN
         CLOSE translateTempfileOfPdbIdL_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileName_c') THEN
      FETCH translateTempfileName_c
       INTO tfRec;
      IF (translateTempfileName_c%NOTFOUND) THEN
         CLOSE translateTempfileName_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileNumber_c') THEN
      FETCH translateTempfileNumber_c
       INTO tfRec;
      IF (translateTempfileNumber_c%NOTFOUND) THEN
         CLOSE translateTempfileNumber_c;
         eof := TRUE;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (eof) THEN
      getTempfileCursor := NULL;
      RAISE no_data_found;                   -- signal end-of-fetch
   END IF;
 
--
--
--
   IF (tfRec.pdbName IS NULL) THEN
      tfRec.pdbName := translatePdb2Name(tfRec.pdbid);
   END IF;
END getTempfile;
 
--
PROCEDURE translateDatafileCancel IS
BEGIN
   IF (getDatafileCursor = 'translateDatafileName') THEN
      CLOSE translateDatafileName;
   ELSIF (getDatafileCursor = 'translateDatafileNumber') THEN
      CLOSE translateDatafileNumber;
   ELSIF (getDatafileCursor = 'translateDatafileCheckpoint') THEN
      CLOSE translateDatafileCheckpoint;
   END IF;
   getDatafileCursor := NULL;                   -- we closed it above
   getDatafileNoRows.error := NULL;             -- clear for next time
   getDatafileLast.dfNumber := NULL;            -- clear for next time
END translateDatafileCancel;
 
--
FUNCTION Num2DisplaySize(input_size IN NUMBER) return VARCHAR2 IS
   OneK number := 1024;
   OneM number := OneK * 1024;
   OneG number := OneM * 1024;
   OneT number := OneG * 1024;
   OneP number := OneT * 1024;
BEGIN
   IF input_size IS NULL THEN
      return NULL;
   ELSE
     IF (input_size < OneM) THEN
        return to_char(input_size/OneK,'9990.09') ||'K';
     ELSIF (input_size < OneG)  THEN
        return to_char(input_size/OneM,'9990.09') ||'M';
     ELSIF (input_size < OneT) THEN
        return to_char(input_size/OneG,'9990.09') ||'G';
     ELSIF (input_size < OneP) THEN
        return to_char(input_size/OneT,'9990.09') ||'T';
     ELSE
        return to_char(input_size/OneP,'9990.09') ||'P';
     END IF;
   END IF;
END Num2DisplaySize;
 
--
FUNCTION Sec2DisplayTime(input_secs IN NUMBER) return VARCHAR2 IS
   inputsecs number ; 
BEGIN
   IF input_secs IS NULL THEN
      return NULL;
   END IF;
   inputsecs := round(input_secs) ;
   RETURN to_char(floor(inputsecs/3600),'FM09')||':'||
            to_char(floor(mod(inputsecs,3600)/60),'FM09')||':'||
            to_char(mod(inputsecs,60),'FM09');
END Sec2DisplayTime;
 
--
PROCEDURE setArchivedLogRecord(
   thread#   IN  number
  ,sequence# IN  number
  ,first     IN  boolean)
IS
  seqTab   sequenceTab_t;
  thrbck   binary_integer;
  seqbck   binary_integer;
BEGIN
   IF first THEN
      tc_threadSeq.delete;
   END IF;
 
--
   IF (thread# >= CONST2GVAL) THEN
      thrbck := CONST2GVAL - thread#;
   ELSE
      thrbck := thread#;
   END IF;
 
--
   IF (sequence# >= CONST2GVAL) THEN
      seqbck := CONST2GVAL - sequence#;
   ELSE
      seqbck := sequence#;
   END IF;
 
   IF NOT tc_threadSeq.exists(thrbck) THEN
      tc_threadSeq(thrbck) := seqTab;
   END IF;
   tc_threadseq(thrbck)(seqbck) := TRUE;
END setArchivedLogRecord;
 
--
PROCEDURE setCanHandleTransportableTbs(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'canHandleTransportableTbs is set to TRUE');
      canHandleTransportableTbs := TRUE#;
   ELSE
      deb(DEB_PRINT, 'canHandleTransportableTbs is set to FALSE');
      canHandleTransportableTbs := FALSE#;
   END IF;
END setCanHandleTransportableTbs;
 
--
PROCEDURE getRestorePoint(
   name         IN  varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number)
IS
   clean      number;
   out_con_id number;
BEGIN
   getRestorePoint(name, rlgscn, rlgtime, scn, guaranteed,
                   0, clean, out_con_id);
END getRestorePoint;
 
PROCEDURE getRestorePoint(
   name         IN  varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number
  ,con_id       IN  number
  ,clean        OUT number
  ,out_con_id   OUT number)
IS
   rsp  restore_point_c%ROWTYPE;
   rsp2 restore_point_c%ROWTYPE;
BEGIN
   deb(DEB_ENTER, 'getRestorePoint');
   IF (restore_point_c%isopen) THEN
      CLOSE restore_point_c;
   END IF;
 
   OPEN restore_point_c(con_id, name);
   FETCH restore_point_c INTO rsp;
   IF restore_point_c%NOTFOUND
   THEN
      rlgscn     := NULL;
      rlgtime    := NULL;
      scn        := NULL;
      guaranteed := NULL;
      clean      := NULL;
   ELSE
      rlgscn     := rsp.reset_scn;
      rlgtime    := rsp.reset_time;
      scn        := rsp.scn;
      out_con_id := rsp.con_id;
      IF (rsp.clean = 'YES')
      THEN
         clean := 1;
      ELSE
         clean := 0;
      END IF;
      IF (rsp.guaranteed = 'YES')
      THEN
        guaranteed := 1;
      ELSE
        guaranteed := 0;
      END IF;
   END IF;
 
   FETCH restore_point_c INTO rsp2;
 
--
   IF ((NOT restore_point_c%NOTFOUND) AND (rsp.con_id = rsp2.con_id))
   THEN
      deb(DEB_EXIT, 'with error 20513');
      raise_application_error(-20513,
         'Restore point name is ambiguous, specify the SCN instead');
   END IF;
   CLOSE restore_point_c;
   deb(DEB_EXIT);
END getRestorePoint;
 
--
PROCEDURE listTranslateRestorePoint(
   name       IN  varchar2)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateRestorePoint');
 
   IF (restore_point_c%isopen) THEN
      CLOSE restore_point_c;
   END IF;
 
   deb(DEB_OPEN, 'restore_point_c');
   OPEN restore_point_c(con_id => 0, name => name);
   deb(DEB_EXIT);
END listTranslateRestorePoint;
 
--
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2)
IS
  pdbname  varchar2(128);
BEGIN
   listGetRestorePoint(name, scn, rsptime, cretime, rsptype, pdbname);
END listGetRestorePoint;
   
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2
  ,pdbname      OUT varchar2)
IS
   rsp restore_point_c%ROWTYPE;
BEGIN
   deb(DEB_ENTER, 'listGetRestorePoint');
 
   FETCH restore_point_c INTO rsp;
   IF (restore_point_c%NOTFOUND) THEN
      CLOSE restore_point_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
   name := rsp.name;
   scn := rsp.scn;
   rsptime := rsp.restore_point_time;
   cretime := rsp.creation_time;
--
   rsptype := ' ';
   IF rsp.preserved = 'YES'
   THEN
     rsptype := 'PRESERVED';
   END IF;
--
   IF rsp.guaranteed = 'YES'
   THEN
     rsptype := 'GUARANTEED';
   END IF;
   pdbname := translatePdb2Name(rsp.con_id);
   deb(DEB_EXIT);
END listGetRestorePoint;
 
--
PROCEDURE setDbidTransClause(dbid IN  number)
IS
  dbidbck  binary_integer;
BEGIN
--
   IF (dbid >= CONST2GVAL) THEN
      dbidbck := CONST2GVAL - dbid;
   ELSE
      dbidbck := dbid;
   END IF;
   tc_dbid(dbidbck) := TRUE;
END setDbidTransClause;
 
--
FUNCTION isTranslatedDbid(dbid IN NUMBER) RETURN NUMBER
IS
  dbidbck  binary_integer;
BEGIN
   IF (tc_anydbid = TRUE#) THEN
      RETURN TRUE#;
   ELSE
--
      IF (dbid >= CONST2GVAL) THEN
         dbidbck := CONST2GVAL - dbid;
      ELSE
         dbidbck := dbid;
      END IF;
      IF (tc_dbid.exists(dbidbck)) THEN
         RETURN TRUE#;
      END IF;
   END IF;
   RETURN FALSE#;
END isTranslatedDbid;
 
--
FUNCTION translatePdbName(pdbName IN VARCHAR2) RETURN NUMBER IS
BEGIN
   initPdbNameList;
 
   IF (pdbNameList.exists(pdbName)) THEN
      RETURN pdbNameList(pdbName);
   ELSE
      RETURN NULL;
   END IF;
END translatePdbName;
 
--
PROCEDURE resetPdbIdList IS
BEGIN
   pdbIdList.delete;
END resetPdbIdList;
 
--
PROCEDURE setPdbId(pdbId IN NUMBER, first IN BOOLEAN) IS
BEGIN
   IF (first) THEN
      resetPdbIdList;
   END IF;
 
   pdbIdList(pdbId - CONST2GVAL) := TRUE;
END setPdbId;
 
--
FUNCTION isTranslatedPdbId(pdbId IN NUMBER) RETURN NUMBER IS
BEGIN
   IF (pdbIdList.exists(pdbId - CONST2GVAL)) THEN
      RETURN TRUE#;
   END IF;
   
   RETURN FALSE#;
END isTranslatedPdbId;
 
--
FUNCTION isPdbScnOrphan(untilSCN IN NUMBER, pdbId IN NUMBER)
RETURN NUMBER IS
   toSCN NUMBER := untilSCN - 1;
BEGIN
   IF (isPdbScnOrphan(0, toSCN, 0, pdbId)) THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isPdbScnOrphan;
 
--
FUNCTION translatePdb2Name(pdbId IN NUMBER) RETURN VARCHAR2 IS
   pdbname  VARCHAR2(128);
BEGIN
--
--
   IF (pdbId IS NULL) THEN
      RETURN NULL;
   END IF;
 
   IF (pdbId <= 1) THEN
      RETURN NULL;
   END IF;
 
   initPdbNameList;
 
   pdbname := pdbNameList.first;
   WHILE pdbname IS NOT NULL
   LOOP
      IF (pdbNameList(pdbname) = pdbId) THEN
         RETURN pdbname;
      END IF; 
      pdbname := pdbNameList.next(pdbname);
   END LOOP;
 
   RETURN NULL;
END translatePdb2Name;
 
--
PROCEDURE setRestoreRangeDevTyp(typ IN VARCHAR2)
IS
BEGIN
   deb(DEB_ENTER, 'setRestoreRangeDevTyp');
 
   restoreRangeDevTyp := typ;
   deb(DEB_EXIT);
END setRestoreRangeDevTyp;
 
--
PROCEDURE resetRestoreRangeDevTyp
IS
BEGIN
   deb(DEB_ENTER, 'resetRestoreRangeDevTyp');
 
   restoreRangeDevTyp := null;
   deb(DEB_EXIT);
END resetRestoreRangeDevTyp;
 
--
PROCEDURE translatePrePluginDf(con_id IN number)
IS
BEGIN
   deb(DEB_ENTER, 'translatePrePluginDf');
--
   raise_application_error(-20999, 'Not supported in recovery catalog');
--
 
   deb(DEB_EXIT);
END translatePrePluginDf;
 
--
FUNCTION getPrePluginDf(
   prePluginDfRec OUT NOCOPY prePluginDfRec_t)
RETURN NUMBER IS
BEGIN
   deb(DEB_ENTER, 'getPrePluginDf');
--
   raise_application_error(-20999, 'Not supported in recovery catalog');
--
 
   deb(DEB_EXIT, 'with FALSE#');
   RETURN FALSE#;
END getPrePluginDf;
 
--
PROCEDURE setBigScnAware
IS
BEGIN
   deb(DEB_PRINT, 'Database is BIGSCN aware, higscnval set to UB8MAXVAL');
   highscnval := UB8MAXVAL; 
END setBigScnAware;
 
--
FUNCTION isNoBackupPdb(pdbname IN VARCHAR2)
RETURN NUMBER IS 
   nobackup NUMBER;
BEGIN
   deb(DEB_ENTER, 'isNoBackupPdb');
   IF (translateNoBackupPdb_c%ISOPEN) THEN
      CLOSE translateNoBackupPdb_c;
   END IF;
 
   OPEN translateNoBackupPdb_c(pdbname => pdbname);
   FETCH translateNoBackupPdb_c INTO nobackup;
   IF (translateNoBackupPdb_c%NOTFOUND) THEN
      nobackup := 0;
   END IF;
   CLOSE translateNoBackupPdb_c;
   deb(DEB_EXIT, 'with '||nobackup);
   RETURN nobackup;
END isNoBackupPdb;
 
--
--
--
 
--
PROCEDURE listApplicationPdbs(
   root_con_id       IN number)
IS
BEGIN
   deb(DEB_ENTER, 'listApplicationPdbs');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   deb(DEB_EXIT);
END listApplicationPdbs;
 
--
FUNCTION listGetAppPdb(
   pdb_name          OUT varchar2)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'listGetAppPdb');
   deb(DEB_EXIT);
END listGetAppPdb;
 
--
 
--
--
--
 
BEGIN
--
--
   versionList(1) := '08.00.04.00';
   versionList(2) := '08.00.05.00';
   versionList(3) := '08.01.03.00';
   versionList(4) := '08.01.05.00';
   versionList(5) := '08.01.06.00';
   versionList(6) := '08.01.07.00';
   versionList(7) := '09.00.00.00';
   versionList(8) := '09.02.00.00';
   versionList(9) := '10.01.00.00';
   versionList(10):= '10.02.00.00';
   versionList(11):= '10.02.00.01';
   versionList(12):= '11.01.00.00';
   versionList(13):= '11.01.00.01';
   versionList(14):= '11.01.00.02';
   versionList(15):= '11.01.00.03';
   versionList(16):= '11.01.00.04';
   versionList(17):= '11.01.00.05';
   versionList(18):= '11.01.00.06';
   versionList(19):= '11.01.00.07';
   versionList(20):= '11.02.00.00';
   versionList(21):= '11.02.00.01';
   versionList(22):= '11.02.00.02';
   versionList(23):= '12.01.00.00';
   versionList(24):= '12.01.00.01';
   versionList(25):= '12.01.00.02';
   versionList(26):= '12.02.00.00';
   versionList(27):= '12.02.00.01';
 
--
   versionCounter  := 1;
   versionMaxIndex := 27;               -- must match highest index used above
 
   resetAll;                              -- init package variables to defaults
END dbms_rcvman;
 

/
--------------------------------------------------------
--  DDL for Package Body DBMS_RCVVPC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."DBMS_RCVVPC" 
AS
 
  g_catowner_uid                  CONSTANT user_users.username%TYPE :=
                                    SYS_CONTEXT('USERENV', 'CURRENT_USERID');
 
  FUNCTION is_ra RETURN BOOLEAN;
  this_is_ra                      CONSTANT BOOLEAN := is_ra;
 
  SUBTYPE predicate_t IS VARCHAR2(256);
  TYPE predicates_t IS VARRAY(14) OF predicate_t;
 
  g_p                             CONSTANT predicates_t :=
    predicates_t(
      'filter_user = SYS_CONTEXT(''USERENV'', ''SESSION_USER'')'  -- 1
    , 'db_id IN (SELECT vpc.db_id FROM vpc_databases vpc)'        -- 2
    , 'db_key IN (SELECT db.db_key FROM db)'                      -- 3
    , 'pdb_key IN (SELECT pdb.pdb_key FROM pdb)'                  -- 4
    , 'dbinc_key IN (SELECT dbinc.dbinc_key FROM dbinc)'          -- 5
    , 'db_key IN (SELECT db.db_key FROM db) OR db_key IS NULL'    -- 6
    , 'bdf_key IN (SELECT bdf.bdf_key FROM bdf)'                  -- 7
    , 'cdf_key IN (SELECT cdf.cdf_key FROM cdf)'                  -- 8
    , 'scr_key IN (SELECT scr.scr_key FROM scr)'                  -- 9
    , 'EXISTS (SELECT NULL FROM vpc_databases)'                   -- 10
    , 'df_key IN (SELECT df.df_key FROM df)'                      -- 11
    , 'created_user = SYS_CONTEXT(''USERENV'', ''SESSION_USER'')' -- 12
    , 'filter_user = SYS_CONTEXT(''USERENV'', ''SESSION_USER'')'  -- 13
    , 'site_key IN (SELECT node.site_key FROM node)'              -- 14
    );
 
  FUNCTION is_ra
  RETURN BOOLEAN
  IS
    l_owner                        all_users.username%TYPE;
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN :owner := dbms_rai_owner; END;'
      USING OUT l_owner;
    RETURN (l_owner IS NOT NULL);
  EXCEPTION
    WHEN OTHERS
    THEN RETURN FALSE;
  END is_ra;
 
  PROCEDURE p (
    i_table                        VARCHAR2
  , i_msg                          VARCHAR2 DEFAULT NULL
  )
  IS
  BEGIN
$IF FALSE
$THEN
    sys.dbms_system.ksdwrt (
       sys.dbms_system.alert_file
     , 'filter_client_data: '
    || SYS_CONTEXT('USERENV', 'SID')
    || ' '
    || i_table
    || ' '
    || SYS_CONTEXT('USERENV', 'CURRENT_USER')
    || ' '
    || SYS_CONTEXT('USERENV', 'SESSION_USER')
    || ' ['
    || i_msg
    || ']'
    );
$ELSE
    NULL;
$END
  END p;
 
  FUNCTION filter_pass_all (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN NULL;
  END filter_pass_all;
 
  FUNCTION f_p (
    i_table                        IN VARCHAR2
  , i_predicate                    IN BINARY_INTEGER
  )
  RETURN VARCHAR2
  IS
  BEGIN
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
    IF (SYS_CONTEXT('USERENV', 'SESSION_USERID') IN (g_catowner_uid, 0))
    THEN
      p(i_table, NULL);
      RETURN NULL;
    ELSE
      p(i_table, g_p(i_predicate));
      RETURN
         g_p(i_predicate)
      || CASE
           WHEN this_is_ra
           THEN
           q'{ OR SYS_CONTEXT('SYS_SESSION_ROLES','RA_CATALOG_SELECT')='TRUE'}'
         END
      || q'{ OR SYS_CONTEXT('SYS_SESSION_ROLES','RMAN_CATALOG_ACCESS')='TRUE'}';
    END IF;
  END f_p;
 
  FUNCTION f_vpc_databases (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 1);
  END f_vpc_databases;
 
  FUNCTION f_db (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 2);
  END f_db;
 
  FUNCTION f_dbinc (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_dbinc;
 
  FUNCTION f_bp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_bp;
 
  FUNCTION f_bsf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_bsf;
 
  FUNCTION f_bs (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_bs;
 
  FUNCTION f_conf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_conf;
 
  FUNCTION f_deleted_object (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_deleted_object;
 
  FUNCTION f_do_seq (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_do_seq;
 
  FUNCTION f_node (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_node;
 
  FUNCTION f_pdb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_pdb;
 
  FUNCTION f_rout (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_rout;
 
  FUNCTION f_watermarks (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_watermarks;
 
  FUNCTION f_sbt_template_db (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_sbt_template_db;
 
  FUNCTION f_rrcache (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 3);
  END f_rrcache;
 
  FUNCTION f_pdbinc (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 4);
  END f_pdbinc;
 
  FUNCTION f_pdb_dbinc (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 4);
  END f_pdb_dbinc;
 
  FUNCTION f_al (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_al;
 
  FUNCTION f_bcf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_bcf;
 
  FUNCTION f_bdf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_bdf;
 
  FUNCTION f_brl (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_brl;
 
  FUNCTION f_ccf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_ccf;
 
  FUNCTION f_cdf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_cdf;
 
  FUNCTION f_ckp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_ckp;
 
  FUNCTION f_df (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_df;
 
  FUNCTION f_fb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_fb;
 
  FUNCTION f_grsp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_grsp;
 
  FUNCTION f_nrsp (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_nrsp;
 
  FUNCTION f_offr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_offr;
 
  FUNCTION f_orl (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_orl;
 
  FUNCTION f_rlh (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_rlh;
 
  FUNCTION f_rr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_rr;
 
  FUNCTION f_rsr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_rsr;
 
  FUNCTION f_rt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_rt;
 
  FUNCTION f_tf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_tf;
 
  FUNCTION f_tsatt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_tsatt;
 
  FUNCTION f_ts (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_ts;
 
  FUNCTION f_xal (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_xal;
 
  FUNCTION f_xcf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_xcf;
 
  FUNCTION f_xdf (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 5);
  END f_xdf;
 
  FUNCTION f_scr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 6);
  END f_scr;
 
  FUNCTION f_bcb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 7);
  END f_bcb;
 
  FUNCTION f_ccb (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 8);
  END f_ccb;
 
  FUNCTION f_scrl (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 9);
  END f_scrl;
 
  FUNCTION f_cfs (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 10);
  END f_cfs;
 
  FUNCTION f_config (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 10);
  END f_config;
 
  FUNCTION f_orsevent (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 10);
  END f_orsevent;
 
  FUNCTION f_rcfile (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 10);
  END f_rcfile;
 
  FUNCTION f_bcr (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 11);
  END f_bcr;
 
  FUNCTION f_xmlstore (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 12);
  END f_xmlstore;
 
  FUNCTION f_server (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 13);
  END f_server;
 
  FUNCTION f_vpc_users (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 13);
  END f_vpc_users;
 
  FUNCTION f_site_dfatt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 14);
  END f_site_dfatt;
 
  FUNCTION f_site_tfatt (
    schema_p                       IN VARCHAR2
  , table_p                        IN VARCHAR2
  )
  RETURN VARCHAR2
  IS
  BEGIN
    RETURN f_p(table_p, 14);
  END f_site_tfatt;
 
END dbms_rcvvpc;

/
--------------------------------------------------------
--  DDL for Package Body DELETE_TXN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."DELETE_TXN" AS
procedure PROCESS_INT_DELETE_TXN (i_remarks in varchar2,
  i_del_ledger in CHAR default 'N',
  i_del_es in CHAR default 'N',
  i_del_gs in CHAR default 'N',
  i_del_mr in CHAR default 'N',
  o_result_code out varchar2, o_result_desc out varchar2)
  is
    v_del_ledger CHAR(1) := 'N';
    v_del_es CHAR(1) := 'N';
    v_del_gs CHAR(1) := 'N';
    v_del_mr CHAR(1) := 'N';
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
BEGIN
      BEGIN  -- exception handling start

      v_log_result := log_activity('PROCEDURE','DELETE_TXN.PROCESS_INT_DELETE_TXN','START',I_remarks,'',v_created_by, sysdate,i_remarks);

      if(i_del_ledger is not null and i_del_ledger='Y') then v_del_ledger := 'Y'; end if;
      if(i_del_es is not null and i_del_es='Y') then v_del_es := 'Y'; end if;
      if(i_del_gs is not null and i_del_gs='Y') then v_del_gs := 'Y'; end if;
      if(i_del_mr is not null and i_del_mr='Y') then v_del_mr := 'Y'; end if;

       -- input validation

      if(i_remarks is null or i_remarks = '' ) then
        Raise_Application_Error (-20343, 'i_remarks is mandatory  ');
      end if;

      if(v_del_mr = 'Y'  and (v_del_ledger = 'N' or v_del_es = 'N' or v_del_gs = 'N')) then
        Raise_Application_Error (-20343, 'Input data issue - Please set the params(v_del_ledger,v_del_es,v_del_gs) to Y ');
      end if;

      if(v_del_gs = 'Y'  and (v_del_ledger = 'N' or v_del_es = 'N' )) then
        Raise_Application_Error (-20343, 'Input data issue - Please set the params(v_del_ledger,v_del_es) to N  ');
      end if;

      if(v_del_es = 'Y' and (v_del_ledger = 'N' )) then
        Raise_Application_Error (-20343, 'Input data issue - Please set the params(v_del_ledger) to N  ');
      end if;

      --reset values
      update INT_DELETE_TXN set PROCESSED=null,DELETE_REMARKS=null,deleted_ledger=null, deleted_es=null,deleted_gs=null,deleted_mr=null where remarks = i_remarks;

      for i in (select GEN_SERVICE_NUMBER, reading_month,reading_year  from INT_DELETE_TXN where REMARKS = i_remarks)
      loop
        delete_by_service(i_remarks, i.GEN_SERVICE_NUMBER,i.reading_month,i.reading_year,v_del_ledger,v_del_es,v_del_gs,v_del_mr,o_result_code,o_result_desc);  
      end loop;

      o_result_code :='SUCCESS';
      exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        o_result_code := 'FAILURE';
        o_result_desc := v_exception_code || ' - ' || v_exception_msg;
        dbms_output.put_line(o_result_desc);
      END;
      <<THE_END>>
      commit;
     -- if(v_result_code = 'SUCCESS')then
     --   v_result_desc := v_batch_id;
     -- end if;
      v_log_result := log_activity('PROCEDURE','DELETE_TXN.PROCESS_INT_DELETE_TXN','RESULT',o_result_code,o_result_desc,v_created_by, sysdate,i_remarks);
END PROCESS_INT_DELETE_TXN;
  procedure DELETE_BY_SERVICE (i_remarks in varchar2,i_service_number IN VARCHAR2,i_reading_month in VARCHAR2,i_reading_year in VARCHAR2,
                              i_del_ledger in CHAR default 'N',
                              i_del_es in CHAR default 'N',
                              i_del_gs in CHAR default 'N',
                              i_del_mr in CHAR default 'N', o_result_code out varchar2, o_result_desc out varchar2)
    is

    v_del_ledger CHAR(1) := 'N';
    v_del_es CHAR(1) := 'N';
    v_del_gs CHAR(1) := 'N';
    v_del_mr CHAR(1) := 'N';    
    v_created_By  varchar2(50):= 'admin';
    v_status varchar2(50);
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_log_result varchar(300):='SUCCESS';
    v_deleted_ledger char;
    v_deleted_es char;
    v_deleted_gs char;
    v_deleted_mr char;
    v_tesid varchar2(50);
    v_service_id varchar2(50);
    v_company_id varchar2(50);
    v_master_count number;
    v_banking_balance t_banking_balance%ROWTYPE;
    v_banking_count number:=0;
    v_delete_txn delete_txn_log%ROWTYPE;
    v_org_id varchar2(50);
BEGIN
    BEGIN
      v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','START','Start - i_service_number-'||i_service_number||',month - '||i_reading_month||',year - '||i_reading_year,'','', sysdate,i_remarks);


      if(i_del_ledger is not null and i_del_ledger='Y') then v_del_ledger := 'Y'; end if;
      if(i_del_es is not null and i_del_es='Y') then v_del_es := 'Y'; end if;
      if(i_del_gs is not null and i_del_gs='Y') then v_del_gs := 'Y'; end if;
      if(i_del_mr is not null and i_del_mr='Y') then v_del_mr := 'Y'; end if;

      -- input validation
      if(v_del_mr='Y'  and (v_del_ledger = 'N' or v_del_es = 'N' or v_del_gs = 'N')) then
        Raise_Application_Error (-20343, 'Input data issue - Please set the params(v_del_ledger,v_del_es,v_del_gs) to Y ');
      end if;

      if(v_del_gs='Y'  and (v_del_ledger = 'N' or v_del_es = 'N' )) then
        Raise_Application_Error (-20343, 'Input data issue - Please set the params(v_del_ledger,v_del_es) to Y  ');
      end if;

      if(v_del_es='Y'  and (v_del_ledger = 'N' )) then
        Raise_Application_Error (-20343, 'Input data issue - Please set the params(v_del_ledger) to Y  ');
      end if;

      if(i_service_number is null or i_service_number = '' ) then
        Raise_Application_Error (-20343, 'i_service_number is mandatory  ');
      end if;

      if(i_reading_month is null or i_reading_month = '' or i_reading_year is null or i_reading_year = '' ) then
        Raise_Application_Error (-20343, 'i_reading_month, i_reading_year are madatory  ');
      end if;

      -- fetch master keys
      select count(id) into v_master_count from V_COMPANY_SERVICE where "number" =i_service_number ;


      if(v_master_count = 0 ) then
        Raise_Application_Error (-20343, 'The input i_service_number '||i_service_number||' is not available in the system ');
      ELSIF(v_master_count > 1 ) then
        Raise_Application_Error (-20343, 'The input i_service_number '||i_service_number||' is duplicated in the system ');
      end if;

      select id,m_company_id  into v_service_id,v_company_id  from V_COMPANY_SERVICE where "number" =i_service_number ;

      if(v_del_ledger='Y') then  
        --DELETE from f_energy_ledger where m_company_service_id = v_service_id and month=i_reading_month and year =i_reading_year;
        for i in (select id from f_energy_sale_order where (seller_comp_serv_id = v_service_id or d_sell_comp_serv_number= i_service_number) and month=i_reading_month and year =i_reading_year)
        loop
          delete from F_ENERGY_CHARGES where f_energy_sale_order_id = i.id;
          DELETE from f_energy_ledger where f_energy_sale_order_id = i.id;
          delete from F_ENERGY_SALE_ORDER_LINES where f_energy_sale_order_id = i.id;
          select t_energy_sale_id into v_tesid  from f_energy_sale_order where id=i.id and rownum=1;
          delete from t_job_hdr where t_energy_sale_id=v_tesid;
          delete from f_energy_sale_order where id = i.id;
          --Changes may be needed


          update t_energy_sale set status_code='CREATED' where ID=v_tesid;
          --
          
          excess_units.reset_balances_to_open_bal(i_service_number,i_reading_month ,i_reading_year,o_result_code,o_result_desc );
        --  select count(*) into v_banking_count from T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
       --   if v_banking_count = 1 then
--            excess_units.reset_balances_to_open_bal( i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason );
        --    select * into v_banking_balance from T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
         --   update T_BANKING_BALANCE set  modified_dt=sysdate,modified_by='DELETE-TXN',remarks='DELETE-TXN',CURR_C1=v_banking_balance.c1,CURR_C2=v_banking_balance.c2,CURR_C3=v_banking_balance.c3,CURR_C4=v_banking_balance.c4,CURR_C5=v_banking_balance.c5 where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
         -- end if;

        end loop;
        v_deleted_ledger := 'Y';
        v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','Deleted Ledger, Energy Sale Order(Allotment Order)',i_service_number,'','', sysdate,i_remarks);
      end if;

      if(v_del_es='Y') then  
        for i in (select id from T_ENERGY_SALE where seller_comp_serv_id = v_service_id and month=i_reading_month and year =i_reading_year)
        loop
          for j in (select id FROM T_ES_MULTIADD_HEADER WHERE T_ES_ID = i.id)
          loop
            delete from T_ES_MULTIADD_LINE where T_ES_MULTIADD_HEADER_ID = j.id;
          end loop;
          delete from T_ES_MULTIADD_HEADER WHERE T_ES_ID=i.id;
          delete from T_ES_CHARGE where t_energy_sale_id = i.id;
          delete from T_ES_USAGE_DETAIL where t_energy_sale_id = i.id;
          delete from T_ES_USAGE_SUMMARY where t_energy_sale_id = i.id;
          delete from T_ENERGY_SALE where id = i.id;
          update T_GEN_STMT set STATUS_CODE='CREATED' where M_COMPANY_SERVICE_ID=v_service_id;
          
          excess_units.reset_balances_to_open_bal(i_service_number,i_reading_month ,i_reading_year,o_result_code,o_result_desc );
          --select count(*) into v_banking_count from T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
          --if v_banking_count = 1 then
            -- excess_units.delete_balances( i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason );
--            select * into v_banking_balance from T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
  --          update T_BANKING_BALANCE set modified_dt=sysdate,modified_by='DELETE-TXN',remarks='DELETE-TXN',CURR_C1=v_banking_balance.c1,CURR_C2=v_banking_balance.c2,CURR_C3=v_banking_balance.c3,CURR_C4=v_banking_balance.c4,CURR_C5=v_banking_balance.c5 where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
    --      end if;


        end loop;
        v_deleted_es := 'Y';
        v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','Deleted Energy Sale(Energy Allotment)',i_service_number,'','', sysdate,i_remarks);
      end if;

      if(v_del_gs='Y'  ) then  
        for i in (select id from T_GEN_STMT where M_COMPANY_SERVICE_ID = v_service_id and stmt_month=i_reading_month and stmt_year =i_reading_year)
        loop
          delete from T_GEN_STMT_CHARGE where t_gen_stmt_id = i.id;
          delete from T_GEN_STMT_SLOT where t_gen_stmt_id = i.id;
          delete from T_GEN_STMT where id = i.id;
          update t_meter_reading_hdr set m_gen_stmt_id = null , GS_BATCH_ID = null where m_gen_stmt_id = i.id;
          excess_units.delete_balances(i_service_number,i_reading_month ,i_reading_year,o_result_code,o_result_desc );
            --select count(*) into v_banking_count from T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
          --if v_banking_count = 1 then
--            select * into v_banking_balance from T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
--            update T_BANKING_BALANCE set modified_dt=sysdate,modified_by='DELETE-TXN',remarks='DELETE-TXN',CURR_C1=v_banking_balance.c1,CURR_C2=v_banking_balance.c2,CURR_C3=v_banking_balance.c3,CURR_C4=v_banking_balance.c4,CURR_C5=v_banking_balance.c5 where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
          --DELETE FROM T_BANKING_BALANCE where m_company_id=v_company_id and month=i_reading_month and year =i_reading_year;
          --end if;
        end loop;
        v_deleted_gs := 'Y';
        v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','Deleted Generation Statement',i_service_number,'','', sysdate,i_remarks);
      end if;

      if(v_del_mr='Y' ) then  
        for i in (select mr.id from t_meter_reading_hdr mr join M_COMPANY_meter m on m.id = mr.M_COMPANY_METER_ID where m.M_COMPANY_SERVICE_ID = v_service_id and mr.reading_month=i_reading_month and mr.reading_year =i_reading_year)
        loop
            delete from t_meter_reading_slot where t_meter_reading_hdr_id = i.id;
            delete from t_meter_reading_hdr where id = i.id;      
        end loop;
        v_deleted_mr := 'Y';
        v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','Deleted Meter Reading',i_service_number,'','', sysdate,i_remarks);
      end if;

         --INSERT STARTS HERE FOR delete_txn_log TABLE
         SELECT M_ORG_ID INTO v_org_id FROM V_COMPANY_SERVICE where "number" =i_service_number;
         v_delete_txn.ID :=delete_txn_log_seq.NEXTVAL;
         v_delete_txn.SERVICE_NO :=i_service_number;
         v_delete_txn.MONTH :=i_reading_month;
         v_delete_txn.YEAR :=i_reading_year;
         v_delete_txn.remarks :=i_remarks;
         v_delete_txn.CREATED_DATE :=sysdate;
         v_delete_txn.CREATED_BY :=v_created_By;
         v_delete_txn.M_ORG_ID :=v_org_id;
         if (v_del_mr='Y') then
            v_delete_txn.READING :='Y';
            else
            v_delete_txn.READING :='N';
        end if;
        if(v_del_gs='Y') then
            v_delete_txn.STATEMENT:='Y';
            else
            v_delete_txn.STATEMENT:='N';
        end if;
        if(v_del_es='Y') then
            v_delete_txn.ALLOTMENT:='Y';
            else
            v_delete_txn.ALLOTMENT:='N';
        end if;
        if(v_del_ledger='Y') then
            v_delete_txn.LEDGER:='Y';
            else
            v_delete_txn.LEDGER:='N';
        end if;
        insert into delete_txn_log values v_delete_txn;
        COMMIT;
         ---INSERT ENDS HERE FOR delete_txn_log TABLE
      o_result_code :='SUCCESS';
      update delete_txn_log set result=o_result_code where service_no=i_service_number and remarks=i_remarks and MONTH=i_reading_month and YEAR=i_reading_year;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(v_reason);
          v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','EXCEPTION',o_result_desc,'','', sysdate,i_remarks);
    END;

    update INT_DELETE_TXN set PROCESSED='Y',DELETE_REMARKS=o_result_code || ' - ' || o_result_desc,deleted_ledger=v_deleted_ledger, deleted_es=v_deleted_es,deleted_gs=v_deleted_gs,deleted_mr=v_deleted_mr where remarks = i_remarks and GEN_SERVICE_NUMBER = i_service_number;
    commit;
    v_log_result := log_activity('FUNCTION','DELETE_TXN_BY_SERVICE_NO','END',i_service_number,o_result_code || ' - ' || o_result_desc,'', sysdate,i_remarks);

  END DELETE_BY_SERVICE;
END DELETE_TXN;

/
--------------------------------------------------------
--  DDL for Package Body ENERGY_SALE_BULK_ALLOTMENT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."ENERGY_SALE_BULK_ALLOTMENT" AS

  procedure clear(i_energy_sale_id in varchar2, i_overwrite in char default 'N', o_result_code out varchar2, o_result_desc out varchar2) is
    v_overwrite char:='N';
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);  
    v_total_count number:=0;
    v_es_multiadd_hdr T_ES_MULTIADD_HEADER%ROWTYPE;
    v_es_multiadd_line T_ES_MULTIADD_LINE%ROWTYPE;
    v_es_multiadd_line_id number:=0;

  BEGIN
    BEGIN

      v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.CLEAR','START','Start - '||i_energy_sale_id,'','', sysdate,i_energy_sale_id);

      if(I_OVERWRITE is not null and I_OVERWRITE='Y') then v_overwrite := 'Y'; end if; 

      o_result_code:='';o_result_desc:='';



      select count(*) into v_total_count from T_ES_MULTIADD_HEADER where T_ES_ID=i_energy_sale_id and IS_COMPLETED!='Y';
--      dbms_output.put_line(v_total_count);
      if(v_total_count>0) then
        if nvl(v_overwrite,'N')='N' then
            o_result_code := 'FAILURE';
            o_result_desc := 'Another Transaction is in progress,Please wait or run clear() with i_overwrite=Y';
            GOTO THE_END;
        else
         select * into v_es_multiadd_hdr from T_ES_MULTIADD_HEADER where T_ES_ID=i_energy_sale_id and IS_COMPLETED!='Y';
         update T_ES_MULTIADD_HEADER set T_ES_ID=i_energy_sale_id,is_completed='N',REMARKS='', error_message='' where id=v_es_multiadd_hdr.id;

        end if;

      end if;

     FOR line IN ( select * into v_es_multiadd_line from T_ES_MULTIADD_LINE where T_ES_MULTIADD_HEADER_ID=v_es_multiadd_hdr.id)
     LOOP
        v_es_multiadd_line_id:=NULL;
        update T_ES_MULTIADD_LINE set id=v_es_multiadd_line_id ,is_clean='N' ,import_remarks='Orphan records' where id=line.id;

     END LOOP;


      <<THE_END>>
      commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.CLEAR','EXCEPTION',o_result_desc,'','', sysdate,i_energy_sale_id);
    END;

    v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.CLEAR','END','Cleared earlier transactions and related orphan records','','', sysdate,i_energy_sale_id);

  END clear;

  procedure init(i_energy_sale_id in varchar2, o_result_code out varchar2, o_result_desc out varchar2, o_es_multi_add_header_id out varchar2) AS
   v_created_by varchar2(100):='admin';
   v_log_result  varchar2(50);
   v_reason varchar2(200):='';
   v_exception_code  NUMBER;
   v_exception_msg  VARCHAR2(200);  
   v_es_multiadd_hdr T_ES_MULTIADD_HEADER%ROWTYPE;
   v_es T_ENERGY_SALE%ROWTYPE;
  BEGIN
    BEGIN
        -- TODO: Implementation required for procedure ENERGY_SALE_BULK_ALLOTMENT.init
        v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.INIT','START','Start - '||i_energy_sale_id,'','', sysdate,i_energy_sale_id);

        select * into v_es from t_energy_sale es where es.id=i_energy_sale_id; 
        v_es_multiadd_hdr.T_ES_ID :=i_energy_sale_id;
        v_es_multiadd_hdr.T_GEN_STMT_ID := v_es.T_GEN_STMT_ID;
        v_es_multiadd_hdr.SELLER_COMP_SERV_ID := v_es.SELLER_COMP_SERV_ID;
        v_es_multiadd_hdr.FROM_DT:= v_es.FROM_DT;
        v_es_multiadd_hdr.TO_DT:= v_es.TO_DT;
        v_es_multiadd_hdr.id :=T_ES_MULTIADD_HEADER_SEQ.NEXTVAL;
        o_es_multi_add_header_id:= v_es_multiadd_hdr.id;
        insert into T_ES_MULTIADD_HEADER values v_es_multiadd_hdr;
        update T_ES_MULTIADD_LINE set T_ES_MULTIADD_HEADER_ID = v_es_multiadd_hdr.id where T_ES_MULTIADD_HEADER_ID IS NULL;

   commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.INIT','EXCEPTION',o_result_desc,'','', sysdate,i_energy_sale_id);
    END;

    v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.INIT','END','Cleared earlier transactions and related orphan records - '||o_result_code,'','', sysdate,i_energy_sale_id);

  END init;

  procedure validate(i_energy_sale_id in varchar2, i_es_multi_add_header_id in varchar2,o_result_code out varchar2, o_result_desc out varchar2) AS
   v_created_by varchar2(100):='admin';
   v_log_result  varchar2(50);
   v_reason varchar2(200):='';
   v_exception_code  NUMBER;
   v_exception_msg  VARCHAR2(200);  
   v_es_multiadd_hdr T_ES_MULTIADD_HEADER%ROWTYPE;
   v_es_multiadd_line T_ES_MULTIADD_LINE%ROWTYPE;
   v_es T_ENERGY_SALE%ROWTYPE;
   v_fuel_group varchar2(50);
   v_seller_num varchar2(50);
   v_comp_serv v_company_service%ROWTYPE;
   v_tr M_TRADE_RELATIONSHIP%ROWTYPE;
   v_es_usage_sum_count number:=0;
   v_serv_no_count number:=0;
   v_traderel_count number:=0;
   v_is_clean_flag boolean;
   v_total_count number:=0;
   v_success_count number:=0;
   v_error_count number:=0;
  BEGIN
      BEGIN
    -- TODO: Implementation required for procedure ENERGY_SALE_BULK_ALLOTMENT.validate
        v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','START','Start - '||i_energy_sale_id,'','', i_es_multi_add_header_id,i_energy_sale_id);

        select * into v_es from t_energy_sale es where es.id=i_energy_sale_id; 
        select "number", fuel_group_name into v_seller_num, v_fuel_group from v_company_service serv where id = v_es.seller_comp_serv_id;
        select * into v_es_multiadd_hdr from T_ES_MULTIADD_HEADER es where es.id=i_es_multi_add_header_id; 
        update t_es_multiadd_line set is_clean='N', import_remarks='Consumer Service Number is empty' where T_ES_MULTIADD_HEADER_ID=i_es_multi_add_header_id and M_COMP_SERV_NUMBER is null;
        FOR line IN ( select * into v_es_multiadd_line from T_ES_MULTIADD_LINE where T_ES_MULTIADD_HEADER_ID=v_es_multiadd_hdr.id)
        LOOP
        BEGIN
            v_is_clean_flag:=true; 
            v_total_count:=v_total_count+1;

            -- finding buyer company service id
            select count(*) into v_serv_no_count from v_company_service serv where "number" =line.M_COMP_SERV_NUMBER;
            v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','v_serv_no_count- '||v_serv_no_count,line.M_COMP_SERV_NUMBER,'','', v_seller_num,i_energy_sale_id);
            if v_serv_no_count >0 then
                select * into v_comp_serv from v_company_service serv where "number" =line.M_COMP_SERV_NUMBER  and rownum=1;
                line.M_COMP_SERV_ID:=v_comp_serv.id;
            else 
                line.is_clean:='N';
                line.import_remarks:='Consumer Service Number is invalid';
                v_is_clean_flag:=false;
                v_error_count:=v_error_count+1;
                goto loop_end;

            end if;


            -- finding trade relationship
            select count(*)into v_traderel_count from m_trade_relationship trade where trade.M_SELLER_COMP_SERVICE_ID =v_es_multiadd_hdr.SELLER_COMP_SERV_ID and M_BUYER_COMP_SERVICE_ID=line.M_COMP_SERV_ID
            and to_date(v_es_multiadd_hdr.from_dt,'dd-mm-yyyy') between to_date(from_date,'dd-mm-yyyy') and to_date(TO_DATE,'dd-mm-yyyy') ;

            -- v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','v_traderel_count','Start - '||v_traderel_count,'','', v_seller_num,i_energy_sale_id);
            if v_traderel_count >0 then
                if v_traderel_count >1 then
                    v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','Multiple TradeRels for same consumer - '||v_traderel_count,v_es_multiadd_hdr.SELLER_COMP_SERV_ID,'',line.M_COMP_SERV_ID, v_seller_num,i_energy_sale_id);
                end if;
                select * into v_tr from m_trade_relationship trade where trade.M_SELLER_COMP_SERVICE_ID =v_es_multiadd_hdr.SELLER_COMP_SERV_ID and M_BUYER_COMP_SERVICE_ID=line.M_COMP_SERV_ID
                    and to_date(v_es_multiadd_hdr.from_dt,'dd-mm-yyyy') between to_date(from_date,'dd-mm-yyyy') and to_date(TO_DATE,'dd-mm-yyyy') and rownum =1;
                line.M_TRADEREL_ID:=v_tr.id;
            else 
                line.is_clean:='N';
                line.import_remarks:='No Agreement with this consumer';
                v_is_clean_flag:=false;
                v_error_count:=v_error_count+1;
                goto loop_end;
            end if;


            if(v_fuel_group = 'FF' and v_tr.interval_type_code='02') then
                -- If quantum in slots of Allocated is greater than quantum in slots of TRs, then its error
                null;
                if (to_number(nvl(line.c1,0)) > to_number(nvl(v_tr.c1,0)) or to_number(nvl(line.c2,0)) > to_number(nvl(v_tr.c2,0)) or to_number(nvl(line.c3,0)) > to_number(nvl(v_tr.c3,0))
                    or to_number(nvl(line.c4,0)) > to_number(nvl(v_tr.c4,0)) or to_number(nvl(line.c5,0)) > to_number(nvl(v_tr.c5,0)) ) then
                    line.is_clean:='N';
                    line.import_remarks:='Allocated quantum in slot is more than quantum configured in TradeRel';
                    v_is_clean_flag:=false;
                    v_error_count:=v_error_count+1;
                    goto loop_end;
                end if;
            end if;

             --finding if buyer already add in esUsageSummary
             -- v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','111','111 - ','','', sysdate,line.M_COMP_SERV_ID);
            select count(*) into v_es_usage_sum_count from t_es_usage_summary  where T_ENERGY_SALE_ID =i_energy_sale_id and BUYER_COMP_SERV_ID=line.M_COMP_SERV_ID and M_TRADE_RELATIONSHIP_ID=line.M_TRADEREL_ID;

          --   v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','v_es_usage_sum_count','Start - '||v_es_usage_sum_count,'','', sysdate,line.M_COMP_SERV_ID);
            if v_es_usage_sum_count =1 then
               select id into line.t_es_usage_summary_id from t_es_usage_summary  where T_ENERGY_SALE_ID =i_energy_sale_id and BUYER_COMP_SERV_ID=line.M_COMP_SERV_ID and M_TRADE_RELATIONSHIP_ID=line.M_TRADEREL_ID;
            end if;
            if v_is_clean_flag then
                line.is_clean:='Y';
                line.import_remarks:='Clean record';
                v_success_count:=v_success_count+1;
                v_es_multiadd_hdr.total_c1:=trim(to_number(nvl(v_es_multiadd_hdr.total_c1,0)))+trim(to_number(nvl(line.c1,0)));
                v_es_multiadd_hdr.total_c2:=trim(to_number(nvl(v_es_multiadd_hdr.total_c2,0)))+trim(to_number(nvl(line.c2,0)));
                v_es_multiadd_hdr.total_c3:=trim(to_number(nvl(v_es_multiadd_hdr.total_c3,0)))+trim(to_number(nvl(line.c3,0)));
                v_es_multiadd_hdr.total_c4:=trim(to_number(nvl(v_es_multiadd_hdr.total_c4,0)))+trim(to_number(nvl(line.c4,0)));
                v_es_multiadd_hdr.total_c5:=trim(to_number(nvl(v_es_multiadd_hdr.total_c5,0)))+trim(to_number(nvl(line.c5,0)));
                if(v_fuel_group <> 'FF') then
                    v_es_multiadd_hdr.total_c001:=trim(to_number(nvl(v_es_multiadd_hdr.total_c001,0)))+trim(to_number(nvl(line.c001,0)));
                    v_es_multiadd_hdr.total_c002:=trim(to_number(nvl(v_es_multiadd_hdr.total_c002,0)))+trim(to_number(nvl(line.c002,0)));
                    v_es_multiadd_hdr.total_c003:=trim(to_number(nvl(v_es_multiadd_hdr.total_c003,0)))+trim(to_number(nvl(line.c003,0)));
                    v_es_multiadd_hdr.total_c004:=trim(to_number(nvl(v_es_multiadd_hdr.total_c004,0)))+trim(to_number(nvl(line.c004,0)));
                    v_es_multiadd_hdr.total_c005:=trim(to_number(nvl(v_es_multiadd_hdr.total_c005,0)))+trim(to_number(nvl(line.c005,0)));
                    v_es_multiadd_hdr.total_c006:=trim(to_number(nvl(v_es_multiadd_hdr.total_c006,0)))+trim(to_number(nvl(line.c006,0)));
                    v_es_multiadd_hdr.total_c007:=trim(to_number(nvl(v_es_multiadd_hdr.total_c007,0)))+trim(to_number(nvl(line.c007,0)));
                    v_es_multiadd_hdr.total_c008:=trim(to_number(nvl(v_es_multiadd_hdr.total_c008,0)))+trim(to_number(nvl(line.c008,0)));
                    v_es_multiadd_hdr.total_c009:=trim(to_number(nvl(v_es_multiadd_hdr.total_c009,0)))+trim(to_number(nvl(line.c009,0)));
                end if;
            end if;
            exception
            when others then
              line.is_clean:='N';
              line.import_remarks:= v_exception_code || ' - ' || SUBSTR(SQLERRM, 1, 200);
              v_is_clean_flag:=false;
              v_error_count:=v_error_count+1;
            dbms_output.put_line(o_result_desc); 

              v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','EXCEPTION', line.import_remarks,'',line.M_COMP_SERV_ID, v_seller_num,i_energy_sale_id);
            END; 
             <<LOOP_END>>
            update t_es_multiadd_line set M_TRADEREL_ID= line.M_TRADEREL_ID , M_COMP_SERV_ID=line.M_COMP_SERV_ID,is_clean=line.is_clean, import_remarks=line.import_remarks,t_es_usage_summary_id=line.t_es_usage_summary_id  where id=line.id;

        END LOOP;

        v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','TOTAL_COUNT',v_total_count,'','', v_seller_num,i_energy_sale_id);

 /*     COMMENTING this section - not sure of purpose in wrongly declaring over-allocation
        if to_number(nvl(v_es_multiadd_hdr.total_c1,0)) >  to_number(nvl(v_es.c1,0)) then
         v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE',' v_es_multiadd_hdr.ERROR_MESSAGE in if',  v_es_multiadd_hdr.ERROR_MESSAGE,'1','', v_seller_num,i_energy_sale_id);
         v_es_multiadd_hdr.ERROR_MESSAGE:=nvl(v_es_multiadd_hdr.ERROR_MESSAGE,'')||'-- Over Allocation on C1';
         v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE',' v_es_multiadd_hdr.ERROR_MESSAGE',  v_es_multiadd_hdr.ERROR_MESSAGE,'1','', v_seller_num,i_energy_sale_id);
        end if;
        if to_number(nvl(v_es_multiadd_hdr.total_c2,0)) >  to_number(nvl(v_es.c2,0)) then
         v_es_multiadd_hdr.ERROR_MESSAGE:=nvl(v_es_multiadd_hdr.ERROR_MESSAGE,'')||'-- Over Allocation on C2';
         v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE',' v_es_multiadd_hdr.ERROR_MESSAGE',  v_es_multiadd_hdr.ERROR_MESSAGE,'2','', v_seller_num,i_energy_sale_id);
        end if;
        if to_number(nvl(v_es_multiadd_hdr.total_c3,0)) >  to_number(nvl(v_es.c3,0)) then
         v_es_multiadd_hdr.ERROR_MESSAGE:=nvl(v_es_multiadd_hdr.ERROR_MESSAGE,'')||'-- Over Allocation on C3';
         v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE',' v_es_multiadd_hdr.ERROR_MESSAGE',  v_es_multiadd_hdr.ERROR_MESSAGE,'3','', v_seller_num,i_energy_sale_id);
        end if;
        if to_number(nvl(v_es_multiadd_hdr.total_c4,0)) >  to_number(nvl(v_es.c4,0)) then
         v_es_multiadd_hdr.ERROR_MESSAGE:=nvl(v_es_multiadd_hdr.ERROR_MESSAGE,'')||'-- Over Allocation on C4';
         v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE',' v_es_multiadd_hdr.ERROR_MESSAGE',  v_es_multiadd_hdr.ERROR_MESSAGE,'4','', v_seller_num,i_energy_sale_id);
        end if;
        if to_number(nvl(v_es_multiadd_hdr.total_c5,0)) >  to_number(nvl(v_es.c5,0)) then
         v_es_multiadd_hdr.ERROR_MESSAGE:=nvl(v_es_multiadd_hdr.ERROR_MESSAGE,'')||'-- Over Allocation on C5';
         v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE',' v_es_multiadd_hdr.ERROR_MESSAGE',  v_es_multiadd_hdr.ERROR_MESSAGE,'5','', v_seller_num,i_energy_sale_id);
        end if;

        */
        <<THE_END>>

        update t_es_multiadd_header set TOTAL_COUNT = v_total_count,SUCCESS_COUNT=v_success_count,ERROR_COUNT=v_error_count,total_c1=v_es_multiadd_hdr.total_c1,total_c2=v_es_multiadd_hdr.total_c2,
            total_c3=v_es_multiadd_hdr.total_c3,total_c4=v_es_multiadd_hdr.total_c4,total_c5=v_es_multiadd_hdr.total_c5,total_c001=v_es_multiadd_hdr.total_c001,total_c002=v_es_multiadd_hdr.total_c002,
            total_c003=v_es_multiadd_hdr.total_c003,total_c004=v_es_multiadd_hdr.total_c004,total_c005=v_es_multiadd_hdr.total_c005,total_c006=v_es_multiadd_hdr.total_c006,total_c007=v_es_multiadd_hdr.total_c007,
            total_c008=v_es_multiadd_hdr.total_c008, ERROR_MESSAGE = v_es_multiadd_hdr.ERROR_MESSAGE where id = i_es_multi_add_header_id;
        commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
            dbms_output.put_line(o_result_desc); 
          v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','EXCEPTION',o_result_desc,'','', v_seller_num,i_energy_sale_id);
    END;

    v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.VALIDATE','END','','','', v_seller_num,i_energy_sale_id);

  END validate;

  procedure import(i_energy_sale_id in varchar2,i_es_multi_add_header_id in varchar2,  o_result_code out varchar2, o_result_desc out varchar2) AS
   v_created_by varchar2(100):='admin';
   v_log_result  varchar2(50);
   v_reason varchar2(200):='';
   v_exception_code  NUMBER;
   v_exception_msg  VARCHAR2(200);  
   v_es_usage_sum_total  NUMBER:=0;
   v_es_multiadd_hdr T_ES_MULTIADD_HEADER%ROWTYPE;
   v_es_multiadd_line T_ES_MULTIADD_LINE%ROWTYPE;
   v_es T_ENERGY_SALE%ROWTYPE;
   v_es_summary T_ES_USAGE_SUMMARY%ROWTYPE;
   v_es_charge T_ES_CHARGE%ROWTYPE;

  BEGIN
     BEGIN
    -- TODO: Implementation required for procedure ENERGY_SALE_BULK_ALLOTMENT.import
     v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.import','START','Start - '||i_energy_sale_id,'','', sysdate,i_energy_sale_id);
     select * into v_es_multiadd_hdr from t_es_multiadd_header where id=i_es_multi_add_header_id; 
      FOR line IN ( select * into v_es_multiadd_line from T_ES_MULTIADD_LINE where T_ES_MULTIADD_HEADER_ID=v_es_multiadd_hdr.id and is_clean='Y')
          LOOP


         v_es_usage_sum_total:=(to_number(nvl(line.C1,0))+to_number(nvl(line.C2,0))+to_number(nvl(line.C3,0))+to_number(nvl(line.C4,0))+to_number(nvl(line.C5,0)));

         
         update T_ES_USAGE_SUMMARY set c1=trim(round(line.C1,0)) , c2=trim(round(line.C2,0)), c3=trim(round(line.C3,0)), c4=trim(round(line.C4,0)), c5=trim(round(line.C5,0)),total =v_es_usage_sum_total where id=line.t_es_usage_summary_id;
         -- null checked
        -- update T_ES_USAGE_SUMMARY set c1=trim(round(nvl(line.C1,0),0)) , c2=trim(round(nvl(line.C2,0),0)), c3=trim(round(nvl(line.C3,0),0)), c4=trim(round(nvl(line.C4,0),0)), c5=trim(round(nvl(line.C5,0),0)),total =v_es_usage_sum_total where id=line.t_es_usage_summary_id;
         
         if line.c001 is not null then

             update t_es_charge set TOTAL_CHARGE=trim(line.c001) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C001';
         end if;

         if line.c002 is not null then
             update t_es_charge set TOTAL_CHARGE=trim(line.c002) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C002';
         end if;

          if line.c003 is not null then
             update t_es_charge set TOTAL_CHARGE=trim(line.c003) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C003';
         end if;

          if line.c004 is not null then
            update t_es_charge set TOTAL_CHARGE=trim(line.c004) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C004';
         end if;

          if line.c005 is not null then
             update t_es_charge set TOTAL_CHARGE=trim(line.c005) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C005';
         end if;

          if line.c006 is not null then
             update t_es_charge set TOTAL_CHARGE=trim(line.c006) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C006';
         end if;

          if line.c007 is not null then
             update t_es_charge set TOTAL_CHARGE=trim(line.c007) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C007';
         end if;

          if line.c008 is not null then
            update t_es_charge set TOTAL_CHARGE=trim(line.c008) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C008';
         end if;

      if line.c009 is not null then
            update t_es_charge set TOTAL_CHARGE=trim(line.c009) where T_ENERGY_SALE_ID=i_energy_sale_id and M_COMP_SERV_ID = line.M_COMP_SERV_ID  and  CHARGE_CODE= 'C009';
         end if;
        END LOOP;
     UPDATE T_ES_MULTIADD_HEADER set is_completed='Y' where id= i_es_multi_add_header_id;
     commit;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- dbms_output.put_line(o_result_desc);
          v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.import','EXCEPTION',o_result_desc,'','', sysdate,i_energy_sale_id);
    END;

    v_log_result := log_activity('PROCEDURE','ENERGY_SALE_BULK_ALLOTMENT.import','END','Cleared earlier transactions and related orphan records','','', sysdate,i_energy_sale_id);

  END import;

END ENERGY_SALE_BULK_ALLOTMENT;

/
--------------------------------------------------------
--  DDL for Package Body EXCESS_UNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."EXCESS_UNITS" AS

procedure FIND_TYPE (i_service_number in varchar2, o_type out varchar2, o_reason out varchar2)
  is
    v_process varchar2(50):='EXCESS_UNITS.FIND_TYPE';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):='';
    service V_COMPANY_SERVICE%ROWTYPE;
    v_third_party_count number:=0;
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(500);
    v_reason varchar2(200):='';
    v_override_count number:=0;
    v_override_remarks  varchar2(500);
BEGIN
      BEGIN  -- exception handling start

        v_stage:='INIT'; v_message:='START';
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,'', '');
       -- input validation

      IF(i_service_number is null or i_service_number = ''  )   then
        Raise_Application_Error (-20343, 'company-service-number is mandatory  ');
      end if;


        select  companyservice.id, powerplant.FUEL_TYPE_CODE,fueltypecodes.FUEL_GROUP AS FUEL_GROUP_NAME,company.code as M_COMPANY_CODE, powerplant.COMMISSION_DATE , companyservice.comp_ser_type_code
        into service.id, service.FUEL_TYPE_CODE, service.FUEL_GROUP_NAME, service.M_COMPANY_CODE, service.COMMISSION_DATE, service.comp_ser_type_code from m_company_service companyservice
                    left join m_company company on company.id =companyservice.M_COMPANY_ID
                    left join M_POWERPLANT powerplant on  powerplant.M_SERVICE_ID=companyservice.id
                    left join m_fuel fueltypecodes on powerplant.FUEL_TYPE_CODE= fueltypecodes.fuel_code
                            WHERE "number" =  i_service_number;
        select count(*) into v_override_count from m_excess_unit_type_override where m_company_service_num = i_service_number and excess_unit_type in('NA','LAPSED','SURPLUS-STB','BANKING');
        if(v_override_count > 0) then
            select excess_unit_type,nvl(remarks,'NO REMARKS PROVIDED')  into o_type, v_override_remarks from m_excess_unit_type_override where m_company_service_num =i_service_number and rownum=1 and excess_unit_type in('NA','LAPSED','SURPLUS-STB','BANKING');
            o_reason:='Overriden - '||v_override_remarks;
            goto THE_END;
        end if;       
        select  count(*) into v_third_party_count from m_trade_relationship  where m_seller_comp_service_id= service.id and flow_type_code = 'THIRD-PARTY';
        if(v_third_party_count >0) then
            service.IS_THIRD_PARTY := 'Y';
        end if;

        --v_stage:='PROCESS'; v_message:=v_third_party_count ||'-'|| service.FUEL_TYPE_CODE ||'-'|| service.IS_THIRD_PARTY||'-'||service.commission_date;
--v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,'', '');
       
--      select * into service from v_company_service  WHERE "number" =  i_service_number;
      if (service.comp_ser_type_code <> '03') then
             o_type :='NA';
             o_reason :='Not a Seller';
      elsif (service.M_COMPANY_CODE = 'IEX') then
               o_type :='LAPSED';
               o_reason :='Company is IEX';
      elsif (service.FUEL_TYPE_CODE ='WIND')then
            if(service.IS_THIRD_PARTY = 'Y') then
               o_type :='LAPSED';
               o_reason :='Wind and ThirdParty';
            elsif(floor(months_between(sysdate,service.commission_date) /12) > 20) then
               o_type :='LAPSED';
               o_reason :='Wind and commissionDate older than 20 years';
            elsif(service.commission_date is not null and service.commission_date > to_date('01-04-2018','DD-MM-YYYY')) then
               o_type :='SURPLUS-STB';
               o_reason :='Wind and commissionDate > 01-04-2018';
            else
               o_type :='BANKING';
               o_reason :='Wind and commissionDate <= 01-04-2018 and Captive';
            end if;
      elsif (service.FUEL_TYPE_CODE ='SOLAR') then
            if(service.IS_THIRD_PARTY = 'Y') then
               o_type :='LAPSED';
               o_reason :='Solar and Third Party';
            elsif(floor(months_between(sysdate,service.commission_date) /12) > 20) then
               o_type :='LAPSED';
               o_reason :='Solar and commissionDate older than 20 years';
            else
               o_type :='SURPLUS-STB';
               o_reason :='Solar and Captive';
            end if;
      elsif (service.FUEL_GROUP_NAME ='FF') then
               o_type :='LAPSED';
               o_reason :='Thermal';
      else
             o_type :='UNKNOWN';
             o_reason :='Rules didnt match';
      end if;
     

    exception
    when others then
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 200);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,'','');
    END;
    <<THE_END>>
    v_step:='END';
    v_message:=o_type;
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,'','');
END FIND_TYPE;

FUNCTION FIND_TYPE_FN (i_service_number in varchar2)
RETURN varchar2 as
o_type VARCHAR2(100);
O_REASON VARCHAR2(200);
BEGIN
EXCESS_UNITS.FIND_TYPE(
    i_service_number => i_service_number,
    O_TYPE => O_TYPE,
    O_REASON => O_REASON
  );
	RETURN o_type;
END FIND_TYPE_FN;
 

procedure OPEN_BALANCES (i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2)
  is
    v_process varchar2(500):='EXCESS_UNITS.OPEN_BALANCES';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_excess_unit_type varchar2(50):='';    
    v_count number:=0; 
    v_excess_unit  UD_EXCESS_UNIT;
	v_exs_bal V_EXS_BALANCE%ROWTYPE;
	v_banking_bal T_EXS_BANKING_BALANCE%ROWTYPE;
	v_surplus_stb_bal T_EXS_SURPLUS_STB_BALANCE%ROWTYPE;
	v_lapsed_bal T_EXS_LAPSED_BALANCE%ROWTYPE;
    service V_COMPANY_SERVICE%ROWTYPE;
    v_third_party_count number:=0;
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(500);
    v_reason varchar2(200):=''; 
	
BEGIN
    BEGIN  -- exception handling start
		v_stage:='INIT'; v_step:=''; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);

		v_stage:='input validation';
		IF(i_service_number is null or i_service_number = '' or i_service_number = '%' or i_reading_month is null or i_reading_month = '' or i_reading_month is null or i_reading_month = ''  )   then
			--Raise_Application_Error (-20343, 'Input Data not complete!');
            o_result:='FAILURE';
            o_reason:='Input Data not complete! ';
            v_message:=o_result||' - '||o_reason;
            GOTO THE_END;         
		end if; 
        
        -- find the excess-unit-type for the service
        EXCESS_UNITS.FIND_TYPE( i_service_number => i_service_number, O_TYPE => v_excess_unit_type,O_REASON => O_REASON);
          
        -- stop for unsupported excess-unit-types
        if(v_excess_unit_type not in ('BANKING','SURPLUS-STB','LAPSED'  )) then
            o_result:='FAILURE';
            o_reason:='unsupported excess unit type - '||v_excess_unit_type;
            v_message:=o_result||' - '||o_reason;
            GOTO THE_END;            
			--Raise_Application_Error (-20343,v_message);
        end if;
        
       v_stage:='OPEN-BANKING-BALANCE'; v_step:=''; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
       EXCESS_UNITS_HELPER.OPEN_BALANCE('BANKING' , i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason );
       
       v_stage:='OPEN-SURPLUS-STB-BALANCE'; v_step:=''; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
       EXCESS_UNITS_HELPER.OPEN_BALANCE('SURPLUS-STB' , i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason );
       
       v_stage:='OPEN-LAPSED-BALANCE'; v_step:=''; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
       EXCESS_UNITS_HELPER.OPEN_BALANCE('LAPSED' , i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason );
    
    exception
    when others then 
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        -- dbms_output.put_line(o_reason);
    END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
END OPEN_BALANCES;

PROCEDURE INCREASE_BALANCE (i_excess_source in varchar2,i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, i_unit_data in UD_EXCESS_UNIT, o_result out varchar2, o_reason out varchar2)
IS
    v_process varchar2(500):='EXCESS_UNITS.INCREASE_BALANCE';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_excess_unit_type varchar2(50):='';    
    v_count number:=0; 
    v_excess_unit  UD_EXCESS_UNIT;
	v_exs_bal V_EXS_BALANCE%ROWTYPE;
	v_banking_bal T_EXS_BANKING_BALANCE%ROWTYPE;
	v_surplus_stb_bal T_EXS_SURPLUS_STB_BALANCE%ROWTYPE;
	v_lapsed_bal T_EXS_LAPSED_BALANCE%ROWTYPE;
    service V_COMPANY_SERVICE%ROWTYPE;
    v_third_party_count number:=0;
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(500);
    v_balance_exists boolean:=false;
    v_reason varchar2(200):=''; 
BEGIN 
    BEGIN  -- exception handling start
		v_stage:='INIT'; v_step:=''; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        -- find the excess-unit-type for the service
        EXCESS_UNITS.FIND_TYPE(i_service_number, v_excess_unit_type,O_REASON);
        
        v_stage:='CHECK-BALANCE-EXISTS'; v_step:=''; v_message:=''; 
         -- check if balance  exists for current month          
        select count(*) into v_count from V_EXS_BALANCE where EXCESS_UNIT_TYPE = v_excess_unit_type and  READING_MONTH = i_reading_month and READING_YEAR = i_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
        
        -- if doesnt exists create balance
        if(v_count = 0) then
            open_balances(i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason);
        else
            v_balance_exists := true;
        end if;
        select * into v_exs_bal from V_EXS_BALANCE where EXCESS_UNIT_TYPE=v_excess_unit_type and READING_MONTH = i_reading_month and READING_YEAR = i_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
        
        if(i_excess_source = 'EA') then
            select round(nvl(i_unit_data.c1,0),5), round(nvl(i_unit_data.c2,0),5),round(nvl(i_unit_data.c3,0),5),round(nvl(i_unit_data.c4,0),5),round(nvl(i_unit_data.c5,0),5)  ,round(nvl(i_unit_data.total_units,0),5), i_unit_data.remarks,  i_unit_data.SRC_ID, v_process,  i_unit_data.update_dt 
            into v_exs_bal.INCR_EA1_C1, v_exs_bal.INCR_EA1_C2, v_exs_bal.INCR_EA1_C3, v_exs_bal.INCR_EA1_C4, v_exs_bal.INCR_EA1_C5, v_exs_bal.INCR_EA1_TOTAL_UNITS, v_exs_bal.INCR_EA1_REMARKS,v_exs_bal. INCR_EA1_SRC_ID, v_exs_bal.INCR_EA1_UPDATE_BY, v_exs_bal.INCR_EA1_UPDATE_DT from dual;
        else --source is HT
            select round(nvl(i_unit_data.c1,0),5), round(nvl(i_unit_data.c2,0),5),round(nvl(i_unit_data.c3,0),5),round(nvl(i_unit_data.c4,0),5),round(nvl(i_unit_data.c5,0),5)  ,round(nvl(i_unit_data.total_units,0),5),i_unit_data.remarks,  i_unit_data.SRC_ID, v_process,  i_unit_data.update_dt 
            into v_exs_bal.INCR_HT_C1, v_exs_bal.INCR_HT_C2, v_exs_bal.INCR_HT_C3, v_exs_bal.INCR_HT_C4, v_exs_bal.INCR_HT_C5, v_exs_bal.INCR_HT_TOTAL_UNITS, v_exs_bal.INCR_HT_REMARKS,v_exs_bal. INCR_HT_SRC_ID, v_exs_bal.INCR_HT_UPDATE_BY, v_exs_bal.INCR_HT_UPDATE_DT from dual;
         end if;
        
        v_stage:='PROCESS'; v_step:='FORMING OBJECT'; v_message:='id-'||v_exs_bal.id; 
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        EXCESS_UNITS_HELPER.SET_OBJ (v_exs_bal, v_banking_bal ,v_surplus_stb_bal ,v_lapsed_bal);
        
       v_stage:='PROCESS'; v_step:='SAVING TO TABLE'; v_message:='id-'||v_exs_bal.id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        EXCESS_UNITS_HELPER.SAVE_TO_DB (v_excess_unit_type, v_balance_exists, v_banking_bal ,v_surplus_stb_bal ,v_lapsed_bal);
    exception
    when others then 
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        -- dbms_output.put_line(o_reason);
    END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);   

END INCREASE_BALANCE;
PROCEDURE DECREASE_BALANCE (i_excess_source in varchar2,i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, i_unit_data in UD_EXCESS_UNIT, o_result out varchar2, o_reason out varchar2)
IS
    v_process varchar2(500):='EXCESS_UNITS.DECREASE_BALANCE';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_excess_unit_type varchar2(50):='';    
    v_count number:=0; 
    v_excess_unit  UD_EXCESS_UNIT;
	v_exs_bal V_EXS_BALANCE%ROWTYPE;
	v_banking_bal T_EXS_BANKING_BALANCE%ROWTYPE;
	v_surplus_stb_bal T_EXS_SURPLUS_STB_BALANCE%ROWTYPE;
	v_lapsed_bal T_EXS_LAPSED_BALANCE%ROWTYPE;
    service V_COMPANY_SERVICE%ROWTYPE;
    v_third_party_count number:=0;
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(500);
    v_reason varchar2(200):=''; 
    v_balance_exists boolean:=false;
BEGIN 
    BEGIN  -- exception handling start
		v_stage:='INIT'; v_step:=''; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        
        if(i_excess_source <> 'EA') then
            o_result:='FAILURE';
            o_reason:='unsupported source - '||i_excess_source;
            v_message:=o_result||' - '||o_reason;
            GOTO THE_END;
        end if;
        
        
        -- find the excess-unit-type for the service
        EXCESS_UNITS.FIND_TYPE(i_service_number, v_excess_unit_type,O_REASON);
        
        v_stage:='CHECK-BALANCE-EXISTS'; v_step:=''; v_message:=''; 
         -- check if balance  exists for current month          
        select count(*) into v_count from V_EXS_BALANCE where EXCESS_UNIT_TYPE = v_excess_unit_type and  READING_MONTH = i_reading_month and READING_YEAR = i_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
        
        -- if doesnt exists create balance
        if(v_count = 0) then
            open_balances(i_service_number ,i_reading_month ,i_reading_year, o_result , o_reason);
        else
            v_balance_exists :=true;
        end if;
        select * into v_exs_bal from V_EXS_BALANCE where EXCESS_UNIT_TYPE=v_excess_unit_type and READING_MONTH = i_reading_month and READING_YEAR = i_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
        
        --source is assumed as EA
        select round(nvl(i_unit_data.c1,0),5), round(nvl(i_unit_data.c2,0),5),round(nvl(i_unit_data.c3,0),5),round(nvl(i_unit_data.c4,0),5),round(nvl(i_unit_data.c5,0),5)  ,round(nvl(i_unit_data.total_units,0),5), i_unit_data.remarks,  i_unit_data.SRC_ID, v_process,  i_unit_data.update_dt 
        into v_exs_bal.DECR_EA1_C1, v_exs_bal.DECR_EA1_C2, v_exs_bal.DECR_EA1_C3, v_exs_bal.DECR_EA1_C4, v_exs_bal.DECR_EA1_C5, v_exs_bal.DECR_EA1_TOTAL_UNITS, v_exs_bal.DECR_EA1_REMARKS,v_exs_bal. DECR_EA1_SRC_ID, v_exs_bal.DECR_EA1_UPDATE_BY, v_exs_bal.DECR_EA1_UPDATE_DT from dual;        
        
        v_stage:='PROCESS'; v_step:='FORMING OBJECT'; v_message:='id-'||v_exs_bal.id; 
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        EXCESS_UNITS_HELPER.SET_OBJ (v_exs_bal, v_banking_bal ,v_surplus_stb_bal ,v_lapsed_bal);
        
       v_stage:='PROCESS'; v_step:='SAVING TO TABLE'; v_message:='id-'||v_exs_bal.id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        EXCESS_UNITS_HELPER.SAVE_TO_DB (v_excess_unit_type, v_balance_exists, v_banking_bal ,v_surplus_stb_bal ,v_lapsed_bal);
    exception
    when others then 
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        -- dbms_output.put_line(o_reason);
    END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);   

END DECREASE_BALANCE;
PROCEDURE RESET_BALANCES_TO_OPEN_BAL (i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2)
is
    v_process varchar2(500):='EXCESS_UNITS.RESET_BALANCES_TO_OPEN_BAL';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_excess_unit_type varchar2(50):='';     
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(500);
    v_reason varchar2(200):=''; 
BEGIN
    BEGIN  -- exception handling start
		v_stage:='INIT'; v_step:=''; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        v_stage:='RESET_BALANCES_TO_OPEN_BAL'; v_step:=''; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        UPDATE T_EXS_BANKING_BALANCE SET
            INCR_EA1_C1='',INCR_EA1_C2='',INCR_EA1_C3='',INCR_EA1_C4='',INCR_EA1_C5='',INCR_EA1_TOTAL_UNITS='',INCR_EA1_REMARKS='',INCR_EA1_SRC_ID='',INCR_EA1_UPDATE_BY='',INCR_EA1_UPDATE_DT='',
            DECR_EA1_C1='',DECR_EA1_C2='',DECR_EA1_C3='',DECR_EA1_C4='',DECR_EA1_C5='',DECR_EA1_TOTAL_UNITS='',DECR_EA1_REMARKS='',DECR_EA1_SRC_ID='',DECR_EA1_UPDATE_BY='',DECR_EA1_UPDATE_DT='',
            INCR_HT_C1='',INCR_HT_C2='',INCR_HT_C3='',INCR_HT_C4='',INCR_HT_C5='',INCR_HT_TOTAL_UNITS='',INCR_HT_REMARKS='',INCR_HT_SRC_ID='',INCR_HT_UPDATE_BY='',INCR_HT_UPDATE_DT='',
            CURR_C1='',CURR_C2='',CURR_C3='',CURR_C4='',CURR_C5='',CURR_TOTAL_UNITS='',CURR_REMARKS='',CURR_UPDATE_DT='', MODIFIED_BY=v_process, modified_dt=sysdate
        WHERE m_company_service_num = i_service_number AND reading_month = i_reading_month AND reading_year = i_reading_year;
        UPDATE T_EXS_SURPLUS_STB_BALANCE SET
            INCR_EA1_C1='',INCR_EA1_C2='',INCR_EA1_C3='',INCR_EA1_C4='',INCR_EA1_C5='',INCR_EA1_TOTAL_UNITS='',INCR_EA1_REMARKS='',INCR_EA1_SRC_ID='',INCR_EA1_UPDATE_BY='',INCR_EA1_UPDATE_DT='',
            DECR_EA1_C1='',DECR_EA1_C2='',DECR_EA1_C3='',DECR_EA1_C4='',DECR_EA1_C5='',DECR_EA1_TOTAL_UNITS='',DECR_EA1_REMARKS='',DECR_EA1_SRC_ID='',DECR_EA1_UPDATE_BY='',DECR_EA1_UPDATE_DT='',
            INCR_HT_C1='',INCR_HT_C2='',INCR_HT_C3='',INCR_HT_C4='',INCR_HT_C5='',INCR_HT_TOTAL_UNITS='',INCR_HT_REMARKS='',INCR_HT_SRC_ID='',INCR_HT_UPDATE_BY='',INCR_HT_UPDATE_DT='',
            CURR_C1='',CURR_C2='',CURR_C3='',CURR_C4='',CURR_C5='',CURR_TOTAL_UNITS='',CURR_REMARKS='',CURR_UPDATE_DT='', MODIFIED_BY=v_process, modified_dt=sysdate
        WHERE m_company_service_num = i_service_number AND reading_month = i_reading_month AND reading_year = i_reading_year;
        UPDATE T_EXS_LAPSED_BALANCE SET
            INCR_EA1_C1='',INCR_EA1_C2='',INCR_EA1_C3='',INCR_EA1_C4='',INCR_EA1_C5='',INCR_EA1_TOTAL_UNITS='',INCR_EA1_REMARKS='',INCR_EA1_SRC_ID='',INCR_EA1_UPDATE_BY='',INCR_EA1_UPDATE_DT='',
            DECR_EA1_C1='',DECR_EA1_C2='',DECR_EA1_C3='',DECR_EA1_C4='',DECR_EA1_C5='',DECR_EA1_TOTAL_UNITS='',DECR_EA1_REMARKS='',DECR_EA1_SRC_ID='',DECR_EA1_UPDATE_BY='',DECR_EA1_UPDATE_DT='',
            INCR_HT_C1='',INCR_HT_C2='',INCR_HT_C3='',INCR_HT_C4='',INCR_HT_C5='',INCR_HT_TOTAL_UNITS='',INCR_HT_REMARKS='',INCR_HT_SRC_ID='',INCR_HT_UPDATE_BY='',INCR_HT_UPDATE_DT='',
            CURR_C1='',CURR_C2='',CURR_C3='',CURR_C4='',CURR_C5='',CURR_TOTAL_UNITS='',CURR_REMARKS='',CURR_UPDATE_DT='', MODIFIED_BY=v_process, modified_dt=sysdate
        WHERE m_company_service_num = i_service_number AND reading_month = i_reading_month AND reading_year = i_reading_year;
        
        COMMIT;
    exception
    when others then 
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        -- dbms_output.put_line(o_reason);
    END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
END RESET_BALANCES_TO_OPEN_BAL;
PROCEDURE DELETE_BALANCES (i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2)
 is
    v_process varchar2(500):='EXCESS_UNITS.DELETE_BALANCES';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(500);
    v_reason varchar2(200):=''; 
BEGIN
    BEGIN  -- exception handling start
		v_stage:='INIT'; v_step:=''; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        v_stage:='DELETE-ALL-BALANCES'; v_step:=''; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        DELETE FROM T_EXS_BANKING_BALANCE WHERE m_company_service_num = i_service_number AND reading_month = i_reading_month AND reading_year = i_reading_year;
        DELETE FROM T_EXS_SURPLUS_STB_BALANCE WHERE m_company_service_num = i_service_number AND reading_month = i_reading_month AND reading_year = i_reading_year;
        DELETE FROM T_EXS_LAPSED_BALANCE WHERE m_company_service_num = i_service_number AND reading_month = i_reading_month AND reading_year = i_reading_year;
        
        COMMIT;
    exception
    when others then 
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        -- dbms_output.put_line(o_reason);
    END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
END DELETE_BALANCES;
END EXCESS_UNITS;

/
--------------------------------------------------------
--  DDL for Package Body EXCESS_UNITS_HELPER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."EXCESS_UNITS_HELPER" AS

PROCEDURE CREATE_NEW_OBJ (i_excess_unit_type in varchar2, i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_exs_bal out V_EXS_BALANCE%ROWTYPE)
  is
    v_process varchar2(50):='EXCESS_UNITS_HELPER.CREATE_NEW_OBJ';
    V_NEW_ID varchar2(50);
BEGIN
    -- create id
    CASE i_excess_unit_type
        WHEN 'BANKING' THEN
			V_NEW_ID := T_EXS_BANKING_BALANCE_SEQ.nextval;
        WHEN 'SURPLUS-STB' THEN
			V_NEW_ID := T_EXS_SURPLUS_STB_BALANCE_SEQ.nextval;
        WHEN 'LAPSED' THEN
			V_NEW_ID := T_EXS_LAPSED_BALANCE_SEQ.nextval;
	END CASE ;
    	-- set basic values 
	select  V_NEW_ID, i_excess_unit_type , i_reading_month ,i_reading_year ,  i_service_number, '0', '0', '0', '0', '0', '0', v_process, sysdate,v_process, sysdate, 'Y'
		into o_exs_bal.ID, o_exs_bal.excess_unit_type,o_exs_bal.reading_month,o_exs_bal.reading_year, o_exs_bal.M_COMPANY_SERVICE_NUM, 
		o_exs_bal.open_c1, o_exs_bal.open_c2, o_exs_bal.open_c3, o_exs_bal.open_c4, o_exs_bal.open_c5, o_exs_bal.open_total_units,o_exs_bal.open_update_by,o_exs_bal.open_update_dt, o_exs_bal.CREATED_BY, o_exs_bal.CREATED_DT, o_exs_bal.enabled  FROM dual;
	 
	-- set service values
	SELECT SER.M_COMPANY_ID,SER.M_COMPANY_NAME,SER.ID , SER.BANKING_SERVICE_ID,SER.BANKING_SERVICE_NUMBER,SER.FUEL_TYPE_CODE    
		into o_exs_bal.M_COMPANY_ID, o_exs_bal.M_COMPANY_NAME, o_exs_bal.M_COMPANY_SERVICE_ID, o_exs_bal.BANKING_SERVICE_ID, o_exs_bal.BANKING_SERVICE_NUM, o_exs_bal.FUEL_TYPE_CODE
		from V_COMPANY_SERVICE SER where SER."number" = i_service_number; 
 
END CREATE_NEW_OBJ;

PROCEDURE CREATE_OBJ_FROM_PREV_MONTH(i_excess_unit_type in varchar2, i_reading_month in varchar2,i_reading_year in varchar2, i_prev_bal in V_EXS_BALANCE%ROWTYPE, o_curr_bal out V_EXS_BALANCE%ROWTYPE)
  is
    v_process varchar2(50):='EXCESS_UNITS_HELPER.CREATE_OBJ_FROM_PREV_MONTH';
    V_NEW_ID varchar2(50);

BEGIN
    -- create id
    CASE i_excess_unit_type
        WHEN 'BANKING' THEN
			V_NEW_ID := T_EXS_BANKING_BALANCE_SEQ.nextval;
        WHEN 'SURPLUS-STB' THEN
			V_NEW_ID := T_EXS_SURPLUS_STB_BALANCE_SEQ.nextval;
        WHEN 'LAPSED' THEN
			V_NEW_ID := T_EXS_LAPSED_BALANCE_SEQ.nextval;
	END CASE;

	-- set basic values 
	select  V_NEW_ID, i_excess_unit_type , i_reading_month ,i_reading_year ,i_prev_bal.M_COMPANY_SERVICE_NUM, greatest(ROUND(NVL(i_prev_bal.CURR_C1,0),5),0) OPEN_C1,greatest(ROUND(NVL(i_prev_bal.CURR_C2,0),5),0) OPEN_C2,greatest(ROUND(NVL(i_prev_bal.CURR_C3,0),5),0) OPEN_C3,greatest(ROUND(NVL(i_prev_bal.CURR_C4,0),5),0) OPEN_C4,greatest(ROUND(NVL(i_prev_bal.CURR_C5,0),5),0) OPEN_C5,v_process, sysdate, v_process, sysdate, 'Y'
		into o_curr_bal.ID, o_curr_bal.excess_unit_type,o_curr_bal.reading_month,o_curr_bal.reading_year,o_curr_bal.M_COMPANY_SERVICE_NUM, 
		o_curr_bal.open_c1, o_curr_bal.open_c2, o_curr_bal.open_c3, o_curr_bal.open_c4, o_curr_bal.open_c5,o_curr_bal.open_update_by, o_curr_bal.OPEN_UPDATE_DT, o_curr_bal.CREATED_BY, o_curr_bal.CREATED_DT, o_curr_bal.enabled  FROM dual;
    select o_curr_bal.open_c1+ o_curr_bal.open_c2+ o_curr_bal.open_c3+ o_curr_bal.open_c4+ o_curr_bal.open_c5 into o_curr_bal.open_total_units from dual;
	-- set service values
	SELECT SER.M_COMPANY_ID,SER.M_COMPANY_NAME,SER.ID , SER.BANKING_SERVICE_ID,SER.BANKING_SERVICE_NUMBER,SER.FUEL_TYPE_CODE   
		into o_curr_bal.M_COMPANY_ID, o_curr_bal.M_COMPANY_NAME, o_curr_bal.M_COMPANY_SERVICE_ID, o_curr_bal.BANKING_SERVICE_ID, o_curr_bal.BANKING_SERVICE_NUM, o_curr_bal.FUEL_TYPE_CODE
		from V_COMPANY_SERVICE SER where SER."number" = o_curr_bal.M_COMPANY_SERVICE_NUM ;
        
END CREATE_OBJ_FROM_PREV_MONTH;
PROCEDURE SET_OBJ (i_obj in V_EXS_BALANCE%ROWTYPE,  o_banking_bal out T_EXS_BANKING_BALANCE%ROWTYPE, o_surplus_stb_bal out T_EXS_SURPLUS_STB_BALANCE%ROWTYPE, o_lapsed_bal out T_EXS_LAPSED_BALANCE%ROWTYPE)
  is
BEGIN 
     CASE i_obj.excess_unit_type
        WHEN 'BANKING' THEN
            select i_obj.ID,i_obj.READING_MONTH,i_obj.READING_YEAR,i_obj.M_COMPANY_ID,i_obj.M_COMPANY_NAME,i_obj.M_COMPANY_SERVICE_ID,i_obj.M_COMPANY_SERVICE_NUM,i_obj.BANKING_SERVICE_ID,i_obj.BANKING_SERVICE_NUM,
            i_obj.OPEN_C1,i_obj.OPEN_C2,i_obj.OPEN_C3,i_obj.OPEN_C4,i_obj.OPEN_C5,i_obj.OPEN_TOTAL_UNITS,i_obj.OPEN_REMARKS,i_obj.OPEN_UPDATE_DT,
            i_obj.INCR_EA1_C1,i_obj.INCR_EA1_C2,i_obj.INCR_EA1_C3,i_obj.INCR_EA1_C4,i_obj.INCR_EA1_C5,i_obj.INCR_EA1_TOTAL_UNITS,i_obj.INCR_EA1_REMARKS,i_obj.INCR_EA1_SRC_ID,i_obj.INCR_EA1_UPDATE_DT,
            i_obj.DECR_EA1_C1,i_obj.DECR_EA1_C2,i_obj.DECR_EA1_C3,i_obj.DECR_EA1_C4,i_obj.DECR_EA1_C5,i_obj.DECR_EA1_TOTAL_UNITS,i_obj.DECR_EA1_REMARKS,i_obj.DECR_EA1_SRC_ID,i_obj.DECR_EA1_UPDATE_DT,
            i_obj.INCR_HT_C1,i_obj.INCR_HT_C2,i_obj.INCR_HT_C3,i_obj.INCR_HT_C4,i_obj.INCR_HT_C5,i_obj.INCR_HT_TOTAL_UNITS,i_obj.INCR_HT_REMARKS,i_obj.INCR_HT_SRC_ID,i_obj.INCR_HT_UPDATE_DT,
            i_obj.CURR_C1,i_obj.CURR_C2,i_obj.CURR_C3,i_obj.CURR_C4,i_obj.CURR_C5,i_obj.CURR_TOTAL_UNITS,i_obj.CURR_REMARKS,i_obj.CURR_UPDATE_DT,
            i_obj.REMARKS,i_obj.CREATED_BY,i_obj.CREATED_DT,i_obj.MODIFIED_BY,i_obj.MODIFIED_DT,i_obj.ENABLED,i_obj.FUEL_TYPE_CODE
            into 
            o_banking_bal.ID,o_banking_bal.READING_MONTH,o_banking_bal.READING_YEAR,o_banking_bal.M_COMPANY_ID,o_banking_bal.M_COMPANY_NAME,o_banking_bal.M_COMPANY_SERVICE_ID,o_banking_bal.M_COMPANY_SERVICE_NUM,o_banking_bal.BANKING_SERVICE_ID,o_banking_bal.BANKING_SERVICE_NUM,
            o_banking_bal.OPEN_C1,o_banking_bal.OPEN_C2,o_banking_bal.OPEN_C3,o_banking_bal.OPEN_C4,o_banking_bal.OPEN_C5,o_banking_bal.OPEN_TOTAL_UNITS,o_banking_bal.OPEN_REMARKS,o_banking_bal.OPEN_UPDATE_DT,
            o_banking_bal.INCR_EA1_C1,o_banking_bal.INCR_EA1_C2,o_banking_bal.INCR_EA1_C3,o_banking_bal.INCR_EA1_C4,o_banking_bal.INCR_EA1_C5,o_banking_bal.INCR_EA1_TOTAL_UNITS,o_banking_bal.INCR_EA1_REMARKS,o_banking_bal.INCR_EA1_SRC_ID,o_banking_bal.INCR_EA1_UPDATE_DT,
            o_banking_bal.DECR_EA1_C1,o_banking_bal.DECR_EA1_C2,o_banking_bal.DECR_EA1_C3,o_banking_bal.DECR_EA1_C4,o_banking_bal.DECR_EA1_C5,o_banking_bal.DECR_EA1_TOTAL_UNITS,o_banking_bal.DECR_EA1_REMARKS,o_banking_bal.DECR_EA1_SRC_ID,o_banking_bal.DECR_EA1_UPDATE_DT,
            o_banking_bal.INCR_HT_C1,o_banking_bal.INCR_HT_C2,o_banking_bal.INCR_HT_C3,o_banking_bal.INCR_HT_C4,o_banking_bal.INCR_HT_C5,o_banking_bal.INCR_HT_TOTAL_UNITS,o_banking_bal.INCR_HT_REMARKS,o_banking_bal.INCR_HT_SRC_ID,o_banking_bal.INCR_HT_UPDATE_DT,
            o_banking_bal.CURR_C1,o_banking_bal.CURR_C2,o_banking_bal.CURR_C3,o_banking_bal.CURR_C4,o_banking_bal.CURR_C5,o_banking_bal.CURR_TOTAL_UNITS,o_banking_bal.CURR_REMARKS,o_banking_bal.CURR_UPDATE_DT,
            o_banking_bal.REMARKS,o_banking_bal.CREATED_BY,o_banking_bal.CREATED_DT,o_banking_bal.MODIFIED_BY,o_banking_bal.MODIFIED_DT,o_banking_bal.ENABLED,o_banking_bal.FUEL_TYPE_CODE
            from dual;
        WHEN  'SURPLUS-STB' THEN
            select i_obj.ID,i_obj.READING_MONTH,i_obj.READING_YEAR,i_obj.M_COMPANY_ID,i_obj.M_COMPANY_NAME,i_obj.M_COMPANY_SERVICE_ID,i_obj.M_COMPANY_SERVICE_NUM,i_obj.BANKING_SERVICE_ID,i_obj.BANKING_SERVICE_NUM,
            i_obj.OPEN_C1,i_obj.OPEN_C2,i_obj.OPEN_C3,i_obj.OPEN_C4,i_obj.OPEN_C5,i_obj.OPEN_TOTAL_UNITS,i_obj.OPEN_REMARKS,i_obj.OPEN_UPDATE_DT,
            i_obj.INCR_EA1_C1,i_obj.INCR_EA1_C2,i_obj.INCR_EA1_C3,i_obj.INCR_EA1_C4,i_obj.INCR_EA1_C5,i_obj.INCR_EA1_TOTAL_UNITS,i_obj.INCR_EA1_REMARKS,i_obj.INCR_EA1_SRC_ID,i_obj.INCR_EA1_UPDATE_DT,
            i_obj.DECR_EA1_C1,i_obj.DECR_EA1_C2,i_obj.DECR_EA1_C3,i_obj.DECR_EA1_C4,i_obj.DECR_EA1_C5,i_obj.DECR_EA1_TOTAL_UNITS,i_obj.DECR_EA1_REMARKS,i_obj.DECR_EA1_SRC_ID,i_obj.DECR_EA1_UPDATE_DT,
            i_obj.INCR_HT_C1,i_obj.INCR_HT_C2,i_obj.INCR_HT_C3,i_obj.INCR_HT_C4,i_obj.INCR_HT_C5,i_obj.INCR_HT_TOTAL_UNITS,i_obj.INCR_HT_REMARKS,i_obj.INCR_HT_SRC_ID,i_obj.INCR_HT_UPDATE_DT,
            i_obj.CURR_C1,i_obj.CURR_C2,i_obj.CURR_C3,i_obj.CURR_C4,i_obj.CURR_C5,i_obj.CURR_TOTAL_UNITS,i_obj.CURR_REMARKS,i_obj.CURR_UPDATE_DT,
            i_obj.REMARKS,i_obj.CREATED_BY,i_obj.CREATED_DT,i_obj.MODIFIED_BY,i_obj.MODIFIED_DT,i_obj.ENABLED,i_obj.FUEL_TYPE_CODE
            into 
            o_surplus_stb_bal.ID,o_surplus_stb_bal.READING_MONTH,o_surplus_stb_bal.READING_YEAR,o_surplus_stb_bal.M_COMPANY_ID,o_surplus_stb_bal.M_COMPANY_NAME,o_surplus_stb_bal.M_COMPANY_SERVICE_ID,o_surplus_stb_bal.M_COMPANY_SERVICE_NUM,o_surplus_stb_bal.BANKING_SERVICE_ID,o_surplus_stb_bal.BANKING_SERVICE_NUM,
            o_surplus_stb_bal.OPEN_C1,o_surplus_stb_bal.OPEN_C2,o_surplus_stb_bal.OPEN_C3,o_surplus_stb_bal.OPEN_C4,o_surplus_stb_bal.OPEN_C5,o_surplus_stb_bal.OPEN_TOTAL_UNITS,o_surplus_stb_bal.OPEN_REMARKS,o_surplus_stb_bal.OPEN_UPDATE_DT,
            o_surplus_stb_bal.INCR_EA1_C1,o_surplus_stb_bal.INCR_EA1_C2,o_surplus_stb_bal.INCR_EA1_C3,o_surplus_stb_bal.INCR_EA1_C4,o_surplus_stb_bal.INCR_EA1_C5,o_surplus_stb_bal.INCR_EA1_TOTAL_UNITS,o_surplus_stb_bal.INCR_EA1_REMARKS,o_surplus_stb_bal.INCR_EA1_SRC_ID,o_surplus_stb_bal.INCR_EA1_UPDATE_DT,
            o_surplus_stb_bal.DECR_EA1_C1,o_surplus_stb_bal.DECR_EA1_C2,o_surplus_stb_bal.DECR_EA1_C3,o_surplus_stb_bal.DECR_EA1_C4,o_surplus_stb_bal.DECR_EA1_C5,o_surplus_stb_bal.DECR_EA1_TOTAL_UNITS,o_surplus_stb_bal.DECR_EA1_REMARKS,o_surplus_stb_bal.DECR_EA1_SRC_ID,o_surplus_stb_bal.DECR_EA1_UPDATE_DT,
            o_surplus_stb_bal.INCR_HT_C1,o_surplus_stb_bal.INCR_HT_C2,o_surplus_stb_bal.INCR_HT_C3,o_surplus_stb_bal.INCR_HT_C4,o_surplus_stb_bal.INCR_HT_C5,o_surplus_stb_bal.INCR_HT_TOTAL_UNITS,o_surplus_stb_bal.INCR_HT_REMARKS,o_surplus_stb_bal.INCR_HT_SRC_ID,o_surplus_stb_bal.INCR_HT_UPDATE_DT,
            o_surplus_stb_bal.CURR_C1,o_surplus_stb_bal.CURR_C2,o_surplus_stb_bal.CURR_C3,o_surplus_stb_bal.CURR_C4,o_surplus_stb_bal.CURR_C5,o_surplus_stb_bal.CURR_TOTAL_UNITS,o_surplus_stb_bal.CURR_REMARKS,o_surplus_stb_bal.CURR_UPDATE_DT,
            o_surplus_stb_bal.REMARKS,o_surplus_stb_bal.CREATED_BY,o_surplus_stb_bal.CREATED_DT,o_surplus_stb_bal.MODIFIED_BY,o_surplus_stb_bal.MODIFIED_DT,o_surplus_stb_bal.ENABLED,o_surplus_stb_bal.FUEL_TYPE_CODE
            from dual;
        WHEN  'LAPSED' THEN
            select i_obj.ID,i_obj.READING_MONTH,i_obj.READING_YEAR,i_obj.M_COMPANY_ID,i_obj.M_COMPANY_NAME,i_obj.M_COMPANY_SERVICE_ID,i_obj.M_COMPANY_SERVICE_NUM,i_obj.BANKING_SERVICE_ID,i_obj.BANKING_SERVICE_NUM,
            i_obj.OPEN_C1,i_obj.OPEN_C2,i_obj.OPEN_C3,i_obj.OPEN_C4,i_obj.OPEN_C5,i_obj.OPEN_TOTAL_UNITS,i_obj.OPEN_REMARKS,i_obj.OPEN_UPDATE_DT,
            i_obj.INCR_EA1_C1,i_obj.INCR_EA1_C2,i_obj.INCR_EA1_C3,i_obj.INCR_EA1_C4,i_obj.INCR_EA1_C5,i_obj.INCR_EA1_TOTAL_UNITS,i_obj.INCR_EA1_REMARKS,i_obj.INCR_EA1_SRC_ID,i_obj.INCR_EA1_UPDATE_DT,
            i_obj.DECR_EA1_C1,i_obj.DECR_EA1_C2,i_obj.DECR_EA1_C3,i_obj.DECR_EA1_C4,i_obj.DECR_EA1_C5,i_obj.DECR_EA1_TOTAL_UNITS,i_obj.DECR_EA1_REMARKS,i_obj.DECR_EA1_SRC_ID,i_obj.DECR_EA1_UPDATE_DT,
            i_obj.INCR_HT_C1,i_obj.INCR_HT_C2,i_obj.INCR_HT_C3,i_obj.INCR_HT_C4,i_obj.INCR_HT_C5,i_obj.INCR_HT_TOTAL_UNITS,i_obj.INCR_HT_REMARKS,i_obj.INCR_HT_SRC_ID,i_obj.INCR_HT_UPDATE_DT,
            i_obj.CURR_C1,i_obj.CURR_C2,i_obj.CURR_C3,i_obj.CURR_C4,i_obj.CURR_C5,i_obj.CURR_TOTAL_UNITS,i_obj.CURR_REMARKS,i_obj.CURR_UPDATE_DT,
            i_obj.REMARKS,i_obj.CREATED_BY,i_obj.CREATED_DT,i_obj.MODIFIED_BY,i_obj.MODIFIED_DT,i_obj.ENABLED,i_obj.FUEL_TYPE_CODE
            into 
            o_lapsed_bal.ID,o_lapsed_bal.READING_MONTH,o_lapsed_bal.READING_YEAR,o_lapsed_bal.M_COMPANY_ID,o_lapsed_bal.M_COMPANY_NAME,o_lapsed_bal.M_COMPANY_SERVICE_ID,o_lapsed_bal.M_COMPANY_SERVICE_NUM,o_lapsed_bal.BANKING_SERVICE_ID,o_lapsed_bal.BANKING_SERVICE_NUM,
            o_lapsed_bal.OPEN_C1,o_lapsed_bal.OPEN_C2,o_lapsed_bal.OPEN_C3,o_lapsed_bal.OPEN_C4,o_lapsed_bal.OPEN_C5,o_lapsed_bal.OPEN_TOTAL_UNITS,o_lapsed_bal.OPEN_REMARKS,o_lapsed_bal.OPEN_UPDATE_DT,
            o_lapsed_bal.INCR_EA1_C1,o_lapsed_bal.INCR_EA1_C2,o_lapsed_bal.INCR_EA1_C3,o_lapsed_bal.INCR_EA1_C4,o_lapsed_bal.INCR_EA1_C5,o_lapsed_bal.INCR_EA1_TOTAL_UNITS,o_lapsed_bal.INCR_EA1_REMARKS,o_lapsed_bal.INCR_EA1_SRC_ID,o_lapsed_bal.INCR_EA1_UPDATE_DT,
            o_lapsed_bal.DECR_EA1_C1,o_lapsed_bal.DECR_EA1_C2,o_lapsed_bal.DECR_EA1_C3,o_lapsed_bal.DECR_EA1_C4,o_lapsed_bal.DECR_EA1_C5,o_lapsed_bal.DECR_EA1_TOTAL_UNITS,o_lapsed_bal.DECR_EA1_REMARKS,o_lapsed_bal.DECR_EA1_SRC_ID,o_lapsed_bal.DECR_EA1_UPDATE_DT,
            o_lapsed_bal.INCR_HT_C1,o_lapsed_bal.INCR_HT_C2,o_lapsed_bal.INCR_HT_C3,o_lapsed_bal.INCR_HT_C4,o_lapsed_bal.INCR_HT_C5,o_lapsed_bal.INCR_HT_TOTAL_UNITS,o_lapsed_bal.INCR_HT_REMARKS,o_lapsed_bal.INCR_HT_SRC_ID,o_lapsed_bal.INCR_HT_UPDATE_DT,
            o_lapsed_bal.CURR_C1,o_lapsed_bal.CURR_C2,o_lapsed_bal.CURR_C3,o_lapsed_bal.CURR_C4,o_lapsed_bal.CURR_C5,o_lapsed_bal.CURR_TOTAL_UNITS,o_lapsed_bal.CURR_REMARKS,o_lapsed_bal.CURR_UPDATE_DT,
            o_lapsed_bal.REMARKS,o_lapsed_bal.CREATED_BY,o_lapsed_bal.CREATED_DT,o_lapsed_bal.MODIFIED_BY,o_lapsed_bal.MODIFIED_DT,o_lapsed_bal.ENABLED,o_lapsed_bal.FUEL_TYPE_CODE
            from dual;
    END CASE;
END SET_OBJ;
PROCEDURE SAVE_TO_DB (i_excess_unit_type in varchar2,i_balance_exists in boolean,  i_banking_bal IN T_EXS_BANKING_BALANCE%ROWTYPE, i_surplus_stb_bal IN T_EXS_SURPLUS_STB_BALANCE%ROWTYPE, i_lapsed_bal in T_EXS_LAPSED_BALANCE%ROWTYPE  )
  is
BEGIN 
        CASE i_excess_unit_type
            WHEN 'BANKING' THEN
                if (i_balance_exists)then
                    update T_EXS_BANKING_BALANCE set row = i_banking_bal where id=i_banking_bal.id;
                else
                    insert into T_EXS_BANKING_BALANCE VALUES i_banking_bal;
                end if;
            WHEN 'SURPLUS-STB' THEN
                if (i_balance_exists)then
                    update T_EXS_SURPLUS_STB_BALANCE set row = i_surplus_stb_bal where id=i_surplus_stb_bal.id;
                else
                    insert into T_EXS_SURPLUS_STB_BALANCE VALUES i_surplus_stb_bal;
                end if;
            WHEN 'LAPSED' THEN
                if (i_balance_exists)then
                    update T_EXS_LAPSED_BALANCE set row = i_lapsed_bal where id=i_lapsed_bal.id;
                else
                    insert into T_EXS_LAPSED_BALANCE VALUES i_lapsed_bal;
                end if;
        END CASE;
        
END SAVE_TO_DB;
procedure OPEN_BALANCE (i_excess_unit_type in varchar2, i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result out varchar2, o_reason out varchar2)
 is
    v_process varchar2(50):='EXCESS_UNITS_HELPER.OPEN_BALANCE';
    v_process_type varchar2(50):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_log_result  varchar2(500);
    v_count number;
	v_prev_reading_month varchar2(10):='';
	v_prev_reading_year varchar2(10):='';
	v_prev_bal V_EXS_BALANCE%ROWTYPE;
	v_curr_bal V_EXS_BALANCE%ROWTYPE;
	v_banking_bal T_EXS_BANKING_BALANCE%ROWTYPE;
	v_surplus_stb_bal T_EXS_SURPLUS_STB_BALANCE%ROWTYPE;
	v_lapsed_bal T_EXS_LAPSED_BALANCE%ROWTYPE;
 BEGIN
    BEGIN
    
		v_stage:='INIT'; v_step:=i_excess_unit_type|| '-START'; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
		v_prev_reading_month := to_char(to_date( '01-'||i_reading_month||'-'||i_reading_year,'dd-mm-yyyy')-1,'mm');
		v_prev_reading_year := to_char(to_date( '01-'||i_reading_month||'-'||i_reading_year,'dd-mm-yyyy')-1,'yyyy');
		
        v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-check if balance already exists for current month '; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
       -- check if balance already exists for current month 
        select count(*) into v_count from V_EXS_BALANCE where EXCESS_UNIT_TYPE=i_excess_unit_type and READING_MONTH = i_reading_month and READING_YEAR = i_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
        
        -- exit if balance already exists for current month
        if(v_count > 0) then
            o_result:='FAILURE';
            o_reason:='balance already exists for '||i_excess_unit_type;
            GOTO THE_END;
        end if;
       
       v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-checking  previous month balance'; v_message:=''; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
       -- check if balance exists for previous month 
        select count(*) into v_count from V_EXS_BALANCE where EXCESS_UNIT_TYPE=i_excess_unit_type and READING_MONTH = v_prev_reading_month and READING_YEAR = v_prev_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
        
        
       v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-checking  previous month balance'; v_message:=' balancecount-'||v_count; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        if(i_reading_month='04') THEN
       		v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-reset balance for April'; v_message:='id-'||v_curr_bal.id; 
			v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
	
        	-- reset the balances in April month
            CREATE_NEW_OBJ(i_excess_unit_type, i_service_number, i_reading_month, i_reading_year, v_curr_bal);
        elsif(v_count>0) then
            -- fetch the previous month's record 
            select * into v_prev_bal from V_EXS_BALANCE where EXCESS_UNIT_TYPE=i_excess_unit_type and READING_MONTH = v_prev_reading_month and READING_YEAR = v_prev_reading_year and M_COMPANY_SERVICE_NUM = i_service_number ;
            CREATE_OBJ_FROM_PREV_MONTH(i_excess_unit_type, i_reading_month, i_reading_year, v_prev_bal, v_curr_bal);
        else        
            CREATE_NEW_OBJ(i_excess_unit_type, i_service_number, i_reading_month, i_reading_year, v_curr_bal);
        end if;
        
        
       v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-created balance object'; v_message:='id-'||v_curr_bal.id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        SET_OBJ (v_curr_bal, v_banking_bal ,v_surplus_stb_bal ,v_lapsed_bal);
        
        
       v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-set to specific object'; v_message:='id-'||v_curr_bal.id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
        
        CASE i_excess_unit_type
            WHEN 'BANKING' THEN
                insert into T_EXS_BANKING_BALANCE VALUES v_banking_bal;
            WHEN 'SURPLUS-STB' THEN
                insert into T_EXS_SURPLUS_STB_BALANCE VALUES v_surplus_stb_bal;
            WHEN 'LAPSED' THEN
                insert into T_EXS_LAPSED_BALANCE VALUES v_lapsed_bal;
        END CASE;
            
       v_stage:='PROCESS'; v_step:=i_excess_unit_type|| '-inserted into balance table'; v_message:='id-'||v_curr_bal.id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
    exception
    when others then
        v_stage:='EXCEPTION';
        v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
        v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
    END;
    <<THE_END>>
    commit;
    v_stage:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
end OPEN_BALANCE;
END EXCESS_UNITS_HELPER;

/
--------------------------------------------------------
--  DDL for Package Body EXCESS_UNITS_SOURCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."EXCESS_UNITS_SOURCE" AS

  procedure update_excess_from_ea(V_ES_ID in varchar2, o_result_code out varchar2, o_result_desc out varchar2)  
  
    IS
    v_process varchar2(500):='EXCESS_UNITS_SOURCE.UPDATE_EXCESS_FROM_EA';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):=''; 
    v_excess_unit_type varchar2(50):='';    
    v_count number:=0; 
    v_service_number varchar2(50);
    v_reading_month  varchar2(50);
    v_reading_year varchar2(50);
    v_ea  t_energy_sale%rowtype;
    v_unit_data  UD_EXCESS_UNIT;
	v_exs_bal V_EXS_BALANCE%ROWTYPE;
	v_banking_bal T_EXS_BANKING_BALANCE%ROWTYPE;
	v_surplus_stb_bal T_EXS_SURPLUS_STB_BALANCE%ROWTYPE;
	v_lapsed_bal T_EXS_LAPSED_BALANCE%ROWTYPE;
    v_serv V_COMPANY_SERVICE%ROWTYPE;  
    v_log_result  varchar2(500);
    v_exs_decrease_result  varchar2(50);
    v_exs_increase_result  varchar2(50);
    v_reason varchar2(200):=''; 
    BEGIN 
        BEGIN  -- exception handling start
            v_stage:='INIT'; v_step:=''; v_message:='START'; 
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,V_ES_ID,'','');
            
            select * into v_ea from t_energy_sale where id= V_ES_ID;
            select * into v_serv from v_company_service where id = v_ea.seller_comp_serv_id;
            v_service_number := v_serv."number"; v_reading_month := v_ea.MONTH;  v_reading_year := v_ea.YEAR; 
            v_excess_unit_type:=v_serv.excess_unit_type;
            
             
            find_excess_consumed_in_ea(v_ea, v_excess_unit_type ,v_reading_month ,v_reading_year, v_unit_data,v_exs_decrease_result , v_reason);
            if(v_exs_decrease_result = 'YES') then
                excess_units.decrease_balance ('EA',v_service_number ,v_reading_month ,v_reading_year , v_unit_data , o_result_code , o_result_desc );  
            end if;
            
            find_excess_produced_in_ea(v_ea, v_excess_unit_type ,v_reading_month ,v_reading_year, v_unit_data,v_exs_increase_result , v_reason);
            if(v_exs_increase_result = 'YES') then
                excess_units.increase_balance ('EA',v_service_number ,v_reading_month ,v_reading_year , v_unit_data ,  o_result_code , o_result_desc );            
            end if;
            
            if(v_exs_decrease_result = 'NO' and v_exs_increase_result = 'NO') then                            
                o_result_code:='FAILURE';
                o_result_desc:='no excess activity';
                v_message := o_result_code||' - '||o_result_desc;
                GOTO THE_END;
            END IF;
            /*
            if increase condition
                logic
            */
        exception
        when others then 
            v_stage:='EXCEPTION';
            v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,V_ES_ID,'','');
            -- dbms_output.put_line(o_reason);
        END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,V_ES_ID,'','');

    END update_excess_from_ea;

  procedure update_excess_from_ht(i_service_number in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_result_code out varchar2, o_result_desc out varchar2) 
  IS
    v_process varchar2(500):='EXCESS_UNITS_SOURCE.update_excess_from_ht';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):='';  
    v_reason varchar2(200):=''; 
    v_log_result varchar2(200):=''; 
    v_serv V_COMPANY_SERVICE%ROWTYPE;  
    v_unit_data  UD_EXCESS_UNIT;
    BEGIN 
        BEGIN  
            v_stage:='INIT'; v_step:=''; v_message:='START'; 
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
            o_result_code:='NO';            
            v_unit_data := UD_EXCESS_UNIT(0,0,0,0,0,0,'','','');            
            
            FOR supplier in (  select ser."number" SUPLR_CODE, ser.M_COMPANY_ID,ser.BANKING_SERVICE_ID, READING_MNTH, READING_YR,sum(nvl(s.C1_WITHLOSS,0)) c1_wl, sum(nvl(s.C2_WITHLOSS,0)) c2_wl,sum(nvl(s.C3_WITHLOSS,0)) c3_wl, sum(nvl(s.C4_WITHLOSS,0)) c4_wl,sum(nvl(s.C5_WITHLOSS,0)) c5_wl 
                                from  F_ENERGY_ADJUSTMET s join m_company_service ser on ser."number"=s.suplr_code  where READING_MNTH=i_reading_month and READING_YR=i_reading_year 
                                and ser."number"=i_service_number
                                group by ser."number" ,ser.M_COMPANY_ID,ser.BANKING_SERVICE_ID,READING_MNTH, READING_YR)
              loop
              begin
                SELECT * INTO v_serv FROM V_COMPANY_SERVICE WHERE "number"=i_service_number;
                v_unit_data.c1 :=0; v_unit_data.c2 :=0; v_unit_data.c3 :=0; v_unit_data.c4 :=0; v_unit_data.c5 :=0;v_unit_data.total_units :=0;              
                                 
                IF TO_NUMBER(nvl(supplier.c1_wl,0))>0 THEN v_unit_data.c1 := TO_NUMBER(nvl(supplier.c1_wl,0)); o_result_code:='YES';   END IF;
                IF TO_NUMBER(nvl(supplier.c2_wl,0))>0 THEN v_unit_data.c2 := TO_NUMBER(nvl(supplier.c2_wl,0)); o_result_code:='YES';   END IF;
                IF TO_NUMBER(nvl(supplier.c3_wl,0))>0 THEN v_unit_data.c3 := TO_NUMBER(nvl(supplier.c3_wl,0)); o_result_code:='YES';   END IF;
                IF TO_NUMBER(nvl(supplier.c4_wl,0))>0 THEN v_unit_data.c4 := TO_NUMBER(nvl(supplier.c4_wl,0)); o_result_code:='YES';   END IF;
                IF TO_NUMBER(nvl(supplier.c5_wl,0))>0 THEN v_unit_data.c5 := TO_NUMBER(nvl(supplier.c5_wl,0)); o_result_code:='YES';   END IF;
                if( o_result_code='YES') then            
                    v_unit_data.total_units := v_unit_data.c1 + v_unit_data.c2 + v_unit_data.c3 + v_unit_data.c4 + v_unit_data.c5;
                end if;            
                v_unit_data.UPDATE_DT := sysdate; --v_unit_data.UPDATE_BY := v_process;
                excess_units.increase_balance ('HT',i_service_number ,i_reading_month ,i_reading_year , v_unit_data ,  o_result_code , o_result_desc );            
                    
           exception
            when others then
            v_stage:='EXCEPTION-INNER';
            v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message, supplier.SUPLR_CODE,i_reading_month, i_reading_year);
               UPDATE F_ENERGY_ADJUSTMET SET imported='N', import_remarks=o_result_desc where READING_MNTH=i_reading_month and READING_YR=i_reading_year and SUPLR_CODE = supplier.SUPLR_CODE;
           END;
          END LOOP; 
        
         exception
        when others then 
            v_stage:='EXCEPTION-OUTER';
            v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
            -- dbms_output.put_line(o_reason);
        END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_service_number,i_reading_month, i_reading_year);
  END update_excess_from_ht;

  procedure find_excess_consumed_in_ea( i_ea in t_energy_sale%rowtype, i_excess_unit_type in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_unit_data out UD_EXCESS_UNIT, o_result_code out varchar2, o_result_desc out varchar2) 
    IS
    v_process varchar2(500):='EXCESS_UNITS_SOURCE.find_excess_consumed_in_ea';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):='';  
    v_reason varchar2(200):=''; 
    v_log_result varchar2(200):=''; 
    BEGIN 
        BEGIN  
            o_result_code:='NO';            
            o_unit_data := UD_EXCESS_UNIT(0,0,0,0,0,0,'','','');                       
            
            if(i_excess_unit_type in ('LAPSED','SURPLUS-STB')) then Raise_Application_Error (-20343, 'Invalid scenario'); end if;
            
            IF TO_NUMBER(nvl(i_ea.BC1,0))>0 THEN o_unit_data.c1 := TO_NUMBER(nvl(i_ea.BC1,0)); o_result_code:='YES';   END IF;
            IF TO_NUMBER(nvl(i_ea.BC2,0))>0 THEN o_unit_data.c2 := TO_NUMBER(nvl(i_ea.BC2,0)); o_result_code:='YES';   END IF;
            IF TO_NUMBER(nvl(i_ea.BC3,0))>0 THEN o_unit_data.c3 := TO_NUMBER(nvl(i_ea.BC3,0)); o_result_code:='YES';   END IF;
            IF TO_NUMBER(nvl(i_ea.BC4,0))>0 THEN o_unit_data.c4 := TO_NUMBER(nvl(i_ea.BC4,0)); o_result_code:='YES';   END IF;
            IF TO_NUMBER(nvl(i_ea.BC5,0))>0 THEN o_unit_data.c5 := TO_NUMBER(nvl(i_ea.BC5,0)); o_result_code:='YES';   END IF;
            if( o_result_code='YES') then            
                o_unit_data.total_units := o_unit_data.c1 + o_unit_data.c2 + o_unit_data.c3 + o_unit_data.c4 + o_unit_data.c5;
            end if;
            o_unit_data.SRC_ID := i_ea.id; o_unit_data.UPDATE_DT := sysdate; --o_unit_data.UPDATED_BY := v_process;
         exception
        when others then 
            v_stage:='EXCEPTION';
            v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_ea.id,'','');
            -- dbms_output.put_line(o_reason);
        END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_ea.id,o_result_code,''); 
  END find_excess_consumed_in_ea;

  procedure find_excess_produced_in_ea(i_ea in t_energy_sale%rowtype, i_excess_unit_type in varchar2,i_reading_month in varchar2,i_reading_year in varchar2, o_unit_data out UD_EXCESS_UNIT, o_result_code out varchar2, o_result_desc out varchar2)
  IS
    v_process varchar2(500):='EXCESS_UNITS_SOURCE.find_excess_produced_in_ea';
    v_process_type varchar2(500):='PACKAGE';
    v_stage varchar2(500):='';
    v_step varchar2(500):='';
    v_message varchar2(500):='';  
    v_reason varchar2(200):=''; 
    v_log_result varchar2(200):=''; 
    BEGIN 
        BEGIN  
            o_result_code:='NO';            
            o_unit_data := UD_EXCESS_UNIT(0,0,0,0,0,0,'','','');                       
            
            IF TO_NUMBER(nvl(i_ea.AVAIL_GC1,0))  > TO_NUMBER(nvl(i_ea.GC1,0)) THEN 
                o_unit_data.c1:=(TO_NUMBER(nvl(i_ea.AVAIL_GC1,0)) - TO_NUMBER(nvl(i_ea.GC1,0))); 
                if i_excess_unit_type ='BANKING' then
                    o_unit_data.c1 :=o_unit_data.c1 -(o_unit_data.c1 *0.14);  
                end if;
                o_result_code:='YES';   
            END IF; 
            IF TO_NUMBER(nvl(i_ea.AVAIL_GC2,0))  > TO_NUMBER(nvl(i_ea.GC2,0)) THEN 
                o_unit_data.c2:=(TO_NUMBER(nvl(i_ea.AVAIL_GC2,0)) - TO_NUMBER(nvl(i_ea.GC2,0))); 
                if i_excess_unit_type ='BANKING' then 
                    o_unit_data.c2 :=o_unit_data.c2 -(o_unit_data.c2 *0.14);    
                end if;
                o_result_code:='YES';   
            END IF; 
            IF TO_NUMBER(nvl(i_ea.AVAIL_GC3,0))  > TO_NUMBER(nvl(i_ea.GC3,0)) THEN 
                o_unit_data.c3:=(TO_NUMBER(nvl(i_ea.AVAIL_GC3,0)) - TO_NUMBER(nvl(i_ea.GC3,0)));  
                if i_excess_unit_type ='BANKING' then
                    o_unit_data.c3 :=o_unit_data.c3 -(o_unit_data.c3 *0.14);    
                end if;
                o_result_code:='YES';   
            END IF; 
            IF TO_NUMBER(nvl(i_ea.AVAIL_GC4,0))  > TO_NUMBER(nvl(i_ea.GC4,0)) THEN 
                o_unit_data.c4:=(TO_NUMBER(nvl(i_ea.AVAIL_GC4,0)) - TO_NUMBER(nvl(i_ea.GC4,0)));  
                if i_excess_unit_type ='BANKING' then
                    o_unit_data.c4 :=o_unit_data.c4 -(o_unit_data.c4 *0.14);    
                end if;
                o_result_code:='YES';   
            END IF; 
            IF TO_NUMBER(nvl(i_ea.AVAIL_GC5,0))  > TO_NUMBER(nvl(i_ea.GC5,0)) THEN 
                o_unit_data.c5:=(TO_NUMBER(nvl(i_ea.AVAIL_GC5,0)) - TO_NUMBER(nvl(i_ea.GC5,0)));  
                if i_excess_unit_type ='BANKING' then
                    o_unit_data.c5 :=o_unit_data.c5 -(o_unit_data.c5 *0.14);    
                end if;
                o_result_code:='YES';   
            END IF; 
            if( o_result_code='YES') then            
                o_unit_data.c1 := round(o_unit_data.c1,0);
                o_unit_data.c2 := round(o_unit_data.c2,0);
                o_unit_data.c3 := round(o_unit_data.c3,0);
                o_unit_data.c4 := round(o_unit_data.c4,0);
                o_unit_data.c5 := round(o_unit_data.c5,0);
                o_unit_data.total_units := o_unit_data.c1 + o_unit_data.c2 + o_unit_data.c3 + o_unit_data.c4 + o_unit_data.c5;
            end if;
            o_unit_data.SRC_ID := i_ea.id; o_unit_data.UPDATE_DT := sysdate;-- o_unit_data.UPDATE_BY := v_process;
         exception
        when others then 
            v_stage:='EXCEPTION';
            v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 100);
            v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_ea.id,'','');
            -- dbms_output.put_line(o_reason);
        END;
    <<THE_END>>
    v_stage:='END'; v_step:='END';
    v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,i_ea.id,'','');
  END find_excess_produced_in_ea;

END EXCESS_UNITS_SOURCE;

/
--------------------------------------------------------
--  DDL for Package Body GENERATION_STATEMENT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."GENERATION_STATEMENT" AS

  
    PROCEDURE CREATE_BY_BATCH_ID(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
	v_process varchar2(50):='GENERATION_STATEMENT.CREATE_BY_BATCH_ID';
	v_process_type varchar2(500):='FUNCTION';
	v_stage varchar2(500):='';
	v_step varchar2(500):='';
	v_message varchar2(500):='';
    v_log_result  varchar2(50);
    v_process_id  VARCHAR2(50);
    v_create_stb_result varchar2(50);
    v_result varchar(300):='SUCCESS';
    v_records_processed number:=0; 
    V_TRADE_REL_COUNT varchar2(50); 
    v_prev_reading_month varchar2(10);
    v_prev_reading_year varchar2(10);
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    	O_RESULT_CODE:='';
		v_stage:='INIT'; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,'', '');
		if (I_BATCH_KEY is null or I_BATCH_KEY = '')then
            Raise_Application_Error (-20343, 'Batch is mandatory  '); 
        end if;
		-- all gen-stmts created will be marked with v_process_id for creating STB and other purpose
    	v_process_id := T_PROCESS_GS_SEQ.nextval; 
    	v_stage:='PROCESS'; v_message:='input validation complete. processId-'+v_process_id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,'', '');
	   	
        FOR mr IN (SELECT mh.id,mh.INIT_READING_DT,mh.M_GEN_STMT_ID GEN_STMT_ID,mh.M_COMPANY_METER_ID,mh.READING_MONTH,mh.READING_YEAR, ser."number" service_number 
                    FROM T_METER_READING_HDR mh  
      				JOIN v_company_service ser ON  ser.m_company_meter_id=mh.m_company_meter_id and ser.enabled='Y' 
                    WHERE mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL
                    and nvl(mh.MERGE_WITH_NEXT_BILLING,'N') = 'N' 
                    and mh.imp_batch_id = I_BATCH_KEY  AND ser.TYPE_OF_SS !='SECTION 10(1)SS')
        LOOP
	         -- skip this meter. reason unclear.
	        IF(mr.M_COMPANY_METER_ID='262208' ) THEN CONTINUE; END IF;
	          
	    	v_stage:='PROCESS'; v_message:='import surplus and open balance for service-'||mr.service_number; 
			v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,'', '');
		
	        v_prev_reading_month := to_char(to_date( '01-'||mr.READING_MONTH  ||'-'||mr.READING_YEAR ,'dd-mm-yyyy')-1,'mm');
	        v_prev_reading_year := to_char(to_date( '01-'||mr.READING_MONTH  ||'-'||mr.READING_YEAR,'dd-mm-yyyy')-1,'yyyy');
	        excess_units_source.update_excess_from_ht(mr.service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
	        excess_units.open_balances(mr.service_number,mr.READING_MONTH,mr.READING_YEAR,O_RESULT_CODE,O_RESULT_DESC ); 
	    
	       	v_stage:='PROCESS'; v_message:='creating GS for service'||mr.service_number||'. mr-'||mr.id; 
			v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,'', '');
		
	    	v_result := create_gs_from_mr( v_process_id,mr.id);
	    
	        if (v_result='SUCCESS') then
	            v_records_processed := v_records_processed +1;
	        end if; 
        END LOOP;

     if(v_records_processed > 0)then
       	v_stage:='PROCESS'; v_message:='creating STBs'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,'', '');
        for new_mr in (select mh.id,mh.INIT_READING_DT, mh.M_GEN_STMT_ID, meter.M_COMPANY_SERVICE_ID from t_meter_reading_hdr mh LEFT JOIN M_COMPANY_METER meter on mh.M_COMPANY_METER_ID = meter.id  where mh.gs_batch_id = v_process_id)
        loop
          SELECT COUNT(*) INTO V_TRADE_REL_COUNT FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = new_mr.M_COMPANY_SERVICE_ID AND M_BUYER_COMPANY_ID = 'TNEB' AND new_mr.INIT_READING_DT BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
          IF V_TRADE_REL_COUNT>0 THEN
            v_create_stb_result := CREATE_STB(new_mr.M_GEN_STMT_ID);
          END IF;
        end loop;
     end if;

    exception
        when others then
        v_stage:='EXCEPTION';
		v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 200);
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,O_RESULT_CODE, O_RESULT_DESC); 
    	O_RESULT_CODE:='FAILURE';
	    O_RESULT_DESC := v_message;
    END;--EXCEPTION ENDS HERE

    update T_PROCESS_GS set status='COMPLETED', remarks='PROCESSED-RECORD-COUNT:'||v_records_processed, end_dt=sysdate where id = v_process_id;
   
	O_RESULT_CODE:='FAILURE';
    O_RESULT_DESC := v_message;
   	v_stage:='End'; v_message:='PROCESSED-RECORD-COUNT:'||v_records_processed; 
	v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_BATCH_KEY,O_RESULT_CODE, O_RESULT_DESC);
    COMMIT;

  END CREATE_BY_BATCH_ID;
 
    PROCEDURE CREATE_BY_MONTH_YR(i_org_id IN VARCHAR2, i_month IN VARCHAR2,i_year IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    BEGIN
	    NULL;
	END CREATE_BY_MONTH_YR;

    PROCEDURE CREATE_MR_INTERNAL(i_101ss_filter IN boolean, i_batch_key IN varchar2, i_org_id IN VARCHAR2, i_service_number IN varchar2, i_substation_id IN varchar2, i_month IN VARCHAR2,i_year IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
		v_process varchar2(50):='GENERATION_STATEMENT.CREATE_MR_INTERNAL';
		v_process_type varchar2(500):='PACKAGE';
		v_stage varchar2(500):='';
		v_step varchar2(500):='';
		v_message varchar2(500):='';
	    v_log_result  varchar2(50);
	    v_process_id  VARCHAR2(50);
	    v_create_stb_result varchar2(50);
	    v_result varchar(300):='SUCCESS';
	    v_records_processed number:=0; 
	    V_TRADE_REL_COUNT varchar2(50); 
	    v_prev_reading_month varchar2(10);
	    v_prev_reading_year varchar2(10);
		v_org_id varchar2(50);
		v_batch_key varchar2(50);
		v_service_number varchar2(50);
		v_substation_id varchar2(50);
		v_month varchar2(50);
		v_year varchar2(50); 
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    	O_RESULT_CODE:='';
		v_stage:='INIT'; v_message:='START'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR, '');
	
        if(i_batch_key IS NULL or i_batch_key='')THEN  v_batch_key := '%'; END IF;
        if(i_org_id IS NULL or i_org_id='')THEN  v_org_id := '%'; END IF;
        if(i_service_number IS NULL or i_service_number='')THEN  v_service_number := '%'; END IF;
        if(i_substation_id IS NULL or i_substation_id='')THEN  v_substation_id := '%'; END IF;
        if(i_month IS NULL or i_month='')THEN  v_month := '%'; END IF;
        if(i_year IS NULL or i_year='')THEN  v_year := '%'; END IF;
       
		-- all gen-stmts created will be marked with v_process_id for creating STB and other purpose
    	v_process_id := T_PROCESS_GS_SEQ.nextval; 
    	v_stage:='PROCESS'; v_message:='input validation complete. processId-'+v_process_id; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR, '');
	   	
        FOR mr IN (SELECT mh.id,mh.INIT_READING_DT,mh.M_GEN_STMT_ID GEN_STMT_ID,mh.M_COMPANY_METER_ID,mh.READING_MONTH,mh.READING_YEAR, ser."number" service_number 
                    FROM T_METER_READING_HDR mh  
      				JOIN v_company_service ser ON  ser.m_company_meter_id=mh.m_company_meter_id and ser.enabled='Y' 
                    WHERE mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL AND ser.M_ORG_ID LIKE v_org_id
                    AND READING_MONTH = I_MONTH AND READING_YEAR = I_YEAR  AND ser.TYPE_OF_SS !='SECTION 10(1)SS')
        LOOP
	         -- skip this meter. reason unclear.
	        IF(mr.M_COMPANY_METER_ID='262208' ) THEN CONTINUE; END IF;
	          
	    	v_stage:='PROCESS'; v_message:='import surplus and open balance for service-'||mr.service_number; 
			v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR, '');
		
	        v_prev_reading_month := to_char(to_date( '01-'||mr.READING_MONTH  ||'-'||mr.READING_YEAR ,'dd-mm-yyyy')-1,'mm');
	        v_prev_reading_year := to_char(to_date( '01-'||mr.READING_MONTH  ||'-'||mr.READING_YEAR,'dd-mm-yyyy')-1,'yyyy');
	        excess_units_source.update_excess_from_ht(mr.service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
	        excess_units.open_balances(mr.service_number,mr.READING_MONTH,mr.READING_YEAR,O_RESULT_CODE,O_RESULT_DESC ); 
	    
	       	v_stage:='PROCESS'; v_message:='creating GS for service'||mr.service_number||'. mr-'||mr.id; 
			v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR, '');
		
	    	v_result := create_gs_from_mr( v_process_id,mr.id);
	    
	        if (v_result='SUCCESS') then
	            v_records_processed := v_records_processed +1;
	        end if; 
        END LOOP;

     if(v_records_processed > 0)then
       	v_stage:='PROCESS'; v_message:='creating STBs'; 
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR, '');
        for new_mr in (select mh.id,mh.INIT_READING_DT, mh.M_GEN_STMT_ID, meter.M_COMPANY_SERVICE_ID from t_meter_reading_hdr mh LEFT JOIN M_COMPANY_METER meter on mh.M_COMPANY_METER_ID = meter.id  where mh.gs_batch_id = v_process_id)
        loop
          SELECT COUNT(*) INTO V_TRADE_REL_COUNT FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = new_mr.M_COMPANY_SERVICE_ID AND M_BUYER_COMPANY_ID = 'TNEB' AND new_mr.INIT_READING_DT BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
          IF V_TRADE_REL_COUNT>0 THEN
            v_create_stb_result := CREATE_STB(new_mr.M_GEN_STMT_ID);
          END IF;
        end loop;
     end if;

    exception
        when others then
        v_stage:='EXCEPTION';
		v_message := SQLCODE || ' - ' ||  SUBSTR(SQLERRM, 1, 200);
		v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR,O_RESULT_CODE); 
    	O_RESULT_CODE:='FAILURE';
	    O_RESULT_DESC := v_message;
    END;--EXCEPTION ENDS HERE

    update T_PROCESS_GS set status='COMPLETED', remarks='PROCESSED-RECORD-COUNT:'||v_records_processed, end_dt=sysdate where id = v_process_id;
   
	O_RESULT_CODE:='FAILURE';
    O_RESULT_DESC := v_message;
   	v_stage:='End'; v_message:='PROCESSED-RECORD-COUNT:'||v_records_processed; 
	v_log_result := log_activity(v_process_type,v_process,v_stage,v_step,v_message,I_MONTH,I_YEAR,O_RESULT_CODE); 
    COMMIT;

  	END CREATE_MR_INTERNAL;


    PROCEDURE CREATE_WITH_SS_LOSS(I_SUBSTATION_ID IN VARCHAR2 default null,I_SERVICE_NUMBER IN VARCHAR2 default null,I_ORG_ID IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_service_number varchar2(50);
    v_result varchar(300):='SUCCESS';
    v_records_processed number:=0;
    v_process_id  VARCHAR2(50);
    v_created_Date DATE := SYSDATE;
    V_TRADE_REL_COUNT varchar2(50);
    v_create_stb_result varchar2(50);
    v_loss_percent number :=0;
    v_Service_count number :=0;
    v_seller_service_id varchar2(200);
    v_commission_date Date;
    v_prev_reading_month varchar2(10);
    v_prev_reading_year varchar2(10);
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','I_SUBSTATION_ID-'||I_SUBSTATION_ID,'Start - '||I_ORG_ID,'','', sysdate,I_ORG_ID);

   -------------------------------------------------------- LOGIC
        v_process_id := T_PROCESS_GS_SEQ.nextval;
        INSERT INTO T_PROCESS_GS (ID,SYS_DT,STATUS,START_DT,END_DT,REMARKS)
        VALUES (v_process_id,v_created_Date,'PROCESSING',v_created_Date,NULL,NULL);
---------------------------------
        if I_SERVICE_NUMBER is null and I_SUBSTATION_ID is null then
            FOR mr IN (SELECT mh.id, mh.m_company_meter_id,ser.m_substation_id FROM T_METER_READING_HDR mh LEFT JOIN V_COMPANY_SERVICE ser on mh.m_company_meter_id=ser.m_company_meter_id WHERE READING_MONTH = I_MONTH AND READING_YEAR = I_YEAR AND ser.m_org_id=I_ORG_ID and ser.type_of_ss='SECTION 10(1)SS')

            LOOP
            BEGIN --EXCEPTION STARTS HERE
            v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','ORG-WISE','v_loss_percent - '||v_loss_percent,'','', sysdate,I_ORG_ID);
            SELECT LOSS_PERCENT into v_loss_percent FROM (SELECT * FROM T_SUBSTATION_LOSS where m_substation_id=mr.m_substation_id ORDER BY id DESC) WHERE ROWNUM = 1;
--            SELECT LOSS_PERCENT into v_loss_percent FROM T_SUBSTATION_LOSS WHERE m_org_id=I_ORG_ID AND MONTH=I_MONTH AND YEAR=I_YEAR AND m_substation_id=mr.m_substation_id;
                v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','v_loss_percent','v_loss_percent - '||v_loss_percent,'','', sysdate,I_ORG_ID);

            select "number",id into v_service_number,v_seller_service_id from v_company_service where m_company_meter_id=mr.m_company_meter_id; 

            DELETE_TXN.DELETE_BY_SERVICE('CREATE_WITH_SS_LOSS'||v_created_Date,v_service_number,I_MONTH,I_YEAR,'Y','Y','Y','N',O_RESULT_CODE,O_RESULT_DESC);
            
            v_prev_reading_month := to_char(to_date( '01-'||I_MONTH ||'-'||I_YEAR,'dd-mm-yyyy')-1,'mm');
            v_prev_reading_year := to_char(to_date( '01-'||I_MONTH ||'-'||I_YEAR,'dd-mm-yyyy')-1,'yyyy');
            excess_units_source.update_excess_from_ht(v_service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
            excess_units.open_balances(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC  );
            
            --IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_service_number,'04' ,'2019',O_RESULT_CODE,O_RESULT_DESC);
              --if  v_commission_date is not null and v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
               --  BANKING_BALANCE.open_balance(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC);
            --end if;
            v_result:=CREATE_FROM_MR(v_process_id,mr.id,v_loss_percent);

        if (v_result='SUCCESS') then
            v_records_processed := v_records_processed +1;
        end if;
        exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','EXCEPTION-inloop',O_RESULT_DESC,'','', sysdate,I_ORG_ID);
        END;--EXCEPTION ENDS HERE
        END LOOP;
   ----------------------------------------------------     
   ELSIF I_SERVICE_NUMBER is not null then
   SELECT count(*) into v_Service_count FROM V_COMPANY_SERVICE WHERE "number"=I_SERVICE_NUMBER;
   if v_Service_count=1 then
        v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','I_SERVICE_NUMBER','v_Service_count - '||v_Service_count,I_SERVICE_NUMBER,'', sysdate,I_ORG_ID);

               FOR mr IN (SELECT mh.id, mh.m_company_meter_id,ser.m_substation_id FROM T_METER_READING_HDR mh LEFT JOIN V_COMPANY_SERVICE ser on mh.m_company_meter_id=ser.m_company_meter_id WHERE READING_MONTH = I_MONTH AND READING_YEAR = I_YEAR AND ser.m_org_id=I_ORG_ID and ser.type_of_ss='SECTION 10(1)SS' and ser."number"=I_SERVICE_NUMBER)

            LOOP
            BEGIN --EXCEPTION STARTS HERE
            v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','SERVICE-WISE','v_loss_percent - '||v_loss_percent,'','', sysdate,I_ORG_ID);
            SELECT LOSS_PERCENT into v_loss_percent FROM (SELECT * FROM T_SUBSTATION_LOSS where m_substation_id=mr.m_substation_id ORDER BY id DESC) WHERE ROWNUM = 1;
--            SELECT LOSS_PERCENT into v_loss_percent FROM T_SUBSTATION_LOSS WHERE m_org_id=I_ORG_ID AND MONTH=I_MONTH AND YEAR=I_YEAR AND m_substation_id=mr.m_substation_id;
                v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','v_loss_percent','v_loss_percent - '||v_loss_percent,'','', sysdate,I_ORG_ID);

            select "number",id into v_service_number,v_seller_service_id from v_company_service where m_company_meter_id=mr.m_company_meter_id; 
            DELETE_TXN.DELETE_BY_SERVICE('CREATE_WITH_SS_LOSS'||v_created_Date,v_service_number,I_MONTH,I_YEAR,'Y','Y','Y','N',O_RESULT_CODE,O_RESULT_DESC);
            
            v_prev_reading_month := to_char(to_date( '01-'||I_MONTH ||'-'||I_YEAR,'dd-mm-yyyy')-1,'mm');
            v_prev_reading_year := to_char(to_date( '01-'||I_MONTH ||'-'||I_YEAR,'dd-mm-yyyy')-1,'yyyy');
            excess_units_source.update_excess_from_ht(v_service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
            excess_units.open_balances(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC  );
            --IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_service_number,'04' ,'2019',O_RESULT_CODE,O_RESULT_DESC);
             --if  v_commission_date is not null and v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
             --   BANKING_BALANCE.open_balance(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC);   
            --end if;
            v_result:=CREATE_FROM_MR(v_process_id,mr.id,v_loss_percent);

        if (v_result='SUCCESS') then
            v_records_processed := v_records_processed +1;
        end if;
        exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','EXCEPTION-inloop',O_RESULT_DESC,'','', sysdate,I_ORG_ID);
        END;--EXCEPTION ENDS HERE
        END LOOP;
     end if;

        ----------------------------------------------------     
   ELSIF I_SUBSTATION_ID is not null and I_ORG_ID is not null then
               FOR mr IN (SELECT mh.id, mh.m_company_meter_id,ser.m_substation_id FROM T_METER_READING_HDR mh LEFT JOIN V_COMPANY_SERVICE ser on mh.m_company_meter_id=ser.m_company_meter_id WHERE READING_MONTH = I_MONTH AND READING_YEAR = I_YEAR AND ser.m_org_id=I_ORG_ID and ser.type_of_ss='SECTION 10(1)SS' and ser.m_substation_id=I_SUBSTATION_ID)

            LOOP
            BEGIN --EXCEPTION STARTS HERE
            v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','SUBSTATION-WISE','v_loss_percent - '||v_loss_percent,'','', sysdate,I_ORG_ID);
            SELECT LOSS_PERCENT into v_loss_percent FROM (SELECT * FROM T_SUBSTATION_LOSS where m_substation_id=mr.m_substation_id ORDER BY id DESC) WHERE ROWNUM = 1;
--            SELECT LOSS_PERCENT into v_loss_percent FROM T_SUBSTATION_LOSS WHERE m_org_id=I_ORG_ID AND MONTH=I_MONTH AND YEAR=I_YEAR AND m_substation_id=mr.m_substation_id;
                v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','v_loss_percent','v_loss_percent - '||v_loss_percent,'','', sysdate,I_ORG_ID);

            select "number" into v_service_number from v_company_service where m_company_meter_id=mr.m_company_meter_id; 
            DELETE_TXN.DELETE_BY_SERVICE('CREATE_WITH_SS_LOSS'||v_created_Date,v_service_number,I_MONTH,I_YEAR,'Y','Y','Y','N',O_RESULT_CODE,O_RESULT_DESC);
            
            v_prev_reading_month := to_char(to_date( '01-'||I_MONTH ||'-'||I_YEAR,'dd-mm-yyyy')-1,'mm');
            v_prev_reading_year := to_char(to_date( '01-'||I_MONTH ||'-'||I_YEAR,'dd-mm-yyyy')-1,'yyyy');
            excess_units_source.update_excess_from_ht(v_service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
            excess_units.open_balances(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC  );
           -- IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_service_number,'04' ,'2019',O_RESULT_CODE,O_RESULT_DESC);
           -- if  v_commission_date is not null and v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
           -- BANKING_BALANCE.open_balance(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC);   
           -- end if;
            v_result:=CREATE_FROM_MR(v_process_id,mr.id,v_loss_percent);

        if (v_result='SUCCESS') then
            v_records_processed := v_records_processed +1;
        end if;
        exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','EXCEPTION-inloop',O_RESULT_DESC,'','', sysdate,I_ORG_ID);
        END;--EXCEPTION ENDS HERE
        END LOOP;
    end if;
        ----------------------------------------------------------------------
    if(v_records_processed > 0)then
    for new_mr in (select mh.id,mh.INIT_READING_DT, mh.M_GEN_STMT_ID, meter.M_COMPANY_SERVICE_ID from t_meter_reading_hdr mh LEFT JOIN M_COMPANY_METER meter on mh.M_COMPANY_METER_ID = meter.id  where mh.gs_batch_id = v_process_id)
    loop
      SELECT COUNT(*) INTO V_TRADE_REL_COUNT FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = new_mr.M_COMPANY_SERVICE_ID AND M_BUYER_COMPANY_ID = 'TNEB' AND new_mr.INIT_READING_DT BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
      IF V_TRADE_REL_COUNT>0 THEN
        v_create_stb_result := CREATE_STB(new_mr.M_GEN_STMT_ID);
      END IF;
    end loop;
    end if;
   --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_ORG_ID);
    END;--EXCEPTION ENDS HERE
        update T_PROCESS_GS set status='COMPLETED', remarks='PROCESSED-RECORD-COUNT:'||v_records_processed, end_dt=sysdate where id = v_process_id;
        v_log_result := log_activity('PROCEDURE','GENERATION_STATEMENT.CREATE_WITH_SS_LOSS','CREATE_WITH_SS_LOSS','END - '||I_ORG_ID,'','', sysdate,I_ORG_ID);
        commit;

  END CREATE_WITH_SS_LOSS;


 FUNCTION CREATE_FROM_MR
(
  v_gs_process_id in varchar2,
  v_mr_id in varchar2,
  i_ss_loss_percent in number default 0
) RETURN VARCHAR2 AS 

v_stage varchar2(50);
v_process_id  VARCHAR2(50); 
v_gen_count  NUMBER:=0;
v_mrh T_METER_READING_HDR%ROWTYPE;
v_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_mr_c5 T_METER_READING_SLOT%ROWTYPE;
v_gs T_GEN_STMT%ROWTYPE;
v_gs_c1 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c2 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c3 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c4 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c5 T_GEN_STMT_SLOT%ROWTYPE;
v_no_records BOOLEAN:=TRUE;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='';
v_plant_class_code VARCHAR2(200);
v_plant_class_desc VARCHAR2(200);
v_gen_month  VARCHAR2(50); 
v_gen_year  VARCHAR2(50); 
v_gen_comp_servi_id VARCHAR2(200);
tariff_rates VARCHAR2(200);
v_log_result varchar(300):='SUCCESS';
v_imported BOOLEAN;

v_gen_voltage_desc VARCHAR2(50); 
v_gen_org_code VARCHAR2(50); 
v_gen_iscaptive VARCHAR2(50); 
v_gen_isstb VARCHAR2(50);
v_gen_isstb_count NUMBER; 
v_gen_ssid VARCHAR2(50) ;
v_gen_ssname  VARCHAR2(50);
v_gen_sstype  VARCHAR2(50);
v_gen_ffid   VARCHAR2(50);
v_gen_ffname VARCHAR2(50);
v_tariff_net_amount VARCHAR2(150);  
v_net_payable VARCHAR2(150);
v_total_charged_amount  VARCHAR2(150);
v_flow_type_code  VARCHAR2(150);
v_c1_exp_ss_loss number:=0;
v_c2_exp_ss_loss number:=0;
v_c3_exp_ss_loss number:=0;
v_c4_exp_ss_loss number:=0;
v_c5_exp_ss_loss number:=0;
v_total_exp_ss_loss number:=0;
v_total_net number:=0;
v_total_exp number:=0;
v_prev_mr_id varchar2(50);
v_prev_mr T_METER_READING_HDR%ROWTYPE;
v_prev_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c5 T_METER_READING_SLOT%ROWTYPE;
v_mhr_count number:=0;

BEGIN

	BEGIN	
        v_stage := '-1-start';
        v_log_result := log_activity('PROCEDURE','create_gs_from_mr','Start',v_reason,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

		FOR meter IN (SELECT distinct mh.M_COMPANY_METER_ID, mh.READING_MONTH, mh.READING_YEAR,mh.MR_SOURCE_CODE SOURCE_CODE,
						nvl(bg.open_c1,0) bc1, nvl(bg.OPEN_C2,0) bc2, nvl(bg.OPEN_C3,0) bc3,nvl(bg.OPEN_C4,0) bc4,nvl(bg.OPEN_C5,0) bc5,  pp.status disp_pp_op_status, cs.capacity disp_capacity, cs.total_capacity  disp_total_capacity, cm.meter_number disp_meter_number,
						cs.M_ORG_ID, c.ID M_COMPANY_ID,cm.M_COMPANY_SERVICE_ID, c.NAME DISP_COMPANY_NAME, cs."number" DISP_SERVICE_NUMBER, cs.VOLTAGE_CODE INJECTING_VOLTAGE_CODE, o.NAME DISP_ORG_NAME,tr.flow_type_code,
						pp.FUEL_TYPE_CODE DISP_FUEL_TYPE_CODE, fuel.FUEL_NAME  DISP_FUEL_TYPE_NAME,fuel.FUEL_GROUP DISP_FUEL_TYPE_GROUP,pp.COMMISSION_DATE COMMISSION_DATE,cs.IS_REC IS_REC,cs.TOTAL_CAPACITY TOTAL_CAPACITY, excess_units.FIND_TYPE_FN(cs."number") excess_unit_type
						FROM T_METER_READING_HDR mh 
						INNER JOIN M_COMPANY_METER cm ON mh.M_COMPANY_METER_ID = cm.ID
						INNER JOIN M_COMPANY_SERVICE cs ON cm.M_COMPANY_SERVICE_ID = cs.id
						INNER JOIN M_COMPANY c ON cs.M_COMPANY_ID = c.id
						INNER JOIN M_ORG o ON cs.M_ORG_ID = o.id
                        INNER JOIN M_TRADE_RELATIONSHIP tr ON tr.m_seller_comp_service_id=cs.id
                        LEFT JOIN t_exs_banking_balance bg ON bg.BANKING_SERVICE_ID = cs.BANKING_SERVICE_ID and to_number(bg.reading_month)= to_number(mh.READING_MONTH) and to_number(bg.reading_year)= to_number(mh.READING_YEAR)
                        LEFT JOIN M_POWERPLANT pp ON cs.id = pp.M_SERVICE_ID
                        LEFT JOIN M_FUEL fuel ON pp.FUEL_TYPE_CODE = fuel.FUEL_CODE			
						WHERE  mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL  
                        and mh.id = v_mr_id)
		LOOP
			BEGIN

        v_stage := '-2-meter-loop-start';

        -- as there is meter-readings to process, we have to set the flag accordingly and start the generation process
				if(v_no_records) THEN
					v_no_records := FALSE;

				END IF;


        v_log_result := log_activity('PROCEDURE','meter service number','Start',meter.M_COMPANY_SERVICE_ID,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

				--dbms_output.put_line('meter.M_COMPANY_METER_ID - '||meter.M_COMPANY_METER_ID);
				--dbms_output.put_line('meter.M_COMPANY_SERVICE_ID - '||meter.M_COMPANY_SERVICE_ID);
				--dbms_output.put_line('meter.READING_Year - '||meter.READING_Year);
				--dbms_output.put_line('meter.READING_MONTH - '||meter.READING_MONTH);

				-- to find generator capacity
				SELECT count(*) INTO v_gen_count FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;
        v_log_result := log_activity('PROCEDURE','meter.M_COMPANY_METER_ID'||meter.M_COMPANY_METER_ID,'v_gen_count-'||v_gen_count,meter.M_COMPANY_SERVICE_ID,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);


        v_stage := '-3-find generator capacity';
				--dbms_output.put_line('v_gen_count- '||v_gen_count);

				if(v_gen_count =0) THEN
					-- setup issue - generator not configured properly for this service
					v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','ISSUE','Setup Issue - '||v_process_id||' - No generator configured for service-id-->'||meter.M_COMPANY_SERVICE_ID,null,v_created_By, v_created_Date);
					CONTINUE;
				ELSE	
          -- TODO - Sum() should be revisited
                          v_stage := '-4-Sum() should be revisited';
					--SELECT sum(nvl(CAPACITY,0))  INTO v_gs.MACHINE_CAPACITY FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;
                   v_gs.MACHINE_CAPACITY:=meter.TOTAL_CAPACITY;
				END IF;


				--dbms_output.put_line('v_gs.MACHINE_CAPACITY - '||v_gs.MACHINE_CAPACITY);
                v_stage := '-5-Getmr header';
				SELECT count(*) INTO v_mhr_count FROM T_METER_READING_HDR WHERE  M_COMPANY_METER_ID = meter.M_COMPANY_METER_ID AND READING_MONTH = meter.READING_MONTH AND READING_Year = meter.READING_Year;
        v_log_result := log_activity('PROCEDURE','meter.M_COMPANY_METER_ID'||meter.M_COMPANY_METER_ID,'v_mhr_count-'||v_mhr_count,meter.READING_MONTH|| meter.READING_Year,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

				SELECT * INTO v_mrh FROM T_METER_READING_HDR WHERE  M_COMPANY_METER_ID = meter.M_COMPANY_METER_ID AND READING_MONTH = meter.READING_MONTH AND READING_Year = meter.READING_Year;


				--dbms_output.put_line('v_mrh.id - '||v_mrh.id);

                v_stage := '-6-';

				SELECT * INTO v_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C1';
				SELECT * INTO v_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C2';
				SELECT * INTO v_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C3';
				SELECT * INTO v_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C4';
				SELECT * INTO v_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C5';



        --check if there previous meter-reading is to be included in this gen-stmt
        v_prev_mr_id := FIND_PREV_MR(v_mrh.id,'Y'); 
        if(v_prev_mr_id is not null )then
          -- previous meter reading is to be merged with the current meter reading
          SELECT * INTO v_prev_mr FROM T_METER_READING_HDR WHERE id =  v_prev_mr_id;
          SELECT * INTO v_prev_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C1';
          SELECT * INTO v_prev_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C2';
          SELECT * INTO v_prev_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C3';
          SELECT * INTO v_prev_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C4';
          SELECT * INTO v_prev_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C5';

          ----- modify current meter reading record according to the same ----

          --modify header
          v_mrh.INIT_READING_DT := v_prev_mr.INIT_READING_DT;
          v_mrh.EXP_RKVAH_INIT := v_prev_mr.EXP_RKVAH_INIT;
          v_mrh.IMP_RKVAH_INIT := v_prev_mr.IMP_RKVAH_INIT;
          v_mrh.EXP_KVAH_INIT := v_prev_mr.EXP_KVAH_INIT;
          v_mrh.IMP_KVAH_INIT := v_prev_mr.IMP_KVAH_INIT;
          v_mrh.RKVAH_DIFF := nvl(v_mrh.IMP_RKVAH_FINAL,0) - nvl(v_mrh.IMP_RKVAH_INIT, 0);
          v_mrh.RKVAH_UNITS := v_mrh.RKVAH_DIFF*v_mrh.mf;
          v_mrh.KVAH_DIFF := nvl((v_mrh.EXP_KVAH_FINAL - v_mrh.EXP_KVAH_INIT)- (v_mrh.IMP_KVAH_FINAL - v_mrh.IMP_KVAH_INIT), 0);
          v_mrh.KVAH_UNITS := v_mrh.KVAH_DIFF*v_mrh.mf;

          -- modify slot data

          --slot1 changes
          v_mr_c1.IMP_INIT := nvl(v_prev_mr_c1.IMP_INIT,0); v_mr_c1.EXP_INIT := nvl(v_prev_mr_c1.EXP_INIT,0);
          v_mr_c1.IMP_DIFF := v_mr_c1.IMP_FINAL - v_mr_c1.IMP_INIT ;v_mr_c1.EXP_DIFF := v_mr_c1.EXP_FINAL - v_mr_c1.EXP_INIT ;


          v_mr_c1.IMP_UNITS := v_mr_c1.IMP_DIFF * v_mrh.mf; v_mr_c1.EXP_UNITS := v_mr_c1.EXP_DIFF * v_mrh.mf;
          if (to_number(v_mr_c1.EXP_DIFF)<0) then
          v_mr_c1.EXP_UNITS :=0;
          end if;
          v_mr_c1.net_units := ROUND(v_mr_c1.EXP_UNITS - v_mr_c1.IMP_UNITS,0) ; if(to_number(v_mr_c1.net_units )<0) THEN v_mr_c1.net_units := 0; END IF;

          --slot2 changes
          v_mr_c2.IMP_INIT := nvl(v_prev_mr_c2.IMP_INIT,0); v_mr_c2.EXP_INIT := nvl(v_prev_mr_c2.EXP_INIT,0);
          v_mr_c2.IMP_DIFF := v_mr_c2.IMP_FINAL - v_mr_c2.IMP_INIT ;v_mr_c2.EXP_DIFF := v_mr_c2.EXP_FINAL - v_mr_c2.EXP_INIT ;
          v_mr_c2.IMP_UNITS := v_mr_c2.IMP_DIFF * v_mrh.mf; v_mr_c2.EXP_UNITS := v_mr_c2.EXP_DIFF * v_mrh.mf;
           if (to_number(v_mr_c2.EXP_DIFF)<0) then
          v_mr_c2.EXP_UNITS :=0;
          end if;
          v_mr_c2.net_units := ROUND(v_mr_c2.EXP_UNITS - v_mr_c2.IMP_UNITS,0) ; if(to_number(v_mr_c2.net_units ) <0) THEN v_mr_c2.net_units := 0; END IF;

          --slot3 changes
          v_mr_c3.IMP_INIT := nvl(v_prev_mr_c3.IMP_INIT,0); v_mr_c3.EXP_INIT := nvl(v_prev_mr_c3.EXP_INIT,0);
          v_mr_c3.IMP_DIFF := v_mr_c3.IMP_FINAL - v_mr_c3.IMP_INIT ;v_mr_c3.EXP_DIFF := v_mr_c3.EXP_FINAL - v_mr_c3.EXP_INIT ;
          v_mr_c3.IMP_UNITS := v_mr_c3.IMP_DIFF * v_mrh.mf; v_mr_c3.EXP_UNITS := v_mr_c3.EXP_DIFF * v_mrh.mf;
          if (to_number(v_mr_c3.EXP_DIFF)<0) then
          v_mr_c3.EXP_UNITS :=0;
          end if;
          v_mr_c3.net_units := ROUND(v_mr_c3.EXP_UNITS - v_mr_c3.IMP_UNITS,0) ; if(to_number(v_mr_c3.net_units ) <0) THEN v_mr_c3.net_units := 0; END IF;  

          --slot4 changes
          v_mr_c4.IMP_INIT := nvl(v_prev_mr_c4.IMP_INIT,0); v_mr_c4.EXP_INIT := nvl(v_prev_mr_c4.EXP_INIT,0);
          v_mr_c4.IMP_DIFF := v_mr_c4.IMP_FINAL - v_mr_c4.IMP_INIT ;v_mr_c4.EXP_DIFF := v_mr_c4.EXP_FINAL - v_mr_c4.EXP_INIT ;
          v_mr_c4.IMP_UNITS := v_mr_c4.IMP_DIFF * v_mrh.mf; v_mr_c4.EXP_UNITS := v_mr_c4.EXP_DIFF * v_mrh.mf;
         if (to_number(v_mr_c4.EXP_DIFF)<0) then
          v_mr_c4.EXP_UNITS :=0;
          end if;
          v_mr_c4.net_units := ROUND(v_mr_c4.EXP_UNITS - v_mr_c4.IMP_UNITS,0) ; if(to_number(v_mr_c4.net_units ) <0) THEN v_mr_c4.net_units := 0; END IF;

          --slot5 changes
          v_mr_c5.IMP_INIT := nvl(v_prev_mr_c5.IMP_INIT,0); v_mr_c5.EXP_INIT := nvl(v_prev_mr_c5.EXP_INIT,0);
          v_mr_c5.IMP_DIFF := v_mr_c5.IMP_FINAL - v_mr_c5.IMP_INIT ;v_mr_c5.EXP_DIFF := v_mr_c5.EXP_FINAL - v_mr_c5.EXP_INIT ;
          v_mr_c5.IMP_UNITS := v_mr_c5.IMP_DIFF * v_mrh.mf; v_mr_c5.EXP_UNITS := v_mr_c5.EXP_DIFF * v_mrh.mf;
          if (to_number(v_mr_c5.EXP_DIFF)<0) then
          v_mr_c5.EXP_UNITS :=0;
          end if;
          v_mr_c5.net_units := ROUND(v_mr_c5.EXP_UNITS - v_mr_c5.IMP_UNITS,0) ; if(to_number(v_mr_c5.net_units ) <0) THEN v_mr_c5.net_units := 0; END IF;  

          -- update summary info in header 
          v_mrh.total_import_gen := v_mr_c1.IMP_UNITS + v_mr_c2.IMP_UNITS + v_mr_c3.IMP_UNITS + v_mr_c4.IMP_UNITS + v_mr_c5.IMP_UNITS;
					v_mrh.total_export_gen := v_mr_c1.EXP_UNITS + v_mr_c2.EXP_UNITS + v_mr_c3.EXP_UNITS + v_mr_c4.EXP_UNITS + v_mr_c5.EXP_UNITS;
					v_mrh.net_gen_units := v_mr_c1.NET_UNITS + v_mr_c2.NET_UNITS + v_mr_c3.NET_UNITS + v_mr_c4.NET_UNITS + v_mr_c5.NET_UNITS;

          ----- modify current meter reading record - end ----
        end if;

				--dbms_output.put_line('all slots- '||v_mrh.id);
				-- intialise PK, FKs for GenStmt and GenSlots
				v_gs.id := T_GEN_STMT_SEQ.nextval;
				v_gs_c1.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c1.T_GEN_STMT_ID := v_gs.id;
				v_gs_c2.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c2.T_GEN_STMT_ID := v_gs.id;
				v_gs_c3.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c3.T_GEN_STMT_ID := v_gs.id;
				v_gs_c4.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c4.T_GEN_STMT_ID := v_gs.id;
				v_gs_c5.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c5.T_GEN_STMT_ID := v_gs.id;

				-- set values in gen stmt
				v_gs.STATUS_CODE := 'CREATED';
				v_gs.M_COMPANY_METER_ID := v_mrh.M_COMPANY_METER_ID ;
				v_gs.T_MR_IDS := v_mrh.M_COMPANY_METER_ID ;
				v_gs.REF_NUMBER := v_gs_process_id;
        --v_gs.gs_batch_id := v_process_id;
				v_gs.mf := v_mrh.mf;
				v_gs.STMT_GEN_DATE := v_created_Date ;
				v_gs.STMT_MONTH :=  v_mrh.READING_MONTH;
				v_gs.STMT_YEAR := v_mrh.READING_YEAR;
				v_gs.INIT_STMT_DT := v_mrh.INIT_READING_DT;
				v_gs.FINAL_STMT_DT := v_mrh.FINAL_READING_DT;
				-- RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL are not relevant currently
				--RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL - IMPORT VALUES 
				v_gs.KVAH_INIT := v_mrh.IMP_KVAH_INIT;
        v_gs.KVAH_FINAL := v_mrh.IMP_KVAH_FINAL;
        v_gs.RKVAH_INIT := v_mrh.IMP_RKVAH_INIT;
        v_gs.RKVAH_FINAL := v_mrh.IMP_RKVAH_FINAL;
				v_gs.KVAH_DIFF := v_mrh.KVAH_DIFF;
				v_gs.KVAH_UNITS := v_mrh.KVAH_UNITS;
				v_gs.RKVAH_DIFF := v_mrh.RKVAH_DIFF;
				v_gs.RKVAH_UNITS := v_mrh.RKVAH_UNITS;
                v_mr_c1.EXP_UNITS := round(v_mr_c1.EXP_UNITS,0); v_mr_c1.IMP_UNITS := round(v_mr_c1.IMP_UNITS,0);v_mr_c1.NET_UNITS := round(v_mr_c1.NET_UNITS,0);
                v_mr_c2.EXP_UNITS := round(v_mr_c2.EXP_UNITS,0); v_mr_c2.IMP_UNITS := round(v_mr_c2.IMP_UNITS,0);v_mr_c2.NET_UNITS := round(v_mr_c2.NET_UNITS,0);
                v_mr_c3.EXP_UNITS := round(v_mr_c3.EXP_UNITS,0); v_mr_c3.IMP_UNITS := round(v_mr_c3.IMP_UNITS,0);v_mr_c3.NET_UNITS := round(v_mr_c3.NET_UNITS,0);
                v_mr_c4.EXP_UNITS := round(v_mr_c4.EXP_UNITS,0); v_mr_c4.IMP_UNITS := round(v_mr_c4.IMP_UNITS,0);v_mr_c4.NET_UNITS := round(v_mr_c4.NET_UNITS,0);
                v_mr_c5.EXP_UNITS := round(v_mr_c5.EXP_UNITS,0); v_mr_c5.IMP_UNITS := round(v_mr_c5.IMP_UNITS,0);v_mr_c5.NET_UNITS := round(v_mr_c5.NET_UNITS,0);

				v_gs.TOTAL_EXPORT_GEN := v_mr_c1.EXP_UNITS+v_mr_c2.EXP_UNITS+v_mr_c3.EXP_UNITS+v_mr_c4.EXP_UNITS+v_mr_c5.EXP_UNITS;
				v_gs.TOTAL_IMPORT_GEN := v_mr_c1.IMP_UNITS+v_mr_c2.IMP_UNITS+v_mr_c3.IMP_UNITS+v_mr_c4.IMP_UNITS+v_mr_c5.IMP_UNITS;
				
				v_gs.MR_SOURCE_CODE := meter.SOURCE_CODE ;
                v_gs.M_ORG_ID := meter.M_ORG_ID;
				v_gs.M_COMPANY_ID := meter.M_COMPANY_ID;
				v_gs.M_COMPANY_SERVICE_ID := meter.M_COMPANY_SERVICE_ID;
				v_gs.DISP_COMPANY_NAME := meter.DISP_COMPANY_NAME;
				v_gs.DISP_SERVICE_NUMBER := meter.DISP_SERVICE_NUMBER;
				v_gs.INJECTING_VOLTAGE_CODE := meter.INJECTING_VOLTAGE_CODE;
				v_gs.DISP_ORG_NAME := meter.DISP_ORG_NAME; 
				v_gs.FLOW_TYPE_CODE := meter.FLOW_TYPE_CODE; 
				v_gs.net_generation := v_mr_c1.NET_UNITS+v_mr_c2.NET_UNITS+v_mr_c3.NET_UNITS+v_mr_c4.NET_UNITS+v_mr_c5.NET_UNITS;
				v_gs.C1 := v_mr_c1.NET_UNITS;
				v_gs.C2 := v_mr_c2.NET_UNITS;
				v_gs.C3 := v_mr_c3.NET_UNITS;
				v_gs.C4 := v_mr_c4.NET_UNITS;
				v_gs.C5 := v_mr_c5.NET_UNITS;
				v_gs.disp_fuel_type_code := meter.disp_fuel_type_code;
				v_gs.disp_fuel_type_name := meter.disp_fuel_type_name;
                v_gs.disp_fuel_type_group := meter.disp_fuel_type_group;
                v_gs.COMMISSION_DATE:= meter.COMMISSION_DATE;
                v_gs.IS_REC := meter.IS_REC;
                v_gs.disp_meter_number := meter.disp_meter_number;
                v_gs.disp_total_capacity := meter.disp_total_capacity;
                v_gs.disp_capacity := meter.disp_capacity;
                v_gs.disp_pp_op_status := meter.disp_pp_op_status;
                v_gs.EXCESS_UNIT_TYPE := meter.EXCESS_UNIT_TYPE; 
                v_gs.MR_SOURCE_CODE := meter.SOURCE_CODE;
				v_gs.created_by := v_created_By;
				v_gs.created_dt := SYSDATE;
				v_gs.enabled := 'Y';
				v_gs.TOTAL_CHARGED_AMOUNT := 0; --actual value calculated by calc_gs_charges() 
				v_gs.NET_PAYABLE := 0; --actual value calculated by calc_gs_charges() 
				if(to_number(v_gs.TOTAL_EXPORT_GEN)*0.01 >= to_number(v_gs.RKVAH_UNITS)) THEN
					v_gs.penalty_rate := '0.25';
				ELSE
					v_gs.penalty_rate := '0.50';
				END IF;
                v_stage := '-7-';


				--dbms_output.put_line('gen stmt - values set');

                -- if excess_unit_type <> BANKING, clear the banking
                -- important note -even if a service has banking-balance for that month, if the excess_unit_type for that month is not banking, then dont include those units in GS
                -- those pending banking balance will be used later when its eligible.
                if( v_gs.excess_unit_type <> 'BANKING')
                then
                     v_gs_c1.BANKED_BALANCE := 0;
                     v_gs_c2.BANKED_BALANCE := 0;
                     v_gs_c3.BANKED_BALANCE := 0;
                     v_gs_c4.BANKED_BALANCE := 0;
                     v_gs_c5.BANKED_BALANCE := 0;
                     
                end if;
                
				SELECT v_mr_c1.SLOT_CODE,v_mr_c1.IMP_INIT, v_mr_c1.IMP_FINAL, v_mr_c1.IMP_DIFF, round(v_mr_c1.IMP_UNITS,0),v_mr_c1.EXP_INIT, v_mr_c1.EXP_FINAL, v_mr_c1.EXP_DIFF, round(v_mr_c1.EXP_UNITS,0), round(meter.bc1,0), round(v_mr_c1.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c1.SLOT_CODE,v_gs_c1.IMP_INIT, v_gs_c1.IMP_FINAL, v_gs_c1.IMP_DIFF, v_gs_c1.IMP_UNITS, v_gs_c1.EXP_INIT, v_gs_c1.EXP_FINAL, v_gs_c1.EXP_DIFF, v_gs_c1.EXP_UNITS, v_gs_c1.BANKED_BALANCE, v_gs_c1.NET_UNITS, v_gs_c1.enabled, v_gs_c1.created_Date
				FROM dual;



                v_c1_exp_ss_loss:=(v_gs_c1.EXP_UNITS*(i_ss_loss_percent/100));
                if(to_number(v_mr_c1.NET_UNITS)<0)then
                v_c1_exp_ss_loss:=0;
                end if;
                v_gs_c1.EXP_UNITS:=round((v_gs_c1.EXP_UNITS-v_c1_exp_ss_loss),0);
               	v_gs_c1.NET_UNITS:=round((v_gs_c1.EXP_UNITS-v_gs_c1.IMP_UNITS),0);
                if(to_number(v_gs_c1.NET_UNITS )<0) THEN v_gs_c1.NET_UNITS := 0; END IF;
                

				SELECT  v_mr_c2.SLOT_CODE,v_mr_c2.IMP_INIT, v_mr_c2.IMP_FINAL, v_mr_c2.IMP_DIFF, round(v_mr_c2.IMP_UNITS,0), v_mr_c2.EXP_INIT, v_mr_c2.EXP_FINAL, v_mr_c2.EXP_DIFF, round(v_mr_c2.EXP_UNITS,0), round(meter.bc2,0), round(v_mr_c2.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c2.SLOT_CODE,v_gs_c2.IMP_INIT, v_gs_c2.IMP_FINAL, v_gs_c2.IMP_DIFF, v_gs_c2.IMP_UNITS, v_gs_c2.EXP_INIT, v_gs_c2.EXP_FINAL, v_gs_c2.EXP_DIFF, v_gs_c2.EXP_UNITS, v_gs_c2.BANKED_BALANCE, v_gs_c2.NET_UNITS, v_gs_c2.enabled, v_gs_c2.created_Date
				FROM dual;
                v_c2_exp_ss_loss:=(v_gs_c2.EXP_UNITS*(i_ss_loss_percent/100));
                if(to_number(v_mr_c2.NET_UNITS)<0)then
                v_c2_exp_ss_loss:=0;
                end if;
                v_gs_c2.EXP_UNITS:=round((v_gs_c2.EXP_UNITS-v_c2_exp_ss_loss),0);
                v_gs_c2.NET_UNITS:=round((v_gs_c2.EXP_UNITS-v_gs_c2.IMP_UNITS),0);
                if(to_number(v_gs_c2.NET_UNITS )<0) THEN v_gs_c2.NET_UNITS := 0; END IF;

				SELECT  v_mr_c3.SLOT_CODE,v_mr_c3.IMP_INIT, v_mr_c3.IMP_FINAL, v_mr_c3.IMP_DIFF, round(v_mr_c3.IMP_UNITS,0), v_mr_c3.EXP_INIT, v_mr_c3.EXP_FINAL, v_mr_c3.EXP_DIFF, round(v_mr_c3.EXP_UNITS,0), round(meter.bc3,0), round(v_mr_c3.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c3.SLOT_CODE,v_gs_c3.IMP_INIT, v_gs_c3.IMP_FINAL, v_gs_c3.IMP_DIFF, v_gs_c3.IMP_UNITS, v_gs_c3.EXP_INIT, v_gs_c3.EXP_FINAL, v_gs_c3.EXP_DIFF, v_gs_c3.EXP_UNITS, v_gs_c3.BANKED_BALANCE, v_gs_c3.NET_UNITS, v_gs_c3.enabled, v_gs_c3.created_Date
				FROM dual;
                v_c3_exp_ss_loss:=(v_gs_c3.EXP_UNITS*(i_ss_loss_percent/100));
                if(to_number(v_mr_c3.NET_UNITS)<0)then
                v_c3_exp_ss_loss:=0;
                end if;
                v_gs_c3.EXP_UNITS:=round((v_gs_c3.EXP_UNITS-v_c3_exp_ss_loss),0);
                v_gs_c3.NET_UNITS:=round((v_gs_c3.EXP_UNITS-v_gs_c3.IMP_UNITS),0);
                if(to_number(v_gs_c3.NET_UNITS )<0) THEN v_gs_c3.NET_UNITS := 0; END IF;

				SELECT  v_mr_c4.SLOT_CODE,v_mr_c4.IMP_INIT, v_mr_c4.IMP_FINAL, v_mr_c4.IMP_DIFF, round(v_mr_c4.IMP_UNITS,0), v_mr_c4.EXP_INIT, v_mr_c4.EXP_FINAL, v_mr_c4.EXP_DIFF, round(v_mr_c4.EXP_UNITS,0), round(meter.bc4,0), round(v_mr_c4.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c4.SLOT_CODE,v_gs_c4.IMP_INIT, v_gs_c4.IMP_FINAL, v_gs_c4.IMP_DIFF, v_gs_c4.IMP_UNITS, v_gs_c4.EXP_INIT, v_gs_c4.EXP_FINAL, v_gs_c4.EXP_DIFF, v_gs_c4.EXP_UNITS, v_gs_c4.BANKED_BALANCE, v_gs_c4.NET_UNITS, v_gs_c4.enabled, v_gs_c4.created_Date
				FROM dual;
                v_c4_exp_ss_loss:=(v_gs_c4.EXP_UNITS*(i_ss_loss_percent/100));
                if(to_number(v_mr_c4.NET_UNITS)<0)then
                v_c4_exp_ss_loss:=0;
                end if;
                v_gs_c4.EXP_UNITS:=round((v_gs_c4.EXP_UNITS-v_c4_exp_ss_loss),0);
                v_gs_c4.NET_UNITS:=round((v_gs_c4.EXP_UNITS-v_gs_c4.IMP_UNITS),0);
                 if(to_number(v_gs_c4.NET_UNITS )<0) THEN v_gs_c4.NET_UNITS := 0; END IF;

				SELECT  v_mr_c5.SLOT_CODE,v_mr_c5.IMP_INIT, v_mr_c5.IMP_FINAL, v_mr_c5.IMP_DIFF, round(v_mr_c5.IMP_UNITS,0), v_mr_c5.EXP_INIT, v_mr_c5.EXP_FINAL, v_mr_c5.EXP_DIFF, round(v_mr_c5.EXP_UNITS,0), round(meter.bc5,0), round(v_mr_c5.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c5.SLOT_CODE,v_gs_c5.IMP_INIT, v_gs_c5.IMP_FINAL, v_gs_c5.IMP_DIFF, v_gs_c5.IMP_UNITS, v_gs_c5.EXP_INIT, v_gs_c5.EXP_FINAL, v_gs_c5.EXP_DIFF, v_gs_c5.EXP_UNITS, v_gs_c5.BANKED_BALANCE, v_gs_c5.NET_UNITS, v_gs_c5.enabled, v_gs_c1.created_Date
				FROM dual;
                v_c5_exp_ss_loss:=(v_gs_c5.EXP_UNITS*(i_ss_loss_percent/100));
                if(to_number(v_mr_c5.NET_UNITS)<0)then
                v_c5_exp_ss_loss:=0;
                end if;
                v_gs_c5.EXP_UNITS:=round((v_gs_c5.EXP_UNITS-v_c5_exp_ss_loss),0);
               	v_gs_c5.NET_UNITS:=round((v_gs_c5.EXP_UNITS-v_gs_c5.IMP_UNITS),0);
                 if(to_number(v_gs_c5.NET_UNITS )<0) THEN v_gs_c5.NET_UNITS := 0; END IF;
				--dbms_output.put_line('gen stmt slots - insert');
                v_total_exp_ss_loss := v_c1_exp_ss_loss+v_c2_exp_ss_loss+v_c3_exp_ss_loss+v_c4_exp_ss_loss+v_c5_exp_ss_loss;
                v_total_exp:=v_gs_c1.EXP_UNITS+v_gs_c2.EXP_UNITS+v_gs_c3.EXP_UNITS+v_gs_c4.EXP_UNITS+v_gs_c5.EXP_UNITS;
                v_total_net:=v_gs_c1.NET_UNITS+v_gs_c2.NET_UNITS+v_gs_c3.NET_UNITS+v_gs_c4.NET_UNITS+v_gs_c5.NET_UNITS;
				INSERT INTO  T_GEN_STMT VALUES  v_gs;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c1;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c2;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c3;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c4;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c5;

				UPDATE T_GEN_STMT SET C1=v_gs_c1.EXP_UNITS,C2=v_gs_c2.EXP_UNITS,C3=v_gs_c3.EXP_UNITS,C4=v_gs_c4.EXP_UNITS,C5=v_gs_c5.EXP_UNITS,NET_GENERATION=v_total_net,TOTAL_EXPORT_GEN=v_total_exp WHERE ID=v_gs.id;

--                 dbms_output.put_line('gen stmt slots - calling charges');

				  v_result := calc_gs_charges(v_gs.id);

--				 dbms_output.put_line('gen stmt slots - after charges');

        update t_meter_reading_hdr set gs_batch_id = v_gs_process_id, M_GEN_STMT_ID = v_gs.id where id = v_mr_id;
                             v_stage := '-8-';
        SELECT STMT_MONTH,STMT_YEAR,M_COMPANY_SERVICE_ID INTO v_gen_month,v_gen_year,v_gen_comp_servi_id FROM T_GEN_STMT gen WHERE gen.ID= v_gs.id;

        SELECT pp.PLANT_CLASS_TYPE_CODE,tariff.WEG_GROUP_NAME,tariff.RATE into  v_plant_class_code,v_plant_class_desc,tariff_rates FROM M_POWERPLANT pp
        LEFT JOIN M_TARIFF tariff ON pp.PLANT_CLASS_TYPE_CODE=tariff.WEG_GROUP_CODE
        LEFT JOIN T_GEN_STMT gen ON pp.m_service_id = gen.M_COMPANY_SERVICE_ID and gen.ID=v_gs.id
        WHERE  gen.M_COMPANY_SERVICE_ID=v_gen_comp_servi_id;

        --        dbms_output.put_line('tariff rate- '||tariff_rates);
        --        dbms_output.put_line('v_plant_class_code- '||v_plant_class_code);
        --        dbms_output.put_line('v_plant_class_desc- '||v_plant_class_desc);
        --        dbms_output.put_line('tariff rate- '||v_gen_comp_servi_id);
        
        select flow_type_code into v_flow_type_code from M_COMPANY_SERVICE where id=v_gen_comp_servi_id;
                dbms_output.put_line('v_flow_type_code 2-'|| v_flow_type_code );

        UPDATE T_GEN_STMT SET PLANT_CLASS_TYPE_CODE=v_plant_class_code,PLANT_CLASS_TYPE_DESC=v_plant_class_desc,TARIFF_RATE=tariff_rates,SS_LOSS_PERCENT=i_ss_loss_percent,TOTAL_SS_LOSS=v_total_exp_ss_loss WHERE ID=v_gs.id;

                        v_stage := '-9-';

   --     SELECT companygs.IS_CAPTIVE INTO v_gen_iscaptive FROM V_COMPANY_SERVICE companygs
  --      LEFT JOIN T_GEN_STMT gengs ON companygs.M_COMPANY_ID = gengs.M_COMPANY_ID AND companygs.IS_CAPTIVE='Y' WHERE gengs.ID=v_gs.id;

    --    SELECT COUNT(compgs.IS_CAPTIVE) into v_gen_isstb_count from V_COMPANY_SERVICE  compgs
    --    LEFT JOIN T_GEN_STMT stbgs on compgs.ID = stbgs.M_COMPANY_SERVICE_ID and compgs.M_COMPANY_ID='TNEB' AND compgs.IS_STB='Y' WHERE stbgs.ID=v_gs.id ;

        SELECT orggs.CODE INTO v_gen_org_code FROM M_ORG orggs
        LEFT JOIN T_GEN_STMT gengs1 ON orggs.ID = gengs1.M_ORG_ID WHERE gengs1.ID=v_gs.id;


        SELECT codes.VALUE_DESC INTO v_gen_voltage_desc FROM V_CODES codes
        LEFT JOIN T_GEN_STMT gengs2 ON codes.VALUE_CODE=INJECTING_VOLTAGE_CODE AND codes.LIST_NAME='Voltage'
        WHERE gengs2.ID=v_gs.id;


  --      if ( v_gen_isstb_count) > 0 THEN
    --      v_gen_isstb := 'Y'; 
 --        ELSE 
   --       v_gen_isstb := 'N'; 
 --       END IF;
        
         --nEW mAY NEED CHANGE 
        if (v_flow_type_code='STB') THEN
            v_gen_isstb := 'Y'; 
         ELSE 
          v_gen_isstb := 'N'; 
        END IF;
          dbms_output.put_line('v_gen_isstb-'|| v_gen_isstb );

        if (v_flow_type_code='IS-CAPTIVE') THEN
           v_gen_iscaptive := 'Y'; 
         ELSE 
          v_gen_iscaptive := 'N'; 
        END IF;
          dbms_output.put_line('v_flow_type_code-'|| v_flow_type_code );


        --IF(v_gen_isstb_count) > 0 THEN
           v_tariff_net_amount :=  to_number((v_total_net)* tariff_rates) ;
           -- dbms_output.put_line('v_tariff_net_amount- '||v_tariff_net_amount );
           SELECT gs.TOTAL_CHARGED_AMOUNT INTO v_total_charged_amount FROM T_GEN_STMT gs where gs.ID=v_gs.id;
           -- dbms_output.put_line('v_total_charged_amoun- '||v_total_charged_amount );
           v_net_payable := v_tariff_net_amount - v_total_charged_amount;
           --dbms_output.put_line('v_net_payable- '||v_net_payable);
        --   ELSE
        --   CONTINUE;
        --END IF;


        UPDATE T_GEN_STMT SET IS_CAPTIVE=v_gen_iscaptive,IS_STB=v_gen_isstb,DISP_ORG_CODE=v_gen_org_code,INJECTING_VOLTAGE_DESC=v_gen_voltage_desc,TARIFF_NET_AMOUNT=v_tariff_net_amount,NET_PAYABLE = v_net_payable WHERE ID=v_gs.id;


        --select  ss.ID,ss.NAME,ss.TYPE_OF_SS INTO v_gen_ssid, v_gen_ssname,v_gen_sstype  FROM  M_SUBSTATION  ss
        --LEFT JOIN T_GEN_STMT gengs3 ON  ss.M_ORG_ID = gengs3.M_ORG_ID   WHERE gengs3.ID=v_gs.id ;
        --
        --select  ff.ID,ff.NAME INTO v_gen_ffid, v_gen_ffname  FROM  M_FEEDER ff
        --LEFT JOIN T_GEN_STMT gengs4 ON  ff.VOLTAGE_CODE= gengs4.INJECTING_VOLTAGE_CODE  WHERE gengs4.ID=v_gs.id ;
                        v_stage := '-10-';

        select service.M_SUBSTATION_ID,service.M_SUBSTATION_NAME,service.TYPE_OF_SS ,service.M_FEEDER_ID,service.M_FEEDER_NAME INTO v_gen_ssid, v_gen_ssname,v_gen_sstype,v_gen_ffid, v_gen_ffname
        from v_company_service service LEFT JOIN T_GEN_STMT gengs3 ON  service.id = gengs3.M_COMPANY_SERVICE_ID WHERE gengs3.ID=v_gs.id ;

        /* dbms_output.put_line('v_gen_ssid- '||v_gen_ssid);  dbms_output.put_line('v_gen_sstype- '||v_gen_sstype);   dbms_output.put_line('v_gen_ffname- '||v_gen_ffname);
        */
        UPDATE T_GEN_STMT SET M_SUBSTATION_ID = v_gen_ssid, M_SUBSTATION_NAME = v_gen_ssname,M_FEEDER_ID = v_gen_ffid,M_FEEDER_NAME = v_gen_ffname ,TYPE_OF_SS =v_gen_sstype  WHERE ID=v_gs.id;

				COMMIT;
			exception
			  when others then
			    v_exception_code := SQLCODE;
			    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
			    v_result := 'FAILURE';
			    v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','create_gs_from_mr','EH','Error while processing each meter-reading - '||v_reason,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);
			END;
		END LOOP;


       -- --dbms_output.put_line('all slots- '||v_mrh.id);
		if(v_no_records) THEN
			v_result := 'FAILURE';
            if(v_reason='') then v_reason := 'No records to process'; end if;
		END IF;

        if( V_RESULT != '') THEN
			v_result := 'SUCCESS'; 
		END IF; 

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
	    -- dbms_output.put_line(v_reason);

      v_log_result := log_activity('PROCEDURE','create_gs_from_mr','EH',v_result,v_reason||v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);
	END;
   <<THE_END>>


      v_log_result := log_activity('PROCEDURE','create_gs_from_mr','End',v_result,v_reason||v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);

  COMMIT;

  return V_RESULT; 

END CREATE_FROM_MR;

END GENERATION_STATEMENT;

/
--------------------------------------------------------
--  DDL for Package Body IMP_INT_ADJUSTED_UNIT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."IMP_INT_ADJUSTED_UNIT" 
AS
-- Package body
  
   PROCEDURE PROCESS_INT_ADJUSTED_UNIT(i_batch_key in varchar2,i_month in varchar2,i_year in varchar2 ,o_result_code out varchar2, o_result_desc out varchar2) IS
    v_process varchar2(50):='IMP_INT_ADJUSTED_UNIT.PROCESS_INT_ADJUSTED_UNIT';
    v_process_type varchar2(50):='PACKAGE';
	v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_log_result varchar(300):='SUCCESS';
    v_intAdjUnit INT_ADJUSTED_UNIT%ROWTYPE;
    v_sellerComService V_COMPANY_SERVICE%ROWTYPE;
    v_buyerComService V_COMPANY_SERVICE%ROWTYPE;
  	v_intAdjCursor sys_refcursor ;
    v_intAdj_charge_Cursor sys_refcursor ;
  	v_sellerCount  VARCHAR2(50);
  	v_buyerCount  VARCHAR2(50);
    v_esOrderCount  VARCHAR2(50);
    v_esOrderLineCount  VARCHAR2(50);
    v_energy_adj_count number;
    v_finalintAdjUnit INT_ADJUSTED_UNIT%ROWTYPE;
    v_intAdjCharge  INT_ADJUSTED_CHARGE%ROWTYPE;
    v_energy_adjustment F_ENERGY_ADJUSTMET%ROWTYPE;
    v_row_count number;

   	v_result1  VARCHAR2(100);
  	v_result2  VARCHAR2(100);

    v_esOrderId  VARCHAR2(50);
    v_esOrderLineId  VARCHAR2(50);


    BEGIN
    v_log_result := log_activity(v_process_type, v_process,'START','Batch-Key - '||i_batch_key,'i_month-'||i_month,'i_year'||i_year, sysdate,i_batch_key);

   	    -- begin for exception handling
    BEGIN
        update INT_ADJUSTED_UNIT set is_clean='', result_desc='',BUYER_COMPANY_ID='', BUYER_COMPANY_SERVICE_ID='',
        SELLER_COMPANY_ID='', SELLER_COMPANY_SERVICE_ID='' WHERE BATCH_KEY = i_batch_key ;
        
        update INT_ADJUSTED_UNIT set is_clean='N', result_desc='ReadingDt is mandatory'  WHERE BATCH_KEY = i_batch_key AND (READING_DT IS NULL) ;
        
        -- update buyer info
        select count(i.id) into v_row_count from INT_ADJUSTED_UNIT i inner join V_COMPANY_SERVICE b on i.SERVICE_NO = b."number" where i.BATCH_KEY =i_batch_key and nvl(i.is_clean,'-')='-';
        if(v_row_count >0) then  -- this reduntant condition is to avoid 'no data found' error
            -- update buyer information in interface table
            UPDATE INT_ADJUSTED_UNIT i SET ( BUYER_COMPANY_ID, BUYER_COMPANY_SERVICE_ID) 
                        = (SELECT b.M_COMPANY_ID BUYER_COMPANY_ID, b.ID BUYER_COMPANY_SERVICE_ID  FROM V_COMPANY_SERVICE b WHERE  i.SERVICE_NO = b."number")
            WHERE EXISTS (
                    SELECT 1 FROM V_COMPANY_SERVICE b WHERE  i.SERVICE_NO = b."number" )
                  AND i.BATCH_KEY =i_batch_key and nvl(is_clean,'-')='-';
        else                  
            -- mark unknown buyers
            UPDATE INT_ADJUSTED_UNIT set is_clean='N', result_desc='Unknown Buyers'  where BATCH_KEY =i_batch_key  and nvl(is_clean,'-')='-' and BUYER_COMPANY_SERVICE_ID ='' ;
         end if;  
         
         -- update seller info
        select count(i.id) into v_row_count from INT_ADJUSTED_UNIT i inner join V_COMPANY_SERVICE s on i.SUPLR_CODE = s."number" where i.BATCH_KEY =i_batch_key and nvl(i.is_clean,'-')='-';
        if(v_row_count >0) then  -- this reduntant condition is to avoid 'no data found' error
            -- update seller information in interface table
            UPDATE INT_ADJUSTED_UNIT i SET ( SELLER_COMPANY_ID, SELLER_COMPANY_SERVICE_ID, FUEL_TYPE_CODE, SELLER_ORG_ID) 
                        = (SELECT s.M_COMPANY_ID SELLER_COMPANY_ID, s.ID SELLER_COMPANY_SERVICE_ID, s.FUEL_TYPE_CODE, s.m_org_id SELLER_ORG_ID  FROM V_COMPANY_SERVICE s WHERE  i.SUPLR_CODE = s."number")
            WHERE EXISTS (
                    SELECT 1 FROM V_COMPANY_SERVICE s WHERE  i.SUPLR_CODE = s."number" )
                  AND i.BATCH_KEY =i_batch_key and nvl(is_clean,'-')='-';
         else
            -- mark unknown sellers
            UPDATE INT_ADJUSTED_UNIT set is_clean='N', result_desc='Unknown Sellers'  where BATCH_KEY =i_batch_key  and nvl(is_clean,'-')='-' and SELLER_COMPANY_SERVICE_ID ='' ;
        end if;
        
        --update saleorder info
        select count(i.id) into v_row_count from INT_ADJUSTED_UNIT i inner join f_energy_sale_order so on i.SUPLR_CODE = so.d_sell_comp_serv_number  where i.BATCH_KEY =i_batch_key and nvl(i.is_clean,'-')='-'  AND so.month=i_month and so.year=i_year;
        if(v_row_count >0) then  -- this reduntant condition is to avoid 'no data found' error
            -- update saleorder id in interface table
            UPDATE INT_ADJUSTED_UNIT i
               SET (F_ENERGY_SALE_ORDER_ID) = (SELECT so.ID F_ENERGY_SALE_ORDER_ID FROM f_energy_sale_order so
                                    WHERE  i.SUPLR_CODE = so.d_sell_comp_serv_number AND so.month=i_month and so.year=i_year)
             WHERE EXISTS (
                SELECT 1
                  FROM f_energy_sale_order so
                 WHERE  i.SUPLR_CODE = so.d_sell_comp_serv_number AND so.month=i_month and so.year=i_year )
                 AND i.BATCH_KEY =i_batch_key and nvl(is_clean,'-')='-';      
            
            select count(i.id) into v_row_count from INT_ADJUSTED_UNIT i inner join F_ENERGY_SALE_ORDER_LINES sol on i.F_ENERGY_SALE_ORDER_ID = sol.id and  i.service_no = sol.d_buyer_comp_serv_name
                where i.BATCH_KEY =i_batch_key and nvl(i.is_clean,'-')='-'  ;
            if(v_row_count >0) then  -- this reduntant condition is to avoid 'no data found' error
                -- update saleorder lineid   in interface table
                UPDATE INT_ADJUSTED_UNIT i
                   SET (F_ENERGY_SALE_ORDER_line_id) = (SELECT sol.ID F_ENERGY_SALE_ORDER_line_id FROM F_ENERGY_SALE_ORDER_LINES sol
                                        WHERE  i.F_ENERGY_SALE_ORDER_ID = sol.id and  i.service_no = sol.d_buyer_comp_serv_name )
                 WHERE EXISTS (
                    SELECT 1
                      FROM F_ENERGY_SALE_ORDER_LINES sol
                     WHERE i.F_ENERGY_SALE_ORDER_ID = sol.id and  i.service_no = sol.d_buyer_comp_serv_name )
                     AND i.BATCH_KEY =i_batch_key and nvl(is_clean,'-')='-';    
            else
                -- mark No Energy allotment for the supplier
                UPDATE INT_ADJUSTED_UNIT set is_clean='N', result_desc='No Record of Energy Allotment for the supplier('||SUPLR_CODE||')  in OA' where BATCH_KEY =i_batch_key  and nvl(is_clean,'-')='-' and F_ENERGY_SALE_ORDER_line_id = '' ;
            end if;

        else
            -- mark No Energy allotment for the supplier
            UPDATE INT_ADJUSTED_UNIT set is_clean='N', result_desc='No Record of Energy Allotment for the supplier('||SUPLR_CODE||')  in OA' where BATCH_KEY =i_batch_key  and nvl(is_clean,'-')='-' and F_ENERGY_SALE_ORDER_ID ='' ;        
        end if;
        
        
        
        UPDATE INT_ADJUSTED_UNIT set is_clean='Y' where BATCH_KEY =i_batch_key  and nvl(is_clean,'-')='-' ;
        
        v_log_result := log_activity(v_process_type, v_process,'Cleanse Complete','','', '',i_batch_key);

        for cur in (SELECT * FROM INT_ADJUSTED_UNIT WHERE BATCH_KEY=i_batch_key and is_clean='Y' )
        LOOP
        BEGIN
        
            SELECT count(*) INTO v_energy_adj_count from F_ENERGY_ADJUSTMET WHERE suplr_code=cur.SUPLR_CODE AND service_no=cur.SERVICE_NO AND reading_mnth=cur.reading_mnth AND reading_yr=cur.reading_yr;
            if(v_energy_adj_count >0)then
                v_log_result := log_activity(v_process_type, v_process,'updating energy adjustment','','',cur.SERVICE_NO, cur.SUPLR_CODE,i_batch_key);
                update F_ENERGY_ADJUSTMET set BATCH_KEY=cur.BATCH_KEY,READING_DT=cur.READING_DT ,C24=cur.C24 , C1=cur.C1, C2=cur.C2, C3=cur.C3, C4=cur.C4, C5=cur.C5, C1_WITHLOSS=cur.C1_WITHLOSS , C2_WITHLOSS= cur.C2_WITHLOSS , C3_WITHLOSS=cur.C3_WITHLOSS, C4_WITHLOSS=cur.C4_WITHLOSS, C5_WITHLOSS=cur.C5_WITHLOSS, ADJUSTED_C1=cur.ADJUSTED_C1, ADJUSTED_C2=cur.ADJUSTED_C2, ADJUSTED_C3=cur.ADJUSTED_C3, ADJUSTED_C4=cur.ADJUSTED_C4, ADJUSTED_C5=cur.ADJUSTED_C5,
                 modified_by=v_process, modified_dt=sysdate
                    WHERE  suplr_code=cur.SUPLR_CODE AND service_no=cur.SERVICE_NO AND reading_mnth=cur.reading_mnth AND reading_yr=cur.reading_yr;
            else
              v_log_result := log_activity(v_process_type, v_process,'inserting energy adjustment','','',cur.SERVICE_NO, cur.SUPLR_CODE,i_batch_key);
              INSERT INTO F_ENERGY_ADJUSTMET
                  (ID, BATCH_KEY, SERVICE_NO, SUPLR_CODE, READING_DT, READING_MNTH, READING_YR, C24, C1, C2, C3, C4, C5, CREATED_BY, CREATED_DT, MODIFIED_BY, MODIFIED_DT, BUYER_COMPANY_ID, BUYER_COMPANY_SERVICE_ID, SELLER_COMPANY_ID, SELLER_COMPANY_SERVICE_ID, F_ENERGY_SALE_ORDER_ID, F_ENERGY_SALE_ORDER_LINE_ID, FUEL_TYPE_CODE, IMPORT_REMARKS, "SOURCE", IMPORTED, SUPLR_NAME, DELETE_FLAG, SUPLR_TYPE, C1_WITHLOSS, C2_WITHLOSS, C3_WITHLOSS, C4_WITHLOSS, C5_WITHLOSS, ADJUSTED_C1, ADJUSTED_C2, ADJUSTED_C3, ADJUSTED_C4, ADJUSTED_C5, IS_CLEAN,SELLER_ORG_ID)
                  VALUES(F_ENERGY_ADJUTMENT_SEQ.NEXTVAL,cur.BATCH_KEY,cur.SERVICE_NO,cur.SUPLR_CODE,cur.READING_DT,cur.READING_MNTH,cur.READING_YR,  cur.C24, cur.C1, cur.C2, cur.C3, cur.C4, cur.C5, v_process, sysdate, '', '',cur.BUYER_COMPANY_ID,cur.BUYER_COMPANY_SERVICE_ID,cur.SELLER_COMPANY_ID,cur.SELLER_COMPANY_SERVICE_ID,cur.F_ENERGY_SALE_ORDER_ID,cur.F_ENERGY_SALE_ORDER_LINE_ID,cur.FUEL_TYPE_CODE,cur.IMPORT_REMARKS,cur."SOURCE",cur.IMPORTED,cur.SUPLR_NAME,cur.DELETE_FLAG,cur.SUPLR_TYPE,cur.C1_WITHLOSS,cur.C2_WITHLOSS,cur.C3_WITHLOSS,cur.C4_WITHLOSS,cur.C5_WITHLOSS,cur.ADJUSTED_C1,cur.ADJUSTED_C2,cur.ADJUSTED_C3,cur.ADJUSTED_C4,cur.ADJUSTED_C5,cur.IS_CLEAN,cur.SELLER_ORG_ID);
              OPEN v_intAdj_charge_Cursor for SELECT * FROM int_adjusted_charge WHERE energy_adjusted_data_id=v_finalintAdjUnit.id;
              LOOP
                    FETCH v_intAdj_charge_Cursor INTO v_intAdjCharge;
                      EXIT WHEN v_intAdj_charge_Cursor%NOTFOUND;
                    SELECT * INTO v_energy_adjustment from F_ENERGY_ADJUSTMET WHERE suplr_code=v_finalintAdjUnit.SUPLR_CODE AND service_no=v_finalintAdjUnit.SERVICE_NO AND reading_mnth=v_finalintAdjUnit.reading_mnth AND reading_yr=v_finalintAdjUnit.reading_yr;
    
                    INSERT INTO F_ENERGY_ADJUSTED_CHARGE
                      (ID,F_ENERGY_ADJUSTED_ID,CHARGE_CODE,CHARGE_DESC,CHARGE_AMOUNT)VALUES(F_ENERGY_ADJUSTED_CHARGE_SEQ.NEXTVAL, v_energy_adjustment.ID, v_intAdjCharge.CHARGE_CODE, v_intAdjCharge.CHARGE_DESC, v_intAdjCharge.CHARGE_AMOUNT);
               END LOOP;
            end if;
        exception
        when others then
            v_exception_code := SQLCODE;
            v_exception_msg := SUBSTR(SQLERRM, 1, 200);
            o_result_code := 'FAILURE';
            o_result_desc := v_exception_code || ' - ' || v_exception_msg;
            v_log_result := log_activity(v_process_type, v_process,'EXCEPTION',o_result_desc,'Loop-exception',v_intAdjUnit.SERVICE_NO, v_intAdjUnit.SUPLR_CODE,i_batch_key);
            UPDATE INT_ADJUSTED_UNIT set is_clean='N',result_desc=o_result_desc  where BATCH_KEY =i_batch_key  and id = cur.id ;
        END;
        end loop;
        INC_SURPLUS_UNIT(i_batch_key,o_result_code, o_result_desc);


	exception
    when others then
      v_exception_code := SQLCODE;
      v_exception_msg := SUBSTR(SQLERRM, 1, 200);
      o_result_code := 'FAILURE';
      o_result_desc := v_exception_code || ' - ' || v_exception_msg;
      v_log_result := log_activity(v_process_type, v_process,'EXCEPTION',o_result_desc,'','', sysdate,i_batch_key);
    --UPDATE INT_ADJUSTED_UNIT set is_clean='N',result_desc=o_result_desc  where BATCH_KEY =i_batch_key  and id = cur.id ;

    END;

    v_log_result := log_activity(v_process_type, v_process,'END',o_result_code, o_result_desc,'', '',i_batch_key);
    COMMIT;


  END PROCESS_INT_ADJUSTED_UNIT;

   PROCEDURE INC_SURPLUS_UNIT(i_batch_key in varchar2, o_result_code out varchar2, o_result_desc out varchar2) AS
    v_process varchar2(50):='IMP_INT_ADJUSTED_UNIT.INC_SURPLUS_UNIT';
    v_process_type varchar2(50):='PACKAGE';
    v_htsurcursor sys_refcursor ;
  	v_adj_unit F_ENERGY_ADJUSTMET%ROWTYPE;
    v_total_loss VARCHAR2(200);
    v_drawl_code VARCHAR2(200); 
    v_inj_code VARCHAR2(200); 
    v_inj_units number; 
    v_trans_loss VARCHAR2(200); 
    v_dis_loss VARCHAR2(200); 
    v_drawl_units  number; 
    v_comp_id VARCHAR2(200); 
    v_bank_service_id VARCHAR2(200); 
    v_banking_count VARCHAR2(50); 
    v_inj_units1 VARCHAR2(200); 
    v_inj_units2 VARCHAR2(200); 
    v_inj_units3 VARCHAR2(200); 
    v_inj_units4 VARCHAR2(200); 
    v_inj_units5 VARCHAR2(200); 
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
    v_count number;

  BEGIN
BEGIN
    v_log_result := log_activity(v_process_type,v_process,'START','Start - '||i_batch_key,'','', sysdate,i_batch_key);

    UPDATE F_ENERGY_ADJUSTMET set READING_MNTH=lpad(READING_MNTH,2,'0') WHERE BATCH_KEY=i_batch_key;

    v_log_result := log_activity(v_process_type,v_process,'Cleanse','Complete','','', sysdate,i_batch_key);

    OPEN v_htsurcursor for select * from F_ENERGY_ADJUSTMET where BATCH_KEY=i_batch_key;
    LOOP
    FETCH v_htsurcursor INTO v_adj_unit;
    EXIT WHEN v_htsurcursor%NOTFOUND;

      SELECT voltage_code INTO v_inj_code FROM m_company_service WHERE "number"=v_adj_unit.SUPLR_CODE;
      SELECT voltage_code INTO v_drawl_code FROM m_company_service WHERE "number"=v_adj_unit.SERVICE_NO;

      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.C1,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units1);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.C2,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units2);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.C3,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units3);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.C4,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units4);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_adj_unit.C5,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units5);


      UPDATE F_ENERGY_ADJUSTMET SET C1_WITHLOSS=round(nvl(v_inj_units1,0),0),C2_WITHLOSS=round(nvl(v_inj_units2,0),0),C3_WITHLOSS=round(nvl(v_inj_units3,0),0),C4_WITHLOSS=round(nvl(v_inj_units4,0),0),C5_WITHLOSS=round(nvl(v_inj_units5,0),0),LOSS_PERCENT=v_total_loss
      WHERE ID = v_adj_unit.ID;

    END LOOP;

    v_log_result := log_activity(v_process_type,v_process,'Completed Loss Calculation','','','', sysdate,i_batch_key);
    
    v_count :=0;
    for serv in ( select distinct suplr_code, reading_mnth, reading_yr from f_energy_adjustmet where BATCH_KEY=i_batch_key)
    LOOP
        excess_units_source.update_excess_from_ht(serv.suplr_code, serv.reading_mnth,serv.reading_yr ,v_log_result  , v_reason);
        v_count := v_count +1;
    END LOOP;
    
    v_log_result := log_activity(v_process_type,v_process,'Updated Balance in OA','','','', sysdate,i_batch_key);


    exception
    when others then
      v_exception_code := SQLCODE;
      v_exception_msg := SUBSTR(SQLERRM, 1, 200);
      o_result_code := 'FAILURE';
      o_result_desc := v_exception_code || ' - ' || v_exception_msg;
      -- dbms_output.put_line(o_result_desc);
      v_log_result := log_activity(v_process_type,v_process,'EXCEPTION',o_result_desc,i_batch_key,'', sysdate,i_batch_key);
    END;
    COMMIT;
    v_log_result := log_activity(v_process_type,v_process,'End','End','','', sysdate,i_batch_key);

  END INC_SURPLUS_UNIT;

    PROCEDURE UPDATE_SURPLUS_BANKING(i_service_number in varchar2,i_month in varchar2,i_year in varchar2, o_result_code out varchar2, o_result_desc out varchar2) AS

    v_process varchar(200):='IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING'; 
    v_process_type varchar2(50):='PACKAGE';

    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
    V_SELLER_COMP_SERVICE V_COMPANY_SERVICE%ROWTYPE;
      v_commission_date  DATE;
    v_banking_count VARCHAR2(50); 
     v_excess_stb_count number; 

        V_NEW_SERV_EX_BANKING T_NEW_SERVICE_EXCESS_BANKING%ROWTYPE;

  BEGIN
      BEGIN
        v_log_result := log_activity(v_process_type,v_process,'START','Start - '||i_month,'','', sysdate,i_service_number);


        FOR supplier in (  select ser."number" SUPLR_CODE, ser.M_COMPANY_ID,ser.BANKING_SERVICE_ID, READING_MNTH, READING_YR,sum(nvl(s.C1_WITHLOSS,0)) c1_wl, sum(nvl(s.C2_WITHLOSS,0)) c2_wl,sum(nvl(s.C3_WITHLOSS,0)) c3_wl, sum(nvl(s.C4_WITHLOSS,0)) c4_wl,sum(nvl(s.C5_WITHLOSS,0)) c5_wl 
                            from  F_ENERGY_ADJUSTMET s join m_company_service ser on ser."number"=s.suplr_code  where READING_MNTH=i_month and READING_YR=i_year 
                            and ser."number"=i_service_number
                            group by ser."number" ,ser.M_COMPANY_ID,ser.BANKING_SERVICE_ID,READING_MNTH, READING_YR)
          loop
          begin
            SELECT * INTO V_SELLER_COMP_SERVICE FROM V_COMPANY_SERVICE WHERE "number"=i_service_number;
            if(V_SELLER_COMP_SERVICE.excess_unit_type='BANKING') then
               select count(*) into v_banking_count from T_BANKING_BALANCE where M_COMPANY_ID = supplier.M_COMPANY_ID and BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID and MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;
                    --  DBMS_OUTPUT.PUT_LINE(' v_banking_count--'||v_banking_count);

                  if(v_banking_count>0) then
                        v_log_result := log_activity(v_process_type,v_process,'Update Banking Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_service_number);
                        update T_BANKING_BALANCE set SURPLUS_C1=round(nvl(supplier.c1_wl,0),0),SURPLUS_C2=round(nvl(supplier.c2_wl,0),0),SURPLUS_C3=round(nvl(supplier.c3_wl,0),0),SURPLUS_C4=round(nvl(supplier.c4_wl,0),0),SURPLUS_C5=round(nvl(supplier.c5_wl,0),0),
                       modified_by=v_process, modified_dt =sysdate where (M_COMPANY_ID = supplier.M_COMPANY_ID or BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID)  AND MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;
                   else
                        v_log_result := log_activity(v_process_type,v_process,'Insert Banking Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_service_number);
                        insert into T_BANKING_BALANCE (ID,M_COMPANY_ID,BANKING_SERVICE_ID,C1,C2,C3,C4,C5,REMARKS,MONTH,YEAR,SURPLUS_C1,SURPLUS_C2,SURPLUS_C3,SURPLUS_C4,SURPLUS_C5,CREATED_BY,CREATED_DT)
                        values (T_BANKING_BALANCE_SEQ.NEXTVAL,supplier.M_COMPANY_ID,supplier.BANKING_SERVICE_ID,nvl(supplier.c1_wl,0),nvl(supplier.c2_wl,0),nvl(supplier.c3_wl,0),nvl(supplier.c4_wl,0),nvl(supplier.c5_wl,0),i_month,supplier.READING_MNTH,supplier.READING_YR,round(nvl(supplier.c1_wl,0),0),round(nvl(supplier.c2_wl,0),0),round(nvl(supplier.c3_wl,0),0),round(nvl(supplier.c4_wl,0),0),round(nvl(supplier.c5_wl,0),0),v_process,sysdate);
                  END IF;

            ELSIF(V_SELLER_COMP_SERVICE.excess_unit_type='SURPLUS-STB') then
                select count(*) into v_excess_stb_count from T_NEW_SERVICE_EXCESS_BANKING where M_COMPANY_ID = supplier.M_COMPANY_ID and BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID and MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;
                if(v_excess_stb_count > 0) then
                        v_log_result := log_activity(v_process_type,v_process,'Update Excess Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_service_number);
                     update T_NEW_SERVICE_EXCESS_BANKING set SURPLUS_C1=round(nvl(supplier.c1_wl,0),0),SURPLUS_C2=round(nvl(supplier.c2_wl,0),0),SURPLUS_C3=round(nvl(supplier.c3_wl,0),0),SURPLUS_C4=round(nvl(supplier.c4_wl,0),0),SURPLUS_C5=round(nvl(supplier.c5_wl,0),0),
                       modified_by=v_process, modified_dt =sysdate where (M_COMPANY_ID = supplier.M_COMPANY_ID or BANKING_SERVICE_ID=supplier.BANKING_SERVICE_ID)  AND MONTH=supplier.READING_MNTH AND YEAR=supplier.READING_YR;
                else
                     v_log_result := log_activity(v_process_type,v_process,'Insert Excess Balance',supplier.BANKING_SERVICE_ID,'','', sysdate,i_service_number);
                    select V_SELLER_COMP_SERVICE.M_COMPANY_ID,V_SELLER_COMP_SERVICE.BANKING_SERVICE_ID,nvl(supplier.c1_wl,0),nvl(supplier.c2_wl,0),nvl(supplier.c3_wl,0),nvl(supplier.c4_wl,0),nvl(supplier.c5_wl,0),nvl(supplier.c1_wl,0),nvl(supplier.c2_wl,0),nvl(supplier.c3_wl,0),nvl(supplier.c4_wl,0),nvl(supplier.c5_wl,0)
                    into V_NEW_SERV_EX_BANKING.M_COMPANY_ID,V_NEW_SERV_EX_BANKING.BANKING_SERVICE_ID,V_NEW_SERV_EX_BANKING.C1,V_NEW_SERV_EX_BANKING.C2,V_NEW_SERV_EX_BANKING.C3,V_NEW_SERV_EX_BANKING.C4,V_NEW_SERV_EX_BANKING.C5,V_NEW_SERV_EX_BANKING.SURPLUS_C1,V_NEW_SERV_EX_BANKING.SURPLUS_C2,V_NEW_SERV_EX_BANKING.SURPLUS_C3,V_NEW_SERV_EX_BANKING.SURPLUS_C4,V_NEW_SERV_EX_BANKING.SURPLUS_C5 from dual;
                    V_NEW_SERV_EX_BANKING.enabled:='Y';
                    V_NEW_SERV_EX_BANKING.CALCULATED:='Y';
                    V_NEW_SERV_EX_BANKING.month:=i_month;
                    V_NEW_SERV_EX_BANKING.year:=i_year;
                    V_NEW_SERV_EX_BANKING.CREATED_BY:=v_process; 
                    V_NEW_SERV_EX_BANKING.CREATED_DT:=sysdate; 
                    V_NEW_SERV_EX_BANKING.id:=T_NEW_SERVICE_EXCESS_BANKING_SEQ.NEXTVAL;
                    insert into T_NEW_SERVICE_EXCESS_BANKING VALUES V_NEW_SERV_EX_BANKING;
                end if;

            END IF;
                
       exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity(v_process_type, v_process,'EXCEPTION-LOOP',o_result_desc,supplier.BANKING_SERVICE_ID,'', sysdate,i_service_number);
           UPDATE F_ENERGY_ADJUSTMET SET imported='N', import_remarks=o_result_desc where READING_MNTH=i_month and READING_YR=i_year and SUPLR_CODE = supplier.SUPLR_CODE;
       END;
        END LOOP;

       exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity(v_process_type, v_process,'EXCEPTION',o_result_desc,i_month,'', sysdate,i_service_number);
       END;
    COMMIT;
     v_log_result := log_activity(v_process_type, v_process,'End','End','','', sysdate,i_service_number);

  END UPDATE_SURPLUS_BANKING;

END IMP_INT_ADJUSTED_UNIT;

/
--------------------------------------------------------
--  DDL for Package Body METER_NUMBER_CHANGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."METER_NUMBER_CHANGE" AS

  
    PROCEDURE IMPORT(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_result varchar(300):='SUCCESS';   
    v_created_Date DATE := SYSDATE;
    v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.IMPORT';
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.IMPORT','IMPORT','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   -------------------------------------------------------- LOGIC
       if I_BATCH_KEY is not null then
         METER_NUMBER_CHANGE.METER_CREATION(I_BATCH_KEY , I_MONTH ,I_YEAR ,O_RESULT_CODE , O_RESULT_DESC ) ;
         METER_NUMBER_CHANGE.IDENTIFY_ERRORS(I_BATCH_KEY , I_MONTH ,I_YEAR ,O_RESULT_CODE , O_RESULT_DESC ) ;
         METER_NUMBER_CHANGE.CLEANSE(I_BATCH_KEY , I_MONTH ,I_YEAR ,O_RESULT_CODE , O_RESULT_DESC ) ;
         METER_NUMBER_CHANGE.CREATE_METER_READING(I_BATCH_KEY , I_MONTH ,I_YEAR ,O_RESULT_CODE , O_RESULT_DESC ) ;
         METER_NUMBER_CHANGE.CREATE_TEMP_GENERATION_STATEMENT(I_BATCH_KEY , I_MONTH ,I_YEAR ,O_RESULT_CODE , O_RESULT_DESC ) ;
         METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT(I_BATCH_KEY , I_MONTH ,I_YEAR ,O_RESULT_CODE , O_RESULT_DESC ) ;

      end if;
   --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.IMPORT','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE



  END IMPORT;


PROCEDURE METER_CREATION(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
v_log_result  varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';   
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.METER_CREATION';
v_imp_mc_line_cursor sys_refcursor ;
v_cur_imp_mr_lines IMP_MC_MR_LINES%ROWTYPE;
v_cur_imp_mr_loop_lines IMP_MC_MR_LINES%ROWTYPE;
v_imp_count  NUMBER;
v_loop_cursor sys_refcursor;
v_service_count  NUMBER;
v_meter_count  NUMBER;
v_company_Service_view M_COMPANY_SERVICE%ROWTYPE;
v_meter_number  VARCHAR2(50);
meter_date date;
meter_count  number;

    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.METER_CREATION','METER_CREATION','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   -------------------------------------------------------- LOGIC
   
   		UPDATE IMP_MR_LINES SET sys_dt = TO_CHAR(SYSDATE,'yyyy-mm-dd'),  INIT_READING_DT = (READING_YEAR||'-'||READING_MONTH||'-'||'01' ) ,
		FINAL_READING_DT = to_char(LAST_DAY( to_date((READING_YEAR||'-'||READING_MONTH||'-'||'01' ),'YYYY-MM-DD')),'YYYY-MM-DD')
		WHERE IMP_MR_HEADER_ID = I_BATCH_KEY;
        
      
    OPEN v_imp_mc_line_cursor for SELECT * FROM IMP_MC_MR_LINES WHERE IMP_MC_MR_HEADER_ID=I_BATCH_KEY and READING_MONTH=I_MONTH and READING_YEAR=I_YEAR;
    LOOP
    FETCH v_imp_mc_line_cursor INTO v_cur_imp_mr_lines;
    EXIT WHEN v_imp_mc_line_cursor%NOTFOUND;
    select count(*) into v_imp_count from IMP_MC_MR_LINES WHERE IMP_MC_MR_HEADER_ID=I_BATCH_KEY and READING_MONTH=I_MONTH and READING_YEAR=I_YEAR AND SERVICE_NO=v_cur_imp_mr_lines.SERVICE_NO;
--       v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.METER_CREATION','v_imp_count','v_imp_count - '||v_imp_count,'','', sysdate,I_BATCH_KEY);
        if v_imp_count=2 then
        
            OPEN v_loop_cursor for SELECT * FROM IMP_MC_MR_LINES WHERE IMP_MC_MR_HEADER_ID=I_BATCH_KEY and READING_MONTH=I_MONTH and READING_YEAR=I_YEAR and service_no=v_cur_imp_mr_lines.service_no;
            LOOP
            FETCH v_loop_cursor INTO v_cur_imp_mr_loop_lines;
            EXIT WHEN v_loop_cursor%NOTFOUND;
            
            --Check if service exists
            select count(*) into v_service_count from m_company_service where "number"=v_cur_imp_mr_loop_lines.service_no;
                      select * into v_company_Service_view from m_company_Service where "number"=v_cur_imp_mr_loop_lines.service_no;
            if v_service_count=1 then
            
                select count(*) into meter_count from m_company_meter where meter_number=v_cur_imp_mr_loop_lines.METER_NO;
                if meter_count=1 then
--                    select * into v_company_Service_view from v_company_Service where "number"=v_cur_imp_mr_loop_lines.service_no;
                    select CREATED_DATE into meter_date from m_company_meter where meter_number=v_cur_imp_mr_loop_lines.METER_NO;
                    if meter_date<sysdate then
                    UPDATE m_company_meter SET enabled='N' WHERE METER_NUMBER=v_cur_imp_mr_loop_lines.METER_NO;
                    end if;
                 elsif  meter_count=0 then
                    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.METER_CREATION','METER-EXISTS','METER_NO - '||v_cur_imp_mr_loop_lines.METER_NO,'','', sysdate,I_BATCH_KEY);
                    INSERT INTO M_COMPANY_METER --mF from amr is used here
                    (ID, M_COMPANY_SERVICE_ID, METER_NUMBER, METER_MAKE_CODE, ACCURACY_CLASS_CODE, IS_ABTMETER, MF, REMARKS, CREATED_BY, CREATED_DATE, MODIFIED_BY, MODIFIED_DATE, MODEM_NUMBER, ENABLED, METER_CT1, METER_CT2, METER_CT3, METER_PT1, METER_PT2, METER_PT3, IMPORT_REMARKS, CT_RATIO, PT_RATIO)
                    VALUES(M_COMPANY_METER_SEQ.NEXTVAL, v_company_Service_view.ID, v_cur_imp_mr_loop_lines.METER_NO, '', '', '', v_cur_imp_mr_loop_lines.MF, '',v_created_By, sysdate, '', '', '', 'Y', '', '', '', '', '', '', 'METER_NUMBER_CHANGE.CLEANSE', '', '');
                     v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.METER_CREATION','METER-CREATED','METER_NO - '||v_cur_imp_mr_loop_lines.METER_NO,'','', sysdate,I_BATCH_KEY);
                end if;
                
            end if;
            END LOOP;
        end if;
    END LOOP;
   --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CLEANSE','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE



  END METER_CREATION;
  
  
  PROCEDURE CLEANSE(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
v_log_result  varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';   
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.CLEANSE';
v_mri_rec IMP_MC_MR_LINES%ROWTYPE;
v_prev_read_in_oa boolean;
v_prev_read_in_imp_table boolean;
v_older_read_in_oa boolean;
v_older_read_in_imp_table boolean;
v_prev_month varchar2(100);
v_prev_year varchar2(100);
v_curr_month_first_date date;
v_count NUMBER; 
v_mr_id varchar2(100);
v_mri_id varchar2(100);

    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CLEANSE','CLEANSE','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   -------------------------------------------------------- LOGIC
  FOR mril IN (SELECT  line.id, line.IMP_MC_MR_HEADER_ID ,line.SERVICE_NO,line.METER_NO, line.READING_MONTH, line.READING_YEAR
			FROM IMP_MC_MR_LINES line
			WHERE 1=1
			and line.IMP_MC_MR_HEADER_ID = I_BATCH_KEY
            and status_code = 'CREATED'
            ORDER BY line.SERVICE_NO,line.METER_NO,line.INIT_READING_DT)
	LOOP
    begin --loop exception starts here
    v_prev_read_in_oa := false;  
    v_prev_read_in_imp_table := false;  
    v_older_read_in_oa := false;  
    v_older_read_in_imp_table := false;
    v_prev_month := TO_CHAR(to_date((mril.READING_YEAR||'-'||mril.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')-1,'MM');
    v_prev_year := TO_CHAR(to_date((mril.READING_YEAR||'-'||mril.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')-1,'YYYY');
    v_curr_month_first_date := to_date((mril.READING_YEAR||'-'||mril.READING_MONTH||'-'||'01' ),'YYYY-MM-DD') ;

		SELECT * INTO v_mri_rec FROM IMP_MC_MR_LINES WHERE id = mril.id;
        
        dbms_output.put_line(' v_mri_rec===='||v_mri_rec.id);
--        dbms_output.put_line(' v_prev_year===='|| v_prev_year);
		SELECT count( mr.id )INTO v_count FROM T_METER_READING_HDR mr
						JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID
						JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
						WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
						AND mr.READING_MONTH = v_prev_month
						AND mr.READING_YEAR = v_prev_year;
         v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CLEANSE','CLEANSE','v_count - '||v_count,'v_prev_month'||v_prev_month,'v_prev_year'||v_prev_year, sysdate,I_BATCH_KEY);
        if(v_count > 0 ) then v_prev_read_in_oa := true;  end if;
        
        SELECT count(*) INTO v_count FROM  IMP_MC_MR_LINES where IMP_MC_MR_HEADER_ID = I_BATCH_KEY AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
				AND READING_MONTH = v_prev_month
				AND READING_YEAR = v_prev_month ;
        if(v_count > 0 ) then v_prev_read_in_imp_table := true;  end if;
        
        SELECT count( mr.id )INTO v_count FROM T_METER_READING_HDR mr
                    JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID
                    JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
                    WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
                    AND mr.FINAL_READING_DT  < v_curr_month_first_date;
        if(v_count > 0 ) then v_older_read_in_oa := true;     end if;
        
        SELECT count(*) INTO v_count FROM  IMP_MC_MR_LINES mr where IMP_MC_MR_HEADER_ID = I_BATCH_KEY AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
				AND to_date(mr.FINAL_READING_DT,'YYYY-MM-DD')	  < v_curr_month_first_date;
        if(v_count > 0 ) then v_older_read_in_imp_table := true;     end if;
        
        if(v_prev_read_in_oa)THEN
        
        SELECT  mr.id INTO v_mr_id FROM T_METER_READING_HDR mr
			JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID
            JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
            WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
			AND mr.READING_MONTH = v_prev_month
			AND mr.READING_YEAR = v_prev_year;
            
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S1, v_mri_rec.EXP_INIT_S1  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C1';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S2, v_mri_rec.EXP_INIT_S2  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C2';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S3, v_mri_rec.EXP_INIT_S3  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C3';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S4, v_mri_rec.EXP_INIT_S4  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C4';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S5, v_mri_rec.EXP_INIT_S5  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C5';
        
            select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0), to_char(FINAL_READING_DT+1,'YYYY-MM-DD' )
            INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT , v_mri_rec.INIT_READING_DT
            from T_METER_READING_HDR where id = v_mr_id;
        ELSIF (v_prev_read_in_imp_table) THEN

        SELECT  id INTO  v_mri_id FROM  IMP_MC_MR_LINES where IMP_MC_MR_HEADER_ID = I_BATCH_KEY AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
			AND READING_MONTH = v_prev_month
			AND READING_YEAR = v_prev_year;

			SELECT nvl(IMP_FINAL_S1,0), nvl(IMP_FINAL_S2,0), nvl(IMP_FINAL_S3,0), nvl(IMP_FINAL_S4,0), nvl(IMP_FINAL_S5,0),
                   nvl(EXP_FINAL_S1,0), nvl(EXP_FINAL_S2,0), nvl(EXP_FINAL_S3,0), nvl(EXP_FINAL_S4,0), nvl(EXP_FINAL_S5,0)
            INTO   v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
                   v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5
            FROM   IMP_MC_MR_lines where id = v_mri_id;
        
              select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0) ,to_char(to_date(FINAL_READING_DT,'YYYY-MM-DD')+1,'YYYY-MM-DD' )
              INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT  , v_mri_rec.INIT_READING_DT
              from IMP_MC_MR_lines where id = v_mri_id;  
        elsif(v_older_read_in_oa)THEN

			SELECT  id INTO v_mr_id from(
			SELECT mr.id FROM T_METER_READING_HDR mr
			JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID
			JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
			WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
			AND mr.FINAL_READING_DT  <  v_curr_month_first_date
			ORDER BY mr.FINAL_READING_DT desc) WHERE  rownum =1;

			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S1, v_mri_rec.EXP_INIT_S1  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C1';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S2, v_mri_rec.EXP_INIT_S2  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C2';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S3, v_mri_rec.EXP_INIT_S3  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C3';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S4, v_mri_rec.EXP_INIT_S4  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C4';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S5, v_mri_rec.EXP_INIT_S5  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C5';

              select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0), to_char(FINAL_READING_DT+1,'YYYY-MM-DD' )
              INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT  , v_mri_rec.INIT_READING_DT
              from T_METER_READING_HDR where id = v_mr_id;
              
      	ELSIF (v_older_read_in_imp_table) THEN


			SELECT  id INTO  v_mri_id from(
			SELECT mr.id FROM  IMP_MC_MR_lines mr where IMP_MC_MR_HEADER_ID = I_BATCH_KEY AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
			AND to_date(mr.FINAL_READING_DT,'YYYY-MM-DD')  < v_curr_month_first_date
			ORDER BY mr.FINAL_READING_DT DESC) WHERE  rownum = 1;



			SELECT nvl(IMP_FINAL_S1,0), nvl(IMP_FINAL_S2,0), nvl(IMP_FINAL_S3,0), nvl(IMP_FINAL_S4,0), nvl(IMP_FINAL_S5,0),
					nvl(EXP_FINAL_S1,0), nvl(EXP_FINAL_S2,0), nvl(EXP_FINAL_S3,0), nvl(EXP_FINAL_S4,0), nvl(EXP_FINAL_S5,0),
          nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0)
				INTO
					v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5,
          v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT
				FROM  IMP_MR_lines where id = v_mri_id;
    
          select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0),to_char(to_date(FINAL_READING_DT,'YYYY-MM-DD')+1,'YYYY-MM-DD' )
          INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT,    v_mri_rec.INIT_READING_DT
          from T_METER_READING_HDR where id = v_mri_id;
		ELSE
			SELECT 'Y',0,0,0,0,0,0,0,0,0,0,0,0 INTO v_mri_rec.is_first_entry,v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5,v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT   FROM dual;
        end if;  
              
              	UPDATE IMP_MC_MR_lines SET ROW = v_mri_rec WHERE id = v_mri_rec.id;
	exception
    	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CLEANSE-LOOP','EXCEPTION',v_reason,O_RESULT_DESC,'', sysdate,I_BATCH_KEY);
    end;--loop exception ends here
    END LOOP;
    
    	UPDATE IMP_MC_MR_LINES SET STATUS_CODE = 'CLEANSED', remarks = ''
	WHERE  IMP_MC_MR_HEADER_ID = I_BATCH_KEY AND STATUS_CODE = 'CREATED';

   --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CLEANSE','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE
  END CLEANSE;
  
  
    
  PROCEDURE IDENTIFY_ERRORS(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
v_log_result  varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';   
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.IDENTIFY_ERRORS';
v_mri_rec IMP_MC_MR_LINES%ROWTYPE;

BEGIN
BEGIN --EXCEPTION STARTS HERE
v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.IDENTIFY_ERRORS','IDENTIFY_ERRORS','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

-------------------------------------------------------- LOGIC
  
  
    --if final ReadingDate <> InitialReadingDate and if Day of FinalReadingDate is 01, then update reduce the FinalReadingDate by one
    UPDATE IMP_MC_MR_LINES SET final_READING_DT= to_char(to_date(final_READING_DT,'yyyy-mm-dd') -1,'yyyy-mm-dd')
    WHERE IMP_MC_MR_HEADER_ID =  I_BATCH_KEY
	AND to_date(INIT_READING_DT,'yyyy-mm-dd') != to_date(final_READING_DT,'yyyy-mm-dd')
	AND SUBSTR(final_READING_DT,9,2) = '01';

	-- dbms_output.put_line('Date stripped');

	/*
	--Ignore any record older than May-2017 - Mark as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Too old records'
	WHERE IMP_MR_HEADER_ID =  I_BATCH_KEY
	AND (final_READING_DT IS NOT NULL AND TO_NUMBER(SUBSTR(final_READING_DT,6,2)) < 5) ;


	*/

	--Mark all records as error with remarks if Final-ReadingDate < InitialReadingDate and not already marked as error with remarks
	UPDATE IMP_MC_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'FinalReadingDate < InitialReadingDate '
	WHERE IMP_MC_MR_HEADER_ID =  I_BATCH_KEY
	AND STATUS_CODE = 'CREATED'
	AND (final_READING_DT IS NOT NULL AND  init_READING_DT IS NOT NULL AND to_date(final_READING_DT,'yyyy-mm-dd') < to_date(init_READING_DT,'yyyy-mm-dd'));





	--If the Service-No doesnt exists in m_company_service, mark as error with remarks
	UPDATE IMP_MC_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Unknown Service-no'
	WHERE IMP_MC_MR_HEADER_ID =  I_BATCH_KEY
	AND STATUS_CODE = 'CREATED'
	AND SERVICE_NO  IN
        (
         SELECT distinct SERVICE_NO  FROM IMP_MC_MR_LINES where IMP_MC_MR_HEADER_ID= I_BATCH_KEY
          minus
         SELECT distinct  "number"  FROM M_COMPANY_SERVICE
        );

	--If   Final values is null, mark as error with remarks
	UPDATE IMP_MC_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Initial/Final values is null'
	WHERE IMP_MC_MR_HEADER_ID =  I_BATCH_KEY
	AND STATUS_CODE = 'CREATED'
	AND ( EXP_FINAL_S1 is null or EXP_FINAL_S2 is null or EXP_FINAL_S3 is null or EXP_FINAL_S4 is null or EXP_FINAL_S5 is null
                     or   IMP_FINAL_S1 is null or IMP_FINAL_S2 is null or IMP_FINAL_S3 is null or IMP_FINAL_S4 is null or IMP_FINAL_S5 is null );

--If the initial or final reading date is null, mark as error with remarks
	UPDATE IMP_MC_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Initial or Final Reading date is null'
	WHERE IMP_MC_MR_HEADER_ID =  I_BATCH_KEY
	AND STATUS_CODE = 'CREATED'
	AND (init_READING_DT IS NULL OR final_READING_DT IS NULL );

	-- make sure the readings from mri, doesnt exist in MeterReading table
	 UPDATE IMP_MC_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Meter Reading Already Exists'
	 WHERE id IN (SELECT mri.id
		FROM IMP_MC_MR_LINES mri
		 JOIN M_COMPANY_METER meter ON meter.METER_NUMBER = mri.METER_NO
		 JOIN M_COMPANY_SERVICE ser ON ser."number" = mri.SERVICE_NO AND meter.M_COMPANY_SERVICE_ID = ser.id
		 JOIN T_METER_READING_HDR mrh ON meter.id = mrh.M_COMPANY_METER_ID AND mri.READING_MONTH = mrh.READING_MONTH AND mri.READING_YEAR = mrh.READING_YEAR
		WHERE mri.IMP_MC_MR_HEADER_ID = I_BATCH_KEY
		and mri.status_code = 'CREATED');




-- as MF from AMR is wrong/inconsistent, MF from OA is used
  for oa_data in (select mrl.id,  mrl.service_no,mrl.meter_no, ser.mf  from imp_mr_lines mrl
                join v_company_service ser on mrl.service_no=ser."number" and mrl.meter_no=ser.meter_number 
                where mrl.imp_mr_header_id= I_BATCH_KEY and mrl.status_code = 'CREATED')
  loop 
    update IMP_MC_MR_LINES set mf = oa_data.mf, MODIFIED_BY='admin', MODIFIED_DATE=sysdate 
      where IMP_MC_MR_HEADER_ID= I_BATCH_KEY and service_no= oa_data.service_no and meter_no = oa_data.meter_no; 
  end loop;

--return 'MIDDLE';

-- if dual entries entry exists for a meter in same month
-- Find MRI with multiple entries for same month if dual entries entry exists for a meter in same reading month-year in same batch
	FOR mul_entry IN (SELECT  line.IMP_MC_MR_HEADER_ID ,line.SERVICE_NO,line.METER_NO, line.READING_MONTH, line.READING_YEAR,  line.mf,count(line.METER_NO) readings_per_meter
			FROM IMP_MC_MR_LINES line
			LEFT JOIN IMP_MC_MR_header head ON line.IMP_MC_MR_HEADER_ID = head.id
			WHERE line.IMP_MC_MR_HEADER_ID = I_BATCH_KEY
			and line.status_code = 'CREATED'
			GROUP BY line.IMP_MC_MR_HEADER_ID, line.SERVICE_NO,line.METER_NO, line.READING_MONTH, line.READING_YEAR, line.mf
			HAVING count(line.METER_NO) >1)
	LOOP
    begin
		v_mri_rec.id := IMP_MR_lines_SEQ.nextval;
		v_mri_rec.IMP_MC_MR_HEADER_ID := mul_entry.IMP_MC_MR_HEADER_ID;
		v_mri_rec.STATUS_CODE := 'CREATED';
        v_mri_rec.SERVICE_NO := mul_entry.SERVICE_NO;
		v_mri_rec.METER_NO := mul_entry.METER_NO;
		v_mri_rec.READING_MONTH := mul_entry.READING_MONTH;
		v_mri_rec.READING_YEAR := mul_entry.READING_YEAR;
		v_mri_rec.mf := mul_entry.mf;
		v_mri_rec.sys_dt := TO_CHAR(SYSDATE,'yyyy-mm-dd');
		v_mri_rec.INIT_READING_DT := (mul_entry.READING_YEAR||'-'||mul_entry.READING_MONTH||'-'||'01' );
		v_mri_rec.FINAL_READING_DT := to_char(LAST_DAY( to_date((mul_entry.READING_YEAR||'-'||mul_entry.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')),'YYYY-MM-DD');

	 		--find the min values for all INIT values for the given batchNo, serviceNo, meterNo, month, year
		SELECT  min(to_number(nvl(IMP_INIT_S1,0))) IMP_INIT_S1,min(to_number(nvl(IMP_INIT_S2,0))) IMP_INIT_S2,min(to_number(nvl(IMP_INIT_S3,0))) IMP_INIT_S3,min(to_number(nvl(IMP_INIT_S4,0))) IMP_INIT_S4,min(to_number(nvl(IMP_INIT_S5,0))) IMP_INIT_S5,
				min(to_number(nvl(EXP_INIT_S1,0))) EXP_INIT_S1,min(to_number(nvl(EXP_INIT_S2,0))) EXP_INIT_S2,min(to_number(nvl(EXP_INIT_S3,0))) EXP_INIT_S3,min(to_number(nvl(EXP_INIT_S4,0))) EXP_INIT_S4,min(to_number(nvl(EXP_INIT_S5,0))) EXP_INIT_S5,
				 min(to_number(nvl(IMP_RKVAH_INIT,0))) IMP_RKVAH_INIT,min(to_number(nvl(EXP_RKVAH_INIT,0))) EXP_RKVAH_INIT,min(to_number(nvl(IMP_KVAH_INIT,0))) IMP_KVAH_INIT,min(to_number(nvl(EXP_KVAH_INIT,0))) EXP_KVAH_INIT
			 INTO v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5,
					v_mri_rec.IMP_RKVAH_INIT ,v_mri_rec.EXP_RKVAH_INIT,v_mri_rec.IMP_KVAH_INIT,v_mri_rec.EXP_KVAH_INIT
			FROM  IMP_MR_lines lines
			WHERE lines.IMP_MR_HEADER_ID = I_BATCH_KEY AND lines.SERVICE_NO = mul_entry.service_no AND lines.METER_NO = mul_entry.meter_no
			AND lines.READING_MONTH = mul_entry.READING_MONTH AND lines.READING_YEAR = mul_entry.READING_YEAR
      group by lines.IMP_MR_HEADER_ID,lines.SERVICE_NO ,lines.METER_NO,lines.READING_MONTH ,lines.READING_YEAR ;


		--find the max values for all final values for the given batchNo, serviceNo, meterNo, month, year
		SELECT  max(to_number(nvl(IMP_FINAL_S1,0))) IMP_FINAL_S1,max(to_number(nvl(IMP_FINAL_S2,0))) IMP_FINAL_S2,max(to_number(nvl(IMP_FINAL_S3,0))) IMP_FINAL_S3,max(to_number(nvl(IMP_FINAL_S4,0))) IMP_FINAL_S4,max(to_number(nvl(IMP_FINAL_S5,0))) IMP_FINAL_S5,

				max(to_number(nvl(EXP_FINAL_S1,0))) EXP_FINAL_S1,max(to_number(nvl(EXP_FINAL_S2,0))) EXP_FINAL_S2,max(to_number(nvl(EXP_FINAL_S3,0))) EXP_FINAL_S3,max(to_number(nvl(EXP_FINAL_S4,0))) EXP_FINAL_S4,max(to_number(nvl(EXP_FINAL_S5,0))) EXP_FINAL_S5,
				 max(to_number(nvl(IMP_RKVAH_FINAL,0))) IMP_RKVAH_FINAL,max(to_number(nvl(EXP_RKVAH_FINAL,0))) EXP_RKVAH_FINAL,max(to_number(nvl(IMP_KVAH_FINAL,0))) IMP_KVAH_FINAL,max(to_number(nvl(EXP_KVAH_FINAL,0))) EXP_KVAH_FINAL
			 INTO v_mri_rec.IMP_FINAL_S1, v_mri_rec.IMP_FINAL_S2, v_mri_rec.IMP_FINAL_S3, v_mri_rec.IMP_FINAL_S4, v_mri_rec.IMP_FINAL_S5,
					v_mri_rec.EXP_FINAL_S1, v_mri_rec.EXP_FINAL_S2, v_mri_rec.EXP_FINAL_S3, v_mri_rec.EXP_FINAL_S4, v_mri_rec.EXP_FINAL_S5,
					v_mri_rec.IMP_RKVAH_FINAL ,v_mri_rec.EXP_RKVAH_FINAL,v_mri_rec.IMP_KVAH_FINAL,v_mri_rec.EXP_KVAH_FINAL
			FROM  IMP_MR_lines lines
			WHERE lines.IMP_MR_HEADER_ID = I_BATCH_KEY AND lines.SERVICE_NO = mul_entry.service_no AND lines.METER_NO = mul_entry.meter_no
			AND lines.READING_MONTH = mul_entry.READING_MONTH AND lines.READING_YEAR = mul_entry.READING_YEAR
      group by lines.IMP_MR_HEADER_ID,lines.SERVICE_NO ,lines.METER_NO,lines.READING_MONTH ,lines.READING_YEAR ;


		UPDATE IMP_MR_LINES lines SET STATUS_CODE= 'ERROR', REMARKS = 'Multiple entries in same month', REF_NO = v_mri_rec.id
			WHERE IMP_MR_HEADER_ID =  I_BATCH_KEY AND lines.SERVICE_NO = mul_entry.service_no AND lines.METER_NO = mul_entry.meter_no
			AND lines.READING_MONTH = mul_entry.READING_MONTH AND lines.READING_YEAR = mul_entry.READING_YEAR;

		INSERT INTO IMP_MC_MR_LINES VALUES v_mri_rec;


  exception
          when others then
            v_exception_code := SQLCODE;
            v_exception_msg := SUBSTR(SQLERRM, 1, 200);
            v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','MRI_IDENTIFY_ERRORS-LOOP','EXCEPTION',v_reason,v_result,'', sysdate,I_BATCH_KEY);
          UPDATE IMP_MR_LINES SET STATUS_CODE = 'ERROR', remarks = 'Unknown Issues - possiblly data issue'
            WHERE  id = v_mri_rec.id;
        end;
	END LOOP;



   --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.IDENTIFY_ERRORS','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE
  END IDENTIFY_ERRORS;
  
  
    PROCEDURE CREATE_METER_READING(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_result varchar(300):='SUCCESS';   
    v_created_Date DATE := SYSDATE;
    v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.CREATE_METER_READING';
    v_process_count number;
    v_total_count number;
    v_mrh T_METER_READING_HDR%ROWTYPE;
    v_mr_c1 T_METER_READING_SLOT%ROWTYPE;v_mr_c2 T_METER_READING_SLOT%ROWTYPE;
    v_mr_c3 T_METER_READING_SLOT%ROWTYPE;v_mr_c4 T_METER_READING_SLOT%ROWTYPE;v_mr_c5 T_METER_READING_SLOT%ROWTYPE;
    v_meter_id VARCHAR2(100);

    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','CREATE_METER_READING','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   -------------------------------------------------------- LOGIC
    select count(id) into v_process_count from IMP_MC_MR_HEADER where status ='PROCESSING';


    -- find the total no. of records to be imported
    select count(import_remarks) into v_total_count from IMP_MC_MR_HEADER where id =I_BATCH_KEY;
    -- set the batch to PROCESSING
    update IMP_MC_MR_HEADER set status='PROCESSING', total_count=v_total_count, MODIFIED_DATE = sysdate where id = I_BATCH_KEY; 
    
    
    --loop through clean imported meter entries
		FOR mri IN (SELECT mri.* FROM IMP_MC_MR_LINES mri WHERE mri.IMP_MC_MR_HEADER_ID = I_BATCH_KEY and mri.status_code = 'CLEANSED')
		LOOP
   		begin
	
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','loop start',mri.meter_no,null,'', sysdate,I_BATCH_KEY);
		  	-- get meter-id
		  	SELECT DISTINCT meter.id INTO v_meter_id FROM M_COMPANY_METER  meter
		  		JOIN M_COMPANY_SERVICE ser ON ser."number" = mri.SERVICE_NO AND meter.M_COMPANY_SERVICE_ID = ser.id WHERE METER_NUMBER = mri.meter_no;
		 	--setting meter-header record
		 	v_mrh.id := T_METER_READING_SEQ.nextval;
			v_mrh.M_COMPANY_METER_ID := v_meter_id;
			v_mrh.STATUS_CODE := 'CREATED';
			v_mrh.IMP_BATCH_ID :=  mri.IMP_MC_MR_HEADER_ID;
			v_mrh.sys_dt := v_created_Date;
			v_mrh.mf :=  mri.mf;
			v_mrh.READING_MONTH := mri.READING_MONTH;
			v_mrh.READING_YEAR := mri.READING_YEAR;
			v_mrh.INIT_READING_DT := to_date(mri.INIT_READING_DT,'yyyy-mm-dd');
			v_mrh.FINAL_READING_DT := to_date(mri.FINAL_READING_DT,'yyyy-mm-dd');
            v_mrh.MERGE_WITH_NEXT_BILLING := NVL(mri.MERGE_WITH_NEXT_BILLING,'N');
			v_mrh.EXP_RKVAH_FINAL := mri.EXP_RKVAH_FINAL; v_mrh.EXP_RKVAH_INIT := mri.EXP_RKVAH_INIT;
			v_mrh.IMP_RKVAH_FINAL := mri.IMP_RKVAH_FINAL; v_mrh.IMP_RKVAH_INIT := mri.IMP_RKVAH_INIT;
			v_mrh.EXP_KVAH_FINAL := mri.EXP_KVAH_FINAL; v_mrh.EXP_KVAH_INIT := mri.EXP_KVAH_INIT;
			v_mrh.IMP_KVAH_FINAL := mri.IMP_KVAH_FINAL; v_mrh.IMP_KVAH_INIT := mri.IMP_KVAH_INIT;
			v_mrh.RKVAH_DIFF := nvl(mri.IMP_RKVAH_FINAL,0) - nvl(mri.IMP_RKVAH_INIT, 0);
			v_mrh.RKVAH_UNITS := v_mrh.RKVAH_DIFF*mri.mf;
			v_mrh.KVAH_DIFF := nvl((mri.EXP_KVAH_FINAL - mri.EXP_KVAH_INIT)- (mri.IMP_KVAH_FINAL - mri.IMP_KVAH_INIT), 0);
--          v_mrh.KVAH_DIFF := nvl(( mri.IMP_KVAH_FINAL - mri.IMP_KVAH_INIT), 0);
			v_mrh.KVAH_UNITS := v_mrh.KVAH_DIFF*mri.mf;
			--v_mrh.TOTAL_IMPORT_GEN := ;
			--v_mrh.TOTAL_EXPORT_GEN := ;
			v_mrh.CREATED_BY := v_created_By;
			v_mrh.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_HDR VALUES v_mrh;
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','insert meter-header record',null,'', sysdate,I_BATCH_KEY);
	
	
			--setting meter-reading for slot1
			v_mr_c1.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c1.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c1.SLOT_CODE := 'C1' ;
			v_mr_c1.IMP_INIT := nvl(mri.IMP_INIT_S1,0);
			v_mr_c1.IMP_FINAL := nvl(mri.IMP_FINAL_S1,0);
			v_mr_c1.EXP_INIT := nvl(mri.EXP_INIT_S1,0);
			v_mr_c1.EXP_FINAL := nvl(mri.EXP_FINAL_S1,0);
			v_mr_c1.IMP_DIFF := v_mr_c1.IMP_FINAL - v_mr_c1.IMP_INIT ;
			v_mr_c1.EXP_DIFF := v_mr_c1.EXP_FINAL - v_mr_c1.EXP_INIT ;
			v_mr_c1.IMP_UNITS := round(nvl(v_mr_c1.IMP_DIFF * mri.mf,0),0);
			v_mr_c1.EXP_UNITS :=  round(nvl(v_mr_c1.EXP_DIFF * mri.mf,0),0);
			v_mr_c1.net_units := v_mr_c1.EXP_UNITS - v_mr_c1.IMP_UNITS ;
			if(v_mr_c1.net_units <0) THEN v_mr_c1.net_units := 0; END IF;
			v_mr_c1.CREATED_BY := v_created_By;
			v_mr_c1.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c1;
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','slot-1',null,'', sysdate,I_BATCH_KEY);
	
	
			--setting meter-reading for slot2
			v_mr_c2.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c2.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c2.SLOT_CODE := 'C2' ;
			v_mr_c2.IMP_INIT := nvl(mri.IMP_INIT_S2,0);
			v_mr_c2.IMP_FINAL := nvl(mri.IMP_FINAL_S2,0);
			v_mr_c2.EXP_INIT := nvl(mri.EXP_INIT_S2,0);
			v_mr_c2.EXP_FINAL := nvl(mri.EXP_FINAL_S2,0);
			v_mr_c2.IMP_DIFF := v_mr_c2.IMP_FINAL - v_mr_c2.IMP_INIT ;
			v_mr_c2.EXP_DIFF := v_mr_c2.EXP_FINAL - v_mr_c2.EXP_INIT ;
			v_mr_c2.IMP_UNITS := round(nvl(v_mr_c2.IMP_DIFF * mri.mf,0),0);
			v_mr_c2.EXP_UNITS := round(nvl(v_mr_c2.EXP_DIFF * mri.mf,0),0);
			v_mr_c2.net_units := v_mr_c2.EXP_UNITS - v_mr_c2.IMP_UNITS ;
			if(v_mr_c2.net_units <0) THEN v_mr_c2.net_units := 0; END IF;
			v_mr_c2.CREATED_BY := v_created_By;
			v_mr_c2.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c2;
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','slot-2',null,'', sysdate,I_BATCH_KEY);
	
	
			--setting meter-reading for slot3
			v_mr_c3.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c3.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c3.SLOT_CODE := 'C3' ;
			v_mr_c3.IMP_INIT := nvl(mri.IMP_INIT_S3,0);
			v_mr_c3.IMP_FINAL := nvl(mri.IMP_FINAL_S3,0);
			v_mr_c3.EXP_INIT := nvl(mri.EXP_INIT_S3,0);
			v_mr_c3.EXP_FINAL := nvl(mri.EXP_FINAL_S3,0);
			v_mr_c3.IMP_DIFF := v_mr_c3.IMP_FINAL - v_mr_c3.IMP_INIT ;
			v_mr_c3.EXP_DIFF := v_mr_c3.EXP_FINAL - v_mr_c3.EXP_INIT ;
			v_mr_c3.IMP_UNITS := round(nvl(v_mr_c3.IMP_DIFF * mri.mf,0),0);
			v_mr_c3.EXP_UNITS := round(nvl(v_mr_c3.EXP_DIFF * mri.mf,0),0);
			v_mr_c3.net_units := v_mr_c3.EXP_UNITS - v_mr_c3.IMP_UNITS ;
			if(v_mr_c3.net_units <0) THEN v_mr_c3.net_units := 0; END IF;
			v_mr_c3.CREATED_BY := v_created_By;
			v_mr_c3.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c3;
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','slot-3',null,'', sysdate,I_BATCH_KEY);
	
			--setting meter-reading for slot4
			v_mr_c4.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c4.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c4.SLOT_CODE := 'C4' ;
			v_mr_c4.IMP_INIT := nvl(mri.IMP_INIT_S4,0);
			v_mr_c4.IMP_FINAL := nvl(mri.IMP_FINAL_S4,0);
			v_mr_c4.EXP_INIT := nvl(mri.EXP_INIT_S4,0);
			v_mr_c4.EXP_FINAL := nvl(mri.EXP_FINAL_S4,0);
			v_mr_c4.IMP_DIFF := v_mr_c4.IMP_FINAL - v_mr_c4.IMP_INIT ;
			v_mr_c4.EXP_DIFF := v_mr_c4.EXP_FINAL - v_mr_c4.EXP_INIT ;
			v_mr_c4.IMP_UNITS := round(nvl(v_mr_c4.IMP_DIFF * mri.mf,0),0);
			v_mr_c4.EXP_UNITS := round(nvl(v_mr_c4.EXP_DIFF * mri.mf,0),0);
			v_mr_c4.net_units := v_mr_c4.EXP_UNITS - v_mr_c4.IMP_UNITS ;
			if(v_mr_c4.net_units <0) THEN v_mr_c4.net_units := 0; END IF;
			v_mr_c4.CREATED_BY := v_created_By;
			v_mr_c4.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c4;
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','slot-4',null,'', sysdate,I_BATCH_KEY);
	
	
			--setting meter-reading for slot5
			v_mr_c5.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c5.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c5.SLOT_CODE := 'C5' ;
			v_mr_c5.IMP_INIT := nvl(mri.IMP_INIT_S5,0);
			v_mr_c5.IMP_FINAL := nvl(mri.IMP_FINAL_S5,0);
			v_mr_c5.EXP_INIT := nvl(mri.EXP_INIT_S5,0);
			v_mr_c5.EXP_FINAL := nvl(mri.EXP_FINAL_S5,0);
			v_mr_c5.IMP_DIFF := v_mr_c5.IMP_FINAL - v_mr_c5.IMP_INIT ;
			v_mr_c5.EXP_DIFF := v_mr_c5.EXP_FINAL - v_mr_c5.EXP_INIT ;
			v_mr_c5.IMP_UNITS := round(nvl(v_mr_c5.IMP_DIFF * mri.mf,0),0);
			v_mr_c5.EXP_UNITS := round(nvl(v_mr_c5.EXP_DIFF * mri.mf,0),0);
			v_mr_c5.net_units := v_mr_c5.EXP_UNITS - v_mr_c5.IMP_UNITS ;
			if(v_mr_c5.net_units <0) THEN v_mr_c5.net_units := 0; END IF;
			v_mr_c5.CREATED_BY := v_created_By;
			v_mr_c5.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c5;
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','slot-5',null,'', sysdate,I_BATCH_KEY);
	
	
			UPDATE T_METER_READING_HDR SET
					total_import_gen = v_mr_c1.IMP_UNITS + v_mr_c2.IMP_UNITS + v_mr_c3.IMP_UNITS + v_mr_c4.IMP_UNITS + v_mr_c5.IMP_UNITS,
					total_export_gen = v_mr_c1.EXP_UNITS + v_mr_c2.EXP_UNITS + v_mr_c3.EXP_UNITS + v_mr_c4.EXP_UNITS + v_mr_c5.EXP_UNITS,
					net_gen_units = v_mr_c1.NET_UNITS + v_mr_c2.NET_UNITS + v_mr_c3.NET_UNITS + v_mr_c4.NET_UNITS + v_mr_c5.NET_UNITS
					WHERE id = v_mrh.id;
                    
                    if mri.DOWNLOADSTATUS='METER CHANGE' then                   	
                    UPDATE T_METER_READING_HDR SET IS_METER_CHANGE='Y' WHERE id = v_mrh.id;
                    end if;
                    
	        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','log','updated',null,'', sysdate,I_BATCH_KEY);
	
            update IMP_MC_MR_LINES set STATUS_CODE = 'IMPORTED' where id = mri.id;
                v_result := 'SUCCESS'; -- resetting result after every loop. as individual loop's result doesnt affect overall procedure's result.
                		    exception
			  when others then
			    v_exception_code := SQLCODE;
			    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
			    v_result := 'FAILURE';
			    v_reason := v_exception_code || ' - ' || v_exception_msg;
			    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING-LOOP','EXCEPTION','End - '||I_BATCH_KEY,v_result || ' - ' || v_reason,v_created_By, sysdate,I_BATCH_KEY, mri.SERVICE_NO, mri.METER_NO);
			   -- dbms_output.put_line('IMPORT_MR - '||v_reason);
			END;
    END LOOP;
     --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_METER_READING','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE

  END CREATE_METER_READING;


    PROCEDURE CREATE_TEMP_GENERATION_STATEMENT(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_result varchar(300):='SUCCESS';   
    v_created_Date DATE := SYSDATE;
    v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.CREATE_GENERATION_STATEMENT';
    v_process_id  VARCHAR2(50);
    v_records_processed number:=0;
    v_service_number varchar2(50);

    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_TEMP_GENERATION_STATEMENT','CREATE_GENERATION_STATEMENT','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   -------------------------------------------------------- LOGIC
    v_process_id := T_PROCESS_GS_SEQ.nextval;
    INSERT INTO T_PROCESS_GS (ID,SYS_DT,STATUS,START_DT,END_DT,REMARKS)
    VALUES (v_process_id,v_created_Date,'PROCESSING',v_created_Date,NULL,NULL) ;
    
    FOR mr IN (SELECT mh.id, m_company_meter_id FROM T_METER_READING_HDR mh  WHERE mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL
                      AND READING_MONTH = I_MONTH AND READING_YEAR = I_YEAR AND mh.IS_METER_CHANGE='Y')
      LOOP
--        select "number" into v_service_number from v_company_service where m_company_meter_id=mr.m_company_meter_id; 
--        BANKING_BALANCE.open_balance(v_service_number,I_MONTH,I_YEAR,O_RESULT_CODE,O_RESULT_DESC);   
         v_result:=METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT(I_BATCH_KEY,v_process_id,mr.id);
        if (v_result='SUCCESS') then
            v_records_processed := v_records_processed +1;
        end if;
    END LOOP;
   --------------------------------------------------------

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_TEMP_GENERATION_STATEMENT','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE

  END CREATE_TEMP_GENERATION_STATEMENT;
  

FUNCTION PROCESS_TEMP_GENERATION_STATEMENT
(
  I_BATCH_KEY in varchar2,
  v_gs_process_id in varchar2,
  v_mr_id in varchar2
) RETURN VARCHAR2 AS
 
v_stage varchar2(50);
v_process_id  VARCHAR2(50); 
v_gen_count  NUMBER:=0;
v_mrh T_METER_READING_HDR%ROWTYPE;
v_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_mr_c5 T_METER_READING_SLOT%ROWTYPE;
v_gs TMP_GEN_STMT%ROWTYPE;
v_gs_c1 TMP_GEN_STMT_SLOT%ROWTYPE;
v_gs_c2 TMP_GEN_STMT_SLOT%ROWTYPE;
v_gs_c3 TMP_GEN_STMT_SLOT%ROWTYPE;
v_gs_c4 TMP_GEN_STMT_SLOT%ROWTYPE;
v_gs_c5 TMP_GEN_STMT_SLOT%ROWTYPE;
v_no_records BOOLEAN:=TRUE;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='';
v_plant_class_code VARCHAR2(200);
v_plant_class_desc VARCHAR2(200);
v_gen_month  VARCHAR2(50); 
v_gen_year  VARCHAR2(50); 
v_gen_comp_servi_id VARCHAR2(200);
tariff_rates VARCHAR2(200);
v_log_result varchar(300):='SUCCESS';
v_imported BOOLEAN;

v_gen_voltage_desc VARCHAR2(50); 
v_gen_org_code VARCHAR2(50); 
v_gen_iscaptive VARCHAR2(50); 
v_gen_isstb VARCHAR2(50);
v_gen_isstb_count NUMBER; 
v_gen_ssid VARCHAR2(50) ;
v_gen_ssname  VARCHAR2(50);
v_gen_sstype  VARCHAR2(50);
v_gen_ffid   VARCHAR2(50);
v_gen_ffname VARCHAR2(50);
v_tariff_net_amount VARCHAR2(150);  
v_net_payable VARCHAR2(150);
v_total_charged_amount  VARCHAR2(150);
v_flow_type_code  VARCHAR2(150);

v_prev_mr_id varchar2(50);
v_prev_mr T_METER_READING_HDR%ROWTYPE;
v_prev_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c5 T_METER_READING_SLOT%ROWTYPE;

BEGIN

	BEGIN	
        v_stage := '-1-start';
        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT','Start',v_reason,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

		FOR meter IN (SELECT mh.M_COMPANY_METER_ID, READING_MONTH, READING_YEAR,
						nvl(bg.C1,0) bc1, nvl(bg.C2,0) bc2, nvl(bg.C3,0) bc3,nvl(bg.C4,0) bc4,nvl(bg.C5,0) bc5,  
						cs.M_ORG_ID, c.ID M_COMPANY_ID,cm.M_COMPANY_SERVICE_ID, c.NAME DISP_COMPANY_NAME, cs."number" DISP_SERVICE_NUMBER, cs.VOLTAGE_CODE INJECTING_VOLTAGE_CODE, o.NAME DISP_ORG_NAME,cs.flow_type_code,
						pp.FUEL_TYPE_CODE DISP_FUEL_TYPE_CODE, fuel_codes.VALUE_DESC  DISP_FUEL_TYPE_NAME,pp.COMMISSION_DATE COMMISSION_DATE,cs.IS_REC IS_REC,cs.TOTAL_CAPACITY TOTAL_CAPACITY
						FROM T_METER_READING_HDR mh 
						INNER JOIN M_COMPANY_METER cm ON mh.M_COMPANY_METER_ID = cm.ID
						INNER JOIN M_COMPANY_SERVICE cs ON cm.M_COMPANY_SERVICE_ID = cs.id
						INNER JOIN M_COMPANY c ON cs.M_COMPANY_ID = c.id
						INNER JOIN M_ORG o ON cs.M_ORG_ID = o.id
                        LEFT JOIN T_BANKING_BALANCE bg ON bg.BANKING_SERVICE_ID = cs.BANKING_SERVICE_ID and to_number(bg.month)= to_number(mh.READING_MONTH) and to_number(bg.year)= to_number(mh.READING_YEAR)
                        LEFT JOIN M_POWERPLANT pp ON cs.id = pp.M_SERVICE_ID
                        LEFT JOIN V_CODES fuel_codes ON pp.FUEL_TYPE_CODE = fuel_codes.VALUE_CODE AND fuel_codes.list_code = 'FUEL_TYPE_CODE'				
						WHERE  mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL AND mh.IS_METER_CHANGE='Y'
                        and mh.id = v_mr_id)
		LOOP
			BEGIN

        v_stage := '-2-meter-loop-start';

        -- as there is meter-readings to process, we have to set the flag accordingly and start the generation process
				if(v_no_records) THEN
					v_no_records := FALSE;

				END IF;


        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT','Start',meter.M_COMPANY_SERVICE_ID,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

				--dbms_output.put_line('meter.M_COMPANY_METER_ID - '||meter.M_COMPANY_METER_ID);
				--dbms_output.put_line('meter.M_COMPANY_SERVICE_ID - '||meter.M_COMPANY_SERVICE_ID);
				--dbms_output.put_line('meter.READING_Year - '||meter.READING_Year);
				--dbms_output.put_line('meter.READING_MONTH - '||meter.READING_MONTH);

				-- to find generator capacity
				SELECT count(*) INTO v_gen_count FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;


        v_stage := '-3-find generator capacity';
				--dbms_output.put_line('v_gen_count- '||v_gen_count);

				if(v_gen_count =0) THEN
					-- setup issue - generator not configured properly for this service
					v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT','ISSUE','Setup Issue - '||v_process_id||' - No generator configured for service-id-->'||meter.M_COMPANY_SERVICE_ID,null,v_created_By, v_created_Date);
					CONTINUE;
				ELSE	
          -- TODO - Sum() should be revisited
                          v_stage := '-4-Sum() should be revisited';
					--SELECT sum(nvl(CAPACITY,0))  INTO v_gs.MACHINE_CAPACITY FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;
                   v_gs.MACHINE_CAPACITY:=meter.TOTAL_CAPACITY;
				END IF;


				--dbms_output.put_line('v_gs.MACHINE_CAPACITY - '||v_gs.MACHINE_CAPACITY);
                v_stage := '-5-Getmr header';

				SELECT * INTO v_mrh FROM T_METER_READING_HDR WHERE  M_COMPANY_METER_ID = meter.M_COMPANY_METER_ID AND READING_MONTH = meter.READING_MONTH AND READING_Year = meter.READING_Year;


				--dbms_output.put_line('v_mrh.id - '||v_mrh.id);

                v_stage := '-6-';

				SELECT * INTO v_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C1';
				SELECT * INTO v_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C2';
				SELECT * INTO v_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C3';
				SELECT * INTO v_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C4';
				SELECT * INTO v_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C5';



        --check if there previous meter-reading is to be included in this gen-stmt
        v_prev_mr_id := FIND_PREV_MR(v_mrh.id,'Y'); 
        if(v_prev_mr_id is not null )then
          -- previous meter reading is to be merged with the current meter reading
          SELECT * INTO v_prev_mr FROM T_METER_READING_HDR WHERE id =  v_prev_mr_id;
          SELECT * INTO v_prev_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C1';
          SELECT * INTO v_prev_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C2';
          SELECT * INTO v_prev_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C3';
          SELECT * INTO v_prev_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C4';
          SELECT * INTO v_prev_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C5';

          ----- modify current meter reading record according to the same ----

          --modify header
          v_mrh.INIT_READING_DT := v_prev_mr.INIT_READING_DT;
          v_mrh.EXP_RKVAH_INIT := v_prev_mr.EXP_RKVAH_INIT;
          v_mrh.IMP_RKVAH_INIT := v_prev_mr.IMP_RKVAH_INIT;
          v_mrh.EXP_KVAH_INIT := v_prev_mr.EXP_KVAH_INIT;
          v_mrh.IMP_KVAH_INIT := v_prev_mr.IMP_KVAH_INIT;
          v_mrh.RKVAH_DIFF := nvl(v_mrh.IMP_RKVAH_FINAL,0) - nvl(v_mrh.IMP_RKVAH_INIT, 0);
          v_mrh.RKVAH_UNITS := v_mrh.RKVAH_DIFF*v_mrh.mf;
          v_mrh.KVAH_DIFF := nvl((v_mrh.EXP_KVAH_FINAL - v_mrh.EXP_KVAH_INIT)- (v_mrh.IMP_KVAH_FINAL - v_mrh.IMP_KVAH_INIT), 0);
          v_mrh.KVAH_UNITS := v_mrh.KVAH_DIFF*v_mrh.mf;

          -- modify slot data

          --slot1 changes
          v_mr_c1.IMP_INIT := nvl(v_prev_mr_c1.IMP_INIT,0); v_mr_c1.EXP_INIT := nvl(v_prev_mr_c1.EXP_INIT,0);
          v_mr_c1.IMP_DIFF := v_mr_c1.IMP_FINAL - v_mr_c1.IMP_INIT ;v_mr_c1.EXP_DIFF := v_mr_c1.EXP_FINAL - v_mr_c1.EXP_INIT ;
          v_mr_c1.IMP_UNITS := v_mr_c1.IMP_DIFF * v_mrh.mf; v_mr_c1.EXP_UNITS := v_mr_c1.EXP_DIFF * v_mrh.mf;
          v_mr_c1.net_units := ROUND(v_mr_c1.EXP_UNITS - v_mr_c1.IMP_UNITS,0) ; if(to_number(v_mr_c1.net_units) <0) THEN v_mr_c1.net_units := 0; END IF;

          --slot2 changes
          v_mr_c2.IMP_INIT := nvl(v_prev_mr_c2.IMP_INIT,0); v_mr_c2.EXP_INIT := nvl(v_prev_mr_c2.EXP_INIT,0);
          v_mr_c2.IMP_DIFF := v_mr_c2.IMP_FINAL - v_mr_c2.IMP_INIT ;v_mr_c2.EXP_DIFF := v_mr_c2.EXP_FINAL - v_mr_c2.EXP_INIT ;
          v_mr_c2.IMP_UNITS := v_mr_c2.IMP_DIFF * v_mrh.mf; v_mr_c2.EXP_UNITS := v_mr_c2.EXP_DIFF * v_mrh.mf;
          v_mr_c2.net_units := ROUND(v_mr_c2.EXP_UNITS - v_mr_c2.IMP_UNITS,0) ; if(to_number(v_mr_c2.net_units) <0) THEN v_mr_c2.net_units := 0; END IF;

          --slot3 changes
          v_mr_c3.IMP_INIT := nvl(v_prev_mr_c3.IMP_INIT,0); v_mr_c3.EXP_INIT := nvl(v_prev_mr_c3.EXP_INIT,0);
          v_mr_c3.IMP_DIFF := v_mr_c3.IMP_FINAL - v_mr_c3.IMP_INIT ;v_mr_c3.EXP_DIFF := v_mr_c3.EXP_FINAL - v_mr_c3.EXP_INIT ;
          v_mr_c3.IMP_UNITS := v_mr_c3.IMP_DIFF * v_mrh.mf; v_mr_c3.EXP_UNITS := v_mr_c3.EXP_DIFF * v_mrh.mf;
          v_mr_c3.net_units := ROUND(v_mr_c3.EXP_UNITS - v_mr_c3.IMP_UNITS,0) ; if(to_number(v_mr_c3.net_units) <0) THEN v_mr_c3.net_units := 0; END IF;  

          --slot4 changes
          v_mr_c4.IMP_INIT := nvl(v_prev_mr_c4.IMP_INIT,0); v_mr_c4.EXP_INIT := nvl(v_prev_mr_c4.EXP_INIT,0);
          v_mr_c4.IMP_DIFF := v_mr_c4.IMP_FINAL - v_mr_c4.IMP_INIT ;v_mr_c4.EXP_DIFF := v_mr_c4.EXP_FINAL - v_mr_c4.EXP_INIT ;
          v_mr_c4.IMP_UNITS := v_mr_c4.IMP_DIFF * v_mrh.mf; v_mr_c4.EXP_UNITS := v_mr_c4.EXP_DIFF * v_mrh.mf;
          v_mr_c4.net_units := ROUND(v_mr_c4.EXP_UNITS - v_mr_c4.IMP_UNITS,0) ; if(to_number(v_mr_c4.net_units) <0) THEN v_mr_c4.net_units := 0; END IF;

          --slot5 changes
          v_mr_c5.IMP_INIT := nvl(v_prev_mr_c5.IMP_INIT,0); v_mr_c5.EXP_INIT := nvl(v_prev_mr_c5.EXP_INIT,0);
          v_mr_c5.IMP_DIFF := v_mr_c5.IMP_FINAL - v_mr_c5.IMP_INIT ;v_mr_c5.EXP_DIFF := v_mr_c5.EXP_FINAL - v_mr_c5.EXP_INIT ;
          v_mr_c5.IMP_UNITS := v_mr_c5.IMP_DIFF * v_mrh.mf; v_mr_c5.EXP_UNITS := v_mr_c5.EXP_DIFF * v_mrh.mf;
          v_mr_c5.net_units := ROUND(v_mr_c5.EXP_UNITS - v_mr_c5.IMP_UNITS,0) ; if(to_number(v_mr_c5.net_units) <0) THEN v_mr_c5.net_units := 0; END IF;  

          -- update summary info in header 
          v_mrh.total_import_gen := v_mr_c1.IMP_UNITS + v_mr_c2.IMP_UNITS + v_mr_c3.IMP_UNITS + v_mr_c4.IMP_UNITS + v_mr_c5.IMP_UNITS;
					v_mrh.total_export_gen := v_mr_c1.EXP_UNITS + v_mr_c2.EXP_UNITS + v_mr_c3.EXP_UNITS + v_mr_c4.EXP_UNITS + v_mr_c5.EXP_UNITS;
					v_mrh.net_gen_units := v_mr_c1.NET_UNITS + v_mr_c2.NET_UNITS + v_mr_c3.NET_UNITS + v_mr_c4.NET_UNITS + v_mr_c5.NET_UNITS;

          ----- modify current meter reading record - end ----
        end if;

				--dbms_output.put_line('all slots- '||v_mrh.id);
				-- intialise PK, FKs for GenStmt and GenSlots
				v_gs.id := T_GEN_STMT_SEQ.nextval;
				v_gs_c1.id := T_GEN_STMT_SEQ.nextval;v_gs_c1.TMP_GEN_STMT_ID := v_gs.id;
				v_gs_c2.id := T_GEN_STMT_SEQ.nextval;v_gs_c2.TMP_GEN_STMT_ID := v_gs.id;
				v_gs_c3.id := T_GEN_STMT_SEQ.nextval;v_gs_c3.TMP_GEN_STMT_ID := v_gs.id;
				v_gs_c4.id := T_GEN_STMT_SEQ.nextval;v_gs_c4.TMP_GEN_STMT_ID := v_gs.id;
				v_gs_c5.id := T_GEN_STMT_SEQ.nextval;v_gs_c5.TMP_GEN_STMT_ID := v_gs.id;

				-- set values in gen stmt
				v_gs.STATUS_CODE := 'CREATED';
				v_gs.M_COMPANY_METER_ID := v_mrh.M_COMPANY_METER_ID ;
				v_gs.T_MR_IDS := v_mrh.M_COMPANY_METER_ID ;
				v_gs.REF_NUMBER := v_gs_process_id;
        --v_gs.gs_batch_id := v_process_id;
				v_gs.mf := v_mrh.mf;
				v_gs.STMT_GEN_DATE := v_created_Date ;
				v_gs.STMT_MONTH :=  v_mrh.READING_MONTH;
				v_gs.STMT_YEAR := v_mrh.READING_YEAR;
				v_gs.INIT_STMT_DT := v_mrh.INIT_READING_DT;
				v_gs.FINAL_STMT_DT := v_mrh.FINAL_READING_DT;
				-- RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL are not relevant currently
				--RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL - IMPORT VALUES 
				v_gs.KVAH_INIT := v_mrh.IMP_KVAH_INIT;
        v_gs.KVAH_FINAL := v_mrh.IMP_KVAH_FINAL;
        v_gs.RKVAH_INIT := v_mrh.IMP_RKVAH_INIT;
        v_gs.RKVAH_FINAL := v_mrh.IMP_RKVAH_FINAL;
				v_gs.KVAH_DIFF := v_mrh.KVAH_DIFF;
				v_gs.KVAH_UNITS := v_mrh.KVAH_UNITS;
				v_gs.RKVAH_DIFF := v_mrh.RKVAH_DIFF;
				v_gs.RKVAH_UNITS := v_mrh.RKVAH_UNITS;
                v_mr_c1.EXP_UNITS := round(v_mr_c1.EXP_UNITS,0); v_mr_c1.IMP_UNITS := round(v_mr_c1.IMP_UNITS,0);v_mr_c1.NET_UNITS := round(v_mr_c1.NET_UNITS,0);
                v_mr_c2.EXP_UNITS := round(v_mr_c2.EXP_UNITS,0); v_mr_c2.IMP_UNITS := round(v_mr_c2.IMP_UNITS,0);v_mr_c2.NET_UNITS := round(v_mr_c2.NET_UNITS,0);
                v_mr_c3.EXP_UNITS := round(v_mr_c3.EXP_UNITS,0); v_mr_c3.IMP_UNITS := round(v_mr_c3.IMP_UNITS,0);v_mr_c3.NET_UNITS := round(v_mr_c3.NET_UNITS,0);
                v_mr_c4.EXP_UNITS := round(v_mr_c4.EXP_UNITS,0); v_mr_c4.IMP_UNITS := round(v_mr_c4.IMP_UNITS,0);v_mr_c4.NET_UNITS := round(v_mr_c4.NET_UNITS,0);
                v_mr_c5.EXP_UNITS := round(v_mr_c5.EXP_UNITS,0); v_mr_c5.IMP_UNITS := round(v_mr_c5.IMP_UNITS,0);v_mr_c5.NET_UNITS := round(v_mr_c5.NET_UNITS,0);
    
				v_gs.TOTAL_EXPORT_GEN := v_mr_c1.EXP_UNITS+v_mr_c2.EXP_UNITS+v_mr_c3.EXP_UNITS+v_mr_c4.EXP_UNITS+v_mr_c5.EXP_UNITS;
				v_gs.TOTAL_IMPORT_GEN := v_mr_c1.IMP_UNITS+v_mr_c2.IMP_UNITS+v_mr_c3.IMP_UNITS+v_mr_c4.IMP_UNITS+v_mr_c5.IMP_UNITS;
				v_gs.M_ORG_ID := meter.M_ORG_ID;
				v_gs.M_COMPANY_ID := meter.M_COMPANY_ID;
				v_gs.M_COMPANY_SERVICE_ID := meter.M_COMPANY_SERVICE_ID;
				v_gs.DISP_COMPANY_NAME := meter.DISP_COMPANY_NAME;
				v_gs.DISP_SERVICE_NUMBER := meter.DISP_SERVICE_NUMBER;
				v_gs.INJECTING_VOLTAGE_CODE := meter.INJECTING_VOLTAGE_CODE;
				v_gs.DISP_ORG_NAME := meter.DISP_ORG_NAME; 
				v_gs.FLOW_TYPE_CODE := meter.FLOW_TYPE_CODE; 
				v_gs.net_generation := v_mr_c1.NET_UNITS+v_mr_c2.NET_UNITS+v_mr_c3.NET_UNITS+v_mr_c4.NET_UNITS+v_mr_c5.NET_UNITS;
				v_gs.C1 := v_mr_c1.NET_UNITS;
				v_gs.C2 := v_mr_c2.NET_UNITS;
				v_gs.C3 := v_mr_c3.NET_UNITS;
				v_gs.C4 := v_mr_c4.NET_UNITS;
				v_gs.C5 := v_mr_c5.NET_UNITS;
				v_gs.disp_fuel_type_code := meter.disp_fuel_type_code;
				v_gs.disp_fuel_type_name := meter.disp_fuel_type_name;
        v_gs.COMMISSION_DATE:= meter.COMMISSION_DATE;
        v_gs.IS_REC := meter.IS_REC;
				v_gs.created_by := v_created_By;
				v_gs.created_dt := SYSDATE;
				v_gs.enabled := 'Y';
                v_gs.batch_key:=I_BATCH_KEY;
				v_gs.TOTAL_CHARGED_AMOUNT := 0; --actual value calculated by calc_gs_charges() 
				v_gs.NET_PAYABLE := 0; --actual value calculated by calc_gs_charges() 
				if(to_number(v_gs.TOTAL_EXPORT_GEN)*0.01 >= to_number(v_gs.RKVAH_UNITS)) THEN
					v_gs.penalty_rate := '0.25';
				ELSE
					v_gs.penalty_rate := '0.50';
				END IF;
                v_stage := '-7-';


				--dbms_output.put_line('gen stmt - values set');

				SELECT v_mr_c1.SLOT_CODE,v_mr_c1.IMP_INIT, v_mr_c1.IMP_FINAL, v_mr_c1.IMP_DIFF, round(v_mr_c1.IMP_UNITS,0),v_mr_c1.EXP_INIT, v_mr_c1.EXP_FINAL, v_mr_c1.EXP_DIFF, round(v_mr_c1.EXP_UNITS,0), meter.bc1, round(v_mr_c1.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c1.SLOT_CODE,v_gs_c1.IMP_INIT, v_gs_c1.IMP_FINAL, v_gs_c1.IMP_DIFF, v_gs_c1.IMP_UNITS, v_gs_c1.EXP_INIT, v_gs_c1.EXP_FINAL, v_gs_c1.EXP_DIFF, v_gs_c1.EXP_UNITS, v_gs_c1.BANKED_BALANCE, v_gs_c1.NET_UNITS, v_gs_c1.enabled, v_gs_c1.created_Date
				FROM dual;

				SELECT  v_mr_c2.SLOT_CODE,v_mr_c2.IMP_INIT, v_mr_c2.IMP_FINAL, v_mr_c2.IMP_DIFF, round(v_mr_c2.IMP_UNITS,0), v_mr_c2.EXP_INIT, v_mr_c2.EXP_FINAL, v_mr_c2.EXP_DIFF, round(v_mr_c2.EXP_UNITS,0), meter.bc2, round(v_mr_c2.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c2.SLOT_CODE,v_gs_c2.IMP_INIT, v_gs_c2.IMP_FINAL, v_gs_c2.IMP_DIFF, v_gs_c2.IMP_UNITS, v_gs_c2.EXP_INIT, v_gs_c2.EXP_FINAL, v_gs_c2.EXP_DIFF, v_gs_c2.EXP_UNITS, v_gs_c2.BANKED_BALANCE, v_gs_c2.NET_UNITS, v_gs_c2.enabled, v_gs_c2.created_Date
				FROM dual;

				SELECT  v_mr_c3.SLOT_CODE,v_mr_c3.IMP_INIT, v_mr_c3.IMP_FINAL, v_mr_c3.IMP_DIFF, round(v_mr_c3.IMP_UNITS,0), v_mr_c3.EXP_INIT, v_mr_c3.EXP_FINAL, v_mr_c3.EXP_DIFF, round(v_mr_c3.EXP_UNITS,0), meter.bc3, round(v_mr_c3.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c3.SLOT_CODE,v_gs_c3.IMP_INIT, v_gs_c3.IMP_FINAL, v_gs_c3.IMP_DIFF, v_gs_c3.IMP_UNITS, v_gs_c3.EXP_INIT, v_gs_c3.EXP_FINAL, v_gs_c3.EXP_DIFF, v_gs_c3.EXP_UNITS, v_gs_c3.BANKED_BALANCE, v_gs_c3.NET_UNITS, v_gs_c3.enabled, v_gs_c3.created_Date
				FROM dual;

				SELECT  v_mr_c4.SLOT_CODE,v_mr_c4.IMP_INIT, v_mr_c4.IMP_FINAL, v_mr_c4.IMP_DIFF, round(v_mr_c4.IMP_UNITS,0), v_mr_c4.EXP_INIT, v_mr_c4.EXP_FINAL, v_mr_c4.EXP_DIFF, round(v_mr_c4.EXP_UNITS,0), meter.bc4, round(v_mr_c4.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c4.SLOT_CODE,v_gs_c4.IMP_INIT, v_gs_c4.IMP_FINAL, v_gs_c4.IMP_DIFF, v_gs_c4.IMP_UNITS, v_gs_c4.EXP_INIT, v_gs_c4.EXP_FINAL, v_gs_c4.EXP_DIFF, v_gs_c4.EXP_UNITS, v_gs_c4.BANKED_BALANCE, v_gs_c4.NET_UNITS, v_gs_c4.enabled, v_gs_c4.created_Date
				FROM dual;

				SELECT  v_mr_c5.SLOT_CODE,v_mr_c5.IMP_INIT, v_mr_c5.IMP_FINAL, v_mr_c5.IMP_DIFF, round(v_mr_c5.IMP_UNITS,0), v_mr_c5.EXP_INIT, v_mr_c5.EXP_FINAL, v_mr_c5.EXP_DIFF, round(v_mr_c5.EXP_UNITS,0), meter.bc5, round(v_mr_c5.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c5.SLOT_CODE,v_gs_c5.IMP_INIT, v_gs_c5.IMP_FINAL, v_gs_c5.IMP_DIFF, v_gs_c5.IMP_UNITS, v_gs_c5.EXP_INIT, v_gs_c5.EXP_FINAL, v_gs_c5.EXP_DIFF, v_gs_c5.EXP_UNITS, v_gs_c5.BANKED_BALANCE, v_gs_c5.NET_UNITS, v_gs_c5.enabled, v_gs_c1.created_Date
				FROM dual;


				--dbms_output.put_line('gen stmt slots - insert');

				INSERT INTO  TMP_GEN_STMT VALUES  v_gs;
				INSERT INTO  TMP_GEN_STMT_SLOT VALUES  v_gs_c1;
				INSERT INTO  TMP_GEN_STMT_SLOT VALUES  v_gs_c2;
				INSERT INTO  TMP_GEN_STMT_SLOT VALUES  v_gs_c3;
				INSERT INTO  TMP_GEN_STMT_SLOT VALUES  v_gs_c4;
				INSERT INTO  TMP_GEN_STMT_SLOT VALUES  v_gs_c5;



--                 dbms_output.put_line('gen stmt slots - calling charges');

				  v_result := METER_NUMBER_CHANGE.CALC_TMP_GS_CHARGES(v_gs.id);

--				 dbms_output.put_line('gen stmt slots - after charges');

        update t_meter_reading_hdr set gs_batch_id = v_gs_process_id, M_GEN_STMT_ID = v_gs.id where id = v_mr_id;

                             v_stage := '-8-';

        SELECT STMT_MONTH,STMT_YEAR,M_COMPANY_SERVICE_ID INTO v_gen_month,v_gen_year,v_gen_comp_servi_id FROM TMP_GEN_STMT gen WHERE gen.ID= v_gs.id;

        SELECT pp.PLANT_CLASS_TYPE_CODE,tariff.WEG_GROUP_NAME,tariff.RATE into  v_plant_class_code,v_plant_class_desc,tariff_rates FROM M_POWERPLANT pp
        LEFT JOIN M_TARIFF tariff ON pp.PLANT_CLASS_TYPE_CODE=tariff.WEG_GROUP_CODE 
        LEFT JOIN TMP_GEN_STMT gen ON pp.m_service_id = gen.M_COMPANY_SERVICE_ID and gen.ID=v_gs.id
        WHERE  gen.M_COMPANY_SERVICE_ID=v_gen_comp_servi_id;

        --        dbms_output.put_line('tariff rate- '||tariff_rates);
        --        dbms_output.put_line('v_plant_class_code- '||v_plant_class_code);
        --        dbms_output.put_line('v_plant_class_desc- '||v_plant_class_desc);
        --        dbms_output.put_line('tariff rate- '||v_gen_comp_servi_id);


        UPDATE TMP_GEN_STMT SET PLANT_CLASS_TYPE_CODE=v_plant_class_code,PLANT_CLASS_TYPE_DESC=v_plant_class_desc,TARIFF_RATE=tariff_rates WHERE ID=v_gs.id;

                        v_stage := '-9-';

        SELECT companygs.IS_CAPTIVE INTO v_gen_iscaptive FROM M_COMPANY companygs
        LEFT JOIN TMP_GEN_STMT gengs ON companygs.ID = gengs.M_COMPANY_ID WHERE gengs.ID=v_gs.id;

        SELECT COUNT(tradegs.IS_CAPTIVE) into v_gen_isstb_count from M_TRADE_RELATIONSHIP  tradegs
        LEFT JOIN TMP_GEN_STMT stbgs on tradegs.M_SELLER_COMP_SERVICE_ID = stbgs.M_COMPANY_SERVICE_ID and tradegs.M_BUYER_COMPANY_ID='TNEB' WHERE stbgs.ID=v_gs.id ;

        SELECT orggs.CODE INTO v_gen_org_code FROM M_ORG orggs
        LEFT JOIN TMP_GEN_STMT gengs1 ON orggs.ID = gengs1.M_ORG_ID WHERE gengs1.ID=v_gs.id;


        SELECT codes.VALUE_DESC INTO v_gen_voltage_desc FROM V_CODES codes
        LEFT JOIN TMP_GEN_STMT gengs2 ON codes.VALUE_CODE=INJECTING_VOLTAGE_CODE AND codes.LIST_NAME='Voltage'
        WHERE gengs2.ID=v_gs.id;


        if ( v_gen_isstb_count) > 0 THEN
          v_gen_isstb := 'Y'; 
         ELSE 
          v_gen_isstb := 'N'; 
        END IF;

        --IF(v_gen_isstb_count) > 0 THEN
           v_tariff_net_amount :=  to_number((v_gs.net_generation)* tariff_rates) ;
           -- dbms_output.put_line('v_tariff_net_amount- '||v_tariff_net_amount );
           SELECT gs.TOTAL_CHARGED_AMOUNT INTO v_total_charged_amount FROM TMP_GEN_STMT gs where gs.ID=v_gs.id;
           -- dbms_output.put_line('v_total_charged_amoun- '||v_total_charged_amount );
           v_net_payable := v_tariff_net_amount - v_total_charged_amount;
           --dbms_output.put_line('v_net_payable- '||v_net_payable);
        --   ELSE
        --   CONTINUE;
        --END IF;


        UPDATE TMP_GEN_STMT SET IS_CAPTIVE=v_gen_iscaptive,IS_STB=v_gen_isstb,DISP_ORG_CODE=v_gen_org_code,INJECTING_VOLTAGE_DESC=v_gen_voltage_desc,TARIFF_NET_AMOUNT=v_tariff_net_amount,NET_PAYABLE = v_net_payable WHERE ID=v_gs.id;


        --select  ss.ID,ss.NAME,ss.TYPE_OF_SS INTO v_gen_ssid, v_gen_ssname,v_gen_sstype  FROM  M_SUBSTATION  ss
        --LEFT JOIN TMP_GEN_STMT gengs3 ON  ss.M_ORG_ID = gengs3.M_ORG_ID   WHERE gengs3.ID=v_gs.id ;
        --
        --select  ff.ID,ff.NAME INTO v_gen_ffid, v_gen_ffname  FROM  M_FEEDER ff
        --LEFT JOIN TMP_GEN_STMT gengs4 ON  ff.VOLTAGE_CODE= gengs4.INJECTING_VOLTAGE_CODE  WHERE gengs4.ID=v_gs.id ;
                        v_stage := '-10-';
        select service.M_SUBSTATION_ID,ss.NAME,ss.TYPE_OF_SS ,service.m_feeder_id,feeder.NAME 
        INTO v_gen_ssid, v_gen_ssname,v_gen_sstype,v_gen_ffid, v_gen_ffname
        from m_company_service service
        left join m_substation ss on service.m_substation_id=ss.id
        left join tmp_gen_stmt gengs3 ON service.id = gengs3.M_COMPANY_SERVICE_ID
        left join m_company_meter meter on meter.m_company_service_id=service.id
        left join m_feeder feeder on feeder.id=service.m_feeder_id 
        WHERE gengs3.ID=v_gs.id AND ROWNUM=1;
        
        UPDATE TMP_GEN_STMT SET M_SUBSTATION_ID = v_gen_ssid, M_SUBSTATION_NAME = v_gen_ssname,M_FEEDER_ID = v_gen_ffid,M_FEEDER_NAME = v_gen_ffname ,TYPE_OF_SS =v_gen_sstype  WHERE ID=v_gs.id;

            COMMIT;
			exception
			  when others then
			    v_exception_code := SQLCODE;
			    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
			    v_result := 'FAILURE';
			    v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT','EH','Error while processing each meter-reading - '||v_reason,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);
			END;
		END LOOP;


       -- --dbms_output.put_line('all slots- '||v_mrh.id);
		if(v_no_records) THEN
			v_result := 'FAILURE';
            if(v_reason='') then v_reason := 'No records to process'; end if;
		END IF;

        if( V_RESULT != '') THEN
			v_result := 'SUCCESS'; 
		END IF; 

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
	    -- dbms_output.put_line(v_reason);

      v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT','EH',v_result,v_reason||v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);
	END;
   <<THE_END>>


      v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.PROCESS_TEMP_GENERATION_STATEMENT','End',v_result,v_reason||v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);

  COMMIT;

  return V_RESULT; 
  END PROCESS_TEMP_GENERATION_STATEMENT;

  
  FUNCTION CALC_TMP_GS_CHARGES (v_gs_id IN VARCHAR2 ) RETURN VARCHAR2 AS

  v_is_stb   VARCHAR2(150);

  v_evaluated      NUMBER;

  v_id             NUMBER;

  v_no_of_days number:=0;

  v_machine_capacity number:=0;

  v_penalty_rate number:=0;

  v_rkvah_inits number:=0;

  v_total_charges number:=0;

  v_grand_total_charges number:=0;

  v_formula        VARCHAR2(150);

  v_charge_type    VARCHAR2(150);

  v_unit_charge    VARCHAR2(150);

  v_charge_code         VARCHAR2(150);

  v_charge         VARCHAR2(150):='0';

  v_fuel_type_Code VARCHAR2(50);

  v_charge_percentage NUMBER:=0;

  v_net_generation VARCHAR2(150);

  v_result varchar(300):='SUCCESS';

  v_log_result varchar(300):='SUCCESS';

  v_exception_code VARCHAR2(150);

  v_exception_msg  VARCHAR2(150);

  v_reason VARCHAR2(300);

  v_cal number:=0;

  v_gen_iscaptive VARCHAR2(50); 

  v_gen_isstb_count NUMBER; 

  v_gen_sstype  VARCHAR2(50);

  v_is_rec VARCHAR2(50); 





BEGIN

  BEGIN



    SELECT gs.machine_capacity, (gs.FINAL_STMT_DT - gs.INIT_STMT_DT)+1 no_of_days, gs.penalty_rate, gs.RKVAH_UNITS ,gs.NET_GENERATION, gs.disp_fuel_type_Code ,nvl(gs.IS_STB,''),gs.TYPE_OF_SS,gs.IS_REC

    INTO v_machine_capacity,v_no_of_days,v_penalty_rate, v_rkvah_inits,v_net_generation, v_fuel_type_Code, v_is_stb ,v_gen_sstype,v_is_rec

    FROM TMP_GEN_STMT gs where id = v_gs_id;



    SELECT companygs.IS_CAPTIVE INTO v_gen_iscaptive FROM M_COMPANY companygs

    LEFT JOIN TMP_GEN_STMT gengs ON companygs.ID = gengs.M_COMPANY_ID WHERE gengs.ID=v_gs_id;



    SELECT COUNT(tradegs.IS_CAPTIVE) into v_gen_isstb_count from M_TRADE_RELATIONSHIP  tradegs

    LEFT JOIN TMP_GEN_STMT stbgs on tradegs.M_SELLER_COMP_SERVICE_ID = stbgs.M_COMPANY_SERVICE_ID and tradegs.M_BUYER_COMPANY_ID='TNEB' WHERE stbgs.ID=v_gs_id ;


select ss.TYPE_OF_SS INTO v_gen_sstype from m_company_service service
left join m_substation ss on service.m_substation_id=ss.id
left join tmp_gen_stmt gengs3 ON service.id = gengs3.M_COMPANY_SERVICE_ID
left join m_company_meter meter on meter.m_company_service_id=service.id WHERE gengs3.ID=v_gs_id AND ROWNUM=1 ;

--    select service.TYPE_OF_SS  INTO v_gen_sstype
--
--    from v_company_service service LEFT JOIN TMP_GEN_STMT gengs3 ON  service.id = gengs3.M_COMPANY_SERVICE_ID and service.m_company_meter_id=gengs3.m_company_meter_id  WHERE gengs3.ID=v_gs_id ;







    if ( v_gen_isstb_count) > 0 THEN

      v_is_stb := 'Y'; 

     ELSE 

      v_is_stb := 'N'; 

    END IF;







    if(v_gen_sstype = 'SECTION 10(1)SS') then

         v_gen_sstype := 'Y';

    else

         v_gen_sstype := 'N';

    end if;



    if(v_is_stb = 'Y') then

      v_is_stb := 'Y';

    else

      v_is_stb := 'N';

    end if;



    FOR charge IN (SELECT CHARGE_CODE, CHARGE_DESC, CHARGE_TYPE_CODE, UNIT_CHARGE FROM M_CHARGE_defn d JOIN  M_CHARGES_MAP m ON d.id = m.M_CHARGE_ID AND CONTEXT = 'GENERATOR_STATEMENT' )

    LOOP

      BEGIN

        v_charge_code :=charge.charge_code ;



        if(v_charge_code in ('C001','C002','C005','C006') or v_is_rec = 'Y') then

            v_charge_percentage:= 100;

        elsif(v_is_rec = 'N' and v_fuel_type_Code = '02') then

            v_charge_percentage:= 50;

        elsif(v_is_rec = 'N' and v_fuel_type_Code = '18') THEN

            v_charge_percentage:= 40;

        else

            v_charge_percentage:= 100;

        end if;



        IF(v_charge_code = 'C001') then

                v_total_charges:= CEIL(to_number(CALC_CHARGES(v_charge_code,'','','')));   

        ELSIF(v_charge_code = 'C002') then

             IF(v_gen_sstype = 'Y') then

             --dbms_output.put_line('No o&M charges  for 10(1) ss');

                  continue; --  No o&M charges  for 10(1) ss

              else

                v_total_charges:= CEIL(to_number(CALC_CHARGES(charge.charge_code,v_machine_capacity,v_no_of_days,'')));

              end if;

        ELSIF(v_charge_code = 'C003') then

            IF(v_is_stb = 'Y') then

                continue; --  No transmission charges for stb

            else

                v_total_charges:= CEIL(to_number(CALC_CHARGES(v_charge_code,v_machine_capacity,v_no_of_days,'')));

            end if;

        ELSIF(v_charge_code = 'C004') then

            v_total_charges:= CEIL(to_number(CALC_CHARGES(v_charge_code,v_machine_capacity,v_no_of_days,'')));



        ELSIF(v_charge_code = 'C005') then

            IF((to_number(v_net_generation)*0.1)>=v_rkvah_inits) then

                v_penalty_rate:= 0.25;

            ELSE

                v_penalty_rate:=0.5;

            end if;



            v_total_charges:= CEIL(to_number(CALC_CHARGES(v_charge_code,v_penalty_rate,v_rkvah_inits,'')));
            
            if(v_total_charges<0)then
            v_total_charges:=0;
            else
            v_total_charges:=v_total_charges;
            end if;

        ELSIF(v_charge_code = 'C006') then

          v_total_charges:= CEIL(to_number(METER_NUMBER_CHANGE.CALC_TMP_NEGATIVE_CHARGES(v_gs_id)));

--          dbms_output.put_line(' v_total_charges'|| v_total_charges);

        ELSIF(v_charge_code = 'C007') then

          v_total_charges:= CEIL(to_number(CALC_CHARGES(v_charge_code,v_no_of_days,'','')));



        else

          continue;

        end if;





        v_total_charges := CEIL(v_total_charges * v_charge_percentage/100);

--  dbms_output.put_line('  v_total_charges  - '||  v_total_charges );


        INSERT INTO TMP_GEN_STMT_CHARGE (ID, TMP_GEN_STMT_ID, CHARGE_CODE, CHARGE_DESC, CHARGE_TYPE_CODE, UNIT_CHARGE, TOTAL_CHARGES)

          VALUES(T_GEN_STMT_CHARGE_SEQ.nextval, v_gs_id, charge.charge_code,charge.charge_desc,charge.CHARGE_TYPE_CODE, charge.UNIT_CHARGE, v_total_charges);



        v_grand_total_charges := CEIL((v_grand_total_charges+NVL(v_total_charges,0)));

--        dbms_output.put_line(' v_grand_total_charges - '|| v_grand_total_charges);



      EXCEPTION

      WHEN OTHERS THEN

        v_exception_code := SQLCODE;

        v_exception_msg  := SUBSTR(SQLERRM, 1, 100);

        v_result := 'FAILURE';

        v_reason := v_exception_code || ' - ' || v_exception_msg;

        v_log_result := log_activity('PROCEDURE','CALC_GS_CHARGES','EH-LOOP','Error while processing charge ('||v_charge_code ||')- '||v_reason,v_result,'admin', sysdate,v_gs_id);

      END;

      v_reason := 'SUCCESS'; -- resetting loop result

    END LOOP;



    update TMP_GEN_STMT set TOTAL_CHARGED_AMOUNT = v_grand_total_charges where id = v_gs_id;



  EXCEPTION

  WHEN OTHERS THEN

    v_exception_code := SQLCODE;

    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);

    v_result := 'FAILURE';

    v_reason := v_exception_code || ' - ' || v_exception_msg;

    v_log_result := log_activity('PROCEDURE','CALC_GS_CHARGES','EH','Issue in CALC_GS_CHARGES - '||v_reason,v_result,'admin', sysdate,v_gs_id);

  END;

RETURN v_result;

END CALC_TMP_GS_CHARGES;



FUNCTION  CALC_TMP_NEGATIVE_CHARGES(v_gs_id IN VARCHAR2 )
  RETURN VARCHAR2
  
  AS
    v_result varchar2(300);
 	v_reason VARCHAR2(300);
    v_total_exp_gen varchar2(300);
 	v_total_imp_gen varchar2(300);
	v_diff_total_gen varchar(300);
	v_c1_units varchar(300);
	v_c2_units varchar(300);
	v_c3_units varchar(300);
	v_c4_units varchar(300);
	v_c5_units varchar(300);
  v_c5_units_tax varchar(300);
  v_log_result varchar(300):='SUCCESS';
  v_exception_code VARCHAR2(150);
  v_exception_msg  VARCHAR2(150);
  v_slot_code VARCHAR(300);

  v_tax NUMBER;
BEGIN	
  BEGIN 
   v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CALC_NEGATIVE_CHARGES','START','START - ','','admin', sysdate,v_gs_id);
	SELECT gs.TOTAL_EXPORT_GEN INTO v_total_exp_gen FROM TMP_GEN_STMT gs WHERE gs.ID= v_gs_id ;
 	SELECT gs.TOTAL_IMPORT_GEN INTO v_total_imp_gen FROM TMP_GEN_STMT gs WHERE gs.ID= v_gs_id ;
        dbms_output.put_line(' v_total_exp_gen - '|| v_total_exp_gen);
        dbms_output.put_line(' v_total_imp_gen - '|| v_total_imp_gen);

--	if(TO_NUMBER(v_total_exp_gen) < TO_NUMBER(v_total_imp_gen))THEN --strat
        v_diff_total_gen := TO_NUMBER(v_total_exp_gen) - TO_NUMBER(v_total_imp_gen);
        dbms_output.put_line(' v_diff_total_gen - '|| v_diff_total_gen);
        FOR genSlot IN (SELECT gs.SLOT_CODE,gs.IMP_UNITS,gs.EXP_UNITS FROM TMP_GEN_STMT_SLOT gs WHERE gs.TMP_GEN_STMT_ID=v_gs_id)
        LOOP
        BEGIN
            v_slot_code :=genSlot.SLOT_CODE ;
            ----------------------------------------------------------
            if(genSlot.SLOT_CODE = 'C1') THEN --1
--  	    dbms_output.put_line(' genSlot.EXP_UNITS - c1===='|| genSlot.EXP_UNITS);
--          dbms_output.put_line(' genSlot.IMP_UNITS- c1===='|| genSlot.IMP_UNITS);
                if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN --2

                v_c1_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*7.62);
                v_tax :=TO_NUMBER(v_c1_units)*0.05;
                v_c1_units:=TO_NUMBER(v_c1_units)+v_tax;
              dbms_output.put_line(' v_c1_units - '|| v_c1_units);
                ELSE
                v_c1_units :=0;
                END IF;	--2
            END IF;--1
            
            ----------------------------------------------------------
            if(genSlot.SLOT_CODE = 'C2') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN
--	        dbms_output.put_line(' genSlot.EXP_UNITS - c2===='|| genSlot.EXP_UNITS);
--          dbms_output.put_line(' genSlot.IMP_UNITS- c2===='|| genSlot.IMP_UNITS);
            v_c2_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*7.62);
            v_tax :=TO_NUMBER(v_c2_units)*0.05;
            v_c2_units:=TO_NUMBER(v_c2_units)+v_tax;
            dbms_output.put_line(' v_c2_units - '|| v_c2_units);
            ELSE
            v_c2_units :=0;
            END IF;
            END IF;
            
             ----------------------------------------------------------

            if(genSlot.SLOT_CODE = 'C3') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN

            v_c3_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*6.35);
            v_tax :=TO_NUMBER(v_c3_units)*0.05;
            v_c3_units:=TO_NUMBER(v_c3_units)+v_tax;
          dbms_output.put_line(' v_c3_units - '|| v_c3_units);
                ELSE
            v_c3_units :=0;
          dbms_output.put_line(' v_c3_units - '|| v_c3_units);
            END IF;
            END IF;
              ----------------------------------------------------------
           
            if(genSlot.SLOT_CODE = 'C4') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN

            v_c4_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*6.35);
            v_tax :=TO_NUMBER(v_c4_units)*0.05;
            v_c4_units:=TO_NUMBER(v_c4_units)+v_tax;
          dbms_output.put_line(' v_c4_units - '|| v_c4_units);
            ELSE
            v_c4_units :=0;
            END IF;
            END IF;
          ----------------------------------------------------------
        
            if(genSlot.SLOT_CODE = 'C5') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN

            v_c5_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*6.0325);
          dbms_output.put_line(' v_c5_units - '|| v_c5_units);
             v_c5_units_tax :=(((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*0.3175));
         dbms_output.put_line(' v_c5_units_tax - '|| v_c5_units_tax);
            v_c5_units := (TO_NUMBER(v_c5_units) + TO_NUMBER(v_c5_units_tax));
          dbms_output.put_line(' v_c5_units - '|| v_c5_units);
            ELSE
            v_c5_units :=0;
            END IF;
            END IF;
          ----------------------------------------------------------

	 EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
    v_result := 'FAILURE';
    v_reason := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CALC_NEGATIVE_CHARGES','EH','Issue in CALC_NEGATIVE_CHARGES - '||v_reason,v_result,'admin', sysdate,v_gs_id);
  END;

    v_reason := 'SUCCESS'; -- resetting loop result

    END LOOP;
--    else
--      v_result := 0; 
--  dbms_output.put_line(' v_result'|| v_result);
--END IF; -- end
dbms_output.put_line(' v_c5_units - '|| v_c5_units);

v_result := (TO_NUMBER(v_c1_units ) + TO_NUMBER(v_c2_units )+ TO_NUMBER(v_c3_units )+ TO_NUMBER(v_c4_units )+ TO_NUMBER(v_c5_units ));
IF(v_result<0)THEN
v_result := (TO_NUMBER(v_c1_units ) + TO_NUMBER(v_c2_units )+ TO_NUMBER(v_c3_units )+ TO_NUMBER(v_c4_units )+ TO_NUMBER(v_c5_units ))*(-1);
dbms_output.put_line(' v_result - '|| v_result);
ELSE
v_result := (TO_NUMBER(v_c1_units ) + TO_NUMBER(v_c2_units )+ TO_NUMBER(v_c3_units )+ TO_NUMBER(v_c4_units )+ TO_NUMBER(v_c5_units ));
END IF;
dbms_output.put_line(' v_result - '|| v_result);

  EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
    v_result := 'FAILURE';
    v_reason := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CALC_NEGATIVE_CHARGES','EH','Issue in CALC_NEGATIVE_CHARGES - '||v_reason,v_result,'admin', sysdate,v_gs_id);
  END;
  dbms_output.put_line(' v_result - '|| v_result); 
RETURN v_result;
END CALC_TMP_NEGATIVE_CHARGES;

      PROCEDURE CREATE_CONSOLIDATED_GENERATION_STATEMENT(I_BATCH_KEY IN VARCHAR2, I_MONTH IN VARCHAR2,I_YEAR IN VARCHAR2,O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_tmp_gen_count number;
    v_exception_msg  VARCHAR2(200);
    v_result varchar(300):='SUCCESS';   
    v_created_Date DATE := SYSDATE;
    v_created_By  varchar2(50):= 'METER_NUMBER_CHANGE.CREATE_GENERATION_STATEMENT';
    v_Service_number  VARCHAR2(200);
    v_count number;
    serv_count number;
    serv_number varchar2(100);
    v_cursor sys_refcursor ;
    v_total_cursor sys_refcursor ;
    v_slot_cursor sys_refcursor ;
    v_charge_cursor sys_refcursor ;
     v_test varchar2(50);
    v_temp_gen_stmt TMP_GEN_STMT%ROWTYPE;
    v_gs T_GEN_STMT%ROWTYPE;
    slot T_GEN_STMT_SLOT%ROWTYPE;
    charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c1 T_GEN_STMT_SLOT%ROWTYPE;
    v_gs_c2 T_GEN_STMT_SLOT%ROWTYPE;
    v_gs_c3 T_GEN_STMT_SLOT%ROWTYPE;
    v_gs_c4 T_GEN_STMT_SLOT%ROWTYPE;
    v_gs_c5 T_GEN_STMT_SLOT%ROWTYPE;
    
     v_gs_c1_charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c2_charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c3_charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c4_charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c5_charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c6_charge T_GEN_STMT_CHARGE%ROWTYPE;
    v_gs_c7_charge T_GEN_STMT_CHARGE%ROWTYPE;
    
    

    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT','CREATE_GENERATION_STATEMENT','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   -------------------------------------------------------- LOGIC
       OPEN v_total_cursor for SELECT DISTINCT disp_Service_number ser_num FROM TMP_GEN_STMT WHERE BATCH_KEY=I_BATCH_KEY AND STMT_MONTH=I_MONTH AND STMT_YEAR=I_YEAR;
    LOOP
    FETCH v_total_cursor INTO serv_number;
    EXIT WHEN v_total_cursor%NOTFOUND;
    SELECT count(disp_Service_number)  into  serv_count FROM TMP_GEN_STMT WHERE disp_Service_number= serv_number AND BATCH_KEY=I_BATCH_KEY AND STMT_MONTH=I_MONTH AND STMT_YEAR=I_YEAR;

    v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT','serv_count','cHECK - '||serv_count,'','', sysdate,I_BATCH_KEY);

  IF serv_count=2 then

     	 OPEN v_cursor for SELECT * FROM TMP_GEN_STMT where batch_key=I_BATCH_KEY and stmt_month=I_MONTH and stmt_year=I_YEAR and disp_Service_number=serv_number;
                LOOP
                FETCH v_cursor INTO v_temp_gen_stmt;
                EXIT WHEN v_cursor%NOTFOUND;
                
        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT','v_cursor-loop','serv_number - '||serv_number,'','', sysdate,I_BATCH_KEY);
           
                v_gs.id := T_GEN_STMT_SEQ.nextval;
				v_gs_c1.id := T_GEN_STMT_SEQ.nextval;v_gs_c1.T_GEN_STMT_ID := v_gs.id;
				v_gs_c2.id := T_GEN_STMT_SEQ.nextval;v_gs_c2.T_GEN_STMT_ID := v_gs.id;
				v_gs_c3.id := T_GEN_STMT_SEQ.nextval;v_gs_c3.T_GEN_STMT_ID := v_gs.id;
				v_gs_c4.id := T_GEN_STMT_SEQ.nextval;v_gs_c4.T_GEN_STMT_ID := v_gs.id;
				v_gs_c5.id := T_GEN_STMT_SEQ.nextval;v_gs_c5.T_GEN_STMT_ID := v_gs.id;
                v_gs_c1_charge.ID:= T_GEN_STMT_SEQ.nextval; v_gs_c1_charge.T_GEN_STMT_ID:= v_gs.id;
                v_gs_c2_charge.ID:= T_GEN_STMT_SEQ.nextval; v_gs_c2_charge.T_GEN_STMT_ID := v_gs.id;
                v_gs_c3_charge.ID:= T_GEN_STMT_SEQ.nextval; v_gs_c3_charge.T_GEN_STMT_ID := v_gs.id;
                v_gs_c4_charge.ID:= T_GEN_STMT_SEQ.nextval; v_gs_c4_charge.T_GEN_STMT_ID := v_gs.id;
                v_gs_c5_charge.ID:= T_GEN_STMT_SEQ.nextval;v_gs_c5_charge.T_GEN_STMT_ID := v_gs.id;
                v_gs_c6_charge.ID:= T_GEN_STMT_SEQ.nextval; v_gs_c6_charge.T_GEN_STMT_ID := v_gs.id;
                v_gs_c7_charge.ID:= T_GEN_STMT_SEQ.nextval; v_gs_c7_charge.T_GEN_STMT_ID := v_gs.id;
				-- set values in gen stmt
				v_gs.STATUS_CODE := 'CREATED';
				v_gs.M_COMPANY_METER_ID := v_temp_gen_stmt.M_COMPANY_METER_ID ;
				v_gs.T_MR_IDS := v_temp_gen_stmt.M_COMPANY_METER_ID ;
				v_gs.REF_NUMBER := v_temp_gen_stmt.ID;
				v_gs.mf := v_temp_gen_stmt.mf;
				v_gs.STMT_GEN_DATE := v_created_Date ;
				v_gs.STMT_MONTH :=  v_temp_gen_stmt.STMT_MONTH;
				v_gs.STMT_YEAR := v_temp_gen_stmt.STMT_YEAR;
				v_gs.INIT_STMT_DT := v_temp_gen_stmt.INIT_STMT_DT;
				v_gs.FINAL_STMT_DT := v_temp_gen_stmt.FINAL_STMT_DT;
				v_gs.KVAH_INIT :=to_number(nvl(v_gs.KVAH_INIT,0)) +to_number(nvl(v_temp_gen_stmt.KVAH_INIT,0)); 
                v_gs.KVAH_FINAL :=to_number(nvl(v_gs.KVAH_FINAL,0)) +to_number(nvl(v_temp_gen_stmt.KVAH_FINAL,0)); 
                v_gs.RKVAH_INIT := to_number(nvl(v_gs.RKVAH_INIT,0)) +to_number(nvl(v_temp_gen_stmt.RKVAH_INIT,0)); 
                v_gs.RKVAH_FINAL := to_number(nvl(v_gs.RKVAH_FINAL,0)) +to_number(nvl(v_temp_gen_stmt.RKVAH_FINAL,0)); 
				v_gs.KVAH_DIFF := to_number(nvl(v_gs.KVAH_DIFF,0)) +to_number(nvl(v_temp_gen_stmt.KVAH_DIFF,0)); 
				v_gs.KVAH_UNITS := to_number(nvl(v_gs.KVAH_UNITS,0)) +to_number(nvl(v_temp_gen_stmt.KVAH_UNITS,0)); 
				v_gs.RKVAH_DIFF := to_number(nvl(v_gs.RKVAH_DIFF,0)) +to_number(nvl(v_temp_gen_stmt.RKVAH_DIFF,0)); 
				v_gs.RKVAH_UNITS := to_number(nvl(v_gs.RKVAH_UNITS,0)) +to_number(nvl(v_temp_gen_stmt.RKVAH_UNITS,0)); 
				v_gs.TOTAL_EXPORT_GEN :=to_number(nvl(v_gs.TOTAL_EXPORT_GEN,0)) +to_number(nvl(v_temp_gen_stmt.TOTAL_EXPORT_GEN,0)); 
				v_gs.TOTAL_IMPORT_GEN := to_number(nvl(v_gs.TOTAL_IMPORT_GEN,0)) +to_number(nvl(v_temp_gen_stmt.TOTAL_IMPORT_GEN,0)); 
				v_gs.M_ORG_ID := v_temp_gen_stmt.M_ORG_ID;
				v_gs.M_COMPANY_ID := v_temp_gen_stmt.M_COMPANY_ID;
				v_gs.M_COMPANY_SERVICE_ID := v_temp_gen_stmt.M_COMPANY_SERVICE_ID;
				v_gs.DISP_COMPANY_NAME := v_temp_gen_stmt.DISP_COMPANY_NAME;
				v_gs.DISP_SERVICE_NUMBER := v_temp_gen_stmt.DISP_SERVICE_NUMBER;
				v_gs.INJECTING_VOLTAGE_CODE := v_temp_gen_stmt.INJECTING_VOLTAGE_CODE;
				v_gs.DISP_ORG_NAME := v_temp_gen_stmt.DISP_ORG_NAME; 
				v_gs.FLOW_TYPE_CODE := v_temp_gen_stmt.FLOW_TYPE_CODE; 
				v_gs.net_generation := v_temp_gen_stmt.net_generation;
				v_gs.C1 := to_number(nvl(v_gs.C1,0)) +to_number(nvl(v_temp_gen_stmt.C1,0));
				v_gs.C2 := to_number(nvl(v_gs.C2,0)) +to_number(nvl(v_temp_gen_stmt.C2,0)); 
				v_gs.C3 := to_number(nvl(v_gs.C3,0)) +to_number(nvl(v_temp_gen_stmt.C3,0)); 
				v_gs.C4 := to_number(nvl(v_gs.C4,0)) +to_number(nvl(v_temp_gen_stmt.C4,0)); 
				v_gs.C5 := to_number(nvl(v_gs.C5,0)) +to_number(nvl(v_temp_gen_stmt.C5,0)); 
				v_gs.disp_fuel_type_code := v_temp_gen_stmt.disp_fuel_type_code;
				v_gs.disp_fuel_type_name := v_temp_gen_stmt.disp_fuel_type_name;
                v_gs.COMMISSION_DATE:= v_temp_gen_stmt.COMMISSION_DATE;
                v_gs.IS_REC := v_temp_gen_stmt.IS_REC;
				v_gs.created_by := v_created_By;
				v_gs.created_dt := SYSDATE;
				v_gs.enabled := 'Y';
        v_gs.IS_METER_CHANGE:='Y';
--                v_gs.batch_key:=I_BATCH_KEY;
				v_gs.TOTAL_CHARGED_AMOUNT := 0; --actual value calculated by calc_gs_charges() 
				v_gs.NET_PAYABLE := 0; --actual value calculated by calc_gs_charges() 
				if(to_number(v_gs.TOTAL_EXPORT_GEN)*0.01 >= to_number(v_gs.RKVAH_UNITS)) THEN
					v_gs.penalty_rate := '0.25';
				ELSE
					v_gs.penalty_rate := '0.50';
				END IF;
--                v_stage := '-7-';
                OPEN v_slot_cursor for select * from tmp_gen_stmt_slot where TMP_GEN_STMT_ID =v_temp_gen_stmt.id ;
                LOOP
                FETCH v_slot_cursor INTO slot;
                EXIT WHEN v_slot_cursor%NOTFOUND;
			        v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT','v_slot_cursor-loop','serv_number - '||serv_number,'','', sysdate,I_BATCH_KEY);

                    if slot.slot_code='C1' then
                    v_gs_c1.slot_code:='C1';
                    v_gs_c1.IMP_INIT:=to_number(nvl(v_gs_c1.IMP_INIT,0)) +to_number(nvl(slot.IMP_INIT,0));
                    v_gs_c1.IMP_FINAL:=to_number(nvl(v_gs_c1.IMP_FINAL,0)) +to_number(nvl(slot.IMP_FINAL,0));
                    v_gs_c1.IMP_DIFF:=to_number(nvl(v_gs_c1.IMP_DIFF,0)) +to_number(nvl(slot.IMP_DIFF,0));
                    v_gs_c1.IMP_UNITS:=to_number(nvl(v_gs_c1.IMP_UNITS,0)) +to_number(nvl(slot.IMP_UNITS,0));
                    v_gs_c1.EXP_INIT:=to_number(nvl(v_gs_c1.EXP_INIT,0)) +to_number(nvl(slot.EXP_INIT,0));
                    v_gs_c1.EXP_FINAL:=to_number(nvl(v_gs_c1.EXP_FINAL,0)) +to_number(nvl(slot.EXP_FINAL,0));
                    v_gs_c1.EXP_DIFF:=to_number(nvl(v_gs_c1.EXP_DIFF,0)) +to_number(nvl(slot.EXP_DIFF,0));
                    v_gs_c1.EXP_UNITS:=to_number(nvl(v_gs_c1.EXP_UNITS,0)) +to_number(nvl(slot.EXP_UNITS,0));
                    v_gs_c1.BANKED_BALANCE:=nvl(slot.BANKED_BALANCE,0);
                    v_gs_c1.NET_UNITS:=to_number(nvl(v_gs_c1.NET_UNITS,0)) +to_number(nvl(slot.NET_UNITS,0));  
                    v_gs_c1.CREATED_DATE:=sysdate;
                    v_gs_c1.CREATED_BY:='METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT';
                    end if;
                    
                    if slot.slot_code='C2' then
                    v_gs_c2.slot_code:='C2';
                    v_gs_c2.IMP_INIT:=to_number(nvl(v_gs_c2.IMP_INIT,0)) +to_number(nvl(slot.IMP_INIT,0));
                    v_gs_c2.IMP_FINAL:=to_number(nvl(v_gs_c2.IMP_FINAL,0)) +to_number(nvl(slot.IMP_FINAL,0));
                    v_gs_c2.IMP_DIFF:=to_number(nvl(v_gs_c2.IMP_DIFF,0)) +to_number(nvl(slot.IMP_DIFF,0));
                    v_gs_c2.IMP_UNITS:=to_number(nvl(v_gs_c2.IMP_UNITS,0)) +to_number(nvl(slot.IMP_UNITS,0));
                    v_gs_c2.EXP_INIT:=to_number(nvl(v_gs_c2.EXP_INIT,0)) +to_number(nvl(slot.EXP_INIT,0));
                    v_gs_c2.EXP_FINAL:=to_number(nvl(v_gs_c2.EXP_FINAL,0)) +to_number(nvl(slot.EXP_FINAL,0));
                    v_gs_c2.EXP_DIFF:=to_number(nvl(v_gs_c2.EXP_DIFF,0)) +to_number(nvl(slot.EXP_DIFF,0));
                    v_gs_c2.EXP_UNITS:=to_number(nvl(v_gs_c2.EXP_UNITS,0)) +to_number(nvl(slot.EXP_UNITS,0));
                    v_gs_c2.BANKED_BALANCE:=nvl(slot.BANKED_BALANCE,0);
                    v_gs_c2.NET_UNITS:=to_number(nvl(v_gs_c2.NET_UNITS,0)) +to_number(nvl(slot.NET_UNITS,0));  
                    v_gs_c2.CREATED_DATE:=sysdate;
                    v_gs_c2.CREATED_BY:='METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT';
                    end if;
                    
                    if slot.slot_code='C3' then
                    v_gs_c3.slot_code:='C3';
                    v_gs_c3.IMP_INIT:=to_number(nvl(v_gs_c3.IMP_INIT,0)) +to_number(nvl(slot.IMP_INIT,0));
                    v_gs_c3.IMP_FINAL:=to_number(nvl(v_gs_c3.IMP_FINAL,0)) +to_number(nvl(slot.IMP_FINAL,0));
                    v_gs_c3.IMP_DIFF:=to_number(nvl(v_gs_c3.IMP_DIFF,0)) +to_number(nvl(slot.IMP_DIFF,0));
                    v_gs_c3.IMP_UNITS:=to_number(nvl(v_gs_c3.IMP_UNITS,0)) +to_number(nvl(slot.IMP_UNITS,0));
                    v_gs_c3.EXP_INIT:=to_number(nvl(v_gs_c3.EXP_INIT,0)) +to_number(nvl(slot.EXP_INIT,0));
                    v_gs_c3.EXP_FINAL:=to_number(nvl(v_gs_c3.EXP_FINAL,0)) +to_number(nvl(slot.EXP_FINAL,0));
                    v_gs_c3.EXP_DIFF:=to_number(nvl(v_gs_c3.EXP_DIFF,0)) +to_number(nvl(slot.EXP_DIFF,0));
                    v_gs_c3.EXP_UNITS:=to_number(nvl(v_gs_c3.EXP_UNITS,0)) +to_number(nvl(slot.EXP_UNITS,0));
                    v_gs_c3.BANKED_BALANCE:=nvl(slot.BANKED_BALANCE,0);
                    v_gs_c3.NET_UNITS:=to_number(nvl(v_gs_c3.NET_UNITS,0)) +to_number(nvl(slot.NET_UNITS,0));  
                    v_gs_c3.CREATED_DATE:=sysdate;
                    v_gs_c3.CREATED_BY:='METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT';
                    end if;
                    
                    if slot.slot_code='C4' then
                    v_gs_c4.slot_code:='C4';
                    v_gs_c4.IMP_INIT:=to_number(nvl(v_gs_c4.IMP_INIT,0)) +to_number(nvl(slot.IMP_INIT,0));
                    v_gs_c4.IMP_FINAL:=to_number(nvl(v_gs_c4.IMP_FINAL,0)) +to_number(nvl(slot.IMP_FINAL,0));
                    v_gs_c4.IMP_DIFF:=to_number(nvl(v_gs_c4.IMP_DIFF,0)) +to_number(nvl(slot.IMP_DIFF,0));
                    v_gs_c4.IMP_UNITS:=to_number(nvl(v_gs_c4.IMP_UNITS,0)) +to_number(nvl(slot.IMP_UNITS,0));
                    v_gs_c4.EXP_INIT:=to_number(nvl(v_gs_c4.EXP_INIT,0)) +to_number(nvl(slot.EXP_INIT,0));
                    v_gs_c4.EXP_FINAL:=to_number(nvl(v_gs_c4.EXP_FINAL,0)) +to_number(nvl(slot.EXP_FINAL,0));
                    v_gs_c4.EXP_DIFF:=to_number(nvl(v_gs_c4.EXP_DIFF,0)) +to_number(nvl(slot.EXP_DIFF,0));
                    v_gs_c4.EXP_UNITS:=to_number(nvl(v_gs_c4.EXP_UNITS,0)) +to_number(nvl(slot.EXP_UNITS,0));
                    v_gs_c4.BANKED_BALANCE:=nvl(slot.BANKED_BALANCE,0);
                    v_gs_c4.NET_UNITS:=to_number(nvl(v_gs_c4.NET_UNITS,0)) +to_number(nvl(slot.NET_UNITS,0));  
                    v_gs_c4.CREATED_DATE:=sysdate;
                    v_gs_c4.CREATED_BY:='METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT';
                    end if;
                    
                    if slot.slot_code='C5' then
                    v_gs_c5.slot_code:='C5';
                    v_gs_c5.IMP_INIT:=to_number(nvl(v_gs_c5.IMP_INIT,0)) +to_number(nvl(slot.IMP_INIT,0));
                    v_gs_c5.IMP_FINAL:=to_number(nvl(v_gs_c5.IMP_FINAL,0)) +to_number(nvl(slot.IMP_FINAL,0));
                    v_gs_c5.IMP_DIFF:=to_number(nvl(v_gs_c5.IMP_DIFF,0)) +to_number(nvl(slot.IMP_DIFF,0));
                    v_gs_c5.IMP_UNITS:=to_number(nvl(v_gs_c5.IMP_UNITS,0)) +to_number(nvl(slot.IMP_UNITS,0));
                    v_gs_c5.EXP_INIT:=to_number(nvl(v_gs_c5.EXP_INIT,0)) +to_number(nvl(slot.EXP_INIT,0));
                    v_gs_c5.EXP_FINAL:=to_number(nvl(v_gs_c5.EXP_FINAL,0)) +to_number(nvl(slot.EXP_FINAL,0));
                    v_gs_c5.EXP_DIFF:=to_number(nvl(v_gs_c5.EXP_DIFF,0)) +to_number(nvl(slot.EXP_DIFF,0));
                    v_gs_c5.EXP_UNITS:=to_number(nvl(v_gs_c5.EXP_UNITS,0)) +to_number(nvl(slot.EXP_UNITS,0));
                    v_gs_c5.BANKED_BALANCE:=nvl(slot.BANKED_BALANCE,0);
                    v_gs_c5.NET_UNITS:=to_number(nvl(v_gs_c5.NET_UNITS,0)) +to_number(nvl(slot.NET_UNITS,0));   
                    v_gs_c5.CREATED_DATE:=sysdate;
                    v_gs_c5.CREATED_BY:='METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT';
                    end if;
                     v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
                    end loop;
                    
                       OPEN v_charge_cursor for select * from tmp_gen_stmt_charge where TMP_GEN_STMT_ID =v_temp_gen_stmt.id ;
                        LOOP
                        FETCH v_charge_cursor INTO charge;
                        EXIT WHEN v_charge_cursor%NOTFOUND;
                            
                         if charge.CHARGE_CODE='C001' then
                         v_gs_c1_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c1_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c1_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c1_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c1_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c1_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c1_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c1_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                         if charge.CHARGE_CODE='C002' then
                         v_gs_c2_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c2_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c2_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c2_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c2_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c2_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c2_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c2_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                         if charge.CHARGE_CODE='C003' then
                         v_gs_c3_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c3_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c3_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c3_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c3_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c3_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c3_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c3_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                        if charge.CHARGE_CODE='C004' then
                         v_gs_c4_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c4_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c4_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c4_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c4_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c4_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c4_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c4_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                         if charge.CHARGE_CODE='C005' then
                                 v_gs_c5_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c5_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c5_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c5_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c5_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c5_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c5_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c5_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                         if charge.CHARGE_CODE='C006' then
                                 v_gs_c6_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c6_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c6_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c6_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c6_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c6_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c6_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c6_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                         if charge.CHARGE_CODE='C007' then
                                 v_gs_c7_charge.CHARGE_CODE:=charge.CHARGE_CODE;
                         v_gs_c7_charge.CHARGE_DESC:=charge.CHARGE_DESC;
                         v_gs_c7_charge.CHARGE_TYPE_CODE:=charge.CHARGE_DESC;
                         v_gs_c7_charge.UNIT_CHARGE:=to_number(nvl(v_gs_c7_charge.UNIT_CHARGE,0)) +to_number(nvl(charge.UNIT_CHARGE,0));    
                         v_gs_c7_charge.TOTAL_CHARGES:=to_number(nvl(v_gs_c7_charge.TOTAL_CHARGES,0)) +to_number(nvl(charge.TOTAL_CHARGES,0));    
                         v_gs_c7_charge.CREATED_DATE:=sysdate;
                         
                         end if;
                         
                         
                        END LOOP;
                    
               END LOOP;
                end if;
       end loop;
       
            	INSERT INTO  T_GEN_STMT VALUES  v_gs;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c1;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c2;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c3;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c4;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c5;
                
                INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c1_charge;
				INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c2_charge;
				INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c3_charge;
				INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c4_charge;
				INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c5_charge;
                INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c6_charge;
				INSERT INTO  T_GEN_STMT_CHARGE VALUES  v_gs_c7_charge;
   -----------------------------------------------------
      exception when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','METER_NUMBER_CHANGE.CREATE_CONSOLIDATED_GENERATION_STATEMENT','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION STARTS HERE
      
  END CREATE_CONSOLIDATED_GENERATION_STATEMENT;
  
END METER_NUMBER_CHANGE;

/
--------------------------------------------------------
--  DDL for Package Body MR_IMPORT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."MR_IMPORT" AS
  procedure process_mr_interface (v_remarks in varchar2,scenario in varchar2 default 'MERGE-WITH-NEXT-BILLING', v_result_code out varchar2, v_result_desc out varchar2) is

    v_batch_id varchar2(100):='';
    v_created_by varchar2(100):='admin';
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
	BEGIN
      BEGIN  -- exception handling start

      v_log_result := log_activity('PROCEDURE','mr_import.process_mr_interface','START',v_remarks,'',v_created_by, sysdate,'');
      v_batch_id :=IMP_MR_HEADER_SEQ.NEXTVAL;

      -- move data from import_meter_reading table to imp_mr_tables
      interface_to_mri(v_batch_id,scenario, v_remarks,v_result_code,v_result_desc);
      if(v_result_code = 'ERROR') then GOTO THE_END; END IF;

      -- populate meter_no
      cleanse(v_batch_id,scenario,v_result_code,v_result_desc);
      if(v_result_code = 'ERROR') then GOTO THE_END; END IF;

      -- call mr processing function
      -- note- MR are imported. after that gen stmt is not generated.
      v_result_code := import_mr(v_batch_id);

      exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result_code := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
        dbms_output.put_line(v_result_desc);
      END;
      <<THE_END>>
      commit;
      if(v_result_code = 'SUCCESS')then
        v_result_desc := v_batch_id;
      end if;
      v_log_result := log_activity('PROCEDURE','mr_import.process_mr_interface','RESULT',v_result_code,v_result_desc,v_created_by, sysdate,v_batch_id);
	END process_mr_interface;
  procedure interface_to_mri (v_batch_id in varchar2, scenario IN VARCHAR2,  v_remarks in varchar2, v_result_code out varchar2, v_result_desc out varchar2) is
    v_total number:=0;
    v_created_by varchar2(300):='admin';
    v_log_result  varchar2(50);
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
	BEGIN
      BEGIN  -- exception handling start

       --init
        v_result_code :='SUCCESS';
        -- find the total no. of records to be imported
        select count(v_remarks) into v_total from IMPORT_METER_READING where remarks=v_remarks;

        -- create import header entry
        Insert into IMP_MR_HEADER (ID,IMPORT_DT,STATUS,REMARKS,MR_SOURCE_CODE,CREATED_BY,CREATED_DATE,ENABLED,CODE,IMPORT_REMARKS,TOTAL_COUNT,SUCCESS_COUNT,ERROR_COUNT)
        values (v_batch_id,SYSDATE,'CREATED',v_remarks,'02',v_created_by,SYSDATE,'Y','MRI'||v_batch_id,null,v_total,0,0);

        v_log_result := log_activity('PROCEDURE','mr_import.interface_to_mri','IMPORT','batch created - '||'MRI'||v_batch_id,'',v_created_by, sysdate,v_batch_id);

        update IMPORT_METER_READING set reading_dt =to_date(reading_dt_str,'yyyy-mm-dd'),
        init_reading_dt = init_reading_dt_str , FINAL_READING_DT = final_reading_dt_str
        where remarks = v_remarks;

       -- update IMPORT_METER_READING set reading_dt = to_date(reading_dt_str,'yyyy-mm-dd'),
        --init_reading_dt = to_date(init_reading_dt_str,'yyyy-mm-dd') , FINAL_READING_DT = to_date(final_reading_dt_str,'yyyy-mm-dd')
        --where remarks = v_remarks;

        IF(scenario = 'MERGE-WITH-NEXT-BILLING' ) THEN 
          update IMPORT_METER_READING set MERGE_WITH_NEXT_BILLING = 'Y', IMPORT_ASIS='Y' where remarks = v_remarks;
        ELSIF(scenario = 'OVERWRITE' OR scenario = 'NO-OVERWRITE' ) THEN
          update IMPORT_METER_READING set IMPORT_ASIS='Y' where remarks = v_remarks;
        end if;

        -- create import line entries
       insert into imp_mr_lines(
          ID,IMP_MR_HEADER_ID,SERVICE_NO,SYS_DT,INIT_READING_DT,FINAL_READING_DT,READING_MONTH,READING_YEAR,
          STATUS_CODE,METER_NO,MF,MERGE_WITH_NEXT_BILLING,
          IMP_FINAL_S1,IMP_FINAL_S2,IMP_FINAL_S3,IMP_FINAL_S4,IMP_FINAL_S5,
          EXP_FINAL_S1,EXP_FINAL_S2,EXP_FINAL_S3,EXP_FINAL_S4,EXP_FINAL_S5,
          IMP_RKVAH_FINAL,EXP_RKVAH_FINAL,IMP_KVAH_FINAL,EXP_KVAH_FINAL,
          IMP_INIT_S1,IMP_INIT_S2,IMP_INIT_S3,IMP_INIT_S4,IMP_INIT_S5,
          EXP_INIT_S1,EXP_INIT_S2,EXP_INIT_S3,EXP_INIT_S4,EXP_INIT_S5,
          IMP_RKVAH_INIT,EXP_RKVAH_INIT,IMP_KVAH_INIT,EXP_KVAH_INIT,IMPORT_ASIS )
        select imp_mr_lines_seq.nextval id, v_batch_id IMP_MR_HEADER_ID, SERVICE_NO, sysdate SYS_DT, INIT_READING_DT, FINAL_READING_DT,reading_month, reading_year,
          'CREATED' STATUS_CODE, METER_NO, MF,MERGE_WITH_NEXT_BILLING,
          IMP_SLOT1 IMP_FINAL_S1,IMP_SLOT2  IMP_FINAL_S2,IMP_SLOT3  IMP_FINAL_S3,IMP_SLOT4  IMP_FINAL_S4,IMP_SLOT5 IMP_FINAL_S5,
          EXP_SLOT1 EXP_FINAL_S1,EXP_SLOT2  EXP_FINAL_S2,EXP_SLOT3  EXP_FINAL_S3,EXP_SLOT4  EXP_FINAL_S4,EXP_SLOT5 EXP_FINAL_S5,
          IMP_RKVAH IMP_RKVAH_FINAL,EXP_RKVAH EXP_RKVAH_FINAL,IMP_KVAH IMP_KVAH_FINAL,EXP_KVAH EXP_KVAH_FINAL,
          IMP_SLOT1 IMP_INIT_S1,IMP_SLOT2  IMP_INIT_S2,IMP_SLOT3  IMP_INIT_S3,IMP_SLOT4  IMP_INIT_S4,IMP_SLOT5 IMP_INIT_S5,
          EXP_SLOT1 EXP_INIT_S1,EXP_SLOT2  EXP_INIT_S2,EXP_SLOT3  EXP_INIT_S3,EXP_SLOT4  EXP_INIT_S4,EXP_SLOT5 EXP_INIT_S5,
          IMP_RKVAH IMP_RKVAH_INIT,EXP_RKVAH EXP_RKVAH_INIT,IMP_KVAH IMP_KVAH_INIT,EXP_KVAH EXP_KVAH_INIT, IMPORT_ASIS
          from IMPORT_METER_READING
          where REMARKS = v_remarks;
        commit;
        v_result_code := 'SUCCESS';
      exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result_code := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
        dbms_output.put_line(v_result_desc);
      END;
      v_log_result := log_activity('PROCEDURE','mr_import.interface_to_mri','RESULT',v_result_code,v_result_desc,v_created_by, sysdate,v_batch_id);

	END interface_to_mri;
	procedure cleanse (v_batch_id in varchar2,scenario IN VARCHAR2,  v_result_code out varchar2, v_result_desc out varchar2) is
    v_created_by varchar2(300):='admin';
    v_remarks  varchar2(100);
    v_meter_no  varchar2(100);
    v_mf  varchar2(100);
    v_log_result  varchar2(50);
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
	BEGIN
      BEGIN  -- exception handling start
      v_result_code:='SUCCESS';

      select remarks into v_remarks from imp_mr_header where id = v_batch_id;
      update imp_mr_lines set (meter_no, mf ) = (select meter_number, mf from v_company_service cs where cs."number"= imp_mr_lines.service_no) where IMP_MR_HEADER_ID = v_batch_id;

      IF(scenario = 'MERGE-WITH-NEXT-BILLING' or scenario = 'OVERWRITE') THEN 
        -- Delete existing(if) MeterReading from system for that month+year+service
        FOR rec IN (SELECT distinct mri.reading_month, mri.reading_year,mri.SERVICE_NO,mr.id t_meter_reading_hdr_id FROM imp_mr_lines mri 
                      join v_company_service ser on mri.service_no =  ser.m_comp_serv_number 
                      join t_meter_reading_hdr mr on ser.m_company_meter_id = mr.m_company_meter_id and  mri.reading_month = mr.reading_month and  mri.reading_year = mr.reading_year
                      where mri.imp_mr_header_id = v_batch_id)
        LOOP
          BEGIN
            DELETE_TXN.DELETE_BY_SERVICE('',rec.SERVICE_NO, rec.reading_month, rec.reading_year, 'Y', 'Y', 'Y', 'Y',v_result_code, v_result_desc);
          exception
          when others then
            v_exception_code := SQLCODE;
            v_exception_msg := SUBSTR(SQLERRM, 1, 200);
            v_result_code := 'FAILURE';
            v_result_desc := v_exception_code || ' - ' || v_exception_msg;
            dbms_output.put_line(v_result_desc);
          END;
        END LOOP;
      end IF;

      commit;
			v_result_code := 'SUCCESS';

      exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result_code := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
        dbms_output.put_line(v_result_desc);
      END;
      v_log_result := log_activity('PROCEDURE','mr_import.cleanse_mri','RESULT',v_result_code,v_result_desc,v_created_by, sysdate,v_batch_id);
	END cleanse;
	procedure process_mri (v_batch_id in varchar2) is
		v_result_code varchar2(100);
		BEGIN
			v_result_code := 'SUCCESS';
			DBMS_OUTPUT.PUT_LINE(v_result_code);
		END process_mri;
END mr_import;

/
--------------------------------------------------------
--  DDL for Package Body SUBSTATION_LOSS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."SUBSTATION_LOSS" AS

PROCEDURE START_IMPORT(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_created_by varchar2(100):='ADMIN';
    v_ss_loss t_substation_loss%ROWTYPE;
    v_Ss_count number:=0;
    v_def1 VARCHAR2(50) default null;
    v_def2 VARCHAR2(50) default null;
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.START_IMPORT','START_IMPORT','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);
    SUBSTATION_LOSS.CLEANSE(I_BATCH_KEY,O_RESULT_CODE,O_RESULT_DESC);
    IF(O_RESULT_CODE = 'ERROR' OR O_RESULT_CODE = 'FAILURE') THEN GOTO THE_END; END IF;

    SUBSTATION_LOSS.IMPORT(I_BATCH_KEY,O_RESULT_CODE,O_RESULT_DESC);
    IF(O_RESULT_CODE = 'ERROR' OR O_RESULT_CODE = 'FAILURE') THEN GOTO THE_END; END IF;
    
    SELECT COUNT(*) into v_Ss_count FROM t_substation_loss WHERE batch_key=I_BATCH_KEY;

     IF(v_Ss_count>1)THEN
    SELECT * into v_ss_loss FROM t_substation_loss WHERE batch_key=I_BATCH_KEY AND ROWNUM=1;
    GENERATION_STATEMENT.CREATE_WITH_SS_LOSS(v_def1,v_def2,v_ss_loss.M_ORG_ID,v_ss_loss.MONTH,v_ss_loss.YEAR,O_RESULT_CODE,O_RESULT_DESC);
    ELSIF(v_Ss_count=1)THEN
    SELECT * into v_ss_loss FROM t_substation_loss WHERE batch_key=I_BATCH_KEY AND ROWNUM=1;
    GENERATION_STATEMENT.CREATE_WITH_SS_LOSS(v_ss_loss.M_SUBSTATION_ID,v_def2,v_ss_loss.M_ORG_ID,v_ss_loss.MONTH,v_ss_loss.YEAR,O_RESULT_CODE,O_RESULT_DESC);
    END IF;
    
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.START_IMPORT','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE
    <<THE_END>>
    COMMIT;
    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.START_IMPORT','RESULT',O_RESULT_CODE,O_RESULT_DESC,v_created_by,sysdate,I_BATCH_KEY);

  END START_IMPORT;
  
  PROCEDURE CLEANSE(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_imp_loss_cursor sys_refcursor ;
    v_imp_ss_loss IMP_SUBSTATION_LOSS%ROWTYPE;
    v_org_name  varchar2(50);v_ss_name  varchar2(50);
    v_org_count  NUMBER:=0;v_ss_count  NUMBER:=0;
    v_number NUMBER;
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.CLEANSE','CLEANSE','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   --------------------------------------------------------
    OPEN v_imp_loss_cursor for select * from IMP_SUBSTATION_LOSS where BATCH_KEY=I_BATCH_KEY;
    LOOP
    FETCH v_imp_loss_cursor INTO v_imp_ss_loss;
    EXIT WHEN v_imp_loss_cursor%NOTFOUND;
	
   SELECT COUNT(*) INTO v_org_count FROM M_ORG WHERE ID=v_imp_ss_loss.M_ORG_ID;
   SELECT COUNT(*) INTO v_ss_count FROM M_SUBSTATION WHERE ID=v_imp_ss_loss.M_SUBSTATION_ID;
  
	IF(v_org_count=1 AND v_ss_count=1)THEN 
        v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.CLEANSE','COUNT-CONDITION','ORG-COUNT-'||v_org_count,'SS_COUNT-'||v_ss_count,'', sysdate,I_BATCH_KEY);

   		SELECT NAME INTO v_org_name FROM M_ORG WHERE ID=v_imp_ss_loss.M_ORG_ID;
   		SELECT NAME INTO v_ss_name FROM M_SUBSTATION WHERE ID=v_imp_ss_loss.M_SUBSTATION_ID;
   		
		SELECT IS_NUMBER(v_imp_ss_loss.LOSS_PERCENT) INTO v_number FROM dual;		
 		IF v_number=1 THEN
 		UPDATE IMP_SUBSTATION_LOSS SET M_SUBSTATION_NAME=v_ss_name,M_ORG_NAME=v_org_name,IS_IMPORTED='Y',RESULT_DESC=O_RESULT_DESC WHERE ID=v_imp_ss_loss.ID;
 		ELSE 
 		v_reason:='LOSS PERCENT IS NOT NUMBER';
 	    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.CLEANSE','CLEANSE',v_imp_ss_loss.M_ORG_ID,v_reason,v_imp_ss_loss.M_SUBSTATION_ID, sysdate,I_BATCH_KEY);
        o_result_desc:=v_reason;
 		UPDATE IMP_SUBSTATION_LOSS SET IS_IMPORTED='N',RESULT_DESC=v_reason WHERE ID=v_imp_ss_loss.ID;
 		END IF;
	ELSE 
	 	v_reason:='ORG OR SUBSTATION ENTERED WRONG OR DUPLICATE FOUND';
 	    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.CLEANSE','CLEANSE',v_imp_ss_loss.M_ORG_ID,v_reason,v_imp_ss_loss.M_SUBSTATION_ID, sysdate,I_BATCH_KEY);
        o_result_desc:=v_reason;
	 	UPDATE IMP_SUBSTATION_LOSS SET IS_IMPORTED='N',RESULT_DESC=v_reason WHERE ID=v_imp_ss_loss.ID;
	END IF;
    END LOOP;
   --------------------------------------------------------
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.CLEANSE','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE
  END CLEANSE;
  
  
  
    PROCEDURE IMPORT(I_BATCH_KEY IN VARCHAR2, O_RESULT_CODE OUT VARCHAR2, O_RESULT_DESC OUT VARCHAR2) IS
    v_log_result  varchar2(50);
    v_reason varchar2(200):='';
    v_exception_code  NUMBER;
    v_exception_msg  VARCHAR2(200);
    v_imp_loss_cursor sys_refcursor;
    v_imp_ss_loss IMP_SUBSTATION_LOSS%ROWTYPE;
    BEGIN
    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.IMPORT','IMPORT','Start - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

   --------------------------------------------------------
    OPEN v_imp_loss_cursor for select * from IMP_SUBSTATION_LOSS where BATCH_KEY=I_BATCH_KEY AND IS_IMPORTED='Y';
    LOOP
    FETCH v_imp_loss_cursor INTO v_imp_ss_loss;
    EXIT WHEN v_imp_loss_cursor%NOTFOUND;
    
    INSERT INTO T_SUBSTATION_LOSS
    (ID, BATCH_KEY, M_ORG_ID, M_SUBSTATION_ID, "MONTH", "YEAR", LOSS_PERCENT, BULK_METER_READING, TOTAL_ALL_WEGS, ENABLED, CREATED_BY, CREATED_DT, M_ORG_NAME, M_SUBSTATION_NAME)
    VALUES(T_SUBSTATION_LOSS_SEQ.NEXTVAL, v_imp_ss_loss.BATCH_KEY, v_imp_ss_loss.M_ORG_ID, v_imp_ss_loss.M_SUBSTATION_ID, v_imp_ss_loss."MONTH", v_imp_ss_loss."YEAR", v_imp_ss_loss.LOSS_PERCENT, v_imp_ss_loss.BULK_METER_READING, v_imp_ss_loss.TOTAL_ALL_WEGS, 'Y', v_imp_ss_loss.ENABLED, sysdate, v_imp_ss_loss.M_ORG_NAME, v_imp_ss_loss.M_SUBSTATION_NAME);
    v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.IMPORT','IMPORT','IMPORTED - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

    END LOOP;
   --------------------------------------------------------
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.IMPORT','EXCEPTION',O_RESULT_DESC,'','', sysdate,I_BATCH_KEY);
    END;--EXCEPTION ENDS HERE
        v_log_result := log_activity('PROCEDURE','SUBSTATION_LOSS.IMPORT','IMPORT','END - '||I_BATCH_KEY,'','', sysdate,I_BATCH_KEY);

  END IMPORT;
  
END SUBSTATION_LOSS;

/
--------------------------------------------------------
--  DDL for Package Body VIEW_REFRESH
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "OPENACCESS"."VIEW_REFRESH" AS 
    procedure COMP_SERV_REFRESH (i_service_number in varchar2,  o_result_code out varchar2,o_result_desc out varchar2) IS
    
    v_process varchar2(50):='VIEW_REFRESH.COMP_SERV_REFRESH';
    v_process_type varchar2(50):='PACKAGE';
    v_tr_count number:=0;
    v_temp TEMP_V_COMP_REFRESH%ROWTYPE;
    v_deleted_all_records boolean:=false;
    v_log_result   varchar2(300):='';
    
        BEGIN
        v_log_result := log_activity(v_process_type,v_process,'Start','','','', '',i_SERVICE_NUMBER);
            if(i_service_number='%') then
                DELETE FROM TEMP_V_COMP_REFRESH;
                v_deleted_all_records:= true;
            else
                DELETE FROM TEMP_V_COMP_REFRESH WHERE "number"=i_service_number;
    
            end if;
            for compserv in (select distinct companyservice.id,companyservice.COMP_SER_TYPE_CODE,companyservice.M_SECTION_ID,section.SECTION_NAME,section.SECTION_CODE,typecodes.value_desc as COMP_SER_TYPE_NAME,companyservice."number",companyservice.m_company_id,company.code as M_COMPANY_CODE,company.name AS M_COMPANY_NAME,company.IS_INTERNAL AS COMPANY_IS_INTERNAL,companyservice.m_org_id,
					org.code as M_ORG_CODE, org.name as M_ORG_NAME,companyservice.capacity,company.is_buyer,company.is_seller,companyservice.is_rec,company.is_captive,companyservice.FLOW_TYPE_CODE,companyservice."number" as m_comp_serv_number,
					companyservice.m_substation_id,substation.code as M_SUBSTATION_CODE,substation.name as M_SUBSTATION_NAME,substation.TYPE_OF_SS as TYPE_OF_SS,companyservice.m_feeder_id,feeder.code as M_FEEDER_CODE,feeder.name as M_FEEDER_NAME,companyservice.ref_number,companyservice.voltage_code,voltagecodes.VALUE_DESC as VOLTAGE_NAME,companyservice.tariff,
					companyservice.BANKING_SERVICE_ID, companyservice.BANKING_SERVICE_NUMBER, companyservice.DL_SERVICE_ID, companyservice.DL_SERVICE_NUMBER, companyservice.TL_SERVICE_ID, companyservice.TL_SERVICE_NUMBER,companyservice.UNADJUSTED_SERVICE_ID, companyservice.UNADJUSTED_SERVICE_NUMBER,companyservice.enabled,
					companymeter.id AS M_COMPANY_METER_ID,companymeter.MODEM_NUMBER, companymeter.METER_NUMBER, companymeter.MF, companymeter.ACCURACY_CLASS_CODE, nvl(companymeter.IS_ABTMETER,'N') IS_ABTMETER, companymeter.METER_MAKE_CODE,companymeter.METER_CT1,companymeter.METER_CT2,companymeter.METER_CT3,companymeter.METER_PT1,companymeter.METER_PT2,companymeter.METER_PT3,
                    powerplant.FUEL_TYPE_CODE,fueltypecodes.FUEL_NAME as FUEL_TYPE_NAME,fueltypecodes.FUEL_GROUP AS FUEL_GROUP_NAME,powerplant.COMMISSION_DATE
                    --,tr.flow_type_code tr_flow_type_code
					from m_company_service companyservice
					left join m_company company on company.id =companyservice.M_COMPANY_ID
					left join M_COMPANY_METER companymeter on companymeter.M_COMPANY_SERVICE_ID =companyservice.id AND companymeter.enabled='Y'
					left join m_org org on org.id=companyservice.M_ORG_ID
					left join m_substation substation on substation.id = companyservice.M_SUBSTATION_ID
					left join m_feeder feeder on feeder.id = companyservice.M_FEEDER_ID
					left join v_codes voltagecodes on companyservice.VOLTAGE_Code= voltagecodes.Value_Code AND  voltagecodes.list_code = 'VOLTAGE_CODE'
					left join v_codes typecodes on companyservice.COMP_SER_TYPE_CODE = typecodes.value_code and typecodes.list_code='SERVICE_TYPE_CODE'
                    left join M_POWERPLANT powerplant on  powerplant.M_SERVICE_ID=companyservice.id
                   -- left join m_trade_relationship tr on tr.m_seller_comp_service_id=companyservice.id
                    left join m_section section on section.Id=companyservice.M_Section_Id
                    left join m_fuel fueltypecodes on powerplant.FUEL_TYPE_CODE= fueltypecodes.fuel_code
                    where companyservice."number" like i_service_number)
                LOOP
                begin
                    v_temp.ID := compserv.id;
                    v_temp.ACCURACY_CLASS_CODE := compserv.ACCURACY_CLASS_CODE;
                    v_temp.BANKING_SERVICE_ID := compserv.BANKING_SERVICE_ID;
                    v_temp.BANKING_SERVICE_NUMBER := compserv.BANKING_SERVICE_NUMBER;
                    v_temp.CAPACITY := compserv.capacity;
                    v_temp.COMMISSION_DATE := compserv.COMMISSION_DATE;
                    v_temp.COMPANY_IS_INTERNAL := compserv.COMPANY_IS_INTERNAL;
                    v_temp.COMP_SER_TYPE_CODE := compserv.COMP_SER_TYPE_CODE;
                    v_temp.COMP_SER_TYPE_NAME := compserv.COMP_SER_TYPE_NAME;
                    v_temp.DL_SERVICE_ID := compserv.DL_SERVICE_ID;
                    v_temp.DL_SERVICE_NUMBER := compserv.DL_SERVICE_NUMBER;
                    v_temp.ENABLED := compserv.enabled;
                    v_temp.FLOW_TYPE_CODE := compserv.FLOW_TYPE_CODE; 
                    v_temp.FUEL_TYPE_CODE := compserv.FUEL_TYPE_CODE;
                    v_temp.FUEL_TYPE_NAME := compserv.FUEL_TYPE_NAME;
                    v_temp.FUEL_GROUP_NAME := compserv.FUEL_GROUP_NAME;
                    v_temp.IS_ABTMETER := compserv.IS_ABTMETER;
                    v_temp.IS_BUYER := compserv.is_buyer;
                    v_temp.IS_REC := compserv.is_rec;
                    v_temp.IS_SELLER := compserv.is_seller;
                    v_temp.METER_CT1 := compserv.METER_CT1;
                    v_temp.METER_CT2 := compserv.METER_CT2;
                    v_temp.METER_CT3 := compserv.METER_CT3;
                    v_temp.METER_MAKE_CODE := compserv.METER_MAKE_CODE;
                    v_temp.METER_NUMBER := compserv.METER_NUMBER;
                    v_temp.METER_PT1 := compserv.METER_PT1;
                    v_temp.METER_PT2 := compserv.METER_PT2;
                    v_temp.METER_PT3 := compserv.METER_PT3;
                    v_temp.MF := compserv.MF;
                    v_temp.MODEM_NUMBER := compserv.MODEM_NUMBER;
                    v_temp.M_COMPANY_CODE := compserv.M_COMPANY_CODE;
                    v_temp.M_COMPANY_ID := compserv.m_company_id;
                    v_temp.M_COMPANY_METER_ID := compserv.M_COMPANY_METER_ID;
                    v_temp.M_COMPANY_NAME := compserv.M_COMPANY_NAME;
                    v_temp.M_COMP_SERV_NUMBER := compserv.m_comp_serv_number;
                    v_temp.M_FEEDER_CODE := compserv.M_FEEDER_CODE;
                    v_temp.M_FEEDER_ID := compserv.m_feeder_id;
                    v_temp.M_FEEDER_NAME := compserv.M_FEEDER_NAME;
                    v_temp.M_ORG_CODE := compserv.M_ORG_CODE;
                    v_temp.M_ORG_ID := compserv.m_org_id;
                    v_temp.M_ORG_NAME := compserv.M_ORG_NAME;
                    v_temp.M_SECTION_ID := compserv.M_SECTION_ID;
                    v_temp.M_SECTION_NAME := compserv.SECTION_NAME;
                    v_temp.M_SECTION_CODE := compserv.SECTION_CODE;
                    v_temp.M_SUBSTATION_CODE := compserv.M_SUBSTATION_CODE;
                    v_temp.M_SUBSTATION_ID := compserv.m_substation_id;
                    v_temp.M_SUBSTATION_NAME := compserv.M_SUBSTATION_NAME;
                    v_temp.REF_NUMBER := compserv.ref_number;
                    v_temp.TARIFF := compserv.tariff;
                    v_temp.TL_SERVICE_ID := compserv.TL_SERVICE_ID;
                    v_temp.TL_SERVICE_NUMBER := compserv.TL_SERVICE_NUMBER;
                    v_temp.TYPE_OF_SS :=compserv.TYPE_OF_SS;
                    v_temp.UNADJUSTED_SERVICE_ID :=compserv.UNADJUSTED_SERVICE_ID; 
                    v_temp.UNADJUSTED_SERVICE_NUMBER := compserv.UNADJUSTED_SERVICE_NUMBER;
                    v_temp.VOLTAGE_CODE := compserv.voltage_code;
                    v_temp.VOLTAGE_NAME := compserv.VOLTAGE_NAME;
                    v_temp."number" := compserv."number";
                    
                    v_temp.IS_CAPTIVE := 'N';
                    v_temp.IS_STB := 'N';
                    v_temp.IS_THIRD_PARTY := 'N';
                    v_temp.tr_flow_type_code := NULL;
                     
                    for tr in (select  flow_type_code from m_trade_relationship  where m_seller_comp_service_id=compserv.id  and flow_type_code is not NULL GROUP BY flow_type_code ORDER BY count(flow_type_code) desc)                    
                    loop
                        if tr.flow_type_code = 'IS-CAPTIVE' THEN v_temp.IS_CAPTIVE := 'Y';
                        ELSIF tr.flow_type_code = 'STB' THEN v_temp.IS_STB := 'Y';
                        elsif tr.flow_type_code = 'THIRD-PARTY' THEN v_temp.IS_THIRD_PARTY := 'Y';
                        END if;
                        
                        if v_temp.tr_flow_type_code is null then v_temp.tr_flow_type_code := tr.flow_type_code; end if;
                    end loop;                    
                    if (v_temp.IS_SELLER = 'Y') then
                        excess_units.find_type(v_temp."number", v_temp.EXCESS_UNIT_TYPE, v_temp.EXCESS_UNIT_TYPE_REASON);
                    else
                        v_temp.EXCESS_UNIT_TYPE:='NA';
                        v_temp.EXCESS_UNIT_TYPE_REASON := 'Not a Seller';
                    end if;
                    INSERT INTO TEMP_V_COMP_REFRESH VALUES v_temp;
                    
                exception
                when others then
                    o_result_code := 'FAILURE';
                    o_result_desc := SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
                    v_log_result := log_activity(v_process_type,v_process,'EH','Exception - '||o_result_desc,o_result_code,'', compserv."number",i_service_number);

                   -- dbms_output.put_line(o_result_desc);
                END;
                END LOOP;
            commit;
            o_result_code :='SUCCESS'; 
            v_log_result := log_activity(v_process_type,v_process,'End',o_result_desc,o_result_code,'', '',I_SERVICE_NUMBER);

        END COMP_SERV_REFRESH;
        
        procedure COMP_SERV_REFRESH_ALL ( o_result_code out varchar2,o_result_desc out varchar2) IS
        begin
            comp_serv_refresh('%', o_result_code, o_result_desc);
        END COMP_SERV_REFRESH_ALL;

      END VIEW_REFRESH;

/
--------------------------------------------------------
--  DDL for Function ADD_COMMERCIALS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."ADD_COMMERCIALS" 
(
  V_SERVICE_NUMBER IN VARCHAR2,
  V_REMARKS IN VARCHAR2 
) RETURN VARCHAR2 AS

v_seller_company_service_id varchar2(50);
v_seller_company_id varchar2(50);
v_seller_org_id varchar2(50);
v_ss_id varchar2(50);
v_buyer_company_service_id varchar2(50);
v_buyer_company_id varchar2(50);
v_buyer_org_id varchar2(50);
v_buyer_ss_id varchar2(50);
v_buyer_voltage_Code varchar2(50);
v_company_service M_COMPANY_SERVICE%ROWTYPE;
v_ewa T_EWA%ROWTYPE;
v_ewa_line T_EWA_LINE%ROWTYPE;
v_aggrement_ewa F_AGREEMENT%ROWTYPE;
v_aggrement_ewa_line F_AGREEMENT_LINE%ROWTYPE;
v_commercials_trade IMPORT_TRADE_REL%ROWTYPE;
v_commercials_cursor sys_refcursor ;
v_date_diff VARCHAR2(17);
v_oaa T_OAA%ROWTYPE;
v_aggrement_oaa F_AGREEMENT%ROWTYPE;
v_epa T_EPA%ROWTYPE;
v_epa_line T_EPA_LINES%ROWTYPE;
v_aggrement_epa F_AGREEMENT%ROWTYPE;
v_aggrement_epa_line F_AGREEMENT_LINE%ROWTYPE;
v_is_captive varchar2(50);
v_flow_type_code varchar2(50);
v_flow_type_for_agmt varchar2(50);
v_conversion number:=0.001;
v_m_trade_rel M_TRADE_RELATIONSHIP%ROWTYPE;
v_imp_trade_rel import_trade_rel%ROWTYPE;

v_created_by varchar2(100):='ADD_COMMERCIALS';
v_result VARCHAR(200):='SUCCESS';
v_result_code varchar2(100);
v_result_desc varchar2(300);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_log_result  varchar2(50);

v_no_dt_count number:=0;

BEGIN
BEGIN
    v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','START','FOR SERVICE- '||V_SERVICE_NUMBER,'STARTED',v_created_by, sysdate,'');


    --Getting seller details
    SELECT service.ID,service.M_COMPANY_ID,service.M_ORG_ID,service.M_SUBSTATION_ID
    INTO v_seller_company_service_id,v_seller_company_id,v_seller_org_id,v_ss_id 
    FROM M_COMPANY_SERVICE service WHERE service."number"=V_SERVICE_NUMBER;
    -- -- dbms_output.put_line('v_seller_company_service_id-' || v_seller_company_service_id || '-v_seller_company_id-' || v_seller_company_id);


    --isCaptive
    SELECT IS_CAPTIVE INTO v_is_captive FROM M_COMPANY WHERE ID=v_seller_company_id;

    --Getting m_company_service
    SELECT * INTO v_company_service FROM M_COMPANY_SERVICE WHERE "number"=V_SERVICE_NUMBER;

    select * into v_imp_trade_rel from IMPORT_TRADE_REL where SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER  and IMPORT_REMARKS=V_REMARKS and rownum=1;

    -- ***************** ASSUMPTION THAT ALL TRADE-RELATIONSHIPS FOR A GENERATOR WILL BE HAVE SAME FLOW_TYPE_CODE *****************
    IF(v_imp_trade_rel.FLOW_TYPE_CODE = 'IS-CAPTIVE') THEN
        v_is_captive := 'Y';
        v_flow_type_code := 'IS-CAPTIVE';
        v_flow_type_for_agmt := 'CAPTIVE';   -- for some reason, flow-type in service and TRs is IS-CAPTIVE but in agreements its CAPTIVE
    elsif(v_imp_trade_rel.FLOW_TYPE_CODE = 'THIRD-PARTY') THEN
        v_is_captive := 'N';
        v_flow_type_code := 'THIRD-PARTY';
        v_flow_type_for_agmt := 'THIRD-PARTY';
    elsif(v_imp_trade_rel.FLOW_TYPE_CODE = 'STB') THEN
        v_is_captive := 'N';
        v_flow_type_code := 'STB';
        v_flow_type_for_agmt := 'THIRD-PARTY';
    else
        v_result_desc   := 'Unknown FlowTypeCode -'||v_imp_trade_rel.FLOW_TYPE_CODE;
        v_result   := 'FAILURE';
        GOTO THE_END;
    END IF;
    if(v_imp_trade_rel.from_date_str IS NOT NULL)THEN
        update import_trade_rel set from_date=to_date(from_date_str,'dd/mm/yyyy') , to_date=to_date(to_date_str,'dd/mm/yyyy'), QUANTUM = (v_company_service.CAPACITY/to_number(SHARE_PERCENT)*100)*v_conversion where SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER  and IMPORT_REMARKS=V_REMARKS;
    END IF;

    update import_trade_rel set QUANTUM = (v_company_service.CAPACITY/to_number(SHARE_PERCENT)*100)*v_conversion where SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER  and IMPORT_REMARKS=V_REMARKS;

    v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','001','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,'');

    IF(v_flow_type_code in ('IS-CAPTIVE','THIRD-PARTY'))THEN

        --Creating EWA
        v_ewa.id := t_ewa_seq.nextval;
        v_ewa.code := 'EWA'||v_ewa.id;
        v_ewa.SELLER_COMP_SERV_ID := v_seller_company_service_id;
        v_ewa.SELLER_END_ORG_ID := v_seller_org_id;
        v_ewa.INJECTION_VOLTAGE_CODE := v_company_service.VOLTAGE_CODE;
        v_ewa.STATUS_CODE := 'COMPLETED';
        v_ewa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
        v_ewa.ENABLED := 'Y';
        v_ewa.created_date := sysdate;
        v_ewa.SELLER_IS_CAPTIVE := v_is_captive;

        INSERT INTO T_EWA VALUES v_ewa;
        v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-001','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,'');


        --Creating Agreement for EWA
        v_aggrement_ewa.id := F_AGREEMENT_SEQ.nextval;
        v_aggrement_ewa.CODE :=  'AGREEMENT'||v_aggrement_ewa.id;
        v_aggrement_ewa.T_EWA_ID := v_ewa.id;
        v_aggrement_ewa.SELLER_COMP_SERV_ID := v_ewa.SELLER_COMP_SERV_ID;
        v_aggrement_ewa.SELLER_EDC_ID := v_ewa.SELLER_END_ORG_ID;
        v_aggrement_ewa.SELLER_COMPANY_ID := v_seller_company_id;
        v_aggrement_ewa.IS_CAPTIVE := v_is_captive;
        v_aggrement_ewa.FLOW_TYPE := v_ewa.FLOW_TYPE_CODE;
        v_aggrement_ewa.STATUS_CODE := 'SIGNED';

        INSERT INTO F_AGREEMENT VALUES v_aggrement_ewa;
        v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-101','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,'');

        OPEN v_commercials_cursor for SELECT * FROM IMPORT_TRADE_REL WHERE SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS;
        LOOP --Loop starts here
            FETCH v_commercials_cursor INTO v_commercials_trade;
            EXIT WHEN v_commercials_cursor%NOTFOUND;
            BEGIN    
                --Getting buyer details
                SELECT buyerservice.ID,buyerservice.M_ORG_ID,buyerservice.M_SUBSTATION_ID,buyerservice.VOLTAGE_CODE,buyerservice.M_COMPANY_ID
                INTO v_buyer_company_service_id,v_buyer_org_id,v_buyer_ss_id,v_buyer_voltage_Code,v_buyer_company_id
                FROM M_COMPANY_SERVICE buyerservice WHERE buyerservice."number"= v_commercials_trade.BUYER_COMPANY_SERVICE_NO;    
                ---- dbms_output.put_line('v_buyer_company_service_id-' || v_buyer_company_service_id );


                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-102','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
                --Updating EWA inside Loop
                SELECT (TO_DATE-FROM_DATE)
                INTO v_date_diff
                FROM IMPORT_TRADE_REL where BUYER_COMPANY_SERVICE_NO = v_commercials_trade.BUYER_COMPANY_SERVICE_NO and SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS and rownum=1;
                IF (v_date_diff>90 AND V_DATE_DIFF<1825)THEN
                v_ewa.AGMT_PERIOD_CODE := 'MTOA';
                ELSIF (v_date_diff>1825)THEN
                v_ewa.AGMT_PERIOD_CODE := 'LTOA';
                ELSE
                v_ewa.AGMT_PERIOD_CODE := 'STOA';
                END IF;
            ---- dbms_output.put_line('QUANTUM;-' || v_commercials_trade.QUANTUM);

                v_ewa.TOAL_APPROVED_UNITS := v_company_service.CAPACITY;
                v_ewa.FROM_DT := v_commercials_trade.FROM_DATE;
                v_ewa.TO_DT := v_commercials_trade.TO_DATE;
                v_ewa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-103','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);

                UPDATE T_EWA SET FROM_DT=v_ewa.FROM_DT, TO_DT=v_ewa.TO_DT,AGMT_PERIOD_CODE=v_ewa.AGMT_PERIOD_CODE,IMPORT_REMARKS=v_ewa.IMPORT_REMARKS,TOAL_APPROVED_UNITS=v_ewa.TOAL_APPROVED_UNITS WHERE id = v_ewa.id;

                v_aggrement_ewa.FROM_DATE := v_ewa.FROM_DT;
                v_aggrement_ewa.TO_DATE := v_ewa.TO_DT;
                v_aggrement_ewa.AGREEMENT_PERIOD_CODE := v_ewa.AGMT_PERIOD_CODE;
                v_aggrement_ewa.AGREEMENT_DATE := v_ewa.FROM_DT;
                v_aggrement_ewa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                UPDATE F_AGREEMENT SET FROM_DATE=v_ewa.FROM_DT,TO_DATE = v_ewa.TO_DT,AGREEMENT_PERIOD_CODE=v_ewa.AGMT_PERIOD_CODE,AGREEMENT_DATE=v_ewa.FROM_DT,IMPORT_REMARKS=v_commercials_trade.IMPORT_REMARKS WHERE id = v_aggrement_ewa.id;

                --Creating Ewa Line
                v_ewa_line.id := t_ewa_line_seq.nextval;
                v_ewa_line.T_EWA_ID := v_ewa.id;
                v_ewa_line.BUYER_COMP_SERV_ID := v_buyer_company_service_id;   
                v_ewa_line.INTERVAL_TYPE_CODE := v_commercials_trade.INTERVAL_TYPE_CODE;
                v_ewa_line.SHARE_PERCENTAGE := v_commercials_trade.SHARE_PERCENT;
                v_ewa_line.IS_CAPTIVE := v_is_captive;
                v_ewa_line.ENABLED := 'Y';
                v_ewa_line.created_by := 'admin';
                v_ewa_line.created_dt := sysdate;
                v_ewa_line.created_date := sysdate;
                v_ewa_line.PROPOSED_UNITS := v_commercials_trade.QUANTUM;
                v_ewa_line.APPROVED_UNITS := v_commercials_trade.QUANTUM;
                v_ewa_line.INJECTION_PEAK_UNITS := v_commercials_trade.PEAK_UNITS;
                v_ewa_line.INJECTION_OFF_PEAK_UNITS := v_commercials_trade.OFF_PEAK_UNITS;
                v_ewa_line.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;
                v_ewa_line.DRAWAL_VOLTAGE_CODE :=v_buyer_voltage_Code;

                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-104','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
                INSERT INTO t_ewa_line VALUES v_ewa_line;

                v_aggrement_ewa_line.id := F_AGREEMENT_LINE_SEQ.nextval;
                v_aggrement_ewa_line.F_AGREEMENT_ID := v_aggrement_ewa.id;
                v_aggrement_ewa_line.BUYER_COMP_SERV_ID := v_ewa_line.BUYER_COMP_SERV_ID;
                v_aggrement_ewa_line.BUYER_ORG_ID := v_ewa_line.BUYER_END_ORG_ID;
                v_aggrement_ewa_line.DRAWAL_VOLTAGE_CODE := v_ewa_line.DRAWAL_VOLTAGE_CODE;
                v_aggrement_ewa_line.PROPOSED_CAPACITY := v_ewa_line.PROPOSED_UNITS;
                v_aggrement_ewa_line.APPROVED_CAPACITY := v_ewa_line.APPROVED_UNITS;
                v_aggrement_ewa_line.FLOW_TYPE_CODE := v_ewa.AGMT_PERIOD_CODE;
                v_aggrement_ewa_line.AGMT_PERIOD_CODE := v_ewa.FLOW_TYPE_CODE;
                v_aggrement_ewa_line.APPROVED_DT := v_ewa_line.APPROVED_DT;
                v_aggrement_ewa_line.AGREEMENT_DT := v_ewa.FROM_DT;
                v_aggrement_ewa_line.IS_CAPTIVE := v_ewa_line.IS_CAPTIVE;
                v_aggrement_ewa_line.PEAK_UNITS :=v_ewa_line.DRAWAL_PEAK_UNITS;
                v_aggrement_ewa_line.OFF_PEAK_UNITS := v_ewa_line.DRAWAL_OFF_PEAK_UNITS;
                v_aggrement_ewa_line.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                INSERT INTO F_AGREEMENT_LINE VALUES v_aggrement_ewa_line;

                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-105','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);

                v_oaa.id := t_oaa_seq.nextval;
                v_oaa.CODE := 'OAA'||v_oaa.id;
                v_oaa.BUYER_COMP_SERV_ID := v_buyer_company_service_id;
                v_oaa.BUYER_END_ORG_ID := v_buyer_org_id;
                v_oaa.DRAWAL_DIST_VOLTAGE_CODE :=v_ewa_line.DRAWAL_VOLTAGE_CODE;
                v_oaa.AGMT_PERIOD_CODE := v_ewa.AGMT_PERIOD_CODE;
                v_oaa.FROM_DT := v_commercials_trade.from_date;
                v_oaa.TO_DT:= v_commercials_trade.to_date;
                v_oaa.PROPOSED_TOTAL_UNITS:= v_commercials_trade.QUANTUM;
                v_oaa.APPROVED_TOTAL_UNITS:= v_commercials_trade.QUANTUM;
                v_oaa.SELLER_COMP_SERV_ID:=v_seller_company_service_id;
                v_oaa.SELLER_END_ORG_ID := v_seller_org_id ;
                v_oaa.INJECTION_DIST_SS_ID:= v_company_service.M_SUBSTATION_ID;
                v_oaa.INJECTION_DIST_VOLTAGE_CODE :=  v_company_service.VOLTAGE_CODE;
                v_oaa.STATUS_CODE := 'COMPLETED';
                v_oaa.INTERVAL_TYPE_CODE := v_commercials_trade.INTERVAL_TYPE_CODE;
                v_oaa.C1_UNITS :=v_commercials_trade.C1;
                v_oaa.C2_UNITS :=v_commercials_trade.C2;
                v_oaa.C3_UNITS :=v_commercials_trade.C3;
                v_oaa.C4_UNITS :=v_commercials_trade.C4;
                v_oaa.C5_UNITS :=v_commercials_trade.C5;
                v_oaa.AGREEMENT_DT :=sysdate;
                v_oaa.PEAK_UNITS := v_commercials_trade.PEAK_UNITS;
                v_oaa.OFF_PEAK_UNITS :=v_commercials_trade.OFF_PEAK_UNITS;
                v_oaa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
                v_oaa.ENABLED := 'Y';
                v_oaa.created_by := 'admin';
                v_oaa.created_dt := sysdate;
                v_oaa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                INSERT INTO t_oaa VALUES v_oaa;


                v_aggrement_oaa.id := F_AGREEMENT_SEQ.nextval;
                v_aggrement_oaa.CODE :=  'AGREEMENT'||v_aggrement_oaa.id;
                v_aggrement_oaa.T_OAA_ID := v_oaa.id;
                v_aggrement_oaa.BUYER_COMP_SERV_ID := v_oaa.BUYER_COMP_SERV_ID;
                v_aggrement_oaa.BUYER_EDC_ID := v_oaa.BUYER_END_ORG_ID;
                v_aggrement_oaa.BUYER_COMP_ID := v_buyer_company_id;
                v_aggrement_oaa.AGREEMENT_PERIOD_CODE := v_oaa.AGMT_PERIOD_CODE;
                v_aggrement_oaa.FROM_DATE := v_oaa.FROM_DT;
                v_aggrement_oaa.TO_DATE:= v_oaa.TO_DT;
                v_aggrement_oaa.STATUS_CODE :='SIGNED';
                v_aggrement_oaa.SELLER_COMP_SERV_ID:=v_oaa.SELLER_COMP_SERV_ID;
                v_aggrement_oaa.INTERVAL_TYPE_CODE := v_oaa.INTERVAL_TYPE_CODE;
                v_aggrement_oaa.C1 :=v_oaa.C1_UNITS;
                v_aggrement_oaa.C2 :=v_oaa.C2_UNITS;
                v_aggrement_oaa.C3 :=v_oaa.C3_UNITS;
                v_aggrement_oaa.C4 :=v_oaa.C4_UNITS;
                v_aggrement_oaa.C5 :=v_oaa.C5_UNITS;
                v_aggrement_oaa.AGREEMENT_DATE :=v_oaa.AGREEMENT_DT;
                v_aggrement_oaa.PEAK_UNITS := v_oaa.PEAK_UNITS;
                v_aggrement_oaa.OFF_PEAK_UNITS :=v_oaa.OFF_PEAK_UNITS;
                v_aggrement_oaa.FLOW_TYPE := v_flow_type_for_agmt;
                v_aggrement_oaa.SELLER_COMPANY_ID := v_seller_company_id;
                v_aggrement_oaa.SELLER_EDC_ID := v_oaa.SELLER_END_ORG_ID;
                v_aggrement_oaa.IS_CAPTIVE := v_is_captive;
                v_aggrement_oaa.TOTAL_UNITS := v_oaa.PEAK_UNITS;
                v_aggrement_oaa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                INSERT INTO F_AGREEMENT VALUES v_aggrement_oaa;
                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-106','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
                --Start here 
                v_m_trade_rel.ID := M_TRADE_RELATIONSHIP_SEQ.nextval;
                v_m_trade_rel.M_SELLER_COMPANY_ID := v_seller_company_id;
                v_m_trade_rel.M_SELLER_COMP_SERVICE_ID := v_seller_company_service_id;
                v_m_trade_rel.M_BUYER_COMPANY_ID := v_buyer_company_id;
                v_m_trade_rel.M_BUYER_COMP_SERVICE_ID := v_buyer_company_service_id;
                v_m_trade_rel.QUANTUM := v_commercials_trade.QUANTUM;
                v_m_trade_rel.FROM_DATE := v_commercials_trade.FROM_DATE;
                v_m_trade_rel.TO_DATE := v_commercials_trade.TO_DATE;
                v_m_trade_rel.C1 := v_commercials_trade.C1;
                v_m_trade_rel.C2 := v_commercials_trade.C2;
                v_m_trade_rel.C3 := v_commercials_trade.C3;
                v_m_trade_rel.C4 := v_commercials_trade.C4;
                v_m_trade_rel.C5 := v_commercials_trade.C5;
                v_m_trade_rel.IS_CAPTIVE := v_is_captive;
                v_m_trade_rel.FLOW_TYPE_CODE := v_flow_type_code;
                v_m_trade_rel.PEAK_UNITS := v_commercials_trade.PEAK_UNITS;
                v_m_trade_rel.OFF_PEAK_UNITS := v_commercials_trade.OFF_PEAK_UNITS;
                v_m_trade_rel.INTERVAL_TYPE_CODE := v_commercials_trade.INTERVAL_TYPE_CODE;
                v_m_trade_rel.SHARE_PERCENT := v_commercials_trade.SHARE_PERCENT;
                v_m_trade_rel.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;
                v_m_trade_rel.agreement_type := v_ewa.AGMT_PERIOD_CODE ;
                v_m_trade_rel.enabled := 'Y' ;
                v_m_trade_rel.created_by := v_created_by ;
                v_m_trade_rel.created_date := sysdate ;


                INSERT INTO M_TRADE_RELATIONSHIP VALUES v_m_trade_rel;


                 update M_TRADE_RELATIONSHIP set INTERVAL_TYPE_CODE='04' where INTERVAL_TYPE_CODE is null;


                Update IMPORT_TRADE_REL set remarks='COMPLETED' WHERE BUYER_COMPANY_SERVICE_NO = v_commercials_trade.BUYER_COMPANY_SERVICE_NO and SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS;

                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-107','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
            EXCEPTION
            WHEN OTHERS THEN 
                v_exception_code := SQLCODE;
                v_exception_msg := SUBSTR(SQLERRM, 1, 200);
                v_result := 'FAILURE';
                v_result_desc := v_exception_code || ' - ' || v_exception_msg;
                -- dbms_output.put_line(v_result_desc);
                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-107','FOR SERVICE- '||V_SERVICE_NUMBER,'EXITING LOOP as one trade-relationship had error',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
                Update IMPORT_TRADE_REL set remarks='FAILED', result=v_result, result_Desc=v_result_desc WHERE BUYER_COMPANY_SERVICE_NO=v_commercials_trade.BUYER_COMPANY_SERVICE_NO and SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS;
            end;    
        END LOOP;

    -------------------------------------------------------------
    -- else of captive-if
    ELSE
        --Creating epa
        v_epa.id := T_EPA_SEQ.nextval;
        v_epa.CODE :=  'EPA'||v_epa.id;
        v_epa.SELLER_COMP_SERV_ID := v_seller_company_service_id;
        v_epa.SELLER_END_ORG_ID := v_seller_org_id;
        v_epa.STATUS_CODE := 'COMPLETED';
        v_epa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
        v_epa.ENABLED:= 'Y';
        v_epa.SELLER_IS_CAPTIVE := v_is_captive;
        v_epa.CREATED_DATE := sysdate;

        INSERT INTO T_EPA VALUES v_epa;

        --Create agreement for epa
        v_aggrement_epa.id := F_AGREEMENT_SEQ.nextval;
        v_aggrement_epa.CODE :=  'AGREEMENT'||v_aggrement_epa.id;
        v_aggrement_epa.T_EPA_ID := v_epa.id;
        v_aggrement_epa.SELLER_COMP_SERV_ID := v_epa.SELLER_COMP_SERV_ID;
        v_aggrement_epa.SELLER_EDC_ID := v_epa.SELLER_END_ORG_ID;
        v_aggrement_epa.SELLER_COMPANY_ID := v_seller_company_id;
        v_aggrement_epa.FLOW_TYPE := v_epa.FLOW_TYPE_CODE;
        v_aggrement_epa.STATUS_CODE := 'SIGNED';
        v_aggrement_epa.BUYER_COMP_SERV_ID :=  'TNEB-'||v_aggrement_epa.SELLER_EDC_ID;

        INSERT INTO F_AGREEMENT VALUES v_aggrement_epa;
        v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-201','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,'');

        --Loop starts
        OPEN v_commercials_cursor for SELECT * FROM IMPORT_TRADE_REL WHERE SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS;
        LOOP
            FETCH v_commercials_cursor INTO v_commercials_trade;
            EXIT WHEN v_commercials_cursor%NOTFOUND;
            BEGIN
                --Getting buyer details
                SELECT buyerservice.ID,buyerservice.M_ORG_ID,buyerservice.M_SUBSTATION_ID,buyerservice.m_company_id
                INTO v_buyer_company_service_id,v_buyer_org_id,v_buyer_ss_id,v_buyer_company_id
                FROM M_COMPANY_SERVICE buyerservice WHERE buyerservice."number"= v_commercials_trade.BUYER_COMPANY_SERVICE_NO;    
                ---- dbms_output.put_line('v_buyer_company_service_id-' || v_buyer_company_service_id );

                SELECT (TO_DATE-FROM_DATE)
                INTO v_date_diff
                FROM IMPORT_TRADE_REL where BUYER_COMPANY_SERVICE_NO = v_commercials_trade.BUYER_COMPANY_SERVICE_NO and SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS and rownum=1;

                IF (v_date_diff>90 AND V_DATE_DIFF<1825)THEN
                    v_epa.AGMT_PERIOD_CODE := 'MTOA';
                ELSIF (v_date_diff>1825)THEN
                    v_epa.AGMT_PERIOD_CODE := 'LTOA';
                ELSE
                    v_epa.AGMT_PERIOD_CODE := 'STOA';
                END IF;

                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-202','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);

                v_epa.APPROVED_TOTAL_UNITS := v_company_service.CAPACITY;
                v_epa.BUYER_COMP_SERV_ID :=v_buyer_company_service_id;
                v_epa.FROM_DT := v_commercials_trade.from_date;
                v_epa.TO_DT := v_commercials_trade.to_date;
                v_epa.PEAK_UNITS  := v_commercials_trade.PEAK_UNITS;
                v_epa.OFF_PEAK_UNITS  :=v_commercials_trade.OFF_PEAK_UNITS;
                v_epa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                --Updating t_epa inside loop
                UPDATE T_EPA SET 
                FROM_DT=v_epa.FROM_DT, TO_DT =  v_epa.TO_DT,PEAK_UNITS= v_epa.PEAK_UNITS,OFF_PEAK_UNITS= v_epa.OFF_PEAK_UNITS,
                AGMT_PERIOD_CODE=v_epa.AGMT_PERIOD_CODE,APPROVED_TOTAL_UNITS=v_epa.APPROVED_TOTAL_UNITS,
                BUYER_COMP_SERV_ID=v_epa.BUYER_COMP_SERV_ID,IMPORT_REMARKS=v_epa.IMPORT_REMARKS
                WHERE id = v_epa.id;

                v_aggrement_epa.AGREEMENT_DATE := v_epa.FROM_DT;
                v_aggrement_epa.FROM_DATE := v_epa.FROM_DT;
                v_aggrement_epa.TO_DATE := v_epa.TO_DT;
                v_aggrement_epa.AGREEMENT_PERIOD_CODE := v_epa.AGMT_PERIOD_CODE;
                v_aggrement_epa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                --Updating agreement for epa
                UPDATE F_AGREEMENT SET 
                FROM_DATE=v_aggrement_epa.FROM_DATE, TO_DATE =  v_aggrement_epa.TO_DATE,AGREEMENT_PERIOD_CODE=v_aggrement_epa.AGREEMENT_PERIOD_CODE,
                AGREEMENT_DATE=v_aggrement_epa.FROM_DATE WHERE id = v_aggrement_epa.id;

                --Creating epa line
                v_epa_line.id := T_EPA_LINE_SEQ.nextval;
                v_epa_line.T_EPA_ID := v_epa.id;
                v_epa_line.ENABLED := 'Y';
                v_epa_line.CREATED_BY := 'admin';
                v_epa_line.CREATED_DT := sysdate;
                v_epa_line.PROPOSED_TOTAL_UNITS := v_commercials_trade.QUANTUM;
                v_epa_line.APPROVED_TOTAL_UNITS := v_commercials_trade.QUANTUM;
                v_epa_line.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                INSERT INTO T_EPA_LINES VALUES v_epa_line;

                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-203','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
                --Creating oaa
                v_oaa.id := t_oaa_seq.nextval;
                v_oaa.CODE := 'OAA'||v_oaa.id;
                v_oaa.BUYER_COMP_SERV_ID := v_buyer_company_service_id;
                v_oaa.BUYER_END_ORG_ID := v_buyer_org_id;
                v_oaa.AGMT_PERIOD_CODE := v_epa.AGMT_PERIOD_CODE;
                v_oaa.FROM_DT := v_commercials_trade.from_date;
                v_oaa.TO_DT:= v_commercials_trade.to_date;
                v_oaa.PROPOSED_TOTAL_UNITS:= v_commercials_trade.QUANTUM;
                v_oaa.APPROVED_TOTAL_UNITS:= v_commercials_trade.QUANTUM;
                v_oaa.SELLER_COMP_SERV_ID:=v_seller_company_service_id;
                v_oaa.SELLER_END_ORG_ID := v_seller_org_id;
                v_oaa.INJECTION_DIST_SS_ID:= v_company_service.M_SUBSTATION_ID;
                v_oaa.INJECTION_DIST_VOLTAGE_CODE :=  v_company_service.VOLTAGE_CODE;
                v_oaa.STATUS_CODE := 'COMPLETED';
                v_oaa.INTERVAL_TYPE_CODE := v_commercials_trade.INTERVAL_TYPE_CODE;
                v_oaa.C1_UNITS :=v_commercials_trade.C1;
                v_oaa.C2_UNITS :=v_commercials_trade.C2;
                v_oaa.C3_UNITS :=v_commercials_trade.C3;
                v_oaa.C4_UNITS :=v_commercials_trade.C4;
                v_oaa.C5_UNITS :=v_commercials_trade.C5;
                v_oaa.AGREEMENT_DT :=sysdate;
                v_oaa.PEAK_UNITS := v_commercials_trade.PEAK_UNITS;
                v_oaa.OFF_PEAK_UNITS :=v_commercials_trade.OFF_PEAK_UNITS;
                v_oaa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
                v_oaa.ENABLED := 'Y';
                v_oaa.created_by := 'admin';
                v_oaa.created_dt := sysdate;
                v_oaa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                INSERT INTO t_oaa VALUES v_oaa;

                --Creating agreement for oaa
                v_aggrement_oaa.id := F_AGREEMENT_SEQ.nextval;
                v_aggrement_oaa.CODE :=  'AGREEMENT'||v_aggrement_oaa.id;
                v_aggrement_oaa.T_OAA_ID := v_oaa.id;
                v_aggrement_oaa.BUYER_COMP_SERV_ID := v_oaa.BUYER_COMP_SERV_ID;
                v_aggrement_oaa.BUYER_EDC_ID := v_oaa.BUYER_END_ORG_ID;
                v_aggrement_oaa.AGREEMENT_PERIOD_CODE := v_oaa.AGMT_PERIOD_CODE;
                v_aggrement_oaa.FROM_DATE := v_oaa.FROM_DT;
                v_aggrement_oaa.TO_DATE:= v_oaa.TO_DT;
                v_aggrement_oaa.STATUS_CODE :='SIGNED';
                v_aggrement_oaa.SELLER_COMP_SERV_ID:=v_oaa.SELLER_COMP_SERV_ID;
                v_aggrement_oaa.INTERVAL_TYPE_CODE := v_oaa.INTERVAL_TYPE_CODE;
                v_aggrement_oaa.C1 :=v_oaa.C1_UNITS;
                v_aggrement_oaa.C2 :=v_oaa.C2_UNITS;
                v_aggrement_oaa.C3 :=v_oaa.C3_UNITS;
                v_aggrement_oaa.C4 :=v_oaa.C4_UNITS;
                v_aggrement_oaa.C5 :=v_oaa.C5_UNITS;
                v_aggrement_oaa.AGREEMENT_DATE :=v_oaa.AGREEMENT_DT;
                v_aggrement_oaa.PEAK_UNITS := v_oaa.PEAK_UNITS;
                v_aggrement_oaa.OFF_PEAK_UNITS :=v_oaa.OFF_PEAK_UNITS;
                v_aggrement_oaa.FLOW_TYPE :=v_oaa.FLOW_TYPE_CODE;
                v_aggrement_oaa.SELLER_COMPANY_ID := v_seller_company_id;
                v_aggrement_oaa.SELLER_EDC_ID := v_oaa.SELLER_END_ORG_ID;
                v_aggrement_oaa.IS_CAPTIVE := 'Y';
                v_aggrement_oaa.TOTAL_UNITS := v_oaa.PEAK_UNITS;
                v_aggrement_oaa.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;

                INSERT INTO F_AGREEMENT VALUES v_aggrement_oaa;

                v_m_trade_rel.ID := M_TRADE_RELATIONSHIP_SEQ.nextval;
                v_m_trade_rel.M_SELLER_COMPANY_ID := v_seller_company_id;
                v_m_trade_rel.M_SELLER_COMP_SERVICE_ID := v_seller_company_service_id;
                v_m_trade_rel.M_BUYER_COMPANY_ID := v_buyer_company_id;
                v_m_trade_rel.M_BUYER_COMP_SERVICE_ID := v_buyer_company_service_id;
                v_m_trade_rel.QUANTUM := v_commercials_trade.QUANTUM;
                v_m_trade_rel.FROM_DATE := v_commercials_trade.FROM_DATE;
                v_m_trade_rel.TO_DATE := v_commercials_trade.TO_DATE;
                v_m_trade_rel.C1 := v_commercials_trade.C1;
                v_m_trade_rel.C2 := v_commercials_trade.C2;
                v_m_trade_rel.C3 := v_commercials_trade.C3;
                v_m_trade_rel.C4 := v_commercials_trade.C4;
                v_m_trade_rel.C5 := v_commercials_trade.C5;
                v_m_trade_rel.IS_CAPTIVE := v_is_captive;
                v_m_trade_rel.FLOW_TYPE_CODE := v_flow_type_code;
                v_m_trade_rel.PEAK_UNITS := v_commercials_trade.PEAK_UNITS;
                v_m_trade_rel.OFF_PEAK_UNITS := v_commercials_trade.OFF_PEAK_UNITS;
                v_m_trade_rel.INTERVAL_TYPE_CODE := v_commercials_trade.INTERVAL_TYPE_CODE;
                v_m_trade_rel.SHARE_PERCENT := v_commercials_trade.SHARE_PERCENT; 
                v_m_trade_rel.IMPORT_REMARKS := v_commercials_trade.IMPORT_REMARKS;
                v_m_trade_rel.agreement_type := v_epa.AGMT_PERIOD_CODE ;
                v_m_trade_rel.enabled := 'Y' ;
                v_m_trade_rel.created_by := v_created_by ;
                v_m_trade_rel.created_date := sysdate ;


                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-203','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);

                INSERT INTO M_TRADE_RELATIONSHIP VALUES v_m_trade_rel;

                update M_TRADE_RELATIONSHIP set INTERVAL_TYPE_CODE='04' where INTERVAL_TYPE_CODE is null;

                Update IMPORT_TRADE_REL set remarks='COMPLETED' WHERE BUYER_COMPANY_SERVICE_NO=v_commercials_trade.BUYER_COMPANY_SERVICE_NO and SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS;
            EXCEPTION
            WHEN OTHERS THEN 
                v_exception_code := SQLCODE;
                v_exception_msg := SUBSTR(SQLERRM, 1, 200);
                v_result := 'FAILURE';
                v_result_desc := v_exception_code || ' - ' || v_exception_msg;
                -- dbms_output.put_line(v_result_desc);
                v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS','002-204','FOR SERVICE- '||V_SERVICE_NUMBER,'EXITING LOOP as one trade-relationship had error',v_created_by, sysdate,v_commercials_trade.BUYER_COMPANY_SERVICE_NO);
                Update IMPORT_TRADE_REL set remarks='FAILED', result=v_result, result_Desc=v_result_desc WHERE BUYER_COMPANY_SERVICE_NO=v_commercials_trade.BUYER_COMPANY_SERVICE_NO and SELLER_COMPANY_SERVICE_NO = V_SERVICE_NUMBER and IMPORT_REMARKS=V_REMARKS;

            end;            
        END LOOP;

    END IF;
    v_result := 'SUCCESS';
    v_result_desc := '';
EXCEPTION
    WHEN OTHERS THEN 
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
        -- dbms_output.put_line(v_result_desc);
END;
<<THE_END>>

v_log_result := log_activity('PROCEDURE','ADD_COMMERCIALS',v_result,v_result_code,v_result_desc,v_created_by, sysdate,V_SERVICE_NUMBER);
RETURN v_result;

END ADD_COMMERCIALS;

/
--------------------------------------------------------
--  DDL for Function ADJUST_ENERGY_SALE_AVAILABLE_UNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."ADJUST_ENERGY_SALE_AVAILABLE_UNITS" 
(
  i_energy_sale_id IN VARCHAR2 
) RETURN VARCHAR2 AS 

v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';

v_count number:=0;
v_es_usage_count number:=0;
v_energy_sale t_energy_sale%ROWTYPE;
v_gen_stmt_slot t_gen_stmt_slot%ROWTYPE;
v_gen_stmt_slot_cursor sys_refcursor;
v_gs_slot1_units number:=0; 
v_gs_slot2_units number:=0;
v_gs_slot3_units number:=0;
v_gs_slot4_units number:=0;
v_gs_slot5_units number:=0;
v_gs_slot1_bb number:=0;
v_gs_slot2_bb number:=0;
v_gs_slot3_bb number:=0;
v_gs_slot4_bb number:=0;
v_gs_slot5_bb number:=0;

v_c1_count number:=0;
v_c2_count number:=0;
v_c3_count number:=0;
v_c4_count number:=0;
v_c5_count number:=0;

--v_test_count number:=0;

v_excess_es1 VARCHAR2(300);
    v_excess_es VARCHAR2(300);


BEGIN

-- begin for exception handling
BEGIN

   v_log_result := log_activity('FUNCTION','ADJUST_ENERGY_SALE_AVAILABLE_UNITS','START','Start - '||i_energy_sale_id,'','', sysdate,i_energy_sale_id);

   select count(*) into v_count from t_energy_sale where  month='02' and year='2019' AND status_code='APPROVED' AND C1=0 AND C2=0 AND C3=0 AND C4=0 AND C5=0  and id=i_energy_sale_id ;

   if v_count=1 then
     select * into v_energy_sale from t_energy_sale where month='02' and year='2019' AND status_code='APPROVED' AND C1=0 AND C2=0 AND C3=0 AND C4=0 AND C5=0  and id=i_energy_sale_id  ;

         select count(*) into v_es_usage_count from T_ES_USAGE_SUMMARY where T_ENERGY_SALE_ID=i_energy_sale_id ;

         if v_es_usage_count>0 then

                   OPEN v_gen_stmt_slot_cursor for select * from t_gen_stmt_slot where t_gen_stmt_id=v_energy_sale.t_gen_stmt_id;
            LOOP
            FETCH v_gen_stmt_slot_cursor INTO v_gen_stmt_slot;
            EXIT WHEN v_gen_stmt_slot_cursor%NOTFOUND;
                if v_gen_stmt_slot.slot_code='C1' then
                    v_gs_slot1_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot1_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C2' then
                    v_gs_slot2_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot2_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C3' then
                    v_gs_slot3_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot3_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C4' then
                    v_gs_slot4_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot4_bb:=v_gen_stmt_slot.banked_balance; 
                end if;
                 if v_gen_stmt_slot.slot_code='C5' then
                    v_gs_slot5_units:=v_gen_stmt_slot.net_units;
                    v_gs_slot5_bb:=v_gen_stmt_slot.banked_balance; 
                end if;              
            END LOOP;
--v_test_count:=v_test_count+1;
--                   -- dbms_output.put_line('v_gs_slot1_units ==>'||v_gs_slot1_units);
--                   -- dbms_output.put_line('v_gs_slot2_units ==>'||v_gs_slot2_units);
--                   -- dbms_output.put_line('v_gs_slot3_units ==>'||v_gs_slot3_units);
--                   -- dbms_output.put_line('v_gs_slot4_units ==>'||v_gs_slot4_units);
--                   -- dbms_output.put_line('v_gs_slot5_units ==>'||v_gs_slot5_units);
--                      
--                   -- dbms_output.put_line('v_gs_slot1_bb ==>'||v_gs_slot1_bb);
--                   -- dbms_output.put_line('v_gs_slot2_bb ==>'||v_gs_slot2_bb);
--                   -- dbms_output.put_line('v_gs_slot3_bb ==>'||v_gs_slot3_bb);
--                   -- dbms_output.put_line('v_gs_slot4_bb ==>'||v_gs_slot4_bb);
--                   -- dbms_output.put_line('v_gs_slot5_bb ==>'||v_gs_slot5_bb);

             FOR summary IN ( select * from T_ES_USAGE_SUMMARY where T_ENERGY_SALE_ID=i_energy_sale_id)
                  LOOP
--                 -- dbms_output.put_line('summary.c1 ==>'||summary.c1);
                   v_c1_count := to_number(nvl(summary.c1,0)) + v_c1_count ;
                   v_c2_count := to_number(nvl(summary.c2,0)) + v_c2_count ;
                   v_c3_count := to_number(nvl(summary.c3,0)) + v_c3_count ;
                   v_c4_count := to_number(nvl(summary.c4,0)) + v_c4_count ;
                   v_c5_count := to_number(nvl(summary.c5,0)) + v_c5_count ;

                  END LOOP;
--                  -- dbms_output.put_line('v_c1_count ==>'||v_c1_count);
--                  -- dbms_output.put_line('v_c2_count ==>'||v_c2_count);
--                  -- dbms_output.put_line('v_c3_count ==>'||v_c3_count);
--                  -- dbms_output.put_line('v_c4_count ==>'||v_c4_count);
--                  -- dbms_output.put_line('v_c5_count ==>'||v_c5_count);


                if (v_c1_count > v_gs_slot1_units) then
                  v_energy_sale.gc1:=v_gs_slot1_units;
                  v_energy_sale.bc1:=v_c1_count-v_gs_slot1_units;
                  v_energy_sale.c1:=to_number(v_energy_sale.gc1)+to_number(v_energy_sale.bc1);
                else if (v_c1_count <=v_gs_slot1_units) then
                    v_energy_sale.gc1:=v_c1_count;
                    v_energy_sale.bc1:=0;
                    v_energy_sale.c1:=to_number(v_energy_sale.gc1)+to_number(v_energy_sale.bc1);
                  end if;                 
                end if;

                if (v_c2_count > v_gs_slot2_units) then
                  v_energy_sale.gc2:=v_gs_slot2_units;
                  v_energy_sale.bc2:=v_c2_count-v_gs_slot2_units;
                  v_energy_sale.c2:=to_number(v_energy_sale.gc2)+to_number(v_energy_sale.bc2);
                else if (v_c2_count <=v_gs_slot2_units) then
                    v_energy_sale.gc2:=v_c2_count;
                    v_energy_sale.bc2:=0;
                    v_energy_sale.c2:=to_number(v_energy_sale.gc2)+to_number(v_energy_sale.bc2);
                  end if;                 
                end if;

                if (v_c3_count > v_gs_slot3_units) then
                  v_energy_sale.gc3:=v_gs_slot3_units;
                  v_energy_sale.bc3:=v_c3_count-v_gs_slot3_units;
                  v_energy_sale.c3:=to_number(v_energy_sale.gc3)+to_number(v_energy_sale.bc3);
                else if (v_c3_count <=v_gs_slot3_units) then
                    v_energy_sale.gc3:=v_c3_count;
                    v_energy_sale.bc3:=0;
                    v_energy_sale.c3:=to_number(v_energy_sale.gc3)+to_number(v_energy_sale.bc3);
                  end if;                 
                end if;

                if (v_c4_count > v_gs_slot4_units) then
                  v_energy_sale.gc4:=v_gs_slot4_units;
                  v_energy_sale.bc4:=v_c4_count-v_gs_slot4_units;
                  v_energy_sale.c4:=to_number(v_energy_sale.gc4)+to_number(v_energy_sale.bc4);
                else if (v_c4_count <=v_gs_slot4_units) then
                    v_energy_sale.gc4:=v_c4_count;
                    v_energy_sale.bc4:=0;
                    v_energy_sale.c4:=to_number(v_energy_sale.gc4)+to_number(v_energy_sale.bc4);
                  end if;                 
                end if;

                if (v_c5_count > v_gs_slot5_units) then
                  v_energy_sale.gc5:=v_gs_slot5_units;
                  v_energy_sale.bc5:=v_c5_count-v_gs_slot5_units;
                  v_energy_sale.c5:=to_number(v_energy_sale.gc5)+to_number(v_energy_sale.bc5);
                else if (v_c5_count <=v_gs_slot5_units) then
                    v_energy_sale.gc5:=v_c5_count;
                    v_energy_sale.bc5:=0;
                    v_energy_sale.c5:=to_number(v_energy_sale.gc5)+to_number(v_energy_sale.bc5);
                  end if;                 
                end if;

                v_energy_sale.NET_GENERATION:=(to_number(v_energy_sale.gc1)+to_number(v_energy_sale.gc2)+to_number(v_energy_sale.gc3)+to_number(v_energy_sale.gc4)+to_number(v_energy_sale.gc5));
                v_energy_sale.TOTAL_BANK_UNITS_USED:=(to_number(v_energy_sale.bc1)+to_number(v_energy_sale.bc2)+to_number(v_energy_sale.bc3)+to_number(v_energy_sale.bc4)+to_number(v_energy_sale.bc5));
                v_energy_sale.NET_ALLOCATION:=(to_number(v_energy_sale.c1)+to_number(v_energy_sale.c2)+to_number(v_energy_sale.c3)+to_number(v_energy_sale.c4)+to_number(v_energy_sale.c5));
                update t_energy_sale set gc1=v_energy_sale.gc1,gc2=v_energy_sale.gc2,gc3=v_energy_sale.gc3,gc4=v_energy_sale.gc4,gc5=v_energy_sale.gc5, bc1=v_energy_sale.bc1,bc2=v_energy_sale.bc2,bc3=v_energy_sale.bc3,bc4=v_energy_sale.bc4,bc5=v_energy_sale.bc5,
                c1=v_energy_sale.c1,c2=v_energy_sale.c2,c3=v_energy_sale.c3,c4=v_energy_sale.c4,c5=v_energy_sale.c5,NET_GENERATION=v_energy_sale.NET_GENERATION,TOTAL_BANK_UNITS_USED=v_energy_sale.TOTAL_BANK_UNITS_USED,NET_ALLOCATION= v_energy_sale.NET_ALLOCATION
                where id=i_energy_sale_id;



                 update F_ENERGY_SALE_ORDER set total_gc1=v_energy_sale.gc1,total_gc2=v_energy_sale.gc2,total_gc3=v_energy_sale.gc3,total_gc4=v_energy_sale.gc4,total_gc5=v_energy_sale.gc5, total_bc1=v_energy_sale.bc1,total_bc2=v_energy_sale.bc2,total_bc3=v_energy_sale.bc3,total_bc4=v_energy_sale.bc4,total_bc5=v_energy_sale.bc5,
                total_c1=v_energy_sale.c1,total_c2=v_energy_sale.c2,total_c3=v_energy_sale.c3,total_c4=v_energy_sale.c4,total_c5=v_energy_sale.c5,TOTAL_GEN_UNITS_SOLD=v_energy_sale.NET_GENERATION,TOTAL_BANKING_UNITS_SOLD=v_energy_sale.TOTAL_BANK_UNITS_USED,TOTAL_UNITS_SOLD= v_energy_sale.NET_ALLOCATION
                where T_ENERGY_SALE_ID=i_energy_sale_id;
                BANKING_BALANCE.confirm_energy_sale_event(i_energy_sale_id,v_excess_es,v_excess_es1);
--                 -- dbms_output.put_line('v_energy_sale.gc1 ==>'||v_energy_sale.gc1 ||'--v_energy_sale.bc1 ==>'||v_energy_sale.bc1 ||'--v_energy_sale.c1 ==>'||v_energy_sale.c1);
--                 -- dbms_output.put_line('v_energy_sale.gc2 ==>'||v_energy_sale.gc2 ||'--v_energy_sale.bc2 ==>'||v_energy_sale.bc2 ||'--v_energy_sale.c2 ==>'||v_energy_sale.c2);
--                 -- dbms_output.put_line('v_energy_sale.gc3 ==>'||v_energy_sale.gc3 ||'--v_energy_sale.bc3 ==>'||v_energy_sale.bc3 ||'--v_energy_sale.c3 ==>'||v_energy_sale.c3);
--                 -- dbms_output.put_line('v_energy_sale.gc4 ==>'||v_energy_sale.gc4 ||'--v_energy_sale.bc4 ==>'||v_energy_sale.bc4 ||'--v_energy_sale.c4 ==>'||v_energy_sale.c4);
--                 -- dbms_output.put_line('v_energy_sale.gc5 ==>'||v_energy_sale.gc5 ||'--v_energy_sale.bc5 ==>'||v_energy_sale.bc5 ||'--v_energy_sale.c5 ==>'||v_energy_sale.c5);
--                 -- dbms_output.put_line('v_net_generation==>'||v_energy_sale.net_generation);
--                 -- dbms_output.put_line('v_total_banked_units==>'||v_energy_sale.TOTAL_BANK_UNITS_USED);
--                 -- dbms_output.put_line('v_net_allocation==>'||v_energy_sale.net_allocation);

         else
            v_log_result := log_activity('FUNCTION','Energy Sale does not exist','ADJUST_ENERGY_SALE_AVAILABLE_UNITS','no data found','error_records -','', sysdate,i_energy_sale_id);
            V_RESULT:= 'FAILURE';
            v_reason := 'no data found';
           end if;

   else
     v_log_result := log_activity('FUNCTION','Energy Sale does not exist','ADJUST_ENERGY_SALE_AVAILABLE_UNITS','no data found','error_records -','', sysdate,i_energy_sale_id);
    V_RESULT:= 'FAILURE';
    v_reason := 'no data found';
   end if;

END;
v_log_result := log_activity('FUNCTION','ADJUST_ENERGY_SALE_AVAILABLE_UNITS','END','','','', sysdate,i_energy_sale_id);


return V_RESULT || ' - ' || v_reason;

END ADJUST_ENERGY_SALE_AVAILABLE_UNITS;


/
--------------------------------------------------------
--  DDL for Function BK_TO_UPDATE_BB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."BK_TO_UPDATE_BB" RETURN VARCHAR2 AS 
v_bb_cur sys_refcursor ;
v_service_number varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count number;
v_bb t_banking_balance%ROWTYPE;
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
BEGIN

      FOR line IN ( select m_company_id from v_company_service where id in(select SELLER_COMP_SERV_ID from T_ENERGY_SALE where  month='02' and year='2019' AND status_code='APPROVED' AND C1=0 AND C2=0 AND C3=0 AND C4=0 AND C5=0 and is_stb='N'))
                  LOOP

                  update T_BANKING_BALANCE set CURR_C1=c1,CURR_C2=c2,CURR_C3=c3,CURR_C4=c4,CURR_C5=c5 where m_company_id= line.m_company_id and month='02' and year='2019';

                  END LOOP;

 RETURN 'success';
END BK_TO_UPDATE_BB;


/
--------------------------------------------------------
--  DDL for Function BK_TO_UPDATE_CURC1
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."BK_TO_UPDATE_CURC1" RETURN VARCHAR2 AS 
v_voltage_cur sys_refcursor ;
v_service_number varchar2(50);
serNo varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count varchar2(50);
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
BEGIN

  OPEN v_voltage_cur FOR SELECT SERVICE_NO FROM BK_UPD_CURVALUES;
  LOOP
  FETCH v_voltage_cur INTO v_service_number;
  SELECT COUNT(*) INTO master_service_count FROM M_COMPANY_SERVICE WHERE "number"=v_service_number;
  -- dbms_output.put_line('v_service_number '||v_service_number);
  -- dbms_output.put_line('master_service_count '||master_service_count);
  IF(master_service_count>0)THEN
  SELECT M_COMPANY_ID,banking_service_id INTO v_comp_id,v_banking_service_id FROM M_COMPANY_SERVICE WHERE "number"=v_service_number  fetch first 1 rows only;
  SELECT C1,C2,C3,C4,C5 INTO v_c1,v_c2,v_c3,v_c4,v_c5 FROM BK_UPD_CURVALUES WHERE SERVICE_NO=v_service_number  fetch first 1 rows only;
  select count(*) into v_bb_count from T_BANKING_BALANCE WHERE M_COMPANY_ID=v_comp_id;
  -- dbms_output.put_line('v_bb_count '||v_bb_count);
  if(v_bb_count >0) then
   ---UPDATE T_BANKING_BALANCE SET CURR_C1=nvl(curr_c1,0)+v_c1,CURR_C2=nvl(curr_c2,0)+v_c2,CURR_C3=nvl(curr_c3,0)+v_c3,CURR_C4=nvl(curr_c4,0)+v_c4,CURR_C5=nvl(curr_c5,0)+v_c5 WHERE banking_service_id=v_banking_service_id and MONTH=v_month and YEAR = v_year;
    UPDATE T_BANKING_BALANCE SET CURR_C1=v_c1,CURR_C2=v_c2,CURR_C3=v_c3,CURR_C4=v_c4,CURR_C5=v_c5 WHERE banking_service_id=v_banking_service_id and MONTH=v_month and YEAR = v_year;
  else
    insert into t_banking_balance (id, remarks, MONTH, YEAR,C1,C2,C3,C4,C5,CREATED_BY,CREATED_DT, ENABLED,M_COMPANY_ID, BANKING_SERVICE_ID,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CALCULATED)
        (SELECT T_BANKING_BALANCE_SEQ.nextval ID, 'BK_TO_UPDATE_CURC1', v_month, v_year,v_c1,v_c2,v_c3,v_c4,v_c5,'admin',sysdate, 'Y',v_comp_id, v_banking_service_id,v_c1,v_c2,v_c3,v_c4,v_c5,'N'
          FROM dual
        );
   end if;

  END IF;
  EXIT WHEN v_voltage_cur%NOTFOUND;
  END LOOP;
  COMMIT;
 RETURN 'success';
END BK_TO_UPDATE_CURC1;


/
--------------------------------------------------------
--  DDL for Function BK_TO_UPDATE_FEB_OPENING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."BK_TO_UPDATE_FEB_OPENING" RETURN VARCHAR2 AS 
v_bb_cur sys_refcursor ;
v_service_number varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count number;
v_bb t_banking_balance%ROWTYPE;
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
BEGIN

      FOR line IN (select m_company_id from bk_banking_closing)
                  LOOP

                  update T_BANKING_BALANCE set CURR_C1=c1,CURR_C2=c2,CURR_C3=c3,CURR_C4=c4,CURR_C5=c5 where m_company_id= line.m_company_id and month='02' and year='2019';

                  END LOOP;

 RETURN 'success';
END BK_TO_UPDATE_FEB_OPENING;


/
--------------------------------------------------------
--  DDL for Function BK_TO_UPDATE_SAME_BB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."BK_TO_UPDATE_SAME_BB" RETURN VARCHAR2 AS 
v_bb_cur sys_refcursor ;
v_service_number varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count number;
v_bb t_banking_balance%ROWTYPE;
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
BEGIN

      FOR line IN ( select m_company_id from v_company_service where m_company_id in
(select m_company_id from t_banking_balance where curr_c1=curr_c2 and curr_c1=curr_c3 and curr_c1=curr_c4 and curr_c1=curr_c5 and curr_c1!=0 and month='02'))
                  LOOP

                  update T_BANKING_BALANCE set CURR_C1=c1,CURR_C2=c2,CURR_C3=c3,CURR_C4=c4,CURR_C5=c5 where m_company_id= line.m_company_id and month='02' and year='2019';

                  END LOOP;

 RETURN 'success';
END BK_TO_UPDATE_SAME_BB;


/
--------------------------------------------------------
--  DDL for Function CALC_CHARGES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALC_CHARGES" (
    V_CHARGE_CODE IN VARCHAR2 ,
    PARAM1        IN VARCHAR2 ,
    PARAM2        IN VARCHAR2 ,
    PARAM3        IN VARCHAR2 )
  RETURN NUMBER
AS
  v_evaluated      NUMBER;
  v_id             NUMBER;
  v_formula        VARCHAR2(150);
  v_charge_type    VARCHAR2(150);
  v_unit_charge    VARCHAR2(150);
  v_result varchar(300):='SUCCESS';
  v_log_result varchar(300):='SUCCESS';
  v_exception_code VARCHAR2(150);
  v_exception_msg  VARCHAR2(150);
  v_reason VARCHAR2(300);
BEGIN
  BEGIN
    SELECT charge_type_code,unit_charge,formula INTO v_charge_type,v_unit_charge,v_formula FROM M_CHARGE_DEFN WHERE CHARGE_CODE = V_CHARGE_CODE;

    IF(TRIM(v_charge_type) = 'FORMULA')THEN
      IF(PARAM1   IS NOT NULL AND v_formula LIKE '%{$1}%')THEN
        v_formula := REPLACE(v_formula,'{$1}',PARAM1);
      END IF;
      IF(PARAM2   IS NOT NULL AND v_formula LIKE '%{$2}%')THEN
        v_formula := REPLACE(v_formula,'{$2}',PARAM2);
      END IF;
      IF(PARAM3   IS NOT NULL AND v_formula LIKE '%{$3}%')THEN
        v_formula := REPLACE(v_formula,'{$3}',PARAM3);
      END IF;
      EXECUTE immediate 'select '||v_formula||' from dual' INTO v_evaluated;
    ELSIF(TRIM(v_charge_type) = 'LUMP_SUM') THEN
      v_evaluated      := v_unit_charge;
    ELSE
      v_evaluated := v_unit_charge*PARAM1;
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
    v_result := 'FAILURE';
    v_reason := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','CALC_CHARGES','EH','Isse in CALC_CHARGES - '||v_reason,V_CHARGE_CODE,'admin', sysdate,PARAM1,PARAM2,PARAM3);
    --SELECT nvl(max(id),0) into v_id  FROM error_table;
    --INSERT INTO ERROR_TABLE  VALUES (v_id,'DB-CALC_CHARGES', v_exception_code || ' - ' || v_exception_msg ,'');


  END;
RETURN v_evaluated;
END CALC_CHARGES;


/
--------------------------------------------------------
--  DDL for Function CALC_ES_CHARGES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALC_ES_CHARGES" (
    v_es_id IN VARCHAR2 )
  RETURN VARCHAR2
AS
  v_is_fossil_fuel boolean := true;
  v_gs_id        VARCHAR2(150);
  v_seller_comp_serv_id VARCHAR2(150);
  v_adjstd_customers number;
  v_evaluated      NUMBER;
  v_id             NUMBER;
  v_no_of_days number:=0;
  v_machine_capacity number:=0;
  v_penalty_rate number:=0;
  v_rkvah_inits number:=0;
  v_total_charges number:=0;
  v_grand_total_charges number:=0;
  v_formula        VARCHAR2(150);
  v_charge_type    VARCHAR2(150);
  v_unit_charge    VARCHAR2(150);
  v_charge         VARCHAR2(150);
  v_fuel_type_Code VARCHAR2(50);
  v_charge_percentage NUMBER:=0;
  v_net_generation VARCHAR2(150);
  v_result varchar(300):='SUCCESS';
  v_log_result varchar(300):='SUCCESS';
  v_exception_code VARCHAR2(150);
  v_exception_msg  VARCHAR2(150);
  v_reason VARCHAR2(300);
  v_month VARCHAR2(20);   v_year VARCHAR2(20); v_c008total_charges number;
  v_other_charges_count number;

BEGIN
  BEGIN

    select es.T_GEN_STMT_ID, es.SELLER_COMP_SERV_ID, count(t_energy_sale_id) into v_gs_id,v_seller_comp_serv_id, v_adjstd_customers from T_ES_USAGE_SUMMARY eus inner join t_energy_sale es on eus.t_energy_sale_id = es.id
    where t_energy_sale_id = v_es_id
    group by t_energy_sale_id, es.T_GEN_STMT_ID,es.SELLER_COMP_SERV_ID ;

	  SELECT gs.machine_capacity, (gs.FINAL_STMT_DT - gs.INIT_STMT_DT)+1 no_of_days, gs.penalty_rate, gs.RKVAH_UNITS ,gs.NET_GENERATION, gs.disp_fuel_type_Code,gs.stmt_month,gs.stmt_year
    INTO v_machine_capacity,v_no_of_days,v_penalty_rate, v_rkvah_inits,v_net_generation, v_fuel_type_Code,v_month,v_year
    FROM T_GEN_STMT gs where id = v_gs_id;
--           -- dbms_output.put_line(v_seller_comp_serv_id);

-- For gen other charges
    select count(*) into v_other_charges_count from T_GEN_OTHER_CHARGES where M_COMPANY_SERVICE_ID=v_seller_comp_serv_id and month=v_month and year=v_year and CHARGE_CODE='C008';

    	if(v_fuel_type_Code = '02') then
            v_charge_percentage:= 50;
        ELSIF(v_fuel_type_Code = '18') THEN
            v_charge_percentage:= 40;
        else
            v_charge_percentage:= 100;
        end if;

    if(v_fuel_type_Code = '03' or v_fuel_type_Code = '04') then
          -- non-fossil fuels
       v_is_fossil_fuel:=false;
    else
      v_is_fossil_fuel := true;
    end if;

--               -- dbms_output.put_line('2');


		FOR meter IN (SELECT CHARGE_CODE, CHARGE_DESC, CHARGE_TYPE_CODE, UNIT_CHARGE FROM M_CHARGE_defn d JOIN  M_CHARGES_MAP m ON d.id = m.M_CHARGE_ID AND CONTEXT = 'GENERATOR_STATEMENT' )
		LOOP
      BEGIN
        if(meter.charge_code = 'C001') then
          if(v_is_fossil_fuel) then
            continue; -- No meter reading charges
          else
            v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,'','',''));
          end if;
        ELSIF(meter.charge_code = 'C002') then
             v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,v_machine_capacity,v_no_of_days,''));
        ELSIF(meter.charge_code = 'C003') then
            v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,v_machine_capacity,v_no_of_days,''));
        ELSIF(meter.charge_code = 'C004') then
            v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,v_machine_capacity,v_no_of_days,''));
        ELSIF(meter.charge_code = 'C005') then
          if(v_is_fossil_fuel) then
              continue; --  No rkvah penalty
            else
              IF((to_number(v_net_generation)*0.1)>=v_rkvah_inits) then
                  v_penalty_rate:= 0.25;
              ELSE
                  v_penalty_rate:=0.5;
              end if;
--           -- dbms_output.put_line('4');

              v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,v_penalty_rate,v_rkvah_inits,''));
            end if;
        ELSIF(meter.charge_code = 'C006') then
          if(v_is_fossil_fuel) then
            continue; -- No negative charges
          else
            v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,v_charge,v_net_generation,''));
          end if;
        ELSIF(meter.charge_code = 'C007') then
          if(v_is_fossil_fuel) then
            v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,'160',v_no_of_days,v_adjstd_customers));
--                       -- dbms_output.put_line('4');

--   for gen other charges                    
    if v_other_charges_count=1 then
        select to_number(TOTAL_CHARGES) into v_c008total_charges from t_gen_other_charges where M_COMPANY_SERVICE_ID=v_seller_comp_serv_id and month=v_month and year=v_year and CHARGE_CODE='C008';

        IF (meter.charge_code = 'C008') then
        v_total_charges:= v_c008total_charges;
        END IF;

    end if;


          else
            v_total_charges:= to_number(CALC_CHARGES(meter.charge_code,v_no_of_days,'',''));
          end if;
        else
          continue;
        end if;
        v_total_charges := ROUND(v_total_charges * v_charge_percentage/100);
--                   -- dbms_output.put_line('5');



        INSERT INTO  T_ES_CHARGE
        (ID, T_ENERGY_SALE_ID, M_COMP_SERV_ID,CHARGE_CODE, TOTAL_CHARGE)
        VALUES(T_ES_CHARGE_SEQ.nextval, v_es_id, v_seller_comp_serv_id, meter.charge_code, v_total_charges);

        v_grand_total_charges :=v_grand_total_charges+v_total_charges;
      EXCEPTION
      WHEN OTHERS THEN
        v_exception_code := SQLCODE;
        v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
        v_result := 'FAILURE';
        v_reason := v_exception_code || ' - ' || v_exception_msg;
        v_log_result := log_activity('PROCEDURE','CALC_ES_CHARGES','EH-LOOP','Error while processing charge ('||meter.charge_code ||')- '||v_reason,v_result,'admin', sysdate,v_gs_id);
      END;

    END LOOP;

      update t_energy_sale set net_charges_allocated = v_grand_total_charges where id = v_es_id;

  EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
    v_result := 'FAILURE';
    v_reason := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','CALC_GS_CHARGES','EH','Isse in CALC_ES_CHARGES - '||v_reason,v_result,'admin', sysdate,v_es_id);
    --SELECT nvl(max(id),0) into v_id  FROM error_table;
    --INSERT INTO ERROR_TABLE  VALUES (v_id,'DB-CALC_CHARGES', v_exception_code || ' - ' || v_exception_msg ,'');
  END;
RETURN v_result;
END CALC_ES_CHARGES;

/
--------------------------------------------------------
--  DDL for Function CALC_GS_CHARGES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALC_GS_CHARGES" (
    v_gs_id IN VARCHAR2
) RETURN VARCHAR2 AS

    v_flow_type_code        VARCHAR2(150);
    v_is_stb                VARCHAR2(150);
    v_evaluated             NUMBER;
    v_id                    NUMBER;
    v_no_of_days            NUMBER := 0;
    v_machine_capacity      NUMBER := 0;
    v_penalty_rate          NUMBER := 0;
    v_rkvah_inits           NUMBER := 0;
    v_total_charges         NUMBER := 0;
    v_grand_total_charges   NUMBER := 0;
    v_formula               VARCHAR2(150);
    v_charge_type           VARCHAR2(150);
    v_unit_charge           VARCHAR2(150);
    v_charge_code           VARCHAR2(150);
    v_charge                VARCHAR2(150) := '0';
    v_fuel_group             VARCHAR2(50);
    v_fuel_type_code        VARCHAR2(50);
    v_charge_percentage     NUMBER := 0;
    v_net_generation        VARCHAR2(150);
    v_result                VARCHAR(300) := 'SUCCESS';
    v_log_result            VARCHAR(300) := 'SUCCESS';
    v_exception_code        VARCHAR2(150);
    v_exception_msg         VARCHAR2(150);
    v_reason                VARCHAR2(300);
    v_cal                   NUMBER := 0;
    v_gen_iscaptive         VARCHAR2(50);
    v_gen_isstb_count       NUMBER;
    v_gen_sstype            VARCHAR2(50);
    v_is_rec                VARCHAR2(50);
    v_source_code           VARCHAR2(50);
    v_other_charges_count   NUMBER;
    v_service_id            VARCHAR2(50);
    v_month                 VARCHAR2(20);
    v_year                  VARCHAR2(20);
    v_c008total_charges     NUMBER;
BEGIN
    BEGIN
        v_log_result := log_activity('PROCEDURE', 'CALC_GS_CHARGES', 'START', 'Start - ', '', '', SYSDATE, '');

        SELECT gs.machine_capacity, ( gs.final_stmt_dt - gs.init_stmt_dt ) + 1 no_of_days, gs.penalty_rate, gs.rkvah_units, gs.net_generation, gs.disp_fuel_type_code, nvl(gs.is_stb, ''),
            gs.type_of_ss, gs.is_rec, gs.stmt_month, gs.stmt_year, gs.m_company_service_id, gs.mr_source_code, disp_fuel_type_group
        INTO
            v_machine_capacity, v_no_of_days, v_penalty_rate, v_rkvah_inits, v_net_generation, v_fuel_type_code, v_is_stb, v_gen_sstype, v_is_rec, v_month, v_year, v_service_id, v_source_code, v_fuel_group
        FROM t_gen_stmt gs WHERE id = v_gs_id;

        SELECT flow_type_code INTO v_flow_type_code FROM m_company_service WHERE id = v_service_id;

        IF ( v_flow_type_code = 'IS_CAPTIVE' ) THEN
            v_gen_iscaptive := 'Y';
        ELSE
            v_gen_iscaptive := 'N';
        END IF;

--    SELECT companygs.IS_CAPTIVE INTO v_gen_iscaptive FROM V_COMPANY_SERVICE companygs
--
--    LEFT JOIN T_GEN_STMT gengs ON companygs.M_COMPANY_ID = gengs.M_COMPANY_ID AND companygs.IS_CAPTIVE='Y' WHERE gengs.ID=v_gs_id;

        -- -- dbms_output.put_line('v_gen_iscaptive-' || v_gen_iscaptive);
        SELECT COUNT(compgs.is_captive) INTO v_gen_isstb_count FROM v_company_service compgs LEFT JOIN t_gen_stmt stbgs ON compgs.id = stbgs.m_company_service_id AND compgs.is_stb = 'Y'
        WHERE stbgs.id = v_gs_id;

        -- -- dbms_output.put_line('v_gen_isstb_count-' || v_gen_isstb_count);
        v_log_result := log_activity('PROCEDURE', 'CALC_GS_CHARGES', 'In Progress', 'v_gen_iscaptive - ' || v_gen_iscaptive, 'v_gen_isstb_count-'|| v_gen_isstb_count, '', SYSDATE, '');

        SELECT service.type_of_ss INTO v_gen_sstype FROM v_company_service service LEFT JOIN t_gen_stmt gengs3 ON service.id = gengs3.m_company_service_id WHERE gengs3.id = v_gs_id;

        -- -- dbms_output.put_line('v_gen_sstype-' || v_gen_sstype);
        v_log_result := log_activity('PROCEDURE', 'CALC_GS_CHARGES', 'In Progress', 'v_gen_sstype - ' || v_gen_sstype, '', '', SYSDATE, '');

        -- For gen other charges

        SELECT COUNT(*) INTO v_other_charges_count FROM t_gen_other_charges
        WHERE m_company_service_id = v_service_id AND month = v_month AND year = v_year AND charge_code = 'C008';

        IF ( v_gen_isstb_count ) > 0 THEN
            v_is_stb := 'Y';
        ELSE
            v_is_stb := 'N';
        END IF;

        IF ( v_gen_sstype = 'SECTION 10(1)SS' ) THEN
            v_gen_sstype := 'Y';
        ELSE
            v_gen_sstype := 'N';
        END IF;

        IF ( v_is_stb = 'Y' ) THEN
            v_is_stb := 'Y';
        ELSE
            v_is_stb := 'N';
        END IF;

        FOR charge IN (SELECT charge_code, charge_desc, charge_type_code, unit_charge, ff FROM v_charge where context = 'GENERATOR_STATEMENT') 
        LOOP
            BEGIN
                v_charge_code := charge.charge_code;

                if(v_fuel_group='FF') then
                    if(charge.ff='04') then 
                        -- TODO - logic to calculate charge for whole year and add to charges
                        continue;
                    ELSIF(charge.ff='N') then 
                        continue;
                    end if;
                end if;
--              v_log_result := log_activity('PROCEDURE','CALC_GS_CHARGES','v_charge_code','v_charge_code - ',v_charge_code,'', sysdate,'');
--              -- dbms_output.put_line('  v_charge_code  - '||  v_charge_code );
                IF ( v_charge_code IN ('C001','C002','C005','C006') OR v_is_rec = 'Y' ) THEN
                    v_charge_percentage := 100;
                ELSIF ( v_is_rec = 'N' AND v_fuel_type_code = 'WIND' ) THEN
                    v_charge_percentage := 50;
                ELSIF ( v_fuel_type_code = 'SOLAR' ) THEN
                    v_log_result := log_activity('PROCEDURE', 'CALC_GS_CHARGES', 'CHARGE_PERCENTAGE', 'FUEL_TYPE- '|| v_fuel_type_code|| '-IS_rEC-'|| v_is_rec, '', 'admin', SYSDATE, v_gs_id);

                    IF v_is_rec = 'N' THEN
                        v_charge_percentage := 50;
                    ELSIF v_is_rec = 'Y' THEN
                        v_charge_percentage := 100;
                    END IF;

--         elsif(v_is_rec = 'Y' and v_fuel_type_Code = '18') THEN
--
--            v_charge_percentage:= 100;

                ELSE
                    v_charge_percentage := 100;
                END IF;

                IF ( v_charge_code = 'C001' ) THEN
                    IF ( v_source_code = '02' OR v_source_code = '03' ) THEN
                        v_total_charges := ceil(to_number(calc_charges(v_charge_code, '', '', '')));
                        v_total_charges := ceil(to_number(300 + v_total_charges));
                        --   -- dbms_output.put_line('meter reading charges manual--');
                    ELSE
                        v_total_charges := ceil(to_number(calc_charges(v_charge_code, '', '', '')));
                        --      -- dbms_output.put_line('meter reading charges AMR--');
                    END IF;
                ELSIF ( v_charge_code = 'C002' ) THEN
                    IF ( v_gen_sstype = 'Y' OR v_fuel_type_code = 'SOLAR' ) THEN
                         ---- dbms_output.put_line('No o&M charges  for 10(1) ss');
                        CONTINUE; --  No o&M charges  for 10(1) ss
                    ELSE
                        v_total_charges := ceil(to_number(calc_charges(charge.charge_code, v_machine_capacity, v_no_of_days, '')));
                    END IF;
                ELSIF ( v_charge_code = 'C003' ) THEN
                    IF ( v_is_stb = 'Y' ) THEN
                        CONTINUE; --  No transmission charges for stb
                    ELSE
                        v_total_charges := ceil(to_number(calc_charges(v_charge_code, v_machine_capacity, v_no_of_days, '')));
                    END IF;
                ELSIF ( v_charge_code = 'C004' ) THEN
                    IF ( v_is_stb = 'Y' ) THEN
                        CONTINUE; --  No transmission charges for stb
                    ELSE
                        v_total_charges := ceil(to_number(calc_charges(v_charge_code, v_machine_capacity, v_no_of_days, '')));
                    END IF;
                ELSIF ( v_charge_code = 'C005' ) THEN
                    IF ( v_fuel_type_code = 'WIND' ) THEN
                        IF ( ( to_number(v_net_generation) * 0.1 ) >= v_rkvah_inits ) THEN
                            v_penalty_rate := 0.25;
                        ELSE
                            v_penalty_rate := 0.5;
                        END IF;
                    ELSIF ( v_fuel_type_code = 'SOLAR' ) THEN
                        v_penalty_rate := 0.155;
                    END IF;

                    v_total_charges := ceil(to_number(calc_charges(v_charge_code, v_penalty_rate, v_rkvah_inits, '')));

                    IF ( v_total_charges < 0 ) THEN
                        v_total_charges := 0;
                    ELSE
                        v_total_charges := v_total_charges;
                    END IF;

                ELSIF ( v_charge_code = 'C006' ) THEN
                    v_total_charges := ceil(to_number(calc_negative_charges(v_gs_id)));
--          -- dbms_output.put_line(' v_total_charges'|| v_total_charges);
                ELSIF ( v_charge_code = 'C007' ) THEN
                    IF ( v_is_stb = 'Y' ) THEN
                        CONTINUE; --  No transmission charges for stb
                    ELSE
                        v_total_charges := ceil(to_number(calc_charges(v_charge_code, v_no_of_days, '', '')));
                    END IF;

--    if v_other_charges_count=1 then
--        select to_number(TOTAL_CHARGES) into v_c008total_charges from t_gen_other_charges where M_COMPANY_SERVICE_ID=v_service_id and month=v_month and year=v_year and CHARGE_CODE='C008';
--        IF (v_charge_code = 'C008') then
--        v_total_charges:= v_c008total_charges;
--        END IF;  
--    end if;
                ELSIF ( v_charge_code = 'C008' ) THEN
--         v_log_result := log_activity('PROCEDURE','CALC_GS_CHARGES','v_charge_code','v_charge_code - ',v_charge_code,'', sysdate,'');
--          -- dbms_output.put_line('  v_charge_code  - '||  v_charge_code );
                    IF v_other_charges_count = 1 THEN
                        SELECT to_number(total_charges) INTO v_c008total_charges FROM t_gen_other_charges WHERE m_company_service_id = v_service_id AND month = v_month AND year = v_year AND charge_code = 'C008';
                        v_total_charges := v_c008total_charges;
--             v_log_result := log_activity('PROCEDURE','CALC_GS_CHARGES','v_total_charges','v_total_charges - ',v_total_charges,'', sysdate,'');
                    ELSE
                        v_total_charges := 0;
                    END IF;
--       ELSIF(v_charge_code='C009')  then
--          v_total_charges:= CEIL(to_number(CALC_CHARGES(v_charge_code,v_machine_capacity,'','')));
                ELSE
                    CONTINUE;
                END IF;

                IF v_charge_code != 'C008' THEN
                    v_total_charges := ceil(v_total_charges * v_charge_percentage / 100);
                END IF;

--         thermal charges update       
              if(v_fuel_group='FF') then
              IF ( v_charge_code = 'C003' ) THEN
                        v_total_charges := 0;
                         END IF;
              IF ( v_charge_code = 'C004' ) THEN
                        v_total_charges := 0;
                         END IF;            
                 IF ( v_charge_code = 'C007' ) THEN
                        v_total_charges := 0;
                         END IF;
                         IF ( v_charge_code = 'C008' ) THEN
                        v_total_charges := 0;
                         END IF;
                   end if;  
    --  -- dbms_output.put_line('  v_total_charges  - '||  v_total_charges );

                INSERT INTO t_gen_stmt_charge ( id, t_gen_stmt_id, charge_code, charge_desc, charge_type_code, unit_charge, total_charges ) VALUES (
                    t_gen_stmt_charge_seq.NEXTVAL, v_gs_id, charge.charge_code, charge.charge_desc, charge.charge_type_code, charge.unit_charge,v_total_charges);

                v_grand_total_charges := ceil((v_grand_total_charges + nvl(v_total_charges, 0)));
--        -- dbms_output.put_line(' v_grand_total_charges - '|| v_grand_total_charges);
            EXCEPTION
                WHEN OTHERS THEN
                    v_exception_code := sqlcode;
                    v_exception_msg := substr(sqlerrm, 1, 100);
                    v_result := 'FAILURE';
                    v_reason := v_exception_code || ' - '|| v_exception_msg;
                    v_log_result := log_activity('PROCEDURE', 'CALC_GS_CHARGES', 'EH-LOOP', 'Error while processing charge ('|| v_charge_code|| ')- '|| v_reason, v_result, 'admin', SYSDATE, v_gs_id);

            END;

            v_reason := 'SUCCESS'; -- resetting loop result
        END LOOP;

        UPDATE t_gen_stmt
        SET
            total_charged_amount = v_grand_total_charges
        WHERE
            id = v_gs_id;

    EXCEPTION
        WHEN OTHERS THEN
            v_exception_code := sqlcode;
            v_exception_msg := substr(sqlerrm, 1, 100);
            v_result := 'FAILURE';
            v_reason := v_exception_code|| ' - '|| v_exception_msg;
            v_log_result := log_activity('PROCEDURE', 'CALC_GS_CHARGES', 'EH', 'Issue in CALC_GS_CHARGES - ' || v_reason, v_result, 'admin', SYSDATE, v_gs_id);

    END;

    RETURN v_result;
END calc_gs_charges;

/
--------------------------------------------------------
--  DDL for Function CALC_NEGATIVE_CHARGES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALC_NEGATIVE_CHARGES" (
    v_gs_id IN VARCHAR2 )
  RETURN VARCHAR2
  
  AS
    v_result varchar2(300);
 	v_reason VARCHAR2(300);
    v_total_exp_gen varchar2(300);
 	v_total_imp_gen varchar2(300);
	v_diff_total_gen varchar(300);
	v_c1_units varchar(300);
	v_c2_units varchar(300);
	v_c3_units varchar(300);
	v_c4_units varchar(300);
	v_c5_units varchar(300);
  v_c5_units_tax varchar(300);
  v_log_result varchar(300):='SUCCESS';
  v_exception_code VARCHAR2(150);
  v_exception_msg  VARCHAR2(150);
  v_slot_code VARCHAR(300);

  v_tax NUMBER;
BEGIN	
  BEGIN 
	SELECT gs.TOTAL_EXPORT_GEN INTO v_total_exp_gen FROM T_GEN_STMT gs WHERE gs.ID= v_gs_id ;
 	SELECT gs.TOTAL_IMPORT_GEN INTO v_total_imp_gen FROM T_GEN_STMT gs WHERE gs.ID= v_gs_id ;
        -- dbms_output.put_line(' v_total_exp_gen - '|| v_total_exp_gen);
        -- dbms_output.put_line(' v_total_imp_gen - '|| v_total_imp_gen);

--	if(TO_NUMBER(v_total_exp_gen) < TO_NUMBER(v_total_imp_gen))THEN --strat
        v_diff_total_gen := TO_NUMBER(v_total_exp_gen) - TO_NUMBER(v_total_imp_gen);
        -- dbms_output.put_line(' v_diff_total_gen - '|| v_diff_total_gen);
        FOR genSlot IN (SELECT gs.SLOT_CODE,gs.IMP_UNITS,gs.EXP_UNITS FROM T_GEN_STMT_SLOT gs WHERE gs.T_GEN_STMT_ID=v_gs_id)
        LOOP
        BEGIN
            v_slot_code :=genSlot.SLOT_CODE ;
            ----------------------------------------------------------
            if(genSlot.SLOT_CODE = 'C1') THEN --1
  	    -- dbms_output.put_line(' genSlot.EXP_UNITS - c1===='|| genSlot.EXP_UNITS);
          -- dbms_output.put_line(' genSlot.IMP_UNITS- c1===='|| genSlot.IMP_UNITS);
                if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN --2

                v_c1_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*7.62);
                v_tax :=TO_NUMBER(v_c1_units)*0.05;
                v_c1_units:=TO_NUMBER(v_c1_units)+v_tax;
              -- dbms_output.put_line(' v_c1_units - '|| v_c1_units);
                ELSE
                v_c1_units :=0;
                END IF;	--2
            END IF;--1

            ----------------------------------------------------------
            if(genSlot.SLOT_CODE = 'C2') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN
	        -- dbms_output.put_line(' genSlot.EXP_UNITS - c2===='|| genSlot.EXP_UNITS);
          -- dbms_output.put_line(' genSlot.IMP_UNITS- c2===='|| genSlot.IMP_UNITS);
            v_c2_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*7.62);
            v_tax :=TO_NUMBER(v_c2_units)*0.05;
            v_c2_units:=TO_NUMBER(v_c2_units)+v_tax;
            -- dbms_output.put_line(' v_c2_units - '|| v_c2_units);
            ELSE
            v_c2_units :=0;
            END IF;
            END IF;

             ----------------------------------------------------------

            if(genSlot.SLOT_CODE = 'C3') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN
            -- dbms_output.put_line(' genSlot.EXP_UNITS - c3===='|| genSlot.EXP_UNITS);
            -- dbms_output.put_line(' genSlot.IMP_UNITS- c3===='|| genSlot.IMP_UNITS);
            v_c3_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*6.35);
            v_tax :=TO_NUMBER(v_c3_units)*0.05;
            v_c3_units:=TO_NUMBER(v_c3_units)+v_tax;
           --dbms_output.put_line(' v_c3_units - '|| v_c3_units);
                ELSE
            v_c3_units :=0;
          -- dbms_output.put_line(' v_c3_units - '|| v_c3_units);
            END IF;
            END IF;
              ----------------------------------------------------------

            if(genSlot.SLOT_CODE = 'C4') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN

            v_c4_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*6.35);
            v_tax :=TO_NUMBER(v_c4_units)*0.05;
            v_c4_units:=TO_NUMBER(v_c4_units)+v_tax;
--          -- dbms_output.put_line(' v_c4_units - '|| v_c4_units);
            ELSE
            v_c4_units :=0;
            END IF;
            END IF;
          ----------------------------------------------------------

            if(genSlot.SLOT_CODE = 'C5') THEN
            if(TO_NUMBER(genSlot.EXP_UNITS) < TO_NUMBER(genSlot.IMP_UNITS))THEN
            -- dbms_output.put_line(' genSlot.EXP_UNITS - c5===='|| genSlot.EXP_UNITS);
            -- dbms_output.put_line(' genSlot.IMP_UNITS- c5===='|| genSlot.IMP_UNITS);
            v_c5_units :=((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*6.0325);
           dbms_output.put_line(' v_c5_units only- '|| v_c5_units);
             v_c5_units_tax :=(((TO_NUMBER(genSlot.EXP_UNITS) - TO_NUMBER(genSlot.IMP_UNITS))*0.3175));
          --dbms_output.put_line(' v_c5_units_tax - '|| v_c5_units_tax);
            v_c5_units := (TO_NUMBER(v_c5_units) + TO_NUMBER(v_c5_units_tax));
         -- dbms_output.put_line(' v_c5_units - '|| v_c5_units);
            ELSE
            v_c5_units :=0;
            END IF;
            END IF;
          ----------------------------------------------------------

	 EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
    v_result := 'FAILURE';
    v_reason := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','CALC_NEGATIVE_CHARGES','EH','Issue in CALC_NEGATIVE_CHARGES - '||v_reason,v_result,'admin', sysdate,v_gs_id);
  END;

    v_reason := 'SUCCESS'; -- resetting loop result

    END LOOP;
--    else
--      v_result := 0; 
--  -- dbms_output.put_line(' v_result'|| v_result);
--END IF; -- end
---- dbms_output.put_line(' v_c5_units - '|| v_c5_units);

v_result := (TO_NUMBER(v_c1_units ) + TO_NUMBER(v_c2_units )+ TO_NUMBER(v_c3_units )+ TO_NUMBER(v_c4_units )+ TO_NUMBER(v_c5_units ));
IF(v_result<0)THEN
v_result := (TO_NUMBER(v_c1_units ) + TO_NUMBER(v_c2_units )+ TO_NUMBER(v_c3_units )+ TO_NUMBER(v_c4_units )+ TO_NUMBER(v_c5_units ))*(-1);
---- dbms_output.put_line(' v_result - '|| v_result);
ELSE
v_result := (TO_NUMBER(v_c1_units ) + TO_NUMBER(v_c2_units )+ TO_NUMBER(v_c3_units )+ TO_NUMBER(v_c4_units )+ TO_NUMBER(v_c5_units ));
END IF;
---- dbms_output.put_line(' v_result - '|| v_result);

  EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
    v_result := 'FAILURE';
    v_reason := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','CALC_NEGATIVE_CHARGES','EH','Issue in CALC_NEGATIVE_CHARGES - '||v_reason,v_result,'admin', sysdate,v_gs_id);
  END;
--  -- dbms_output.put_line(' v_result - '|| v_result);
RETURN v_result;
END CALC_NEGATIVE_CHARGES;

/
--------------------------------------------------------
--  DDL for Function CALL_ADJUST_ES_AVAILABLE_UNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALL_ADJUST_ES_AVAILABLE_UNITS" RETURN VARCHAR2 AS 
v_bb_cur sys_refcursor ;
v_service_number varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count number;
v_bb t_banking_balance%ROWTYPE;
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
v_result varchar2(50);
BEGIN

      FOR line IN ( select id from T_ENERGY_SALE where  month='02' and year='2019' AND status_code='APPROVED' AND C1=0 AND C2=0 AND C3=0 AND C4=0 AND C5=0)
                  LOOP

                  v_result:=ADJUST_ENERGY_SALE_AVAILABLE_UNITS(line.id);

                  END LOOP;

 RETURN 'success';
END call_adjust_es_available_units;


/
--------------------------------------------------------
--  DDL for Function CALL_CONFIRM_ES_EVENT_FEB_OPENING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALL_CONFIRM_ES_EVENT_FEB_OPENING" RETURN VARCHAR2 AS 
v_bb_cur sys_refcursor ;
v_es_id varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count number;
v_bb t_banking_balance%ROWTYPE;
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
v_result varchar2(50);
V_ES_ID varchar2(50);
v_excess_es1 VARCHAR2(300);
        v_excess_es VARCHAR2(300);
    v_id VARCHAR2(300);

BEGIN

      FOR line in(select id from t_energy_sale where seller_comp_serv_id in (select id from m_company_service where m_company_id in
                    (select m_company_id from bk_banking_closing)) and month='02')
                  LOOP
                            v_id:=line.id;
                  BANKING_BALANCE.confirm_energy_sale_event(v_id,v_excess_es,v_excess_es1);

                  END LOOP;

 RETURN 'success';
END call_confirm_es_event_feb_opening;


/
--------------------------------------------------------
--  DDL for Function CALL_CONFIRM_ES_EVENT_SAME_BANKING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALL_CONFIRM_ES_EVENT_SAME_BANKING" RETURN VARCHAR2 AS 
v_bb_cur sys_refcursor ;
v_es_id varchar2(50);
master_service_count varchar2(50);
v_comp_id varchar2(50);
v_banking_service_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_bb_count number;
v_bb t_banking_balance%ROWTYPE;
v_month varchar2(10):='02';
v_year varchar2(10):='2019';
v_result varchar2(50);
V_ES_ID varchar2(50);
v_excess_es1 VARCHAR2(300);
        v_excess_es VARCHAR2(300);
    v_id VARCHAR2(300);

BEGIN

      FOR line in(select id from t_energy_sale where seller_comp_serv_id in (select id from m_company_service where m_company_id in
                    (select m_company_id from bk_banking_same_c1)) and month='02')
                  LOOP
                            v_id:=line.id;
                  BANKING_BALANCE.confirm_energy_sale_event(v_id,v_excess_es,v_excess_es1);

                  END LOOP;

 RETURN 'success';
END call_confirm_es_event_same_banking;


/
--------------------------------------------------------
--  DDL for Function CALL_UPDATE_SURPLUS_BANKING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CALL_UPDATE_SURPLUS_BANKING" 
(
  V_MONTH IN VARCHAR2 
, V_YEAR IN VARCHAR2 
) RETURN VARCHAR2 AS 
v_cursor sys_refcursor ;
v_number varchar2(50);
o_res_code varchar2(100);
o_res_desc varchar2(200);
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
o_result_code varchar2(100);
o_result_desc varchar2(200);

BEGIN
  BEGIN
  v_log_result := log_activity('FUNCTION','CALL_UPDATE_SURPLUS_BANKING','EXCEPTION','START',V_MONTH||'-'||V_YEAR,'', sysdate,V_MONTH);
	--Loop starts
	OPEN v_cursor for select distinct suplr_code from f_energy_adjustmet where reading_mnth=V_MONTH and reading_yr=V_YEAR;
	LOOP
	FETCH v_cursor INTO v_number;
	EXIT WHEN v_cursor%NOTFOUND;
  begin
  v_log_result := log_activity('FUNCTION','CALL_UPDATE_SURPLUS_BANKING','loop-start',o_result_desc,V_MONTH||'-'||V_YEAR,v_number, sysdate,V_MONTH);


  IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_number,V_MONTH,V_YEAR,o_res_code,o_res_desc);
  v_log_result := log_activity('FUNCTION','CALL_UPDATE_SURPLUS_BANKING','in-loop',o_res_code||'-'||o_res_desc,V_MONTH||'-'||V_YEAR,v_number, sysdate,'');


  exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
           v_log_result := log_activity('FUNCTION','CALL_UPDATE_SURPLUS_BANKING','EXCEPTION-loop',o_result_desc,V_MONTH||'-'||V_YEAR,v_number, sysdate,V_MONTH);
       END;
  END LOOP;
  --Loop ends

         exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('FUNCTION','CALL_UPDATE_SURPLUS_BANKING','EXCEPTION',o_result_desc,V_MONTH||'-'||V_YEAR,'', sysdate,V_MONTH);
       END;
  RETURN NULL;
END CALL_UPDATE_SURPLUS_BANKING;


/
--------------------------------------------------------
--  DDL for Function CLEANSE_MRI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CLEANSE_MRI" 
(
  V_BATCH_ID IN VARCHAR2
) RETURN VARCHAR2 AS
v_count NUMBER; 
v_prev_month varchar2(100);
v_prev_year varchar2(100);
v_prev_read_in_oa boolean;
v_prev_read_in_imp_table boolean;
v_older_read_in_oa boolean;
v_older_read_in_imp_table boolean;
v_curr_month_first_date date;
v_mr_id varchar2(100);
v_mri_id varchar2(100);
v_mri_rec IMP_MR_LINES%ROWTYPE;
v_source varchar2(50);
v_is_complete varchar2(50);
v_status varchar2(50);
v_reason varchar2(200);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(250);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300);
mr_source_code VARCHAR2(50);
BEGIN 
	BEGIN
	    v_log_result := log_activity('PROCEDURE','CLEANSE_MRI','start',null,null,'', sysdate,V_BATCH_ID);

	SELECT mr_source_code INTO v_source FROM IMP_MR_HEADER WHERE ID = V_BATCH_ID;



	UPDATE IMP_MR_LINES SET STATUS_CODE = 'CREATED', is_first_entry = 'N'  WHERE IMP_MR_HEADER_ID = V_BATCH_ID;

--	---- dbms_output.put_line('In cleanse function');

	--if source="01" (mdms), then change the date formats to 'YYYY-MM-DD' and strip time from it
/*
	if(v_source = '01') THEN
		UPDATE IMP_MR_LINES SET sys_dt = TO_CHAR(to_date(sys_dt,'mm/dd/yyyy'),'yyyy-mm-dd'), INIT_READING_DT=TO_CHAR(to_date(INIT_READING_DT,'mm/dd/yyyy'),'yyyy-mm-dd') , FINAL_READING_DT=TO_CHAR(to_date(FINAL_READING_DT,'mm/dd/yyyy'),'yyyy-mm-dd')
		WHERE  IMP_MR_HEADER_ID = V_BATCH_ID;

		UPDATE IMP_MR_LINES SET READING_MONTH = SUBSTR(final_READING_DT,6,2),READING_YEAR = SUBSTR(final_READING_DT,0,4)
		WHERE  IMP_MR_HEADER_ID = V_BATCH_ID;

	ELSE 	*/
		UPDATE IMP_MR_LINES SET sys_dt = TO_CHAR(SYSDATE,'yyyy-mm-dd'),  INIT_READING_DT = (READING_YEAR||'-'||READING_MONTH||'-'||'01' ) ,
		FINAL_READING_DT = to_char(LAST_DAY( to_date((READING_YEAR||'-'||READING_MONTH||'-'||'01' ),'YYYY-MM-DD')),'YYYY-MM-DD')
		WHERE IMP_MR_HEADER_ID = V_BATCH_ID and nvl(MERGE_WITH_NEXT_BILLING,'N')='N';

	--END IF;
   -- cleanup the imported meter lines, by ignoring dirty data
	  v_result := MRI_IDENTIFY_ERRORS(v_batch_id);
      v_log_result := log_activity('PROCEDURE','CLEANSE_MRI','identifying errors',V_RESULT,V_RESULT,'', sysdate,V_BATCH_ID);

    if(substr(v_result,0,7) = 'FAILURE') THEN
	 	GOTO THE_END;
	 END IF;



	FOR mril IN (SELECT  line.id, line.IMP_MR_HEADER_ID ,line.SERVICE_NO,line.METER_NO, line.READING_MONTH, line.READING_YEAR
			FROM IMP_MR_lines line
			WHERE 1=1
			and line.IMP_MR_HEADER_ID = v_batch_id
            and status_code = 'CREATED'
		--  	and ( line.IS_FIRST_ENTRY = 'Y'
      --nvl(to_number(IMP_INIT_S1),0) = 0 and nvl(to_number(IMP_INIT_S2),0) = 0 and nvl(to_number(IMP_INIT_S3),0) = 0 and nvl(to_number(IMP_INIT_S4),0) = 0 and nvl(to_number(IMP_INIT_S5),0) = 0 and
				--nvl(to_number(EXP_INIT_S1),0) = 0 and nvl(to_number(EXP_INIT_S2),0) = 0 and nvl(to_number(EXP_INIT_S3),0) = 0 and nvl(to_number(EXP_INIT_S4),0) = 0 and nvl(to_number(EXP_INIT_S5),0) = 0
				--and nvl(to_number(IMP_RKVAH_INIT ),0) = 0 and nvl(to_number(v_mri_rec.EXP_RKVAH_INIT),0) = 0 and nvl(to_number(v_mri_rec.IMP_KVAH_INIT),0) = 0 and nvl(to_number(v_mri_rec.EXP_KVAH_INIT)=0
				--)
                ORDER BY line.SERVICE_NO,line.METER_NO,line.INIT_READING_DT)
	LOOP
    begin 
    v_prev_read_in_oa := false;  
    v_prev_read_in_imp_table := false;  
    v_older_read_in_oa := false;  
    v_older_read_in_imp_table := false;  

    v_prev_month := TO_CHAR(to_date((mril.READING_YEAR||'-'||mril.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')-1,'MM');
    v_prev_year := TO_CHAR(to_date((mril.READING_YEAR||'-'||mril.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')-1,'YYYY');

    v_curr_month_first_date := to_date((mril.READING_YEAR||'-'||mril.READING_MONTH||'-'||'01' ),'YYYY-MM-DD') ;
		SELECT * INTO v_mri_rec FROM IMP_MR_lines WHERE id = mril.id;

    if (nvl(v_mri_rec.MERGE_WITH_NEXT_BILLING,'N') = 'Y') then
      continue ; --leave the record untouched and skip the loop
    end if;

		SELECT count( mr.id )INTO v_count FROM T_METER_READING_HDR mr
						JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID and meter.ENABLED='Y'
						JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
						WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
						AND mr.READING_MONTH = v_prev_month
						AND mr.READING_YEAR = v_prev_month;
        if(v_count > 0 ) then v_prev_read_in_oa := true;   end if; 

		SELECT count(*) INTO v_count FROM  IMP_MR_lines where IMP_MR_HEADER_ID = v_batch_id AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
				AND READING_MONTH = v_prev_month
				AND READING_YEAR = v_prev_month ;
        if(v_count > 0 ) then v_prev_read_in_imp_table := true;     end if;

		SELECT count( mr.id )INTO v_count FROM T_METER_READING_HDR mr
						JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID and meter.ENABLED='Y'
						JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
						WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
						AND mr.FINAL_READING_DT  < v_curr_month_first_date;
        if(v_count > 0 ) then v_older_read_in_oa := true;     end if;

		SELECT count(*) INTO v_count FROM  IMP_MR_lines mr where IMP_MR_HEADER_ID = v_batch_id AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
				AND to_date(mr.FINAL_READING_DT,'YYYY-MM-DD')	  < v_curr_month_first_date;
        if(v_count > 0 ) then v_older_read_in_imp_table := true;     end if;



		if(v_prev_read_in_oa)THEN

			SELECT  mr.id INTO v_mr_id FROM T_METER_READING_HDR mr
			JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID and meter.ENABLED='Y'
			JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
			WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
			AND mr.READING_MONTH = v_prev_month
			AND mr.READING_YEAR = v_prev_year;

			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S1, v_mri_rec.EXP_INIT_S1  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C1';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S2, v_mri_rec.EXP_INIT_S2  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C2';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S3, v_mri_rec.EXP_INIT_S3  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C3';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S4, v_mri_rec.EXP_INIT_S4  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C4';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S5, v_mri_rec.EXP_INIT_S5  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C5';

              select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0), to_char(FINAL_READING_DT+1,'YYYY-MM-DD' )
              INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT , v_mri_rec.INIT_READING_DT
              from T_METER_READING_HDR where id = v_mr_id;
		ELSIF (v_prev_read_in_imp_table) THEN

			SELECT  id INTO  v_mri_id FROM  IMP_MR_lines where IMP_MR_HEADER_ID = v_batch_id AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
			AND READING_MONTH = v_prev_month
			AND READING_YEAR = v_prev_year;

			SELECT nvl(IMP_FINAL_S1,0), nvl(IMP_FINAL_S2,0), nvl(IMP_FINAL_S3,0), nvl(IMP_FINAL_S4,0), nvl(IMP_FINAL_S5,0),
					nvl(EXP_FINAL_S1,0), nvl(EXP_FINAL_S2,0), nvl(EXP_FINAL_S3,0), nvl(EXP_FINAL_S4,0), nvl(EXP_FINAL_S5,0)
				INTO
					v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5
				FROM  IMP_MR_lines where id = v_mri_id;

              select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0) ,to_char(to_date(FINAL_READING_DT,'YYYY-MM-DD')+1,'YYYY-MM-DD' )
              INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT  , v_mri_rec.INIT_READING_DT
              from IMP_MR_lines where id = v_mri_id;

		elsif(v_older_read_in_oa)THEN

			SELECT  id INTO v_mr_id from(
			SELECT mr.id FROM T_METER_READING_HDR mr
			JOIN M_COMPANY_METER meter ON meter.id = mr.M_COMPANY_METER_ID and meter.ENABLED='Y'
			JOIN M_COMPANY_SERVICE ser ON meter.M_COMPANY_SERVICE_ID = ser.id
			WHERE ser."number" = mril.SERVICE_NO AND meter.METER_NUMBER = mril.meter_NO
			AND mr.FINAL_READING_DT  <  v_curr_month_first_date
			ORDER BY mr.FINAL_READING_DT desc) WHERE  rownum =1;

			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S1, v_mri_rec.EXP_INIT_S1  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C1';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S2, v_mri_rec.EXP_INIT_S2  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C2';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S3, v_mri_rec.EXP_INIT_S3  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C3';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S4, v_mri_rec.EXP_INIT_S4  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C4';
			SELECT nvl(IMP_FINAL,0),nvl(EXP_FINAL,0) INTO v_mri_rec.IMP_INIT_S5, v_mri_rec.EXP_INIT_S5  FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mr_id AND SLOT_CODE='C5';

              select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0), to_char(FINAL_READING_DT+1,'YYYY-MM-DD' )
              INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT  , v_mri_rec.INIT_READING_DT
              from T_METER_READING_HDR where id = v_mr_id;
		ELSIF (v_older_read_in_imp_table) THEN


			SELECT  id INTO  v_mri_id from(
			SELECT mr.id FROM  IMP_MR_lines mr where IMP_MR_HEADER_ID = v_batch_id AND SERVICE_NO = mril.SERVICE_NO AND meter_no = mril.meter_no
			AND to_date(mr.FINAL_READING_DT,'YYYY-MM-DD')  < v_curr_month_first_date
			ORDER BY mr.FINAL_READING_DT DESC) WHERE  rownum = 1;



			SELECT nvl(IMP_FINAL_S1,0), nvl(IMP_FINAL_S2,0), nvl(IMP_FINAL_S3,0), nvl(IMP_FINAL_S4,0), nvl(IMP_FINAL_S5,0),
					nvl(EXP_FINAL_S1,0), nvl(EXP_FINAL_S2,0), nvl(EXP_FINAL_S3,0), nvl(EXP_FINAL_S4,0), nvl(EXP_FINAL_S5,0),
          nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0)
				INTO
					v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5,
          v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT
				FROM  IMP_MR_lines where id = v_mri_id;

          select nvl(IMP_RKVAH_FINAL,0),nvl(EXP_RKVAH_FINAL,0),to_char(to_date(FINAL_READING_DT,'YYYY-MM-DD')+1,'YYYY-MM-DD' )
          INTO v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT,    v_mri_rec.INIT_READING_DT
          from T_METER_READING_HDR where id = v_mri_id;
		ELSE
			SELECT 'Y',0,0,0,0,0,0,0,0,0,0,0,0 INTO v_mri_rec.is_first_entry,v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5,v_mri_rec.IMP_RKVAH_INIT, v_mri_rec.EXP_RKVAH_INIT   FROM dual;
		END IF;

		UPDATE IMP_MR_lines SET ROW = v_mri_rec WHERE id = v_mri_rec.id;
		--TO_CHAR(to_date((mri.READING_YEAR||'-'||mri.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')-1,'MM')

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      v_log_result := log_activity('PROCEDURE','CLEANSE_MRI-LOOP','EXCEPTION',v_reason,v_result,'', sysdate,V_BATCH_ID);
      UPDATE IMP_MR_LINES SET STATUS_CODE = 'ERROR', remarks = 'Unknown Issues - possibly data issue'
        WHERE  id = v_mri_rec.id;
    end;
    END LOOP;

	UPDATE IMP_MR_LINES SET STATUS_CODE = 'CLEANSED', remarks = ''
	WHERE  IMP_MR_HEADER_ID = V_BATCH_ID AND STATUS_CODE = 'CREATED';

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      v_log_result := log_activity('PROCEDURE','CLEANSE_MRI','EXCEPTION',v_reason,v_result,'', sysdate,V_BATCH_ID);

	    ---- dbms_output.put_line('CLEANSE_MRI - '||v_reason);

	END;
   <<THE_END>>

  IF V_RESULT = 'SUCCESS' THEN
    COMMIT;
  else
    v_result := v_result || ' - ' || v_reason;
  END IF;

	    v_log_result := log_activity('PROCEDURE','CLEANSE_MRI','End',v_result,v_result,'', sysdate,V_BATCH_ID);
  return v_result;
END CLEANSE_MRI;


/
--------------------------------------------------------
--  DDL for Function COMPLETE_ESI
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."COMPLETE_ESI" 
(
  v_es_intent_id in varchar2
) RETURN VARCHAR2 AS
/**
For not-completed ESI flow of type-WEG,
      will create trade-relationship for each ewa-line
      update the esi-line with the tr-id
      update the ESI status to COMPLETED

*/


v_tr M_TRADE_RELATIONSHIP%ROWTYPE;
v_flow_type_code varchar2(50);
v_esi_status_code varchar2(50);
v_no_records BOOLEAN:=TRUE;
--v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_imported BOOLEAN;

BEGIN

	BEGIN

    v_log_result := log_activity('PROCEDURE','complete_esi','START',v_reason,v_result,v_created_By, sysdate,v_es_intent_id);

    select flow_type_code, STATUS_CODE into v_flow_type_code, v_esi_status_code from t_es_intent WHERE ID = v_es_intent_id;

    if(v_flow_type_code = 'WEG' and v_esi_status_code != 'COMPLETED') then
        FOR ewal IN (select sell.M_COMPANY_ID M_SELLER_COMPANY_ID, ewa.SELLER_COMP_SERV_ID M_SELLER_COMP_SERVICE_ID,buy.M_COMPANY_ID M_BUYER_COMPANY_ID,
                          ewal.buyer_comp_serv_id M_BUYER_COMP_SERVICE_ID, ewa.from_dt from_date, ewa.to_dt to_date, ewal.ID REFERENCENUMBER ,ewal.DRAWAL_PEAK_UNITS PEAK_UNITS,
                          ewal.DRAWAL_OFF_PEAK_UNITS OFF_PEAK_UNITS, ewal.approved_units quantum, ewal.interval_type_code, ewal.share_percentage SHARE_PERCENT,ewal.IS_CAPTIVE
                           from t_ewa_line ewal
                           left  join t_ewa ewa on ewal.t_ewa_id = ewa.id
                           left join M_COMPANY_SERVICE sell on ewa.SELLER_COMP_SERV_ID = sell.id
                           left join M_COMPANY_SERVICE buy on ewal.buyer_comp_serv_id = buy.id
                           where ewa.T_ES_INTENT_ID =v_es_intent_id
                         )
      LOOP
        begin
        v_tr.id := M_TRADE_RELATIONSHIP_SEQ.nextval;
        v_tr.M_SELLER_COMPANY_ID := ewal.M_SELLER_COMPANY_ID;
        v_tr.M_SELLER_COMP_SERVICE_ID := ewal.M_SELLER_COMP_SERVICE_ID;
        v_tr.M_BUYER_COMPANY_ID := ewal.M_BUYER_COMPANY_ID;
        v_tr.M_BUYER_COMP_SERVICE_ID := ewal.M_BUYER_COMP_SERVICE_ID;
        v_tr.FROM_DATE := ewal.FROM_DATE;
        v_tr.TO_DATE := ewal.TO_DATE;
        v_tr.REFERENCENUMBER := ewal.REFERENCENUMBER;
        v_tr.PEAK_UNITS := ewal.PEAK_UNITS;
        v_tr.OFF_PEAK_UNITS := ewal.OFF_PEAK_UNITS;
        v_tr.QUANTUM := ewal.QUANTUM;
        v_tr.INTERVAL_TYPE_CODE := ewal.INTERVAL_TYPE_CODE;
        v_tr.SHARE_PERCENT := ewal.SHARE_PERCENT;
        v_tr.TRADE_RELATIONSHIP_SOURCE_CODE := 'EWA';
        v_tr.IS_CAPTIVE := ewal.IS_CAPTIVE;
        v_tr.ENABLED := 'Y';
        v_tr.STATUS_CODE := 'ACTIVATED';
        v_tr.CREATED_BY := v_created_by;
        v_tr.CREATED_DATE := sysdate;

        insert into M_TRADE_RELATIONSHIP values v_tr;
        update t_es_intent_line set m_trade_relationship_id= v_tr.id , status_code ='COMPLETED' where T_EST_INTENT_ID = v_es_intent_id and  BUYER_COMP_SERV_ID = v_tr.M_BUYER_COMP_SERVICE_ID;

        if(v_no_records) THEN
            v_no_records := FALSE;
        END IF;
      exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_reason := v_exception_code || ' - ' || v_exception_msg;
        -- dbms_output.put_line(v_reason);

        v_log_result := log_activity('PROCEDURE','complete_esi','EH-LOOP',v_reason,v_result,v_created_By, sysdate,v_es_intent_id);
      END;
      end loop;


      if(not v_no_records)then
        update t_es_intent SET status_code ='COMPLETED' where ID = v_es_intent_id;
      end if;
    else
      if (v_esi_status_code = 'COMPLETED') THEN
          v_reason:='ESI already completed';
        else
          v_reason:='Only flows of type-WEG is handled';
      end if;
    end if;
		if(v_no_records) THEN
			v_result := 'FAILURE';
	    if(v_reason='' OR V_REASON IS NULL) then v_reason := 'No records to process'; end if;
		END IF;


	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
	    -- dbms_output.put_line(v_reason);

      v_log_result := log_activity('PROCEDURE','complete_esi','EH',v_reason,v_result,v_created_By, sysdate,v_es_intent_id);
	END;
   <<THE_END>>

  v_log_result := log_activity('PROCEDURE','complete_esi','END',v_reason,v_result,v_created_By, sysdate,v_es_intent_id);

  COMMIT;

  return V_RESULT;

END complete_esi;

/
--------------------------------------------------------
--  DDL for Function CONFIRM_SIGNUP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CONFIRM_SIGNUP" 
(
  V_SIGNUP_ID IN VARCHAR2
) RETURN VARCHAR2 AS
v_signup M_SIGNUP%ROWTYPE;
v_exist_number_count NUMBER;
v_company_id varchar2(50);
v_powerplant_id varchar2(50);
v_company_service_id varchar2(50);
v_company_meter_id varchar2(50);
v_company_shareholder_id varchar2(50);
v_status varchar2(50);
v_reason varchar2(200);
v_is_buyer char(1);
v_is_seller char(1);
v_comp_serv_type_code varchar2(2);
V_BG_ID VARCHAR2(50);
V_TL_ID VARCHAR2(50);
V_DL_ID VARCHAR2(50);
V_UN_ID VARCHAR2(50);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(200):='SUCCESS';
v_log_result VARCHAR2(50):='';
flag VARCHAR2(50):='';
v_signup_traderel M_SIGNUP_TRADE_REL%ROWTYPE ;
v_traderel M_TRADE_RELATIONSHIP%ROWTYPE ;
v_signup_traderel_cursor sys_refcursor ;
BEGIN
	BEGIN

        v_log_result := log_activity('PROCEDURE','CONFIRM_SIGNUP','START','Start - '||V_SIGNUP_ID,'','', sysdate,V_SIGNUP_ID);

        select  * into v_signup from M_SIGNUP where id =V_SIGNUP_ID;
        SELECT count("number") INTO v_exist_number_count FROM M_COMPANY_SERVICE WHERE "number" = v_signup.HTSC_NUMBER;


	  if(v_signup.is_complete = 'Y') then
	    v_reason := 'Signup already completed';
	    V_RESULT := 'FAILURE';
	    GOTO THE_END;
	  ELSIF( v_signup.HTSC_NUMBER IS NULL OR  v_signup.HTSC_NUMBER ='' ) THEN
	  	v_reason := 'Service Number is mandatory';
	    V_RESULT := 'FAILURE';
	    GOTO THE_END;
	  ELSIF(v_exist_number_count > 0) THEN

	  	v_reason := 'A service with number-'|| v_signup.HTSC_NUMBER||' already exists';
	    V_RESULT := 'FAILURE';
	    GOTO THE_END;
    ELSE
      IF(v_signup.PURPOSE = '01') THEN
      --01-BUYER
        v_is_buyer :='Y';
        v_is_seller :='N';
        v_comp_serv_type_code:='02';

      ELSE
        v_is_buyer :='N';
        v_is_seller :='Y';
        v_comp_serv_type_code:='03';

      END IF;
	  end if;
	  	v_company_id:= m_company_seq.nextval;
        v_company_service_id:= m_company_seq.nextval;
        v_company_meter_id:= m_company_seq.nextval;
	  	V_BG_ID:= m_company_seq.nextval;
	  	V_TL_ID:= m_company_seq.nextval;
	  	V_DL_ID:= m_company_seq.nextval;
	  	V_UN_ID:= m_company_seq.nextval;
		v_powerplant_id:= M_POWERPLANT_SEQ.NEXTVAL;


        Insert into M_COMPANY (ID,CODE,NAME,COMPANY_TYPE_CODE,REGISTRATION_NO,REGISTRATION_DATE,COB_DATE,INCORP_PLACE,IS_CAPTIVE,CAPTIVE_PURPOSE,PAN,TAN,CST,GST,ENABLED,
            CREATED_BY,CREATED_DATE,REMARKS,IS_INTERNAL,IS_BUYER,IS_SELLER, IMPORT_REMARKS)
        values (v_company_id,'COM'||v_company_id,v_signup.company_name,'01',v_signup.REGISTRATION_NO,v_signup.REGISTRATION_DATE,null,null,v_signup.IS_CAPTIVE,null,null,null,null,null,'Y',
            v_signup.created_by,sysdate,v_signup.remarks,'N',v_is_buyer,v_is_seller,v_signup.IMPORT_REMARKS);



        Insert into M_COMPANY_SERVICE (ID,COMP_SER_TYPE_CODE,"number",M_COMPANY_ID,M_ORG_ID,CAPACITY,M_SUBSTATION_ID,M_FEEDER_ID,REF_NUMBER,VOLTAGE_CODE,FUEL_TYPE_CODE,TARIFF,TOTAL_CAPACITY,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,MODIFIED_BY,MODIFIED_DATE,TYPE,BANKING_SERVICE_ID,BANKING_SERVICE_NUMBER,TL_SERVICE_ID,TL_SERVICE_NUMBER,DL_SERVICE_ID,DL_SERVICE_NUMBER,UNADJUSTED_SERVICE_ID,UNADJUSTED_SERVICE_NUMBER, IMPORT_REMARKS,FLOW_TYPE_CODE,IS_REC)
        values (v_company_service_id,v_comp_serv_type_code, v_signup.HTSC_NUMBER,v_company_id,v_signup.M_ORG_ID,v_signup.TOTAL_CAPACITY,v_signup.M_SUBSTATION_ID,v_signup.M_FEEDER_ID,'SIGNUP:'||v_signup.ID,v_signup.VOLTAGE,v_signup.FUEL,v_signup.TARIFF,v_signup.TOTAL_CAPACITY,'Y',NULL,v_signup.created_by,SYSDATE,null,NULL,null,V_BG_ID,'BG'||V_BG_ID,V_DL_ID,'TL'||V_TL_ID,V_DL_ID,'DL'||V_DL_ID,V_DL_ID,'UN'||V_UN_ID,v_signup.IMPORT_REMARKS,v_signup.FLOW_TYPE_CODE,v_signup.IS_REC);



        IF(v_is_seller ='Y') THEN

        --insert company meter
          Insert into M_COMPANY_METER (ID,M_COMPANY_SERVICE_ID,METER_NUMBER,METER_MAKE_CODE,ACCURACY_CLASS_CODE,IS_ABTMETER,MF,REMARKS,CREATED_BY,CREATED_DATE,MODEM_NUMBER,ENABLED,METER_CT1,METER_CT2,METER_CT3,METER_PT1,METER_PT2,METER_PT3, IMPORT_REMARKS)
        values (v_company_meter_id,v_company_service_id,v_signup.METER_NUMBER,v_signup.METER_MAKE_CODE,v_signup.ACCURACY_CLASS_TYPE_CODE,v_signup.IS_ABT_METER,v_signup.MULTIPLICATION_FACTOR,v_signup.REMARKS,v_signup.CREATED_BY,SYSDATE,v_signup.MODEM_NO,'Y',v_signup.METER_CT_1,v_signup.METER_CT_2,v_signup.METER_CT_3,v_signup.METER_BT_1,v_signup.METER_BT_2,v_signup.METER_BT_3, v_signup.IMPORT_REMARKS);

        --insert powerplant
          Insert into M_POWERPLANT (ID,IS_PRIMARY,VERSION,CODE,NAME,PLANT_TYPE_CODE,FUEL_TYPE_CODE,M_SERVICE_ID,M_ORG_ID,T_GRID_CONN_APPLN_ID,TOTAL_CAPACITY,M_SUBSTATION_ID,INTERFACE_VOLTAGE_PHASE,INTERFACE_VOLTAGE_FREQUENCY,
                 COMMISSION_DATE,PURPOSE,ENABLED,STATUS,LINE1,CITY,STATE_CODE,PINCODE,VILLAGE,TALUK_CODE,DISTRICT_CODE,
                 PLS_SF_NO,PL_VILLAGE,PL_TOWN,PL_TALUK_CODE,
                PL_DISTRICT_CODE,WIND_PASS_CODE,WIND_ZONE_AREA_CODE,APPLICATION_DT,APPROVAL_DT,REMARKS,CREATED_BY,CREATED_DATE,IMPORT_REMARKS,PLANT_CLASS_TYPE_CODE,M_FEEDER_ID)
          values (v_powerplant_id,'Y',null,M_POWERPLANT_SEQ.CURRVAL,v_signup.POWERPLANT_NAME,v_signup.POWERPLANT_TYPE,v_signup.FUEL,v_company_service_id,v_signup.M_ORG_ID,null,v_signup.TOTAL_CAPACITY,v_signup.M_SUBSTATION_ID,null,null,
                v_signup.COMMISSION_DATE,v_signup.PURPOSE,'Y',null,v_signup.ADDRESS_LINE,v_signup.CITY,v_signup.STATE_CODE,null,v_signup.VILLAGE,v_signup.TALUK_CODE,
                v_signup.DISTRICT_CODE,null,v_signup.VILLAGE,null,v_signup.TALUK_CODE,
                v_signup.DISTRICT_CODE,v_signup.WIND_PASS_CODE,null,null,null,v_signup.REMARKS,'admin',sysdate,v_signup.IMPORT_REMARKS,v_signup.PLANT_CLASS_TYPE_CODE,v_signup.M_FEEDER_ID);


        --insert gen-unit
          Insert into m_generator (ID,M_POWERPLANT_ID,NAME,MAKE_CODE,SERIAL_NO,ROTOR_DIA,HUB_HEIGHT,CAPACITY,REFERENCE_ID,VOLTAGE_CODE,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,NO_OF_UNITS, IMPORT_REMARKS)
          values (m_generator_seq.nextval,M_POWERPLANT_SEQ.currval,null,v_signup.GU_MODEL1,null,null,null,v_signup.GU_CAPACITY1,null,v_signup.VOLTAGE,'Y',v_signup.REMARKS,'admin', sysdate,v_signup.NO_OF_GU1,v_signup.IMPORT_REMARKS);


          if v_signup.GU_MODEL2 IS NOT NULL then
          Insert into m_generator (ID,M_POWERPLANT_ID,NAME,MAKE_CODE,SERIAL_NO,ROTOR_DIA,HUB_HEIGHT,CAPACITY,REFERENCE_ID,VOLTAGE_CODE,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,NO_OF_UNITS, IMPORT_REMARKS)
          values (m_generator_seq.nextval,M_POWERPLANT_SEQ.currval,null,v_signup.GU_MODEL2,null,null,null,v_signup.GU_CAPACITY2,null,v_signup.VOLTAGE,'Y',v_signup.REMARKS,'admin', sysdate,v_signup.NO_OF_GU2,v_signup.IMPORT_REMARKS);

          end if;
           if v_signup.GU_MODEL3 IS NOT NULL then
          Insert into m_generator (ID,M_POWERPLANT_ID,NAME,MAKE_CODE,SERIAL_NO,ROTOR_DIA,HUB_HEIGHT,CAPACITY,REFERENCE_ID,VOLTAGE_CODE,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,NO_OF_UNITS, IMPORT_REMARKS)
          values (m_generator_seq.nextval,M_POWERPLANT_SEQ.currval,null,v_signup.GU_MODEL3,null,null,null,v_signup.GU_CAPACITY3,null,v_signup.VOLTAGE,'Y',v_signup.REMARKS,'admin', sysdate,v_signup.NO_OF_GU3,v_signup.IMPORT_REMARKS);

          end if;
           if v_signup.GU_MODEL4 IS NOT NULL then
          Insert into m_generator (ID,M_POWERPLANT_ID,NAME,MAKE_CODE,SERIAL_NO,ROTOR_DIA,HUB_HEIGHT,CAPACITY,REFERENCE_ID,VOLTAGE_CODE,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,NO_OF_UNITS, IMPORT_REMARKS)
          values (m_generator_seq.nextval,M_POWERPLANT_SEQ.currval,null,v_signup.GU_MODEL4,null,null,null,v_signup.GU_CAPACITY4,null,v_signup.VOLTAGE,'Y',v_signup.REMARKS,'admin', sysdate,v_signup.NO_OF_GU4,v_signup.IMPORT_REMARKS);

          end if;
           if v_signup.GU_MODEL5 IS NOT NULL then
          Insert into m_generator (ID,M_POWERPLANT_ID,NAME,MAKE_CODE,SERIAL_NO,ROTOR_DIA,HUB_HEIGHT,CAPACITY,REFERENCE_ID,VOLTAGE_CODE,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,NO_OF_UNITS, IMPORT_REMARKS)
          values (m_generator_seq.nextval,M_POWERPLANT_SEQ.currval,null,v_signup.GU_MODEL5,null,null,null,v_signup.GU_CAPACITY5,null,v_signup.VOLTAGE,'Y',v_signup.REMARKS,'admin', sysdate,v_signup.NO_OF_GU5,v_signup.IMPORT_REMARKS);

          end if;
           if v_signup.GU_MODEL6 IS NOT NULL then
          Insert into m_generator (ID,M_POWERPLANT_ID,NAME,MAKE_CODE,SERIAL_NO,ROTOR_DIA,HUB_HEIGHT,CAPACITY,REFERENCE_ID,VOLTAGE_CODE,ENABLED,REMARKS,CREATED_BY,CREATED_DATE,NO_OF_UNITS, IMPORT_REMARKS)
          values (m_generator_seq.nextval,M_POWERPLANT_SEQ.currval,null,v_signup.GU_MODEL6,null,null,null,v_signup.GU_CAPACITY6,null,v_signup.VOLTAGE,'Y',v_signup.REMARKS,'admin', sysdate,v_signup.NO_OF_GU6,v_signup.IMPORT_REMARKS);

          end if;
          INSERT INTO AUTH_USER(ID,FIRST_NAME,LAST_NAME,USER_NAME,PASSWORD,USER_TYPE_CODE,IS_SUPER_USER,SYSTEM_KEY_CODE,SYSTEM_REF_KEY,EDC_CODE,COMPANY_ID,ORG_ID,COMPANY_SERVICE_ID, IMPORT_REMARKS, master_confirmed)
          values(USER_ID_SEQ.NEXTVAL,v_signup.HTSC_NUMBER,v_signup.company_name,v_signup.HTSC_NUMBER,'tneb','GEN','N','OA',v_company_service_id,v_signup.M_ORG_ID,v_company_id,v_signup.M_ORG_ID,v_company_service_id,v_signup.IMPORT_REMARKS,'Y');



            v_result := CREATE_AGMTS_FOR_SIGNUP(V_SIGNUP_ID);


            OPEN v_signup_traderel_cursor for SELECT *  FROM M_SIGNUP_TRADE_REL WHERE M_SIGNUP_ID = V_SIGNUP_ID;

             LOOP
            FETCH v_signup_traderel_cursor INTO v_signup_traderel;

            EXIT WHEN v_signup_traderel_cursor%NOTFOUND;

            v_traderel.id:= m_trade_relationship_seq.nextval;
            select v_company_id, v_company_service_id,v_signup_traderel.M_BUYER_COMPANY_ID,v_signup_traderel.M_BUYER_COMP_SERVICE_ID,v_signup_traderel.QUANTUM,v_signup_traderel.FROM_DATE,v_signup_traderel.TO_DATE,v_signup_traderel.C1,v_signup_traderel.C2
            ,v_signup_traderel.C3,v_signup_traderel.C4,v_signup_traderel.C5,v_signup_traderel.IS_CAPTIVE,v_signup_traderel.PEAK_UNITS,v_signup_traderel.OFF_PEAK_UNITS,v_signup_traderel.INTERVAL_TYPE_CODE,v_signup_traderel.SHARE_PERCENT,'SIGNUP',v_signup.IMPORT_REMARKS,v_signup.flow_type_code
            into v_traderel.M_SELLER_COMPANY_ID,v_traderel.M_SELLER_COMP_SERVICE_ID,v_traderel.M_BUYER_COMPANY_ID,v_traderel.M_BUYER_COMP_SERVICE_ID,v_traderel.QUANTUM,v_traderel.FROM_DATE,v_traderel.TO_DATE,v_traderel.C1,
            v_traderel.C2,v_traderel.C3,v_traderel.C4,v_traderel.C5,v_traderel.IS_CAPTIVE,v_traderel.PEAK_UNITS,v_traderel.OFF_PEAK_UNITS,v_traderel.INTERVAL_TYPE_CODE,v_traderel.SHARE_PERCENT,v_traderel.TRADE_RELATIONSHIP_SOURCE_CODE,v_traderel.IMPORT_REMARKS,v_traderel.flow_type_code from dual;

            if v_signup_traderel.INTERVAL_TYPE_CODE='04' then
            v_company_shareholder_id:= m_company_seq.nextval;

            insert into M_COMPANY_SHAREHOLDER (ID,M_COMPANY_ID,M_SHAREHOLDER_COMPANY_ID,"share",IMPORT_REMARKS) VALUES(v_company_shareholder_id,v_company_id,v_signup_traderel.M_BUYER_COMPANY_ID,v_signup_traderel.SHARE_PERCENT,v_signup.IMPORT_REMARKS);


            end if;

            INSERT INTO M_TRADE_RELATIONSHIP VALUES v_traderel;

            view_refresh.COMP_SERV_REFRESH(v_signup.HTSC_NUMBER, v_result, v_reason);

            END LOOP;


          update M_SIGNUP set is_complete = 'Y' where id=V_SIGNUP_ID;
        END IF;

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','CONFIRM_SIGNUP','EH','Exception - '||v_exception_code,V_RESULT,v_reason, sysdate,V_SIGNUP_ID);
	END;
   <<THE_END>>

  IF V_RESULT = 'SUCCESS' THEN
    COMMIT;
  else
    v_result := v_result || ' - ' || v_reason;
  END IF;

   v_log_result := log_activity('PROCEDURE','CONFIRM_SIGNUP','End',V_RESULT,V_RESULT,v_reason, sysdate,V_SIGNUP_ID);

  return v_result;
END CONFIRM_SIGNUP;


/
--------------------------------------------------------
--  DDL for Function CREATE_AGMTS_FOR_SIGNUP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CREATE_AGMTS_FOR_SIGNUP" 
(
  V_SIGNUP_ID IN VARCHAR2
) RETURN VARCHAR2 AS
v_signup M_SIGNUP%ROWTYPE;
v_ewa T_EWA%ROWTYPE;
v_ewa_line T_EWA_LINE%ROWTYPE;
v_oaa T_OAA%ROWTYPE;
v_seller_company_id varchar2(50);
v_seller_service_id varchar2(50);
buyer_end_org_id varchar2(50);
v_reason varchar2(200);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(64);
v_result varchar(200):='SUCCESS';
v_log_result VARCHAR2(50):='';
v_signup_traderel M_SIGNUP_TRADE_REL%ROWTYPE ;
v_signup_traderel_cursor sys_refcursor ;
V_DATE_DIFF VARCHAR2(17);
v_aggrement_ewa F_AGREEMENT%ROWTYPE;
v_aggrement_oaa F_AGREEMENT%ROWTYPE;
v_aggrement_ewa_line F_AGREEMENT_LINE%ROWTYPE;
v_aggrement_oaa_line F_AGREEMENT_LINE%ROWTYPE;
v_epa T_EPA%ROWTYPE;
v_epa_line T_EPA_LINES%ROWTYPE;
v_aggrement_epa F_AGREEMENT%ROWTYPE;
v_aggrement_epa_line F_AGREEMENT_LINE%ROWTYPE;
v_is_captive varchar2(10):='N';
v_flow_type_code varchar2(50);
v_flow_type_for_agmt varchar2(50);
v_fuel_grp varchar2(50);
BEGIN
    BEGIN

--    v_log_result := log_activity('PROCEDURE','CREATE_AGMTS_FOR_SIGNUP','START','Start - '||V_SIGNUP_ID,'','', sysdate,V_SIGNUP_ID);

    select  * into v_signup from M_SIGNUP where id =V_SIGNUP_ID;

	select  id ,m_company_id into v_seller_service_id,v_seller_company_id from m_company_service where "number" = v_signup.htsc_number;
	   -- -- dbms_output.put_line('v_seller_service_id' || v_seller_service_id);


    if v_flow_type_code ='IS-CAPTIVE' then
        v_flow_type_for_agmt :='CAPTIVE';
        v_is_captive:='Y';
    else
        v_flow_type_for_agmt := v_flow_type_code;
        v_is_captive:='N';
    end if;

-- IF(v_signup.IS_CAPTIVE='Y' OR v_signup.NATURE_OF_BOARD='WEG-THIRD-PARTY') THEN
IF v_signup.flow_type_code in ('THIRD_PARTY', 'IS-CAPTIVE') THEN

       -- -- dbms_output.put_line('1');
    -- insert EWA

       v_ewa.id := t_ewa_seq.nextval;
       v_ewa.code := 'EWA'||v_ewa.id;
       v_ewa.SELLER_COMP_SERV_ID := v_seller_service_id;
       v_ewa.SELLER_END_ORG_ID := v_signup.m_org_id;
       v_ewa.INJECTION_VOLTAGE_CODE := v_signup.voltage;
       v_ewa.TOAL_APPROVED_UNITS := v_signup.SANCTIONED_QUANTUM;
       v_ewa.FROM_DT := ''; --WILL BE UPDATED FROM TR LOOP
       v_ewa.TO_DT := ''; --WILL BE UPDATED FROM TR LOOP
       v_ewa.STATUS_CODE := 'COMPLETED';
-------------------------------

       v_ewa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
       v_ewa.SELLER_IS_CAPTIVE := v_is_captive;
		/*
        IF(v_signup.NATURE_OF_BOARD='WEG-THIRD-PARTY')THEN
		       v_ewa.FLOW_TYPE_CODE := 'THIRD-PARTY';
       		   v_ewa.SELLER_IS_CAPTIVE := 'N';
		ELSE
		       v_ewa.FLOW_TYPE_CODE := 'CAPTIVE';
       		   v_ewa.SELLER_IS_CAPTIVE := 'Y';
		END IF;
        */
--------------------------------
       v_ewa.ENABLED := 'Y';
       v_ewa.created_date := sysdate;
       v_ewa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

       -- -- dbms_output.put_line('2-'||v_ewa.id);
       INSERT INTO T_EWA VALUES v_ewa;
       -- -- dbms_output.put_line('3');

        v_aggrement_ewa.id := F_AGREEMENT_SEQ.nextval;
        v_aggrement_ewa.CODE :=  'AGREEMENT'||v_aggrement_ewa.id;
        v_aggrement_ewa.T_EWA_ID := v_ewa.id;
        v_aggrement_ewa.SELLER_COMP_SERV_ID := v_ewa.SELLER_COMP_SERV_ID;
        v_aggrement_ewa.SELLER_EDC_ID := v_ewa.SELLER_END_ORG_ID;
        v_aggrement_ewa.AGREEMENT_DATE := v_ewa.FROM_DT;
        v_aggrement_ewa.SELLER_COMPANY_ID := v_seller_company_id;
        v_aggrement_ewa.FROM_DATE := v_ewa.FROM_DT;
        v_aggrement_ewa.TO_DATE := v_ewa.TO_DT;
-------------------------------

       v_aggrement_ewa.IS_CAPTIVE := v_is_captive;
/*       
		IF(v_signup.NATURE_OF_BOARD='WEG-THIRD-PARTY')THEN
        		v_aggrement_ewa.IS_CAPTIVE := 'N';
		ELSE
			    v_aggrement_ewa.IS_CAPTIVE := 'Y';
		END IF;
        */
--------------------------------
        v_aggrement_ewa.AGREEMENT_PERIOD_CODE := v_ewa.AGMT_PERIOD_CODE;
        v_aggrement_ewa.FLOW_TYPE := v_ewa.FLOW_TYPE_CODE;
        v_aggrement_ewa.STATUS_CODE := 'SIGNED';
        v_aggrement_ewa.M_SIGNUP_ID := V_SIGNUP_ID;
        v_aggrement_ewa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

        -- -- dbms_output.put_line('02'||v_aggrement_ewa.id);
        INSERT INTO F_AGREEMENT VALUES v_aggrement_ewa;
        -- -- dbms_output.put_line('03');

    for v_signup_traderel in (SELECT *  FROM M_SIGNUP_TRADE_REL WHERE M_SIGNUP_ID = V_SIGNUP_ID)
    LOOP
    BEGIN

    SELECT (TO_DATE-FROM_DATE)
	INTO V_DATE_DIFF
	FROM M_SIGNUP_TRADE_REL where M_SIGNUP_ID =V_SIGNUP_ID and rownum=1;
    -- -- dbms_output.put_line('v_date_diff' || V_DATE_DIFF );

    IF (V_DATE_DIFF>90 AND V_DATE_DIFF<1825)THEN
		v_ewa.AGMT_PERIOD_CODE := 'MTOA';
    ELSIF (V_DATE_DIFF>1825)THEN
		v_ewa.AGMT_PERIOD_CODE := 'LTOA';
    ELSE
        v_ewa.AGMT_PERIOD_CODE := 'STOA';
    END IF;
    -- -- dbms_output.put_line('agmt_period_code'||v_ewa.AGMT_PERIOD_CODE);

              -- -- dbms_output.put_line('4');
              -- set values fro ewa line
              v_ewa_line.id := t_ewa_line_seq.nextval;
              v_ewa_line.T_EWA_ID := v_ewa.id;
              v_ewa_line.BUYER_COMP_SERV_ID := v_signup_traderel.M_BUYER_COMP_SERVICE_ID;
              select m_org_id, voltage_code into v_ewa_line.BUYER_END_ORG_ID, v_ewa_line.DRAWAL_VOLTAGE_CODE from m_company_service where id = v_signup_traderel.M_BUYER_COMP_SERVICE_ID;
              v_ewa_line.INTERVAL_TYPE_CODE := v_signup_traderel.INTERVAL_TYPE_CODE;
              v_ewa_line.SHARE_PERCENTAGE := v_signup_traderel.SHARE_PERCENT;
-------------------------------

       v_ewa_line.IS_CAPTIVE := v_is_captive;
       /*
		IF(v_signup.NATURE_OF_BOARD='WEG-THIRD-PARTY')THEN
              v_ewa_line.IS_CAPTIVE := 'N';
		ELSE
		      v_ewa_line.IS_CAPTIVE := 'Y';
		END IF;
        */
--------------------------------
              v_ewa_line.ENABLED := 'Y';
              v_ewa_line.created_by := 'admin';
              v_ewa_line.created_dt := sysdate;
              v_ewa_line.created_date := sysdate;
              v_ewa_line.PROPOSED_UNITS := v_signup_traderel.QUANTUM;
              v_ewa_line.APPROVED_UNITS := v_signup_traderel.QUANTUM;
              v_ewa_line.INJECTION_PEAK_UNITS := v_signup_traderel.PEAK_UNITS;
              v_ewa_line.INJECTION_OFF_PEAK_UNITS := v_signup_traderel.OFF_PEAK_UNITS;
              v_ewa_line.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

                -- -- dbms_output.put_line('quantum' || v_signup_traderel.QUANTUM);
              -- -- dbms_output.put_line('5');

              v_ewa.FROM_DT := v_signup_traderel.from_date;
              v_ewa.TO_DT:= v_signup_traderel.to_date;

              UPDATE T_EWA SET FROM_DT=v_ewa.FROM_DT, TO_DT =  v_ewa.TO_DT,AGMT_PERIOD_CODE=v_ewa.AGMT_PERIOD_CODE WHERE id = v_ewa.id;
              UPDATE F_AGREEMENT SET FROM_DATE=v_ewa.FROM_DT, TO_DATE =  v_ewa.TO_DT,AGREEMENT_PERIOD_CODE=v_ewa.AGMT_PERIOD_CODE,AGREEMENT_DATE=v_ewa.FROM_DT WHERE id = v_aggrement_ewa.id;
              -- insert ewa line
              INSERT INTO t_ewa_line VALUES v_ewa_line;

    select M_COMPANY_ID into v_aggrement_ewa.BUYER_COMP_ID from m_company_service where id = v_signup_traderel.M_BUYER_COMP_SERVICE_ID;

    for v_ewa_line in (SELECT *  FROM T_EWA_LINE WHERE T_EWA_ID = v_ewa.ID)
    LOOP

        v_aggrement_ewa_line.id := F_AGREEMENT_LINE_SEQ.nextval;
        v_aggrement_ewa_line.F_AGREEMENT_ID := v_aggrement_ewa.id;
        v_aggrement_ewa_line.BUYER_COMP_SERV_ID := v_ewa_line.BUYER_COMP_SERV_ID;
        v_aggrement_ewa_line.BUYER_ORG_ID := v_ewa_line.BUYER_END_ORG_ID;
        v_aggrement_ewa_line.DRAWAL_VOLTAGE_CODE := v_ewa_line.DRAWAL_VOLTAGE_CODE;
        v_aggrement_ewa_line.PROPOSED_CAPACITY := v_ewa_line.PROPOSED_UNITS;
        v_aggrement_ewa_line.APPROVED_CAPACITY := v_ewa_line.APPROVED_UNITS;
        v_aggrement_ewa_line.FLOW_TYPE_CODE := v_ewa.FLOW_TYPE_CODE; 
        v_aggrement_ewa_line.AGMT_PERIOD_CODE := v_ewa.AGMT_PERIOD_CODE;
        v_aggrement_ewa_line.APPROVED_DT := v_ewa_line.APPROVED_DT;
        v_aggrement_ewa_line.AGREEMENT_DT := v_ewa.FROM_DT;
        v_aggrement_ewa_line.IS_CAPTIVE := v_ewa_line.IS_CAPTIVE;
        v_aggrement_ewa_line.PEAK_UNITS :=v_ewa_line.DRAWAL_PEAK_UNITS;
        v_aggrement_ewa_line.OFF_PEAK_UNITS := v_ewa_line.DRAWAL_OFF_PEAK_UNITS;
        v_aggrement_ewa_line.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;
   END LOOP;

        INSERT INTO F_AGREEMENT_LINE VALUES v_aggrement_ewa_line;

              -- -- dbms_output.put_line('6-'||v_ewa_line.id );
              -- -- dbms_output.put_line('6-'||v_signup_traderel.from_date);
              -- -- dbms_output.put_line('6-'||v_signup_traderel.to_date );
              -- set values fro openaccess
              v_oaa.id := t_oaa_seq.nextval;
              v_oaa.CODE := 'OAA'||v_oaa.id;
              v_oaa.BUYER_COMP_SERV_ID := v_signup_traderel.M_BUYER_COMP_SERVICE_ID;
              v_oaa.BUYER_END_ORG_ID := v_ewa_line.BUYER_END_ORG_ID;
              v_oaa.DRAWAL_DIST_VOLTAGE_CODE :=v_ewa_line.DRAWAL_VOLTAGE_CODE;
              v_oaa.AGMT_PERIOD_CODE := v_ewa.AGMT_PERIOD_CODE; -- need to fix this
              v_oaa.FROM_DT := v_signup_traderel.from_date;
              v_oaa.TO_DT:= v_signup_traderel.to_date;
              v_oaa.PROPOSED_TOTAL_UNITS:= v_signup_traderel.QUANTUM;
              v_oaa.APPROVED_TOTAL_UNITS:= v_signup_traderel.QUANTUM;
              v_oaa.SELLER_COMP_SERV_ID:=v_seller_service_id;
              v_oaa.SELLER_END_ORG_ID := v_signup.m_org_id;
              v_oaa.INJECTION_DIST_SS_ID:= v_signup.m_substation_id;
              v_oaa.INJECTION_DIST_VOLTAGE_CODE :=  v_signup.voltage;
              v_oaa.STATUS_CODE := 'COMPLETED';
              v_oaa.INTERVAL_TYPE_CODE := v_signup_traderel.INTERVAL_TYPE_CODE;
              v_oaa.C1_UNITS :=v_signup_traderel.C1;
              v_oaa.C2_UNITS :=v_signup_traderel.C2;
              v_oaa.C3_UNITS :=v_signup_traderel.C3;
              v_oaa.C4_UNITS :=v_signup_traderel.C4;
              v_oaa.C5_UNITS :=v_signup_traderel.C5;
              v_oaa.AGREEMENT_DT :=sysdate;
              v_oaa.PEAK_UNITS := v_signup_traderel.PEAK_UNITS;
              v_oaa.OFF_PEAK_UNITS :=v_signup_traderel.OFF_PEAK_UNITS;
-------------------------------

              v_oaa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
       /*
		IF(v_signup.NATURE_OF_BOARD='WEG-THIRD-PARTY')THEN
              v_oaa.FLOW_TYPE_CODE := 'THIRD-PARTY';
		ELSE
			  v_oaa.FLOW_TYPE_CODE := 'CAPTIVE';

		END IF;
        */
--------------------------------
              v_oaa.ENABLED := 'Y';
              v_oaa.created_by := 'admin';
              v_oaa.created_dt := sysdate;
              v_oaa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;


              -- -- dbms_output.put_line('7');
              INSERT INTO t_oaa VALUES v_oaa;

              select M_COMPANY_ID into v_aggrement_oaa.BUYER_COMP_ID from m_company_service where id = v_signup_traderel.M_BUYER_COMP_SERVICE_ID;


              v_aggrement_oaa.id := F_AGREEMENT_SEQ.nextval;
              v_aggrement_oaa.CODE :=  'AGREEMENT'||v_aggrement_oaa.id;
              v_aggrement_oaa.T_OAA_ID := v_oaa.id;
              v_aggrement_oaa.BUYER_COMP_SERV_ID := v_oaa.BUYER_COMP_SERV_ID;
              v_aggrement_oaa.BUYER_EDC_ID := v_oaa.BUYER_END_ORG_ID;
              v_aggrement_oaa.AGREEMENT_PERIOD_CODE := v_oaa.AGMT_PERIOD_CODE;
              v_aggrement_oaa.FROM_DATE := v_oaa.FROM_DT;
              v_aggrement_oaa.TO_DATE:= v_oaa.TO_DT;
              v_aggrement_oaa.STATUS_CODE :='SIGNED';
              v_aggrement_oaa.SELLER_COMP_SERV_ID:=v_oaa.SELLER_COMP_SERV_ID;
              v_aggrement_oaa.INTERVAL_TYPE_CODE := v_oaa.INTERVAL_TYPE_CODE;
              v_aggrement_oaa.C1 :=v_oaa.C1_UNITS;
              v_aggrement_oaa.C2 :=v_oaa.C2_UNITS;
              v_aggrement_oaa.C3 :=v_oaa.C3_UNITS;
              v_aggrement_oaa.C4 :=v_oaa.C4_UNITS;
              v_aggrement_oaa.C5 :=v_oaa.C5_UNITS;
              v_aggrement_oaa.AGREEMENT_DATE :=v_oaa.AGREEMENT_DT;
              v_aggrement_oaa.PEAK_UNITS := v_oaa.PEAK_UNITS;
              v_aggrement_oaa.OFF_PEAK_UNITS :=v_oaa.OFF_PEAK_UNITS;
              v_aggrement_oaa.FLOW_TYPE :=v_oaa.FLOW_TYPE_CODE;
              v_aggrement_oaa.M_SIGNUP_ID := V_SIGNUP_ID;
              v_aggrement_oaa.SELLER_COMPANY_ID := v_seller_company_id;
              v_aggrement_oaa.SELLER_EDC_ID := v_oaa.SELLER_END_ORG_ID;
-------------------------------

              v_aggrement_oaa.IS_CAPTIVE := v_is_captive;
              /*
		IF(v_signup.NATURE_OF_BOARD='WEG-THIRD-PARTY')THEN
              v_aggrement_oaa.IS_CAPTIVE := 'N';
		ELSE
			  v_aggrement_oaa.IS_CAPTIVE := 'Y';

		END IF;
        */
--------------------------------
              v_aggrement_oaa.TOTAL_UNITS := v_oaa.PEAK_UNITS;
              v_aggrement_oaa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

            INSERT INTO F_AGREEMENT VALUES v_aggrement_oaa;


              -- -- dbms_output.put_line('8-'||v_oaa.id );

            exception
            when others then
              v_exception_code := SQLCODE;
              v_exception_msg := SUBSTR(SQLERRM, 1, 64);
              v_result := 'FAILURE';
              v_reason := v_exception_code || ' - ' || v_exception_msg;
                  v_log_result := log_activity('PROCEDURE','CREATE_AGMTS_FOR_SIGNUP-loop','v_exception_code','Exception - '||v_exception_code,V_RESULT,v_reason, sysdate,V_SIGNUP_ID);
          END;
         END LOOP;
ELSE

       		-- -- dbms_output.put_line('EPA START');
            v_epa.id := T_EPA_SEQ.nextval;
            v_epa.CODE :=  'EPA'||v_epa.id;
            v_epa.SELLER_COMP_SERV_ID := v_seller_service_id;
            v_epa.SELLER_END_ORG_ID := v_signup.m_org_id;
            v_epa.APPROVED_TOTAL_UNITS := v_signup.SANCTIONED_QUANTUM;
            v_epa.STATUS_CODE := 'COMPLETED';
            v_epa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
            v_epa.ENABLED:= 'Y';
            v_epa.SELLER_IS_CAPTIVE := '';
            v_epa.CREATED_DATE := sysdate;
            v_epa.FROM_DT := '';
            v_epa.TO_DT := '';
            v_epa.PEAK_UNITS  := '';
            v_epa.OFF_PEAK_UNITS  :='';
            v_epa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

            INSERT INTO T_EPA VALUES v_epa;

        for v_signup_traderel in (SELECT *  FROM M_SIGNUP_TRADE_REL WHERE M_SIGNUP_ID = V_SIGNUP_ID)
        LOOP
        BEGIN
    SELECT (TO_DATE-FROM_DATE)
	INTO V_DATE_DIFF
	FROM M_SIGNUP_TRADE_REL where M_SIGNUP_ID =V_SIGNUP_ID and rownum=1;
    -- -- dbms_output.put_line('v_date_diff' || V_DATE_DIFF );
        IF (V_DATE_DIFF>90 AND V_DATE_DIFF<1825)THEN
			v_epa.AGMT_PERIOD_CODE := 'MTOA';
		ELSIF (V_DATE_DIFF>1825)THEN
			v_epa.AGMT_PERIOD_CODE := 'LTOA';
		ELSE
			v_epa.AGMT_PERIOD_CODE := 'STOA';
		END IF;
              -- set values fro epa line
              v_epa_line.id := T_EPA_LINE_SEQ.nextval;
              v_epa_line.T_EPA_ID := v_epa.id;
              v_epa_line.ENABLED := 'Y';
              v_epa_line.CREATED_BY := 'admin';
              v_epa_line.CREATED_DT := sysdate;
              v_epa_line.PROPOSED_TOTAL_UNITS := v_signup_traderel.QUANTUM;
              v_epa_line.APPROVED_TOTAL_UNITS := v_signup_traderel.QUANTUM;
              v_epa.PEAK_UNITS  := v_signup_traderel.PEAK_UNITS;
              v_epa.OFF_PEAK_UNITS  := v_signup_traderel.OFF_PEAK_UNITS;
              v_epa.BUYER_COMP_SERV_ID :=v_signup_traderel.M_BUYER_COMP_SERVICE_ID;

              v_epa.FROM_DT := v_signup_traderel.from_date;
              v_epa.TO_DT:= v_signup_traderel.to_date;
              v_epa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

            UPDATE T_EPA SET FROM_DT=v_epa.FROM_DT, TO_DT =  v_epa.TO_DT,PEAK_UNITS= v_epa.PEAK_UNITS,OFF_PEAK_UNITS= v_epa.OFF_PEAK_UNITS,AGMT_PERIOD_CODE=v_epa.AGMT_PERIOD_CODE WHERE id = v_epa.id;
            UPDATE F_AGREEMENT SET FROM_DATE=v_epa.FROM_DT, TO_DATE =  v_epa.TO_DT,AGREEMENT_PERIOD_CODE=v_epa.AGMT_PERIOD_CODE,AGREEMENT_DATE=v_epa.FROM_DT WHERE id = v_aggrement_epa.id;

              -- insert ewa line

              INSERT INTO T_EPA_LINES VALUES v_epa_line;

                select M_COMPANY_ID,M_ORG_ID into v_aggrement_epa.BUYER_COMP_ID,v_aggrement_epa.BUYER_EDC_ID from m_company_service where id = v_signup_traderel.M_BUYER_COMP_SERVICE_ID;

           v_aggrement_epa.id := F_AGREEMENT_SEQ.nextval;
           v_aggrement_epa.CODE :=  'AGREEMENT'||v_aggrement_epa.id;
           v_aggrement_epa.T_EPA_ID := v_epa.id;
           v_aggrement_epa.SELLER_COMP_SERV_ID := v_epa.SELLER_COMP_SERV_ID;
           v_aggrement_epa.SELLER_EDC_ID := v_epa.SELLER_END_ORG_ID;
           v_aggrement_epa.AGREEMENT_DATE := v_epa.FROM_DT;
           v_aggrement_epa.SELLER_COMPANY_ID := v_seller_company_id;
           v_aggrement_epa.FROM_DATE := v_epa.FROM_DT;
           v_aggrement_epa.TO_DATE := v_epa.TO_DT;
           v_aggrement_epa.AGREEMENT_PERIOD_CODE := v_epa.AGMT_PERIOD_CODE;
           v_aggrement_epa.FLOW_TYPE := v_epa.FLOW_TYPE_CODE;
           v_aggrement_epa.STATUS_CODE := 'SIGNED';
           v_aggrement_epa.M_SIGNUP_ID := V_SIGNUP_ID;
           v_aggrement_epa.BUYER_COMP_SERV_ID :=  'TNEB-'||v_aggrement_epa.SELLER_EDC_ID;
           v_aggrement_epa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

        INSERT INTO F_AGREEMENT VALUES v_aggrement_epa;
 select m_org_id into buyer_end_org_id from m_company_service where id = v_signup_traderel.M_BUYER_COMP_SERVICE_ID;

    -- -- dbms_output.put_line('start oaa for epa');
    -- -- dbms_output.put_line('from date-'||v_signup_traderel.from_date);
    -- -- dbms_output.put_line('to date-'||v_signup_traderel.to_date );
              -- set values fro openaccess
              v_oaa.id := t_oaa_seq.nextval;
              v_oaa.CODE := 'OAA'||v_oaa.id;
              v_oaa.BUYER_COMP_SERV_ID := v_signup_traderel.M_BUYER_COMP_SERVICE_ID;
              v_oaa.BUYER_END_ORG_ID := buyer_end_org_id;
--              v_oaa.DRAWAL_DIST_VOLTAGE_CODE :=v_ewa_line.DRAWAL_VOLTAGE_CODE;
              v_oaa.AGMT_PERIOD_CODE := v_epa.AGMT_PERIOD_CODE; -- need to fix this
              v_oaa.FROM_DT := v_signup_traderel.from_date;
              v_oaa.TO_DT:= v_signup_traderel.to_date;
              v_oaa.PROPOSED_TOTAL_UNITS:= v_signup_traderel.QUANTUM;
              v_oaa.APPROVED_TOTAL_UNITS:= v_signup_traderel.QUANTUM;
              v_oaa.SELLER_COMP_SERV_ID:=v_seller_service_id;
              v_oaa.SELLER_END_ORG_ID := v_signup.m_org_id;
              v_oaa.INJECTION_DIST_SS_ID:= v_signup.m_substation_id;
              v_oaa.INJECTION_DIST_VOLTAGE_CODE :=  v_signup.voltage;
              v_oaa.STATUS_CODE := 'COMPLETED';
              v_oaa.INTERVAL_TYPE_CODE := v_signup_traderel.INTERVAL_TYPE_CODE;
              v_oaa.C1_UNITS :=v_signup_traderel.C1;
              v_oaa.C2_UNITS :=v_signup_traderel.C2;
              v_oaa.C3_UNITS :=v_signup_traderel.C3;
              v_oaa.C4_UNITS :=v_signup_traderel.C4;
              v_oaa.C5_UNITS :=v_signup_traderel.C5;
              v_oaa.AGREEMENT_DT :=sysdate;
              v_oaa.PEAK_UNITS := v_signup_traderel.PEAK_UNITS;
              v_oaa.OFF_PEAK_UNITS :=v_signup_traderel.OFF_PEAK_UNITS;
              v_oaa.FLOW_TYPE_CODE := v_flow_type_for_agmt;
              v_oaa.ENABLED := 'Y';
              v_oaa.created_by := 'admin';
              v_oaa.created_dt := sysdate;
              v_oaa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

                -- -- dbms_output.put_line('buyer end org id-'||v_oaa.BUYER_END_ORG_ID);
                -- -- dbms_output.put_line('seller service id-'||v_seller_service_id);

              -- -- dbms_output.put_line('7');
              INSERT INTO t_oaa VALUES v_oaa;

              select M_COMPANY_ID into v_aggrement_oaa.BUYER_COMP_ID from m_company_service where id = v_signup_traderel.M_BUYER_COMP_SERVICE_ID;


              v_aggrement_oaa.id := F_AGREEMENT_SEQ.nextval;
              v_aggrement_oaa.CODE :=  'AGREEMENT'||v_aggrement_oaa.id;
              v_aggrement_oaa.T_OAA_ID := v_oaa.id;
              v_aggrement_oaa.BUYER_COMP_SERV_ID := v_oaa.BUYER_COMP_SERV_ID;
              v_aggrement_oaa.BUYER_EDC_ID := v_oaa.BUYER_END_ORG_ID;
              v_aggrement_oaa.AGREEMENT_PERIOD_CODE := v_oaa.AGMT_PERIOD_CODE;
              v_aggrement_oaa.FROM_DATE := v_oaa.FROM_DT;
              v_aggrement_oaa.TO_DATE:= v_oaa.TO_DT;
              v_aggrement_oaa.STATUS_CODE :='SIGNED';
              v_aggrement_oaa.SELLER_COMP_SERV_ID:=v_oaa.SELLER_COMP_SERV_ID;
              v_aggrement_oaa.INTERVAL_TYPE_CODE := v_oaa.INTERVAL_TYPE_CODE;
              v_aggrement_oaa.C1 :=v_oaa.C1_UNITS;
              v_aggrement_oaa.C2 :=v_oaa.C2_UNITS;
              v_aggrement_oaa.C3 :=v_oaa.C3_UNITS;
              v_aggrement_oaa.C4 :=v_oaa.C4_UNITS;
              v_aggrement_oaa.C5 :=v_oaa.C5_UNITS;
              v_aggrement_oaa.AGREEMENT_DATE :=v_oaa.AGREEMENT_DT;
              v_aggrement_oaa.PEAK_UNITS := v_oaa.PEAK_UNITS;
              v_aggrement_oaa.OFF_PEAK_UNITS :=v_oaa.OFF_PEAK_UNITS;
              v_aggrement_oaa.FLOW_TYPE :=v_oaa.FLOW_TYPE_CODE;
              v_aggrement_oaa.M_SIGNUP_ID := V_SIGNUP_ID;
              v_aggrement_oaa.SELLER_COMPANY_ID := v_seller_company_id;
              v_aggrement_oaa.SELLER_EDC_ID := v_oaa.SELLER_END_ORG_ID;
              v_aggrement_oaa.IS_CAPTIVE := v_is_captive;
              v_aggrement_oaa.TOTAL_UNITS := v_oaa.PEAK_UNITS;
              v_aggrement_oaa.IMPORT_REMARKS := v_signup.IMPORT_REMARKS;

            INSERT INTO F_AGREEMENT VALUES v_aggrement_oaa;


    END;
    END LOOP;


END IF;
    exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 64);
        v_result := 'FAILURE';
        v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','CREATE_AGMTS_FOR_SIGNUP','v_exception_code','Exception - '||v_exception_code,V_RESULT,v_reason, sysdate,V_SIGNUP_ID);
    END;
   <<THE_END>>


              -- -- dbms_output.put_line('8');
  IF V_RESULT = 'SUCCESS' THEN
    COMMIT;
  else
    v_result := v_result || ' - ' || v_reason;
  END IF;

   v_log_result := log_activity('PROCEDURE','CREATE_AGMTS_FOR_SIGNUP','End',V_RESULT,V_RESULT,v_reason, sysdate,V_SIGNUP_ID);

  return v_result;
END CREATE_AGMTS_FOR_SIGNUP;


/
--------------------------------------------------------
--  DDL for Function CREATE_GS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CREATE_GS" 
(
  v_imp_batch_id in varchar2,
  v_month IN VARCHAR2,
  v_year in varchar2
) RETURN VARCHAR2 AS

v_batch_based boolean:=false;
v_duration_based boolean:=false;
v_process_id  VARCHAR2(50);
v_records_processed number:=0;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_mr_id varchar2(200);
v_mr_hdr_init_rdr_date varchar2(50);
v_mr_hdr_gen_stmt_id varchar2(200);
v_seller_service_id varchar2(200);
V_TRADE_REL_COUNT varchar2(50);
v_create_stb_result varchar2(50);
v_service_number varchar2(50);
v_ss_type varchar2(50);
O_RESULT_CODE VARCHAR2(200);
O_RESULT_DESC VARCHAR2(200);
v_prev_month varchar2(10);
v_current_month varchar2(10);
v_commission_date Date;
v_prev_reading_month varchar2(10);
v_prev_reading_year varchar2(10);
BEGIN

	BEGIN

      v_log_result := log_activity('PROCEDURE','create_gs','Start',v_result,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month, v_year);
      select to_char(sysdate,'mm') into v_current_month from dual;
--     v_prev_month := to_char(to_date( '01-'||v_month||'-'||v_year,'dd-mm-yyyy')-1,'mm');

    -- this flag might be of better use in future
    if (v_imp_batch_id is null or v_imp_batch_id = '')then
      if (v_month is null or v_month = '' or v_year is null or v_year = '')
      then
        Raise_Application_Error (-20343, 'Month and Year is mandatory  ');
      else 
        v_duration_based:= true;
      end if;

    else
      v_batch_based := true;
    end if;
    v_process_id := T_PROCESS_GS_SEQ.nextval;
    INSERT INTO T_PROCESS_GS (ID,SYS_DT,STATUS,START_DT,END_DT,REMARKS)
      VALUES (v_process_id,v_created_Date,'PROCESSING',v_created_Date,NULL,NULL) ;
-- v_log_result := log_activity('PROCEDURE','create_gs','test-start',v_result,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month,v_year);
    -- dbms_output.put_line('next1');

    if(v_duration_based) then
      FOR mr IN (SELECT mh.id, m_company_meter_id,READING_MONTH,READING_YEAR FROM T_METER_READING_HDR mh  WHERE mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL
                      AND READING_MONTH = v_month AND READING_YEAR = v_year and M_COMPANY_METER_ID!='262208' )
      LOOP
      BEGIN
            select "number",TYPE_OF_SS,id into v_service_number,v_ss_type,v_seller_service_id from v_company_service where m_company_meter_id=mr.m_company_meter_id and enabled='Y'; 
    --         v_log_result := log_activity('PROCEDURE','create_gs-inside',v_seller_service_id,v_result,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month,v_year);
          v_log_result := log_activity('PROCEDURE','create_gs','IN-LOOP',mr.m_company_meter_id,'','', sysdate,v_imp_batch_id, v_month, v_year);
        -- dbms_output.put_line('next2');
     
            IF(v_ss_type!='SECTION 10(1)SS')THEN --CONDITION FOR 10(1) SS
    
                v_prev_reading_month := to_char(to_date( '01-'||v_month ||'-'||v_year,'dd-mm-yyyy')-1,'mm');
                v_prev_reading_year := to_char(to_date( '01-'||v_month ||'-'||v_year,'dd-mm-yyyy')-1,'yyyy');
                excess_units_source.update_excess_from_ht(v_service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
                excess_units.open_balances(v_service_number,mr.READING_MONTH,mr.READING_YEAR,O_RESULT_CODE,O_RESULT_DESC  );
         --  v_log_result := log_activity('PROCEDURE','create_gs-inside',v_seller_service_id,v_result,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month,v_year);
    
    -- 
    --        if v_current_month='05' then 
    --                  BANKING_BALANCE.reset_for_yearend(v_service_number,v_month ,v_year,O_RESULT_CODE,O_RESULT_DESC);  
    --            else
                    --IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_service_number,'04' ,'2019',O_RESULT_CODE,O_RESULT_DESC);
                   --  if v_commission_date is not null and v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
                   --      BANKING_BALANCE.open_balance(v_service_number,v_month,v_year,O_RESULT_CODE,O_RESULT_DESC);  
                   --  end if;
    --          end if;
             -- */
            v_result := create_gs_from_mr( v_process_id,mr.id);
            if (v_result='SUCCESS') then
                v_records_processed := v_records_processed +1;
            end if;
            END IF; --CONDITION FOR 10(1) SS ENDS
       exception
	   when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
--	    -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('PROCEDURE','create_gs','EH-v_duration_based',v_reason,v_result,v_created_By, sysdate,v_imp_batch_id);
      END;     
      END LOOP;
    else
      FOR mr IN (SELECT mh.id,mh.INIT_READING_DT,mh.M_GEN_STMT_ID GEN_STMT_ID,mh.M_COMPANY_METER_ID,mh.READING_MONTH,mh.READING_YEAR
                    FROM T_METER_READING_HDR mh 
                    WHERE mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL
                    and nvl(mh.MERGE_WITH_NEXT_BILLING,'N') = 'N' 
                    and mh.imp_batch_id = v_imp_batch_id)

      LOOP
      BEGIN
          select "number",TYPE_OF_SS,id  into v_service_number,v_ss_type,v_seller_service_id from v_company_service where m_company_meter_id=mr.m_company_meter_id and enabled='Y';
--           v_log_result := log_activity('PROCEDURE','create_gs-inside-2',v_seller_service_id,v_result,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month,v_year);
         v_log_result := log_activity('PROCEDURE','create_gs','IN-LOOP','NUMBER-'||v_service_number,'SERVICE_ID-'||v_seller_service_id,'', sysdate,v_imp_batch_id, v_month, v_year);

--            v_log_result := log_activity('PROCEDURE','create_gs-inside-3',v_seller_service_id,v_commission_date,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month,v_year);
          IF(v_ss_type!='SECTION 10(1)SS')THEN --CONDITION FOR 10(1) SS

            v_prev_reading_month := to_char(to_date( '01-'||mr.READING_MONTH ||'-'||mr.READING_YEAR,'dd-mm-yyyy')-1,'mm');
            v_prev_reading_year := to_char(to_date( '01-'||mr.READING_MONTH ||'-'||mr.READING_YEAR,'dd-mm-yyyy')-1,'yyyy');
            excess_units_source.update_excess_from_ht(v_service_number,v_prev_reading_month,v_prev_reading_year,O_RESULT_CODE,O_RESULT_DESC  );
            excess_units.open_balances(v_service_number,mr.READING_MONTH,mr.READING_YEAR,O_RESULT_CODE,O_RESULT_DESC  );
  --       if v_current_month='05' then 
  --                BANKING_BALANCE.reset_for_yearend(v_service_number,mr.READING_MONTH ,mr.READING_YEAR,O_RESULT_CODE,O_RESULT_DESC);  
   --         else
               -- IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_service_number,'04' ,'2019',O_RESULT_CODE,O_RESULT_DESC);
               --   if v_commission_date is not null and v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
               --      BANKING_BALANCE.open_balance(v_service_number,mr.READING_MONTH ,mr.READING_YEAR,O_RESULT_CODE,O_RESULT_DESC);  
               --    end if;
           -- v_log_result := log_activity('PROCEDURE','create_gs','IN-LOOP-commision','NUMBER-'||v_service_number,'SERVICE_ID-'||v_seller_service_id,v_commission_date, sysdate,v_imp_batch_id, 'ss-'||v_ss_type, v_year);

     --     end if;
        v_log_result := log_activity('PROCEDURE','create_gs','IN-LOOP-ss','NUMBER-'||v_service_number,'serviceId/process-d'||v_seller_service_id||'-'||v_process_id,v_commission_date, sysdate,v_imp_batch_id, 'ss-'||v_ss_type, v_year);

          v_result:= create_gs_from_mr(v_process_id,mr.id);

          if (v_result='SUCCESS') then
            v_records_processed := v_records_processed +1;
          end if;
          END IF; --CONDITION FOR 10(1) SS ENDS
       exception
	   when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
--	    -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('PROCEDURE','create_gs','EH-v_duration_based',v_reason,v_result,v_created_By, sysdate,v_imp_batch_id);
      END;  
      END LOOP;

	end if;

  if(v_records_processed > 0)then
    for new_mr in (select mh.id,mh.INIT_READING_DT, mh.M_GEN_STMT_ID, meter.M_COMPANY_SERVICE_ID from t_meter_reading_hdr mh LEFT JOIN M_COMPANY_METER meter on mh.M_COMPANY_METER_ID = meter.id  where mh.gs_batch_id = v_process_id)
    loop
      SELECT COUNT(*) INTO V_TRADE_REL_COUNT FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = new_mr.M_COMPANY_SERVICE_ID AND FLOW_TYPE_CODE = 'STB' AND new_mr.INIT_READING_DT BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
      IF V_TRADE_REL_COUNT>0 THEN
        v_create_stb_result := CREATE_STB(new_mr.M_GEN_STMT_ID);
      END IF;
    end loop;
  end if;

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
--	    -- dbms_output.put_line(v_reason);
      v_log_result := log_activity('PROCEDURE','create_gs','EH',v_reason,v_result,v_created_By, sysdate,v_imp_batch_id);
	END;
   <<THE_END>>

    update T_PROCESS_GS set status='COMPLETED', remarks='PROCESSED-RECORD-COUNT:'||v_records_processed, end_dt=sysdate where id = v_process_id;
    v_log_result := log_activity('PROCEDURE','create_gs','End',v_result,v_reason,v_created_By, sysdate,v_imp_batch_id, v_month,v_year);
    COMMIT;

    return v_result;
END create_gs;

/
--------------------------------------------------------
--  DDL for Function CREATE_GS_FROM_MR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CREATE_GS_FROM_MR" 
(
  v_gs_process_id in varchar2,
  v_mr_id in varchar2
) RETURN VARCHAR2 AS 
 
v_stage varchar2(50);
v_process_id  VARCHAR2(50); 
v_gen_count  NUMBER:=0;
v_mrh T_METER_READING_HDR%ROWTYPE;
v_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_mr_c5 T_METER_READING_SLOT%ROWTYPE;
v_gs T_GEN_STMT%ROWTYPE;
v_gs_c1 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c2 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c3 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c4 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c5 T_GEN_STMT_SLOT%ROWTYPE;
v_no_records BOOLEAN:=TRUE;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='';
v_plant_class_code VARCHAR2(200);
v_plant_class_desc VARCHAR2(200);
v_gen_month  VARCHAR2(50); 
v_gen_year  VARCHAR2(50); 
v_gen_comp_servi_id VARCHAR2(200);
tariff_rates VARCHAR2(200);
v_log_result varchar(300):='SUCCESS';
v_imported BOOLEAN;

v_gen_voltage_desc VARCHAR2(50); 
v_gen_org_code VARCHAR2(50); 
v_gen_iscaptive VARCHAR2(50); 
v_gen_isstb VARCHAR2(50);
v_gen_isstb_count NUMBER; 
v_gen_ssid VARCHAR2(50) ;
v_gen_ssname  VARCHAR2(50);
v_gen_sstype  VARCHAR2(50);
v_gen_ffid   VARCHAR2(50);
v_gen_ffname VARCHAR2(50);
v_tariff_net_amount VARCHAR2(150);  
v_net_payable VARCHAR2(150);
v_total_charged_amount  VARCHAR2(150);
v_flow_type_code  VARCHAR2(150);

v_prev_mr_id varchar2(50);
v_prev_mr T_METER_READING_HDR%ROWTYPE;
v_prev_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_prev_mr_c5 T_METER_READING_SLOT%ROWTYPE;

BEGIN

	BEGIN	
        v_stage := '-1-start';
        v_log_result := log_activity('PROCEDURE','create_gs_from_mr','Start',v_reason,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

		FOR meter IN (SELECT distinct mh.M_COMPANY_METER_ID, mh.READING_MONTH, mh.READING_YEAR,mh.MR_SOURCE_CODE SOURCE_CODE,
						nvl(bg.open_c1,0) bc1, nvl(bg.OPEN_C2,0) bc2, nvl(bg.OPEN_C3,0) bc3,nvl(bg.OPEN_C4,0) bc4,nvl(bg.OPEN_C5,0) bc5,  pp.status disp_pp_op_status, cs.capacity disp_capacity, cs.total_capacity  disp_total_capacity, cm.meter_number disp_meter_number,
						cs.M_ORG_ID, c.ID M_COMPANY_ID,cm.M_COMPANY_SERVICE_ID, c.NAME DISP_COMPANY_NAME, cs."number" DISP_SERVICE_NUMBER, cs.VOLTAGE_CODE INJECTING_VOLTAGE_CODE, o.NAME DISP_ORG_NAME,tr.flow_type_code,
						pp.FUEL_TYPE_CODE DISP_FUEL_TYPE_CODE, fuel.FUEL_NAME  DISP_FUEL_TYPE_NAME,fuel.FUEL_GROUP DISP_FUEL_TYPE_GROUP,pp.COMMISSION_DATE COMMISSION_DATE,cs.IS_REC IS_REC,cs.TOTAL_CAPACITY TOTAL_CAPACITY, excess_units.FIND_TYPE_FN(cs."number") excess_unit_type
						FROM T_METER_READING_HDR mh 
						INNER JOIN M_COMPANY_METER cm ON mh.M_COMPANY_METER_ID = cm.ID
						INNER JOIN M_COMPANY_SERVICE cs ON cm.M_COMPANY_SERVICE_ID = cs.id
						INNER JOIN M_COMPANY c ON cs.M_COMPANY_ID = c.id
						INNER JOIN M_ORG o ON cs.M_ORG_ID = o.id
                        INNER JOIN M_TRADE_RELATIONSHIP tr ON tr.m_seller_comp_service_id=cs.id
                        LEFT JOIN t_exs_banking_balance bg ON bg.BANKING_SERVICE_ID = cs.BANKING_SERVICE_ID and to_number(bg.reading_month)= to_number(mh.READING_MONTH) and to_number(bg.reading_year)= to_number(mh.READING_YEAR)
                        LEFT JOIN M_POWERPLANT pp ON cs.id = pp.M_SERVICE_ID
                        LEFT JOIN M_FUEL fuel ON pp.FUEL_TYPE_CODE = fuel.FUEL_CODE			
						WHERE  mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL  
                        and mh.id = v_mr_id)
		LOOP
			BEGIN

        v_stage := '-2-meter-loop-start';

        -- as there is meter-readings to process, we have to set the flag accordingly and start the generation process
				if(v_no_records) THEN
					v_no_records := FALSE;

				END IF;


        v_log_result := log_activity('PROCEDURE','meter.id','Start',meter.M_COMPANY_SERVICE_ID,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);

				-- -- dbms_output.put_line('meter.M_COMPANY_METER_ID - '||meter.M_COMPANY_METER_ID);
				-- -- dbms_output.put_line('meter.M_COMPANY_SERVICE_ID - '||meter.M_COMPANY_SERVICE_ID);
				-- -- dbms_output.put_line('meter.READING_Year - '||meter.READING_Year);
				-- -- dbms_output.put_line('meter.READING_MONTH - '||meter.READING_MONTH);

				-- to find generator capacity
				SELECT count(*) INTO v_gen_count FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;


        v_stage := '-3-find generator capacity';
				-- -- dbms_output.put_line('v_gen_count- '||v_gen_count);
     v_log_result := log_activity('PROCEDURE','meter.id','v_stage',meter.M_COMPANY_SERVICE_ID,v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);
				if(v_gen_count =0) THEN
					-- setup issue - generator not configured properly for this service
					v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','ISSUE','Setup Issue - '||v_process_id||' - No generator configured for service-id-->'||meter.M_COMPANY_SERVICE_ID,null,v_created_By, v_created_Date);
					CONTINUE;
				ELSE	
          -- TODO - Sum() should be revisited
                          v_stage := '-4-Sum() should be revisited';
					--SELECT sum(nvl(CAPACITY,0))  INTO v_gs.MACHINE_CAPACITY FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;
                   v_gs.MACHINE_CAPACITY:=meter.TOTAL_CAPACITY;
				END IF;


				-- -- dbms_output.put_line('v_gs.MACHINE_CAPACITY - '||v_gs.MACHINE_CAPACITY);
                v_stage := '-5-Getmr header';

				SELECT * INTO v_mrh FROM T_METER_READING_HDR WHERE  M_COMPANY_METER_ID = meter.M_COMPANY_METER_ID AND READING_MONTH = meter.READING_MONTH AND READING_Year = meter.READING_Year;


    -- -- dbms_output.put_line('v_mrh.id - '||v_mrh.id);

                v_stage := '-6-';

				SELECT * INTO v_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C1';
				SELECT * INTO v_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C2';
				SELECT * INTO v_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C3';
				SELECT * INTO v_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C4';
				SELECT * INTO v_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C5';

               -- -- dbms_output.put_line('crossed stage 6');

        --check if there previous meter-reading is to be included in this gen-stmt
        v_prev_mr_id := FIND_PREV_MR(v_mrh.id,'Y'); 
        if(v_prev_mr_id is not null )then
          -- previous meter reading is to be merged with the current meter reading
          SELECT * INTO v_prev_mr FROM T_METER_READING_HDR WHERE id =  v_prev_mr_id;
          SELECT * INTO v_prev_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C1';
          SELECT * INTO v_prev_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C2';
          SELECT * INTO v_prev_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C3';
          SELECT * INTO v_prev_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C4';
          SELECT * INTO v_prev_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_prev_mr_id AND SLOT_CODE = 'C5';

          ----- modify current meter reading record according to the same ----
         -- -- dbms_output.put_line('crossed prev_mr');

          --modify header
          v_mrh.INIT_READING_DT := v_prev_mr.INIT_READING_DT;
          v_mrh.EXP_RKVAH_INIT := v_prev_mr.EXP_RKVAH_INIT;
          v_mrh.IMP_RKVAH_INIT := v_prev_mr.IMP_RKVAH_INIT;
          v_mrh.EXP_KVAH_INIT := v_prev_mr.EXP_KVAH_INIT;
          v_mrh.IMP_KVAH_INIT := v_prev_mr.IMP_KVAH_INIT;
          v_mrh.RKVAH_DIFF := nvl(v_mrh.IMP_RKVAH_FINAL,0) - nvl(v_mrh.IMP_RKVAH_INIT, 0);
          v_mrh.RKVAH_UNITS := v_mrh.RKVAH_DIFF*v_mrh.mf;
          v_mrh.KVAH_DIFF := nvl((v_mrh.EXP_KVAH_FINAL - v_mrh.EXP_KVAH_INIT)- (v_mrh.IMP_KVAH_FINAL - v_mrh.IMP_KVAH_INIT), 0);
          v_mrh.KVAH_UNITS := v_mrh.KVAH_DIFF*v_mrh.mf;

         -- -- dbms_output.put_line('crossed hdr data');
          -- modify slot data
          -- -- dbms_output.put_line('crossed slot data');

          --slot1 changes
          v_mr_c1.IMP_INIT := nvl(v_prev_mr_c1.IMP_INIT,0); v_mr_c1.EXP_INIT := nvl(v_prev_mr_c1.EXP_INIT,0);
          v_mr_c1.IMP_DIFF := v_mr_c1.IMP_FINAL - v_mr_c1.IMP_INIT ;v_mr_c1.EXP_DIFF := v_mr_c1.EXP_FINAL - v_mr_c1.EXP_INIT ;


          v_mr_c1.IMP_UNITS := v_mr_c1.IMP_DIFF * v_mrh.mf; v_mr_c1.EXP_UNITS := v_mr_c1.EXP_DIFF * v_mrh.mf;
          if (to_number(v_mr_c1.EXP_DIFF)<0) then
          v_mr_c1.EXP_UNITS :=0;
          end if;
          v_mr_c1.net_units := ROUND(v_mr_c1.EXP_UNITS - v_mr_c1.IMP_UNITS,0) ; if(to_number(v_mr_c1.net_units )<0) THEN v_mr_c1.net_units := 0; END IF;

          --slot2 changes
          v_mr_c2.IMP_INIT := nvl(v_prev_mr_c2.IMP_INIT,0); v_mr_c2.EXP_INIT := nvl(v_prev_mr_c2.EXP_INIT,0);
          v_mr_c2.IMP_DIFF := v_mr_c2.IMP_FINAL - v_mr_c2.IMP_INIT ;v_mr_c2.EXP_DIFF := v_mr_c2.EXP_FINAL - v_mr_c2.EXP_INIT ;
          v_mr_c2.IMP_UNITS := v_mr_c2.IMP_DIFF * v_mrh.mf; v_mr_c2.EXP_UNITS := v_mr_c2.EXP_DIFF * v_mrh.mf;
           if (to_number(v_mr_c2.EXP_DIFF)<0) then
          v_mr_c2.EXP_UNITS :=0;
          end if;
          v_mr_c2.net_units := ROUND(v_mr_c2.EXP_UNITS - v_mr_c2.IMP_UNITS,0) ; if(to_number(v_mr_c2.net_units ) <0) THEN v_mr_c2.net_units := 0; END IF;

          --slot3 changes
          v_mr_c3.IMP_INIT := nvl(v_prev_mr_c3.IMP_INIT,0); v_mr_c3.EXP_INIT := nvl(v_prev_mr_c3.EXP_INIT,0);
          v_mr_c3.IMP_DIFF := v_mr_c3.IMP_FINAL - v_mr_c3.IMP_INIT ;v_mr_c3.EXP_DIFF := v_mr_c3.EXP_FINAL - v_mr_c3.EXP_INIT ;
          v_mr_c3.IMP_UNITS := v_mr_c3.IMP_DIFF * v_mrh.mf; v_mr_c3.EXP_UNITS := v_mr_c3.EXP_DIFF * v_mrh.mf;
          if (to_number(v_mr_c3.EXP_DIFF)<0) then
          v_mr_c3.EXP_UNITS :=0;
          end if;
          v_mr_c3.net_units := ROUND(v_mr_c3.EXP_UNITS - v_mr_c3.IMP_UNITS,0) ; if(to_number(v_mr_c3.net_units ) <0) THEN v_mr_c3.net_units := 0; END IF;  

          --slot4 changes
          v_mr_c4.IMP_INIT := nvl(v_prev_mr_c4.IMP_INIT,0); v_mr_c4.EXP_INIT := nvl(v_prev_mr_c4.EXP_INIT,0);
          v_mr_c4.IMP_DIFF := v_mr_c4.IMP_FINAL - v_mr_c4.IMP_INIT ;v_mr_c4.EXP_DIFF := v_mr_c4.EXP_FINAL - v_mr_c4.EXP_INIT ;
          v_mr_c4.IMP_UNITS := v_mr_c4.IMP_DIFF * v_mrh.mf; v_mr_c4.EXP_UNITS := v_mr_c4.EXP_DIFF * v_mrh.mf;
         if (to_number(v_mr_c4.EXP_DIFF)<0) then
          v_mr_c4.EXP_UNITS :=0;
          end if;
          v_mr_c4.net_units := ROUND(v_mr_c4.EXP_UNITS - v_mr_c4.IMP_UNITS,0) ; if(to_number(v_mr_c4.net_units ) <0) THEN v_mr_c4.net_units := 0; END IF;

          --slot5 changes
          v_mr_c5.IMP_INIT := nvl(v_prev_mr_c5.IMP_INIT,0); v_mr_c5.EXP_INIT := nvl(v_prev_mr_c5.EXP_INIT,0);
          v_mr_c5.IMP_DIFF := v_mr_c5.IMP_FINAL - v_mr_c5.IMP_INIT ;v_mr_c5.EXP_DIFF := v_mr_c5.EXP_FINAL - v_mr_c5.EXP_INIT ;
          v_mr_c5.IMP_UNITS := v_mr_c5.IMP_DIFF * v_mrh.mf; v_mr_c5.EXP_UNITS := v_mr_c5.EXP_DIFF * v_mrh.mf;
          if (to_number(v_mr_c5.EXP_DIFF)<0) then
          v_mr_c5.EXP_UNITS :=0;
          end if;
          v_mr_c5.net_units := ROUND(v_mr_c5.EXP_UNITS - v_mr_c5.IMP_UNITS,0) ; if(to_number(v_mr_c5.net_units ) <0) THEN v_mr_c5.net_units := 0; END IF;  

          -- update summary info in header 
          v_mrh.total_import_gen := v_mr_c1.IMP_UNITS + v_mr_c2.IMP_UNITS + v_mr_c3.IMP_UNITS + v_mr_c4.IMP_UNITS + v_mr_c5.IMP_UNITS;
					v_mrh.total_export_gen := v_mr_c1.EXP_UNITS + v_mr_c2.EXP_UNITS + v_mr_c3.EXP_UNITS + v_mr_c4.EXP_UNITS + v_mr_c5.EXP_UNITS;
					v_mrh.net_gen_units := v_mr_c1.NET_UNITS + v_mr_c2.NET_UNITS + v_mr_c3.NET_UNITS + v_mr_c4.NET_UNITS + v_mr_c5.NET_UNITS;

          ----- modify current meter reading record - end ----
        end if;

				---- -- dbms_output.put_line('all slots- '||v_mrh.id);
				-- intialise PK, FKs for GenStmt and GenSlots
				v_gs.id := T_GEN_STMT_SEQ.nextval;
				v_gs_c1.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c1.T_GEN_STMT_ID := v_gs.id;
				v_gs_c2.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c2.T_GEN_STMT_ID := v_gs.id;
				v_gs_c3.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c3.T_GEN_STMT_ID := v_gs.id;
				v_gs_c4.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c4.T_GEN_STMT_ID := v_gs.id;
				v_gs_c5.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c5.T_GEN_STMT_ID := v_gs.id;

				-- set values in gen stmt
				v_gs.STATUS_CODE := 'CREATED';
				v_gs.M_COMPANY_METER_ID := v_mrh.M_COMPANY_METER_ID ;
				v_gs.T_MR_IDS := v_mrh.M_COMPANY_METER_ID ;
				v_gs.REF_NUMBER := v_gs_process_id;
        --v_gs.gs_batch_id := v_process_id;
				v_gs.mf := v_mrh.mf;
				v_gs.STMT_GEN_DATE := v_created_Date ;
				v_gs.STMT_MONTH :=  v_mrh.READING_MONTH;
				v_gs.STMT_YEAR := v_mrh.READING_YEAR;
				v_gs.INIT_STMT_DT := v_mrh.INIT_READING_DT;
				v_gs.FINAL_STMT_DT := v_mrh.FINAL_READING_DT;
				-- RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL are not relevant currently
				--RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL - IMPORT VALUES 
				v_gs.KVAH_INIT := v_mrh.IMP_KVAH_INIT;
        v_gs.KVAH_FINAL := v_mrh.IMP_KVAH_FINAL;
        v_gs.RKVAH_INIT := v_mrh.IMP_RKVAH_INIT;
        v_gs.RKVAH_FINAL := v_mrh.IMP_RKVAH_FINAL;
				v_gs.KVAH_DIFF := v_mrh.KVAH_DIFF;
				v_gs.KVAH_UNITS := v_mrh.KVAH_UNITS;
				v_gs.RKVAH_DIFF := v_mrh.RKVAH_DIFF;
				v_gs.RKVAH_UNITS := v_mrh.RKVAH_UNITS;
                v_mr_c1.EXP_UNITS := round(v_mr_c1.EXP_UNITS,0); v_mr_c1.IMP_UNITS := round(v_mr_c1.IMP_UNITS,0);v_mr_c1.NET_UNITS := round(v_mr_c1.NET_UNITS,0);
                v_mr_c2.EXP_UNITS := round(v_mr_c2.EXP_UNITS,0); v_mr_c2.IMP_UNITS := round(v_mr_c2.IMP_UNITS,0);v_mr_c2.NET_UNITS := round(v_mr_c2.NET_UNITS,0);
                v_mr_c3.EXP_UNITS := round(v_mr_c3.EXP_UNITS,0); v_mr_c3.IMP_UNITS := round(v_mr_c3.IMP_UNITS,0);v_mr_c3.NET_UNITS := round(v_mr_c3.NET_UNITS,0);
                v_mr_c4.EXP_UNITS := round(v_mr_c4.EXP_UNITS,0); v_mr_c4.IMP_UNITS := round(v_mr_c4.IMP_UNITS,0);v_mr_c4.NET_UNITS := round(v_mr_c4.NET_UNITS,0);
                v_mr_c5.EXP_UNITS := round(v_mr_c5.EXP_UNITS,0); v_mr_c5.IMP_UNITS := round(v_mr_c5.IMP_UNITS,0);v_mr_c5.NET_UNITS := round(v_mr_c5.NET_UNITS,0);

				v_gs.TOTAL_EXPORT_GEN := v_mr_c1.EXP_UNITS+v_mr_c2.EXP_UNITS+v_mr_c3.EXP_UNITS+v_mr_c4.EXP_UNITS+v_mr_c5.EXP_UNITS;
				v_gs.TOTAL_IMPORT_GEN := v_mr_c1.IMP_UNITS+v_mr_c2.IMP_UNITS+v_mr_c3.IMP_UNITS+v_mr_c4.IMP_UNITS+v_mr_c5.IMP_UNITS; 

				v_gs.MR_SOURCE_CODE := meter.SOURCE_CODE ;
                v_gs.M_ORG_ID := meter.M_ORG_ID;
				v_gs.M_COMPANY_ID := meter.M_COMPANY_ID;
				v_gs.M_COMPANY_SERVICE_ID := meter.M_COMPANY_SERVICE_ID;
				v_gs.DISP_COMPANY_NAME := meter.DISP_COMPANY_NAME;
				v_gs.DISP_SERVICE_NUMBER := meter.DISP_SERVICE_NUMBER;
				v_gs.INJECTING_VOLTAGE_CODE := meter.INJECTING_VOLTAGE_CODE;
				v_gs.DISP_ORG_NAME := meter.DISP_ORG_NAME; 
				v_gs.FLOW_TYPE_CODE := meter.FLOW_TYPE_CODE; 
				v_gs.net_generation := v_mr_c1.NET_UNITS+v_mr_c2.NET_UNITS+v_mr_c3.NET_UNITS+v_mr_c4.NET_UNITS+v_mr_c5.NET_UNITS;
				v_gs.C1 := v_mr_c1.NET_UNITS;
				v_gs.C2 := v_mr_c2.NET_UNITS;
				v_gs.C3 := v_mr_c3.NET_UNITS;
				v_gs.C4 := v_mr_c4.NET_UNITS;
				v_gs.C5 := v_mr_c5.NET_UNITS;
				v_gs.disp_fuel_type_code := meter.disp_fuel_type_code;
				v_gs.disp_fuel_type_name := meter.disp_fuel_type_name;
                v_gs.disp_fuel_type_group := meter.disp_fuel_type_group;
                v_gs.COMMISSION_DATE:= meter.COMMISSION_DATE;
                v_gs.IS_REC := meter.IS_REC;
                v_gs.disp_meter_number := meter.disp_meter_number;
                v_gs.disp_total_capacity := meter.disp_total_capacity;
                v_gs.disp_capacity := meter.disp_capacity;
                v_gs.disp_pp_op_status := meter.disp_pp_op_status;
                v_gs.EXCESS_UNIT_TYPE := meter.EXCESS_UNIT_TYPE; 
				v_gs.created_by := v_created_By;
				v_gs.created_dt := SYSDATE;
				v_gs.enabled := 'Y';
				v_gs.TOTAL_CHARGED_AMOUNT := 0; --actual value calculated by calc_gs_charges() 
				v_gs.NET_PAYABLE := 0; --actual value calculated by calc_gs_charges() 
				if(to_number(v_gs.TOTAL_EXPORT_GEN)*0.01 >= to_number(v_gs.RKVAH_UNITS)) THEN
					v_gs.penalty_rate := '0.25';
				ELSE
					v_gs.penalty_rate := '0.50';
				END IF;
                v_stage := '-7-';

                -- if excess_unit_type <> BANKING, clear the banking
                -- important note -even if a service has banking-balance for that month, if the excess_unit_type for that month is not banking, then dont include those units in GS
                -- those pending banking balance will be used later when its eligible.
                if( v_gs.excess_unit_type <> 'BANKING')
                then
                     v_gs_c1.BANKED_BALANCE := 0;
                     v_gs_c2.BANKED_BALANCE := 0;
                     v_gs_c3.BANKED_BALANCE := 0;
                     v_gs_c4.BANKED_BALANCE := 0;
                     v_gs_c5.BANKED_BALANCE := 0;

                end if;
				---- -- dbms_output.put_line('gen stmt - values set');

				SELECT v_mr_c1.SLOT_CODE,v_mr_c1.IMP_INIT, v_mr_c1.IMP_FINAL, v_mr_c1.IMP_DIFF, round(v_mr_c1.IMP_UNITS,0),v_mr_c1.EXP_INIT, v_mr_c1.EXP_FINAL, v_mr_c1.EXP_DIFF, round(v_mr_c1.EXP_UNITS,0), round(meter.bc1,0), round(v_mr_c1.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c1.SLOT_CODE,v_gs_c1.IMP_INIT, v_gs_c1.IMP_FINAL, v_gs_c1.IMP_DIFF, v_gs_c1.IMP_UNITS, v_gs_c1.EXP_INIT, v_gs_c1.EXP_FINAL, v_gs_c1.EXP_DIFF, v_gs_c1.EXP_UNITS, v_gs_c1.BANKED_BALANCE, v_gs_c1.NET_UNITS, v_gs_c1.enabled, v_gs_c1.created_Date
				FROM dual;

				SELECT  v_mr_c2.SLOT_CODE,v_mr_c2.IMP_INIT, v_mr_c2.IMP_FINAL, v_mr_c2.IMP_DIFF, round(v_mr_c2.IMP_UNITS,0), v_mr_c2.EXP_INIT, v_mr_c2.EXP_FINAL, v_mr_c2.EXP_DIFF, round(v_mr_c2.EXP_UNITS,0), round(meter.bc2,0), round(v_mr_c2.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c2.SLOT_CODE,v_gs_c2.IMP_INIT, v_gs_c2.IMP_FINAL, v_gs_c2.IMP_DIFF, v_gs_c2.IMP_UNITS, v_gs_c2.EXP_INIT, v_gs_c2.EXP_FINAL, v_gs_c2.EXP_DIFF, v_gs_c2.EXP_UNITS, v_gs_c2.BANKED_BALANCE, v_gs_c2.NET_UNITS, v_gs_c2.enabled, v_gs_c2.created_Date
				FROM dual;

				SELECT  v_mr_c3.SLOT_CODE,v_mr_c3.IMP_INIT, v_mr_c3.IMP_FINAL, v_mr_c3.IMP_DIFF, round(v_mr_c3.IMP_UNITS,0), v_mr_c3.EXP_INIT, v_mr_c3.EXP_FINAL, v_mr_c3.EXP_DIFF, round(v_mr_c3.EXP_UNITS,0), round(meter.bc3,0), round(v_mr_c3.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c3.SLOT_CODE,v_gs_c3.IMP_INIT, v_gs_c3.IMP_FINAL, v_gs_c3.IMP_DIFF, v_gs_c3.IMP_UNITS, v_gs_c3.EXP_INIT, v_gs_c3.EXP_FINAL, v_gs_c3.EXP_DIFF, v_gs_c3.EXP_UNITS, v_gs_c3.BANKED_BALANCE, v_gs_c3.NET_UNITS, v_gs_c3.enabled, v_gs_c3.created_Date
				FROM dual;

				SELECT  v_mr_c4.SLOT_CODE,v_mr_c4.IMP_INIT, v_mr_c4.IMP_FINAL, v_mr_c4.IMP_DIFF, round(v_mr_c4.IMP_UNITS,0), v_mr_c4.EXP_INIT, v_mr_c4.EXP_FINAL, v_mr_c4.EXP_DIFF, round(v_mr_c4.EXP_UNITS,0), round(meter.bc4,0), round(v_mr_c4.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c4.SLOT_CODE,v_gs_c4.IMP_INIT, v_gs_c4.IMP_FINAL, v_gs_c4.IMP_DIFF, v_gs_c4.IMP_UNITS, v_gs_c4.EXP_INIT, v_gs_c4.EXP_FINAL, v_gs_c4.EXP_DIFF, v_gs_c4.EXP_UNITS, v_gs_c4.BANKED_BALANCE, v_gs_c4.NET_UNITS, v_gs_c4.enabled, v_gs_c4.created_Date
				FROM dual;

				SELECT  v_mr_c5.SLOT_CODE,v_mr_c5.IMP_INIT, v_mr_c5.IMP_FINAL, v_mr_c5.IMP_DIFF, round(v_mr_c5.IMP_UNITS,0), v_mr_c5.EXP_INIT, v_mr_c5.EXP_FINAL, v_mr_c5.EXP_DIFF, round(v_mr_c5.EXP_UNITS,0), round(meter.bc5,0), round(v_mr_c5.NET_UNITS,0), 'Y',sysdate
				INTO  v_gs_c5.SLOT_CODE,v_gs_c5.IMP_INIT, v_gs_c5.IMP_FINAL, v_gs_c5.IMP_DIFF, v_gs_c5.IMP_UNITS, v_gs_c5.EXP_INIT, v_gs_c5.EXP_FINAL, v_gs_c5.EXP_DIFF, v_gs_c5.EXP_UNITS, v_gs_c5.BANKED_BALANCE, v_gs_c5.NET_UNITS, v_gs_c5.enabled, v_gs_c1.created_Date
				FROM dual;


				---- -- dbms_output.put_line('gen stmt slots - insert');

				INSERT INTO  T_GEN_STMT VALUES  v_gs;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c1;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c2;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c3;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c4;
				INSERT INTO  T_GEN_STMT_SLOT VALUES  v_gs_c5;



                 -- -- dbms_output.put_line('gen stmt slots - calling charges');
  --              if(v_gs.disp_fuel_type_group='RE') then
                       v_result := calc_gs_charges(v_gs.id);
               --             end if;



 			 -- -- dbms_output.put_line('gen stmt slots - after charges');

        update t_meter_reading_hdr set gs_batch_id = v_gs_process_id, M_GEN_STMT_ID = v_gs.id where id = v_mr_id;

                             v_stage := '-8-';

        SELECT STMT_MONTH,STMT_YEAR,M_COMPANY_SERVICE_ID INTO v_gen_month,v_gen_year,v_gen_comp_servi_id FROM T_GEN_STMT gen WHERE gen.ID= v_gs.id;

        SELECT pp.PLANT_CLASS_TYPE_CODE,tariff.WEG_GROUP_NAME,tariff.RATE into  v_plant_class_code,v_plant_class_desc,tariff_rates FROM M_POWERPLANT pp
        LEFT JOIN M_TARIFF tariff ON pp.PLANT_CLASS_TYPE_CODE=tariff.WEG_GROUP_CODE 
        LEFT JOIN T_GEN_STMT gen ON pp.m_service_id = gen.M_COMPANY_SERVICE_ID and gen.ID=v_gs.id
        WHERE  gen.M_COMPANY_SERVICE_ID=v_gen_comp_servi_id;

              -- -- dbms_output.put_line('tariff rate- '||tariff_rates);
               -- -- dbms_output.put_line('v_plant_class_code- '||v_plant_class_code);
            -- -- dbms_output.put_line('v_plant_class_desc- '||v_plant_class_desc);
              -- -- dbms_output.put_line('service id- '||v_gen_comp_servi_id);


        select flow_type_code into v_flow_type_code from M_COMPANY_SERVICE where id=v_gen_comp_servi_id;
                -- -- dbms_output.put_line('v_flow_type_code 2-'|| v_flow_type_code );


        UPDATE T_GEN_STMT SET PLANT_CLASS_TYPE_CODE=v_plant_class_code,PLANT_CLASS_TYPE_DESC=v_plant_class_desc,TARIFF_RATE=tariff_rates WHERE ID=v_gs.id;

                        v_stage := '-9-';

--        SELECT companygs.IS_CAPTIVE INTO v_gen_iscaptive FROM V_COMPANY_SERVICE companygs
--        LEFT JOIN T_GEN_STMT gengs ON companygs.M_COMPANY_ID = gengs.M_COMPANY_ID and companygs.IS_CAPTIVE='Y' WHERE gengs.ID=v_gs.id;
--        
--        -- -- dbms_output.put_line('v_gen_iscaptive 2-'|| v_gen_iscaptive );

  --      SELECT COUNT(compgs.IS_CAPTIVE) into v_gen_isstb_count from V_COMPANY_SERVICE  compgs
  --      LEFT JOIN T_GEN_STMT stbgs on compgs.ID = stbgs.M_COMPANY_SERVICE_ID and compgs.M_COMPANY_ID='TNEB' WHERE stbgs.ID=v_gs.id ;



--        -- -- dbms_output.put_line('v_gen_isstb_count-2-'|| v_gen_isstb_count );

        SELECT orggs.CODE INTO v_gen_org_code FROM M_ORG orggs
        LEFT JOIN T_GEN_STMT gengs1 ON orggs.ID = gengs1.M_ORG_ID WHERE gengs1.ID=v_gs.id;

        -- -- dbms_output.put_line('v_gen_org_code-2-'|| v_gen_org_code );

        SELECT codes.VALUE_DESC INTO v_gen_voltage_desc FROM V_CODES codes
        LEFT JOIN T_GEN_STMT gengs2 ON codes.VALUE_CODE=gengs2.INJECTING_VOLTAGE_CODE AND codes.LIST_NAME='Voltage'
        WHERE gengs2.ID=v_gs.id;

      -- -- dbms_output.put_line('v_gen_voltage_desc-2-'|| v_gen_voltage_desc);

--        if ( v_gen_isstb_count) > 0 THEN
--          v_gen_isstb := 'Y'; 
--         ELSE 
--          v_gen_isstb := 'N'; 
--        END IF;

       --nEW mAY NEED CHANGE 
        if (v_flow_type_code='STB') THEN
            v_gen_isstb := 'Y'; 
         ELSE 
          v_gen_isstb := 'N'; 
        END IF;
          -- -- dbms_output.put_line('v_gen_isstb-'|| v_gen_isstb );

        if (v_flow_type_code='IS-CAPTIVE') THEN
           v_gen_iscaptive := 'Y'; 
         ELSE 
          v_gen_iscaptive := 'N'; 
        END IF;
          -- -- dbms_output.put_line('v_flow_type_code-'|| v_flow_type_code );



        --IF(v_gen_isstb_count) > 0 THEN
           v_tariff_net_amount :=  to_number((v_gs.net_generation)* tariff_rates) ;
            -- -- dbms_output.put_line('v_tariff_net_amount- '||v_tariff_net_amount );
           SELECT gs.TOTAL_CHARGED_AMOUNT INTO v_total_charged_amount FROM T_GEN_STMT gs where gs.ID=v_gs.id;
           -- -- dbms_output.put_line('v_total_charged_amoun- '||v_total_charged_amount );
           v_net_payable := v_tariff_net_amount - v_total_charged_amount;
           -- -- dbms_output.put_line('v_net_payable- '||v_net_payable);
        --   ELSE
        --   CONTINUE;
        --END IF;

         -- -- dbms_output.put_line('v_gen_isstb--'|| v_gen_isstb);

        UPDATE T_GEN_STMT SET IS_CAPTIVE=v_gen_iscaptive,IS_STB=v_gen_isstb,DISP_ORG_CODE=v_gen_org_code,INJECTING_VOLTAGE_DESC=v_gen_voltage_desc,TARIFF_NET_AMOUNT=v_tariff_net_amount,NET_PAYABLE = v_net_payable WHERE ID=v_gs.id;


        --select  ss.ID,ss.NAME,ss.TYPE_OF_SS INTO v_gen_ssid, v_gen_ssname,v_gen_sstype  FROM  M_SUBSTATION  ss
        --LEFT JOIN T_GEN_STMT gengs3 ON  ss.M_ORG_ID = gengs3.M_ORG_ID   WHERE gengs3.ID=v_gs.id ;
        --
        --select  ff.ID,ff.NAME INTO v_gen_ffid, v_gen_ffname  FROM  M_FEEDER ff
        --LEFT JOIN T_GEN_STMT gengs4 ON  ff.VOLTAGE_CODE= gengs4.INJECTING_VOLTAGE_CODE  WHERE gengs4.ID=v_gs.id ;
                        v_stage := '-10-';

        select service.M_SUBSTATION_ID,service.M_SUBSTATION_NAME,service.TYPE_OF_SS ,service.M_FEEDER_ID,service.M_FEEDER_NAME INTO v_gen_ssid, v_gen_ssname,v_gen_sstype,v_gen_ffid, v_gen_ffname
        from v_company_service service LEFT JOIN T_GEN_STMT gengs3 ON  service.id = gengs3.M_COMPANY_SERVICE_ID WHERE gengs3.ID=v_gs.id ;

         -- -- dbms_output.put_line('v_gen_ssid- '||v_gen_ssid);  -- -- dbms_output.put_line('v_gen_sstype- '||v_gen_sstype);   -- -- dbms_output.put_line('v_gen_ffname- '||v_gen_ffname);

        UPDATE T_GEN_STMT SET M_SUBSTATION_ID = v_gen_ssid, M_SUBSTATION_NAME = v_gen_ssname,M_FEEDER_ID = v_gen_ffid,M_FEEDER_NAME = v_gen_ffname ,TYPE_OF_SS =v_gen_sstype  WHERE ID=v_gs.id;

				COMMIT;
			exception
			  when others then
			    v_exception_code := SQLCODE;
			    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
			    v_result := 'FAILURE';
			    v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','create_gs_from_mr','EH','Error while processing each meter-reading - '||v_reason,v_result,v_created_By, sysdate,v_mr_id,v_gs_process_id);
			END;
		END LOOP;


       -- ---- -- dbms_output.put_line('all slots- '||v_mrh.id);
		if(v_no_records) THEN
			v_result := 'FAILURE';
            if(v_reason IS NULL OR v_reason ='') then v_reason := 'No records to process'; end if;
		END IF;

        if( V_RESULT != '') THEN
			v_result := 'SUCCESS'; 
		END IF; 

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
	    -- -- -- dbms_output.put_line(v_reason);

      v_log_result := log_activity('PROCEDURE','create_gs_from_mr','EH',v_result,v_reason||v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);
	END;
   <<THE_END>>


      v_log_result := log_activity('PROCEDURE','create_gs_from_mr','End',v_result,v_reason||v_stage,v_created_By, sysdate,v_mr_id,v_gs_process_id);

  COMMIT;

  return V_RESULT; 

END create_gs_from_mr;

/
--------------------------------------------------------
--  DDL for Function CREATE_STB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."CREATE_STB" 
(V_GS_ID VARCHAR2) RETURN VARCHAR2
AS
    V_TR M_TRADE_RELATIONSHIP%ROWTYPE;
    V_GS T_GEN_STMT%ROWTYPE;
    V_ES_USAGESUMMARY T_ES_USAGE_SUMMARY%ROWTYPE;
    V_ES T_ENERGY_SALE%ROWTYPE;
    V_ES_VALUES T_ENERGY_SALE%ROWTYPE;
    V_RESULT VARCHAR(300):='SUCCESS';
    V_EXCEPTION_CODE VARCHAR2(150);
    V_EXCEPTION_MSG  VARCHAR2(150);
    V_ES_ID VARCHAR2(150);
    V_TR_ID VARCHAR2(150);
    V_ES_US_TOTAL VARCHAR2(150);
    V_DATE DATE;
    V_RES M_TRADE_RELATIONSHIP%ROWTYPE;
    V_BUYER_ORGID VARCHAR2(150);
    TR VARCHAR2(150);
    V_COMP_SERV VARCHAR2(150);
    V_SELLER_ORGID VARCHAR2(150);
    V_BUYER_SERVICE_ID VARCHAR2(150);
    V_IS_ES_EXIST_COUNT VARCHAR2(150);
    V_REASON VARCHAR2(200);
    V_TRADE_REL_COUNT VARCHAR2(150);
    V_ES_CONFIRMATION_RESULT VARCHAR2(100);
    V_STB_PMT NUMBER;
    V_GC_CHARGE_CURSOR sys_refcursor ;
    V_ES_CHARGE_CURSOR sys_refcursor ;
    CHARGE_CODE VARCHAR2(200);
    TOTAL_CHARGE VARCHAR2(200);
    V_ES_CHARGE T_ES_CHARGE%ROWTYPE;
    V_TOTAL_AMT_CHARGABLE NUMBER;
    v_log_result varchar(300):='SUCCESS';
BEGIN
   BEGIN
         v_log_result := log_activity('PROCEDURE','CREATE_STB','Start',v_result,v_reason,'', sysdate,V_GS_ID, '', '');

     SELECT TO_DATE(CONCAT(STMT_YEAR,(CONCAT(CONCAT('-',STMT_MONTH),'-01'))),'YYYY-MM-DD'),M_COMPANY_SERVICE_ID,M_ORG_ID  INTO V_DATE,V_COMP_SERV,V_SELLER_ORGID
     FROM T_GEN_STMT WHERE ID=V_GS_ID;
         v_log_result := log_activity('PROCEDURE','CREATE_STB','Start','1',v_reason,'', sysdate,V_GS_ID, '', '');
     V_BUYER_SERVICE_ID := CONCAT('TNEB-',V_SELLER_ORGID);
      v_log_result := log_activity('PROCEDURE','CREATE_STB','Start','2',v_reason,'', sysdate,V_GS_ID, '', '');
     SELECT COUNT(*) INTO V_TRADE_REL_COUNT FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = V_COMP_SERV AND M_BUYER_COMP_SERVICE_ID = V_BUYER_SERVICE_ID AND V_DATE BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
--        -- dbms_output.put_line('V_TRADE_REL_COUNT'||V_TRADE_REL_COUNT);
 v_log_result := log_activity('PROCEDURE','CREATE_STB','Start','V_TRADE_REL_COUNT',V_TRADE_REL_COUNT,'', sysdate,V_GS_ID, '', '');
       IF V_TRADE_REL_COUNT=1 THEN
        SELECT * INTO V_RES FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = V_COMP_SERV AND M_BUYER_COMP_SERVICE_ID = V_BUYER_SERVICE_ID AND V_DATE BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
        SELECT COUNT(*) INTO V_IS_ES_EXIST_COUNT FROM T_ENERGY_SALE WHERE T_GEN_STMT_ID=V_GS_ID AND IS_STB='Y';
--          -- dbms_output.put_line('V_IS_ES_EXIST_COUNT'||V_IS_ES_EXIST_COUNT);
 v_log_result := log_activity('PROCEDURE','CREATE_STB','Start','V_IS_ES_EXIST_COUNT',V_IS_ES_EXIST_COUNT,'', sysdate,V_GS_ID, '', '');
         IF V_IS_ES_EXIST_COUNT = 0 THEN
                SELECT V_RES.C1,V_RES.C2,V_RES.C3,V_RES.C4,V_RES.C5,V_RES.M_SELLER_COMP_SERVICE_ID,V_RES.FROM_DATE,V_RES.TO_DATE
                INTO V_ES.C1,V_ES.C2,V_ES.C3,V_ES.C4,V_ES.C5,V_ES.SELLER_COMP_SERV_ID,V_ES.FROM_DT,V_ES.TO_DT
                FROM M_TRADE_RELATIONSHIP WHERE ID =V_RES.ID;
                SELECT * INTO V_GS FROM T_GEN_STMT WHERE ID = V_GS_ID;
                SELECT V_GS.M_ORG_ID,V_GS.INJECTING_VOLTAGE_CODE,V_GS.STMT_MONTH,V_GS.STMT_YEAR,V_GS.ID
                INTO   V_ES.SELLER_END_ORG_ID,V_ES.INJECTING_VOLTAGE_CODE,V_ES.MONTH,V_ES.YEAR,V_ES.T_GEN_STMT_ID
                FROM DUAL;
                V_ES.ID := T_ENERGY_SALE_SEQ.NEXTVAL||'ES';
                --SET VALUES IN ENERGY-SALE
                V_ES.MULTIPLE_BUYERS :='N';
                V_ES.USAGE_DETAIL_AVAIL :='N';
                V_ES.SIMPLE_ENERGY_SALE :='N';
                V_ES.IS_STB :='Y';
                V_ES.STATUS_CODE :='CREATED';

                IF TO_NUMBER(V_GS.C1)  > TO_NUMBER(V_RES.C1)  THEN
                V_ES.C1 := V_RES.C1;
                ELSE
                V_ES.C1 := V_GS.C1;
                END IF;

                IF TO_NUMBER(V_GS.C2)  > TO_NUMBER(V_RES.C2)   THEN
                V_ES.C2 := V_RES.C2;
                ELSE
                V_ES.C2 := V_GS.C2;
                END IF;

                IF TO_NUMBER(V_GS.C3)  > TO_NUMBER(V_RES.C3)   THEN
                V_ES.C3:=V_RES.C3;
                ELSE
                V_ES.C3:=V_GS.C3;
                END IF;


                IF TO_NUMBER(V_GS.C4)  > TO_NUMBER(V_RES.C4)   THEN
                V_ES.C4 := V_RES.C4;
                ELSE
                V_ES.C4 := V_GS.C4;
                END IF;

                IF TO_NUMBER(V_GS.C5)  > TO_NUMBER(V_RES.C5)   THEN
                V_ES.C5 := V_RES.C5;
                ELSE
                V_ES.C5 := V_GS.C5;
                END IF;

                INSERT INTO T_ENERGY_SALE VALUES V_ES;

                SELECT CONCAT('TNEB-',SELLER_END_ORG_ID) INTO V_BUYER_ORGID
                FROM T_ENERGY_SALE  WHERE T_GEN_STMT_ID=V_GS_ID;

                SELECT * INTO V_ES_VALUES FROM T_ENERGY_SALE WHERE T_GEN_STMT_ID = V_GS_ID;
                V_TOTAL_AMT_CHARGABLE:=0;
                INSERT INTO t_es_charge (ID, T_ENERGY_SALE_ID,M_COMP_SERV_ID,CHARGE_CODE,TOTAL_CHARGE  )
                (SELECT T_ES_CHARGE_SEQ.NEXTVAL||'ESC' ID, V_ES.ID T_ENERGY_SALE_ID, V_ES.SELLER_COMP_SERV_ID M_COMP_SERV_ID, CHARGE_CODE,NVL(TOTAL_CHARGES,0) FROM T_GEN_STMT_CHARGE  WHERE T_GEN_STMT_ID = V_GS_ID);

                SELECT SUM(TOTAL_CHARGE) INTO V_TOTAL_AMT_CHARGABLE FROM t_es_charge WHERE M_COMP_SERV_ID = V_ES.SELLER_COMP_SERV_ID;
                V_ES_US_TOTAL := V_ES_VALUES.C1 +V_ES_VALUES.C2+V_ES_VALUES.C3+V_ES_VALUES.C4+V_ES_VALUES.C5;
                SELECT V_ES_VALUES.C1,V_ES_VALUES.C2,V_ES_VALUES.C3,V_ES_VALUES.C4,V_ES_VALUES.C5,V_BUYER_ORGID,V_ES_VALUES.SELLER_END_ORG_ID,V_ES_VALUES.ID,V_ES_US_TOTAL
                INTO V_ES_USAGESUMMARY.C1,V_ES_USAGESUMMARY.C2,V_ES_USAGESUMMARY.C3,V_ES_USAGESUMMARY.C4,V_ES_USAGESUMMARY.C5,V_ES_USAGESUMMARY.BUYER_COMP_SERV_ID,V_ES_USAGESUMMARY.BUYER_END_ORG_ID,V_ES_USAGESUMMARY.T_ENERGY_SALE_ID,V_ES_USAGESUMMARY.TOTAL
                FROM DUAL;

                V_STB_PMT :=STB_PMT_CALC(V_GS_ID);
                V_ES_USAGESUMMARY.UNIT_COST :=V_STB_PMT ;
                V_ES_USAGESUMMARY.TOTAL_AMOUNT_PAYABLE:=V_STB_PMT*V_ES_US_TOTAL;
                V_ES_USAGESUMMARY.TOTAL_AMOUNT_CHARGABLE:=V_TOTAL_AMT_CHARGABLE;
               V_ES_USAGESUMMARY.NET_AMOUNT_PAYABLE:=V_ES_USAGESUMMARY.TOTAL_AMOUNT_PAYABLE - V_TOTAL_AMT_CHARGABLE;
                V_ES_USAGESUMMARY.ID := T_ES_USAGE_SUMMARY_SEQ.NEXTVAL||'ESU';
                V_ES_USAGESUMMARY.M_TRADE_RELATIONSHIP_ID:=V_RES.id;

                INSERT INTO T_ES_USAGE_SUMMARY VALUES V_ES_USAGESUMMARY;
                --V_RESULT := CREATE_STB(V_ES.ID);

                V_GS.STATUS_CODE:='PART_ALLOC';

                UPDATE T_GEN_STMT SET STATUS_CODE=V_GS.STATUS_CODE  WHERE ID = V_GS_ID;
                V_ES_CONFIRMATION_RESULT :=ENERGY_SALE_CONFIRMATION(V_ES.ID);
        ELSE
        V_REASON    := 'STB ENERGY SALE ALREADY EXIST';
        V_RESULT    := 'FAILURE';
        GOTO THE_END;
        END IF;
    ELSE
    V_REASON    := 'NO ACTION';
    V_RESULT    := 'FAILURE';
    GOTO THE_END;
    END IF;
      EXCEPTION
              WHEN OTHERS THEN
                V_EXCEPTION_CODE := SQLCODE;
                V_EXCEPTION_MSG  := SUBSTR(SQLERRM, 1, 100);
                V_RESULT := 'FAILURE' || ' - ' || V_EXCEPTION_CODE || ' - ' || V_EXCEPTION_MSG;
--                -- dbms_output.put_line('ISSUE IN CREATE_STB-'||V_RESULT);
 v_log_result := log_activity('PROCEDURE','CREATE_STB','EXCEPTION',V_RESULT,V_EXCEPTION_MSG,'', sysdate,'');
 END;
 <<THE_END>>
IF V_RESULT = 'SUCCESS' THEN
  COMMIT;
ELSE
  v_result := v_result || ' - ' || v_reason;
END IF;
RETURN V_RESULT;
END CREATE_STB;


/
--------------------------------------------------------
--  DDL for Function DBMS_CATOWNER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DBMS_CATOWNER" RETURN VARCHAR2 AUTHID DEFINER IS
   u varchar2(128);
begin
   select username into u from user_users;
   return u;
end;


/
--------------------------------------------------------
--  DDL for Function DELETE_ADD_COMMERCIALS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_ADD_COMMERCIALS" 
(
  V_REMARKS IN VARCHAR2 
) RETURN VARCHAR2 AS 

v_imp_trade_rel_cursor sys_refcursor ;
v_imp_trade_count NUMBER;
v_service_number_count NUMBER;
v_commercials_trade IMPORT_TRADE_REL%ROWTYPE;
v_service_number varchar2(50);
v_number varchar2(50);

v_log_result  varchar2(50);
v_created_by varchar2(100):='Admin';
v_result_code varchar2(100);
v_result_desc varchar2(300);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result VARCHAR(200):='SUCCESS';
v_trade_remarks varchar2(100);
v_missing_fields_count number:=0;
BEGIN



    BEGIN --Exception starts here
    v_log_result := log_activity('PROCEDURE','DELETE_ADD_COMMERCIALS','START','for Remarks - '||V_REMARKS,'RUNNING',v_created_by, sysdate,'');


    IF(V_REMARKS IS NULL OR V_REMARKS = '') THEN
        v_reason   := 'Remarks is mandatory';
        v_result   := 'FAILURE';
        GOTO THE_END;
    else
        update IMPORT_TRADE_REL set SELLER_COMPANY_NAME=trim(SELLER_COMPANY_NAME),SELLER_END_EDC=trim(SELLER_END_EDC),SELLER_COMPANY_SERVICE_NO=trim(SELLER_COMPANY_SERVICE_NO), BUYER_COMPANY_SERVICE_NO=trim(BUYER_COMPANY_SERVICE_NO), remarks ='', status_Code='', result='', result_desc='' WHERE IMPORT_REMARKS=V_REMARKS;
    END IF;

    select COUNT(*) INTO v_missing_fields_count FROM IMPORT_TRADE_REL WHERE IMPORT_REMARKS=V_REMARKS
    and (SELLER_COMPANY_NAME is null or SELLER_END_EDC is null or SELLER_COMPANY_SERVICE_NO is null or BUYER_COMPANY_SERVICE_NO is null or FROM_DATE_STR is null or TO_DATE_STR is null or QUANTUM is null or flow_type_code is null) ;


    IF(v_missing_fields_count IS NULL OR v_missing_fields_count = '') THEN
        v_reason   := 'SELLER_COMPANY_NAME, SELLER_END_EDC, SELLER_COMPANY_SERVICE_NO, BUYER_COMPANY_SERVICE_NO, FROM_DATE_STR, TO_DATE_STR, QUANTUM, flow_type_code are mandatory ';
        v_result   := 'FAILURE';
        GOTO THE_END;
    END IF;

	SELECT COUNT(*) INTO v_imp_trade_count FROM IMPORT_TRADE_REL WHERE IMPORT_REMARKS=V_REMARKS;
    SELECT count(distinct SELLER_COMPANY_SERVICE_NO) INTO v_service_number_count FROM IMPORT_TRADE_REL WHERE IMPORT_REMARKS=V_REMARKS;
    v_log_result := log_activity('PROCEDURE','DELETE_ADD_COMMERCIALS','FINDING-RECORDS','','','', sysdate,'COMMERCIALS-COUNT-'||v_imp_trade_count,'SERVICES-COUNT-'||v_service_number_count);   

	IF(v_imp_trade_count >=1) THEN

	OPEN v_imp_trade_rel_cursor for SELECT distinct SELLER_COMPANY_SERVICE_NO FROM IMPORT_TRADE_REL WHERE IMPORT_REMARKS=V_REMARKS;
    LOOP
    BEGIN --Exception inside Loop
        FETCH v_imp_trade_rel_cursor INTO v_number;
        EXIT WHEN v_imp_trade_rel_cursor%NOTFOUND;
        v_log_result := log_activity('PROCEDURE','DELETE_ADD_COMMERCIALS','LOOP','Start -'||v_number,v_result||'-'||v_reason,'', sysdate,'REMARKS-'||v_remarks,'loop-for-service-'||v_number);
        v_result := DELETE_COMMERCIALS(v_number,V_REMARKS);
        if(v_result like 'FAILURE%' ) then
           v_result_desc :='RELS NOT DELETED';
           update IMPORT_TRADE_REL set result=v_result, result_Desc=v_result_desc where IMPORT_REMARKS=V_REMARKS and SELLER_COMPANY_SERVICE_NO = v_number;
        else
            v_result := ADD_COMMERCIALS(v_number,V_REMARKS);
        end if;

        view_refresh.COMP_SERV_REFRESH(V_SERVICE_NUMBER, v_result_code, v_result_desc);

    EXCEPTION
    WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 200);
    v_result         := 'FAILURE' || ' - ' || v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','DELETE_ADD_COMMERCIALS','Loop','Exception - '||v_exception_code,v_result,'',sysdate,V_REMARKS,v_service_number);
    END;
	END LOOP;
	END IF;

    EXCEPTION
      WHEN OTHERS THEN 
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
        -- dbms_output.put_line(v_result_desc);
      END;
      <<THE_END>>
      COMMIT;
      v_log_result := log_activity('PROCEDURE','DELETE_ADD_COMMERCIALS','RESULT',v_result_code,v_result_desc,v_created_by, sysdate,V_REMARKS);


  RETURN v_result;
END DELETE_ADD_COMMERCIALS;

/
--------------------------------------------------------
--  DDL for Function DELETE_ALL_ADJUSTMENT_RECORDS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_ALL_ADJUSTMENT_RECORDS" RETURN VARCHAR2 AS
BEGIN

DELETE FROM F_ENERGY_CHARGES;
DELETE FROM F_ENERGY_LEDGER;
DELETE FROM F_ENERGY_SALE_ORDER_LINES;
DELETE FROM F_ENERGY_SALE_ORDER;
DELETE FROM T_ES_CHARGE;
DELETE FROM T_ES_USAGE_DETAIL;
DELETE FROM T_ES_USAGE_SUMMARY;
DELETE FROM T_ENERGY_SALE;
DELETE FROM T_GEN_STMT_CHARGE;
DELETE FROM T_GEN_STMT_SLOT;
DELETE FROM T_GEN_STMT;
--DELETE FROM T_METER_READING_SLOT;
--DELETE FROM T_METER_READING_HDR;
DELETE FROM T_PROCESS_GS;
delete from IMP_MR_LINES;
DELETE  from IMP_MR_HEADER;
COMMIT;

return 'SUCCESS';
END DELETE_ALL_ADJUSTMENT_RECORDS;

/
--------------------------------------------------------
--  DDL for Function DELETE_ALL_GRID_CONNECTIVITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_ALL_GRID_CONNECTIVITY" RETURN VARCHAR2 AS
BEGIN


  DELETE FROM  T_GC_TRANSFORMERS;
  DELETE FROM  T_GC_APPLICATION_STATUS;
  DELETE FROM  T_GC_LOAN ;
  DELETE FROM  T_GC_ID_TABLEA;
  DELETE FROM  T_GC_ID_TABLEB;
  DELETE FROM  T_GC_QUANTUM_ALLOCATION;
  DELETE FROM  T_GC_CHECKLIST;
  DELETE FROM  T_GC_GEN_UNIT;
  DELETE FROM  T_GRID_CONN_APPLN ;
  DELETE FROM  T_GRID_CONNECTIVITY ;



 COMMIT;

 return 'SUCCESS';
 END DELETE_ALL_GRID_CONNECTIVITY ;


/
--------------------------------------------------------
--  DDL for Function DELETE_ALL_MASTER_RECORDS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_ALL_MASTER_RECORDS" RETURN VARCHAR2 AS
BEGIN

 DELETE FROM T_OAA;
 DELETE FROM F_AGREEMENT_LINE;
 DELETE FROM F_AGREEMENT;
 DELETE FROM T_EWA_LINE;
 DELETE FROM T_EWA;
 DELETE FROM T_STANDING_CLEARENCE;
 DELETE FROM T_EPA_LINES;
 DELETE FROM T_EPA ;
 DELETE FROM T_PPA;
 DELETE FROM T_CONSENT;
 DELETE FROM T_NOC_GENERATOR_LINE;
 DELETE FROM T_NOC_GENERATOR;
 DELETE FROM T_NOC;
 DELETE FROM T_INPRINCIPLE_APPLN_LINE;
 DELETE FROM T_INPRINCIPLE_APPLN;
 DELETE FROM T_ES_INTENT_LINE;
 DELETE FROM T_ES_INTENT;
 DELETE FROM T_CS_ID_TABLEA;
 DELETE FROM T_CS_ID_TABLEB;
 DELETE FROM T_CS_LOAN;
 DELETE FROM T_CS_QUANTUM_ALLOCATION;
 DELETE FROM T_CS;
 DELETE FROM M_TRADE_RELATIONSHIP;
 DELETE FROM M_GENERATOR ;
 DELETE FROM M_POWERPLANT ;
 DELETE FROM T_COMPANY_NAME_CHANGE;
 DELETE FROM T_COMPANY_METER_CHANGE;

 DELETE FROM M_COMPANY_SHAREHOLDER;
 DELETE FROM M_COMPANY_METER where id in (select M_COMPANY_METER_ID FROM V_COMPANY_SERVICE WHERE COMP_SER_TYPE_CODE = '03' AND NOT (m_company_code = 'IEX' OR m_company_code = 'TNEB'));
 DELETE FROM M_COMPANY_SERVICE where id in  (select id FROM V_COMPANY_SERVICE WHERE COMP_SER_TYPE_CODE = '03' AND NOT (m_company_code = 'IEX' OR m_company_code = 'TNEB'));
 DELETE FROM M_COMPANY where id in  (select M_COMPANY_ID FROM V_COMPANY_SERVICE WHERE COMP_SER_TYPE_CODE = '03' AND NOT (m_company_code = 'IEX' OR m_company_code = 'TNEB'));

 UPDATE M_SIGNUP SET IS_COMPLETE = 'N' WHERE PURPOSE = '02';

 COMMIT;

 return 'SUCCESS';
 END DELETE_ALL_MASTER_RECORDS;


/
--------------------------------------------------------
--  DDL for Function DELETE_BY_SERVICE_CALL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_BY_SERVICE_CALL" 
(
  I_REMARKS IN VARCHAR2 , 
  I_SERVICE_NUMBER IN VARCHAR2 , 
  I_READING_MONTH IN VARCHAR2 , 
  I_READING_YEAR IN VARCHAR2 


) RETURN VARCHAR2 AS 

v_result1 varchar(300):='SUCCESS';
v_result2 varchar(300):='SUCCESS';
I_DEL_LEDGER  boolean:=TRUE; 
I_DEL_ES boolean :=TRUE; 
I_DEL_GS  boolean :=TRUE; 
I_DEL_MR  boolean :=TRUE; 

BEGIN
 DELETE_TXN.DELETE_BY_SERVICE(I_REMARKS,I_SERVICE_NUMBER,I_READING_MONTH,I_READING_YEAR,'Y','Y','Y','Y',v_result1,v_result2);

return v_result1;

END DELETE_BY_SERVICE_CALL;


/
--------------------------------------------------------
--  DDL for Function DELETE_COMMERCIALS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_COMMERCIALS" 
(
  V_SERVICE_NUMBER IN VARCHAR2,
    V_REMARKS IN VARCHAR2 

) RETURN VARCHAR2 AS

v_seller_company_service_id varchar2(50);
v_f_agreement_id varchar2(50);
v_f_agreement_count varchar2(50);
v_t_oaa_count varchar2(50);
v_ewa_id varchar2(50);
v_ewa_count varchar2(50);
v_epa_id varchar2(50);
v_epa_count varchar2(50);
v_agreement_cursor sys_refcursor ;
v_ewa_cursor sys_refcursor ;
v_created_by varchar2(100):='Admin';
v_result VARCHAR(200):='SUCCESS';
v_result_code varchar2(100);
v_result_desc varchar2(300);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_log_result  varchar2(50);
v_trade_count varchar2(50);


BEGIN

    BEGIN --EXCEPTION STARTS HERE
    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','START','FOR SERVICE- '||V_SERVICE_NUMBER,'STARTED',v_created_by, sysdate,'');

	--Getting servive ID from service number
	SELECT ID INTO v_seller_company_service_id FROM M_COMPANY_SERVICE WHERE "number"=V_SERVICE_NUMBER;

    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','001','FOR SERVICE- '||v_seller_company_service_id,'PROCESSING',v_created_by, sysdate,'');

	--Finding and deleting records

	--f_agreement and f_agreement_lines
	SELECT COUNT(*) INTO v_f_agreement_count FROM F_AGREEMENT WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
	IF(v_f_agreement_count >= '1') THEN
--    -- dbms_output.put_line('AGREEMENT EXISTS FOR DELETION -' || v_f_agreement_count);
	OPEN v_agreement_cursor for SELECT ID FROM F_AGREEMENT WHERE SELLER_COMP_SERV_ID = v_seller_company_service_id;
    LOOP 
    FETCH v_agreement_cursor INTO v_f_agreement_id;
	EXIT WHEN v_agreement_cursor%NOTFOUND;
	DELETE FROM F_AGREEMENT_LINE WHERE F_AGREEMENT_ID=v_f_agreement_id;
	END LOOP;
	DELETE FROM F_AGREEMENT WHERE SELLER_COMP_SERV_ID = v_seller_company_service_id;
--    ELSE
--    -- dbms_output.put_line('Agreement EXISTS IS -' || v_f_agreement_count || '-NO DELETION');
	END IF;

    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','002','FOR SERVICE- '||v_seller_company_service_id,'PROCESSING',v_created_by, sysdate,'');

	--t_oaa
	SELECT COUNT(*) INTO v_t_oaa_count FROM T_OAA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
	IF(v_t_oaa_count >='1') THEN 
--    -- dbms_output.put_line('OAA EXISTS FOR DELETION -' || v_t_oaa_count);
	DELETE FROM T_OAA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
--    ELSE
--    -- dbms_output.put_line('OAA EXISTS IS -' || v_t_oaa_count || '-NO DELETION');
	END IF;
    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','003','FOR SERVICE- '||v_seller_company_service_id,'PROCESSING',v_created_by, sysdate,'');

	--t_ewa and t_ewa_line
	SELECT COUNT(*) INTO v_ewa_count FROM T_EWA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
	IF(v_ewa_count>='1') THEN
--    -- dbms_output.put_line('EWA EXISTS FOR DELETION -' || v_ewa_count);
    --EWA LOOP STARTS
    OPEN v_ewa_cursor FOR SELECT ID FROM T_EWA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
    LOOP
    FETCH v_ewa_cursor INTO v_ewa_id;
    EXIT WHEN v_ewa_cursor%NOTFOUND;
    DELETE FROM T_EWA_LINE WHERE T_EWA_ID=v_ewa_id;
    END LOOP;
	DELETE FROM T_EWA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
--    ELSE
--    -- dbms_output.put_line('EWA EXISTS IS -' || v_ewa_count || '-NO DELETION');
	END IF;
    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','004','FOR SERVICE- '||v_seller_company_service_id,'PROCESSING',v_created_by, sysdate,'');

	--t_epa and t_epa_line
	SELECT COUNT(*) INTO v_epa_count FROM T_EPA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
	IF(v_epa_count>=1) THEN
--    -- dbms_output.put_line('EPA EXISTS FOR DELETION -' || v_epa_count);
    FOR epa IN (SELEct id FROM T_EPA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id)
    loop
        DELETE FROM T_EPA_LINES WHERE T_EPA_ID=epa.id;
        DELETE FROM T_EPA WHERE id = epa.id;
    end loop;
     
	
--    ELSE
--    -- dbms_output.put_line('EPA EXISTS IS -' || v_epa_count || '-NO DELETION');
	END IF;

        v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','005','FOR SERVICE- '||v_seller_company_service_id,'PROCESSING',v_created_by, sysdate,'');

    select count(*) into v_trade_count from M_TRADE_RELATIONSHIP where M_SELLER_COMP_SERVICE_ID=v_seller_company_service_id;
    if(v_trade_count>='1')then
    delete from M_TRADE_RELATIONSHIP where M_SELLER_COMP_SERVICE_ID=v_seller_company_service_id;
    end if;
    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','006','FOR SERVICE- '||v_seller_company_service_id,'PROCESSING',v_created_by, sysdate,'');
    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS','007','FOR SERVICE- '||V_SERVICE_NUMBER,'PROCESSING',v_created_by, sysdate,'');


    EXCEPTION
    WHEN OTHERS THEN 
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
        -- dbms_output.put_line(v_result_desc);
    END;
    <<THE_END>>
    COMMIT;
    v_log_result := log_activity('PROCEDURE','DELETE_COMMERCIALS',v_result,v_result_code,v_result_desc,v_created_by, sysdate,V_SERVICE_NUMBER);

 RETURN v_result;
END DELETE_COMMERCIALS;

/
--------------------------------------------------------
--  DDL for Function DELETE_MASTER_BY_REMARKS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_MASTER_BY_REMARKS" 
(
  V_REMARKS IN VARCHAR2 
) RETURN VARCHAR2 AS 

v_master_cursor sys_refcursor ;
service_num varchar2(100);
v_result VARCHAR(200):='SUCCESS';

BEGIN

    OPEN v_master_cursor for SELECT SERVICE_NO FROM SERVICEMASVIEW WHERE VOLTAGE=V_REMARKS;
    LOOP 
    FETCH v_master_cursor INTO service_num;
	EXIT WHEN v_master_cursor%NOTFOUND;
    v_result := DELETE_MASTER_WITH_SER_NUMBER(service_num);
	END LOOP;

  RETURN v_result;
END DELETE_MASTER_BY_REMARKS;

/
--------------------------------------------------------
--  DDL for Function DELETE_MASTER_LEVEL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_MASTER_LEVEL" 
(
  v_service_number IN VARCHAR2 
) RETURN VARCHAR2 AS 
v_service_id varchar2(50);
v_meter_id varchar2(50);
v_meter_hdr_count varchar2(50);
v_meter_slot varchar2(50);
v_meter_cursor sys_refcursor;
v_t_meter_hdr_id varchar2(50);
v_gen_stmt_count varchar2(50);
v_gen_stmt_cursor sys_refcursor;
v_gen_stmt_id varchar2(50);
v_energy_sale_count varchar2(50);
v_energy_sale_id varchar2(50);
v_es_charge_count varchar2(50);
v_energy_sale_order_count varchar2(50);
v_energy_sale_order_id varchar2(50);
v_energy_charge_count varchar2(50);
v_energy_sale_order_lines_count varchar2(50);
v_energy_ledger_count varchar2(50);

BEGIN

SELECT  ID INTO v_service_id FROM M_COMPANY_SERVICE WHERE "number" =v_service_number;


SELECT id into v_energy_sale_id from T_ENERGY_SALE where SELLER_COMP_SERV_ID=v_service_id;

SELECT id into v_energy_sale_order_id from F_ENERGY_SALE_ORDER where T_ENERGY_SALE_ID=v_energy_sale_id;

SELECT COUNT(*) INTO v_energy_charge_count FROM F_ENERGY_CHARGES WHERE F_ENERGY_SALE_ORDER_ID=v_energy_sale_order_id;
    IF(v_energy_charge_count >'0') THEN 
    DELETE FROM F_ENERGY_CHARGES WHERE F_ENERGY_SALE_ORDER_ID=v_energy_sale_order_id;
    END IF;

SELECT COUNT(*) INTO v_energy_sale_order_lines_count FROM F_ENERGY_SALE_ORDER_LINES WHERE F_ENERGY_SALE_ORDER_ID=v_energy_sale_order_id;
    IF(v_energy_sale_order_lines_count >'0') THEN 
    DELETE FROM F_ENERGY_SALE_ORDER_LINES WHERE F_ENERGY_SALE_ORDER_ID=v_energy_sale_order_id;
    END IF;

SELECT COUNT(*) INTO v_energy_ledger_count FROM F_ENERGY_LEDGER WHERE F_ENERGY_SALE_ORDER_ID=v_energy_sale_order_id;
    IF(v_energy_ledger_count >'0') THEN 
    DELETE FROM F_ENERGY_LEDGER WHERE F_ENERGY_SALE_ORDER_ID=v_energy_sale_order_id;
    END IF;

RETURN 'success';
END DELETE_MASTER_LEVEL;

/
--------------------------------------------------------
--  DDL for Function DELETE_MASTER_WITH_SER_NUMBER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_MASTER_WITH_SER_NUMBER" 
(
  V_SERVICE_NUMBER IN VARCHAR2 
) RETURN VARCHAR2 AS 
v_process varchar2(50):='DELETE_MASTER_WITH_SER_NUMBER';
v_process_type varchar2(50):='FUNCTION';
v_result_code  varchar2(50):='FAILURE';
v_result_desc  varchar2(300):='';
v_log_result   varchar2(300):='';
v_master_cursor sys_refcursor ;
service_num varchar2(100);

v_seller_company_service_id varchar2(50);
v_f_agreement_id varchar2(50);
v_f_agreement_count varchar2(50);
v_t_oaa_count varchar2(50);
v_ewa_id varchar2(50);
v_ewa_count varchar2(50);
v_epa_id varchar2(50);
v_intent_id varchar2(50);
--v_noc_gen_id varchar2(50);
v_epa_count varchar2(50);
v_agreement_cursor sys_refcursor ;
v_ewa_cursor sys_refcursor ;
v_trade_count varchar2(50);
v_powerplant_id varchar2(50);
v_company_id varchar2(50);
v_signup_id varchar2(50);
v_service_count varchar2(50);
v_signup_count varchar2(50);
v_pp_count varchar2(50);
v_intent_count varchar2(50);
BEGIN
BEGIN    
    v_log_result := log_activity(v_process_type,v_process,'Start','','','', '',V_SERVICE_NUMBER);

    SELECT count(*) INTO v_service_count FROM M_COMPANY_SERVICE WHERE "number"=V_SERVICE_NUMBER;
    IF(v_service_count>0) THEN

    --OPEN v_master_cursor for SELECT id FROM M_COMPANY_SERVICE WHERE "number"=V_SERVICE_NUMBER;
    --LOOP 
    --FETCH v_master_cursor INTO v_seller_company_service_id;


        SELECT ID INTO v_seller_company_service_id FROM M_COMPANY_SERVICE WHERE "number"=V_SERVICE_NUMBER;


        SELECT COUNT(*) INTO v_f_agreement_count FROM F_AGREEMENT WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;

        IF(v_f_agreement_count >= '1') THEN
      OPEN v_agreement_cursor for SELECT ID FROM F_AGREEMENT WHERE SELLER_COMP_SERV_ID = v_seller_company_service_id;
        LOOP 
        FETCH v_agreement_cursor INTO v_f_agreement_id;
        EXIT WHEN v_agreement_cursor%NOTFOUND;
        DELETE FROM F_AGREEMENT_LINE WHERE F_AGREEMENT_ID=v_f_agreement_id;
        END LOOP;
        DELETE FROM F_AGREEMENT WHERE SELLER_COMP_SERV_ID = v_seller_company_service_id;
        END IF;


        SELECT COUNT(*) INTO v_t_oaa_count FROM T_OAA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        IF(v_t_oaa_count >='1') THEN 
        DELETE FROM T_OAA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        END IF;

        SELECT COUNT(*) INTO v_ewa_count FROM T_EWA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        IF(v_ewa_count>='1') THEN

        OPEN v_ewa_cursor FOR SELECT ID FROM T_EWA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        LOOP
        FETCH v_ewa_cursor INTO v_ewa_id;
        EXIT WHEN v_ewa_cursor%NOTFOUND;
        DELETE FROM T_EWA_LINE WHERE T_EWA_ID=v_ewa_id;
        END LOOP;
        DELETE FROM T_EWA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        END IF;

        SELECT COUNT(*) INTO v_epa_count FROM T_EPA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        IF(v_epa_count>='1') THEN
        SELECT ID INTO v_epa_id FROM T_EPA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        DELETE FROM T_EPA_LINES WHERE T_EPA_ID=v_epa_id;
        DELETE FROM T_EPA WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
        END IF;


        DELETE FROM T_CONSENT WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
    --    SELECT COUNT(*) INTO v_intent_count FROM T_ES_INTENT WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
    --    IF(v_intent_count>='0') THEN
    --    SELECT ID INTO v_intent_id FROM T_ES_INTENT WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
    ----    SELECT ID INTO v_noc_gen_id FROM T_NOC_GENERATOR WHERE T_ES_INTENT_ID=v_intent_id;
    ----    DELETE T_NOC_GENERATOR_LINE WHERE T_NOC_GENERATOR_ID=v_noc_gen_id;
    ----    DELETE T_NOC_GENERATOR WHERE T_ES_INTENT_ID=v_intent_id;
    ----    DELETE T_NOC WHERE T_ES_INTENT_ID=v_intent_id;
    --    DELETE T_ES_INTENT_LINE WHERE T_EST_INTENT_ID=v_intent_id;
    --    DELETE T_ES_INTENT WHERE SELLER_COMP_SERV_ID=v_seller_company_service_id;
    --    END IF;

        select count(*) into v_trade_count from M_TRADE_RELATIONSHIP where M_SELLER_COMP_SERVICE_ID=v_seller_company_service_id;
        if(v_trade_count>='1')then
        delete from M_TRADE_RELATIONSHIP where M_SELLER_COMP_SERVICE_ID=v_seller_company_service_id;
        end if;

    --Master

    SELECT count(*) into v_pp_count FROM M_POWERPLANT WHERE M_SERVICE_ID=v_seller_company_service_id;
      IF(v_pp_count>0) THEN
        SELECT id into v_powerplant_id FROM M_POWERPLANT WHERE M_SERVICE_ID=v_seller_company_service_id;
        DELETE FROM M_GENERATOR WHERE M_POWERPLANT_ID=v_powerplant_id;
      ELSE
          v_log_result := log_activity(v_process_type,v_process,'Service-Check','POWERPLANT DOES NOT EXIST - COUNT = ' || v_signup_count,'','', '',V_SERVICE_NUMBER);
      END IF;

    DELETE FROM M_POWERPLANT WHERE M_SERVICE_ID=v_seller_company_service_id;
    DELETE FROM M_COMPANY_METER WHERE M_COMPANY_SERVICE_ID=v_seller_company_service_id;

    SELECT M_COMPANY_ID into v_company_id FROM M_COMPANY_SERVICE WHERE ID=v_seller_company_service_id;
    DELETE FROM M_COMPANY_SERVICE WHERE ID=v_seller_company_service_id;

    DELETE FROM M_COMPANY WHERE ID=v_company_id;


    SELECT count(*) into v_signup_count FROM M_SIGNUP WHERE HTSC_NUMBER=V_SERVICE_NUMBER;

      if(v_signup_count>0) THEN
        SELECT id into v_signup_id FROM M_SIGNUP WHERE HTSC_NUMBER=V_SERVICE_NUMBER;
        DELETE M_SIGNUP_TRADE_REL WHERE M_SIGNUP_ID=v_signup_id;
        DELETE M_SIGNUP WHERE HTSC_NUMBER=V_SERVICE_NUMBER;
      ELSE
        v_log_result := log_activity(v_process_type,v_process,'Signup-Check','SIGNUP DOES NOT EXIST','','', '',V_SERVICE_NUMBER);
      END IF;

    DELETE FROM AUTH_USER WHERE USER_NAME=V_SERVICE_NUMBER;
    COMMIT;
    v_result_code :='SUCCESS';
    v_result_desc := '';

    v_log_result := log_activity(v_process_type,v_process,'Complete','calling service refresh',v_result_code,'', '',V_SERVICE_NUMBER);

    view_refresh.COMP_SERV_REFRESH(V_SERVICE_NUMBER,v_result_code, v_result_desc);

    ELSE
        v_log_result := log_activity(v_process_type,v_process,'Service-Check','SERVICE NUMBER DOES NOT EXIST','','', '',V_SERVICE_NUMBER);

    END IF;
exception
  when others then
    v_result_code := 'FAILURE';
    v_result_desc := SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
    v_log_result := log_activity(v_process_type,v_process,'EH','Exception - '||v_result_desc,v_result_code,v_result_desc, sysdate,V_SERVICE_NUMBER);
END;
<<THE_END>>
    v_log_result := log_activity(v_process_type,v_process,'End',v_result_desc,v_result_code,'', '',V_SERVICE_NUMBER);
  RETURN 'success';
END DELETE_MASTER_WITH_SER_NUMBER;

/
--------------------------------------------------------
--  DDL for Function DELETE_T_METER_READING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_T_METER_READING" 
(
  V_BATCH_ID IN VARCHAR2 
) RETURN VARCHAR2 AS 

v_mr_cursor sys_refcursor ;
v_mr_header T_METER_READING_HDR%ROWTYPE;
mr_id varchar2(50);


BEGIN
	OPEN v_mr_cursor for select id from T_METER_READING_HDR where IMP_BATCH_ID=V_BATCH_ID;
    LOOP 
    FETCH v_mr_cursor INTO mr_id;
	EXIT WHEN v_mr_cursor%NOTFOUND;
    delete T_METER_READING_SLOT where T_METER_READING_HDR_ID=mr_id;
	END LOOP;
    delete T_METER_READING_HDR where IMP_BATCH_ID=V_BATCH_ID;


  RETURN 'success';
END DELETE_T_METER_READING;


/
--------------------------------------------------------
--  DDL for Function DELETE_USING_ES_ID
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."DELETE_USING_ES_ID" 
(
  V_ES_ID IN VARCHAR2 
) RETURN VARCHAR2 AS 
BEGIN



          delete from F_ENERGY_CHARGES where F_ENERGY_SALE_ORDER_ID='30980';
          DELETE from f_energy_ledger where F_ENERGY_SALE_ORDER_ID='30980';
          delete from F_ENERGY_SALE_ORDER_LINES where T_ENERGY_SALE_ID='310ef273-ce3d-41ca-936b-fb06f6728ea7';
          delete from f_energy_sale_order where T_ENERGY_SALE_ID='310ef273-ce3d-41ca-936b-fb06f6728ea7';


          delete from T_ES_CHARGE where t_energy_sale_id = '310ef273-ce3d-41ca-936b-fb06f6728ea7';
          delete from T_ES_USAGE_DETAIL where t_energy_sale_id = '310ef273-ce3d-41ca-936b-fb06f6728ea7';
          delete from T_ES_USAGE_SUMMARY where t_energy_sale_id = '310ef273-ce3d-41ca-936b-fb06f6728ea7';
          delete from T_ENERGY_SALE where id = '310ef273-ce3d-41ca-936b-fb06f6728ea7';

  RETURN 'SUCCESS';
END DELETE_USING_ES_ID;


/
--------------------------------------------------------
--  DDL for Function ENERGY_SALE_CONFIRMATION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."ENERGY_SALE_CONFIRMATION" 
(V_ES_ID VARCHAR2) RETURN VARCHAR2 
AS   
    v_process_name  VARCHAR2(500):= 'ENERGY_SALE_CONFIRMATION';
     V_SELLER_COMP_SERVICE V_COMPANY_SERVICE%ROWTYPE;
    V_BUYER_COMP_SERVICE V_COMPANY_SERVICE%ROWTYPE;
    V_ES T_ENERGY_SALE%ROWTYPE;
    V_ES_USAGESUMMARY T_ES_USAGE_SUMMARY%ROWTYPE;
    V_GS T_GEN_STMT%ROWTYPE;
    V_ES_ORDER F_ENERGY_SALE_ORDER%ROWTYPE;
    V_ES_ORDERLINE F_ENERGY_SALE_ORDER_LINES%ROWTYPE;
    V_ES_ORDERLINE_LEDGER F_ENERGY_SALE_ORDER_LINES%ROWTYPE;
    V_ENERGY_CHARGE F_ENERGY_CHARGES%ROWTYPE;
    V_GEN_STMT_ENERGY_CHARGE F_ENERGY_CHARGES%ROWTYPE;
    V_ES_CHARGE T_ES_CHARGE%ROWTYPE;
    V_GS_CHARGE T_GEN_STMT_CHARGE%ROWTYPE;
    V_NEW_SERV_EX_BANKING T_NEW_SERVICE_EXCESS_BANKING%ROWTYPE;
   -- V_RESULT VARCHAR(300):='SUCCESS';
  --  V_REASON VARCHAR2(200); 
   -- V_EXCEPTION_CODE VARCHAR2(150);
   -- V_EXCEPTION_MSG  VARCHAR2(150);
    V_ES_USAGESUMMARY_CURSOR sys_refcursor ;
    V_ES_ORDERLINE_CURSOR sys_refcursor ;
    V_GC_CHARGE_CURSOR sys_refcursor ;
    V_ES_CHARGE_CURSOR sys_refcursor ;
    CHARGE_COMP_SERVICE_ID VARCHAR2(200); 
    CHARGE_CODE VARCHAR2(200); 
    CHARGE_DESC VARCHAR2(200); 
    TOTAL_CHARGE VARCHAR2(200); 
    V_ENERGY_LEDGER F_ENERGY_LEDGER%ROWTYPE;
    V_ENERGY_LEDGER_BANK F_ENERGY_LEDGER%ROWTYPE;
    V_ENERGY_LEDGER_BUYER F_ENERGY_LEDGER%ROWTYPE;
    V_ENERGY_LEDGER_SELLER_TL F_ENERGY_LEDGER%ROWTYPE;
    V_ENERGY_LEDGER_SELLER_DL F_ENERGY_LEDGER%ROWTYPE;
    V_LOSS_CAL_BUYER_TRANS VARCHAR2(200);
    V_LOSS_CAL_BUYER_DIST VARCHAR2(200);
    V_LOSS_CAL_BUYER_TOTAL VARCHAR2(200); 
    V_LOSS_CAL_BUYER_DRAWAL1 VARCHAR2(200); 
    V_LOSS_CAL_BUYER_DRAWAL2 VARCHAR2(200); 
    V_LOSS_CAL_BUYER_DRAWAL3 VARCHAR2(200); 
    V_LOSS_CAL_BUYER_DRAWAL4 VARCHAR2(200); 
    V_LOSS_CAL_BUYER_DRAWAL5 VARCHAR2(200); 
    V_LOSS_CAL_BUYER_DRAWALOUT VARCHAR2(200); 

    V_LOSS_CAL_SELLER_TL_TOTAL VARCHAR2(200); 
    V_LOSS_CAL_SELLER_TL_DRAWAL VARCHAR2(200); 
    V_LOSS_CAL_SELLER_TL_DIST VARCHAR2(200);
    V_LOSS_CAL_SELLER_TL_TRANS1 VARCHAR2(200);   
    V_LOSS_CAL_SELLER_TL_TRANS2 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_TL_TRANS3 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_TL_TRANS4 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_TL_TRANS5 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_TL_TRANSOUT VARCHAR2(200); 

    V_LOSS_CAL_SELLER_DL_TOTAL VARCHAR2(200); 
    V_LOSS_CAL_SELLER_DL_DRAWAL VARCHAR2(200); 
    V_LOSS_CAL_SELLER_DL_TRANS VARCHAR2(200);
    V_LOSS_CAL_SELLER_DL_DIST1 VARCHAR2(200);
    V_LOSS_CAL_SELLER_DL_DIST2 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_DL_DIST3 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_DL_DIST4 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_DL_DIST5 VARCHAR2(200); 
    V_LOSS_CAL_SELLER_DL_DISTOUT VARCHAR2(200); 
    v_result varchar(300):='SUCCESS';
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
    v_excess_es VARCHAR2(300);
    v_excess_es1 VARCHAR2(300);
    v_excess_es2 VARCHAR2(300);
  ------------------------------------------------  
    v_sale_order_count number:=0;
    v_alloc_cons_count number :=0;
    v_charge_count number:=0;
    v_commission_date  DATE;
    v_adj_priority  VARCHAR2(150);
    --Dates
    v_date_47  DATE;v_date44_1 DATE;v_date44_2 DATE;
    v_date_46_1 date;v_date_46_2 date;v_date_45_1 date;v_date_45_2 date;
    v_date_43_1 date;v_date_43_2 date;v_date_42_1 date;v_date_42_2 date;
    v_date_41_1 date;v_date_41_2 date;
  ------------------------------------------------
    V_BB T_BANKING_BALANCE%ROWTYPE;
    V_C1 NUMBER:=0;
    V_C2 NUMBER:=0;
    V_C3 NUMBER:=0;
    V_C4 NUMBER:=0;
    V_C5 NUMBER:=0;
    V_UNALLOCATED_GEN_FLAG boolean:=false;
    V_ALLOCATED_BANK_FLAG boolean:=false;

    V_NEW_C1 NUMBER:=0;
    V_NEW_C2 NUMBER:=0;
    V_NEW_C3 NUMBER:=0;
    V_NEW_C4 NUMBER:=0;
    V_NEW_C5 NUMBER:=0;
    V_NEW_SERV_EXCESS_FLAG boolean:=false;
BEGIN  
   BEGIN
     SELECT * INTO V_ES FROM T_ENERGY_SALE WHERE ID = V_ES_ID;
       -- -- dbms_output.put_line(V_ES.STATUS_CODE);


       IF (V_ES.STATUS_CODE='CREATED' ) THEN
         update T_ENERGY_SALE set status_code = 'PROCESSING' where id = V_ES_ID;
         commit;

         SELECT * INTO V_SELLER_COMP_SERVICE FROM V_COMPANY_SERVICE WHERE ID=V_ES.SELLER_COMP_SERV_ID;
v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','V_ES.STATUS_CODE',V_ES.STATUS_CODE, v_reason,'admin', sysdate,v_es_id);
         -----------------------------------Commsion date wise prioroty-----------------------------------      
    IF(V_SELLER_COMP_SERVICE.COMMISSION_DATE is not null) THEN

        v_commission_date := V_SELLER_COMP_SERVICE.COMMISSION_DATE;
        v_date_47 := to_date('15/05/2006','dd-mm-yyyy');v_date_46_1 := to_date('14/05/2006','dd-mm-yyyy');v_date_45_2 := to_date('20/03/2009','dd-mm-yyyy');
        v_date44_1 := to_date('31/07/2012','dd-mm-yyyy');v_date_46_2 := to_date('19/03/2009','dd-mm-yyyy');v_date_43_1 := to_date('30/03/2016','dd-mm-yyyy');
        v_date44_2 := to_date('01/04/2009','dd-mm-yyyy');v_date_45_1 := to_date('31/03/2009','dd-mm-yyyy');v_date_43_2 := to_date('01/08/2012','dd-mm-yyyy');
        v_date_42_1 := to_date('31/03/2018','dd-mm-yyyy');v_date_42_2 := to_date('31/03/2016','dd-mm-yyyy');v_date_41_1 := to_date('01/04/2018','dd-mm-yyyy');

        if(v_commission_date <= v_date_47) then
         v_adj_priority:='57';
        ELSIF(v_commission_date BETWEEN v_date_46_1 AND v_date_46_2) then
         v_adj_priority:='56';
        ELSIF(v_commission_date BETWEEN v_date_45_2 AND v_date_45_1) then
         v_adj_priority:='55'; 
        ELSIF(v_commission_date BETWEEN v_date44_2 AND v_date44_1) then
         v_adj_priority:='54';
        ELSIF(v_commission_date BETWEEN v_date_43_2 AND v_date_43_1) then
         v_adj_priority:='53'; 
        ELSIF(v_commission_date BETWEEN v_date_42_2 AND  v_date_42_1) then
         v_adj_priority:='52';
        ELSIF(v_commission_date >= v_date_41_1) then
         v_adj_priority:='51'; 

         end if;
             v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION',v_date_47,'COMM-DATE - '||v_commission_date,v_adj_priority,'admin', sysdate,v_es_id);

       END IF; 

       ------------------------------------------------------------------------------------------------------------


         SELECT V_ES.ID,V_ES.SELLER_COMP_SERV_ID,V_ES.SELLER_END_ORG_ID,V_ES.MONTH,V_ES.YEAR,V_ES.INJECTING_VOLTAGE_CODE,V_ES.FROM_DT,V_ES.TO_DT,V_ES.LOSS,
         V_ES.MULTIPLE_BUYERS,V_ES.USAGE_DETAIL_AVAIL,V_ES.SIMPLE_ENERGY_SALE,V_ES.C1,V_ES.C2,V_ES.C3,V_ES.C4,V_ES.C5,V_ES.NET_GENERATION,V_ES.BC1,V_ES.BC2,V_ES.BC3,V_ES.BC4,V_ES.BC5,V_ES.TOTAL_BANK_UNITS_USED,V_ES.NET_ALLOCATION,
             V_SELLER_COMP_SERVICE.M_COMPANY_NAME,V_SELLER_COMP_SERVICE.M_COMPANY_CODE,V_SELLER_COMP_SERVICE."number",V_SELLER_COMP_SERVICE.M_ORG_NAME,V_SELLER_COMP_SERVICE.M_ORG_CODE,V_ES.GC1,V_ES.GC2,V_ES.GC3,V_ES.GC4,V_ES.GC5,V_SELLER_COMP_SERVICE.BANKING_SERVICE_ID,V_SELLER_COMP_SERVICE.BANKING_SERVICE_NUMBER,V_SELLER_COMP_SERVICE.M_COMPANY_ID,V_ES.ALLOW_LOWER_SLOT_ADMT, v_process_name, sysdate INTO 
         V_ES_ORDER.T_ENERGY_SALE_ID,V_ES_ORDER.SELLER_COMP_SERV_ID,V_ES_ORDER.SELLER_END_ORG_ID,V_ES_ORDER.MONTH,V_ES_ORDER.YEAR,V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDER.FROM_DT,V_ES_ORDER.TO_DT,V_ES_ORDER.LOSS,
         V_ES_ORDER.MULTIPLE_BUYERS,V_ES_ORDER.USAGE_DETAIL_AVAIL,V_ES_ORDER.SIMPLE_ENERGY_SALE,V_ES_ORDER.TOTAL_C1,V_ES_ORDER.TOTAL_C2,V_ES_ORDER.TOTAL_C3,V_ES_ORDER.TOTAL_C4,V_ES_ORDER.TOTAL_C5,V_ES_ORDER.TOTAL_GEN_UNITS_SOLD,V_ES_ORDER.TOTAL_BC1,V_ES_ORDER.TOTAL_BC2,V_ES_ORDER.TOTAL_BC3,V_ES_ORDER.TOTAL_BC4,V_ES_ORDER.TOTAL_BC5,V_ES_ORDER.TOTAL_BANKING_UNITS_SOLD,V_ES_ORDER.TOTAL_UNITS_SOLD,
         V_ES_ORDER.D_SELL_COMP_NAME,V_ES_ORDER.D_SELL_COMP_CODE,V_ES_ORDER.D_SELL_COMP_SERV_NUMBER,V_ES_ORDER.D_SELL_ORG_NAME,V_ES_ORDER.D_SELL_ORG_CODE,V_ES_ORDER.TOTAL_GC1,V_ES_ORDER.TOTAL_GC2,V_ES_ORDER.TOTAL_GC3,V_ES_ORDER.TOTAL_GC4,V_ES_ORDER.TOTAL_GC5,V_ES_ORDER.BANKING_SERVICE_ID,V_ES_ORDER.BANKING_SERVICE_NUMBER,V_ES_ORDER.SELLER_COMP_ID,V_ES_ORDER.ALLOW_LOWER_SLOT_ADMT, V_ES_ORDER.created_by, V_ES_ORDER.CREATED_DATE     FROM DUAL;

        -- check if sale-order already exists for the energysale
         select count(*) into v_sale_order_count from F_ENERGY_SALE_ORDER 
               where T_ENERGY_SALE_ID = V_ES_ORDER.T_ENERGY_SALE_ID;
v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','v_sale_order_count',v_sale_order_count, v_reason,'admin', sysdate,v_es_id);
         --avoid duplicate saleorder                                                                                                                        
         if(v_sale_order_count=0) then
             V_ES_ORDER.ID := F_ENERGY_SALE_ORDER_SEQ.NEXTVAL; 
             INSERT INTO OPENACCESS.F_ENERGY_SALE_ORDER VALUES V_ES_ORDER;  
             v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','  V_ES_ORDER.ID ',  V_ES_ORDER.ID , v_reason,'admin', sysdate,v_es_id);
        else
             v_result:='FAILURE';
             v_reason:='Energy Sale Order already exists for '||v_es_id;
             v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','Issue',v_result, v_reason,'admin', sysdate,v_es_id);
             GOTO THE_END;
        end if;

            OPEN V_ES_USAGESUMMARY_CURSOR for SELECT * FROM T_ES_USAGE_SUMMARY WHERE T_ENERGY_SALE_ID = V_ES_ID and BUYER_COMP_SERV_ID is not null;

            LOOP
            FETCH V_ES_USAGESUMMARY_CURSOR INTO V_ES_USAGESUMMARY;

            SELECT * INTO V_BUYER_COMP_SERVICE FROM V_COMPANY_SERVICE WHERE ID=V_ES_USAGESUMMARY.BUYER_COMP_SERV_ID;

            EXIT WHEN V_ES_USAGESUMMARY_CURSOR%NOTFOUND;
            v_alloc_cons_count := v_alloc_cons_count +1;

            V_ES_ORDERLINE.ID := F_ENERGY_SALE_ORDER_LINE_SEQ.NEXTVAL;  
             -- -- dbms_output.put_line('V_ES_ORDERLINE'||V_ES_ORDERLINE.ID);
           SELECT V_ES_ID,V_ES_ORDER.ID,V_ES_USAGESUMMARY.BUYER_END_ORG_ID,V_BUYER_COMP_SERVICE.M_SUBSTATION_ID,V_ES_USAGESUMMARY.BUYER_COMP_SERV_ID,V_ES_USAGESUMMARY.C1,V_ES_USAGESUMMARY.C2,V_ES_USAGESUMMARY.C3,V_ES_USAGESUMMARY.C4,V_ES_USAGESUMMARY.C5,V_ES_USAGESUMMARY.TOTAL,V_BUYER_COMP_SERVICE.M_COMPANY_NAME,V_BUYER_COMP_SERVICE.M_COMPANY_CODE,
            V_BUYER_COMP_SERVICE."number",V_BUYER_COMP_SERVICE.M_ORG_NAME,V_BUYER_COMP_SERVICE.M_ORG_CODE,V_BUYER_COMP_SERVICE.M_SUBSTATION_NAME,V_BUYER_COMP_SERVICE.M_COMPANY_ID,V_BUYER_COMP_SERVICE.VOLTAGE_CODE,V_ES_USAGESUMMARY.UNIT_COST,V_ES_USAGESUMMARY.TOTAL_AMOUNT_PAYABLE,V_ES_USAGESUMMARY.TOTAL_AMOUNT_CHARGABLE,V_ES_USAGESUMMARY.NET_AMOUNT_PAYABLE INTO 
            V_ES_ORDERLINE.T_ENERGY_SALE_ID,V_ES_ORDERLINE.F_ENERGY_SALE_ORDER_ID,V_ES_ORDERLINE.BUYER_END_ORG_ID,V_ES_ORDERLINE.BUYER_END_SS_ID,V_ES_ORDERLINE.BUYER_COMP_SERV_ID,
            V_ES_ORDERLINE.C1,V_ES_ORDERLINE.C2,V_ES_ORDERLINE.C3,V_ES_ORDERLINE.C4,V_ES_ORDERLINE.C5,V_ES_ORDERLINE.TOTAL_UNITS_SOLD,V_ES_ORDERLINE.D_BUYER_COMP_NAME,V_ES_ORDERLINE.D_BUYER_COMP_CODE,V_ES_ORDERLINE.D_BUYER_COMP_SERV_NAME,V_ES_ORDERLINE.D_BUYER_ORG_NAME,V_ES_ORDERLINE.D_BUYER_ORG_CODE,V_ES_ORDERLINE.D_BUYER_SS_NAME,V_ES_ORDERLINE.BUYER_COMP_ID,V_ES_ORDERLINE.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE.UNIT_COST,V_ES_ORDERLINE.TOTAL_AMOUNT_PAYABLE,V_ES_ORDERLINE.TOTAL_AMOUNT_CHARGABLE,V_ES_ORDERLINE.NET_AMOUNT_PAYABLE FROM DUAL;         

            IF V_ES.IS_STB='Y' THEN
              V_ES_ORDERLINE.D_DRAWAL_VOLTAGE_CODE := V_ES_ORDER.INJECTING_VOLTAGE_CODE;
            END IF;
v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','V_ES_ORDERLINE.ID ',V_ES_ORDERLINE.ID , v_reason,'admin', sysdate,v_es_id);
           INSERT INTO F_ENERGY_SALE_ORDER_LINES VALUES V_ES_ORDERLINE;  

            END LOOP;


            OPEN V_ES_CHARGE_CURSOR for SELECT ESCHARGE.M_COMP_SERV_ID,ESCHARGE.CHARGE_CODE,ESCHARGE.TOTAL_CHARGE,CHARGEDEFN.CHARGE_DESC FROM T_ES_CHARGE ESCHARGE  LEFT JOIN M_CHARGE_DEFN CHARGEDEFN ON ESCHARGE.CHARGE_CODE = CHARGEDEFN.CHARGE_CODE WHERE T_ENERGY_SALE_ID = V_ES_ID;

            LOOP
             FETCH V_ES_CHARGE_CURSOR INTO CHARGE_COMP_SERVICE_ID,CHARGE_CODE,TOTAL_CHARGE,CHARGE_DESC;
             EXIT WHEN V_ES_CHARGE_CURSOR%NOTFOUND;
             SELECT CHARGE_COMP_SERVICE_ID,CHARGE_CODE,TOTAL_CHARGE,CHARGE_DESC,V_ES_ORDER.ID INTO
             V_ENERGY_CHARGE.M_COMPANY_SERVICE_ID,V_ENERGY_CHARGE.CHARGE_CODE,V_ENERGY_CHARGE.TOTAL_CHARGES,V_ENERGY_CHARGE.CHARGE_DESC,V_ENERGY_CHARGE.F_ENERGY_SALE_ORDER_ID FROM DUAL;

             --check if a same charge already exists for the same saleorder,service-id
             select count(*) into v_charge_count from F_ENERGY_CHARGES where F_ENERGY_SALE_ORDER_ID=V_ENERGY_CHARGE.F_ENERGY_SALE_ORDER_ID and M_COMPANY_SERVICE_ID=V_ENERGY_CHARGE.M_COMPANY_SERVICE_ID 
             and CHARGE_CODE = V_ENERGY_CHARGE.CHARGE_CODE;
--v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','v_charge_count ',v_charge_count , v_reason,'admin', sysdate,v_es_id);
             -- avoid duplicate
             if(v_charge_count=0) then
                V_ENERGY_CHARGE.ID := F_ENERGY_CHARGES_SEQ.NEXTVAL;  
                INSERT INTO F_ENERGY_CHARGES VALUES V_ENERGY_CHARGE; 
             end if;
            END LOOP;




              SELECT V_ES_ORDER.SELLER_END_ORG_ID,V_ES_ORDER.SELLER_COMP_ID,V_ES_ORDER.SELLER_COMP_SERV_ID,V_ES_ORDER.MONTH,V_ES_ORDER.YEAR,V_ES_ORDER.FROM_DT,V_ES_ORDER.TO_DT,V_ES_ORDER.TOTAL_GC1,
            V_ES_ORDER.TOTAL_GC2,V_ES_ORDER.TOTAL_GC3,V_ES_ORDER.TOTAL_GC4,V_ES_ORDER.TOTAL_GC5,V_ES_ORDER.TOTAL_GEN_UNITS_SOLD,V_ES_ORDER.ID,V_ES_ORDER.D_SELL_COMP_NAME,V_ES_ORDER.D_SELL_COMP_CODE,V_ES_ORDER.D_SELL_COMP_SERV_NUMBER,V_ES_ORDER.D_SELL_ORG_NAME,V_ES_ORDER.D_SELL_ORG_CODE,V_SELLER_COMP_SERVICE.COMMISSION_DATE,v_adj_priority,V_ES_ORDER.ALLOW_LOWER_SLOT_ADMT,V_SELLER_COMP_SERVICE.IS_REC INTO
            V_ENERGY_LEDGER.M_ORG_ID,V_ENERGY_LEDGER.M_COMPANY_ID,V_ENERGY_LEDGER.M_COMPANY_SERVICE_ID,V_ENERGY_LEDGER.MONTH,V_ENERGY_LEDGER.YEAR,V_ENERGY_LEDGER.FROM_DT,V_ENERGY_LEDGER.TO_DT,V_ENERGY_LEDGER.C1,
            V_ENERGY_LEDGER.C2,V_ENERGY_LEDGER.C3,V_ENERGY_LEDGER.C4,V_ENERGY_LEDGER.C5,V_ENERGY_LEDGER.ENERGY_IN,V_ENERGY_LEDGER.F_ENERGY_SALE_ORDER_ID,V_ENERGY_LEDGER.D_COMP_NAME,V_ENERGY_LEDGER.D_COMP_CODE,V_ENERGY_LEDGER.D_COMP_SERV_NUMBER,V_ENERGY_LEDGER.D_ORG_NAME,V_ENERGY_LEDGER.D_ORG_CODE,V_ENERGY_LEDGER.D_COMMISSION_DATE,V_ENERGY_LEDGER.D_ADJUSTMENT_PRIORITY,V_ENERGY_LEDGER.ALLOW_LOWER_SLOT_ADMT, V_ENERGY_LEDGER_BANK.D_IS_REC  FROM DUAL;

            V_ENERGY_LEDGER.LEDGER_DATE:= SYSDATE;
            V_ENERGY_LEDGER.SERVICE_TYPE_CODE:= '03';

            V_ENERGY_LEDGER.ID:=F_ENERGY_LEDGER_SEQ.NEXTVAL;
--            DBMS.OUTPUT.PUT_LINE(V_ENERGY_LEDGER.ALLOW_LOWER_SLOT_ADMT);
            INSERT INTO F_ENERGY_LEDGER VALUES V_ENERGY_LEDGER;
--v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','v_charge_count ',v_charge_count , v_reason,'admin', sysdate,v_es_id);
            IF V_ES.TOTAL_BANK_UNITS_USED!=NULL AND V_ES.TOTAL_BANK_UNITS_USED>0 THEN

                SELECT V_ES_ORDER.SELLER_END_ORG_ID,V_ES_ORDER.SELLER_COMP_ID,V_ES_ORDER.SELLER_COMP_SERV_ID,V_ES_ORDER.MONTH,V_ES_ORDER.YEAR,V_ES_ORDER.FROM_DT,V_ES_ORDER.TO_DT,V_ES_ORDER.TOTAL_GC1,
                V_ES_ORDER.TOTAL_GC2,V_ES_ORDER.TOTAL_GC3,V_ES_ORDER.TOTAL_GC4,V_ES_ORDER.TOTAL_GC5,V_ES_ORDER.TOTAL_BANKING_UNITS_SOLD,V_ES_ORDER.ID,V_ES_ORDER.D_SELL_COMP_NAME,V_ES_ORDER.D_SELL_COMP_CODE,V_ES_ORDER.D_SELL_COMP_SERV_NUMBER,V_ES_ORDER.D_SELL_ORG_NAME,V_ES_ORDER.D_SELL_ORG_CODE,V_SELLER_COMP_SERVICE.COMMISSION_DATE,v_adj_priority,V_ES_ORDER.ALLOW_LOWER_SLOT_ADMT,V_SELLER_COMP_SERVICE.IS_REC INTO
                V_ENERGY_LEDGER_BANK.M_ORG_ID,V_ENERGY_LEDGER_BANK.M_COMPANY_ID,V_ENERGY_LEDGER_BANK.M_COMPANY_SERVICE_ID,V_ENERGY_LEDGER_BANK.MONTH,V_ENERGY_LEDGER_BANK.YEAR,V_ENERGY_LEDGER_BANK.FROM_DT,V_ENERGY_LEDGER_BANK.TO_DT,V_ENERGY_LEDGER_BANK.C1,
                V_ENERGY_LEDGER_BANK.C2,V_ENERGY_LEDGER_BANK.C3,V_ENERGY_LEDGER_BANK.C4,V_ENERGY_LEDGER_BANK.C5,V_ENERGY_LEDGER_BANK.ENERGY_IN,V_ENERGY_LEDGER_BANK.F_ENERGY_SALE_ORDER_ID,V_ENERGY_LEDGER_BANK.D_COMP_NAME,V_ENERGY_LEDGER_BANK.D_COMP_CODE,V_ENERGY_LEDGER_BANK.D_COMP_SERV_NUMBER,V_ENERGY_LEDGER_BANK.D_ORG_NAME,V_ENERGY_LEDGER_BANK.D_ORG_CODE,V_ENERGY_LEDGER_BANK.D_COMMISSION_DATE,V_ENERGY_LEDGER_BANK.D_ADJUSTMENT_PRIORITY,V_ENERGY_LEDGER_BANK.ALLOW_LOWER_SLOT_ADMT, V_ENERGY_LEDGER_BANK.D_IS_REC  FROM DUAL;

                V_ENERGY_LEDGER_BANK.LEDGER_DATE:= SYSDATE;
                V_ENERGY_LEDGER_BANK.SERVICE_TYPE_CODE:= '01';



                V_ENERGY_LEDGER_BANK.ID:=F_ENERGY_LEDGER_SEQ.NEXTVAL;
                INSERT INTO F_ENERGY_LEDGER VALUES V_ENERGY_LEDGER_BANK;

            END IF;


--            OPEN V_ES_ORDERLINE_CURSOR for SELECT * FROM F_ENERGY_SALE_ORDER_LINES WHERE F_ENERGY_SALE_ORDER_ID = '69';
            OPEN V_ES_ORDERLINE_CURSOR for SELECT * FROM F_ENERGY_SALE_ORDER_LINES WHERE T_ENERGY_SALE_ID = V_ES_ID;

            LOOP
            FETCH V_ES_ORDERLINE_CURSOR INTO V_ES_ORDERLINE_LEDGER;

            EXIT WHEN V_ES_ORDERLINE_CURSOR%NOTFOUND;



            V_ENERGY_LEDGER_BUYER.LEDGER_DATE:= SYSDATE;
            V_ENERGY_LEDGER_BUYER.SERVICE_TYPE_CODE:= '02';

            V_LOSS_CAL_BUYER_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C1,V_LOSS_CAL_BUYER_TRANS,V_LOSS_CAL_BUYER_DIST,V_LOSS_CAL_BUYER_TOTAL,V_LOSS_CAL_BUYER_DRAWAL1);
            V_LOSS_CAL_BUYER_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C2,V_LOSS_CAL_BUYER_TRANS,V_LOSS_CAL_BUYER_DIST,V_LOSS_CAL_BUYER_TOTAL,V_LOSS_CAL_BUYER_DRAWAL2);
            V_LOSS_CAL_BUYER_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C3,V_LOSS_CAL_BUYER_TRANS,V_LOSS_CAL_BUYER_DIST,V_LOSS_CAL_BUYER_TOTAL,V_LOSS_CAL_BUYER_DRAWAL3);
            V_LOSS_CAL_BUYER_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C4,V_LOSS_CAL_BUYER_TRANS,V_LOSS_CAL_BUYER_DIST,V_LOSS_CAL_BUYER_TOTAL,V_LOSS_CAL_BUYER_DRAWAL4);
            V_LOSS_CAL_BUYER_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C5,V_LOSS_CAL_BUYER_TRANS,V_LOSS_CAL_BUYER_DIST,V_LOSS_CAL_BUYER_TOTAL,V_LOSS_CAL_BUYER_DRAWAL5);
            V_LOSS_CAL_BUYER_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.TOTAL_UNITS_SOLD,V_LOSS_CAL_BUYER_TRANS,V_LOSS_CAL_BUYER_DIST,V_LOSS_CAL_BUYER_TOTAL,V_LOSS_CAL_BUYER_DRAWALOUT);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_TOTAL'||V_LOSS_CAL_BUYER_TOTAL);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_DIST'||V_LOSS_CAL_BUYER_DIST);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_TRANS'||V_LOSS_CAL_BUYER_TRANS);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_DRAWAL'||V_LOSS_CAL_BUYER_DRAWAL1||'-------'||V_LOSS_CAL_BUYER_DRAWAL2||'-------'||V_LOSS_CAL_BUYER_DRAWAL3||'-------'||V_LOSS_CAL_BUYER_DRAWAL4||'-------'||V_LOSS_CAL_BUYER_DRAWAL5||'-------'||V_LOSS_CAL_BUYER_DRAWALIN);
          SELECT V_ES_ORDERLINE_LEDGER.BUYER_END_ORG_ID,V_ES_ORDERLINE_LEDGER.BUYER_COMP_ID,V_ES_ORDERLINE_LEDGER.BUYER_COMP_SERV_ID,V_ES_ORDER.MONTH,V_ES_ORDER.YEAR,V_ES_ORDER.FROM_DT,V_ES_ORDER.TO_DT,
            V_LOSS_CAL_BUYER_DRAWAL1,V_LOSS_CAL_BUYER_DRAWAL2,V_LOSS_CAL_BUYER_DRAWAL3,V_LOSS_CAL_BUYER_DRAWAL4,V_LOSS_CAL_BUYER_DRAWAL5,V_LOSS_CAL_BUYER_DRAWALOUT,V_ES_ORDER.ID,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_CODE,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_SERV_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_ORG_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_ORG_CODE,V_ES_ORDERLINE_LEDGER.ID,V_SELLER_COMP_SERVICE.COMMISSION_DATE,v_adj_priority,V_SELLER_COMP_SERVICE.IS_REC,V_ES_ORDER.ALLOW_LOWER_SLOT_ADMT INTO 
            V_ENERGY_LEDGER_BUYER.M_ORG_ID,V_ENERGY_LEDGER_BUYER.M_COMPANY_ID,V_ENERGY_LEDGER_BUYER.M_COMPANY_SERVICE_ID,V_ENERGY_LEDGER_BUYER.MONTH,V_ENERGY_LEDGER_BUYER.YEAR,V_ENERGY_LEDGER_BUYER.FROM_DT,V_ENERGY_LEDGER_BUYER.TO_DT,V_ENERGY_LEDGER_BUYER.C1,
            V_ENERGY_LEDGER_BUYER.C2,V_ENERGY_LEDGER_BUYER.C3,V_ENERGY_LEDGER_BUYER.C4,V_ENERGY_LEDGER_BUYER.C5,V_ENERGY_LEDGER_BUYER.ENERGY_OUT,V_ENERGY_LEDGER_BUYER.F_ENERGY_SALE_ORDER_ID,V_ENERGY_LEDGER_BUYER.D_COMP_NAME,V_ENERGY_LEDGER_BUYER.D_COMP_CODE,V_ENERGY_LEDGER_BUYER.D_COMP_SERV_NUMBER,V_ENERGY_LEDGER_BUYER.D_ORG_NAME,V_ENERGY_LEDGER_BUYER.D_ORG_CODE,V_ENERGY_LEDGER_BUYER.F_ENERGY_SALE_ORDER_LINES_ID,V_ENERGY_LEDGER_BUYER.D_COMMISSION_DATE,V_ENERGY_LEDGER_BUYER.D_ADJUSTMENT_PRIORITY,V_ENERGY_LEDGER_BUYER.D_IS_REC,V_ENERGY_LEDGER_BUYER.ALLOW_LOWER_SLOT_ADMT FROM DUAL;


            V_ENERGY_LEDGER_BUYER.ID:=F_ENERGY_LEDGER_SEQ.NEXTVAL;
            INSERT INTO F_ENERGY_LEDGER VALUES V_ENERGY_LEDGER_BUYER;


             V_ENERGY_LEDGER_SELLER_TL.LEDGER_DATE:= SYSDATE;
            V_ENERGY_LEDGER_SELLER_TL.SERVICE_TYPE_CODE:= '04';

            V_LOSS_CAL_SELLER_TL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C1,V_LOSS_CAL_SELLER_TL_TRANS1,V_LOSS_CAL_SELLER_TL_DIST,V_LOSS_CAL_SELLER_TL_TOTAL,V_LOSS_CAL_SELLER_TL_DRAWAL);
            V_LOSS_CAL_SELLER_TL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C2,V_LOSS_CAL_SELLER_TL_TRANS2,V_LOSS_CAL_SELLER_TL_DIST,V_LOSS_CAL_SELLER_TL_TOTAL,V_LOSS_CAL_SELLER_TL_DRAWAL);
            V_LOSS_CAL_SELLER_TL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C3,V_LOSS_CAL_SELLER_TL_TRANS3,V_LOSS_CAL_SELLER_TL_DIST,V_LOSS_CAL_SELLER_TL_TOTAL,V_LOSS_CAL_SELLER_TL_DRAWAL);
            V_LOSS_CAL_SELLER_TL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C4,V_LOSS_CAL_SELLER_TL_TRANS4,V_LOSS_CAL_SELLER_TL_DIST,V_LOSS_CAL_SELLER_TL_TOTAL,V_LOSS_CAL_SELLER_TL_DRAWAL);
            V_LOSS_CAL_SELLER_TL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C5,V_LOSS_CAL_SELLER_TL_TRANS5,V_LOSS_CAL_SELLER_TL_DIST,V_LOSS_CAL_SELLER_TL_TOTAL,V_LOSS_CAL_SELLER_TL_DRAWAL);
            V_LOSS_CAL_SELLER_TL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.GEN_UNITS_SOLD,V_LOSS_CAL_SELLER_TL_TRANSOUT,V_LOSS_CAL_SELLER_TL_DIST,V_LOSS_CAL_SELLER_TL_TOTAL,V_LOSS_CAL_SELLER_TL_DRAWAL);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_TOTAL'||V_LOSS_CAL_SELLER_TL_TOTAL);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_DIST'||V_LOSS_CAL_SELLER_TL_DIST);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_TRANS'||V_LOSS_CAL_SELLER_TL_TRANS);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_DRAWAL'||V_LOSS_CAL_SELLER_TL_DRAWAL1||'-------'||V_LOSS_CAL_SELLER_TL_DRAWAL2||'-------'||V_LOSS_CAL_SELLER_TL_DRAWAL3||'-------'||V_LOSS_CAL_SELLER_TL_DRAWAL4||'-------'||V_LOSS_CAL_SELLER_TL_DRAWAL5||'-------'||V_LOSS_CAL_SELLER_TL_DRAWALIN);
            SELECT V_ES_ORDERLINE_LEDGER.BUYER_END_ORG_ID,V_ES_ORDERLINE_LEDGER.BUYER_COMP_ID,V_ES_ORDERLINE_LEDGER.BUYER_COMP_SERV_ID,V_ES_ORDER.MONTH,V_ES_ORDER.YEAR,V_ES_ORDER.FROM_DT,V_ES_ORDER.TO_DT,
            V_LOSS_CAL_SELLER_TL_TRANS1,V_LOSS_CAL_SELLER_TL_TRANS2,V_LOSS_CAL_SELLER_TL_TRANS3,V_LOSS_CAL_SELLER_TL_TRANS4,V_LOSS_CAL_SELLER_TL_TRANS5,V_LOSS_CAL_SELLER_TL_TRANSOUT,V_ES_ORDER.ID,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_CODE,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_SERV_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_ORG_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_ORG_CODE,V_ES_ORDERLINE_LEDGER.ID,V_SELLER_COMP_SERVICE.COMMISSION_DATE,v_adj_priority  INTO 
           V_ENERGY_LEDGER_SELLER_TL.M_ORG_ID,V_ENERGY_LEDGER_SELLER_TL.M_COMPANY_ID,V_ENERGY_LEDGER_SELLER_TL.M_COMPANY_SERVICE_ID,V_ENERGY_LEDGER_SELLER_TL.MONTH,V_ENERGY_LEDGER_SELLER_TL.YEAR,V_ENERGY_LEDGER_SELLER_TL.FROM_DT,V_ENERGY_LEDGER_SELLER_TL.TO_DT,V_ENERGY_LEDGER_SELLER_TL.C1,
            V_ENERGY_LEDGER_SELLER_TL.C2,V_ENERGY_LEDGER_SELLER_TL.C3,V_ENERGY_LEDGER_SELLER_TL.C4,V_ENERGY_LEDGER_SELLER_TL.C5,V_ENERGY_LEDGER_SELLER_TL.ENERGY_OUT,V_ENERGY_LEDGER_SELLER_TL.F_ENERGY_SALE_ORDER_ID,V_ENERGY_LEDGER_SELLER_TL.D_COMP_NAME,V_ENERGY_LEDGER_SELLER_TL.D_COMP_CODE,V_ENERGY_LEDGER_SELLER_TL.D_COMP_SERV_NUMBER,V_ENERGY_LEDGER_SELLER_TL.D_ORG_NAME,V_ENERGY_LEDGER_SELLER_TL.D_ORG_CODE,V_ENERGY_LEDGER_SELLER_TL.F_ENERGY_SALE_ORDER_LINES_ID,V_ENERGY_LEDGER_SELLER_TL.D_COMMISSION_DATE,V_ENERGY_LEDGER_SELLER_TL.D_ADJUSTMENT_PRIORITY FROM DUAL;

            V_ENERGY_LEDGER_SELLER_TL.ID:=F_ENERGY_LEDGER_SEQ.NEXTVAL;
            INSERT INTO F_ENERGY_LEDGER VALUES V_ENERGY_LEDGER_SELLER_TL;




            V_ENERGY_LEDGER_SELLER_DL.LEDGER_DATE:= SYSDATE;
            V_ENERGY_LEDGER_SELLER_DL.SERVICE_TYPE_CODE:= '05';

            V_LOSS_CAL_SELLER_DL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C1,V_LOSS_CAL_SELLER_DL_TRANS,V_LOSS_CAL_SELLER_DL_DIST1,V_LOSS_CAL_SELLER_DL_TOTAL,V_LOSS_CAL_SELLER_DL_DRAWAL);
            V_LOSS_CAL_SELLER_DL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C2,V_LOSS_CAL_SELLER_DL_TRANS,V_LOSS_CAL_SELLER_DL_DIST2,V_LOSS_CAL_SELLER_DL_TOTAL,V_LOSS_CAL_SELLER_DL_DRAWAL);
            V_LOSS_CAL_SELLER_DL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C3,V_LOSS_CAL_SELLER_DL_TRANS,V_LOSS_CAL_SELLER_DL_DIST3,V_LOSS_CAL_SELLER_DL_TOTAL,V_LOSS_CAL_SELLER_DL_DRAWAL);
            V_LOSS_CAL_SELLER_DL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C4,V_LOSS_CAL_SELLER_DL_TRANS,V_LOSS_CAL_SELLER_DL_DIST4,V_LOSS_CAL_SELLER_DL_TOTAL,V_LOSS_CAL_SELLER_DL_DRAWAL);
            V_LOSS_CAL_SELLER_DL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.C5,V_LOSS_CAL_SELLER_DL_TRANS,V_LOSS_CAL_SELLER_DL_DIST5,V_LOSS_CAL_SELLER_DL_TOTAL,V_LOSS_CAL_SELLER_DL_DRAWAL);
            V_LOSS_CAL_SELLER_DL_TOTAL :=LOSS_CALCULATION(V_ES_ORDER.INJECTING_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.D_DRAWAL_VOLTAGE_CODE,V_ES_ORDERLINE_LEDGER.GEN_UNITS_SOLD,V_LOSS_CAL_SELLER_DL_TRANS,V_LOSS_CAL_SELLER_DL_DISTOUT,V_LOSS_CAL_SELLER_DL_TOTAL,V_LOSS_CAL_SELLER_DL_DRAWAL);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_TOTAL'||V_LOSS_CAL_SELLER_DL_TOTAL);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_DIST'||V_LOSS_CAL_SELLER_DL_DIST);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_TRANS'||V_LOSS_CAL_SELLER_DL_TRANS);
--           -- dbms_output.put_line('V_LOSS_CALCULATION_DRAWAL'||V_LOSS_CAL_SELLER_DL_DRAWAL1||'-------'||V_LOSS_CAL_SELLER_DL_DRAWAL2||'-------'||V_LOSS_CAL_SELLER_DL_DRAWAL3||'-------'||V_LOSS_CAL_SELLER_DL_DRAWAL4||'-------'||V_LOSS_CAL_SELLER_DL_DRAWAL5||'-------'||V_LOSS_CAL_SELLER_DL_DRAWALIN);
            SELECT V_ES_ORDERLINE_LEDGER.BUYER_END_ORG_ID,V_ES_ORDERLINE_LEDGER.BUYER_COMP_ID,V_ES_ORDERLINE_LEDGER.BUYER_COMP_SERV_ID,V_ES_ORDER.MONTH,V_ES_ORDER.YEAR,V_ES_ORDER.FROM_DT,V_ES_ORDER.TO_DT,
            V_LOSS_CAL_SELLER_DL_DIST1,V_LOSS_CAL_SELLER_DL_DIST2,V_LOSS_CAL_SELLER_DL_DIST3,V_LOSS_CAL_SELLER_DL_DIST4,V_LOSS_CAL_SELLER_DL_DIST5,V_LOSS_CAL_SELLER_DL_DISTOUT,V_ES_ORDER.ID,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_CODE,V_ES_ORDERLINE_LEDGER.D_BUYER_COMP_SERV_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_ORG_NAME,V_ES_ORDERLINE_LEDGER.D_BUYER_ORG_CODE,V_ES_ORDERLINE_LEDGER.ID,V_SELLER_COMP_SERVICE.COMMISSION_DATE,v_adj_priority  INTO 
           V_ENERGY_LEDGER_SELLER_DL.M_ORG_ID,V_ENERGY_LEDGER_SELLER_DL.M_COMPANY_ID,V_ENERGY_LEDGER_SELLER_DL.M_COMPANY_SERVICE_ID,V_ENERGY_LEDGER_SELLER_DL.MONTH,V_ENERGY_LEDGER_SELLER_DL.YEAR,V_ENERGY_LEDGER_SELLER_DL.FROM_DT,V_ENERGY_LEDGER_SELLER_DL.TO_DT,V_ENERGY_LEDGER_SELLER_DL.C1,
            V_ENERGY_LEDGER_SELLER_DL.C2,V_ENERGY_LEDGER_SELLER_DL.C3,V_ENERGY_LEDGER_SELLER_DL.C4,V_ENERGY_LEDGER_SELLER_DL.C5,V_ENERGY_LEDGER_SELLER_DL.ENERGY_OUT,V_ENERGY_LEDGER_SELLER_DL.F_ENERGY_SALE_ORDER_ID,V_ENERGY_LEDGER_SELLER_DL.D_COMP_NAME,V_ENERGY_LEDGER_SELLER_DL.D_COMP_CODE,V_ENERGY_LEDGER_SELLER_DL.D_COMP_SERV_NUMBER,V_ENERGY_LEDGER_SELLER_DL.D_ORG_NAME,V_ENERGY_LEDGER_SELLER_DL.D_ORG_CODE,V_ENERGY_LEDGER_SELLER_DL.F_ENERGY_SALE_ORDER_LINES_ID,V_ENERGY_LEDGER_SELLER_DL.D_COMMISSION_DATE,V_ENERGY_LEDGER_SELLER_DL.D_ADJUSTMENT_PRIORITY FROM DUAL;

            V_ENERGY_LEDGER_SELLER_DL.ID:=F_ENERGY_LEDGER_SEQ.NEXTVAL;
            INSERT INTO F_ENERGY_LEDGER VALUES V_ENERGY_LEDGER_SELLER_DL;

            END LOOP;


           UPDATE T_ENERGY_SALE SET STATUS_CODE='APPROVED' WHERE ID=V_ES_ID;
--          v_excess_es := EXCESS_ES_BANKING_BALANCE(V_ES_ID);

            excess_units_source.update_excess_from_ea(V_ES_ID, V_RESULT , V_REASON);
--      calculation for unallocated gen units
--            if v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
--                BANKING_BALANCE.confirm_energy_sale_event(V_ES_ID,v_excess_es,v_excess_es1);
--            ELSIF v_commission_date> to_date('01-04-2018','DD-MM-YYYY') THEN
--                  IF TO_NUMBER(nvl(V_ES.AVAIL_GC1,0))  > TO_NUMBER(nvl(V_ES.GC1,0)) THEN
--                    V_NEW_C1 := (TO_NUMBER(nvl(V_ES.AVAIL_GC1,0)) - TO_NUMBER(nvl(V_ES.GC1,0)));
----                    V_NEW_C1 :=(V_NEW_C1 *0.75);  
--                    V_NEW_SERV_EXCESS_FLAG:=true;
--                END IF;
--                
--                IF TO_NUMBER(nvl(V_ES.AVAIL_GC2,0))  > TO_NUMBER(nvl(V_ES.GC2,0)) THEN
--                    V_NEW_C2 := (TO_NUMBER(nvl(V_ES.AVAIL_GC2,0)) - TO_NUMBER(nvl(V_ES.GC2,0)));
----                    V_NEW_C2 :=(V_NEW_C2 *0.75); 
--                    V_NEW_SERV_EXCESS_FLAG:=true;
--                END IF;
--                
--                IF TO_NUMBER(nvl(V_ES.AVAIL_GC3,0))  > TO_NUMBER(nvl(V_ES.GC3,0)) THEN
--                    V_NEW_C3 := (TO_NUMBER(nvl(V_ES.AVAIL_GC3,0)) - TO_NUMBER(nvl(V_ES.GC3,0)));
----                    V_NEW_C3 :=(V_NEW_C3 *0.75); 
--                    V_NEW_SERV_EXCESS_FLAG:=true;
--                END IF;
--                
--                IF TO_NUMBER(nvl(V_ES.AVAIL_GC4,0))  > TO_NUMBER(nvl(V_ES.GC4,0)) THEN
--                    V_NEW_C4 := (TO_NUMBER(nvl(V_ES.AVAIL_GC4,0)) - TO_NUMBER(nvl(V_ES.GC4,0)));
----                    V_NEW_C4 :=(V_NEW_C4 *0.75); 
--                    V_NEW_SERV_EXCESS_FLAG:=true;
--                END IF;
--                
--                IF TO_NUMBER(nvl(V_ES.AVAIL_GC5,0))  > TO_NUMBER(nvl(V_ES.GC5,0)) THEN
--                    V_NEW_C5 := (TO_NUMBER(nvl(V_ES.AVAIL_GC5,0)) - TO_NUMBER(nvl(V_ES.GC5,0)));
----                    V_NEW_C5 :=(V_NEW_C5 *0.75); 
--                    V_NEW_SERV_EXCESS_FLAG:=true;
--                END IF;
--                IF V_NEW_SERV_EXCESS_FLAG THEN
--                    select V_SELLER_COMP_SERVICE.M_COMPANY_ID,V_SELLER_COMP_SERVICE.BANKING_SERVICE_ID,V_NEW_C1,V_NEW_C2,V_NEW_C3,V_NEW_C4,V_NEW_C5,V_NEW_C1,V_NEW_C2,V_NEW_C3,V_NEW_C4,V_NEW_C5
--                    into V_NEW_SERV_EX_BANKING.M_COMPANY_ID,V_NEW_SERV_EX_BANKING.BANKING_SERVICE_ID,V_NEW_SERV_EX_BANKING.C1,V_NEW_SERV_EX_BANKING.C2,V_NEW_SERV_EX_BANKING.C3,V_NEW_SERV_EX_BANKING.C4,V_NEW_SERV_EX_BANKING.C5,V_NEW_SERV_EX_BANKING.CURR_C1,V_NEW_SERV_EX_BANKING.CURR_C2,V_NEW_SERV_EX_BANKING.CURR_C3,V_NEW_SERV_EX_BANKING.CURR_C4,V_NEW_SERV_EX_BANKING.CURR_C5 from dual;
--                    V_NEW_SERV_EX_BANKING.enabled:='Y';
--                    V_NEW_SERV_EX_BANKING.CALCULATED:='Y';
--                    V_NEW_SERV_EX_BANKING.month:=V_ES.MONTH;
--                    V_NEW_SERV_EX_BANKING.year:=V_ES.YEAR;
--                    V_NEW_SERV_EX_BANKING.CREATED_BY:='CONFIRM_ENERGY_SALE_EVENT'; 
--                    V_NEW_SERV_EX_BANKING.CREATED_DT:=sysdate; 
--                    V_NEW_SERV_EX_BANKING.id:=T_NEW_SERVICE_EXCESS_BANKING_SEQ.NEXTVAL;
--                    insert into T_NEW_SERVICE_EXCESS_BANKING VALUES V_NEW_SERV_EX_BANKING;
--                END IF;
--                 END IF;

       elsif( V_ES.status_code = 'PROCESSING') then
        V_REASON    := 'Another ENERGY SALE ORDER already in process';
        V_RESULT    := 'FAILURE';
        GOTO THE_END;

       ELSE 
        V_REASON    := 'CANNOT UPDATE ALREADY APPROVED ENERGY SALE';
        V_RESULT    := 'FAILURE';
        GOTO THE_END;
       END IF;




      EXCEPTION
              WHEN OTHERS THEN
                  v_exception_code := SQLCODE;
                  v_exception_msg  := SUBSTR(SQLERRM, 1, 100); 
                  v_result := 'FAILURE';
                  v_reason := v_exception_code || ' - ' || v_exception_msg;
                  v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','EH','Isse in ENERGY_SALE_CONFIRMATION - '||v_reason,v_result,'admin', sysdate,v_es_id);
                  select status_code into V_ES.status_code from T_ENERGY_SALE where id = V_ES_ID;
                  if ( V_ES.status_code = 'PROCESSING') then 
                    update T_ENERGY_SALE set status_code = 'CREATED',PROCESS_REMARKS=v_reason where id = V_ES_ID;
                  end if;

    END;
    select status_code into V_ES.status_code from T_ENERGY_SALE where id = V_ES_ID;

    --delete any orphan energy sale order without any consumers
    -- dont run this for records already approved
    if(V_ES.status_code='CREATED' and v_alloc_cons_count =0) then
        v_result :='FAILURE';
        V_REASON := 'No Consumers allocated in this energy-sale';
        if (V_ES_ORDER.ID is not null) then
            delete f_energy_sale_order where id =  V_ES_ORDER.ID;
        end if;
        update T_ENERGY_SALE set status_code = 'CREATED',PROCESS_REMARKS=v_reason where id = V_ES_ID;
    end if;
    commit;
    <<THE_END>>
   v_log_result := log_activity('PROCEDURE','ENERGY_SALE_CONFIRMATION','End',v_result, v_reason,'admin', sysdate,v_es_id);

    IF V_RESULT = 'SUCCESS' THEN
      null;
    ELSE
      v_result := v_result || ' - ' || v_reason;
    end if;
RETURN V_RESULT;
END ENERGY_SALE_CONFIRMATION;


/
--------------------------------------------------------
--  DDL for Function EXCESS_ES_BANKING_BALANCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."EXCESS_ES_BANKING_BALANCE" 
(
  V_ES_ID IN VARCHAR2 
) RETURN VARCHAR2 AS 
v_created_By  varchar2(30):= 'admin';
v_status varchar2(30);
v_reason varchar2(30):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(200):='SUCCESS';
v_log_result varchar(200):='SUCCESS';
V_ES T_ENERGY_SALE%ROWTYPE;
V_ES_ORDER F_ENERGY_SALE_ORDER%ROWTYPE;
V_BB T_BANKING_BALANCE%ROWTYPE;
V_UPDATE_FLAG boolean:=false;


BEGIN

-- begin for exception handling
BEGIN

    v_log_result := log_activity('FUNCTION','EXCESS_ES_BANKING_BALANCE','START','Start - '||V_ES_ID,'','', sysdate,V_ES_ID);

    select * into V_ES from T_ENERGY_SALE where ID = V_ES_ID;


    IF V_ES.STATUS_CODE='APPROVED' THEN

        SELECT * INTO V_ES_ORDER FROM F_ENERGY_SALE_ORDER WHERE T_ENERGY_SALE_ID=V_ES_ID;

        IF V_ES_ORDER.ID IS NOT NULL THEN

            V_BB.M_COMPANY_ID:=V_ES_ORDER.SELLER_COMP_ID;  
            V_BB.BANKING_SERVICE_ID:=V_ES_ORDER.BANKING_SERVICE_ID;
            V_BB.REMARKS:=V_ES_ID;
            V_BB.MONTH:=V_ES.MONTH;
            V_BB.YEAR:=V_ES.YEAR;

            IF TO_NUMBER(V_ES.AVAIL_GC1)  > TO_NUMBER(V_ES.C1) THEN
                V_BB.C1 := (TO_NUMBER(V_ES.AVAIL_GC1) - TO_NUMBER(V_ES.C1));
                V_BB.C1 :=(V_BB.C1)-(V_BB.C1 *0.14);                    
                V_UPDATE_FLAG:=true;
            END IF;

            IF TO_NUMBER(V_ES.AVAIL_GC2)  > TO_NUMBER(V_ES.C2) THEN
                V_BB.C2 := (TO_NUMBER(V_ES.AVAIL_GC2) - TO_NUMBER(V_ES.C2));
                V_BB.C2 :=(V_BB.C2)-(V_BB.C2 *0.14); 
                V_UPDATE_FLAG:=true;
            END IF;

            IF TO_NUMBER(V_ES.AVAIL_GC3)  > TO_NUMBER(V_ES.C3) THEN
                V_BB.C3 := (TO_NUMBER(V_ES.AVAIL_GC3) - TO_NUMBER(V_ES.C3));
                V_BB.C3 :=(V_BB.C3)-(V_BB.C3 *0.14); 
                V_UPDATE_FLAG:=true;
            END IF;

            IF TO_NUMBER(V_ES.AVAIL_GC4)  > TO_NUMBER(V_ES.C4) THEN
                V_BB.C4 := (TO_NUMBER(V_ES.AVAIL_GC4) - TO_NUMBER(V_ES.C4));
                V_BB.C4 :=(V_BB.C4)-(V_BB.C4 *0.14); 
                V_UPDATE_FLAG:=true;
            END IF;

            IF TO_NUMBER(V_ES.AVAIL_GC5)  > TO_NUMBER(V_ES.C5) THEN
                V_BB.C5 := (TO_NUMBER(V_ES.AVAIL_GC5) - TO_NUMBER(V_ES.C5));
                V_BB.C5 :=(V_BB.C5)-(V_BB.C5 *0.14); 
                V_UPDATE_FLAG:=true;
            END IF;

            IF V_UPDATE_FLAG THEN
                V_BB.ID:=T_BANKING_BALANCE_SEQ.NEXTVAL;
                V_BB.ENABLED:='Y';
                V_BB.CREATED_DATE := SYSDATE;
                INSERT INTO T_BANKING_BALANCE VALUES V_BB;
            END IF;
        END IF;

    END IF;



    commit;
exception
when others then
v_exception_code := SQLCODE;
v_exception_msg := SUBSTR(SQLERRM, 1, 200);
v_result := 'FAILURE';
v_reason := v_exception_code || ' - ' || v_exception_msg;
   -- -- dbms_output.put_line(v_reason);
v_log_result := log_activity('FUNCTION','EXCESS_ES_BANKING_BALANCE','EXCEPTION',v_reason,'','', sysdate,V_ES_ID);
END;

v_log_result := log_activity('FUNCTION','EXCESS_ES_BANKING_BALANCE','END','Import complete','','', sysdate,V_ES_ID);

return V_RESULT || ' - ' || v_reason;

END EXCESS_ES_BANKING_BALANCE;


/
--------------------------------------------------------
--  DDL for Function FINANCIAL_UNUTILIZED_BANKING_REPORT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."FINANCIAL_UNUTILIZED_BANKING_REPORT" 
(
  V_MONTH IN VARCHAR2,
  V_YEAR IN VARCHAR2
) RETURN VARCHAR2 AS

v_total varchar(300);
v_log_result varchar(300):='SUCCESS';
v_exception_code VARCHAR2(150);
v_exception_msg  VARCHAR2(150);
v_reason VARCHAR2(300);
o_result_desc VARCHAR2(300);
o_result_code VARCHAR2(300);

v_table FINANCIAL_UNUTILIZED_BANKING%ROWTYPE;

BEGIN
BEGIN
    v_log_result := log_activity('FUNCTION','FINANCIAL_UNUTILIZED_BANKING_REPORT','START',V_MONTH||'-'||V_YEAR,'','', sysdate,'');

SELECT COUNT(*) INTO v_total FROM FINANCIAL_UNUTILIZED_BANKING WHERE ST_MONTH=V_MONTH AND ST_YEAR=V_YEAR;

      for bb in  ( select ROW_NUMBER() OVER (ORDER BY s."number") AS ROW_NO,s."number" as service_number,s.m_company_name,s.m_org_name,bb.remarks ,s.m_org_id,bb.curr_c1,bb.curr_c2,bb.curr_c3,bb.curr_c4,bb.curr_c5,
 bb.month month,bb.year year,pp.plant_class_type_code weg_group_code ,co.value_desc weg_group_desc,tr.rate tr_rate
 from t_banking_balance bb
 left join v_company_Service s on bb.m_Company_id=s.m_company_id
 left join m_powerplant pp on s.id=pp.m_service_id
 left join v_codes co on pp.plant_class_type_code=co.value_code and co.list_code='PLANT_CLASS_TYPE_CODE'
 left join m_tariff tr on tr.weg_group_code=pp.plant_class_type_code
 where bb.month=V_MONTH and bb.year=V_YEAR and (bb.curr_c1+ bb.curr_c2+ bb.curr_c3+ bb.curr_c4+bb.curr_c5)>0)


     loop 
        v_table.ID:=FINANCIAL_UNUTILIZED_BANKING_SEQ.NEXTVAL;
        v_table.SNO:=bb.ROW_NO;
        v_table.SERVICE_NUMBER:=bb.service_number;
        v_table.EDC_NO:=bb.m_org_id;
        v_table.EDC_NAME:=bb.m_org_name;
        v_table.C1:=trunc(bb.curr_c1);
        v_table.C2:=trunc(bb.curr_c2);
        v_table.C3:=trunc(bb.curr_c3);
        v_table.C4:=trunc(bb.curr_c4);
        v_table.C5:=trunc(bb.curr_c5);
        v_table.ST_MONTH:=V_MONTH;
        v_table.SERVICE_NAME:=bb.m_company_name;
        v_table.ST_YEAR:=V_YEAR;
        v_table.RATE:=bb.tr_rate;
        v_table.WEG_GROUP_CODE:=bb.weg_group_code;
        v_table.WEG_GROUP_DESC:=bb.weg_group_desc;
        v_table.ST_TOTAL := v_table.C1 + v_table.C2 + v_table.C3 + v_table.C4 + v_table.C5;
        v_table.UNUTILISED_ENERGY := ROUND(v_table.ST_TOTAL*0.75);
        v_table.AMOUNT:=ROUND(v_table.UNUTILISED_ENERGY*bb.tr_rate,2);

        IF v_total=0 THEN
        INSERT INTO FINANCIAL_UNUTILIZED_BANKING VALUES v_table;
        ELSE

       UPDATE FINANCIAL_UNUTILIZED_BANKING SET EDC_NO = bb.m_org_id,EDC_NAME = bb.m_org_name, SERVICE_NAME = bb.m_company_name, C1 = trunc(bb.curr_c1),C2 = trunc(bb.curr_c2),C3 = trunc(bb.curr_c3),C4 = trunc(bb.curr_c4),C5 = trunc(bb.curr_c5),
       RATE = bb.tr_rate,WEG_GROUP_CODE = bb.weg_group_code,WEG_GROUP_DESC = bb.weg_group_desc,ST_TOTAL=v_table.C1 + v_table.C2 + v_table.C3 + v_table.C4 + v_table.C5,  
       UNUTILISED_ENERGY = ROUND(v_table.ST_TOTAL*0.75),AMOUNT = ROUND(v_table.UNUTILISED_ENERGY*bb.tr_rate,2)
       WHERE SERVICE_NUMBER = bb.service_number AND ST_MONTH = V_MONTH AND ST_YEAR = V_YEAR;

        END IF;

        end loop;
         COMMIT;

        exception
    when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        o_result_code := 'FAILURE';
       END;
    COMMIT;

 RETURN 'SUCCESS';
        COMMIT;


END FINANCIAL_UNUTILIZED_BANKING_REPORT;


/
--------------------------------------------------------
--  DDL for Function FIND_MISSING_MRS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."FIND_MISSING_MRS" 
(
  v_month in varchar2, v_year in varchar2
) RETURN VARCHAR2 AS
v_unresolved_count number;
v_flow_type_code varchar2(50);
v_esi_status_code varchar2(50);
v_signup_count number:=0;
v_signup_tr_count number:=0;
--v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_signup_import_result varchar(300):='SUCCESS';
v_imported BOOLEAN;
v_signup M_SIGNUP%ROWTYPE;
v_conversion number:=0.001;

BEGIN
-- begin for exception handling
BEGIN

   v_log_result := log_activity('PROCEDURE','FIND_MISSING_MRS','START','Start v_month-'||v_month||'v_year-'||v_year,'','', sysdate,v_month,v_year);

  delete from TEMP_MISSING_MR_SERVICES where READING_MONTH =v_month and READING_YEAR = v_year ;
  commit;
  insert into TEMP_MISSING_MR_SERVICES
  select circlecode,serviceno, meterno,'Y','',v_month,v_year from (
  SELECT  distinct substr( "number",6,3)  circlecode, "number" serviceno, c.METER_NUMBER meterno
   FROM V_COMPANY_SERVICE c
   WHERE
   COMPANY_IS_INTERNAL = 'N' AND COMP_SER_TYPE_CODE = '03'
   and  length("number")=12
   minus
   SELECT  distinct substr( "number",6,3)  circlecode, "number" serviceno, c.METER_NUMBER meterno
   FROM V_COMPANY_SERVICE c,T_METER_READING_HDR a
   WHERE
   COMPANY_IS_INTERNAL = 'N' AND COMP_SER_TYPE_CODE = '03'
   and  length("number")=12
   and C.M_COMPANY_METER_ID=A.M_COMPANY_METER_ID
   and READING_MONTH =v_month and READING_YEAR = v_year
   );

  -- records not in AMR
  FOR i IN ( select serviceno  from TEMP_MISSING_MR_SERVICES where READING_MONTH =v_month and READING_YEAR = v_year
               minus
                 select distinct a.serviceno  from UV_TBL_HISTORY_SLOT a  where  TO_CHAR(INITIAL_READING_DATE,'MM') =v_month and  TO_CHAR(INITIAL_READING_DATE,'YYYY') =  v_year
            )
  LOOP
    update TEMP_MISSING_MR_SERVICES set in_amr = 'N', remarks='Service Number not in AMR' where remarks is null and  serviceno = i.serviceno  and  READING_MONTH =v_month and READING_YEAR = v_year;
  END LOOP;


  -- records not in AMR during the given period
  FOR i IN ( select serviceno from UV_TBL_HISTORY_SLOT where serviceno in 
              (select serviceno from TEMP_MISSING_MR_SERVICES miss
              where miss.remarks='Service Number not in AMR'  and miss.READING_MONTH =v_month and miss.READING_YEAR = v_year) 
            )
  LOOP
    update TEMP_MISSING_MR_SERVICES set in_amr = 'N', remarks='Service Number not in AMR for '||v_month||'-'||v_year where  serviceno = i.serviceno  and  READING_MONTH =v_month and READING_YEAR = v_year;
  END LOOP;

 -- records  in AMR but meter-no doesnt match
  FOR i IN ( select distinct  l.service_no, l.remarks from imp_mr_lines l
              inner join imp_mr_header h on l.imp_mr_header_id = h.id
              where 1=1
              --and l.remarks is not null
              and nvl(l.remarks,'')  in ('Wrong ServiceNo-MeterNo combo','Unknown Service-no')
              and l.status_code in ('CLEANSED','ERROR','IMPORTED')
              and h.status in ('IMPORT-ERROR', 'COMPLETED')
              and READING_MONTH = v_month  and READING_YEAR =  v_year
              and nvl(service_no,'')   in (
               select serviceno from  TEMP_MISSING_MR_SERVICES where remarks is null and  READING_MONTH =v_month and READING_YEAR = v_year )
            )
  LOOP
    update TEMP_MISSING_MR_SERVICES set   remarks=i.remarks where  remarks is null and serviceno = i.service_no  and  READING_MONTH =v_month and READING_YEAR = v_year;
  END LOOP;

  -- records  in AMR but unit values in imp_mr_lines is null
  FOR i IN ( select distinct  l.service_no, nvl(l.remarks,'') remarks from imp_mr_lines l
              where 1=1
               and TO_CHAR(to_date(l.INIT_READING_DT,'YYYY-MM-DD'),'MM') =v_month and  TO_CHAR(to_date(l.INIT_READING_DT,'YYYY-MM-DD'),'YYYY') =  v_year
             and (   EXP_FINAL_S1 is null or EXP_FINAL_S2 is null or EXP_FINAL_S3 is null or EXP_FINAL_S4 is null or EXP_FINAL_S5 is null
                     or   IMP_FINAL_S1 is null or IMP_FINAL_S2 is null or IMP_FINAL_S3 is null or IMP_FINAL_S4 is null or IMP_FINAL_S5 is null  )
            )
  LOOP
    update TEMP_MISSING_MR_SERVICES set   remarks='One of the INIT values is null' where remarks is null and serviceno = i.service_no  and  READING_MONTH =v_month and READING_YEAR = v_year;
  END LOOP;

   -- records  in AMR but dont know
  FOR i IN ( select distinct  l.service_no, l.remarks from imp_mr_lines l
              where 1=1
              --and l.remarks is not null
             -- and l.status_code in ('CLEANSED','ERROR','IMPORTED')
              and READING_MONTH = v_month  and READING_YEAR =  v_year
              and nvl(service_no,'')   in (
               select serviceno from  TEMP_MISSING_MR_SERVICES where remarks is null and  READING_MONTH =v_month and READING_YEAR = v_year )
            )
  LOOP
    update TEMP_MISSING_MR_SERVICES set   remarks=i.remarks where  remarks is null and serviceno = i.service_no  and  READING_MONTH =v_month and READING_YEAR = v_year;
  END LOOP;

  -- records  in AMR but unit values in AMR'sview is null
  FOR i IN ( select distinct  l.serviceno  from UV_TBL_HISTORY_SLOT l
              where 1=1
               and TO_CHAR( l.INITIAL_READING_DATE ,'MM') =v_month and  TO_CHAR( l.INITIAL_READING_DATE,'YYYY') =  v_year
             and (   EXP_FINAL_S1 is null or EXP_FINAL_S2 is null or EXP_FINAL_S3 is null or EXP_FINAL_S4 is null or EXP_FINAL_S5 is null
                     or   IMP_FINAL_S1 is null or IMP_FINAL_S2 is null or IMP_FINAL_S3 is null or IMP_FINAL_S4 is null or IMP_FINAL_S5 is null  )
            )
  LOOP
    update TEMP_MISSING_MR_SERVICES set   remarks='One of the unit values is null' where remarks is null and serviceno = i.serviceno  and  READING_MONTH =v_month and READING_YEAR = v_year;
  END LOOP;


  select count(*) into v_unresolved_count from TEMP_MISSING_MR_SERVICES where  READING_MONTH =v_month and READING_YEAR = v_year and remarks is null;
  -- dbms_output.put_line('unresolved services-'||v_unresolved_count);

  update TEMP_MISSING_MR_SERVICES set   remarks = 'UNRESOLVED' where remarks is null;
  v_log_result := log_activity('PROCEDURE','FIND_MISSING_MRS','END','unresolved services-'||v_unresolved_count,'','', sysdate,v_month,v_year);
  v_log_result := log_activity('PROCEDURE','FIND_MISSING_MRS','END','process complete','','', sysdate,v_month,v_year);
exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      -- -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('PROCEDURE','FIND_MISSING_MRS','EXCEPTION',v_reason,'','', sysdate,v_month,v_year);
END;
commit;
return V_RESULT || ' - ' || v_reason;

END FIND_MISSING_MRS;


/
--------------------------------------------------------
--  DDL for Function FIND_PREV_MR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."FIND_PREV_MR" 
(
  V_METER_READING_HDR_ID IN VARCHAR2 , FETCH_RECORD_TO_MERGE IN VARCHAR2 DEFAULT 'Y'
) RETURN VARCHAR2 is
v_result varchar(25) := null;
BEGIN
  /**
    GET FIRST RECORD
    if FETCH_RECORD_TO_MERGE = 'Y',
      check if the previous meter reading is labelled for merge.
        return id
    else
      return id
  **/
  for mr in (select mr.id, nvl(mr.merge_with_next_billing,'N') merge_with_next_billing from t_meter_reading_hdr mr join t_meter_reading_hdr curr on curr.m_company_meter_id=mr.m_company_meter_id and curr.id = V_METER_READING_HDR_ID
                  where  mr.final_reading_dt < curr.init_reading_dt
                  order by mr.final_reading_dt desc)
  loop
    if(FETCH_RECORD_TO_MERGE = 'Y') then
      if(mr.merge_with_next_billing = 'Y') then
        v_result:=mr.id;
      end if;
    else
      v_result:=mr.id;
    end if;
    exit;
  end loop;

  RETURN v_result;
END;


/
--------------------------------------------------------
--  DDL for Function GET_LOCK_ON_CATALOG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."GET_LOCK_ON_CATALOG" (lock_type IN integer) 
return integer 
authid current_user
is
lock_handle varchar2(128);
ret integer;
str1 varchar2(256);
str2 varchar2(100);
x_mode number;
s_mode number;
begin
--
--
--
--
--
--
--
--
--
--

   str2 := 'ORA$RMAN_CATALOG_LOCK';
   str1 := 'begin dbms_lock.allocate_unique(:1||dbms_catowner, :2,'||
              ' 2147483647); end;';
   execute immediate str1 using str2, out lock_handle; 

   ret := -1;

--
--

   str1 := 'begin :1 := dbms_lock.X_MODE ; :2 := dbms_lock.S_MODE; end;';
   execute immediate str1 using out x_mode, out s_mode;

   if (lock_type = x_mode) then
--
      if (user = dbms_catowner) then
--
--
--

         str1 := 'begin :1 := dbms_lock.convert(:2, dbms_lock.X_MODE,1); end;';
         execute immediate str1 using out ret, lock_handle;  

--
--
--
--
--
         if (ret = 4) then 
--
            str1 :=  'begin :1 := dbms_lock.request(:2, dbms_lock.X_MODE, 1, '||
                        ' FALSE); end;'; 
            execute immediate str1 using out ret, lock_handle;
         end if;
      end if;

   elsif (lock_type = s_mode) then
      if (user = dbms_catowner) then
--
--

         str1 := 'begin :1 := dbms_lock.request(:2, dbms_lock.S_MODE, 1, '||
                    ' FALSE); end;';
         execute immediate str1 using out ret, lock_handle;
--
--
--
         if (ret != 0) then
            str1 := 'begin :1  := dbms_lock.convert(:2, dbms_lock.S_MODE, 1);'||
                       ' end;';
            execute immediate str1 using out ret, lock_handle;

--
--
            if (ret != 0) then
               ret := 1;
            end if;
         end if;
--
      else
         str1 := 'begin :1 := dbms_lock.request(:2, dbms_lock.S_MODE, 1,'||
                    ' FALSE); end;';
         execute immediate str1 using OUT ret, lock_handle;
      end if;
   end if;

   return ret;
end get_lock_on_catalog;


/
--------------------------------------------------------
--  DDL for Function HANDLE_DUP_FOR_HTUNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."HANDLE_DUP_FOR_HTUNITS" RETURN VARCHAR2 AS 
V_RES1 VARCHAR2(100);
V_RES2 VARCHAR2(100);
V_BATCHKEY VARCHAR2(100);
V_LOG VARCHAR2(100);

BEGIN

--SELECT ID FROM INT_SURPLUS_UNIT WHERE SUPLR_CODE='039224320143' AND SERVICE_NO='039094390403' AND READING_MNTH='1' AND READING_YR='2019' AND ROWNUM=1;
--SELECT DISTINCT SUPLR_CODE,SERVICE_NO,READING_MNTH,READING_YR FROM INT_SURPLUS_UNIT WHERE READING_MNTH='1';

--FOR surplusUnits IN (SELECT DISTINCT SUPLR_CODE,SERVICE_NO,READING_MNTH,READING_YR FROM INT_SURPLUS_UNIT WHERE READING_MNTH='1')
--LOOP
--INSERT INTO INT_SURPLUS_UNIT_2(ID,BATCH_KEY,SERVICE_NO,SUPLR_CODE,SUPLR_TYPE,READING_DT,READING_MNTH,READING_YR,C24,C1,C2,C3,C4,C5,
--CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,BUYER_COMPANY_ID,BUYER_COMPANY_SERVICE_ID,SELLER_COMPANY_ID,SELLER_COMPANY_SERVICE_ID,FUEL_TYPE_CODE,
--IMPORT_REMARKS,SOURCE,IMPORTED,SUPLR_NAME,DELETE_FLAG)
--SELECT ID,BATCH_KEY,SERVICE_NO,SUPLR_CODE,SUPLR_TYPE,READING_DT,READING_MNTH,READING_YR,C24,C1,C2,C3,C4,C5,
--CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,BUYER_COMPANY_ID,BUYER_COMPANY_SERVICE_ID,SELLER_COMPANY_ID,SELLER_COMPANY_SERVICE_ID,FUEL_TYPE_CODE,
--IMPORT_REMARKS,SOURCE,IMPORTED,SUPLR_NAME,DELETE_FLAG FROM INT_SURPLUS_UNIT WHERE SUPLR_CODE=surplusUnits.SUPLR_CODE 
--AND SERVICE_NO=surplusUnits.SERVICE_NO AND READING_MNTH=surplusUnits.READING_MNTH AND READING_YR=surplusUnits.READING_YR AND ROWNUM=1; 
--END LOOP;

FOR batchkey in(select distinct batch_key from int_surplus_unit_2 where READING_MNTH='1')
LOOP

V_BATCHKEY:=batchkey.batch_key;

            BANKING_BALANCE.increment_surplus_units(V_BATCHKEY,V_RES1,V_RES2);
V_LOG:=log_activity('PROCEDURE','HANDLE_DUP_FOR_HTUNITS','int_surplus_unit_2',V_BATCHKEY, V_BATCHKEY,'admin', sysdate,V_BATCHKEY);
END LOOP;
  RETURN 'SUCCESS';
END HANDLE_DUP_FOR_HTUNITS;


/
--------------------------------------------------------
--  DDL for Function IMPORT_AND_PROCESS_MRI_BATCH
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."IMPORT_AND_PROCESS_MRI_BATCH" 
(
  v_imp_batch_id in varchar2
) RETURN VARCHAR2 AS

v_batch_based boolean:=false;
v_duration_based boolean:=false;
v_process_id  VARCHAR2(50);
v_records_processed number:=0;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';

BEGIN

	BEGIN

    v_log_result := log_activity('PROCEDURE','IMPORT_AND_PROCESS_MRI_BATCH','START','Start',NULL,v_created_By, sysdate,v_imp_batch_id);

    -- goto THE_END;
    v_result := import_mr(v_imp_batch_id);
    v_log_result := log_activity('PROCEDURE','IMPORT_AND_PROCESS_MRI_BATCH','import_mr','called',v_result,v_created_By, sysdate,v_imp_batch_id);

    if (instr(v_result,'SUCCESS') > 0) then
	    v_result := create_gs(v_imp_batch_id, null, null);
	    v_log_result := log_activity('PROCEDURE','IMPORT_AND_PROCESS_MRI_BATCH','create_gs','called',v_result,v_created_By, sysdate,v_imp_batch_id);
	     if (instr(v_result,'FAILURE') > 0) then
	        v_reason := v_result;
            v_result := 'FAILURE';
	      end if;
    ELSE
     v_reason := v_result;
     -- v_result := 'FAILURE';
    end if;


	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
	    ---- dbms_output.put_line(v_reason);
      v_log_result := log_activity('PROCEDURE','IMPORT_AND_PROCESS_MRI_BATCH','EH',v_reason,v_result,v_created_By, sysdate,v_imp_batch_id );
	END;
   <<THE_END>>

  v_log_result := log_activity('PROCEDURE','IMPORT_AND_PROCESS_MRI_BATCH','END',v_reason,v_result,v_created_By, sysdate,v_imp_batch_id );

  COMMIT;

  return v_result;

END IMPORT_AND_PROCESS_MRI_BATCH;


/
--------------------------------------------------------
--  DDL for Function IMPORT_CONSUMERS_FROM_SIGNUP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."IMPORT_CONSUMERS_FROM_SIGNUP" (
    v_remarks IN VARCHAR2 )
  RETURN VARCHAR2
AS
  v_is_complete      VARCHAR2(50);
  v_incomplete_count NUMBER;
  v_status           VARCHAR2(50);
  v_reason           VARCHAR2(200);
  v_exception_code   NUMBER;
  v_exception_msg    VARCHAR2(64);
  v_result           VARCHAR(200):='SUCCESS';
BEGIN
  BEGIN
    IF(v_remarks IS NULL OR v_remarks = '') THEN
      v_reason   := 'Remarks is mandatory';
      V_RESULT   := 'FAILURE';
      GOTO THE_END;
    ELSE
      SELECT COUNT(id) INTO v_incomplete_count FROM m_SIGNUP WHERE NVL(REMARKS,'') = v_remarks AND is_complete  = 'N';
      IF(v_incomplete_count = 0)THEN
        v_reason           := 'No Records to import with the given remark';
        V_RESULT           := 'FAILURE';
        GOTO THE_END;
      ELSE
        FOR signup IN (SELECT id FROM m_SIGNUP WHERE NVL(REMARKS,'')= v_remarks )
        LOOP
          BEGIN
            v_result:=CONFIRM_SIGNUP(signup.id);
          EXCEPTION
          WHEN OTHERS THEN
            v_exception_code := SQLCODE;
            v_exception_msg  := SUBSTR(SQLERRM, 1, 100);
            v_result         := 'FAILURE' || ' - ' || v_exception_code || ' - ' || v_exception_msg;
            -- dbms_output.put_line('Isse in loop-'||v_result);
          END;
        END LOOP;
      END IF;
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 64);
    v_result         := 'FAILURE';
    v_reason         := v_exception_code || ' - ' || v_exception_msg;
  END;
<<THE_END>>
IF V_RESULT = 'SUCCESS' THEN
  COMMIT;
ELSE
  v_result := v_result || ' - ' || v_reason;
END IF;
RETURN v_result;
END IMPORT_CONSUMERS_FROM_SIGNUP;


/
--------------------------------------------------------
--  DDL for Function IMPORT_FROM_SIGNUP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."IMPORT_FROM_SIGNUP" (
    v_remarks IN VARCHAR2 )
  RETURN VARCHAR2
AS
  v_is_complete      VARCHAR2(50);
  v_incomplete_count NUMBER;
  v_status           VARCHAR2(50);
  v_reason           VARCHAR2(200);
  v_exception_code   NUMBER;
  v_exception_msg    VARCHAR2(200);
  v_result           VARCHAR(200):='SUCCESS';
  v_log_result varchar(300):='SUCCESS';
  v_signup_id VARCHAR2(200);
BEGIN
  BEGIN    
    v_log_result := log_activity('PROCEDURE','IMPORT_FROM_SIGNUP','Start','Import - '||v_remarks,'','', sysdate,v_remarks);

    IF(v_remarks IS NULL OR v_remarks = '') THEN
      v_reason   := 'Remarks is mandatory';
      V_RESULT   := 'FAILURE';
      GOTO THE_END;
    ELSE
      SELECT COUNT(id) INTO v_incomplete_count FROM m_SIGNUP WHERE NVL(REMARKS,'') = v_remarks AND is_complete  = 'N';
      IF(v_incomplete_count = 0)THEN
        v_reason           := 'No Records to import with the given remark';
        V_RESULT           := 'FAILURE';
        GOTO THE_END;
      ELSE
        FOR signup IN (SELECT id FROM m_SIGNUP WHERE NVL(REMARKS,'')= v_remarks )
        LOOP
          BEGIN
            V_SIGNUP_ID := signup.id;
            v_log_result := log_activity('PROCEDURE','IMPORT_FROM_SIGNUP','Loop','Start - '||V_SIGNUP_ID,V_RESULT,v_reason, sysdate,v_remarks,V_SIGNUP_ID);
            v_result:=CONFIRM_SIGNUP(signup.id);
          EXCEPTION
          WHEN OTHERS THEN
            v_exception_code := SQLCODE;
            v_exception_msg  := SUBSTR(SQLERRM, 1, 200);
            v_result         := 'FAILURE' || ' - ' || v_exception_code || ' - ' || v_exception_msg;
            v_log_result := log_activity('PROCEDURE','IMPORT_FROM_SIGNUP','EH-Loop','Exception - '||v_exception_code,V_RESULT,v_reason, sysdate,v_remarks,V_SIGNUP_ID);
            -- -- dbms_output.put_line('Isse in loop-'||v_result);
          END;
        END LOOP;
      END IF;
    END IF;
  EXCEPTION
  WHEN OTHERS THEN
    v_exception_code := SQLCODE;
    v_exception_msg  := SUBSTR(SQLERRM, 1, 200);
    v_result         := 'FAILURE';
    v_reason         := v_exception_code || ' - ' || v_exception_msg;
    v_log_result := log_activity('PROCEDURE','IMPORT_FROM_SIGNUP','EH','Exception - '||v_exception_code,V_RESULT,v_reason, sysdate,v_remarks);
  END;
<<THE_END>>
IF V_RESULT = 'SUCCESS' THEN
  COMMIT;
ELSE
  v_result := v_result || ' - ' || v_reason;
END IF;
RETURN v_result;
END IMPORT_FROM_SIGNUP;


/
--------------------------------------------------------
--  DDL for Function IMPORT_MR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."IMPORT_MR" 
(
  V_BATCH_ID IN VARCHAR2
) RETURN VARCHAR2 AS
v_mrh T_METER_READING_HDR%ROWTYPE;
v_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_mr_c5 T_METER_READING_SLOT%ROWTYPE;
v_meter_id VARCHAR2(100);
v_imported BOOLEAN:=FALSE;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_process_count number;
v_reason varchar2(200);
v_exception_code  NUMBER;
v_source varchar2(50);
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_total_count number;
v_success_count number;
v_error_count number;
v_log_result VARCHAR2(50):='';

BEGIN

	BEGIN
		v_log_result := log_activity('PROCEDURE','IMPORT_MR','START','Start - '||V_BATCH_ID,V_RESULT,v_created_By, sysdate,V_BATCH_ID);

		select count(id) into v_process_count from imp_mr_header where status ='PROCESSING';

		-- if the batch is already processing, then stop flow
		if(v_process_count > 0) then
			v_reason := 'Another Batch is already processing . please wait';
		    V_RESULT := 'FAILURE';
		    GOTO THE_END;
		end if;

		-- find the total no. of records to be imported
		select count(import_remarks) into v_total_count from imp_mr_header where id =v_batch_id;

		-- set the batch to PROCESSING
		update imp_mr_header set status='PROCESSING', total_count=v_total_count, MODIFIED_DATE = sysdate where id = v_batch_id;
			SELECT mr_source_code INTO v_source FROM IMP_MR_HEADER WHERE ID = v_batch_id;

		-- cleanup the imported meter lines, by ignoring dirty data
		v_result := CLEANSE_MRI(v_batch_id);

		if(substr(v_result,0,7) = 'FAILURE') THEN
			 ---- dbms_output.put_line('cleanse result - '||v_result);
		 	GOTO THE_END;
		END IF;

		--loop through clean imported meter entries
		FOR mri IN (SELECT mri.* FROM IMP_MR_lines mri WHERE mri.IMP_MR_HEADER_ID = v_batch_id and mri.status_code = 'CLEANSED')
		LOOP
   		begin

	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','loop start',mri.meter_no,null,'', sysdate,V_BATCH_ID);
		  	-- get meter-id
		  	SELECT DISTINCT meter.id INTO v_meter_id FROM M_COMPANY_METER  meter
		  		JOIN M_COMPANY_SERVICE ser ON ser."number" = mri.SERVICE_NO AND meter.M_COMPANY_SERVICE_ID = ser.id WHERE METER_NUMBER = mri.meter_no and meter.ENABLED='Y';
		 	--setting meter-header record
		 	v_mrh.id := T_METER_READING_SEQ.nextval;
			v_mrh.M_COMPANY_METER_ID := v_meter_id;
			v_mrh.STATUS_CODE := 'CREATED';
			v_mrh.IMP_BATCH_ID :=  mri.IMP_MR_HEADER_ID;
			v_mrh.sys_dt := v_created_Date;
			v_mrh.mf :=  mri.mf;
			v_mrh.READING_MONTH := mri.READING_MONTH;
			v_mrh.READING_YEAR := mri.READING_YEAR;
			v_mrh.INIT_READING_DT := to_date(mri.INIT_READING_DT,'yyyy-mm-dd');
			v_mrh.FINAL_READING_DT := to_date(mri.FINAL_READING_DT,'yyyy-mm-dd');
      v_mrh.MERGE_WITH_NEXT_BILLING := NVL(mri.MERGE_WITH_NEXT_BILLING,'N');
			v_mrh.EXP_RKVAH_FINAL := mri.EXP_RKVAH_FINAL; v_mrh.EXP_RKVAH_INIT := mri.EXP_RKVAH_INIT;
			v_mrh.IMP_RKVAH_FINAL := mri.IMP_RKVAH_FINAL; v_mrh.IMP_RKVAH_INIT := mri.IMP_RKVAH_INIT;
			v_mrh.EXP_KVAH_FINAL := mri.EXP_KVAH_FINAL; v_mrh.EXP_KVAH_INIT := mri.EXP_KVAH_INIT;
			v_mrh.IMP_KVAH_FINAL := mri.IMP_KVAH_FINAL; v_mrh.IMP_KVAH_INIT := mri.IMP_KVAH_INIT;
			v_mrh.RKVAH_DIFF := nvl(mri.IMP_RKVAH_FINAL,0) - nvl(mri.IMP_RKVAH_INIT, 0);
			v_mrh.RKVAH_UNITS := v_mrh.RKVAH_DIFF*mri.mf;
			v_mrh.KVAH_DIFF := nvl((mri.EXP_KVAH_FINAL - mri.EXP_KVAH_INIT)- (mri.IMP_KVAH_FINAL - mri.IMP_KVAH_INIT), 0);
--            v_mrh.KVAH_DIFF := nvl(( mri.IMP_KVAH_FINAL - mri.IMP_KVAH_INIT), 0);
			v_mrh.KVAH_UNITS := v_mrh.KVAH_DIFF*mri.mf;
            v_mrh.MR_SOURCE_CODE := v_source ;

			--v_mrh.TOTAL_IMPORT_GEN := ;
			--v_mrh.TOTAL_EXPORT_GEN := ;
			v_mrh.CREATED_BY := v_created_By;
			v_mrh.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_HDR VALUES v_mrh;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','insert meter-header record',null,'', sysdate,V_BATCH_ID);


			--setting meter-reading for slot1
			v_mr_c1.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c1.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c1.SLOT_CODE := 'C1' ;
			v_mr_c1.IMP_INIT := nvl(mri.IMP_INIT_S1,0);
			v_mr_c1.IMP_FINAL := nvl(mri.IMP_FINAL_S1,0);
			v_mr_c1.EXP_INIT := nvl(mri.EXP_INIT_S1,0);
			v_mr_c1.EXP_FINAL := nvl(mri.EXP_FINAL_S1,0);
			v_mr_c1.IMP_DIFF := v_mr_c1.IMP_FINAL - v_mr_c1.IMP_INIT ;
			v_mr_c1.EXP_DIFF := v_mr_c1.EXP_FINAL - v_mr_c1.EXP_INIT ;
			v_mr_c1.IMP_UNITS := round(nvl(v_mr_c1.IMP_DIFF * mri.mf,0),0);
			v_mr_c1.EXP_UNITS :=  round(nvl(v_mr_c1.EXP_DIFF * mri.mf,0),0);
			v_mr_c1.net_units := v_mr_c1.EXP_UNITS - v_mr_c1.IMP_UNITS ;
			if(v_mr_c1.net_units <0) THEN v_mr_c1.net_units := 0; END IF;
			v_mr_c1.CREATED_BY := v_created_By;
			v_mr_c1.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c1;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','slot-1',null,'', sysdate,V_BATCH_ID);


			--setting meter-reading for slot2
			v_mr_c2.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c2.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c2.SLOT_CODE := 'C2' ;
			v_mr_c2.IMP_INIT := nvl(mri.IMP_INIT_S2,0);
			v_mr_c2.IMP_FINAL := nvl(mri.IMP_FINAL_S2,0);
			v_mr_c2.EXP_INIT := nvl(mri.EXP_INIT_S2,0);
			v_mr_c2.EXP_FINAL := nvl(mri.EXP_FINAL_S2,0);
			v_mr_c2.IMP_DIFF := v_mr_c2.IMP_FINAL - v_mr_c2.IMP_INIT ;
			v_mr_c2.EXP_DIFF := v_mr_c2.EXP_FINAL - v_mr_c2.EXP_INIT ;
			v_mr_c2.IMP_UNITS := round(nvl(v_mr_c2.IMP_DIFF * mri.mf,0),0);
			v_mr_c2.EXP_UNITS := round(nvl(v_mr_c2.EXP_DIFF * mri.mf,0),0);
			v_mr_c2.net_units := v_mr_c2.EXP_UNITS - v_mr_c2.IMP_UNITS ;
			if(v_mr_c2.net_units <0) THEN v_mr_c2.net_units := 0; END IF;
			v_mr_c2.CREATED_BY := v_created_By;
			v_mr_c2.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c2;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','slot-2',null,'', sysdate,V_BATCH_ID);


			--setting meter-reading for slot3
			v_mr_c3.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c3.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c3.SLOT_CODE := 'C3' ;
			v_mr_c3.IMP_INIT := nvl(mri.IMP_INIT_S3,0);
			v_mr_c3.IMP_FINAL := nvl(mri.IMP_FINAL_S3,0);
			v_mr_c3.EXP_INIT := nvl(mri.EXP_INIT_S3,0);
			v_mr_c3.EXP_FINAL := nvl(mri.EXP_FINAL_S3,0);
			v_mr_c3.IMP_DIFF := v_mr_c3.IMP_FINAL - v_mr_c3.IMP_INIT ;
			v_mr_c3.EXP_DIFF := v_mr_c3.EXP_FINAL - v_mr_c3.EXP_INIT ;
			v_mr_c3.IMP_UNITS := round(nvl(v_mr_c3.IMP_DIFF * mri.mf,0),0);
			v_mr_c3.EXP_UNITS := round(nvl(v_mr_c3.EXP_DIFF * mri.mf,0),0);
			v_mr_c3.net_units := v_mr_c3.EXP_UNITS - v_mr_c3.IMP_UNITS ;
			if(v_mr_c3.net_units <0) THEN v_mr_c3.net_units := 0; END IF;
			v_mr_c3.CREATED_BY := v_created_By;
			v_mr_c3.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c3;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','slot-3',null,'', sysdate,V_BATCH_ID);

			--setting meter-reading for slot4
			v_mr_c4.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c4.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c4.SLOT_CODE := 'C4' ;
			v_mr_c4.IMP_INIT := nvl(mri.IMP_INIT_S4,0);
			v_mr_c4.IMP_FINAL := nvl(mri.IMP_FINAL_S4,0);
			v_mr_c4.EXP_INIT := nvl(mri.EXP_INIT_S4,0);
			v_mr_c4.EXP_FINAL := nvl(mri.EXP_FINAL_S4,0);
			v_mr_c4.IMP_DIFF := v_mr_c4.IMP_FINAL - v_mr_c4.IMP_INIT ;
			v_mr_c4.EXP_DIFF := v_mr_c4.EXP_FINAL - v_mr_c4.EXP_INIT ;
			v_mr_c4.IMP_UNITS := round(nvl(v_mr_c4.IMP_DIFF * mri.mf,0),0);
			v_mr_c4.EXP_UNITS := round(nvl(v_mr_c4.EXP_DIFF * mri.mf,0),0);
			v_mr_c4.net_units := v_mr_c4.EXP_UNITS - v_mr_c4.IMP_UNITS ;
			if(v_mr_c4.net_units <0) THEN v_mr_c4.net_units := 0; END IF;
			v_mr_c4.CREATED_BY := v_created_By;
			v_mr_c4.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c4;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','slot-4',null,'', sysdate,V_BATCH_ID);


			--setting meter-reading for slot5
			v_mr_c5.ID := T_METER_READING_SLOT_SEQ.nextval;
			v_mr_c5.T_METER_READING_HDR_ID :=  v_mrh.id;
			v_mr_c5.SLOT_CODE := 'C5' ;
			v_mr_c5.IMP_INIT := nvl(mri.IMP_INIT_S5,0);
			v_mr_c5.IMP_FINAL := nvl(mri.IMP_FINAL_S5,0);
			v_mr_c5.EXP_INIT := nvl(mri.EXP_INIT_S5,0);
			v_mr_c5.EXP_FINAL := nvl(mri.EXP_FINAL_S5,0);
			v_mr_c5.IMP_DIFF := v_mr_c5.IMP_FINAL - v_mr_c5.IMP_INIT ;
			v_mr_c5.EXP_DIFF := v_mr_c5.EXP_FINAL - v_mr_c5.EXP_INIT ;
			v_mr_c5.IMP_UNITS := round(nvl(v_mr_c5.IMP_DIFF * mri.mf,0),0);
			v_mr_c5.EXP_UNITS := round(nvl(v_mr_c5.EXP_DIFF * mri.mf,0),0);
			v_mr_c5.net_units := v_mr_c5.EXP_UNITS - v_mr_c5.IMP_UNITS ;
			if(v_mr_c5.net_units <0) THEN v_mr_c5.net_units := 0; END IF;
			v_mr_c5.CREATED_BY := v_created_By;
			v_mr_c5.CREATED_DATE := v_created_Date;
			INSERT INTO T_METER_READING_SLOT VALUES v_mr_c5;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','slot-5',null,'', sysdate,V_BATCH_ID);


			UPDATE T_METER_READING_HDR SET
					total_import_gen = v_mr_c1.IMP_UNITS + v_mr_c2.IMP_UNITS + v_mr_c3.IMP_UNITS + v_mr_c4.IMP_UNITS + v_mr_c5.IMP_UNITS,
					total_export_gen = v_mr_c1.EXP_UNITS + v_mr_c2.EXP_UNITS + v_mr_c3.EXP_UNITS + v_mr_c4.EXP_UNITS + v_mr_c5.EXP_UNITS,
					net_gen_units = v_mr_c1.NET_UNITS + v_mr_c2.NET_UNITS + v_mr_c3.NET_UNITS + v_mr_c4.NET_UNITS + v_mr_c5.NET_UNITS
					WHERE id = v_mrh.id;
	        v_log_result := log_activity('PROCEDURE','IMPORT_MR','log','updated',null,'', sysdate,V_BATCH_ID);

	    		update IMP_MR_lines set STATUS_CODE = 'IMPORTED' where id = mri.id;

	   		v_imported := TRUE;

		    exception
			  when others then
			    v_exception_code := SQLCODE;
			    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
			    v_result := 'FAILURE';
			    v_reason := v_exception_code || ' - ' || v_exception_msg;
			    v_log_result := log_activity('PROCEDURE','IMPORT_MR','LOOP-EXCEPTION','End - '||V_BATCH_ID,v_result || ' - ' || v_reason,v_created_By, sysdate,V_BATCH_ID, mri.SERVICE_NO, mri.METER_NO);
			   -- -- dbms_output.put_line('IMPORT_MR - '||v_reason);
			END;
	  		v_result := 'SUCCESS'; -- resetting result after every loop. as individual loop's result doesnt affect overall procedure's result.
		 END LOOP;

	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
     v_log_result := log_activity('PROCEDURE','IMPORT_MR','EXCEPTION',v_reason,V_RESULT,v_created_By, sysdate,V_BATCH_ID);
	   -- -- dbms_output.put_line('IMPORT_MR - '||v_reason);
	END;
   <<THE_END>>

	IF (NOT v_imported) THEN
	  	v_result := 'FAILURE';
	  	v_reason := 'No clean meter reading available to process';
	END IF;


	select count(STATUS_CODE) into v_success_count from imp_mr_lines where imp_mr_header_id= v_batch_id and status_code='IMPORTED';
	select count(STATUS_CODE) into v_error_count from imp_mr_lines where imp_mr_header_id= v_batch_id and status_code<>'IMPORTED';

	IF V_RESULT = 'SUCCESS' THEN
	    update imp_mr_header set status='COMPLETED', REMARKS = '' , success_count= v_success_count, error_count= v_error_count where id = v_batch_id;
	ELSE
	    update imp_mr_header set status='IMPORT-ERROR', REMARKS=v_reason , success_count= v_success_count, error_count= v_error_count where id = v_batch_id;
	    v_result := v_result || ' - ' || v_reason;
	END IF;

	COMMIT;

	v_log_result := log_activity('PROCEDURE','IMPORT_MR','END','End - '||V_BATCH_ID,V_RESULT,v_created_By, sysdate,V_BATCH_ID);

	return v_result;

END IMPORT_MR;


/
--------------------------------------------------------
--  DDL for Function IS_LEAP_YEAR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."IS_LEAP_YEAR" (nYr in number) return VARCHAR2 is
v_day varchar2(2);
begin
  select to_char(last_day(to_date( '01-FEB-'|| to_char(nYr), 'DD-MON-YYYY')), 'DD') into v_day from dual;
  if v_day = '29' then -- if v_day = 29 then it must be a leap year, return TRUE
    return 'TRUE';
  else
    return 'FALSE';  -- otherwise year is not a leap year, return false
  end if;
end;



/
--------------------------------------------------------
--  DDL for Function IS_NUMBER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."IS_NUMBER" (p_string IN VARCHAR2)
   RETURN INT
IS
   v_new_num NUMBER;
BEGIN
   v_new_num := TO_NUMBER(p_string);
   RETURN 1;
EXCEPTION
WHEN VALUE_ERROR THEN
   RETURN 0;
END is_number;


/
--------------------------------------------------------
--  DDL for Function LOG_ACTIVITY
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."LOG_ACTIVITY" 
(
  v_type IN VARCHAR2,
  v_process IN VARCHAR2,
  v_activity IN VARCHAR2,
  v_message IN VARCHAR2,
  v_result IN VARCHAR2,
  v_created_by IN VARCHAR2,
  v_att1 in varchar2 default null,
  v_att2 in varchar2 default null,
  v_att3 in varchar2 default null,
  v_att4 in varchar2 default null
) RETURN VARCHAR2 AS
BEGIN
	BEGIN
         dbms_output.enable(null);

			INSERT INTO T_ACTIVITY_LOG (ID,PROCESS_TYPE,PROCESS_NAME,ACTIVITY_NAME,MESSAGE,"result",CREATED_BY,CREATED_DT, att1, att2, att3, att4)
			VALUES (t_activity_log_seq.nextval,v_type,v_process,v_activity,v_message,v_result,v_created_by,sysdate,v_att1,v_att2,v_att3,v_att4) ;
			COMMIT;

	exception
	  when others then
                  dbms_output.put_line('FLUSH LOGGIN_ERRORS table-'||SUBSTR(SQLERRM, 1, 200));
        /*
        begin
            insert into LOGGING_ERRORS values(SUBSTR(SQLERRM, 1, 200), sysdate);
        exception
        when others then
            dbms_output.put_line('FLUSH LOGGIN_ERRORS table-'||SUBSTR(SQLERRM, 1, 200));
        end;
        */
	END;
  return 'SUCCESS';
END log_activity;

/
--------------------------------------------------------
--  DDL for Function LOL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."LOL" RETURN VARCHAR2 AS 
v_status varchar(50);
v_number varchar(50);
o_Result_Code varchar(150);
o_Result_desc varchar(200);
v_comp_id varchar(50);
v_seller_comp_id varchar(50);
v_Es_id varchar(100);
v_gen_stmt_count number:=0;
v_commission_date Date;
    v_result varchar(300):='SUCCESS';
v_log_result VARCHAR2(50):='';
BEGIN
	v_log_result := log_activity('PROCEDURE','TMP','START','','','', sysdate,'');

--for hahaha in(select g.id from T_GEN_STMT g
--left join T_GEN_STMT_CHARGE ch on g.id=ch.T_GEN_STMT_ID
--where g.STMT_MONTH='06' having count(ch.id)=0 
--group by g.id)
--loop
--v_result:=CALC_GS_CHARGES(hahaha.id);
--update T_GEN_STMT set remarks='WITHOUTCHARGES' WHERE ID=hahaha.ID;
--end loop;

--        for approved in(select seller_comp_serv_id FROM t_energy_sale where status_code='APPROVED' AND t_gen_stmt_id in (select id from t_gen_stmt where stmt_month='06' and disp_service_number in
--        (select DISTINCT suplr_code from missing_int_adj_units_0306)))
--        loop
--        
--        select "number" into v_number from m_company_service where id=approved.seller_comp_serv_id;
--        update missing_int_adj_units_0306 set ES_STATUS='APPROVED' WHERE suplr_code=v_number;
--        end loop;


--        for hehehe in(select ID,DISP_SERVICE_NUMBER from t_gen_stmt  where TYPE_OF_SS = 'SECTION 10(1)SS' and STMT_MONTH='06')
--        loop
--        
--        select id into v_seller_comp_id from m_company_service where "number"=hehehe.DISP_SERVICE_NUMBER;
--         select count(*) into v_gen_stmt_count from t_energy_sale where T_GEN_STMT_ID=hehehe.id and month='06' and seller_comp_serv_id=v_seller_comp_id ;
--         if v_gen_stmt_count =1 then 
--        select id into v_Es_id from t_energy_sale where T_GEN_STMT_ID=hehehe.id and seller_comp_serv_id=v_seller_comp_id and month='06';
----        update t_energy_sale set status_code='CREATED' WHERE ID=v_Es_id;
----        DELETE_TXN.DELETE_BY_SERVICE('TENONESS_RERUB',hehehe.DISP_SERVICE_NUMBER,'06','2019','Y','N','N','N',o_Result_Code,o_Result_desc);
--        if v_Es_id!='63600' OR v_Es_id!='63692' OR v_Es_id!='63871' OR v_Es_id!='63886'  then
--        v_result:= ENERGY_SALE_CONFIRMATION(v_Es_id);
--        end if;
--    end if;
--        end loop;

--          for hahaha in(select M_COMPANY_ID from T_BANKING_BALANCE  where month='05' and (nvl(CURR_C1,0)+nvl(CURR_C3,0)+nvl(CURR_C3,0)+nvl(CURR_C4,0)+nvl(CURR_C5,0)+nvl(SURPLUS_C1,0)+nvl(SURPLUS_C2,0)+nvl(SURPLUS_C3,0)+nvl(SURPLUS_C4,0)+nvl(SURPLUS_C5,0))>0 and  M_COMPANY_ID not in (select M_COMPANY_ID from T_BANKING_BALANCE where month='06'))
--          loop
--          select id,"number" into v_seller_comp_id,v_number from v_company_service where M_COMPANY_ID=hahaha.M_COMPANY_ID;
----          delete from t_banking_balance where m_company_id=v_comp_id and month='06';
--         if v_seller_comp_id is not null then
--                   select COMMISSION_DATE into v_commission_date from M_POWERPLANT where M_SERVICE_ID = v_seller_comp_id;
--                   end if;
--          if v_commission_date is not null and v_commission_date< to_date('01-04-2018','DD-MM-YYYY') then
--          	v_log_result := log_activity('PROCEDURE','LOL','LOOP','M_COMPANY_ID'||hahaha.M_COMPANY_ID,'v_number'||v_number,'', sysdate,'');
--                  BANKING_BALANCE.open_balance (v_number,'06','2019',o_Result_Code,o_Result_desc);
--                  end if;
--          end loop;
	v_log_result := log_activity('PROCEDURE','TMP','END','','','', sysdate,'');
  RETURN NULL;
END LOL;


/
--------------------------------------------------------
--  DDL for Function LOSS_CALCULATION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."LOSS_CALCULATION" 
(INJECTION_CODE IN VARCHAR2,
DRAWAL_CODE IN  VARCHAR2,
INJECTED_UNITS IN VARCHAR2,
TRANS_LOSS OUT NUMBER,DIST_LOSS OUT NUMBER,
TOTAL_LOSS OUT NUMBER,DRAWAL_UNITS OUT NUMBER)
RETURN VARCHAR2
IS
    V_LOSS_CALCULATION M_LOSS_CALC_CHART%ROWTYPE;
    V_REASON VARCHAR2(200);
    V_RESULT VARCHAR(300):='SUCCESS';
    V_EXCEPTION_CODE VARCHAR2(150);
    V_EXCEPTION_MSG  VARCHAR2(150);

BEGIN
   BEGIN
-- -- dbms_output.put_line('INJECTION_CODE'||INJECTION_CODE);
--  -- dbms_output.put_line('DRAWAL_CODE'||DRAWAL_CODE);
        SELECT * INTO V_LOSS_CALCULATION FROM M_LOSS_CALC_CHART WHERE INJECTION_VOLTAGE_CODE=INJECTION_CODE AND DRAWAL_VOLTAGE_CODE=DRAWAL_CODE ;
-- -- dbms_output.put_line('TRANS_LOSS'||V_LOSS_CALCULATION.TRANS_LOSS_PERCENT);
-- -- dbms_output.put_line('DIST_LOSS'||V_LOSS_CALCULATION.DIST_LOSS_PERCENT);
--  -- dbms_output.put_line('INJECTED_UNITS'||INJECTED_UNITS);

--          -- dbms_output.put_line('DISTLOSS'||V_LOSS_CALCULATION.DIST_LOSS_PERCENT*INJECTED_UNITS);
--           -- dbms_output.put_line('INJECTED_UNITS'||INJECTED_UNITS);
        TRANS_LOSS := V_LOSS_CALCULATION.TRANS_LOSS_PERCENT*INJECTED_UNITS;
        TRANS_LOSS :=TO_BINARY_FLOAT(TRANS_LOSS)/100;
--         -- dbms_output.put_line('TRANS_LOSS'||TRANS_LOSS);
          DIST_LOSS := V_LOSS_CALCULATION.DIST_LOSS_PERCENT*INJECTED_UNITS;
        DIST_LOSS :=TO_BINARY_FLOAT(DIST_LOSS)/100;
--         -- dbms_output.put_line('DISTLOSS'||DIST_LOSS);

        TOTAL_LOSS :=TRANS_LOSS+DIST_LOSS;
        DRAWAL_UNITS := INJECTED_UNITS- TOTAL_LOSS;
--         -- dbms_output.put_line('DRAWAL_UNITS'||DRAWAL_UNITS);

--               -- dbms_output.put_line('TOTAL_LOSS'||TOTAL_LOSS);

      EXCEPTION
              WHEN OTHERS THEN
                V_EXCEPTION_CODE := SQLCODE;
                V_EXCEPTION_MSG  := SUBSTR(SQLERRM, 1, 100);
                V_RESULT := 'FAILURE' || ' - ' || V_EXCEPTION_CODE || ' - ' || V_EXCEPTION_MSG;
--                -- dbms_output.put_line('ISSUE IN CREATE_STB-'||V_RESULT);

 END;
 <<THE_END>>
IF V_RESULT = 'SUCCESS' THEN
  COMMIT;
ELSE
  v_result := v_result || ' - ' || v_reason;
END IF;
RETURN TOTAL_LOSS;
--RETURN DISTLOSS;
--RETURN TOTAL_LOSS;
END ;


/
--------------------------------------------------------
--  DDL for Function MRI_IDENTIFY_ERRORS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."MRI_IDENTIFY_ERRORS" 
(
  V_BATCH_ID IN VARCHAR2
) RETURN VARCHAR2 AS

v_mri_rec IMP_MR_LINES%ROWTYPE;
v_status varchar2(50);
v_reason varchar2(200);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(250);
v_result varchar(300):='SUCCESS';
v_LOG_result varchar(300);
BEGIN

	--if final ReadingDate <> InitialReadingDate and if Day of FinalReadingDate is 01, then update reduce the FinalReadingDate by one
	UPDATE IMP_MR_LINES SET final_READING_DT= to_char(to_date(final_READING_DT,'yyyy-mm-dd') -1,'yyyy-mm-dd')
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND to_date(INIT_READING_DT,'yyyy-mm-dd') != to_date(final_READING_DT,'yyyy-mm-dd')
	AND SUBSTR(final_READING_DT,9,2) = '01';


	-- -- dbms_output.put_line('Date stripped');

	/*
	--Ignore any record older than May-2017 - Mark as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Too old records'
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND (final_READING_DT IS NOT NULL AND TO_NUMBER(SUBSTR(final_READING_DT,6,2)) < 5) ;


	*/

	--Mark all records as error with remarks if Final-ReadingDate < InitialReadingDate and not already marked as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'FinalReadingDate < InitialReadingDate '
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND STATUS_CODE = 'CREATED'
	AND (final_READING_DT IS NOT NULL AND  init_READING_DT IS NOT NULL AND to_date(final_READING_DT,'yyyy-mm-dd') < to_date(init_READING_DT,'yyyy-mm-dd'));





	--If the Service-No doesnt exists in m_company_service, mark as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Unknown Service-no'
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND STATUS_CODE = 'CREATED'
	AND SERVICE_NO  IN
        (
         SELECT distinct SERVICE_NO  FROM IMP_MR_lines where imp_mr_header_id= V_BATCH_ID
          minus
         SELECT distinct  "number"  FROM M_COMPANY_SERVICE
        );



   --If the ServiceNo-MeterNo combo doesnt exist in v_company_service, mark as error with remarks
  UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Wrong ServiceNo-MeterNo combo'
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND STATUS_CODE = 'CREATED'
	AND SERVICE_NO||'-'||METER_NO  IN
        (
         SELECT distinct SERVICE_NO||'-'||METER_NO  FROM IMP_MR_lines where imp_mr_header_id= V_BATCH_ID
          minus
         select "number"||'-'|| nvl(meter_number,'no-meter') meter_number from v_company_service where COMP_SER_TYPE_CODE='03'
        );




	--If the Meter_no doesnt exists in m_company_meter, mark as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Unknown Meter-no'
    where IMP_MR_HEADER_ID =  V_BATCH_ID
        AND STATUS_CODE = 'CREATED'
        AND meter_no in
        (
         SELECT distinct meter_no  FROM IMP_MR_lines where imp_mr_header_id= V_BATCH_ID
          minus
         SELECT distinct  METER_NUMBER  FROM M_COMPANY_METER  meter
        );


	--If   Final values is null, mark as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Initial/Final values is null'
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND STATUS_CODE = 'CREATED'
	AND ( EXP_FINAL_S1 is null or EXP_FINAL_S2 is null or EXP_FINAL_S3 is null or EXP_FINAL_S4 is null or EXP_FINAL_S5 is null
                     or   IMP_FINAL_S1 is null or IMP_FINAL_S2 is null or IMP_FINAL_S3 is null or IMP_FINAL_S4 is null or IMP_FINAL_S5 is null );

--If the initial or final reading date is null, mark as error with remarks
	UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Initial or Final Reading date is null'
	WHERE IMP_MR_HEADER_ID =  V_BATCH_ID
	AND STATUS_CODE = 'CREATED'
	AND (init_READING_DT IS NULL OR final_READING_DT IS NULL );

	-- make sure the readings from mri, doesnt exist in MeterReading table
	 UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Meter Reading Already Exists'
	 WHERE id IN (SELECT mri.id
		FROM IMP_MR_lines mri
		 JOIN M_COMPANY_METER meter ON meter.METER_NUMBER = mri.METER_NO and meter.ENABLED='Y'
		 JOIN M_COMPANY_SERVICE ser ON ser."number" = mri.SERVICE_NO AND meter.M_COMPANY_SERVICE_ID = ser.id
		 JOIN T_METER_READING_HDR mrh ON meter.id = mrh.M_COMPANY_METER_ID AND mri.READING_MONTH = mrh.READING_MONTH AND mri.READING_YEAR = mrh.READING_YEAR
		WHERE mri.IMP_MR_HEADER_ID = v_batch_id
		and mri.status_code = 'CREATED');

-- as MF from AMR is wrong/inconsistent, MF from OA is used
  for oa_data in (select mrl.id,  mrl.service_no,mrl.meter_no, ser.mf  from imp_mr_lines mrl
                join v_company_service ser on mrl.service_no=ser."number" and mrl.meter_no=ser.meter_number 
                where mrl.imp_mr_header_id= v_batch_id and mrl.status_code = 'CREATED')
  loop 
    update imp_mr_lines set mf = oa_data.mf, MODIFIED_BY='admin', MODIFIED_DATE=sysdate 
      where imp_mr_header_id= v_batch_id and service_no= oa_data.service_no and meter_no = oa_data.meter_no; 
  end loop;

--return 'MIDDLE';

-- if dual entries entry exists for a meter in same month
-- Find MRI with multiple entries for same month if dual entries entry exists for a meter in same reading month-year in same batch
	FOR mul_entry IN (SELECT  line.IMP_MR_HEADER_ID ,line.SERVICE_NO,line.METER_NO, line.READING_MONTH, line.READING_YEAR,  line.mf,count(line.METER_NO) readings_per_meter
			FROM IMP_MR_lines line
			LEFT JOIN IMP_MR_header head ON line.IMP_MR_HEADER_ID = head.id
			WHERE line.IMP_MR_HEADER_ID = v_batch_id
			and line.status_code = 'CREATED'
			GROUP BY line.IMP_MR_HEADER_ID, line.SERVICE_NO,line.METER_NO, line.READING_MONTH, line.READING_YEAR, line.mf
			HAVING count(line.METER_NO) >1)
	LOOP
    begin
		v_mri_rec.id := IMP_MR_lines_SEQ.nextval;
		v_mri_rec.IMP_MR_HEADER_ID := mul_entry.IMP_MR_HEADER_ID;
		v_mri_rec.STATUS_CODE := 'CREATED';
    v_mri_rec.SERVICE_NO := mul_entry.SERVICE_NO;
		v_mri_rec.METER_NO := mul_entry.METER_NO;
		v_mri_rec.READING_MONTH := mul_entry.READING_MONTH;
		v_mri_rec.READING_YEAR := mul_entry.READING_YEAR;
		v_mri_rec.mf := mul_entry.mf;
		v_mri_rec.sys_dt := TO_CHAR(SYSDATE,'yyyy-mm-dd');
		v_mri_rec.INIT_READING_DT := (mul_entry.READING_YEAR||'-'||mul_entry.READING_MONTH||'-'||'01' );
		v_mri_rec.FINAL_READING_DT := to_char(LAST_DAY( to_date((mul_entry.READING_YEAR||'-'||mul_entry.READING_MONTH||'-'||'01' ),'YYYY-MM-DD')),'YYYY-MM-DD');

	 		--find the min values for all INIT values for the given batchNo, serviceNo, meterNo, month, year
		SELECT  min(to_number(nvl(IMP_INIT_S1,0))) IMP_INIT_S1,min(to_number(nvl(IMP_INIT_S2,0))) IMP_INIT_S2,min(to_number(nvl(IMP_INIT_S3,0))) IMP_INIT_S3,min(to_number(nvl(IMP_INIT_S4,0))) IMP_INIT_S4,min(to_number(nvl(IMP_INIT_S5,0))) IMP_INIT_S5,
				min(to_number(nvl(EXP_INIT_S1,0))) EXP_INIT_S1,min(to_number(nvl(EXP_INIT_S2,0))) EXP_INIT_S2,min(to_number(nvl(EXP_INIT_S3,0))) EXP_INIT_S3,min(to_number(nvl(EXP_INIT_S4,0))) EXP_INIT_S4,min(to_number(nvl(EXP_INIT_S5,0))) EXP_INIT_S5,
				 min(to_number(nvl(IMP_RKVAH_INIT,0))) IMP_RKVAH_INIT,min(to_number(nvl(EXP_RKVAH_INIT,0))) EXP_RKVAH_INIT,min(to_number(nvl(IMP_KVAH_INIT,0))) IMP_KVAH_INIT,min(to_number(nvl(EXP_KVAH_INIT,0))) EXP_KVAH_INIT
			 INTO v_mri_rec.IMP_INIT_S1, v_mri_rec.IMP_INIT_S2, v_mri_rec.IMP_INIT_S3, v_mri_rec.IMP_INIT_S4, v_mri_rec.IMP_INIT_S5,
					v_mri_rec.EXP_INIT_S1, v_mri_rec.EXP_INIT_S2, v_mri_rec.EXP_INIT_S3, v_mri_rec.EXP_INIT_S4, v_mri_rec.EXP_INIT_S5,
					v_mri_rec.IMP_RKVAH_INIT ,v_mri_rec.EXP_RKVAH_INIT,v_mri_rec.IMP_KVAH_INIT,v_mri_rec.EXP_KVAH_INIT
			FROM  IMP_MR_lines lines
			WHERE lines.IMP_MR_HEADER_ID = v_batch_id AND lines.SERVICE_NO = mul_entry.service_no AND lines.METER_NO = mul_entry.meter_no
			AND lines.READING_MONTH = mul_entry.READING_MONTH AND lines.READING_YEAR = mul_entry.READING_YEAR
      group by lines.IMP_MR_HEADER_ID,lines.SERVICE_NO ,lines.METER_NO,lines.READING_MONTH ,lines.READING_YEAR ;


		--find the max values for all final values for the given batchNo, serviceNo, meterNo, month, year
		SELECT  max(to_number(nvl(IMP_FINAL_S1,0))) IMP_FINAL_S1,max(to_number(nvl(IMP_FINAL_S2,0))) IMP_FINAL_S2,max(to_number(nvl(IMP_FINAL_S3,0))) IMP_FINAL_S3,max(to_number(nvl(IMP_FINAL_S4,0))) IMP_FINAL_S4,max(to_number(nvl(IMP_FINAL_S5,0))) IMP_FINAL_S5,

				max(to_number(nvl(EXP_FINAL_S1,0))) EXP_FINAL_S1,max(to_number(nvl(EXP_FINAL_S2,0))) EXP_FINAL_S2,max(to_number(nvl(EXP_FINAL_S3,0))) EXP_FINAL_S3,max(to_number(nvl(EXP_FINAL_S4,0))) EXP_FINAL_S4,max(to_number(nvl(EXP_FINAL_S5,0))) EXP_FINAL_S5,
				 max(to_number(nvl(IMP_RKVAH_FINAL,0))) IMP_RKVAH_FINAL,max(to_number(nvl(EXP_RKVAH_FINAL,0))) EXP_RKVAH_FINAL,max(to_number(nvl(IMP_KVAH_FINAL,0))) IMP_KVAH_FINAL,max(to_number(nvl(EXP_KVAH_FINAL,0))) EXP_KVAH_FINAL
			 INTO v_mri_rec.IMP_FINAL_S1, v_mri_rec.IMP_FINAL_S2, v_mri_rec.IMP_FINAL_S3, v_mri_rec.IMP_FINAL_S4, v_mri_rec.IMP_FINAL_S5,
					v_mri_rec.EXP_FINAL_S1, v_mri_rec.EXP_FINAL_S2, v_mri_rec.EXP_FINAL_S3, v_mri_rec.EXP_FINAL_S4, v_mri_rec.EXP_FINAL_S5,
					v_mri_rec.IMP_RKVAH_FINAL ,v_mri_rec.EXP_RKVAH_FINAL,v_mri_rec.IMP_KVAH_FINAL,v_mri_rec.EXP_KVAH_FINAL
			FROM  IMP_MR_lines lines
			WHERE lines.IMP_MR_HEADER_ID = v_batch_id AND lines.SERVICE_NO = mul_entry.service_no AND lines.METER_NO = mul_entry.meter_no
			AND lines.READING_MONTH = mul_entry.READING_MONTH AND lines.READING_YEAR = mul_entry.READING_YEAR
      group by lines.IMP_MR_HEADER_ID,lines.SERVICE_NO ,lines.METER_NO,lines.READING_MONTH ,lines.READING_YEAR ;


		UPDATE IMP_MR_LINES lines SET STATUS_CODE= 'ERROR', REMARKS = 'Multiple entries in same month', REF_NO = v_mri_rec.id
			WHERE IMP_MR_HEADER_ID =  V_BATCH_ID AND lines.SERVICE_NO = mul_entry.service_no AND lines.METER_NO = mul_entry.meter_no
			AND lines.READING_MONTH = mul_entry.READING_MONTH AND lines.READING_YEAR = mul_entry.READING_YEAR;

		INSERT INTO IMP_MR_LINES VALUES v_mri_rec;


    exception
          when others then
            v_exception_code := SQLCODE;
            v_exception_msg := SUBSTR(SQLERRM, 1, 200);
            v_reason := v_exception_code || ' - ' || v_exception_msg;
          v_log_result := log_activity('PROCEDURE','MRI_IDENTIFY_ERRORS','LOOP-EXCEPTION',v_reason,v_result,'', sysdate,V_BATCH_ID);
          UPDATE IMP_MR_LINES SET STATUS_CODE = 'ERROR', remarks = 'Unknown Issues - possiblly data issue'
            WHERE  id = v_mri_rec.id;
        end;
	END LOOP;

	-- make sure the readings from mri, doesnt exist in MeterReading table
	 UPDATE IMP_MR_LINES SET STATUS_CODE= 'ERROR', REMARKS = 'Meter Reading Already Exists'
	 WHERE id IN (SELECT mri.id
		FROM IMP_MR_lines mri
		 JOIN M_COMPANY_METER meter ON meter.METER_NUMBER = mri.METER_NO and meter.ENABLED='Y'
		 JOIN M_COMPANY_SERVICE ser ON ser."number" = mri.SERVICE_NO AND meter.M_COMPANY_SERVICE_ID = ser.id
		 JOIN T_METER_READING_HDR mrh ON meter.id = mrh.M_COMPANY_METER_ID AND mri.READING_MONTH = mrh.READING_MONTH AND mri.READING_YEAR = mrh.READING_YEAR
		WHERE mri.IMP_MR_HEADER_ID = v_batch_id
		and mri.status_code = 'CREATED');


  RETURN 'SUCCESS';
	exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	   -- v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
	   -- -- dbms_output.put_line('CLEANSE_MRI - '||v_reason);
      v_log_result := log_activity('PROCEDURE','MRI_IDENTIFY_ERRORS','EXCEPTION',v_reason,NULL,'', sysdate,V_BATCH_ID);

      return 'FAILURE';
END MRI_IDENTIFY_ERRORS;


/
--------------------------------------------------------
--  DDL for Function PROCESS_EXP_TECHNICAL_DATA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."PROCESS_EXP_TECHNICAL_DATA" 
(
  V_REMARKS IN VARCHAR2 
) RETURN VARCHAR2 AS 
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_total_count number:=0;
v_total_service_no number:=0;
v_total_trade number:=0;
v_exp_tec_data exp_technical_data%ROWTYPE;
v_tr M_TRADE_RELATIONSHIP%ROWTYPE;
v_company_serv_id VARCHAR2(200);
i number:=1;
j NUMBER:=1;
BEGIN

-- begin for exception handling
BEGIN

   v_log_result := log_activity('FUNCTION','PROCESS_EXP_TECHNICAL_DATA','START','Start - '||V_REMARKS,'','', sysdate,V_REMARKS);

    select count(*) into v_total_count from exp_technical_data where remarks = V_REMARKS;
  if(v_total_count=0) then
      Raise_Application_Error (-20343, 'No records to process');
  end if;


 FOR exp_data IN ( select * from exp_technical_data  where remarks =V_REMARKS)
  LOOP
        select count(*) into v_total_service_no from m_company_service where "number"=exp_data.M_SERVICE_NUMBER;
         if(v_total_count=0) then
                v_reason:=exp_data.M_SERVICE_NUMBER||'- service number doesnot exist';
                v_log_result := log_activity('FUNCTION','PROCESS_EXP_TECHNICAL_DATA','EXCEPTION',v_reason,'','', sysdate,V_REMARKS);
        else
                SELECT COMP_SERV.M_COMPANY_NAME COMPANY_NAME,COMP_SERV.M_ORG_NAME EDC_NAME,COMP_SERV.M_ORG_ID,PP.TOTAL_CAPACITY TOTAL_CAPACITY_KW,PP.PLS_SF_NO,
                PP.VILLAGE,COMP_SERV.M_SUBSTATION_NAME SS_NAME_IN_OA,COMP_SERV.M_SUBSTATION_ID,COMP_SERV.M_FEEDER_NAME FEEDER_NAME_IN_OA,COMP_SERV.M_FEEDER_ID,
                COMP_SERV.IS_REC,  DECODE(IS_BUYER,'Y','BUYER','SELLER') PURPOSE,to_char(PP.COMMISSION_DATE,'dd/MM/yyyy') COMMISSION_DATE_STR,WIND_PASS.VALUE_DESC WIND_PASS_NAME,PP.COMMISSION_DATE,
                PP.WIND_PASS_CODE,PP.IMPORT_REMARKS,COMP_SERV.FUEL_TYPE_CODE,COMP_SERV.FUEL_TYPE_NAME,COMP_SERV.id,
                COMP_SERV.M_COMPANY_ID,pp.id
                INTO
                v_exp_tec_data.COMPANY_NAME,v_exp_tec_data.EDC_NAME,v_exp_tec_data.M_ORG_ID,v_exp_tec_data.TOTAL_CAPACITY_KW,v_exp_tec_data.SF_NO,
                v_exp_tec_data.VILLAGE,v_exp_tec_data.SS_NAME_IN_OA,v_exp_tec_data.M_SUBSTATION_ID,v_exp_tec_data.FEEDER_NAME_IN_OA,v_exp_tec_data.M_FEEDER_ID,
                v_exp_tec_data.IS_REC,v_exp_tec_data.PURPOSE,v_exp_tec_data.COMMISSION_DATE_STR,v_exp_tec_data.WIND_PASS_NAME,v_exp_tec_data.COMMISSION_DATE,
                v_exp_tec_data.WIND_PASS_CODE,v_exp_tec_data.IMPORT_REMARKS,v_exp_tec_data.FUEL,v_exp_tec_data.FUEL_CODE,v_exp_tec_data.M_COMPANY_SERVICE_ID,  
                v_exp_tec_data.M_COMPANY_ID,v_exp_tec_data.M_POWERPLANT_ID
                FROM V_COMPANY_SERVICE COMP_SERV 
                LEFT JOIN M_POWERPLANT PP ON PP.M_SERVICE_ID = COMP_SERV.ID
                LEFT JOIN M_GENERATOR GEN ON GEN.M_POWERPLANT_ID = PP.ID
                LEFT JOIN V_CODES CODE ON CODE.VALUE_CODE = GEN.MAKE_CODE AND CODE.LIST_CODE='GENERATOR_MAKE_CODE'
                LEFT JOIN M_COMPANY_METER METER ON METER.M_COMPANY_SERVICE_ID = COMP_SERV.ID 
                LEFT JOIN V_CODES METER_CODE ON METER_CODE.VALUE_CODE = COMP_SERV.METER_MAKE_CODE AND METER_CODE.LIST_CODE='METER_MAKE_CODE'
                LEFT JOIN V_CODES WIND_PASS ON WIND_PASS.VALUE_CODE = COMP_SERV.METER_MAKE_CODE AND WIND_PASS.LIST_CODE='WIND_PASS_CODE'
                WHERE "number"=exp_data.M_SERVICE_NUMBER;


                 FOR meter IN ( select * from m_company_meter  where M_COMPANY_SERVICE_ID =v_exp_tec_data.M_COMPANY_SERVICE_ID)
                  LOOP
                    if i=1 then
                    v_exp_tec_data.M_METER_ID_1:=meter.ID;
                    v_exp_tec_data.METER1_PT_RATIO:=meter.PT_RATIO;
                    v_exp_tec_data.METER1_CT_RATIO:=meter.CT_RATIO;
                    v_exp_tec_data.METER1_METER_MAKE_CODE:=meter.METER_MAKE_CODE;
                    v_exp_tec_data.METER1_METER_NUMBER:=meter.METER_NUMBER;
                    v_exp_tec_data.METER1_MODEM_NO:=meter.MODEM_NUMBER;
                    v_exp_tec_data.METER1_ACCURACY_CLASS_CODE:=meter.ACCURACY_CLASS_CODE;
                    v_exp_tec_data.METER1_MF:=meter.MF;
                    end if;

                    if i=2 then
                    v_exp_tec_data.M_METER_ID_2:=meter.ID;
                    v_exp_tec_data.METER2_PT_RATIO:=meter.PT_RATIO;
                    v_exp_tec_data.METER2_CT_RATIO:=meter.CT_RATIO;
                    v_exp_tec_data.METER2_METER_MAKE_CODE:=meter.METER_MAKE_CODE;
                    v_exp_tec_data.METER2_METER_NUMBER:=meter.METER_NUMBER;
                    v_exp_tec_data.METER2_MODEM_NO:=meter.MODEM_NUMBER;
                    v_exp_tec_data.METER2_ACCURACY_CLASS_CODE:=meter.ACCURACY_CLASS_CODE;
                    v_exp_tec_data.METER2_MF:=meter.MF;
                    end if;

                    if i=3 then
                    v_exp_tec_data.M_METER_ID_3:=meter.ID;
                    v_exp_tec_data.METER3_PT_RATIO:=meter.PT_RATIO;
                    v_exp_tec_data.METER3_CT_RATIO:=meter.CT_RATIO;
                    v_exp_tec_data.METER3_METER_MAKE_CODE:=meter.METER_MAKE_CODE;
                    v_exp_tec_data.METER3_METER_NUMBER:=meter.METER_NUMBER;
                    v_exp_tec_data.METER3_MODEM_NO:=meter.MODEM_NUMBER;
                    v_exp_tec_data.METER3_ACCURACY_CLASS_CODE:=meter.ACCURACY_CLASS_CODE;
                    v_exp_tec_data.METER3_MF:=meter.MF;
                    end if;

                    if i=4 then
                    v_exp_tec_data.M_METER_ID_4:=meter.ID;
                    v_exp_tec_data.METER4_PT_RATIO:=meter.PT_RATIO;
                    v_exp_tec_data.METER4_CT_RATIO:=meter.CT_RATIO;
                    v_exp_tec_data.METER4_METER_MAKE_CODE:=meter.METER_MAKE_CODE;
                    v_exp_tec_data.METER4_METER_NUMBER:=meter.METER_NUMBER;
                    v_exp_tec_data.METER4_MODEM_NO:=meter.MODEM_NUMBER;
                    v_exp_tec_data.METER4_ACCURACY_CLASS_CODE:=meter.ACCURACY_CLASS_CODE;
                    v_exp_tec_data.METER4_MF:=meter.MF;
                    end if;

                    if i=5 then
                    v_exp_tec_data.M_METER_ID_5:=meter.ID;
                    v_exp_tec_data.METER5_PT_RATIO:=meter.PT_RATIO;
                    v_exp_tec_data.METER5_CT_RATIO:=meter.CT_RATIO;
                    v_exp_tec_data.METER5_METER_MAKE_CODE:=meter.METER_MAKE_CODE;
                    v_exp_tec_data.METER5_METER_NUMBER:=meter.METER_NUMBER;
                    v_exp_tec_data.METER5_MODEM_NO:=meter.MODEM_NUMBER;
                    v_exp_tec_data.METER5_ACCURACY_CLASS_CODE:=meter.ACCURACY_CLASS_CODE;
                    v_exp_tec_data.METER5_MF:=meter.MF;
                    end if;

                    if i=6 then

                    v_exp_tec_data.M_METER_ID_6:=meter.ID;
                    v_exp_tec_data.METER6_PT_RATIO:=meter.PT_RATIO;
                    v_exp_tec_data.METER6_CT_RATIO:=meter.CT_RATIO;
                    v_exp_tec_data.METER6_METER_MAKE_CODE:=meter.METER_MAKE_CODE;
                    v_exp_tec_data.METER6_METER_NUMBER:=meter.METER_NUMBER;
                    v_exp_tec_data.METER6_MODEM_NO:=meter.MODEM_NUMBER;
                    v_exp_tec_data.METER6_ACCURACY_CLASS_CODE:=meter.ACCURACY_CLASS_CODE;
                    v_exp_tec_data.METER6_MF:=meter.MF;
                    end if;


                    i:=i+1;
                    END LOOP;


                     FOR generator IN ( select * from m_generator where M_POWERPLANT_ID =v_exp_tec_data.M_POWERPLANT_ID)
                      LOOP
                    if j=1 then
                    v_exp_tec_data.M_GENERATOR_ID_1:=generator.ID;
                    v_exp_tec_data.GEN1_GEN_MAKE_CODE:=generator.MAKE_CODE;
                    v_exp_tec_data.GEN1_NO_OF_GEN_UNITS:=generator.NO_OF_UNITS;
                    v_exp_tec_data.GEN1_GEN_UNIT_CAPACITY:=generator.CAPACITY;
                    v_exp_tec_data.GEN1_VOLTAGE_CODE:=generator.VOLTAGE_CODE;
                    v_exp_tec_data.GEN1_TURBINE_SL_NO:=generator.SERIAL_NO;
                    v_exp_tec_data.GEN1_TURBINE_ROTOR_DIA:=generator.ROTOR_DIA;
                    v_exp_tec_data.GEN1_TURBINE_HUB_HEIGHT:=generator.HUB_HEIGHT;
                    end if;

                    if j=2 then
                    v_exp_tec_data.M_GENERATOR_ID_2:=generator.ID;
                    v_exp_tec_data.GEN2_GEN_MAKE_CODE:=generator.MAKE_CODE;
                    v_exp_tec_data.GEN2_NO_OF_GEN_UNITS:=generator.NO_OF_UNITS;
                    v_exp_tec_data.GEN2_GEN_UNIT_CAPACITY:=generator.CAPACITY;
                    v_exp_tec_data.GEN2_VOLTAGE_CODE:=generator.VOLTAGE_CODE;
                    v_exp_tec_data.GEN2_TURBINE_SL_NO:=generator.SERIAL_NO;
                    v_exp_tec_data.GEN2_TURBINE_ROTOR_DIA:=generator.ROTOR_DIA;
                    v_exp_tec_data.GEN2_TURBINE_HUB_HEIGHT:=generator.HUB_HEIGHT;
                    end if;

                    if j=3 then
                    v_exp_tec_data.M_GENERATOR_ID_3:=generator.ID;
                    v_exp_tec_data.GEN3_GEN_MAKE_CODE:=generator.MAKE_CODE;
                    v_exp_tec_data.GEN3_NO_OF_GEN_UNITS:=generator.NO_OF_UNITS;
                    v_exp_tec_data.GEN3_GEN_UNIT_CAPACITY:=generator.CAPACITY;
                    v_exp_tec_data.GEN3_VOLTAGE_CODE:=generator.VOLTAGE_CODE;
                    v_exp_tec_data.GEN3_TURBINE_SL_NO:=generator.SERIAL_NO;
                    v_exp_tec_data.GEN3_TURBINE_ROTOR_DIA:=generator.ROTOR_DIA;
                    v_exp_tec_data.GEN3_TURBINE_HUB_HEIGHT:=generator.HUB_HEIGHT;
                    end if;

                    if j=4 then
                    v_exp_tec_data.M_GENERATOR_ID_4:=generator.ID;
                    v_exp_tec_data.GEN4_GEN_MAKE_CODE:=generator.MAKE_CODE;
                    v_exp_tec_data.GEN4_NO_OF_GEN_UNITS:=generator.NO_OF_UNITS;
                    v_exp_tec_data.GEN4_GEN_UNIT_CAPACITY:=generator.CAPACITY;
                    v_exp_tec_data.GEN4_VOLTAGE_CODE:=generator.VOLTAGE_CODE;
                    v_exp_tec_data.GEN4_TURBINE_SL_NO:=generator.SERIAL_NO;
                    v_exp_tec_data.GEN4_TURBINE_ROTOR_DIA:=generator.ROTOR_DIA;
                    v_exp_tec_data.GEN4_TURBINE_HUB_HEIGHT:=generator.HUB_HEIGHT;
                    end if;

                    if j=5 then
                    v_exp_tec_data.M_GENERATOR_ID_5:=generator.ID;
                    v_exp_tec_data.GEN5_GEN_MAKE_CODE:=generator.MAKE_CODE;
                    v_exp_tec_data.GEN5_NO_OF_GEN_UNITS:=generator.NO_OF_UNITS;
                    v_exp_tec_data.GEN5_GEN_UNIT_CAPACITY:=generator.CAPACITY;
                    v_exp_tec_data.GEN5_VOLTAGE_CODE:=generator.VOLTAGE_CODE;
                    v_exp_tec_data.GEN5_TURBINE_SL_NO:=generator.SERIAL_NO;
                    v_exp_tec_data.GEN5_TURBINE_ROTOR_DIA:=generator.ROTOR_DIA;
                    v_exp_tec_data.GEN5_TURBINE_HUB_HEIGHT:=generator.HUB_HEIGHT;
                    end if;

                    if j=6 then
                    v_exp_tec_data.M_GENERATOR_ID_6:=generator.ID;
                    v_exp_tec_data.GEN6_GEN_MAKE_CODE:=generator.MAKE_CODE;
                    v_exp_tec_data.GEN6_NO_OF_GEN_UNITS:=generator.NO_OF_UNITS;
                    v_exp_tec_data.GEN6_GEN_UNIT_CAPACITY:=generator.CAPACITY;
                    v_exp_tec_data.GEN6_VOLTAGE_CODE:=generator.VOLTAGE_CODE;
                    v_exp_tec_data.GEN6_TURBINE_SL_NO:=generator.SERIAL_NO;
                    v_exp_tec_data.GEN6_TURBINE_ROTOR_DIA:=generator.ROTOR_DIA;
                    v_exp_tec_data.GEN6_TURBINE_HUB_HEIGHT:=generator.HUB_HEIGHT;
                    end if;


                    j:=j+1;
                    END LOOP;

                     select count(*) into v_total_trade from M_TRADE_RELATIONSHIP  where M_SELLER_COMPANY_ID=v_company_serv_id and M_BUYER_COMPANY_ID='TNEB';

                    if v_total_trade >0 then
                        v_exp_tec_data.SURPLUS_ENERGY:='SELL-TO-BOARD';
                        v_exp_tec_data.NATURE_OF_BOARD :='SELL-TO-BOARD';
                        FOR trade IN ( select * from M_TRADE_RELATIONSHIP  where M_SELLER_COMPANY_ID=v_company_serv_id and M_BUYER_COMPANY_ID='TNEB')
                        LOOP

                            if trade.IS_CAPTIVE='Y' then
                                v_exp_tec_data.NATURE_OF_BOARD :='IS-CAPTIVE';
                --                else
                --                 v_exp_tec_data.NATURE_OF_BOARD :='NCES-THIRD-PARTY';
                            end if;

                        END LOOP;
                    else
                         v_exp_tec_data.SURPLUS_ENERGY:='BANKING';
                    end if;

                  update exp_technical_data set COMPANY_NAME= v_exp_tec_data.COMPANY_NAME ,
                    M_ORG_ID= v_exp_tec_data.M_ORG_ID ,
                    TOTAL_CAPACITY_KW= v_exp_tec_data.TOTAL_CAPACITY_KW ,
                    SF_NO= v_exp_tec_data.SF_NO ,
                    VILLAGE= v_exp_tec_data.VILLAGE ,

                    M_SUBSTATION_ID= v_exp_tec_data.M_SUBSTATION_ID ,

                    M_FEEDER_ID= v_exp_tec_data.M_FEEDER_ID ,

                    IS_REC= v_exp_tec_data.IS_REC ,

                    COMMISSION_DATE_STR= v_exp_tec_data.COMMISSION_DATE_STR ,
                    IMPORTED= v_exp_tec_data.IMPORTED ,
                    COMMISSION_DATE= v_exp_tec_data.COMMISSION_DATE ,
                    WIND_PASS_CODE= v_exp_tec_data.WIND_PASS_CODE ,
                    IMPORT_REMARKS= v_exp_tec_data.IMPORT_REMARKS ,

                    FUEL_CODE= v_exp_tec_data.FUEL_CODE ,
                    M_COMPANY_ID= v_exp_tec_data.M_COMPANY_ID ,
                    M_COMPANY_SERVICE_ID= v_exp_tec_data.M_COMPANY_SERVICE_ID ,
                    M_POWERPLANT_ID= v_exp_tec_data.M_POWERPLANT_ID ,
                    M_METER_ID_1= v_exp_tec_data.M_METER_ID_1 ,
                    METER1_PT_RATIO= v_exp_tec_data.METER1_PT_RATIO ,
                    METER1_CT_RATIO= v_exp_tec_data.METER1_CT_RATIO ,
                    METER1_MF= v_exp_tec_data.METER1_MF ,
                    METER1_METER_MAKE_CODE= v_exp_tec_data.METER1_METER_MAKE_CODE ,
                    METER1_METER_NUMBER= v_exp_tec_data.METER1_METER_NUMBER ,
                    METER1_MODEM_NO= v_exp_tec_data.METER1_MODEM_NO ,
                    METER1_IS_ABT= v_exp_tec_data.METER1_IS_ABT ,
                    METER1_ACCURACY_CLASS_CODE= v_exp_tec_data.METER1_ACCURACY_CLASS_CODE ,
                    M_METER_ID_2= v_exp_tec_data.M_METER_ID_2 ,
                    METER2_PT_RATIO= v_exp_tec_data.METER2_PT_RATIO ,
                    METER2_CT_RATIO= v_exp_tec_data.METER2_CT_RATIO ,
                    METER2_MF= v_exp_tec_data.METER2_MF ,
                    METER2_METER_MAKE_CODE= v_exp_tec_data.METER2_METER_MAKE_CODE ,
                    METER2_METER_NUMBER= v_exp_tec_data.METER2_METER_NUMBER ,
                    METER2_MODEM_NO= v_exp_tec_data.METER2_MODEM_NO ,
                    METER2_IS_ABT= v_exp_tec_data.METER2_IS_ABT ,
                    METER2_ACCURACY_CLASS_CODE= v_exp_tec_data.METER2_ACCURACY_CLASS_CODE ,

                    M_METER_ID_3= v_exp_tec_data.M_METER_ID_3 ,
                    METER3_PT_RATIO= v_exp_tec_data.METER3_PT_RATIO ,
                    METER3_CT_RATIO= v_exp_tec_data.METER3_CT_RATIO ,
                    METER3_MF= v_exp_tec_data.METER3_MF ,
                    METER3_METER_MAKE_CODE= v_exp_tec_data.METER3_METER_MAKE_CODE ,
                    METER3_METER_NUMBER= v_exp_tec_data.METER3_METER_NUMBER ,
                    METER3_MODEM_NO= v_exp_tec_data.METER3_MODEM_NO ,
                    METER3_IS_ABT= v_exp_tec_data.METER3_IS_ABT ,
                    METER3_ACCURACY_CLASS_CODE= v_exp_tec_data.METER3_ACCURACY_CLASS_CODE ,

                    M_METER_ID_4= v_exp_tec_data.M_METER_ID_4 ,
                    METER4_PT_RATIO= v_exp_tec_data.METER4_PT_RATIO ,
                    METER4_CT_RATIO= v_exp_tec_data.METER4_CT_RATIO ,
                    METER4_MF= v_exp_tec_data.METER4_MF ,
                    METER4_METER_MAKE_CODE= v_exp_tec_data.METER4_METER_MAKE_CODE ,
                    METER4_METER_NUMBER= v_exp_tec_data.METER4_METER_NUMBER ,
                    METER4_MODEM_NO= v_exp_tec_data.METER4_MODEM_NO ,
                    METER4_IS_ABT= v_exp_tec_data.METER4_IS_ABT ,
                    METER4_ACCURACY_CLASS_CODE= v_exp_tec_data.METER4_ACCURACY_CLASS_CODE ,

                    M_METER_ID_5= v_exp_tec_data.M_METER_ID_5 ,
                    METER5_PT_RATIO= v_exp_tec_data.METER5_PT_RATIO ,
                    METER5_CT_RATIO= v_exp_tec_data.METER5_CT_RATIO ,
                    METER5_MF= v_exp_tec_data.METER5_MF ,
                    METER5_METER_MAKE_CODE= v_exp_tec_data.METER5_METER_MAKE_CODE ,
                    METER5_METER_NUMBER= v_exp_tec_data.METER5_METER_NUMBER ,
                    METER5_MODEM_NO= v_exp_tec_data.METER5_MODEM_NO ,
                    METER5_IS_ABT= v_exp_tec_data.METER5_IS_ABT ,
                    METER5_ACCURACY_CLASS_CODE= v_exp_tec_data.METER5_ACCURACY_CLASS_CODE ,

                    M_METER_ID_6= v_exp_tec_data.M_METER_ID_6 ,
                    METER6_PT_RATIO= v_exp_tec_data.METER6_PT_RATIO ,
                    METER6_CT_RATIO= v_exp_tec_data.METER6_CT_RATIO ,
                    METER6_MF= v_exp_tec_data.METER6_MF ,
                    METER6_METER_MAKE_CODE= v_exp_tec_data.METER6_METER_MAKE_CODE ,
                    METER6_METER_NUMBER= v_exp_tec_data.METER6_METER_NUMBER ,
                    METER6_MODEM_NO= v_exp_tec_data.METER6_MODEM_NO ,
                    METER6_IS_ABT= v_exp_tec_data.METER6_IS_ABT ,
                    METER6_ACCURACY_CLASS_CODE= v_exp_tec_data.METER6_ACCURACY_CLASS_CODE ,


                    M_GENERATOR_ID_1= v_exp_tec_data.M_GENERATOR_ID_1 ,
                    GEN1_GEN_MAKE_CODE= v_exp_tec_data.GEN1_GEN_MAKE_CODE ,
                    GEN1_NO_OF_GEN_UNITS= v_exp_tec_data.GEN1_NO_OF_GEN_UNITS ,
                    GEN1_GEN_UNIT_CAPACITY= v_exp_tec_data.GEN1_GEN_UNIT_CAPACITY ,
                    GEN1_VOLTAGE_CODE= v_exp_tec_data.GEN1_VOLTAGE_CODE ,
                    GEN1_TURBINE_SL_NO= v_exp_tec_data.GEN1_TURBINE_SL_NO ,
                    GEN1_TURBINE_ROTOR_DIA= v_exp_tec_data.GEN1_TURBINE_ROTOR_DIA ,
                    GEN1_TURBINE_HUB_HEIGHT= v_exp_tec_data.GEN1_TURBINE_HUB_HEIGHT ,

                    M_GENERATOR_ID_2= v_exp_tec_data.M_GENERATOR_ID_2 ,
                    GEN2_GEN_MAKE_CODE= v_exp_tec_data.GEN2_GEN_MAKE_CODE ,
                    GEN2_NO_OF_GEN_UNITS= v_exp_tec_data.GEN2_NO_OF_GEN_UNITS ,
                    GEN2_GEN_UNIT_CAPACITY= v_exp_tec_data.GEN2_GEN_UNIT_CAPACITY ,
                    GEN2_VOLTAGE_CODE= v_exp_tec_data.GEN2_VOLTAGE_CODE ,
                    GEN2_TURBINE_SL_NO= v_exp_tec_data.GEN2_TURBINE_SL_NO ,
                    GEN2_TURBINE_ROTOR_DIA= v_exp_tec_data.GEN2_TURBINE_ROTOR_DIA ,
                    GEN2_TURBINE_HUB_HEIGHT= v_exp_tec_data.GEN2_TURBINE_HUB_HEIGHT ,

                    M_GENERATOR_ID_3= v_exp_tec_data.M_GENERATOR_ID_3 ,
                    GEN3_GEN_MAKE_CODE= v_exp_tec_data.GEN3_GEN_MAKE_CODE ,
                    GEN3_NO_OF_GEN_UNITS= v_exp_tec_data.GEN3_NO_OF_GEN_UNITS ,
                    GEN3_GEN_UNIT_CAPACITY= v_exp_tec_data.GEN3_GEN_UNIT_CAPACITY ,
                    GEN3_VOLTAGE_CODE= v_exp_tec_data.GEN3_VOLTAGE_CODE ,
                    GEN3_TURBINE_SL_NO= v_exp_tec_data.GEN3_TURBINE_SL_NO ,
                    GEN3_TURBINE_ROTOR_DIA= v_exp_tec_data.GEN3_TURBINE_ROTOR_DIA ,
                    GEN3_TURBINE_HUB_HEIGHT= v_exp_tec_data.GEN3_TURBINE_HUB_HEIGHT ,

                    M_GENERATOR_ID_4= v_exp_tec_data.M_GENERATOR_ID_4 ,
                    GEN4_GEN_MAKE_CODE= v_exp_tec_data.GEN4_GEN_MAKE_CODE ,
                    GEN4_NO_OF_GEN_UNITS= v_exp_tec_data.GEN4_NO_OF_GEN_UNITS ,
                    GEN4_GEN_UNIT_CAPACITY= v_exp_tec_data.GEN4_GEN_UNIT_CAPACITY ,
                    GEN4_VOLTAGE_CODE= v_exp_tec_data.GEN4_VOLTAGE_CODE ,
                    GEN4_TURBINE_SL_NO= v_exp_tec_data.GEN4_TURBINE_SL_NO ,
                    GEN4_TURBINE_ROTOR_DIA= v_exp_tec_data.GEN4_TURBINE_ROTOR_DIA ,
                    GEN4_TURBINE_HUB_HEIGHT= v_exp_tec_data.GEN4_TURBINE_HUB_HEIGHT ,

                    M_GENERATOR_ID_5= v_exp_tec_data.M_GENERATOR_ID_5 ,
                    GEN5_GEN_MAKE_CODE= v_exp_tec_data.GEN5_GEN_MAKE_CODE ,
                    GEN5_NO_OF_GEN_UNITS= v_exp_tec_data.GEN5_NO_OF_GEN_UNITS ,
                    GEN5_GEN_UNIT_CAPACITY= v_exp_tec_data.GEN5_GEN_UNIT_CAPACITY ,
                    GEN5_VOLTAGE_CODE= v_exp_tec_data.GEN5_VOLTAGE_CODE ,
                    GEN5_TURBINE_SL_NO= v_exp_tec_data.GEN5_TURBINE_SL_NO ,
                    GEN5_TURBINE_ROTOR_DIA= v_exp_tec_data.GEN5_TURBINE_ROTOR_DIA ,
                    GEN5_TURBINE_HUB_HEIGHT= v_exp_tec_data.GEN5_TURBINE_HUB_HEIGHT ,

                    M_GENERATOR_ID_6= v_exp_tec_data.M_GENERATOR_ID_6 ,
                    GEN6_GEN_MAKE_CODE= v_exp_tec_data.GEN6_GEN_MAKE_CODE ,
                    GEN6_NO_OF_GEN_UNITS= v_exp_tec_data.GEN6_NO_OF_GEN_UNITS ,
                    GEN6_GEN_UNIT_CAPACITY= v_exp_tec_data.GEN6_GEN_UNIT_CAPACITY ,
                    GEN6_VOLTAGE_CODE= v_exp_tec_data.GEN6_VOLTAGE_CODE ,
                    GEN6_TURBINE_SL_NO= v_exp_tec_data.GEN6_TURBINE_SL_NO ,
                    GEN6_TURBINE_ROTOR_DIA= v_exp_tec_data.GEN6_TURBINE_ROTOR_DIA ,
                    GEN6_TURBINE_HUB_HEIGHT= v_exp_tec_data.GEN6_TURBINE_HUB_HEIGHT 
                        where M_SERVICE_NUMBER = exp_data.M_SERVICE_NUMBER and   remarks =V_REMARKS;


            end if;
          END LOOP;



      commit;
    exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      -- -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('FUNCTION','PROCESS_EXP_TECHNICAL_DATA','EXCEPTION',v_reason,'','', sysdate,V_REMARKS);
END;

v_log_result := log_activity('FUNCTION','PROCESS_EXP_TECHNICAL_DATA','END','Import complete','','', sysdate,V_REMARKS);

return V_RESULT || ' - ' || v_reason;

END PROCESS_EXP_TECHNICAL_DATA;


/
--------------------------------------------------------
--  DDL for Function PROCESS_GEN_STMT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."PROCESS_GEN_STMT" 
(
  v_month IN VARCHAR2,
  v_year in varchar2
) RETURN VARCHAR2 AS

v_batch_based boolean:=false;
v_duration_based boolean:=false;
v_process_id  VARCHAR2(50);
v_gen_count  NUMBER:=0;
v_mrh T_METER_READING_HDR%ROWTYPE;
v_mr_c1 T_METER_READING_SLOT%ROWTYPE;
v_mr_c2 T_METER_READING_SLOT%ROWTYPE;
v_mr_c3 T_METER_READING_SLOT%ROWTYPE;
v_mr_c4 T_METER_READING_SLOT%ROWTYPE;
v_mr_c5 T_METER_READING_SLOT%ROWTYPE;
v_gs T_GEN_STMT%ROWTYPE;
v_gs_c1 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c2 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c3 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c4 T_GEN_STMT_SLOT%ROWTYPE;
v_gs_c5 T_GEN_STMT_SLOT%ROWTYPE;
v_no_records BOOLEAN:=TRUE;
v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200);
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_imported BOOLEAN;

BEGIN

        BEGIN
    v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','INIT','Start '||v_process_id,null,v_created_By, sysdate);

                FOR meter IN (SELECT mh.M_COMPANY_METER_ID, READING_MONTH, READING_YEAR,
                                                nvl(bg.C1,0) bc1, nvl(bg.C2,0) bc2, nvl(bg.C3,0) bc3,nvl(bg.C4,0) bc4,nvl(bg.C5,0) bc5,
                                                cs.M_ORG_ID, c.ID M_COMPANY_ID,cm.M_COMPANY_SERVICE_ID, c.NAME DISP_COMPANY_NAME, cs."number" DISP_SERVICE_NUMBER, cs.VOLTAGE_CODE INJECTING_VOLTAGE_CODE, o.NAME DISP_ORG_NAME,
            p.fuel_type_Code
                                                FROM T_METER_READING_HDR mh
                                                INNER JOIN M_COMPANY_METER cm ON mh.M_COMPANY_METER_ID = cm.ID
                                                INNER JOIN M_COMPANY_SERVICE cs ON cm.M_COMPANY_SERVICE_ID = cs.id
            inner join M_POWERPLANT  p on cm.M_COMPANY_SERVICE_ID = p.m_service_id
                                                INNER JOIN M_COMPANY c ON cs.M_COMPANY_ID = c.id
                                                INNER JOIN M_ORG o ON cs.M_ORG_ID = o.id
                        LEFT JOIN T_BANKING_BALANCE bg ON bg.BANKING_SERVICE_ID = cs.BANKING_SERVICE_ID
                                                WHERE mh.M_GEN_STMT_ID IS NULL AND mh.GS_BATCH_ID IS NULL
                                                AND READING_MONTH = v_month AND READING_YEAR = v_year
                                                 )
                LOOP
                        BEGIN
        v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','IN-LOOP-START','Start '||meter.DISP_SERVICE_NUMBER,null,v_created_By, sysdate);
                                -- as there is meter-readings to process, we have to set the flag accordingly and start the generation process
                                if(v_no_records) THEN
                                        v_no_records := FALSE;
                                        v_process_id := T_PROCESS_GS_SEQ.nextval;
                                        INSERT INTO T_PROCESS_GS (ID,SYS_DT,STATUS,START_DT,END_DT,REMARKS)
                                                VALUES (v_process_id,v_created_Date,'PROCESSING',v_created_Date,NULL,NULL) ;
                                        --v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','STARTED','Start - '||v_process_id,null,v_created_By, sysdate);

                                END IF;

                                -- -- dbms_output.put_line('meter.M_COMPANY_METER_ID - '||meter.M_COMPANY_METER_ID);
                                -- -- dbms_output.put_line('meter.M_COMPANY_SERVICE_ID - '||meter.M_COMPANY_SERVICE_ID);
                                -- -- dbms_output.put_line('meter.READING_Year - '||meter.READING_Year);
                                -- -- dbms_output.put_line('meter.READING_MONTH - '||meter.READING_MONTH);

                                -- to find generator capacity
                                SELECT count(*) INTO v_gen_count FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;

                                if(v_gen_count =0) THEN
                                        -- setup issue - generator not configured properly for this service
                                        v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','ISSUE','Setup Issue - '||v_process_id||' - No generator configured for service-id-->'||meter.M_COMPANY_SERVICE_ID,null,v_created_By, sysdate,v_process_id);

          v_result := 'FAILURE - No generator configured';
          GOTO LOOP_END;
                                ELSE
          -- TODO - Sum() should be revisited
                                        SELECT sum(nvl(CAPACITY,0))  INTO v_gs.MACHINE_CAPACITY FROM M_GENERATOR g JOIN M_POWERPLANT p ON g.M_POWERPLANT_ID = p.ID WHERE p.M_SERVICE_ID = meter.M_COMPANY_SERVICE_ID ;
                                END IF;


                                -- -- dbms_output.put_line('v_gs.MACHINE_CAPACITY - '||v_gs.MACHINE_CAPACITY);

                                SELECT * INTO v_mrh FROM T_METER_READING_HDR WHERE  M_COMPANY_METER_ID = meter.M_COMPANY_METER_ID AND READING_MONTH = meter.READING_MONTH AND READING_Year = meter.READING_Year;


                                -- -- dbms_output.put_line('v_mrh.id - '||v_mrh.id);

                                SELECT * INTO v_mr_c1 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C1';
                                SELECT * INTO v_mr_c2 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C2';
                                SELECT * INTO v_mr_c3 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C3';
                                SELECT * INTO v_mr_c4 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C4';
                                SELECT * INTO v_mr_c5 FROM T_METER_READING_SLOT WHERE T_METER_READING_HDR_ID = v_mrh.id AND SLOT_CODE = 'C5';


                                -- -- dbms_output.put_line('all slots- '||v_mrh.id);
                                -- intialise PK, FKs for GenStmt and GenSlots
                                v_gs.id := T_GEN_STMT_SEQ.nextval;
                                v_gs_c1.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c1.T_GEN_STMT_ID := v_gs.id;
                                v_gs_c2.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c2.T_GEN_STMT_ID := v_gs.id;
                                v_gs_c3.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c3.T_GEN_STMT_ID := v_gs.id;
                                v_gs_c4.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c4.T_GEN_STMT_ID := v_gs.id;
                                v_gs_c5.id := T_GEN_STMT_SLOT_SEQ.nextval;v_gs_c5.T_GEN_STMT_ID := v_gs.id;

                                -- set values in gen stmt
                                v_gs.STATUS_CODE := 'CREATED';
                                v_gs.M_COMPANY_METER_ID := v_mrh.M_COMPANY_METER_ID ;
                                v_gs.T_MR_IDS := v_mrh.M_COMPANY_METER_ID ;
                                v_gs.REF_NUMBER := v_process_id;
                                v_gs.mf := v_mrh.mf;
                                v_gs.STMT_GEN_DATE := v_created_Date ;
                                v_gs.STMT_MONTH :=  v_mrh.READING_MONTH;
                                v_gs.STMT_YEAR := v_mrh.READING_YEAR;
                                v_gs.INIT_STMT_DT := v_mrh.INIT_READING_DT;
                                v_gs.FINAL_STMT_DT := v_mrh.FINAL_READING_DT;
                                -- RKVAH_INIT, RKVAH_FINAL, KVAH_INIT, KVAH_FINAL are not relevant currently
                                v_gs.KVAH_DIFF := v_mrh.KVAH_DIFF;
                                v_gs.KVAH_UNITS := v_mrh.KVAH_UNITS;
                                v_gs.RKVAH_DIFF := v_mrh.RKVAH_DIFF;
                                v_gs.RKVAH_UNITS := v_mrh.RKVAH_UNITS;
                                v_gs.TOTAL_EXPORT_GEN := v_mr_c1.EXP_UNITS+v_mr_c2.EXP_UNITS+v_mr_c3.EXP_UNITS+v_mr_c4.EXP_UNITS+v_mr_c5.EXP_UNITS;
                                v_gs.TOTAL_IMPORT_GEN := v_mr_c1.IMP_UNITS+v_mr_c2.IMP_UNITS+v_mr_c3.IMP_UNITS+v_mr_c4.IMP_UNITS+v_mr_c5.IMP_UNITS;
                                v_gs.M_ORG_ID := meter.M_ORG_ID;
                                v_gs.M_COMPANY_ID := meter.M_COMPANY_ID;
                                v_gs.M_COMPANY_SERVICE_ID := meter.M_COMPANY_SERVICE_ID;
                                v_gs.DISP_COMPANY_NAME := meter.DISP_COMPANY_NAME;
                                v_gs.DISP_SERVICE_NUMBER := meter.DISP_SERVICE_NUMBER;
                                v_gs.INJECTING_VOLTAGE_CODE := meter.INJECTING_VOLTAGE_CODE;
                                v_gs.DISP_ORG_NAME := meter.DISP_ORG_NAME;
                                v_gs.net_generation := v_mr_c1.NET_UNITS+v_mr_c2.NET_UNITS+v_mr_c3.NET_UNITS+v_mr_c4.NET_UNITS+v_mr_c5.NET_UNITS;
                                v_gs.C1 := v_mr_c1.NET_UNITS;
                                v_gs.C2 := v_mr_c2.NET_UNITS;
                                v_gs.C3 := v_mr_c3.NET_UNITS;
                                v_gs.C4 := v_mr_c4.NET_UNITS;
                                v_gs.C5 := v_mr_c5.NET_UNITS;
                                v_gs.created_by := v_created_By;
                                v_gs.created_dt := v_created_date;
                                v_gs.TOTAL_CHARGED_AMOUNT := 0; --actual value calculated by calc_gs_charges()

                                if(to_number(v_gs.TOTAL_EXPORT_GEN)*0.01 >= to_number(v_gs.RKVAH_UNITS)) THEN
                                        v_gs.penalty_rate := '0.25';
                                ELSE
                                        v_gs.penalty_rate := '0.50';
                                END IF;


                                -- -- dbms_output.put_line('gen stmt - values set');

                                SELECT v_mr_c1.SLOT_CODE,v_mr_c1.IMP_INIT, v_mr_c1.IMP_FINAL, v_mr_c1.IMP_DIFF, v_mr_c1.IMP_UNITS, v_mr_c1.EXP_INIT, v_mr_c1.EXP_FINAL, v_mr_c1.EXP_DIFF, v_mr_c1.EXP_UNITS, meter.bc1, v_mr_c1.NET_UNITS
                                INTO  v_gs_c1.SLOT_CODE,v_gs_c1.IMP_INIT, v_gs_c1.IMP_FINAL, v_gs_c1.IMP_DIFF, v_gs_c1.IMP_UNITS, v_gs_c1.EXP_INIT, v_gs_c1.EXP_FINAL, v_gs_c1.EXP_DIFF, v_gs_c1.EXP_UNITS, v_gs_c1.BANKED_BALANCE, v_gs_c1.NET_UNITS
                                FROM dual;

                                SELECT  v_mr_c2.SLOT_CODE,v_mr_c2.IMP_INIT, v_mr_c2.IMP_FINAL, v_mr_c2.IMP_DIFF, v_mr_c2.IMP_UNITS, v_mr_c2.EXP_INIT, v_mr_c2.EXP_FINAL, v_mr_c2.EXP_DIFF, v_mr_c2.EXP_UNITS, meter.bc2, v_mr_c2.NET_UNITS
                                INTO  v_gs_c2.SLOT_CODE,v_gs_c2.IMP_INIT, v_gs_c2.IMP_FINAL, v_gs_c2.IMP_DIFF, v_gs_c2.IMP_UNITS, v_gs_c2.EXP_INIT, v_gs_c2.EXP_FINAL, v_gs_c2.EXP_DIFF, v_gs_c2.EXP_UNITS, v_gs_c2.BANKED_BALANCE, v_gs_c2.NET_UNITS
                                FROM dual;

                                SELECT  v_mr_c3.SLOT_CODE,v_mr_c3.IMP_INIT, v_mr_c3.IMP_FINAL, v_mr_c3.IMP_DIFF, v_mr_c3.IMP_UNITS, v_mr_c3.EXP_INIT, v_mr_c3.EXP_FINAL, v_mr_c3.EXP_DIFF, v_mr_c3.EXP_UNITS, meter.bc3, v_mr_c3.NET_UNITS
                                INTO  v_gs_c3.SLOT_CODE,v_gs_c3.IMP_INIT, v_gs_c3.IMP_FINAL, v_gs_c3.IMP_DIFF, v_gs_c3.IMP_UNITS, v_gs_c3.EXP_INIT, v_gs_c3.EXP_FINAL, v_gs_c3.EXP_DIFF, v_gs_c3.EXP_UNITS, v_gs_c3.BANKED_BALANCE, v_gs_c3.NET_UNITS
                                FROM dual;

                                SELECT  v_mr_c4.SLOT_CODE,v_mr_c4.IMP_INIT, v_mr_c4.IMP_FINAL, v_mr_c4.IMP_DIFF, v_mr_c4.IMP_UNITS, v_mr_c4.EXP_INIT, v_mr_c4.EXP_FINAL, v_mr_c4.EXP_DIFF, v_mr_c4.EXP_UNITS, meter.bc4, v_mr_c4.NET_UNITS
                                INTO  v_gs_c4.SLOT_CODE,v_gs_c4.IMP_INIT, v_gs_c4.IMP_FINAL, v_gs_c4.IMP_DIFF, v_gs_c4.IMP_UNITS, v_gs_c4.EXP_INIT, v_gs_c4.EXP_FINAL, v_gs_c4.EXP_DIFF, v_gs_c4.EXP_UNITS, v_gs_c4.BANKED_BALANCE, v_gs_c4.NET_UNITS
                                FROM dual;

                                SELECT  v_mr_c5.SLOT_CODE,v_mr_c5.IMP_INIT, v_mr_c5.IMP_FINAL, v_mr_c5.IMP_DIFF, v_mr_c5.IMP_UNITS, v_mr_c5.EXP_INIT, v_mr_c5.EXP_FINAL, v_mr_c5.EXP_DIFF, v_mr_c5.EXP_UNITS, meter.bc5, v_mr_c5.NET_UNITS
                                INTO  v_gs_c5.SLOT_CODE,v_gs_c5.IMP_INIT, v_gs_c5.IMP_FINAL, v_gs_c5.IMP_DIFF, v_gs_c5.IMP_UNITS, v_gs_c5.EXP_INIT, v_gs_c5.EXP_FINAL, v_gs_c5.EXP_DIFF, v_gs_c5.EXP_UNITS, v_gs_c5.BANKED_BALANCE, v_gs_c5.NET_UNITS
                                FROM dual;


                                -- -- dbms_output.put_line('gen stmt slots - insert');

                                INSERT INTO T_GEN_STMT VALUES  v_gs;
                                INSERT INTO T_GEN_STMT_SLOT VALUES  v_gs_c1;
                                INSERT INTO T_GEN_STMT_SLOT VALUES  v_gs_c2;
                                INSERT INTO T_GEN_STMT_SLOT VALUES  v_gs_c3;
                                INSERT INTO T_GEN_STMT_SLOT VALUES  v_gs_c4;
                                INSERT INTO T_GEN_STMT_SLOT VALUES  v_gs_c5;

                                -- -- dbms_output.put_line('gen stmt slots - calling charges');

        if(meter.fuel_type_Code = '03' or meter.fuel_type_Code = '04') then
          -- non-fossil fuels
          v_result := calc_gs_charges(v_gs.id);
          -- -- dbms_output.put_line('gen stmt slots - after charges');
        else
          --fossil fuels; charges are calculated in energy-sale
          null;
        end if;
        v_result := 'SUCCESS';
                                <<LOOP_END>>
        v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','IN-LOOP-END','End -'||meter.DISP_SERVICE_NUMBER,v_result,v_created_By, sysdate);
                                COMMIT;
                        exception
                          when others then
                            v_exception_code := SQLCODE;
                            v_exception_msg := SUBSTR(SQLERRM, 1, 200);
                            v_result := 'FAILURE';
                            v_reason := v_exception_code || ' - ' || v_exception_msg;
                            -- -- dbms_output.put_line('Error while processing each meter-reading - '||v_reason);

          v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','IN-LOOP-END','Exception -'||meter.DISP_SERVICE_NUMBER, v_reason,null,v_created_By, sysdate);
                        END;
                END LOOP;


                if(v_no_records) THEN
                        v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT',null,'No Records to process',null,v_created_By, v_created_Date);

                ELSE
                        -- -- dbms_output.put_line('v_no_records- false. process-id->'||v_process_id);
      NULL;
                END IF;

        exception
          when others then
            v_exception_code := SQLCODE;
            v_exception_msg := SUBSTR(SQLERRM, 1, 200);
            v_result := 'FAILURE';
            v_reason := v_exception_code || ' - ' || v_exception_msg;
            -- -- dbms_output.put_line(v_reason);
        END;
   <<THE_END>>

  IF (v_no_records) THEN
        v_result := 'FAILURE';
        v_reason := 'No meter reading available to process generation statements';
         v_result := v_result || ' - ' || v_reason;

  else
          IF (V_RESULT = 'SUCCESS') THEN
                update T_PROCESS_GS set status='COMPLETED' where id = v_process_id;
          ELSE

                update T_PROCESS_GS set status='ERROR',  REMARKS=v_reason  where id = v_process_id;
            v_result := v_result || ' - ' || v_reason;
          END IF;
  END IF;

  v_log_result := log_activity('PROCEDURE','PROCESS_GEN_STMT','END','Start - '||v_process_id,V_RESULT,v_created_By, v_created_Date);

  COMMIT;

  return v_result;

END process_gen_stmt;

/
--------------------------------------------------------
--  DDL for Function PROCESS_IMPORT_SELLERS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."PROCESS_IMPORT_SELLERS" 
(
  v_REMARKS in varchar2
) RETURN VARCHAR2 AS
v_flow_type_code varchar2(50);
v_esi_status_code varchar2(50);
v_signup_count number:=0;
v_signup_tr_count number:=0;
--v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_signup_import_result varchar(300):='SUCCESS';
v_imported BOOLEAN;
v_signup M_SIGNUP%ROWTYPE;
v_itr import_trade_rel%ROWTYPE;
v_conversion number:=0.001;
process_san_qun_result varchar2(50):= '';
v_process_name varchar2(200):='PROCESS_IMPORT_SELLERS';
v_import_remarks  VARCHAR2(1000):=null;
v_is_captive varchar2(10);
v_import_row_count number;
BEGIN
-- begin for exception handling
BEGIN

   v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','START','Start - '||v_REMARKS,'','', sysdate,v_REMARKS);

   select count(*) into v_import_row_count from  import_sellers where remarks = v_remarks;
   if(v_import_row_count <= 0) then
	    v_reason := 'No rows in import table for the given remark - '||v_remarks;
	    V_RESULT := 'FAILURE';
	    GOTO THE_END;
    end if;

  -- reset values
  update import_sellers set m_org_id=null, m_substation_id=null,m_feeder_id=null,gen_make_code=null,commission_date=null, CLEAN_REC='Y', IMPORT_REMARKS='' where remarks = v_remarks;
  UPDATE import_trade_rel SET  import_remarks =null WHERE   remarks = v_remarks;

  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Init Done',''||v_REMARKS,'','', sysdate,v_REMARKS);
  update import_sellers set commission_date =  to_date(trim(commission_date_str),'dd/mm/yyyy')  where commission_date is  null and commission_date_str is not null and remarks = v_remarks;



  --update org-id
  FOR i IN ( select distinct i.edc_name, o.org_id from import_sellers i inner join v_org o on o.org_name = i.edc_name where i.remarks = v_remarks)
  LOOP
    update import_sellers set m_org_id = i.org_id where trim(edc_name) = i.edc_name and remarks = v_remarks;
  END LOOP;

  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Org lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);

  --update ss-id
  FOR j IN ( select distinct i.SS_NAME_IN_OA, s.id  from import_sellers i inner join m_substation s on i.SS_NAME_IN_OA = s.name where i.remarks = v_remarks)
  LOOP
    update import_sellers set m_substation_id = j.id where trim(SS_NAME_IN_OA) = j.SS_NAME_IN_OA and remarks = v_remarks;
  END LOOP;

  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','SS lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);
  --update feeder-id and voltage-code
  FOR k IN (select distinct i.FEEDER_NAME_IN_OA, f.id, f.voltage_code from import_sellers i inner join m_feeder f on i.FEEDER_NAME_IN_OA = f.name where i.remarks = v_remarks)
  LOOP
  --, voltage_code=k.voltage_code  -- not mapping voltage from feeder as instructed by aruna madam
    update import_sellers set m_feeder_id = k.id where trim(feeder_NAME_IN_OA) = k.feeder_NAME_IN_OA and remarks = v_remarks;
  END LOOP;

  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Feeder lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);

  --update voltage code
  FOR l IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'VOLTAGE_CODE')
  LOOP
    UPDATE import_sellers SET  VOLTAGE_code = l.VALUE_code WHERE trim(INJECTION_VOLTAGE)= l.VALUE_DESC and remarks = v_remarks and INJECTION_VOLTAGE is not null;
  END LOOP;
  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Voltage lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);

  --update generator make code
  FOR q IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'GENERATOR_MAKE_CODE')
  LOOP
    UPDATE import_sellers SET  gen_make_code = q.VALUE_code WHERE trim(gen_make_name_oa)= q.VALUE_DESC and remarks = v_remarks;
  END LOOP;
  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Gen Make lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);
  --update meter make code
  FOR m IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'METER_MAKE_CODE')
  LOOP
    UPDATE import_sellers SET  meter_make_code = m.VALUE_code WHERE trim(meter_make)= m.VALUE_DESC and remarks = v_remarks;
  END LOOP;
  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Meter Make lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);
  --update Wind pass  code
  FOR n IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'WIND_PASS_CODE')
  LOOP
    UPDATE import_sellers SET  wind_pass_code = n.VALUE_code WHERE trim(wind_pass_name)= n.VALUE_DESC and remarks = v_remarks;
  END LOOP;
  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Wind Pass  lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);

  --update WEG group code
  FOR p IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'PLANT_CLASS_TYPE_CODE')
  LOOP
    UPDATE import_sellers SET  weg_group_code = p.VALUE_code WHERE  trim(weg_group_name) = p.VALUE_DESC and remarks = v_remarks;
  END LOOP;
  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Weg Group  lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);

   --update Fuel code
  FOR r IN ( select fuel_code, fuel_name FROM m_fuel)
  LOOP
  --- UPDATE import_sellers SET  fuel_code =r.fuel_code WHERE  upper(trim(fuel)) = upper(r.fuel_name) and remarks = v_remarks and 
  --- substr(GENERATOR_SERVICE_NO_NEW,3,3) in  ('910','911','912'); ---MY

    UPDATE import_sellers SET  fuel_code =r.fuel_code WHERE  upper(trim(fuel)) = upper(r.fuel_name) and remarks = v_remarks;---original
  END LOOP;

  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','Fuel code lookup Done',''||v_REMARKS,'','', sysdate,v_REMARKS);

  --  code cleansing start
  update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='Valid Fuel is mandatory' where  remarks = v_remarks and nvl(CLEAN_REC,'') <> 'N' and fuel_code is null;
  update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='EDCNAME not provided or given name doesnt exist in system' where  remarks = v_remarks and nvl(CLEAN_REC,'') <> 'N' and m_org_id is null;
  update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='GENERATOR_SERVICE_NO_NEW not provided' where  remarks = v_remarks and  nvl(CLEAN_REC,'') <> 'N' and (GENERATOR_SERVICE_NO_NEW is null or GENERATOR_SERVICE_NO_NEW ='');
  update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='INJECTION_VOLTAGE or VOLTAGE_code of feeder is null. cannot be imported' where  remarks = v_remarks and  nvl(CLEAN_REC,'') <> 'N' and (VOLTAGE_code is null or VOLTAGE_code ='');

  update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='FlowTypeCode in import_sellers is mandatory. expected - IS-CAPTIVE, STB, THIRD-PARTY' where  remarks = v_remarks and  nvl(CLEAN_REC,'') <> 'N' and (flow_type_Code is null or FLOW_TYPE_CODE not in('IS-CAPTIVE','STB','THIRD-PARTY'));


  FOR s1 IN(select sig.HTSC_NUMBER  from M_SIGNUP sig join import_sellers sel on sig.HTSC_NUMBER = sel.GENERATOR_SERVICE_NO_NEW where  sel.remarks = v_remarks)
  loop
    update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='Service Already exists in signup. to import clear that entry from signup' where  nvl(CLEAN_REC,'') <> 'N' and GENERATOR_SERVICE_NO_NEW  = s1.HTSC_NUMBER and remarks = v_remarks;
  end loop;


  FOR s2 IN(select  serv."number" gen_serv_no from v_company_Service serv join import_sellers sel on serv."number" = sel.GENERATOR_SERVICE_NO_NEW where  sel.remarks = v_remarks)
  loop
    update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS='Service Already exists in the system. cannot import this service'
    where  nvl(CLEAN_REC,'') <> 'N' and GENERATOR_SERVICE_NO_NEW = s2.gen_serv_no and remarks = v_remarks;
  end loop;

  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','PROCESS','Validating Trade Relationships ','','', sysdate,v_REMARKS);

 --validating trade relationships
    FOR v_itr IN ( SELECT SELLER_COMPANY_SERVICE_NO,BUYER_COMPANY_SERVICE_NO, FLOW_TYPE_CODE, INTERVAL_TYPE_CODE,SHARE_PERCENT, QUANTUM, c1,c2,c3,c4, c5, PEAK_UNITS, OFF_PEAK_UNITS 
                    FROM IMPORT_TRADE_REL WHERE remarks = v_remarks)
    LOOP
        v_import_remarks := null;
        if(v_itr.FLOW_TYPE_CODE is null) then
            v_import_remarks := 'FlowTypeCode is mandatory for TradeRelationship';
        else
           if(v_itr.FLOW_TYPE_CODE not in('IS-CAPTIVE','STB','THIRD-PARTY')) then
                v_import_remarks := 'FlowTypeCode in TradeRelationship is not supported. expected - IS-CAPTIVE, STB, THIRD-PARTY';
           end if;
        end if;

        if(v_itr.INTERVAL_TYPE_CODE is null) then
            v_import_remarks := 'IntervalTypeCode is mandatory for TradeRelationship';
        else
           if(v_itr.INTERVAL_TYPE_CODE ='01' and (v_itr.peak_units is null and v_itr.off_peak_units is null)) then
                v_import_remarks := 'slots in TradeRelationship are not set';
           elsif(v_itr.INTERVAL_TYPE_CODE ='02' and (v_itr.c1 is null and v_itr.c2 is null and v_itr.c3 is null and v_itr.c4 is null and v_itr.c5 is null)) then
                v_import_remarks := 'slots in TradeRelationship are not set';
           ELSIF(v_itr.INTERVAL_TYPE_CODE ='04' and (v_itr.share_percent is null or v_itr.quantum is null)) then
                v_import_remarks := 'share percentage and quantum in TradeRelationship are not set';

           end if;
        end if;
         -- v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','PROCESS','v_import_remarks-'||v_import_remarks,'','', sysdate,v_REMARKS);

        if(v_import_remarks is not null) then
            UPDATE import_trade_rel SET  import_remarks = v_import_remarks 
            WHERE  SELLER_COMPANY_SERVICE_NO=v_itr.SELLER_COMPANY_SERVICE_NO and BUYER_COMPANY_SERVICE_NO = v_itr.BUYER_COMPANY_SERVICE_NO and remarks = v_remarks;

            update import_sellers set CLEAN_REC = 'N', IMPORT_REMARKS=v_import_remarks where  remarks = v_remarks and generator_service_no_new =v_itr.SELLER_COMPANY_SERVICE_NO and nvl(CLEAN_REC,'') <> 'N';
        end if;
    END LOOP;

  --  code cleansing end
  v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','PROCESS','lookup codes and data cleansing completed ','','', sysdate,v_REMARKS);
              -- -- dbms_output.put_line('code cleansing completed') ;

  --insert into m_signup table
  INSERT INTO M_SIGNUP
    (
      ID , COMPANY_NAME,PURPOSE ,COMMISSION_DATE ,VOLTAGE,HTSC_NUMBER_OLD ,HTSC_NUMBER ,SANCTIONED_QUANTUM ,TOTAL_CAPACITY ,IS_CAPTIVE ,
      FUEL,NO_OF_GENERATOR ,IS_REC ,WIND_PASS_code ,ADDRESS_LINE,
      VILLAGE ,M_ORG_ID ,M_SUBSTATION_ID ,M_FEEDER_ID ,IS_COMPLETE ,PLANT_CLASS_TYPE_code ,GENERATOR_CAPACITY ,METER_NUMBER ,METER_MAKE_code ,ACCURACY_CLASS_TYPE_code ,IS_ABT_METER ,MULTIPLICATION_FACTOR ,
      CREATED_BY ,CREATED_DATE ,REMARKS ,MODEM_NO ,GU_MODEL1 ,GU_CAPACITY1 ,NO_OF_GU1 ,ENABLED ,TURBINE_SL_NO ,TURBINE_ROTOR_DIA, TURBINE_HUB_HEIGHT, IS_DLMS_METER ,METER_CT_RATIO ,METER_PT_RATIO ,TOTAL_GENERATOR_UNIT, SURPLUS_ENERGY_CODE, ACCELERATED_DEPRECIATION, import_remarks,NATURE_OF_BOARD, flow_type_code
    )
    (SELECT M_SIGNUP_SEQ.nextval ID, COMPANY_NAME COMPANY_NAME, '02' PURPOSE,COMMISSION_DATE,VOLTAGE_code VOLTAGE,GENERATOR_SERVICE_NO_OLD HTSC_NUMBER_OLD ,GENERATOR_SERVICE_NO_NEW HTSC_NUMBER,TOTAL_CAPACITY_KW SANCTIONED_QUANTUM ,TOTAL_CAPACITY_KW TOTAL_CAPACITY, DEcode(flow_type_code,'IS-CAPTIVE','Y','N') IS_CAPTIVE,
    fuel_code  FUEL,
    NO_OF_GEN_UNITS NO_OF_GENERATOR,IS_REC IS_REC,WIND_PASS_code,SF_NO ADDRESS_LINE,
        VILLAGE VILLAGE ,M_ORG_ID M_ORG_ID,M_SUBSTATION_ID,M_FEEDER_ID,'N' IS_COMPLETE ,WEG_GROUP_code ,GEN_UNIT_CAPACITY GENERATOR_CAPACITY,METER_NUMBER METER_NUMBER,METER_MAKE_code,ACCURACY_CLASS,IS_ABT IS_ABT_METER,MF MULTIPLICATION_FACTOR,
        v_process_name CREATED_BY,sysdate created_date,REMARKS REMARKS,MODEM_NO MODEM_NO,GEN_MAKE_code GU_MODEL1,
        GEN_UNIT_CAPACITY GU_CAPACITY1,NO_OF_GEN_UNITS NO_OF_GU1,'Y' enabled,TURBINE_SL_NO TURBINE_SL_NO,
        TURBINE_ROTOR_DIA TURBINE_ROTOR_DIA ,TURBINE_HUB_HEIGHT TURBINE_HUB_HEIGHT ,IS_DLMS,CT_RATIO METER_CT_RATIO ,
        PT_RATIO METER_PT_RATIO ,GEN_UNIT_CAPACITY TOTAL_GENERATOR_UNIT,SURPLUS_ENERGY,ACCELERATED_DEPRECIATION,v_remarks,
        NATURE_OF_BOARD, flow_type_code
      FROM import_sellers
      WHERE remarks = v_remarks
      AND CLEAN_REC = 'Y'
    );

    v_signup_count :=   sql%Rowcount;
      v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','PROCESS','insert into m_signup completed','signup_count -' ||v_signup_count,'', sysdate,v_REMARKS);

  --- import signup traderelationship
  if(v_signup_count>0) then



   --update Interval type code
    FOR p IN ( select value_code, value_desc FROM v_codes WHERE list_code = 'INTERVAL_TYPE_CODE')
    LOOP
      UPDATE import_trade_rel SET  INTERVAL_TYPE_code = p.VALUE_code WHERE  trim(INTERVAL_TYPE_NAME) = p.VALUE_DESC and remarks = v_remarks;
    END LOOP;


    FOR signup IN(select * into v_signup from M_SIGNUP where remarks = v_remarks)

    LOOP
      BEGIN
        update import_trade_rel set M_SIGNUP_ID = signup.id, id = signup.id ||rownum where 
        remarks = v_remarks and seller_company_service_no = signup.HTSC_NUMBER;

        -- updating the service_id, company id of the consumers in import-trade-rel
        UPDATE import_trade_rel t1
         SET (t1.M_BUYER_COMP_SERVICE_ID, t1.M_BUYER_COMPANY_ID) = (SELECT t2.id, t2.M_COMPANY_ID
                               FROM  v_company_service t2
                              WHERE t1.BUYER_COMPANY_SERVICE_NO = t2."number")
        WHERE EXISTS (
          SELECT 1
            FROM v_company_service t2
           WHERE t1.BUYER_COMPANY_SERVICE_NO = t2."number" );

           -- PROCESS_SANC_QUAN_FOR_FF(v_remarks, process_san_qun_result);

        update import_trade_rel set from_date=to_date(from_date_str,'dd/mm/yyyy') , to_date=to_date(to_date_str,'dd/mm/yyyy'), 
        quantum = (signup.SANCTIONED_QUANTUM/to_number(SHARE_PERCENT)*100)*v_conversion where  remarks = v_remarks  ;

---(( insert into t_banking_balance (id, remarks, MONTH, YEAR,C1,C2,C3,C4,C5,CREATED_BY,CREATED_DT, ENABLED,M_COMPANY_ID, 
--BANKING_SERVICE_ID,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CALCULATED)
    -----    (SELECT T_BANKING_BALANCE_SEQ.nextval ID, 'BK_TO_UPDATE_CURC1', v_month, v_year,v_c1,v_c2,v_c3,v_c4,v_c5,
   ----     'admin',sysdate, 'Y',v_comp_id, v_banking_service_id,v_c1,v_c2,v_c3,v_c4,v_c5,'N'
      ---------    FROM dual       );))---



        insert into M_SIGNUP_TRADE_REL(ID,M_SIGNUP_ID,QUANTUM,FROM_DATE,TO_DATE,STATUS_CODE,M_BUYER_COMPANY_ID,
            M_BUYER_COMP_SERVICE_ID, REMARKS,SHARE_PERCENT,CREATED_BY,CREATED_DATE,C1,C2,C3,C4,C5,ENABLED,PEAK_UNITS,OFF_PEAK_UNITS,INTERVAL_TYPE_CODE,IMPORT_REMARKS, FLOW_TYPE_CODE)
        (select ID,M_SIGNUP_ID,QUANTUM,FROM_DATE,TO_DATE,STATUS_code,M_BUYER_COMPANY_ID,
             M_BUYER_COMP_SERVICE_ID,REMARKS,SHARE_PERCENT,v_process_name,sysdate,C1,C2,C3,C4,C5,ENABLED,PEAK_UNITS,OFF_PEAK_UNITS,INTERVAL_TYPE_code, v_remarks AS import_remarks, FLOW_TYPE_CODE
          from import_TRADE_REL where  remarks = v_remarks and seller_company_service_no = signup.HTSC_NUMBER and
          M_BUYER_COMP_SERVICE_ID is not null);

        v_signup_tr_count :=  v_signup_tr_count + sql%Rowcount;
        v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','PROCESS','traderelationship completed',signup.HTSC_NUMBER,sql%Rowcount, sysdate,v_REMARKS);
      exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          v_result := 'FAILURE';
          v_reason := v_exception_code || ' - ' || v_exception_msg;
          -- -- dbms_output.put_line(v_reason);
            v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','EXCEPTION IN TR',v_reason,'','', sysdate,v_REMARKS);
    END;

    END LOOP;
  end if;

     v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','RESULT','signups created - '||v_signup_count,'trs created - '||v_signup_tr_count,'', sysdate,v_REMARKS);


  FOR e IN(select  GENERATOR_SERVICE_NO_NEW, import_remarks from  import_sellers sel where  sel.remarks = v_remarks and nvl(CLEAN_REC,'') = 'N')
  loop
      v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','IMPORT_ERROR',e.GENERATOR_SERVICE_NO_NEW,e.import_remarks,'', sysdate,v_REMARKS);
  end loop;
  commit;

  if(v_signup_count>0) then
    v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','RESULT','Calling IMPORT_FROM_SIGNUP','','', sysdate,v_REMARKS);
    v_signup_import_result := IMPORT_FROM_SIGNUP(v_remarks);
  end if;
exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      -- -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','EXCEPTION',v_reason,'','', sysdate,v_REMARKS);
END;
<<THE_END>>

v_log_result := log_activity('PROCEDURE','PROCESS_IMPORT_SELLERS','END','Import complete',V_RESULT,v_reason, sysdate,v_REMARKS);

return V_RESULT || ' - ' || v_reason;

END PROCESS_IMPORT_SELLERS;

/
--------------------------------------------------------
--  DDL for Function PROCESS_IMP_BANKING_BALANCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."PROCESS_IMP_BANKING_BALANCE" 
(
  I_REMARKS IN VARCHAR2 ,
  I_OVERWRITE IN CHAR DEFAULT 'N' 
) RETURN VARCHAR2 AS 

V_OVERWRITE CHAR(1) := 'N';
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_imported BOOLEAN;
v_imported_count number:=0;
v_total_count number:=0;

BEGIN

-- begin for exception handling
BEGIN

   v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','START','Start - '||I_REMARKS,'','', sysdate,I_REMARKS);

  if(I_OVERWRITE is not null and I_OVERWRITE='Y') then V_OVERWRITE := 'Y'; end if; 

  select count(*) into v_total_count from IMP_BANKING_BALANCE where remarks = I_REMARKS;
  if(v_total_count=0) then
      Raise_Application_Error (-20343, 'No records to process');
  end if;

  -- reset values
  update IMP_BANKING_BALANCE set GEN_SERVICE_NUMBER = trim(GEN_SERVICE_NUMBER), M_COMPANY_ID = null, BANKING_SERVICE_ID = null,CLEAN_REC = null,IMPORTED = null, IMPORT_REMARKS=null, created_by = v_created_By, created_dt=sysdate where remarks = I_REMARKS;

  v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','Init Done',''||I_REMARKS,'','', sysdate,I_REMARKS);

  --update company-id, banking-service-id,company-service-id
  FOR i IN ( select IMP.GEN_SERVICE_NUMBER, SER.M_COMPANY_ID, SER.BANKING_SERVICE_ID,SER.ID  from IMP_BANKING_BALANCE IMP inner join v_company_service SER on SER."number" = IMP.GEN_SERVICE_NUMBER where IMP.remarks =I_REMARKS)
  LOOP
    update IMP_BANKING_BALANCE set BANKING_SERVICE_ID = i.BANKING_SERVICE_ID,  M_COMPANY_ID = i.M_COMPANY_ID ,M_COMPANY_SERVICE_ID=i.ID, CLEAN_REC ='Y', ENABLED='Y' where GEN_SERVICE_NUMBER = i.GEN_SERVICE_NUMBER and remarks = I_REMARKS;
  END LOOP;


  --  code cleansing start
  update IMP_BANKING_BALANCE set CLEAN_REC = 'N', IMPORT_REMARKS='ERROR - GEN_SERVICE_NUMBER not in system' where  remarks = I_REMARKS and CLEAN_REC is null;

  FOR i IN ( select IMP.GEN_SERVICE_NUMBER,bal.BANKING_SERVICE_ID, bal.month,bal.year from IMP_BANKING_BALANCE IMP inner join t_banking_balance bal on bal.BANKING_SERVICE_ID = IMP.BANKING_SERVICE_ID and to_number(bal.month) = to_number(imp.month) and  to_number(bal.year) = to_number(imp.year)
    where IMP.remarks =I_REMARKS and nvl(CLEAN_REC,'') ='Y')
  LOOP
    IF (V_OVERWRITE = 'Y') THEN
      DELETE t_banking_balance where BANKING_SERVICE_ID=i.BANKING_SERVICE_ID and  to_number(MONTH)=to_number(i.MONTH) and to_number(YEAR)=to_number(i.YEAR);
    ELSE
      update IMP_BANKING_BALANCE set CLEAN_REC = 'N', IMPORT_REMARKS='ERROR - Banking Balance already exists' where  remarks = I_REMARKS and GEN_SERVICE_NUMBER = i.GEN_SERVICE_NUMBER;
    END IF;

  END LOOP;




  -- CODE FOR CHECKING TRADERELATIONSHIP WITH TNEB EXIST
   FOR i IN ( SELECT count(*) total,trade.M_SELLER_COMPANY_ID  FROM IMP_BANKING_BALANCE IMP inner join M_TRADE_RELATIONSHIP trade on TRADE.M_SELLER_COMPANY_ID=imp.M_COMPANY_ID and to_date(to_char(lpad(IMP.month,2,'0')||'-'||IMP.year),'MM-YYYY') BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE 
and trade.M_BUYER_COMPANY_ID='TNEB' 
    where IMP.remarks =I_REMARKS and nvl(CLEAN_REC,'') ='Y'  GROUP BY trade.M_SELLER_COMPANY_ID )
  LOOP
  IF to_number(i.total)>0 then
   update IMP_BANKING_BALANCE set CLEAN_REC = 'N', IMPORT_REMARKS='ERROR - TradeRelationship with TNEB already exists' where  remarks = I_REMARKS and M_COMPANY_ID=i.M_SELLER_COMPANY_ID;
   end IF;
  END LOOP;

    v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','Cleansing Complete',''||I_REMARKS,'','', sysdate,I_REMARKS);

  insert into t_banking_balance (id, remarks, MONTH, YEAR,C1,C2,C3,C4,C5,CREATED_BY,CREATED_DT, ENABLED,M_COMPANY_ID, BANKING_SERVICE_ID,CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CALCULATED)
    (SELECT T_BANKING_BALANCE_SEQ.nextval ID, remarks, lpad(month,2,'0'), year,C1,C2,C3,C4,C5,CREATED_BY,CREATED_DT, ENABLED,M_COMPANY_ID, BANKING_SERVICE_ID,C1,C2,C3,C4,C5,'N'
      FROM IMP_BANKING_BALANCE
      WHERE remarks = I_REMARKS
      AND CLEAN_REC = 'Y'
    );

  v_imported_count :=   sql%Rowcount;
  if(v_imported_count>0) then
    update IMP_BANKING_BALANCE set IMPORTED = 'Y', IMPORT_REMARKS='IMPORTED' where  remarks = I_REMARKS and CLEAN_REC = 'Y';
    v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','PROCESS','data imported complete','success_records -' ||v_imported_count,'', sysdate,I_REMARKS);
  else
    v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','PROCESS','no data imported','error_records -' ||(v_total_count-v_imported_count),'', sysdate,I_REMARKS);
    V_RESULT:= 'FAILURE';
    v_reason := 'no clean data to import';

  end if;
  commit;
exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      -- -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','EXCEPTION',v_reason,'','', sysdate,I_REMARKS);
END;

v_log_result := log_activity('FUNCTION','PROCESS_IMP_BANKING_BALANCE','END','Import complete','','', sysdate,I_REMARKS);

return V_RESULT || ' - ' || v_reason;

END PROCESS_IMP_BANKING_BALANCE;


/
--------------------------------------------------------
--  DDL for Function PROCESS_IMP_TECHNICAL_DATA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."PROCESS_IMP_TECHNICAL_DATA" 
(
  V_REMARKS IN VARCHAR2 
) RETURN VARCHAR2 AS 
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_total_count number:=0;

BEGIN

-- begin for exception handling
BEGIN

  v_log_result := log_activity('FUNCTION','PROCESS_IMP_TECHNICAL_DATA','START','Start - '||V_REMARKS,'','', sysdate,V_REMARKS);

  select count(*) into v_total_count from imp_technical_data where remarks = V_REMARKS;
  if(v_total_count=0) then
      Raise_Application_Error (-20343, 'No records to process');
  end if;

  FOR imp_data IN ( select * from imp_technical_data  where remarks =V_REMARKS)
    LOOP

      if imp_data.m_company_id is not null then
        update m_company set name=imp_data.COMPANY_NAME where id=imp_data.m_company_id;
      end if;

      if imp_data.M_COMPANY_SERVICE_ID is not null then
        update m_company_service set M_ORG_ID=imp_data.M_ORG_ID ,M_SUBSTATION_ID=imp_data.M_SUBSTATION_ID ,M_FEEDER_ID=imp_data.M_FEEDER_ID,
          TOTAL_CAPACITY=imp_data.TOTAL_CAPACITY_KW,IS_REC=imp_data.IS_REC,FUEL_TYPE_CODE=imp_data.FUEL_CODE,IMPORT_REMARKS=imp_data.IMPORT_REMARKS
          where id= imp_data.M_COMPANY_SERVICE_ID;
      end if;

      if imp_data.M_POWERPLANT_ID is not null then
          update m_powerplant set COMMISSION_DATE=imp_data.COMMISSION_DATE , VILLAGE=imp_data.VILLAGE ,
            PLS_SF_NO=imp_data.SF_NO,WIND_PASS_CODE=imp_data.WIND_PASS_CODE where id= imp_data.M_POWERPLANT_ID;
      end if;

      if imp_data.M_METER_ID_1 is not null then
        update m_company_meter set PT_RATIO = imp_data.METER1_PT_RATIO,CT_RATIO= imp_data.METER1_CT_RATIO,MF= imp_data.METER1_MF,
          METER_MAKE_CODE= imp_data.METER1_METER_MAKE_CODE,METER_NUMBER= imp_data.METER1_METER_NUMBER,MODEM_NUMBER= imp_data.METER1_MODEM_NO,
          ACCURACY_CLASS_CODE = imp_data.METER1_ACCURACY_CLASS_CODE where id =imp_data.M_METER_ID_1;
      end if;

      if imp_data.M_METER_ID_2 is not null then
        update m_company_meter set PT_RATIO = imp_data.METER2_PT_RATIO,CT_RATIO= imp_data.METER2_CT_RATIO,MF= imp_data.METER2_MF,
          METER_MAKE_CODE= imp_data.METER2_METER_MAKE_CODE,METER_NUMBER= imp_data.METER2_METER_NUMBER,MODEM_NUMBER= imp_data.METER2_MODEM_NO,
          ACCURACY_CLASS_CODE = imp_data.METER2_ACCURACY_CLASS_CODE where id =imp_data.M_METER_ID_2;
      end if;

      if imp_data.M_METER_ID_3 is not null then
        update m_company_meter set PT_RATIO = imp_data.METER3_PT_RATIO,CT_RATIO= imp_data.METER3_CT_RATIO,MF= imp_data.METER3_MF,
          METER_MAKE_CODE= imp_data.METER3_METER_MAKE_CODE,METER_NUMBER= imp_data.METER3_METER_NUMBER,MODEM_NUMBER= imp_data.METER3_MODEM_NO,
          ACCURACY_CLASS_CODE = imp_data.METER3_ACCURACY_CLASS_CODE where id =imp_data.M_METER_ID_3;
      end if;

      if imp_data.M_METER_ID_4 is not null then
        update m_company_meter set PT_RATIO = imp_data.METER4_PT_RATIO,CT_RATIO= imp_data.METER4_CT_RATIO,MF= imp_data.METER4_MF,
          METER_MAKE_CODE= imp_data.METER4_METER_MAKE_CODE,METER_NUMBER= imp_data.METER4_METER_NUMBER,MODEM_NUMBER= imp_data.METER4_MODEM_NO,
          ACCURACY_CLASS_CODE = imp_data.METER4_ACCURACY_CLASS_CODE where id =imp_data.M_METER_ID_4;
      end if;

      if imp_data.M_METER_ID_5 is not null then
        update m_company_meter set PT_RATIO = imp_data.METER5_PT_RATIO,CT_RATIO= imp_data.METER5_CT_RATIO,MF= imp_data.METER5_MF,
          METER_MAKE_CODE= imp_data.METER5_METER_MAKE_CODE,METER_NUMBER= imp_data.METER5_METER_NUMBER,MODEM_NUMBER= imp_data.METER5_MODEM_NO,
          ACCURACY_CLASS_CODE = imp_data.METER5_ACCURACY_CLASS_CODE where id =imp_data.M_METER_ID_5;
      end if;

      if imp_data.M_METER_ID_6 is not null then
        update m_company_meter set PT_RATIO = imp_data.METER6_PT_RATIO,CT_RATIO= imp_data.METER6_CT_RATIO,MF= imp_data.METER6_MF,
          METER_MAKE_CODE= imp_data.METER6_METER_MAKE_CODE,METER_NUMBER= imp_data.METER6_METER_NUMBER,MODEM_NUMBER= imp_data.METER6_MODEM_NO,
          ACCURACY_CLASS_CODE = imp_data.METER6_ACCURACY_CLASS_CODE where id =imp_data.M_METER_ID_6;
      end if;

      if imp_data.M_GENERATOR_ID_1 is not null then
        update m_generator set MAKE_CODE = imp_data.GEN1_GEN_MAKE_CODE,NO_OF_UNITS= imp_data.GEN1_NO_OF_GEN_UNITS,CAPACITY = imp_data.GEN1_GEN_UNIT_CAPACITY,
          VOLTAGE_CODE =imp_data.GEN1_VOLTAGE_CODE,SERIAL_NO=imp_data.GEN1_TURBINE_SL_NO,ROTOR_DIA = imp_data.GEN1_TURBINE_ROTOR_DIA,
          HUB_HEIGHT =imp_data.GEN1_TURBINE_HUB_HEIGHT where id= imp_data.M_GENERATOR_ID_1;
      end if;

      if imp_data.M_GENERATOR_ID_2 is not null then
        update m_generator set MAKE_CODE = imp_data.GEN2_GEN_MAKE_CODE,NO_OF_UNITS= imp_data.GEN2_NO_OF_GEN_UNITS,CAPACITY = imp_data.GEN2_GEN_UNIT_CAPACITY,
          VOLTAGE_CODE =imp_data.GEN2_VOLTAGE_CODE,SERIAL_NO=imp_data.GEN2_TURBINE_SL_NO,ROTOR_DIA = imp_data.GEN2_TURBINE_ROTOR_DIA,
          HUB_HEIGHT =imp_data.GEN2_TURBINE_HUB_HEIGHT where id= imp_data.M_GENERATOR_ID_2;
      end if;

      if imp_data.M_GENERATOR_ID_3 is not null then
        update m_generator set MAKE_CODE = imp_data.GEN3_GEN_MAKE_CODE,NO_OF_UNITS= imp_data.GEN3_NO_OF_GEN_UNITS,CAPACITY = imp_data.GEN3_GEN_UNIT_CAPACITY,
          VOLTAGE_CODE =imp_data.GEN3_VOLTAGE_CODE,SERIAL_NO=imp_data.GEN3_TURBINE_SL_NO,ROTOR_DIA = imp_data.GEN3_TURBINE_ROTOR_DIA,
          HUB_HEIGHT =imp_data.GEN3_TURBINE_HUB_HEIGHT where id= imp_data.M_GENERATOR_ID_3;
      end if;

      if imp_data.M_GENERATOR_ID_4 is not null then
        update m_generator set MAKE_CODE = imp_data.GEN4_GEN_MAKE_CODE,NO_OF_UNITS= imp_data.GEN4_NO_OF_GEN_UNITS,CAPACITY = imp_data.GEN4_GEN_UNIT_CAPACITY,
          VOLTAGE_CODE =imp_data.GEN4_VOLTAGE_CODE,SERIAL_NO=imp_data.GEN4_TURBINE_SL_NO,ROTOR_DIA = imp_data.GEN4_TURBINE_ROTOR_DIA,
          HUB_HEIGHT =imp_data.GEN4_TURBINE_HUB_HEIGHT where id= imp_data.M_GENERATOR_ID_4;
      end if;

      if imp_data.M_GENERATOR_ID_5 is not null then
        update m_generator set MAKE_CODE = imp_data.GEN5_GEN_MAKE_CODE,NO_OF_UNITS= imp_data.GEN5_NO_OF_GEN_UNITS,CAPACITY = imp_data.GEN5_GEN_UNIT_CAPACITY,
          VOLTAGE_CODE =imp_data.GEN5_VOLTAGE_CODE,SERIAL_NO=imp_data.GEN5_TURBINE_SL_NO,ROTOR_DIA = imp_data.GEN5_TURBINE_ROTOR_DIA,
          HUB_HEIGHT =imp_data.GEN5_TURBINE_HUB_HEIGHT where id= imp_data.M_GENERATOR_ID_5;
      end if;

      if imp_data.M_GENERATOR_ID_6 is not null then
          update m_generator set MAKE_CODE = imp_data.GEN6_GEN_MAKE_CODE,NO_OF_UNITS= imp_data.GEN6_NO_OF_GEN_UNITS,CAPACITY = imp_data.GEN6_GEN_UNIT_CAPACITY,
            VOLTAGE_CODE =imp_data.GEN6_VOLTAGE_CODE,SERIAL_NO=imp_data.GEN6_TURBINE_SL_NO,ROTOR_DIA = imp_data.GEN6_TURBINE_ROTOR_DIA,
            HUB_HEIGHT =imp_data.GEN6_TURBINE_HUB_HEIGHT where id= imp_data.M_GENERATOR_ID_6;
      end if;

    end loop;


    commit;
    exception
	  when others then
	    v_exception_code := SQLCODE;
	    v_exception_msg := SUBSTR(SQLERRM, 1, 200);
	    v_result := 'FAILURE';
	    v_reason := v_exception_code || ' - ' || v_exception_msg;
      -- -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('FUNCTION','PROCESS_IMP_TECHNICAL_DATA','EXCEPTION',v_reason,'','', sysdate,V_REMARKS);
    END;

  v_log_result := log_activity('FUNCTION','PROCESS_IMP_TECHNICAL_DATA','END','Import complete','','', sysdate,V_REMARKS);

  return V_RESULT || ' - ' || v_reason;

END PROCESS_IMP_TECHNICAL_DATA;


/
--------------------------------------------------------
--  DDL for Function PROGRESS_REPORT_RR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."PROGRESS_REPORT_RR" 
(
  V_MONTH IN VARCHAR2,
  V_YEAR IN VARCHAR2,
  V_TYPE IN VARCHAR2 DEFAULT 'OVERALL',
  V_ORG_ID IN VARCHAR2,
  V_FUEL_TYPE_CODE IN VARCHAR2
) RETURN VARCHAR2 AS

--v_STMT_MONTH VARCHAR2;
--v_STMT_YEAR VARCHAR2;
v_total_import_gen_IS_CAPTIVE NUMBER;
v_TOTAL_EXPORT_GEN_IS_CAPTIVE NUMBER;
v_NET_GENERATION_IS_CAPTIVE NUMBER;
v_total_import_gen_STB NUMBER;
v_TOTAL_EXPORT_GEN_STB NUMBER;
v_NET_GENERATION_STB NUMBER;
v_total_import_gen_THIRD_PARTY NUMBER;
v_TOTAL_EXPORT_GEN_THIRD_PARTY NUMBER;
v_NET_GENERATION_THIRD_PARTY NUMBER;
v_BANKED_UNITS NUMBER;
v_FUEL_NAME VARCHAR2(20);
--v_TOTAL_IMPORT_GEN NUMBER;
--v_TOTAL_EXPORT_GEN NUMBER;
--v_NET_GENERATION NUMBER;
--v_FLOW_TYPE_CODE NUMBER;
--v_STMT_MONTH NUMBER;
--v_STMT_YEAR NUMBER;

v_total_services NUMBER;
v_total_statement NUMBER;
v_captive_statement NUMBER;
v_stb_statement NUMBER;
v_weg_third_statement NUMBER;
v_valid_captive NUMBER;

v_valid_third_party NUMBER;
v_valid_stb NUMBER;

v_invalid_captive NUMBER;
v_invalid_third_party NUMBER;
v_invalid_stb NUMBER;

v_total_invalid NUMBER;

v_allotment_created NUMBER;
v_allotment_completed NUMBER;
v_mtr_read_dwnld NUMBER;
v_manual_reading NUMBER;
v_progress_count NUMBER;

v_log_result varchar(300):='SUCCESS';
v_exception_code VARCHAR2(150);
v_exception_msg  VARCHAR2(150);
v_reason VARCHAR2(300);
o_result_desc VARCHAR2(300);
o_result_code VARCHAR2(300);



BEGIN
BEGIN
    v_log_result := log_activity('FUNCTION','PROGRESS_REPORT_RR','START',V_MONTH||'-'||V_YEAR,'','', sysdate,'');


  -----------------------------------------------------------------------------------------------------------------------  
    IF V_TYPE='OVERALL' AND V_ORG_ID IS NULL THEN


        SELECT COUNT(*) INTO v_total_services FROM m_company_service WHERE comp_ser_type_code='03' AND m_org_id in ('432','434','439','450','470','472','474','476','478') and FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_total_statement FROM t_gen_stmt WHERE STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_captive_statement FROM t_gen_stmt WHERE IS_CAPTIVE='Y' AND STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_stb_statement FROM t_gen_stmt WHERE IS_STB='Y' AND STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_weg_third_statement FROM t_gen_stmt WHERE FLOW_TYPE_CODE='THIRD-PARTY' AND STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_allotment_created FROM t_energy_sale WHERE STATUS_CODE='CREATED' AND MONTH=V_MONTH AND YEAR=V_YEAR and T_GEN_STMT_ID in (select id from t_gen_stmt where DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE);

        SELECT COUNT(*) INTO v_allotment_completed FROM t_energy_sale WHERE STATUS_CODE='APPROVED' AND MONTH=V_MONTH AND YEAR=V_YEAR and T_GEN_STMT_ID in (select id from t_gen_stmt where DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE);

        SELECT COUNT(*) INTO v_mtr_read_dwnld FROM t_meter_reading_hdr hd LEFT JOIN imp_mr_header hr on hr.id=hd.imp_batch_id left join t_gen_stmt gs on hd.M_GEN_STMT_ID=gs.id 
        where hd.reading_month=V_MONTH AND hd.reading_year=V_YEAR AND hr.mr_source_code='01' and gs.DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_manual_reading FROM t_meter_reading_hdr hd LEFT JOIN imp_mr_header hr on hr.id=hd.imp_batch_id left join t_gen_stmt gs on hd.M_GEN_STMT_ID=gs.id
        where hd.reading_month=V_MONTH AND hd.reading_year=V_YEAR AND hr.mr_source_code='02' and gs.DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE; 

        SELECT COUNT(*) INTO v_progress_count FROM PROGRESS_REPORT WHERE MONTH=V_MONTH AND YEAR=V_YEAR AND TYPE=V_TYPE and FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;


        SELECT COUNT(*) INTO v_valid_captive FROM v_company_service cs LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id WHERE  cs.flow_type_code= 'IS-CAPTIVE' AND ts.status='LIVE' and cs.FUEL_TYPE_CODE=V_FUEL_TYPE_CODE; 
        SELECT COUNT(*) INTO v_invalid_captive FROM v_company_service cs LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id WHERE cs.flow_type_code= 'IS-CAPTIVE' AND ts.status!='LIVE' and cs.FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_valid_third_party FROM v_company_service cs LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id WHERE cs.flow_type_code= 'THIRD-PARTY' AND ts.status='LIVE' and cs.FUEL_TYPE_CODE=V_FUEL_TYPE_CODE; 
        SELECT COUNT(*) INTO v_invalid_third_party FROM v_company_service cs LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id WHERE cs.flow_type_code= 'THIRD-PARTY' AND ts.status!='LIVE' and cs.FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        SELECT COUNT(*) INTO v_valid_stb FROM v_company_service cs LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id WHERE cs.flow_type_code= 'STB' AND ts.status='LIVE' and cs.FUEL_TYPE_CODE=V_FUEL_TYPE_CODE; 
        SELECT COUNT(*) INTO v_invalid_stb FROM v_company_service cs LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id WHERE cs.flow_type_code= 'STB' AND ts.status!='LIVE' and cs.FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;

        select COUNT(*) INTO v_total_invalid FROM m_powerplant WHERE status!='LIVE' and FUEL_TYPE_CODE=V_FUEL_TYPE_CODE; 

       select sum(TOTAL_IMPORT_GEN),sum(TOTAL_EXPORT_GEN),sum(NET_GENERATION) into v_total_import_gen_IS_CAPTIVE,v_TOTAL_EXPORT_GEN_IS_CAPTIVE,v_NET_GENERATION_IS_CAPTIVE  from t_gen_stmt where FLOW_TYPE_CODE= 'IS-CAPTIVE'and STMT_MONTH=V_MONTH and STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;
       select sum(TOTAL_IMPORT_GEN),sum(TOTAL_EXPORT_GEN),sum(NET_GENERATION) into v_total_import_gen_STB,v_TOTAL_EXPORT_GEN_STB,v_NET_GENERATION_STB from t_gen_stmt where FLOW_TYPE_CODE= 'STB' and STMT_MONTH=V_MONTH and STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;
       select sum(TOTAL_IMPORT_GEN),sum(TOTAL_EXPORT_GEN),sum(NET_GENERATION) into v_total_import_gen_THIRD_PARTY,v_TOTAL_EXPORT_GEN_THIRD_PARTY,v_NET_GENERATION_THIRD_PARTY from t_gen_stmt where FLOW_TYPE_CODE= 'THIRD-PARTY' and STMT_MONTH=V_MONTH and STMT_YEAR=V_YEAR and DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;


        select FUEL_NAME into v_FUEL_NAME from m_fuel where FUEL_CODE =V_FUEL_TYPE_CODE;

--       select round(sum(BANKED_BALANCE),2) into v_BANKED_UNITS from t_gen_stmt_slot where T_GEN_STMT_ID in (select id from t_gen_stmt where DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE);

       select to_char(sum(cast(regexp_replace(BANKED_BALANCE,'[^0-9]+','') as number))) into v_BANKED_UNITS from t_gen_stmt_slot where T_GEN_STMT_ID in (select id from t_gen_stmt where DISP_FUEL_TYPE_CODE=V_FUEL_TYPE_CODE and STMT_MONTH=V_MONTH and STMT_YEAR=V_YEAR);


        IF v_progress_count=0 THEN

        INSERT INTO PROGRESS_REPORT
        (ID,TOTAL_SERVICES,VALID_CAPTIVE_SERVICES,VALID_STB_SERVICES,VALID_WEG_THIRD_PARTY_SERVICES,TOTAL_INVALID_SERVICES,INVALID_CAPTIVE_SERVICES,INVALID_STB_SERVICES,
        INVALID_WEG_THIRD_PARTY_SERVICES,TOTAL_STATEMENTS,CAPTIVE_STATEMENTS,STB_STATEMENTS,WEG_THIRD_PARTY_STATEMENTS,ALLOTMENTS_CREATED,ALLOTMENTS_COMPLETED,METER_READINGS_DOWNLOADED,
        MANUAL_MR_READING,CREATED_DATE,MONTH,YEAR,TYPE,M_ORG_ID,TOTAL_IMPORT_IS_CAPTIVE,TOTAL_EXPORT_IS_CAPTIVE,NET_GENERATION_IS_CAPTIVE,TOTAL_IMPORT_STB,TOTAL_EXPORT_STB,NET_GENERATION_STB,
        TOTAL_IMPORT_THIRD_PARTY,TOTAL_EXPORT_THIRD_PARTY,NET_GENERATION_THIRD_PARTY,FUEL_TYPE_CODE,FUEL_TYPE_NAME,BANKED_UNITS) 
        VALUES (PROGRESS_REPORT_RR_SEQ.NEXTVAL, v_total_services ,v_valid_captive,v_valid_stb,v_valid_third_party,v_total_invalid,v_invalid_captive,v_invalid_stb,v_invalid_third_party, v_total_statement, v_captive_statement, v_stb_statement, v_weg_third_statement,
        v_allotment_created, v_allotment_completed, v_mtr_read_dwnld,v_manual_reading,sysdate,V_MONTH, V_YEAR, V_TYPE,V_ORG_ID,v_total_import_gen_IS_CAPTIVE,v_TOTAL_EXPORT_GEN_IS_CAPTIVE,v_NET_GENERATION_IS_CAPTIVE,
        v_total_import_gen_STB,v_TOTAL_EXPORT_GEN_STB,v_NET_GENERATION_STB,v_total_import_gen_THIRD_PARTY,v_TOTAL_EXPORT_GEN_THIRD_PARTY,v_NET_GENERATION_THIRD_PARTY,V_FUEL_TYPE_CODE,v_FUEL_NAME,v_BANKED_UNITS);

        ELSIF v_progress_count=1 THEN
        UPDATE PROGRESS_REPORT
        SET TOTAL_SERVICES=v_total_services, VALID_CAPTIVE_SERVICES=v_valid_captive, VALID_STB_SERVICES=v_valid_stb, VALID_WEG_THIRD_PARTY_SERVICES=v_valid_third_party, TOTAL_INVALID_SERVICES=v_total_invalid, INVALID_CAPTIVE_SERVICES=v_invalid_captive,
        INVALID_STB_SERVICES=v_invalid_stb, INVALID_WEG_THIRD_PARTY_SERVICES=v_invalid_third_party, TOTAL_STATEMENTS=v_total_statement, CAPTIVE_STATEMENTS=v_captive_statement, STB_STATEMENTS=v_stb_statement,
        WEG_THIRD_PARTY_STATEMENTS=v_weg_third_statement, ALLOTMENTS_CREATED=v_allotment_created,
        ALLOTMENTS_COMPLETED=v_allotment_completed, METER_READINGS_DOWNLOADED=v_mtr_read_dwnld, MANUAL_MR_READING=v_manual_reading,MODIFIED_DATE=SYSDATE, "MONTH"=V_MONTH, "YEAR"=V_YEAR, TYPE=V_TYPE,
         TOTAL_IMPORT_IS_CAPTIVE=v_total_import_gen_IS_CAPTIVE,TOTAL_EXPORT_IS_CAPTIVE=v_TOTAL_EXPORT_GEN_IS_CAPTIVE,
        NET_GENERATION_IS_CAPTIVE=v_NET_GENERATION_IS_CAPTIVE,TOTAL_IMPORT_STB=v_total_import_gen_STB,TOTAL_EXPORT_STB=v_TOTAL_EXPORT_GEN_STB,
        NET_GENERATION_STB=v_NET_GENERATION_STB,TOTAL_IMPORT_THIRD_PARTY=v_total_import_gen_THIRD_PARTY,TOTAL_EXPORT_THIRD_PARTY=v_TOTAL_EXPORT_GEN_THIRD_PARTY,
        NET_GENERATION_THIRD_PARTY=v_NET_GENERATION_THIRD_PARTY,FUEL_TYPE_CODE=V_FUEL_TYPE_CODE,FUEL_TYPE_NAME=v_FUEL_NAME,BANKED_UNITS=v_BANKED_UNITS
        WHERE "MONTH"=V_MONTH AND "YEAR"=V_YEAR AND TYPE=V_TYPE and FUEL_TYPE_CODE=V_FUEL_TYPE_CODE;
        END IF;
        COMMIT;

    END IF;    


    -----------------------------------------------------------------------------------------------------------------------
    IF V_TYPE='EDC' AND V_ORG_ID IS NOT NULL THEN

        SELECT COUNT(*) INTO v_total_services FROM m_company_service WHERE comp_ser_type_code='03' AND m_org_id = V_ORG_ID;
        SELECT COUNT(*) INTO v_total_statement FROM t_gen_stmt WHERE STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and M_ORG_ID=V_ORG_ID;
        SELECT COUNT(*) INTO v_captive_statement FROM t_gen_stmt WHERE IS_CAPTIVE='Y' AND STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and M_ORG_ID=V_ORG_ID;
        SELECT COUNT(*) INTO v_stb_statement FROM t_gen_stmt WHERE IS_STB='Y' AND  STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and M_ORG_ID=V_ORG_ID;          
        SELECT COUNT(*) INTO v_weg_third_statement FROM t_gen_stmt WHERE FLOW_TYPE_CODE='WEG-THIRD-PARTY' AND STMT_MONTH=V_MONTH AND STMT_YEAR=V_YEAR and M_ORG_ID=V_ORG_ID;
        SELECT COUNT(*) INTO v_allotment_created FROM t_energy_sale WHERE STATUS_CODE='CREATED' AND MONTH=V_MONTH AND YEAR=V_YEAR AND SELLER_END_ORG_ID=V_ORG_ID;
        SELECT COUNT(*) INTO v_allotment_completed FROM t_energy_sale WHERE STATUS_CODE='APPROVED' AND MONTH=V_MONTH AND YEAR=V_YEAR AND SELLER_END_ORG_ID=V_ORG_ID;        


        SELECT COUNT(*) INTO v_mtr_read_dwnld
        FROM t_meter_reading_hdr hd 
        LEFT JOIN imp_mr_header hr on hr.id=hd.imp_batch_id
        LEFT JOIN V_COMPANY_SERVICE s on hd.M_COMPANY_METER_ID=s.M_COMPANY_METER_ID
        where hd.reading_month=V_MONTH AND hd.reading_year=V_YEAR AND hr.mr_source_code='01' AND s.M_ORG_ID=V_ORG_ID;      

        SELECT COUNT(*) INTO v_manual_reading
        FROM t_meter_reading_hdr hd
        LEFT JOIN imp_mr_header hr on hr.id=hd.imp_batch_id
        LEFT JOIN V_COMPANY_SERVICE s on hd.M_COMPANY_METER_ID=s.M_COMPANY_METER_ID
        where hd.reading_month=V_MONTH AND hd.reading_year=V_YEAR AND hr.mr_source_code='02' and s.M_ORG_ID=V_ORG_ID; 

        SELECT COUNT(*) INTO v_progress_count FROM PROGRESS_REPORT WHERE MONTH=V_MONTH AND YEAR=V_YEAR AND TYPE=V_TYPE AND M_ORG_ID=V_ORG_ID;

        SELECT COUNT(*) INTO v_valid_captive
        FROM v_company_service cs
        LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id 
        WHERE  cs.flow_type_code= 'IS-CAPTIVE' AND ts.status='LIVE' and cs.M_ORG_ID=V_ORG_ID; 

        SELECT COUNT(*) INTO v_invalid_captive
        FROM v_company_service cs 
        LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id 
        WHERE cs.flow_type_code= 'IS-CAPTIVE' AND ts.status!='LIVE' and cs.M_ORG_ID=V_ORG_ID; 

        SELECT COUNT(*) INTO v_valid_third_party
        FROM v_company_service cs 
        LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id
        WHERE cs.flow_type_code= 'WEG-THIRD-PARTY' AND ts.status='LIVE' and cs.M_ORG_ID=V_ORG_ID; 


        SELECT COUNT(*) INTO v_invalid_third_party
        FROM v_company_service cs 
        LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id 
        WHERE cs.flow_type_code= 'WEG-THIRD-PARTY' AND ts.status!='LIVE' and cs.M_ORG_ID=V_ORG_ID; 



        SELECT COUNT(*) INTO v_valid_stb
        FROM v_company_service cs 
        LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id 
        WHERE cs.flow_type_code= 'STB' AND ts.status='LIVE' and cs.M_ORG_ID=V_ORG_ID;


        SELECT COUNT(*) INTO v_invalid_stb
        FROM v_company_service cs 
        LEFT JOIN m_powerplant ts on ts.M_SERVICE_ID = cs.id
        WHERE cs.flow_type_code= 'STB' AND ts.status!='LIVE' and cs.M_ORG_ID=V_ORG_ID;

        select COUNT(*) INTO v_total_invalid FROM m_powerplant WHERE status!='LIVE' and M_ORG_ID=V_ORG_ID;


        IF v_progress_count=0 THEN
        INSERT INTO PROGRESS_REPORT
        (ID,TOTAL_SERVICES,VALID_CAPTIVE_SERVICES,VALID_STB_SERVICES,VALID_WEG_THIRD_PARTY_SERVICES,TOTAL_INVALID_SERVICES,INVALID_CAPTIVE_SERVICES,INVALID_STB_SERVICES,
        INVALID_WEG_THIRD_PARTY_SERVICES,TOTAL_STATEMENTS,CAPTIVE_STATEMENTS,STB_STATEMENTS,WEG_THIRD_PARTY_STATEMENTS,ALLOTMENTS_CREATED,ALLOTMENTS_COMPLETED,METER_READINGS_DOWNLOADED,
        MANUAL_MR_READING,CREATED_DATE,MONTH,YEAR,TYPE) 
        VALUES (PROGRESS_REPORT_RR_SEQ.NEXTVAL, v_total_services ,v_valid_captive,v_valid_stb,v_valid_third_party,v_total_invalid,v_invalid_captive,v_invalid_stb,v_invalid_third_party, v_total_statement, v_captive_statement, v_stb_statement, v_weg_third_statement,
        v_allotment_created, v_allotment_completed, v_mtr_read_dwnld,v_manual_reading,sysdate,V_MONTH, V_YEAR,V_TYPE);

        ELSIF v_progress_count=1 THEN
        UPDATE PROGRESS_REPORT
        SET TOTAL_SERVICES=v_total_services, VALID_CAPTIVE_SERVICES=v_valid_captive, VALID_STB_SERVICES=v_valid_stb, VALID_WEG_THIRD_PARTY_SERVICES=v_valid_third_party, TOTAL_INVALID_SERVICES=v_total_invalid, INVALID_CAPTIVE_SERVICES=v_invalid_captive,
        INVALID_STB_SERVICES=v_invalid_stb, INVALID_WEG_THIRD_PARTY_SERVICES=v_invalid_third_party, TOTAL_STATEMENTS=v_total_statement, CAPTIVE_STATEMENTS=v_captive_statement, STB_STATEMENTS=v_stb_statement,
        WEG_THIRD_PARTY_STATEMENTS=v_weg_third_statement, ALLOTMENTS_CREATED=v_allotment_created,
        ALLOTMENTS_COMPLETED=v_allotment_completed, METER_READINGS_DOWNLOADED=v_mtr_read_dwnld, MANUAL_MR_READING=v_manual_reading,MODIFIED_DATE=SYSDATE, "MONTH"=V_MONTH, "YEAR"=V_YEAR, TYPE=V_TYPE, M_ORG_ID=V_ORG_ID
        WHERE "MONTH"=V_MONTH AND "YEAR"=V_YEAR AND TYPE=V_TYPE AND M_ORG_ID=V_ORG_ID;
        END IF;
        COMMIT;


    END IF;
   -----------------------------------------------------------------------------------------------------------------------
    exception
    when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        o_result_code := 'FAILURE';
        o_result_desc := v_exception_code || ' - ' || v_exception_msg;
        v_log_result := log_activity('FUNCTION','PROGRESS_REPORT_RR','EXCEPTION',o_result_desc,V_MONTH||'-'||V_YEAR,'', sysdate,'');
       END;
    COMMIT;
        v_log_result := log_activity('FUNCTION','PROGRESS_REPORT_RR','END',V_MONTH||'-'||V_YEAR,'','', sysdate,'');   


         RETURN 'SUCCESS';

END PROGRESS_REPORT_RR;


/
--------------------------------------------------------
--  DDL for Function RC_LISTBACKUPPIPE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."RC_LISTBACKUPPIPE" 
   RETURN rc_lbRecSet_t AUTHID DEFINER PIPELINED using rc_lbRecSetImpl_t;


/
--------------------------------------------------------
--  DDL for Function RC_LISTRSRANGEPIPE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."RC_LISTRSRANGEPIPE" (opCode IN varchar2)
   RETURN rc_RangeRecSet_t AUTHID DEFINER PIPELINED using rc_RangeRecSetImpl_t;


/
--------------------------------------------------------
--  DDL for Function REFRESH_UNALLOCATED_UNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."REFRESH_UNALLOCATED_UNITS" RETURN VARCHAR2 AS
v_result varchar(300):='SUCCESS';
v_reason VARCHAR2(300);
BEGIN
    FOR line IN (SELECT nvl(incr_ea1_src_id,INCR_EA1_remarks) es_id FROM t_EXS_banking_BALANCE WHERE
                    READING_YEAR='2020' AND READING_MONTH = '06')
            LOOP
            if (line.es_id is not null) then
                excess_units_source.update_excess_from_ea(line.es_id, V_RESULT , V_REASON);
            end if;
            END LOOP;
            COMMIT;
RETURN 'success';
END refresh_unallocated_units;

/
--------------------------------------------------------
--  DDL for Function R_DELETE_ALL_GS_ES_MR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."R_DELETE_ALL_GS_ES_MR" 
(
  V_SERVICE_NUMBER IN VARCHAR2 
) RETURN VARCHAR2 AS 
--@Author : Rini
--After this function successfully runs, DELETE_MASTER_WITH_SER_NUMBER can be run
v_process varchar2(50):='R_DELETE_ALL_GS_ES_MR';
v_process_type varchar2(50):='FUNCTION';
v_result_code  varchar2(50):='FAILURE';
v_result_desc  varchar2(300):='';
v_log_result   varchar2(300):='';
v_master_cursor sys_refcursor ;
--service_num varchar2(100);

v_gen_stmt_count varchar2(50);
v_mr_hdr_count varchar2(50); 

v_seller_company_service_id varchar2(50);
v_meter_id varchar2(50);
v_mr_hdr_id varchar2(50);
v_gen_stmt_id varchar2(50);
v_es_id varchar2(50);
v_es_order_id varchar2(50);
v_m_company_id varchar2(50);


v_gen_st_cursor sys_refcursor;
v_es_cursor sys_refcursor;
v_es_order_cursor sys_refcursor;
v_mr_hdr_cursor sys_refcursor;
BEGIN
BEGIN    
    v_log_result := log_activity(v_process_type,v_process,'Start','','','', '',V_SERVICE_NUMBER);

        SELECT ID,m_company_id INTO v_seller_company_service_id ,v_m_company_id FROM M_COMPANY_SERVICE WHERE "number"=V_SERVICE_NUMBER;
     ----Deletion of GS & ES starts here---  
select count(*) into  v_gen_stmt_count from t_gen_stmt where disp_service_number=V_SERVICE_NUMBER;

      IF(v_gen_stmt_count>0) THEN
      OPEN v_gen_st_cursor for select ID from t_gen_stmt where disp_service_number= V_SERVICE_NUMBER;
        LOOP 
        FETCH v_gen_st_cursor INTO v_gen_stmt_id;
--         v_log_result := log_activity(v_process_type,v_process,'DEL GS-gs-id',v_gen_stmt_id,'','', '',V_SERVICE_NUMBER);

        EXIT WHEN v_gen_st_cursor%NOTFOUND;
            OPEN v_es_cursor for select id from t_energy_sale where t_Gen_stmt_id =v_gen_stmt_id;
            LOOP 
            FETCH v_es_cursor INTO v_es_id;
            EXIT WHEN v_es_cursor%NOTFOUND;
--              v_log_result := log_activity(v_process_type,v_process,'DEL ES-es-id',v_es_id,'','', '',V_SERVICE_NUMBER);

            delete from T_ES_USAGE_SUMMARY where t_energy_sale_id = v_es_id;
            delete from t_es_charge where t_energy_sale_id = v_es_id;
               OPEN v_es_order_cursor for SELECT id from f_energy_sale_order where t_energy_sale_id =v_es_id;
                LOOP 
                FETCH v_es_order_cursor INTO v_es_order_id;
                EXIT WHEN v_es_order_cursor%NOTFOUND;
                delete  from f_energy_ledger where f_energy_sale_order_id =  v_es_order_id;
                delete from f_energy_sale_order_lines where f_energy_sale_order_id =  v_es_order_id;
                delete from f_energy_Charges where f_energy_sale_order_id =  v_es_order_id;
                END LOOP;
             delete from f_energy_sale_order where t_energy_sale_id =v_es_id;
            END LOOP;
            delete from t_energy_sale where t_Gen_stmt_id =v_gen_stmt_id;
            delete from T_GEN_STMT_CHARGE where t_gen_stmt_id =v_gen_stmt_id;
            delete from t_gen_stmt_slot where t_gen_stmt_id =v_gen_stmt_id;  


        END LOOP;
        delete from t_gen_stmt where disp_service_number=V_SERVICE_NUMBER;
          v_log_result := log_activity(v_process_type,v_process,'GS-DELETION','GS DELETED','SUCCESS','', '',V_SERVICE_NUMBER);
        ELSE
        v_log_result := log_activity(v_process_type,v_process,'GS-check','GS DOES NOT EXIST','','', '',V_SERVICE_NUMBER);

    END IF;    

        ----GS & ES have been deleted---

        select id into v_meter_id from m_company_meter where m_company_service_id=v_seller_company_service_id;
        ------METER READING HEADER AND METER READING SLOT DATA STARTS--
       select count(*) into  v_mr_hdr_count from t_meter_reading_hdr where  m_company_meter_id=v_meter_id;
      IF(v_mr_hdr_count>0) THEN
         OPEN v_mr_hdr_cursor for  select id from t_meter_reading_hdr where  m_company_meter_id=v_meter_id;
            LOOP 
            FETCH v_mr_hdr_cursor INTO v_mr_hdr_id;
            EXIT WHEN v_mr_hdr_cursor%NOTFOUND;
             delete From t_meter_reading_slot where T_METER_READING_HDR_ID = v_mr_hdr_id;
            END LOOP;
            delete from t_meter_reading_hdr where  m_company_meter_id=v_meter_id;
               v_log_result := log_activity(v_process_type,v_process,'MR_DELETION','MR DELETED','SUCCESS','', '',V_SERVICE_NUMBER);
            ELSE
        v_log_result := log_activity(v_process_type,v_process,'MR_HDR_CHECK','MR DOES NOT EXIST','','', '',V_SERVICE_NUMBER);

    END IF;        
            ------METER READING HEADER AND METER READING SLOT DATA DELETED--

          delete From t_banking_balance where m_company_id=v_m_company_id;
          delete from t_new_service_excess_banking where m_Company_id=v_m_company_id;


    COMMIT;
    v_result_code :='SUCCESS';
    v_result_desc := '';

    v_log_result := log_activity(v_process_type,v_process,'Complete','calling service refresh',v_result_code,'', '',V_SERVICE_NUMBER);

    view_refresh.COMP_SERV_REFRESH(V_SERVICE_NUMBER,v_result_code, v_result_desc);


exception
  when others then
    v_result_code := 'FAILURE';
    v_result_desc := SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
    v_log_result := log_activity(v_process_type,v_process,'EH','Exception - '||v_result_desc,v_result_code,v_result_desc, sysdate,V_SERVICE_NUMBER);
END;
<<THE_END>>
    v_log_result := log_activity(v_process_type,v_process,'End',v_result_desc,v_result_code,'', '',V_SERVICE_NUMBER);
  RETURN 'success';
END R_DELETE_ALL_GS_ES_MR;

/
--------------------------------------------------------
--  DDL for Function SERVICE_RECONCILIATION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."SERVICE_RECONCILIATION" 
(
  v_month in varchar,
  v_year in varchar
) RETURN VARCHAR2 AS
v_unresolved_count number;
v_flow_type_code varchar2(50);
v_esi_status_code varchar2(50);
v_signup_count number:=0;
v_signup_tr_count number:=0;
--v_created_Date DATE := SYSDATE;
v_created_By  varchar2(50):= 'admin';
v_status varchar2(50);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result varchar(300):='SUCCESS';
v_log_result varchar(300):='SUCCESS';
v_signup_import_result varchar(300):='SUCCESS';
v_imported BOOLEAN;
v_service_duplicated BOOLEAN :=false;
v_signup M_SIGNUP%ROWTYPE;
v_conversion number:=0.001;

BEGIN
-- begin for exception handling
BEGIN

   v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','START','Start','','', sysdate);

   update IMPORT_SELLERS_RECONCILIATION set
   "s_in_signup"= null,    "signup_id"= null,"s_in_comp_serv"= null,"m_comp_serv_id"= null,"s_in_t_mr"= null,"t_mr_id"= null,
   "s_in_imp_mr"= null, "s_in_amr"= null, "sm_in_signup"= null, "sm_in_comp_meter"= null, "sm_in_t_mr"= null, "sm_in_imp_mr"= null, "sm_in_amr"= null,"id"=null ;

   update IMPORT_SELLERS_RECONCILIATION set "id" = rownum ;

   v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','INIT','Init Complete','','', sysdate);
  commit;

    FOR i IN (select generator_service_no_new, count(generator_service_no_new) count1 from IMPORT_SELLERS_RECONCILIATION
            group by generator_service_no_new
            having count(generator_service_no_new) > 1
            )
    LOOP
     v_service_duplicated:= true;
     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Duplicate Service',i.generator_service_no_new||'-'||i.count1,'', sysdate);
    end loop;

    if(v_service_duplicated) then
      v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Duplicate Services found. please fix them or remove duplicacy and try again','','', sysdate);
      V_RESULT := 'FAILURE';
      v_reason := 'Duplicate Services found. please fix them or remove duplicacy and try again';
      GOTO THE_END;
   else
      v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Duplicate check complete','','', sysdate);
    end if;

   /* check if the service-no is in oa's signup table and update reconciliation
    */
    update IMPORT_SELLERS_RECONCILIATION r set ("s_in_signup","signup_id"  ) = (select distinct 'Y', s.id from m_signup s where s.HTSC_NUMBER = r.GENERATOR_SERVICE_NO_NEW  );
    update IMPORT_SELLERS_RECONCILIATION set "s_in_signup" = 'N' where "s_in_signup" is null;

    v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Checked Service in oa signup table','','', sysdate);

     /* check if the service-no is in oa's comp_serv table and update reconciliation
    */
    update IMPORT_SELLERS_RECONCILIATION r set ("s_in_comp_serv","m_comp_serv_id"  ) = (select distinct 'Y', s.id from M_COMPANY_SERVICE s where s."number" = r.GENERATOR_SERVICE_NO_NEW );
    update IMPORT_SELLERS_RECONCILIATION set "s_in_comp_serv" = 'N' where "s_in_comp_serv" is null;

    v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Checked Service in oa service table','','', sysdate);

     /* check if the meter-reading exists for the service in oa and update reconciliation
    */
     update IMPORT_SELLERS_RECONCILIATION r set ("s_in_t_mr","t_mr_id"  ) = (select distinct  'Y', s.M_COMPANY_METER_ID from v_company_service s  join T_METER_READING_HDR m on m.M_COMPANY_METER_ID = s.M_COMPANY_METER_ID where s."number"=r.GENERATOR_SERVICE_NO_NEW);
     update IMPORT_SELLERS_RECONCILIATION set "s_in_t_mr" = 'N' where "s_in_t_mr" is null;

     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Checked Service in oa meter reading table','','', sysdate);


     /* check if the gen-stmt exists for the service in oa and update reconciliation
    */
     update IMPORT_SELLERS_RECONCILIATION r set ("S_IN_T_GS","T_GS_ID"  ) = (select distinct  'Y', s.M_COMPANY_METER_ID from v_company_service s  join T_gen_stmt m on m.M_COMPANY_METER_ID = s.M_COMPANY_METER_ID where s."number"=r.GENERATOR_SERVICE_NO_NEW);
     update IMPORT_SELLERS_RECONCILIATION set "S_IN_T_GS" = 'N' where "S_IN_T_GS" is null;

     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','now checking Service in oa mr-staging table','','', sysdate);

    /* check if the meter-reading exists for the service in oa's mr-staging table and update reconciliation
    */
     update IMPORT_SELLERS_RECONCILIATION r set ("s_in_imp_mr"   ) = (select distinct  'Y'  from imp_mr_lines i   where i.service_no =r.GENERATOR_SERVICE_NO_NEW );
     update IMPORT_SELLERS_RECONCILIATION set "s_in_imp_mr" = 'N' where "s_in_imp_mr" is null;

     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Services matched with all oa tables. now checking in amr','','', sysdate);

    /* check if the meter-reading exists for the service in amr and update reconciliation
    */
    update IMPORT_SELLERS_RECONCILIATION r set ("s_in_amr"  ) = (select distinct  'Y'  from uv_tbl_history_slot a where a.serviceno = r.GENERATOR_SERVICE_NO_NEW );
    update IMPORT_SELLERS_RECONCILIATION set "s_in_amr" = 'N' where "s_in_amr" is null;

    v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Services matched in amr. now matching service-meterno','','', sysdate);

    /* check if the service+meterno combination exists in the oa's  signup and update reconciliation
    */
    update IMPORT_SELLERS_RECONCILIATION r set ("sm_in_signup"  ) = (select distinct  'Y'  from m_signup s where s.HTSC_NUMBER = r.GENERATOR_SERVICE_NO_NEW and s.METER_NUMBER= r.METER_NUMBER);
    update IMPORT_SELLERS_RECONCILIATION set "sm_in_signup" = 'N' where "sm_in_signup" is null;

     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Checked ServiceMeter in oa signup table','','', sysdate);

    /* check if the service+meterno combination exists in the oa's  comp serv and update reconciliation
    */
    update IMPORT_SELLERS_RECONCILIATION r set ("sm_in_comp_meter"  ) = (select distinct  'Y'  from v_company_service s where s."number" = r.GENERATOR_SERVICE_NO_NEW and s.METER_NUMBER= r.METER_NUMBER );
    update IMPORT_SELLERS_RECONCILIATION set "sm_in_comp_meter" = 'N' where "sm_in_comp_meter" is null;

      v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','Checked ServiceMeter in oa service table','','', sysdate);
    /* check if the meter-reading exists for the service+meterno combination in oa  and update reconciliation
    */
     update IMPORT_SELLERS_RECONCILIATION r set ("sm_in_t_mr" ) = (select  distinct  'Y' from v_company_service s  join T_METER_READING_HDR m on m.M_COMPANY_METER_ID = s.M_COMPANY_METER_ID where s."number"=r.GENERATOR_SERVICE_NO_NEW and s.METER_NUMBER= r.METER_NUMBER  );
     update IMPORT_SELLERS_RECONCILIATION set "sm_in_t_mr" = 'N' where "sm_in_t_mr" is null;

     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','now checking ServiceMeter in oa mr-staging table','','', sysdate);

     /* check if the meter-reading exists for the service in oa's mr-staging table and update reconciliation
    */
     update IMPORT_SELLERS_RECONCILIATION r set ("sm_in_imp_mr"   ) = (select distinct  'Y'  from imp_mr_lines i   where i.service_no =r.GENERATOR_SERVICE_NO_NEW and  i.meter_no = r.METER_NUMBER );
     update IMPORT_SELLERS_RECONCILIATION set "sm_in_imp_mr" = 'N' where "sm_in_imp_mr" is null;

     v_log_result := log_activity('PROCEDURE','IMPORT_SELLERS_RECONCILIATION','PROCESS','ServiceMeter matched with all oa tables. now checking in amr','','', sysdate);

    /* check if the meter-reading exists for the service in amr and update reconciliation
    */
    update IMPORT_SELLERS_RECONCILIATION r set ("s_in_amr"  ) = (select  distinct 'Y'  from uv_tbl_history_slot a where a.serviceno = r.GENERATOR_SERVICE_NO_NEW and  a.meterno = r.METER_NUMBER );
    update IMPORT_SELLERS_RECONCILIATION set "s_in_amr" = 'N' where "s_in_amr" is null;

     v_log_result := log_activity('PROCEDURE','service_reconciliation','PROCESS','reconciliation complete. now checking mismatched services for each month','','', sysdate);

    -- run mismatch finding functions for each month
     v_log_result := FIND_MISSING_MRS(v_month,v_year);
     -- v_log_result := FIND_MISSING_MRS('05','2018');
     -- v_log_result := FIND_MISSING_MRS('06','2018');
     --v_log_result := FIND_MISSING_MRS('07','2018');
     --v_log_result := FIND_MISSING_MRS('08','2018');

    v_log_result := log_activity('PROCEDURE','service_reconciliation','END','process complete','','', sysdate);

exception
      when others then
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_reason := v_exception_code || ' - ' || v_exception_msg;
      -- -- dbms_output.put_line(v_reason);
        v_log_result := log_activity('PROCEDURE','service_reconciliation','EXCEPTION',v_reason,'','', sysdate);
END;
<<THE_END>>
commit;
return V_RESULT || ' - ' || v_reason;

END service_reconciliation;


/
--------------------------------------------------------
--  DDL for Function STB_PMT_CALC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."STB_PMT_CALC" 
(V_GS_ID VARCHAR2) RETURN VARCHAR2
AS

    V_RESULT VARCHAR(300):='SUCCESS';
    V_EXCEPTION_CODE VARCHAR2(150);
    V_EXCEPTION_MSG  VARCHAR2(150);
    V_REASON VARCHAR2(200);
    V_GS T_GEN_STMT%ROWTYPE;
    V_DOC VARCHAR2(150);
    V_DATE DATE;
    V_COMP_SERV VARCHAR2(150);
    V_STB_PMT NUMBER;


BEGIN
   BEGIN
     SELECT TO_DATE(CONCAT(STMT_YEAR,(CONCAT(CONCAT('-',STMT_MONTH),'-01'))),'YYYY-MM-DD'),M_COMPANY_SERVICE_ID INTO V_DATE,V_COMP_SERV
     FROM T_GEN_STMT WHERE ID=V_GS_ID;
-- dbms_output.put_line('V_COMP_SERV----'||V_COMP_SERV || '---DATE---' || V_DATE);

    SELECT COMMISSION_DATE INTO V_DOC FROM M_POWERPLANT WHERE M_SERVICE_ID = V_COMP_SERV;
     -- dbms_output.put_line('COMMISSION_DATE----'||V_DOC);

--     SELECT COUNT(*) INTO V_PERIOD1  FROM DUAL WHERE V_DOC < '2006-05-15';
     IF V_DOC < TO_DATE('2006-05-15','YYYY-MM-DD') THEN
        V_STB_PMT := '2.75';
     ELSIF V_DOC > TO_DATE('2006-05-15','YYYY-MM-DD')AND  V_DOC < TO_DATE('2009-03-19' ,'YYYY-MM-DD')THEN
      V_STB_PMT := '2.90';
     ELSIF V_DOC > TO_DATE('2009-03-20','YYYY-MM-DD')  AND  V_DOC < TO_DATE('2009-03-31','YYYY-MM-DD')  THEN
      V_STB_PMT := '3.24';
     ELSIF V_DOC > TO_DATE('2009-04-01','YYYY-MM-DD')  AND  V_DOC <  TO_DATE('2012-07-31','YYYY-MM-DD')  THEN
      V_STB_PMT := '3.39';
     ELSIF V_DOC > TO_DATE('2012-08-01','YYYY-MM-DD') AND  V_DOC < TO_DATE('2016-03-31','YYYY-MM-DD')  THEN
      V_STB_PMT := '3.51';
     ELSIF V_DOC > TO_DATE('2016-04-01','YYYY-MM-DD')  THEN
      V_STB_PMT := '3.70';
     END IF;
  -- dbms_output.put_line('V_STB_PMT----'||V_STB_PMT);

      EXCEPTION
              WHEN OTHERS THEN
                V_EXCEPTION_CODE := SQLCODE;
                V_EXCEPTION_MSG  := SUBSTR(SQLERRM, 1, 100);
                V_RESULT := 'FAILURE' || ' - ' || V_EXCEPTION_CODE || ' - ' || V_EXCEPTION_MSG;
                -- dbms_output.put_line('ISSUE IN STB_PMT_CALC-'||V_RESULT);

 END;
 <<THE_END>>
IF V_RESULT = 'SUCCESS' THEN
  COMMIT;
ELSE
  v_result := v_result || ' - ' || v_reason;
END IF;
RETURN V_STB_PMT;
END STB_PMT_CALC;



/
--------------------------------------------------------
--  DDL for Function SURPLUS_ENERGY_LOSS_CALC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."SURPLUS_ENERGY_LOSS_CALC" 
(INJECTION_CODE IN VARCHAR2,
DRAWAL_CODE IN  VARCHAR2,
DRAWAL_UNITS IN VARCHAR2,

TRANS_LOSS OUT NUMBER,DIST_LOSS OUT NUMBER,
TOTAL_LOSS OUT NUMBER,INJECTED_UNITS OUT NUMBER)
RETURN VARCHAR2
IS
    V_LOSS_CALCULATION M_LOSS_CALC_CHART%ROWTYPE;
    V_REASON VARCHAR2(200);
    V_RESULT VARCHAR(300):='SUCCESS';
    V_EXCEPTION_CODE VARCHAR2(150);
    V_EXCEPTION_MSG  VARCHAR2(150);
INJECTED_UNITS_LOSS VARCHAR2(150);
GROSSED_UP_UNITS VARCHAR2(150);
BEGIN
   BEGIN

SELECT * INTO V_LOSS_CALCULATION FROM M_LOSS_CALC_CHART WHERE INJECTION_VOLTAGE_CODE=INJECTION_CODE AND DRAWAL_VOLTAGE_CODE=DRAWAL_CODE ;

--        TRANS_LOSS := V_LOSS_CALCULATION.TRANS_LOSS_PERCENT*DRAWAL_UNITS;
--        TRANS_LOSS :=TO_BINARY_FLOAT(TRANS_LOSS)/100;

--        DIST_LOSS := V_LOSS_CALCULATION.DIST_LOSS_PERCENT*DRAWAL_UNITS;
--        DIST_LOSS :=TO_BINARY_FLOAT(DIST_LOSS)/100;


        TOTAL_LOSS :=V_LOSS_CALCULATION.TRANS_LOSS_PERCENT+V_LOSS_CALCULATION.DIST_LOSS_PERCENT;
        GROSSED_UP_UNITS := DRAWAL_UNITS / ((100 - TOTAL_LOSS)/100);

        INJECTED_UNITS := GROSSED_UP_UNITS - (GROSSED_UP_UNITS * (14/100));

      EXCEPTION
              WHEN OTHERS THEN
                V_EXCEPTION_CODE := SQLCODE;
                V_EXCEPTION_MSG  := SUBSTR(SQLERRM, 1, 100);
                V_RESULT := 'FAILURE' || ' - ' || V_EXCEPTION_CODE || ' - ' || V_EXCEPTION_MSG;
 END;
 <<THE_END>>
IF V_RESULT = 'SUCCESS' THEN
  COMMIT;
ELSE
  v_result := v_result || ' - ' || v_reason;
END IF;
RETURN TOTAL_LOSS;
END ;


/
--------------------------------------------------------
--  DDL for Function TEMP_BANKING_SOLUTION_FUNC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TEMP_BANKING_SOLUTION_FUNC" 
(v_remarks in varchar2,
v_month IN VARCHAR2,
v_year in varchar2) RETURN VARCHAR2 AS

v_service_no varchar2(50);
v_comp_id varchar2(50);
v_bb_serv_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
v_curr_c1 varchar2(50);
v_curr_c2 varchar2(50);
v_curr_c3 varchar2(50);
v_curr_c4 varchar2(50);
v_curr_c5 varchar2(50);
v_new_c1 number;
v_new_c2 number;
v_new_c3 number;
v_new_c4 number;
v_new_c5 number;
v_created_by varchar2(100):='admin';
v_up_new_c1 varchar2(50);
v_up_new_c2 varchar2(50);
v_up_new_c3 varchar2(50);
v_up_new_c4 varchar2(50);
v_up_new_c5 varchar2(50);
v_total number;

BEGIN

    FOR bb in (select * from TEMP_BANKING_SOLUTION where REMARKS=v_remarks and MONTH=v_month AND YEAR=v_year)
    LOOP
    select "number",M_COMPANY_ID,BANKING_SERVICE_ID into v_service_no,v_comp_id,v_bb_serv_id from m_company_service where "number"=bb.SERVICE_NO;

    update TEMP_BANKING_SOLUTION set M_COMPANY_ID=v_comp_id,BANKING_SERVICE_ID=v_bb_serv_id where SERVICE_NO=v_service_no and MONTH=v_month AND YEAR=v_year;

    select C1,C2,C3,C4,C5 into v_c1,v_c2,v_c3,v_c4,v_c5 from TEMP_BANKING_SOLUTION where REMARKS=v_remarks and MONTH=v_month AND YEAR=v_year AND SERVICE_NO=v_service_no;

    select CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5 into v_curr_c1,v_curr_c2,v_curr_c3,v_curr_c4,v_curr_c5 from T_BANKING_BALANCE where M_COMPANY_ID=v_comp_id 
            and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;

            --------validation and updation for newc1 in TEMP_BANKING_SOLUTION starts here-------------------------
            if(v_curr_c1) > 0 then
            v_new_c1 := v_curr_c1-v_c1;
            update TEMP_BANKING_SOLUTION set NEW_C1=to_char(v_new_c1),C1_REMARKS='C1-Success',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            elsif(v_curr_c1='0') or (v_curr_c1 is null) then
            v_new_c1 := v_curr_c1-v_c1;
            update TEMP_BANKING_SOLUTION set NEW_C1=v_new_c1,C1_REMARKS='curr_c1 is 0 or null',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_curr_c2) > 0 then
            v_new_c2 := v_curr_c2-v_c2;
            update TEMP_BANKING_SOLUTION set NEW_C2=to_char(v_new_c2),C2_REMARKS='C2-Success',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            elsif(v_curr_c2 ='0')  or (v_curr_c2 is null) then
            v_new_c2 := v_curr_c2-v_c2;
            update TEMP_BANKING_SOLUTION set NEW_C2=v_new_c2,C2_REMARKS='curr_c2 is 0 or null',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_curr_c3) > 0 then
            v_new_c3 := v_curr_c3-v_c3;
            update TEMP_BANKING_SOLUTION set NEW_C3=to_char(v_new_c3),C3_REMARKS='C3-Success',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            elsif(v_curr_c3 ='0') or (v_curr_c3 is null) then
            v_new_c3 := v_curr_c3-v_c3;
            update TEMP_BANKING_SOLUTION set NEW_C3=v_new_c3,C3_REMARKS='curr_c3 is 0 or null',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_curr_c4) > 0 then
            v_new_c4 := v_curr_c4-v_c4;
            update TEMP_BANKING_SOLUTION set NEW_C4=to_char(v_new_c4),C4_REMARKS='C4-Success',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            elsif(v_curr_c4 ='0') or (v_curr_c4 is null) then
            v_new_c4 := v_curr_c4-v_c4;
            update TEMP_BANKING_SOLUTION set NEW_C4=v_new_c4,C4_REMARKS='curr_c4 is 0 or null',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_curr_c5) > 0 then
            v_new_c5 := v_curr_c5-v_c5;
            update TEMP_BANKING_SOLUTION set NEW_C5=to_char(v_new_c5),C5_REMARKS='C5-Success',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            elsif(v_curr_c5 ='0') or (v_curr_c5 is null) then
            v_new_c5 := v_curr_c5-v_c5;
            update TEMP_BANKING_SOLUTION set NEW_C5=v_new_c5,C5_REMARKS='curr_c5 is 0 or null',CREATED_DATE=sysdate,CREATED_BY=v_created_by where M_COMPANY_ID=v_comp_id and MONTH=v_month AND YEAR=v_year;
            end if;
            --------validation and updation for newc1 in TEMP_BANKING_SOLUTION ends here-------------------------

            select NEW_C1,NEW_C2,NEW_C3,NEW_C4,NEW_C5 into v_up_new_c1,v_up_new_c2,v_up_new_c3,v_up_new_c4,v_up_new_c5 from TEMP_BANKING_SOLUTION where REMARKS=v_remarks and MONTH=v_month AND YEAR=v_year AND SERVICE_NO=v_service_no;
            -- dbms_output.put_line('  v_up_new_c1  - '||  v_up_new_c1 );

            ---updation in banking balance starts---------------------
            if(v_up_new_c1)>=0 then
            update T_BANKING_BALANCE set CURR_C1=v_up_new_c1 where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            else
            update T_BANKING_BALANCE set CURR_C1=decode(sign(v_up_new_c1),-1,0,v_up_new_c1) where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_up_new_c2)>=0 then
            update T_BANKING_BALANCE set CURR_C2=v_up_new_c2 where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            else
            update T_BANKING_BALANCE set CURR_C2=decode(sign(v_up_new_c2),-1,0,v_up_new_c2) where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_up_new_c3)>=0 then
            update T_BANKING_BALANCE set CURR_C3=v_up_new_c3 where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            else
            update T_BANKING_BALANCE set CURR_C3=decode(sign(v_up_new_c3),-1,0,v_up_new_c3) where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_up_new_c4)>=0 then
            update T_BANKING_BALANCE set CURR_C4=v_up_new_c4 where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            else
            update T_BANKING_BALANCE set CURR_C4=decode(sign(v_up_new_c4),-1,0,v_up_new_c4) where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            end if;

            if(v_up_new_c5)>=0 then
            update T_BANKING_BALANCE set CURR_C5=v_up_new_c5 where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            else
            update T_BANKING_BALANCE set CURR_C5=decode(sign(v_up_new_c5),-1,0,v_up_new_c5) where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            end if;

            v_total:=(v_up_new_c1+v_up_new_c2+v_up_new_c3+v_up_new_c4+v_up_new_c5);
            -- dbms_output.put_line('  v_total  - '||  v_total );

            if (v_total)>=0 then
            update T_BANKING_BALANCE set REMARKS='Alloted units 0 so remaining excess banking in current month'||to_char(decode(sign(v_new_c1),1,0,v_new_c1)+decode(sign(v_new_c2),1,0,v_new_c2)+decode(sign(v_new_c3),1,0,v_new_c3)+decode(sign(v_new_c4),1,0,v_new_c4)+decode(sign(v_new_c5),1,0,v_new_c5)) 
            where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            else 
            update T_BANKING_BALANCE set REMARKS='added_negative_charges'||to_char(decode(sign(v_new_c1),1,0,v_new_c1)+decode(sign(v_new_c2),1,0,v_new_c2)+decode(sign(v_new_c3),1,0,v_new_c3)+decode(sign(v_new_c4),1,0,v_new_c4)+decode(sign(v_new_c5),1,0,v_new_c5))
            where M_COMPANY_ID=v_comp_id and BANKING_SERVICE_ID=v_bb_serv_id and MONTH=v_month AND YEAR=v_year;
            end if;
            ---updation in banking balance ends here---------------------

    END LOOP;
    commit;

    RETURN 'success';
END TEMP_BANKING_SOLUTION_FUNC;


/
--------------------------------------------------------
--  DDL for Function TEMP_CLEAR_ES_FOR_BK_FIX
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TEMP_CLEAR_ES_FOR_BK_FIX" 
(
  I_MONTH IN VARCHAR2 
, I_YEAR IN VARCHAR2 
) RETURN VARCHAR2 AS 

v_number varchar2(50);
v_service_count number;
o_res_code varchar2(50);
o_res_desc varchar2(200);

BEGIN

  for s in(select * FROM T_ENERGY_SALE WHERE MONTH='05' and  BC1+BC2+BC3+BC4+BC5>0)
  loop
    select count(*) into v_service_count from m_company_service where id=s.seller_comp_serv_id;
    if v_service_count=0 then
    select "number" into v_number from m_company_service where id=s.seller_comp_serv_id;
    DELETE_TXN.DELETE_BY_SERVICE('BANKING-ISSUEFIX-240619',v_number,I_MONTH,I_YEAR,'Y','N','N','N',o_res_code,o_res_desc);
    update T_ENERGY_SALE set PROCESS_REMARKS='MANUAL-BANKING-UPDATE-240619' WHERE SELLER_COMP_SERV_ID=s.seller_comp_serv_id AND MONTH=I_MONTH AND YEAR=I_YEAR;
    end if;
  end loop;
  RETURN NULL;
END TEMP_CLEAR_ES_FOR_BK_FIX;


/
--------------------------------------------------------
--  DDL for Function TEMP_FIX_FOR_BK_ES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TEMP_FIX_FOR_BK_ES" 
(
  I_SERVICE_NUMBER IN VARCHAR2

) RETURN VARCHAR2 AS 
v_company_servicess V_COMPANY_SERVICE%ROWTYPE;
v_banking_count number:=0;
v_created_Date DATE := SYSDATE;
o_result_code VARCHAR2(100);
o_result_desc VARCHAR2(100);
v_es_id VARCHAR2(100);
v_es_count number:=0;
v_c1 VARCHAR2(100);v_c2 VARCHAR2(100);
v_c3 VARCHAR2(100);v_c4 VARCHAR2(100);
v_c5 VARCHAR2(100);

BEGIN
SELECT * INTO v_company_servicess FROM V_COMPANY_SERVICE WHERE "number"=I_SERVICE_NUMBER;
SELECT COUNT(*) INTO v_banking_count FROM T_BANKING_BALANCE WHERE M_COMPANY_ID=v_company_servicess.M_COMPANY_ID AND MONTH='03';
IF v_banking_count=1 THEN 
DELETE FROM T_BANKING_BALANCE WHERE M_COMPANY_ID=v_company_servicess.M_COMPANY_ID AND MONTH='03';
SELECT C1,C2,C3,C4,C5 INTO v_c1,v_c2,v_c3,v_c4,v_c5 FROM T_BANKING_BALANCE WHERE M_COMPANY_ID=v_company_servicess.M_COMPANY_ID AND MONTH='02';
UPDATE T_BANKING_BALANCE SET curr_c1=v_c1,curr_c2=v_c2,curr_c3=v_c3,curr_c4=v_c4,curr_c5=v_c5 WHERE M_COMPANY_ID=v_company_servicess.M_COMPANY_ID AND MONTH='02';
DELETE_TXN.DELETE_BY_SERVICE('TEMP_FIX_FOR_BK_ES'||v_created_Date,I_SERVICE_NUMBER,'03','2019','Y','Y','Y','N',o_result_code,o_result_desc);
SELECT count(*) INTO v_es_count FROM T_ENERGY_SALE WHERE SELLER_COMP_SERV_ID=v_company_servicess.ID AND MONTH='02';

IF v_es_count=1 THEN
SELECT ID INTO v_es_id FROM T_ENERGY_SALE WHERE SELLER_COMP_SERV_ID=v_company_servicess.ID AND MONTH='02';
BANKING_BALANCE.confirm_energy_sale_event(v_es_id,o_result_code,o_result_desc);
END IF;
END IF;
RETURN 'SUCCESS';
END TEMP_FIX_FOR_BK_ES;


/
--------------------------------------------------------
--  DDL for Function TEMP_GAND
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TEMP_GAND" RETURN VARCHAR2 AS 
    V_TRADE_REL_COUNT VARCHAR2(150);
v_create_stb_result varchar2(50);
    v_log_result varchar(300):='SUCCESS';

BEGIN
         v_log_result := log_activity('PROCEDURE','TEMP_GAND','Start','','','', sysdate,'', '', '');

 for new_mr in (select mh.id,mh.INIT_READING_DT, mh.M_GEN_STMT_ID, meter.M_COMPANY_SERVICE_ID from t_meter_reading_hdr mh LEFT JOIN M_COMPANY_METER meter on mh.M_COMPANY_METER_ID = meter.id  where mh.gs_batch_id IN ('11172','11167'))
    loop
      v_log_result := log_activity('PROCEDURE','TEMP_GAND','LOOP','','','', sysdate,'', '', '');
      SELECT COUNT(*) INTO V_TRADE_REL_COUNT FROM M_TRADE_RELATIONSHIP TRADE WHERE M_SELLER_COMP_SERVICE_ID = new_mr.M_COMPANY_SERVICE_ID AND M_BUYER_COMPANY_ID = 'TNEB' AND new_mr.INIT_READING_DT BETWEEN TRADE.FROM_DATE AND TRADE.TO_DATE;
           v_log_result := log_activity('PROCEDURE','V_TRADE_REL_COUNT',V_TRADE_REL_COUNT,'','','', sysdate,'', '', '');
      IF V_TRADE_REL_COUNT>0 THEN
        v_create_stb_result := CREATE_STB(new_mr.M_GEN_STMT_ID);
      END IF;
    end loop;
  RETURN NULL;
END TEMP_GAND;


/
--------------------------------------------------------
--  DDL for Function TEMP_SETUP_EXCESS_BAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TEMP_SETUP_EXCESS_BAL" 
 RETURN VARCHAR2 AS 
v_cursor sys_refcursor ;
v_number varchar2(50);
o_res_code varchar2(100);
o_res_desc varchar2(200);
    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
o_result_code varchar2(100);
o_result_desc varchar2(200);

BEGIN
  BEGIN

	--insert from banking_src
	for banking_src in (select id from T_EXS_BANKING_BALANCE_SRC_29_JUN where IMPORT_RESULT<>'Y' )
	LOOP
	begin
      INSERT INTO T_EXS_BANKING_BALANCE(ID, READING_MONTH, READING_YEAR, M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,
								INCR_EA1_C1, INCR_EA1_C2, INCR_EA1_C3, INCR_EA1_C4, INCR_EA1_C5, INCR_EA1_TOTAL_UNITS,DECR_EA1_C1, DECR_EA1_C2, DECR_EA1_C3, DECR_EA1_C4, DECR_EA1_C5, DECR_EA1_TOTAL_UNITS,INCR_HT_C1, INCR_HT_C2, INCR_HT_C3, INCR_HT_C4, INCR_HT_C5, INCR_HT_TOTAL_UNITS,
								CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED)
        select ID,READING_MONTH,READING_YEAR,M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,
								INCR_EA1_C1, INCR_EA1_C2, INCR_EA1_C3, INCR_EA1_C4, INCR_EA1_C5, INCR_EA1_TOTAL_UNITS,DECR_EA1_C1, DECR_EA1_C2, DECR_EA1_C3, DECR_EA1_C4, DECR_EA1_C5, DECR_EA1_TOTAL_UNITS,INCR_HT_C1, INCR_HT_C2, INCR_HT_C3, INCR_HT_C4, INCR_HT_C5, INCR_HT_TOTAL_UNITS,
								CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED
								from T_EXS_BANKING_BALANCE_SRC_29_JUN where id=banking_src.id;
      update T_EXS_BANKING_BALANCE_SRC_29_JUN set import_result='Y' where id=banking_src.id;
    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          ---- dbms_output.put_line(o_result_desc);
          update T_EXS_BANKING_BALANCE_SRC_29_JUN set import_result=v_exception_msg where id=banking_src.id;
       END;
     END LOOP;

	--insert from banking_src
	for surplus_stb_src in (select id from T_EXS_SURPLUS_STB_SRC_29_JUN where IMPORT_RESULT<>'Y' )
	LOOP
	begin
	INSERT INTO T_EXS_SURPLUS_STB_BALANCE(ID, READING_MONTH, READING_YEAR, M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,
								INCR_EA1_C1, INCR_EA1_C2, INCR_EA1_C3, INCR_EA1_C4, INCR_EA1_C5, INCR_EA1_TOTAL_UNITS,DECR_EA1_C1, DECR_EA1_C2, DECR_EA1_C3, DECR_EA1_C4, DECR_EA1_C5, DECR_EA1_TOTAL_UNITS,INCR_HT_C1, INCR_HT_C2, INCR_HT_C3, INCR_HT_C4, INCR_HT_C5, INCR_HT_TOTAL_UNITS,
								CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED)
        select ID,READING_MONTH,READING_YEAR,M_COMPANY_ID,M_COMPANY_NAME,M_COMPANY_SERVICE_ID,M_COMPANY_SERVICE_NUM,BANKING_SERVICE_ID,BANKING_SERVICE_NUM,OPEN_C1,OPEN_C2,OPEN_C3,OPEN_C4,OPEN_C5,OPEN_TOTAL_UNITS,
								INCR_EA1_C1, INCR_EA1_C2, INCR_EA1_C3, INCR_EA1_C4, INCR_EA1_C5, INCR_EA1_TOTAL_UNITS,DECR_EA1_C1, DECR_EA1_C2, DECR_EA1_C3, DECR_EA1_C4, DECR_EA1_C5, DECR_EA1_TOTAL_UNITS,INCR_HT_C1, INCR_HT_C2, INCR_HT_C3, INCR_HT_C4, INCR_HT_C5, INCR_HT_TOTAL_UNITS,
								CURR_C1,CURR_C2,CURR_C3,CURR_C4,CURR_C5,CURR_TOTAL_UNITS,CREATED_BY,CREATED_DT,MODIFIED_BY,MODIFIED_DT,ENABLED
								from T_EXS_SURPLUS_STB_SRC_29_JUN where id=surplus_stb_src.id;
      update T_EXS_SURPLUS_STB_SRC_29_JUN set import_result='Y' where id=surplus_stb_src.id;

    exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          ---- dbms_output.put_line(o_result_desc);
          update T_EXS_SURPLUS_STB_SRC_29_JUN set import_result=v_exception_msg where id=surplus_stb_src.id;
       END;
     END LOOP;
  --Loop ends

         exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;

       END;
       COMMIT;
  RETURN NULL;
END TEMP_SETUP_EXCESS_BAL;


/
--------------------------------------------------------
--  DDL for Function TEMP_UPDATE_INC_EAL_C5
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TEMP_UPDATE_INC_EAL_C5" RETURN VARCHAR2 AS
v_result varchar(300):='SUCCESS';
v_reason VARCHAR2(300);
BEGIN
    FOR line IN (SELECT nvl(incr_ea1_src_id,INCR_EA1_remarks) es_id FROM t_EXS_banking_BALANCE WHERE
                    READING_YEAR='2020' AND READING_MONTH = '06')
            LOOP
            excess_units_source.update_excess_from_ea(line.es_id, V_RESULT , V_REASON);
            END LOOP;
            COMMIT;
RETURN 'success';
END TEMP_UPDATE_INC_EAL_C5;

/
--------------------------------------------------------
--  DDL for Function TEMP_UPDATE_LOSS_PERCENTAGE
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE FUNCTION "OPENACCESS"."TEMP_UPDATE_LOSS_PERCENTAGE" RETURN VARCHAR2 AS 
v_cursor sys_refcursor;
v_f_eng_adj F_ENERGY_ADJUSTMET%ROWTYPE;
v_buyer_drw_code varchar2(50);
v_seller_inj_code varchar2(50);
v_loss_percent varchar2(50);

BEGIN
    OPEN v_cursor for select * from F_ENERGY_ADJUSTMET; 
    LOOP
    FETCH v_cursor INTO v_f_eng_adj;
    EXIT WHEN v_cursor%NOTFOUND;
    SELECT voltage_code into v_buyer_drw_code from m_company_service where "number"=v_f_eng_adj.SERVICE_NO;
    SELECT voltage_code into v_seller_inj_code from m_company_service where "number"=v_f_eng_adj.SUPLR_CODE;

    SELECT TOTAL_LOSS_PERCENT INTO v_loss_percent FROM M_LOSS_CALC_CHART WHERE INJECTION_VOLTAGE_CODE=v_seller_inj_code AND DRAWAL_VOLTAGE_CODE=v_buyer_drw_code;
    update F_ENERGY_ADJUSTMET set LOSS_PERCENT=v_loss_percent WHERE SERVICE_NO=v_f_eng_adj.SERVICE_NO AND SUPLR_CODE=v_f_eng_adj.SUPLR_CODE;

    END LOOP;
  RETURN 'SUCCESS';
END TEMP_UPDATE_LOSS_PERCENTAGE;


/
--------------------------------------------------------
--  DDL for Function TMP_CALL_GS_CHARGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TMP_CALL_GS_CHARGE" RETURN VARCHAR2 AS 

v_gs_id VARCHAR2(50);
 v_gs number := 0;

BEGIN 
        for ss in (select distinct v_gs_id from Dummy1 where reading_month='01'and reading_year='2020')

        LOOP 
             v_gs:= calc_gs_charges(v_gs_id) ;

             UPDATE T_GEN_STMT SET REMARKS ='CMRI1' WHERE STMT_MONTH='01' AND STMT_YEAR='2020' AND  ID = V_GS_ID;

        END LOOP;

        RETURN 'SUCCESS';

        commit;

END TMP_CALL_GS_CHARGE;


/
--------------------------------------------------------
--  DDL for Function TMP_METER_CHANGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TMP_METER_CHANGE" 
(
i_remarks varchar2
) RETURN VARCHAR2 AS 

v_id varchar2(20);
v_m_id varchar2(20);
v_s_id varchar2(20);
v_number varchar2(20);
v_MONTH varchar2(20);
v_YEAR varchar2(20);
v_result varchar2(50);
o_res_code varchar2(50);
o_res_desc varchar2(200);

BEGIN

     for im in(select * from int_meter_change where REMARKS=i_remarks)
     loop

  --   if im.reading_month != to_char( sysdate, 'mm' ) and im.reading_year != to_char( sysdate, 'yyyy' ) then

--          if im.reading_month = to_char( sysdate, 'mm' ) - 1 then

     select id,"number" into v_m_id,v_number from m_company_service where "number"=im.service_no;

     select id into v_id from m_company_meter where M_COMPANY_SERVICE_ID=v_m_id;

     select id,READING_MONTH,READING_YEAR into v_s_id,v_MONTH,v_YEAR from t_meter_reading_hdr where READING_MONTH = im.reading_month and READING_YEAR = im.reading_year and M_COMPANY_METER_ID = v_id; 


     update t_meter_reading_hdr set TOTAL_IMPORT_GEN=trim(im.total_import_units), TOTAL_EXPORT_GEN=trim(im.total_export_units), RKVAH_UNITS=trim(im.rkvah_units), NET_GEN_UNITS=trim(im.total_net_units)
     where READING_MONTH = im.reading_month and M_COMPANY_METER_ID = v_id;

     update t_meter_reading_slot set IMP_UNITS=trim(im.IMP_C1_UNITS), EXP_UNITS=trim(im.EXP_C1_UNITS), NET_UNITS=trim(im.NET_C1_UNITS) where T_METER_READING_HDR_ID = v_s_id and slot_code='C1';

     update t_meter_reading_slot set IMP_UNITS=trim(im.IMP_C2_UNITS), EXP_UNITS=trim(im.EXP_C2_UNITS), NET_UNITS=trim(im.NET_C2_UNITS) where T_METER_READING_HDR_ID = v_s_id and slot_code='C2';

     update t_meter_reading_slot set IMP_UNITS=trim(im.IMP_C3_UNITS), EXP_UNITS=trim(im.EXP_C3_UNITS), NET_UNITS=trim(im.NET_C3_UNITS) where T_METER_READING_HDR_ID = v_s_id and slot_code='C3';

     update t_meter_reading_slot set IMP_UNITS=trim(im.IMP_C4_UNITS), EXP_UNITS=trim(im.EXP_C4_UNITS), NET_UNITS=trim(im.NET_C4_UNITS) where T_METER_READING_HDR_ID = v_s_id and slot_code='C4';

     update t_meter_reading_slot set IMP_UNITS=trim(im.IMP_C5_UNITS), EXP_UNITS=trim(im.EXP_C5_UNITS), NET_UNITS=trim(im.NET_C5_UNITS) where T_METER_READING_HDR_ID = v_s_id and slot_code='C5';

     update m_company_meter set METER_NUMBER=trim(im.NEW_METER_NO) where M_COMPANY_SERVICE_ID=v_m_id and METER_NUMBER=trim(im.OLD_METER_NO);


     DELETE_TXN.DELETE_BY_SERVICE('Meter_change',v_number,v_MONTH,v_YEAR,'Y','Y','Y','N',o_res_code,o_res_desc);

     update int_meter_change set IMPORT_REMARKS='success' where service_no=v_number;

    -- else 

  --   update int_meter_change set IMPORT_REMARKS='failure' where service_no=v_number;

   ---  return 'download meter reading';

   --  end if;

     END LOOP;

     v_result:=CREATE_GS('',v_MONTH,v_YEAR);

  RETURN 'success';

END ;

/
--------------------------------------------------------
--  DDL for Function TMP_REDO_SURPLUS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TMP_REDO_SURPLUS" 
(
  I_MONTH IN VARCHAR2 
, I_YEAR IN VARCHAR2 
) RETURN VARCHAR2 AS 

v_count number;
v_count2 number;
  v_log_result varchar(300):='SUCCESS';

BEGIN

v_log_result := log_activity('FUNCTION','TMP_REDO_SURPLUS','START','','','ADMIN', sysdate,'');

FOR  s in (select * from missing_int_adj_units_0306)

loop

select count(*) into v_count from int_adjusted_unit where SERVICE_NO=s.SERVICE_NO and reading_mnth='00' and suplr_code=s.SUPLR_CODE;
v_log_result := log_activity('FUNCTION','TMP_REDO_SURPLUS','int_count-'||v_count,'LOOP', '','ADMIN', sysdate,'');


if v_count>0 then
delete from int_adjusted_unit where SERVICE_NO=s.SERVICE_NO and reading_mnth='00' and suplr_code=s.SUPLR_CODE;
end if;


select count(*) into v_count2 from f_energy_adjustmet where SERVICE_NO=s.SERVICE_NO and reading_mnth='009' and suplr_code=s.SUPLR_CODE;
v_log_result := log_activity('FUNCTION','TMP_REDO_SURPLUS','ENERGY_count-'||v_count2,'LOOP', '','ADMIN', sysdate,'');

if v_count2>0 then
delete from f_energy_adjustmet where SERVICE_NO=s.SERVICE_NO and reading_mnth='09' and suplr_code=s.SUPLR_CODE;
end if;

end loop;
v_log_result := log_activity('FUNCTION','TMP_REDO_SURPLUS','END','','','ADMIN', sysdate,'');

  RETURN NULL;
END TMP_REDO_SURPLUS;


/
--------------------------------------------------------
--  DDL for Function TMP_SECTION_UPDATE
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE FUNCTION "OPENACCESS"."TMP_SECTION_UPDATE" 
RETURN VARCHAR2 AS 
v_cursor sys_refcursor ;
v_section_name varchar2(100);
v_tmp_section TMP_M_SECTION%ROWTYPE;
v_seq varchar2(100);
BEGIN
OPEN v_cursor for SELECT distinct section_name from tmp_m_section;
    LOOP
    FETCH v_cursor INTO v_section_name;
    EXIT WHEN v_cursor%NOTFOUND;
    SELECT * into v_tmp_section from tmp_m_section where section_name=v_section_name and rownum=1;
    v_seq:=SECTION_SEQ.NEXTVAL;
         -- dbms_output.put_line(v_section_name);
         -- dbms_output.put_line(v_tmp_section.M_ORG_ID);
             INSERT INTO m_section (ID, SECTION_NAME, M_ORG_ID, REMARKS, CREATED_BY, CREATED_DATE, SECTION_CODE) 
             VALUES (v_seq,v_section_name,v_tmp_section.M_ORG_ID, 'TMP_SECTION_UPDATE','TMP_SECTION_UPDATE' ,sysdate,v_tmp_section.M_ORG_ID||v_seq);
 END LOOP;
  RETURN NULL;
END TMP_SECTION_UPDATE;


/
--------------------------------------------------------
--  DDL for Function TMP_UPDATE_SURPLUSLOSS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TMP_UPDATE_SURPLUSLOSS" 
(
  I_MONTH IN VARCHAR2 
, I_YEAR IN VARCHAR2 
) RETURN VARCHAR2 AS 

    v_cursor sys_refcursor ;
    v_total_loss VARCHAR2(200);
    v_drawl_code VARCHAR2(200); 
    v_inj_code VARCHAR2(200); 
    v_energy_adj F_ENERGY_ADJUSTMET%ROWTYPE;

    v_trans_loss VARCHAR2(200); 
    v_dis_loss VARCHAR2(200); 
    v_inj_units1 VARCHAR2(200); 
    v_inj_units2 VARCHAR2(200); 
    v_inj_units3 VARCHAR2(200); 
    v_inj_units4 VARCHAR2(200); 
    v_inj_units5 VARCHAR2(200); 

    v_log_result varchar(300):='SUCCESS';
    v_exception_code VARCHAR2(150);
    v_exception_msg  VARCHAR2(150);
    v_reason VARCHAR2(300);
    o_result_code VARCHAR2(100);
    o_result_desc  VARCHAR2(200);
BEGIN
BEGIN
    v_log_result := log_activity('FUNCTION','TMP_UPDATE_SURPLUSLOSS','START','Start - '||I_MONTH,'','', sysdate,I_YEAR);

    OPEN v_cursor for select * from F_ENERGY_ADJUSTMET where READING_MNTH=I_MONTH and READING_YR=I_YEAR;
    LOOP
    FETCH v_cursor INTO v_energy_adj;
    EXIT WHEN v_cursor%NOTFOUND;

      SELECT voltage_code INTO v_inj_code FROM m_company_service WHERE "number"=v_energy_adj.SUPLR_CODE;
      SELECT voltage_code INTO v_drawl_code FROM m_company_service WHERE "number"=v_energy_adj.SERVICE_NO;

      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_energy_adj.C1,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units1);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_energy_adj.C2,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units2);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_energy_adj.C3,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units3);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_energy_adj.C4,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units4);
      v_total_loss :=SURPLUS_ENERGY_LOSS_CALC(v_inj_code,v_drawl_code,v_energy_adj.C5,v_trans_loss,v_dis_loss,v_total_loss,v_inj_units5);
      UPDATE F_ENERGY_ADJUSTMET SET C1_WITHLOSS=round(nvl(v_inj_units1,0),0),C2_WITHLOSS=round(nvl(v_inj_units2,0),0),C3_WITHLOSS=round(nvl(v_inj_units3,0),0),C4_WITHLOSS=round(nvl(v_inj_units4,0),0),C5_WITHLOSS=round(nvl(v_inj_units5,0),0)
      WHERE ID = v_energy_adj.ID;

    END LOOP;
        exception
        when others then
          v_exception_code := SQLCODE;
          v_exception_msg := SUBSTR(SQLERRM, 1, 200);
          o_result_code := 'FAILURE';
          o_result_desc := v_exception_code || ' - ' || v_exception_msg;
          -- -- dbms_output.put_line(o_result_desc);
        v_log_result := log_activity('FUNCTION','TMP_UPDATE_SURPLUSLOSS','EXCEPTION',o_result_desc,I_MONTH,'', sysdate,I_YEAR);
       END;
    COMMIT;
    v_log_result := log_activity('FUNCTION','TMP_UPDATE_SURPLUSLOSS','End','End','','', sysdate,I_MONTH);
  RETURN o_result_desc;
END TMP_UPDATE_SURPLUSLOSS;


/
--------------------------------------------------------
--  DDL for Function TO_CALL_SURPLUS_LOSS_CALC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_CALL_SURPLUS_LOSS_CALC" 
--AUTHOR: AE/LT5
(GENERATOR_CODE IN VARCHAR2,
SUPPLIER_CODE IN VARCHAR2,
DRAWAL_UNITS IN VARCHAR2,

TRANS_LOSS OUT NUMBER,DIST_LOSS OUT NUMBER,
TOTAL_LOSS OUT NUMBER,INJECTED_UNITS OUT NUMBER)
RETURN VARCHAR2 AS 
BEGIN


  RETURN NULL;
END;


/
--------------------------------------------------------
--  DDL for Function TO_CALL_UPDATE_SURPLUS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_CALL_UPDATE_SURPLUS" RETURN VARCHAR2 AS

v_number VARCHAR2(50);
v_month VARCHAR2(50);
v_year VARCHAR2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);

BEGIN
        for ss in (select distinct suplr_code from f_energy_adjustmet where reading_mnth='04' and READING_YR='2020')
        LOOP
        select ms."number" into v_number from m_company_service ms where ms."number"=ss.suplr_code;
        IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_number,'04','2020',o_result_code,o_result_desc);
        END LOOP;

        RETURN 'SUCCESS';

        commit;

     END TO_CALL_UPDATE_SURPLUS;


/
--------------------------------------------------------
--  DDL for Function TO_REDO_BANKING
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_REDO_BANKING" 

(v_remarks in varchar2,
v_month IN VARCHAR2,
v_year in varchar2) RETURN VARCHAR2 AS

v_id varchar2(50);
v_number varchar2(50);
v_comp_id varchar2(50);
v_es_id varchar2(50);
v_gen_id varchar2(50);
v_c1 varchar2(50);
v_c2 varchar2(50);
v_c3 varchar2(50);
v_c4 varchar2(50);
v_c5 varchar2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);
--v_log_result varchar(300):='SUCCESS';
v_result varchar(300):='SUCCESS';

BEGIN

        for dd in (select GEN_SERVICE_NUMBER from int_delete_txn where remarks=v_remarks)
        loop
        select id,"number",m_company_id into v_id,v_number,v_comp_id from m_company_service where "number"=dd.GEN_SERVICE_NUMBER;
        delete from t_banking_balance where m_company_id=v_comp_id and month=v_month and year=v_year;        
        DELETE_TXN.DELETE_BY_SERVICE(v_remarks,v_number,'07',v_year,'Y','N','N','N',o_result_code,o_result_desc);
        select id into v_es_id from t_energy_sale where seller_comp_serv_id=v_id and month='07' and year=v_year;
        v_result:=ENERGY_SALE_CONFIRMATION(v_es_id);
        select id into v_gen_id from t_gen_stmt where m_company_service_id=v_id and stmt_month=v_month and stmt_year=v_year;
        IMP_INT_ADJUSTED_UNIT.UPDATE_SURPLUS_BANKING(v_number,'07',v_year,o_result_code,o_result_desc);
        BANKING_BALANCE.open_balance(v_number,v_month,v_year,o_result_code,o_result_desc);
        select c1,c2,c3,c4,c5 into v_c1,v_c2,v_c3,v_c4,v_c5 from t_banking_balance where m_company_id=v_comp_id and month=v_month and year=v_year;
        update t_gen_stmt_slot set banked_balance=v_c1 where t_gen_stmt_id=v_gen_id and slot_code='C1';
        update t_gen_stmt_slot set banked_balance=v_c2 where t_gen_stmt_id=v_gen_id and slot_code='C2';
        update t_gen_stmt_slot set banked_balance=v_c3 where t_gen_stmt_id=v_gen_id and slot_code='C3';
        update t_gen_stmt_slot set banked_balance=v_c4 where t_gen_stmt_id=v_gen_id and slot_code='C4';
        update t_gen_stmt_slot set banked_balance=v_c5 where t_gen_stmt_id=v_gen_id and slot_code='C5';
        select id into v_es_id from t_energy_sale where seller_comp_serv_id=v_id and month=v_month and year=v_year;
        update t_energy_sale set avail_bc1=v_c1,avail_bc2=v_c2,avail_bc3=v_c3,avail_bc4=v_c4,avail_bc5=v_c5 where seller_comp_serv_id=v_id and month=v_month and year=v_year;
        DELETE_TXN.DELETE_BY_SERVICE(v_remarks,v_number,v_month,v_year,'Y','N','N','N',o_result_code,o_result_desc);
        select id into v_es_id from t_energy_sale where seller_comp_serv_id=v_id and month=v_month and year=v_year;
        v_result:=ENERGY_SALE_CONFIRMATION(v_es_id);

        end loop;
        commit;



     RETURN v_result;

END TO_REDO_BANKING;


/
--------------------------------------------------------
--  DDL for Function TO_REDO_UNALLOCATED_ES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_REDO_UNALLOCATED_ES" 

(v_remarks in varchar2,
v_month IN VARCHAR2,
v_year in varchar2) RETURN VARCHAR2 AS

v_id varchar2(50);
v_number varchar2(50);
v_comp_id varchar2(50);
v_es_id varchar2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);
v_result varchar(300):='SUCCESS';

BEGIN

    for dd in (select GEN_SERVICE_NUMBER from int_delete_txn where remarks=v_remarks)
        loop
        select id,"number",m_company_id into v_id,v_number,v_comp_id from m_company_service where "number"=dd.GEN_SERVICE_NUMBER;
        DELETE_TXN.DELETE_BY_SERVICE(v_remarks,v_number,v_month,v_year,'Y','N','N','N',o_result_code,o_result_desc);
        select id into v_es_id from t_energy_sale where seller_comp_serv_id=v_id and month=v_month and year=v_year;
        v_result:=ENERGY_SALE_CONFIRMATION(v_es_id);
        end loop;
        commit;

  RETURN v_result;
END TO_REDO_UNALLOCATED_ES;


/
--------------------------------------------------------
--  DDL for Function TO_REDO_UNALLOCATED_UNITS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_REDO_UNALLOCATED_UNITS" 
(v_month IN VARCHAR2,
v_year in varchar2) RETURN VARCHAR2 AS
v_number VARCHAR2(100);
v_service_id VARCHAR2(50);
v_es_id VARCHAR2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);
v_result varchar(300):='SUCCESS';


BEGIN
        for ss in (select ms."number" as service_no,ms.id as service_id,ms.m_org_id as edc_code,og.name as edc_name,es.month as month 
                        from m_company_service ms
                        left join m_org og on og.id=ms.m_org_id
                        left join t_energy_sale es on es.seller_comp_serv_id=ms.id
                        left join t_es_usage_summary ss on ss.t_energy_sale_id=es.id
                        left join v_company_service cc on cc.id=ms.id
                        where (es.gc1+es.gc2+es.gc3+es.gc4+es.gc5)=0 and (ss.c1+ss.c2+ss.c3+ss.c4+ss.c5)>0 and es.month='09'
                        group by ss.t_energy_sale_id,ms."number",ms.id,ms.m_org_id,es.month,og.name)
        LOOP
        select ms."number",ms.id into v_number,v_service_id from m_company_service ms where ms."number"=ss.service_no;
        DELETE_TXN.DELETE_BY_SERVICE('TO_REDO_UNALLOCATED_UNITS',v_number,v_month,v_year,'Y','N','N','N',o_result_code,o_result_desc);
        select es.id into v_es_id from t_energy_sale es where es.seller_comp_serv_id=v_service_id and month=v_month;
        v_result:=ENERGY_SALE_CONFIRMATION(v_es_id);

        END LOOP;

        RETURN 'SUCCESS';

        commit;

     END TO_REDO_UNALLOCATED_UNITS;


/
--------------------------------------------------------
--  DDL for Function TO_RUN_GEN_SS_LOSS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_RUN_GEN_SS_LOSS" RETURN VARCHAR2 AS

v_number VARCHAR2(50);
v_org VARCHAR2(50);
v_subs VARCHAR2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);

BEGIN
        for ss in (select GEN_SERVICE_NUMBER from int_delete_txn where remarks='TARRIF_CHANGE_30OCT' and  reading_month='09' and reading_year='2019')
        LOOP
        select ms."number",ms.m_org_id,ms.m_substation_id into v_number,v_org,v_subs from m_company_service ms where ms."number"=ss.gen_service_number;
        GENERATION_STATEMENT.CREATE_WITH_SS_LOSS(v_subs,v_number,v_org,'09','2019',o_result_code,o_result_desc);
        END LOOP;

        RETURN 'SUCCESS';

        commit;

     END TO_RUN_GEN_SS_LOSS;


/
--------------------------------------------------------
--  DDL for Function TO_RUN_OPENIG_BALANCE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_RUN_OPENIG_BALANCE" RETURN VARCHAR2 AS

v_number VARCHAR2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);

BEGIN

            for bb in (select M_COMPANY_ID from T_BANKING_BALANCE where month='04' and year='2020')
--            for bb in (select M_COMPANY_ID from temp_banking_solution where month='09' and year='2019' and remarks='BANKING_NOT_IN_OCT')
                LOOP
                 select ms."number" into v_number from M_COMPANY_SERVICE ms where ms.M_COMPANY_ID=bb.M_COMPANY_ID;

                BANKING_BALANCE.open_balance(v_number,'05','2020',o_result_code,o_result_desc);
                END LOOP;

                RETURN 'SUCCESS';

        commit;

         END TO_RUN_OPENIG_BALANCE;


/
--------------------------------------------------------
--  DDL for Function TO_RUN_RESET_BB_ALL_SERVICES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."TO_RUN_RESET_BB_ALL_SERVICES" RETURN VARCHAR2 AS

v_number VARCHAR2(50);
o_result_code VARCHAR2(200);
o_result_desc VARCHAR2(200);

BEGIN

           -- for bb in (select m_company_id from m_company_service where "number" in 
           --                 (select gen_num from to_update_list))
--            for bb in (select M_COMPANY_ID from temp_banking_solution where month='09' and year='2019' and remarks='BANKING_NOT_IN_OCT')
            for bb in (select "number" service_number from v_company_service where comp_ser_type_code = '03') --only generators
                LOOP
                 --select ms."number" into v_number from M_COMPANY_SERVICE ms where ms.M_COMPANY_ID=bb.M_COMPANY_ID;

                 BANKING_BALANCE.RESET_FOR_YEAREND(bb.service_number,'04','2020',o_result_code,o_result_desc);
                -- -- dbms_output.put_line(bb.service_number||'-'||o_result_code||'-'||o_result_desc);
                insert into TEMP_RESULTS_PLS_FLUSH values(bb.service_number,o_result_code,o_result_desc);
                END LOOP;

                RETURN 'SUCCESS';

        commit;

         END TO_RUN_RESET_BB_ALL_SERVICES;


/
--------------------------------------------------------
--  DDL for Function UPDATE_925_SERVICES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_925_SERVICES" RETURN VARCHAR2 AS 
v_service_count varchar2(50);
v_cursor sys_refcursor ;
v_company_id varchar2(50);

BEGIN
select count(*) into v_service_count from t_banking_balance where month='05' and m_company_id in (select m_Company_id from v_company_Service where commission_date>to_date('01-04-2018','DD-MM-YYYY'));

OPEN v_cursor for select m_company_id from t_banking_balance where month='05' and m_company_id in (select m_Company_id from v_company_Service where commission_date>to_date('01-04-2018','DD-MM-YYYY'));
    LOOP
    FETCH v_cursor INTO v_company_id;

    update t_banking_balance set c1=0,c2=0,c3=0,c4=0,c5=0,curr_c1=0,curr_c2=0,curr_c3=0,curr_c4=0,curr_c5=0 where m_company_id=v_company_id and month='05' and year='2019';

  EXIT WHEN v_cursor%NOTFOUND;
END LOOP;

COMMIT;

  RETURN v_service_count;
END UPDATE_925_SERVICES;


/
--------------------------------------------------------
--  DDL for Function UPDATE_BUYER
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_BUYER" RETURN VARCHAR2 AS
v_buyer_cur sys_refcursor ;
v_buyer_number varchar2(100);
v_buyer_count number:=0;
BEGIN
OPEN v_buyer_cur for select buyernumber from temp_buyer_update;
    LOOP
    FETCH v_buyer_cur INTO v_buyer_number;
    select count(*) into v_buyer_count from m_company_service where   "number"=v_buyer_number;
    if v_buyer_count=1 then
    --already exist
    --update in remarks - buyer exits
    UPDATE temp_buyer_update SET  REMARKS = 'Buyer Already Exists';
    else
    UPDATE temp_buyer_update SET REMARKS = 'New Buyer';
    --update in remarks - buyer does not exist
    end if;
  EXIT WHEN v_buyer_cur%NOTFOUND;
END LOOP;
  RETURN 'success';
END ;


/
--------------------------------------------------------
--  DDL for Function UPDATE_BUYER_VOLTGE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_BUYER_VOLTGE" RETURN VARCHAR2 AS 
v_serviceView_cur sys_refcursor ;
v_voltage_code varchar2(50);
service_number varchar2(50);
master_service_count varchar2(50);
v_serviceMasView SERVICEMASVIEW%ROWTYPE;
--------------
v_log_result  varchar2(50);
v_created_by varchar2(100):='Admin';
v_result_code varchar2(100);
v_result_desc varchar2(300);
v_reason varchar2(200):='';
v_exception_code  NUMBER;
v_exception_msg  VARCHAR2(200);
v_result VARCHAR(200):='SUCCESS';
v_error_message  VARCHAR2(200);

BEGIN

--To run this procedure
-- 1. Get ht SERVICE_NO,VOLTAGE,CONSUMER_NAME data in excel fromat from HT
-- 2. Upload the excel in SERVICEMASVIEW
-- 3. run this fumction
-- 4. Check for errors in activity log

    BEGIN --Exception starts here
    v_log_result := log_activity('PROCEDURE','UPDATE_BUYER_VOLTGE','START','UPDATING STARTS','START',v_created_by, sysdate,'');


    OPEN v_serviceView_cur for select * from SERVICEMASVIEW;
    LOOP 

    BEGIN --Exception starts here
    v_log_result := log_activity('PROCEDURE','-in loop','START','UPDATING STARTS','START',v_created_by, sysdate,'');
    FETCH v_serviceView_cur INTO v_serviceMasView;
    EXIT WHEN v_serviceView_cur%NOTFOUND;

    select codes.value_code into v_voltage_code from servicemasview ser left join v_codes codes on ser.voltage=codes.value_desc and codes.list_Code='VOLTAGE_CODE' where ser.SERVICE_NO=v_serviceMasView.SERVICE_NO;
    update SERVICEMASVIEW s set s.VOLTAGE_CODE=v_voltage_code where s.SERVICE_NO=v_serviceMasView.SERVICE_NO;    
    COMMIT;


    select count(*) into master_service_count from M_COMPANY_SERVICE where "number"=v_serviceMasView.SERVICE_NO;

    if(master_service_count=1)then
    update M_COMPANY_SERVICE set VOLTAGE_CODE=v_voltage_code where "number"=v_serviceMasView.SERVICE_NO;
    update m_company set name=v_serviceMasView.CONSUMER_NAME where id=(select m_company_id from m_company_service where "number"=v_serviceMasView.SERVICE_NO);
    v_error_message:='service exits and will be updated';

    ELSIF(master_service_count > 1)then
    v_error_message:='service duplicate exits';
    ELSIF(master_service_count=0)then
    v_error_message:='service does not exist';
    end if;

    EXCEPTION
      WHEN OTHERS THEN 
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
      END;
            v_log_result := log_activity('PROCEDURE','end loop-',v_error_message||'-'||master_service_count,v_result_code,v_result_desc,v_created_by, sysdate,v_serviceMasView.SERVICE_NO);

    END LOOP;

    EXCEPTION
      WHEN OTHERS THEN 
        v_exception_code := SQLCODE;
        v_exception_msg := SUBSTR(SQLERRM, 1, 200);
        v_result := 'FAILURE';
        v_result_desc := v_exception_code || ' - ' || v_exception_msg;
      END;
    COMMIT;
      v_log_result := log_activity('PROCEDURE','UPDATE_BUYER_VOLTGE','RESULT',v_result_code,v_result_desc,v_created_by, sysdate,'');
  RETURN 'success';
END UPDATE_BUYER_VOLTGE;


/
--------------------------------------------------------
--  DDL for Function UPDATE_GROUP_CODE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_GROUP_CODE" RETURN VARCHAR2 AS 

v_plant_class_type varchar(20);

BEGIN

    for gs in(SELECT * FROM t_gen_stmt where stmt_month='05' and plant_class_type_code is null)
    loop

    select plant_class_type_code into v_plant_class_type from m_powerplant where m_service_id=gs.M_COMPANY_SERVICE_ID;
    update t_gen_stmt set plant_class_type_code=v_plant_class_type where id=gs.id;
    end loop;

   RETURN NULL;

END UPDATE_GROUP_CODE;


/
--------------------------------------------------------
--  DDL for Function UPDATE_QUANTUM
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_QUANTUM" RETURN VARCHAR2 AS 
v_trade_cursor sys_refcursor ;
service_id varchar2(50);
v_conversion number:=0.001;
share_prcent number:=100;

v_result number:=0;


BEGIN

	OPEN v_trade_cursor for select id from m_company_service where flow_type_code='WEG-THIRD-PARTY'; 
    LOOP 
    FETCH v_trade_cursor INTO service_id;
    select (ser.CAPACITY/(share_prcent)*100)*v_conversion into v_result from M_COMPANY_SERVICE ser where ser.id=service_id;
    update M_TRADE_RELATIONSHIP set QUANTUM=v_result where M_SELLER_COMP_SERVICE_ID=service_id;
	EXIT WHEN v_trade_cursor%NOTFOUND;

	END LOOP;
  RETURN NULL;
END UPDATE_QUANTUM;


/
--------------------------------------------------------
--  DDL for Function UPDATE_SECTION_ID
--------------------------------------------------------

  CREATE OR REPLACE NONEDITIONABLE FUNCTION "OPENACCESS"."UPDATE_SECTION_ID" 
RETURN VARCHAR2 AS 
v_cursor sys_refcursor ;
v_cursor2 sys_refcursor ;
v_section_name varchar2(100);
v_section_id varchar2(100);
v_tmp_m_section TMP_M_SECTION%ROWTYPE; 

BEGIN
--1st
    OPEN v_cursor for SELECT distinct section_name from tmp_m_section;
    LOOP
    FETCH v_cursor INTO v_section_name;
    EXIT WHEN v_cursor%NOTFOUND;
             -- dbms_output.put_line(v_section_name);

        select id into v_section_id from m_section WHERE SECTION_NAME=v_section_name;
         update tmp_m_section set section_id=v_section_id where section_name =v_section_name;

    END LOOP;
--2nd    
    OPEN v_cursor2 for SELECT * from tmp_m_section;
    LOOP
    FETCH v_cursor2 INTO v_tmp_m_section;
    EXIT WHEN v_cursor2%NOTFOUND;
    update m_company_service set M_SECTION_ID=v_tmp_m_section.SECTION_ID where "number"=v_tmp_m_section.SERVICE_NUMBER;
    END LOOP;

  RETURN 'success';
END UPDATE_SECTION_ID;


/
--------------------------------------------------------
--  DDL for Function UPDATE_SUBSTATION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_SUBSTATION" RETURN VARCHAR2 AS 
v_ss_cur sys_refcursor ;
v_pp M_POWERPLANT%ROWTYPE;
BEGIN
	OPEN v_ss_cur for select * from m_powerplant;
    LOOP 
    FETCH v_ss_cur INTO v_pp;
    UPDATE M_COMPANY_SERVICE SET M_SUBSTATION_ID=v_pp.M_SUBSTATION_ID WHERE ID=v_pp.M_SERVICE_ID and M_SUBSTATION_ID is null;
	EXIT WHEN v_ss_cur%NOTFOUND;

	END LOOP;
  RETURN 'success';
END UPDATE_SUBSTATION;


/
--------------------------------------------------------
--  DDL for Function UPDATE_USER_NAME
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."UPDATE_USER_NAME" 
(v_service_no in varchar2
)RETURN VARCHAR2 AS 
v_service_count varchar2(50);
v_comp_service_id varchar2(50);
v_comp_id varchar2(50);
v_comp_name varchar2(50);
v_org_id varchar2(50);
v_user_name varchar2(50);
v_user_count varchar2(50);



BEGIN
select count(*) into v_user_count from auth_user where user_name=v_service_no;
if(v_user_count=0)then

      select count(*) into v_service_count from v_company_service where "number"=v_service_no; 
        if(v_service_count > 0) then    

            select id,"number",M_COMPANY_ID,M_COMPANY_NAME ,M_ORG_ID into v_comp_service_id,v_user_name,v_comp_id,v_comp_name,v_org_id from v_company_service where "number"=v_service_no;
            insert into AUTH_USER(ID,FIRST_NAME,LAST_NAME,USER_NAME,PASSWORD,USER_TYPE_CODE,IS_SUPER_USER,SYSTEM_KEY_CODE,SYSTEM_REF_KEY,EDC_CODE,COMPANY_ID,
            ORG_ID,COMPANY_SERVICE_ID, IMPORT_REMARKS)
            values(USER_ID_SEQ.NEXTVAL,v_user_name,v_comp_name,v_user_name,'tneb','GEN','N','OA',v_comp_service_id,v_org_id,
            v_comp_id,v_org_id,v_comp_service_id,'USER_ADDED_BY_PROC');
      else
            -- dbms_output.put_line('Failed');
       end if;

else
        -- dbms_output.put_line('user name exits');
end if;
COMMIT;

  RETURN 'success';
END UPDATE_USER_NAME;


/
--------------------------------------------------------
--  DDL for Function refresh_unallocated_units
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "OPENACCESS"."refresh_unallocated_units" RETURN VARCHAR2 AS
v_result varchar(300):='SUCCESS';
v_reason VARCHAR2(300);
BEGIN
    FOR line IN (SELECT nvl(incr_ea1_src_id,INCR_EA1_remarks) es_id FROM t_EXS_banking_BALANCE WHERE
                    READING_YEAR='2020' AND READING_MONTH = '06')
            LOOP
            excess_units_source.update_excess_from_ea(line.es_id, V_RESULT , V_REASON);
            END LOOP;
            COMMIT;
RETURN 'success';
END refresh_unallocated_units;

/
--------------------------------------------------------
--  Constraints for Table T_STANDING_CLEARENCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_STANDING_CLEARENCE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_STANDING_CLEARENCE" ADD CONSTRAINT "T_STANDING_CLEARENCE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_SLOT_040619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_SLOT_040619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_M_COMPANY_METER_01AUG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_METER_01AUG" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_METER_01AUG" MODIFY ("M_COMPANY_SERVICE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TMP_GEN_STMT_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT_SLOT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT_SLOT" ADD CONSTRAINT "TMP_GEN_STMT_SLOT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 4194304 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table FINANCIAL_UNUTILIZED_BANKING
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."FINANCIAL_UNUTILIZED_BANKING" ADD CONSTRAINT "FINANCIAL_UNUTILIZED_BANKING_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 40960 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EPA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EPA" ADD CONSTRAINT "T_EPA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_EXCESS_UNIT_TYPE_OVERRIDE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_EXCESS_UNIT_TYPE_OVERRIDE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_EXCESS_UNIT_TYPE_OVERRIDE" ADD CONSTRAINT "M_EXCESS_UNIT_TYPE_OVERRIDE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_CS_QUANTUM_ALLOCATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" MODIFY ("T_CS_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" ADD CONSTRAINT "T_CS_QUANTUM_ALLOCATION_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_USER_FEATURE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER_FEATURE" MODIFY ("AUTH_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."AUTH_USER_FEATURE" MODIFY ("AUTH_FEATURE_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."AUTH_USER_FEATURE" ADD CONSTRAINT "AUTH_USER_FEATURE_PK" PRIMARY KEY ("AUTH_ID", "AUTH_FEATURE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table R_METER_CHG_LIST
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_METER_CHG_LIST" ADD CONSTRAINT "GEN_NO_PK" PRIMARY KEY ("GENERATOR_NO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table CONS_ENERGY_ADJUSTED_ORDER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."CONS_ENERGY_ADJUSTED_ORDER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."CONS_ENERGY_ADJUSTED_ORDER" MODIFY ("SELLER_SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."CONS_ENERGY_ADJUSTED_ORDER" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."CONS_ENERGY_ADJUSTED_ORDER" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_TRADE_RELATIONSHIP_05102020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_05102020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_05102020" MODIFY ("M_SELLER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_05102020" MODIFY ("M_BUYER_COMPANY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_CHARGE_059414600129
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_CHARGE_059414600129" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table D_EXS_BANKING_BALANCE_02NOV2020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."D_EXS_BANKING_BALANCE_02NOV2020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."D_EXS_BANKING_BALANCE_02NOV2020" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."D_EXS_BANKING_BALANCE_02NOV2020" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."D_EXS_BANKING_BALANCE_02NOV2020" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."D_EXS_BANKING_BALANCE_02NOV2020" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_CHARGES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_CHARGES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_CHARGES" ADD CONSTRAINT "F_ENERGY_CHARGES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table R_SURPLUS_SER_DET
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_SURPLUS_SER_DET" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_SURPLUS_SER_DET" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_SUBS_COPY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SUBS_COPY" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_SUBS_COPY" MODIFY ("NAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EPA_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EPA_LINES" ADD CONSTRAINT "T_EPA_LINES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 131072 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_CHARGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_CHARGE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GEN_STMT_CHARGE" ADD CONSTRAINT "T_GEN_STMT_CHARGE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_COMPANY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY" MODIFY ("COMPANY_TYPE_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY" ADD CONSTRAINT "M_COMPANY_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 655360 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_LOSS_CALC_CHART
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_LOSS_CALC_CHART" ADD CONSTRAINT "M_LOSS_CALC_CHART_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_METER_READING_SLOT_019104041686
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_SLOT_019104041686" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_M_COMPANY_29JUL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_29JUL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_29JUL" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_29JUL" MODIFY ("COMPANY_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DBINC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DBINC" MODIFY ("DBINC_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DBINC" MODIFY ("DB_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DBINC" MODIFY ("DB_NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DBINC" MODIFY ("RESET_SCN" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DBINC" MODIFY ("RESET_TIME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DBINC" MODIFY ("DBINC_STATUS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DBINC" ADD CONSTRAINT "DBINC_STATUS" CHECK (dbinc_status in ('CURRENT', 'PARENT', 'ORPHAN')) ENABLE;
  ALTER TABLE "OPENACCESS"."DBINC" ADD CONSTRAINT "DBINC_P" PRIMARY KEY ("DBINC_KEY")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
  ALTER TABLE "OPENACCESS"."DBINC" ADD CONSTRAINT "DBINC_U1" UNIQUE ("DB_KEY", "RESET_SCN", "RESET_TIME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_SUBSTATION_LOSS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS" MODIFY ("BATCH_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS" MODIFY ("M_SUBSTATION_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS" MODIFY ("YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BACKUP_T_EXS_BANKING_BALANCE_082020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_082020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_082020" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_082020" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_082020" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_082020" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_METER_CHANGE_FROM_AMR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_METER_CHANGE_FROM_AMR" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_METER_CHANGE_FROM_AMR" ADD CONSTRAINT "T_METER_CHANGE_FROM_AMR_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_16
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_16" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BK_T_ENERGY_SALE_09SEP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_T_ENERGY_SALE_09SEP" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_02022021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_02022021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_02022021" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_02022021" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_02022021" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_02022021" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ERROR_TABLE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."ERROR_TABLE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ERROR_TABLE" ADD CONSTRAINT "ERROR_TABLE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_PROCESS_GS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_PROCESS_GS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_PROCESS_GS" ADD CONSTRAINT "T_PROCESS_GS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_TRADE_RELATIONSHIP_1686_062020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_1686_062020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_1686_062020" MODIFY ("M_SELLER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_1686_062020" MODIFY ("M_BUYER_COMPANY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_F_ENERGY_ADJUSTMET02SEP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET02SEP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET02SEP" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET02SEP" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET02SEP" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET02SEP" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INT_ADJUSTED_UNIT_050421
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_050421" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_050421" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_050421" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_050421" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_050421" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_COMPANY_SHAREHOLDER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SHAREHOLDER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SHAREHOLDER" MODIFY ("M_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SHAREHOLDER" MODIFY ("M_SHAREHOLDER_COMPANY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INT_SURPLUS_UNIT_2
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("SUPLR_TYPE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("READING_DT" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT_2" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_CORR_SS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_CORR_SS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_CORR_SS" MODIFY ("NAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_AGREEMENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_AGREEMENT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_AGREEMENT" ADD CONSTRAINT "F_AGREEMENT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GC_ID_TABLEB
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEB" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEB" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEB" ADD CONSTRAINT "GC_ID_TABLEB_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_TRADE_RELATIONSHIP_OPG110UNIT1
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_OPG110UNIT1" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_OPG110UNIT1" MODIFY ("M_SELLER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP_OPG110UNIT1" MODIFY ("M_BUYER_COMPANY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_MAR262020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_MAR262020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_MAR262020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_MAR262020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_MAR262020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_MAR262020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_SURPLUS_STB_BALANCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" MODIFY ("CREATED_DT" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_SURPLUS_STB_BALANCE" ADD CONSTRAINT "T_EXS_SURPLUS_STB_BALANCE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_ES_USAGE_DETAIL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_USAGE_DETAIL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ES_USAGE_DETAIL" MODIFY ("T_ENERGY_SALE_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ES_USAGE_DETAIL" ADD CONSTRAINT "T_ES_USAGE_DETAIL_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_031220
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_031220" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_031220" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_031220" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_031220" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_031220" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INT_DELETE_TXN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_DELETE_TXN" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_DELETE_TXN" MODIFY ("GEN_SERVICE_NUMBER" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_DELETE_TXN" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_DELETE_TXN" MODIFY ("READING_YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_15
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_15" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_NOC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NOC" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_NOC" ADD CONSTRAINT "T_NOC_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_FEATURE_221020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_FEATURE_221020" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_01032021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01032021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01032021" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01032021" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01032021" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01032021" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_COMPANY_LOCATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_LOCATION" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_LOCATION" ADD CONSTRAINT "M_COMPANY_LOCATION_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GC_LOAN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_LOAN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_LOAN" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_LOAN" ADD CONSTRAINT "GC_LOAN_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_SLOT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GEN_STMT_SLOT" ADD CONSTRAINT "T_GEN_STMT_SLOT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_01
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_01" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_CONSENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GC_TRANSFORMERS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_TRANSFORMERS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_TRANSFORMERS" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_TRANSFORMERS" ADD CONSTRAINT "GC_TRANSFORMERS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_SUBSTATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SUBSTATION" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_SUBSTATION" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_SUBSTATION" ADD CONSTRAINT "M_SUBSTATION_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INT_ADJUSTED_UNIT_01032021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01032021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01032021" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01032021" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01032021" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01032021" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_ENERGY_SALE_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_COMPANY_NAME_CHANGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_COMPANY_NAME_CHANGE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_COMPANY_NAME_CHANGE" ADD CONSTRAINT "T_COMPANY_NAME_CHANGE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_CHARGES_MAP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_CHARGES_MAP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_CHARGES_MAP" ADD CONSTRAINT "M_CHARGES_MAP_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_09
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_09" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TMP_GEN_STMT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT" ADD CONSTRAINT "TMP_GEN_STMT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 851968 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_CS_LOAN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_LOAN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_LOAN" MODIFY ("T_CS_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_LOAN" ADD CONSTRAINT "T_CS_LOAN_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INT_ADJUSTED_UNIT_220620
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_220620" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_220620" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_220620" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_220620" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_220620" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table AUTH_USER_10062021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER_10062021" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_ENERGY_ADJUSTMENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_ENERGY_ADJUSTMENT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_ENERGY_ADJUSTMENT" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_ENERGY_ADJUSTMENT" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_GEN_STMT_21AUG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_GEN_STMT_21AUG" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_METER_READING_HDR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_HDR" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_METER_READING_HDR" ADD CONSTRAINT "T_METER_READING_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_BANK
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_BANK" MODIFY ("BANK_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_BANK" ADD CONSTRAINT "M_BANK_PK" PRIMARY KEY ("BANK_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_ACTIVITY_LOG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ACTIVITY_LOG" ADD CONSTRAINT "T_ACTIVITY_LOG_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table INT_SURPLUS_UNIT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT" MODIFY ("READING_DT" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_SURPLUS_UNIT" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_JOB_HDR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_JOB_HDR" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table IMPORT_CONTACT_INFO
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMPORT_CONTACT_INFO" MODIFY ("number" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_CONTACT_INFO" ADD CONSTRAINT "IMPORT_CONTACT_INFO_UK1" UNIQUE ("number")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_AMENDMENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_AMENDMENT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_AMENDMENT" ADD CONSTRAINT "T_AMENDMENT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table UV_TBL_03032020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."UV_TBL_03032020" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DUMMY_18062020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DUMMY_18062020" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_F_ENERGY_042020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_F_ENERGY_042020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_LEDGER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_LEDGER" ADD CONSTRAINT "F_ENERGY_LEDGER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BK_T_SUBSTATION_LOSS_06AUG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS_06AUG" MODIFY ("BATCH_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS_06AUG" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS_06AUG" MODIFY ("M_SUBSTATION_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS_06AUG" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS_06AUG" MODIFY ("YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_IMPORT_METER_READING
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("METER_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("MF" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("INIT_READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("FINAL_READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_SLOT1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_SLOT2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_SLOT3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_SLOT4" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_SLOT5" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_SLOT1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_SLOT2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_SLOT3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_SLOT4" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_SLOT5" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_RKVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_RKVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("IMP_KVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING" MODIFY ("EXP_KVAH" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_METER_HDRSLOT_DWNLD_03072020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_HDRSLOT_DWNLD_03072020" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_COMPANY_EMPLOYEE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_EMPLOYEE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_EMPLOYEE" ADD CONSTRAINT "M_COMPANY_EMPLOYEE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_ES_INTENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_INTENT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ES_INTENT" ADD CONSTRAINT "T_ES_INTENT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_021120
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_021120" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_021120" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_021120" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_021120" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_021120" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_T_SUBSTATION_LOSS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS" MODIFY ("BATCH_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS" MODIFY ("M_SUBSTATION_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_T_SUBSTATION_LOSS" MODIFY ("YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_SALE_ORDER_LINES_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table IMP_MR_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_MR_LINES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_MR_LINES" ADD CONSTRAINT "IMP_MR_LINES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_ORG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_ORG" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_ORG" MODIFY ("CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_ORG" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_ORG" MODIFY ("TYPE_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_ORG" ADD CONSTRAINT "M_ORG_CODE_UN" UNIQUE ("CODE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
  ALTER TABLE "OPENACCESS"."M_ORG" ADD CONSTRAINT "M_ORG_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table IMP_MC_MR_HEADER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_MC_MR_HEADER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_MC_MR_HEADER" MODIFY ("MR_SOURCE_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_MC_MR_HEADER" ADD CONSTRAINT "IMP_MC_MR_HEADER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EWA_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EWA_LINE" ADD CONSTRAINT "T_EWA_LINE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_0029_0716
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_0029_0716" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_BANKING_BALANCE_042020_WITHSURPLUS_SEG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_BANKING_BALANCE_042020_WITHSURPLUS_SEG" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_CS_ID_TABLEB
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEB" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEB" MODIFY ("T_CS_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEB" ADD CONSTRAINT "T_CS_ID_TABLEB_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_SECTION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SECTION" ADD CONSTRAINT "M_SECTION_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_LOV_HEADER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_LOV_HEADER" MODIFY ("CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_LOV_HEADER" ADD CONSTRAINT "M_LOV_HEADER_PK" PRIMARY KEY ("CODE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_METER_READING_SLOT_059414600132
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_SLOT_059414600132" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table AUTH_FEATURE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_FEATURE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."AUTH_FEATURE" ADD CONSTRAINT "AUTH_FEATURE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TMP_M_TRADE_REALTIONSHIP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_M_TRADE_REALTIONSHIP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_M_TRADE_REALTIONSHIP" MODIFY ("M_SELLER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_M_TRADE_REALTIONSHIP" MODIFY ("M_BUYER_COMPANY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_08
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_08" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_USER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."AUTH_USER" ADD CONSTRAINT "AUTH_USER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
  ALTER TABLE "OPENACCESS"."AUTH_USER" ADD CONSTRAINT "AUTH_USR_UK" UNIQUE ("USER_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_20
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_20" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_COPY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" MODIFY ("READING_YR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_COPY" MODIFY ("READING_MNTH" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TMP_GEN_STMT_CHARGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT_CHARGE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT_CHARGE" ADD CONSTRAINT "TMP_GEN_STMT_CHARGE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 5242880 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_METER_READING_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_SLOT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_METER_READING_SLOT" ADD CONSTRAINT "T_METER_READING_SLOT_PK" PRIMARY KEY ("ID")
  USING INDEX (CREATE INDEX "OPENACCESS"."T_METER_READING_SLOT_IDX" ON "OPENACCESS"."T_METER_READING_SLOT" ("ID", "T_METER_READING_HDR_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM" )  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_02
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_02" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_T_EXS_BANKING_BALANCE_30APRIL2021" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_COMPANY_SERVICE_THERMALDELETED
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE_THERMALDELETED" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE_THERMALDELETED" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table EXP_TECHNICAL_DATA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."EXP_TECHNICAL_DATA" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."EXP_TECHNICAL_DATA" MODIFY ("M_SERVICE_NUMBER" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table ENERGY_ADJ_REP_18062020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_18062020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_18062020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_18062020" MODIFY ("F_ENERGY_SALE_ORDER_LINE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_COMPANY_METER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_METER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_METER" MODIFY ("M_COMPANY_SERVICE_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_METER" ADD CONSTRAINT "M_COMPANY_METER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_USER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_USER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_USER" MODIFY ("TYPE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_USER" ADD CONSTRAINT "M_USER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_29022020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_29022020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_29022020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_29022020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_29022020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_29022020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DOWNLOAD_03072020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DOWNLOAD_03072020" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table IMP_BANKING_BALANCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_BANKING_BALANCE" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_BANKING_BALANCE" MODIFY ("GEN_SERVICE_NUMBER" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_BANKING_BALANCE" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_BANKING_BALANCE" MODIFY ("YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EWA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EWA" ADD CONSTRAINT "T_EWA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table DB
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DB" MODIFY ("DB_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DB" MODIFY ("DB_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DB" ADD CONSTRAINT "DB_P" PRIMARY KEY ("DB_KEY")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
  ALTER TABLE "OPENACCESS"."DB" ADD CONSTRAINT "DB_U1" UNIQUE ("DB_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_COMPANY_SERVICE_1219
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE_1219" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE_1219" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_04
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_04" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_01062021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_01062021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_01062021" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_01062021" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_01062021" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_01062021" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_SLOT_0029_0716
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_SLOT_0029_0716" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_CS_ID_TABLEA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEA" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEA" MODIFY ("T_CS_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEA" ADD CONSTRAINT "T_CS_ID_TABLEA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_FEATURE_211020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_FEATURE_211020" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_SIGNUP_ARKAYENERGY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SIGNUP_ARKAYENERGY" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_06
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_06" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_METER_READING_HDR_0029_0716
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_HDR_0029_0716" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GC_ID_TABLEA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEA" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEA" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEA" ADD CONSTRAINT "GC_ID_TABLEA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table UV_TBL_HISTORY_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INT_ADJUSTED_UNIT_031220
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_031220" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_031220" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_031220" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_031220" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_031220" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DUMMY_123
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DUMMY_123" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."DUMMY_123" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table UV_TBL_HISTORY_SLOT_MAR19
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_MAR19" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table TMP_GEN_SS_LOSS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_SS_LOSS" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_SS_LOSS" MODIFY ("M_SUBSTATION_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_SS_LOSS" MODIFY ("M_SERVICE_NUMBER" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_SS_LOSS" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."TMP_GEN_SS_LOSS" MODIFY ("YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_SLOT_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_SLOT_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_T_GEN_STMT_240619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_T_GEN_STMT_240619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_T_GEN_STMT_SLOT_09SEP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_T_GEN_STMT_SLOT_09SEP" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_TRADE_RELATIONSHIP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP" MODIFY ("M_SELLER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP" MODIFY ("M_BUYER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIONSHIP" ADD CONSTRAINT "M_TRADE_RELATIONSHIP_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_CHARGE_0029_0716
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_CHARGE_0029_0716" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_13
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_13" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_NEW_SERVICE_EXCESS_BANKING
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NEW_SERVICE_EXCESS_BANKING" ADD CONSTRAINT "T_NEW_SERVICE_EXCESS_BANKING_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 720896 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table UV_TBL_HISTORY_SLOT_BKP1118
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_BKP1118" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_POWERPLANT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_POWERPLANT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_POWERPLANT" ADD CONSTRAINT "M_POWERPLANT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_COMPANY_SERVICE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" ADD CONSTRAINT "M_SERVICE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 458752 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" ADD CONSTRAINT "M_COMPANY_SERVICE_UN" UNIQUE ("COMP_SER_TYPE_CODE", "number", "M_COMPANY_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 851968 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_ES_MULTIADD_HEADER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_MULTIADD_HEADER" ADD CONSTRAINT "T_ES_MULTIADD_HEADER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_FEATURE_01092020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_FEATURE_01092020" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_ENERGY_SALE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE" ADD CONSTRAINT "T_ENERGY_SALE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_ENERGY_SALE_040619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE_040619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_POWERPLANT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_POWERPLANT" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_ES_USAGE_SUMMARY_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_M_COMPANY_SERVICE_29JUL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_SERVICE_29JUL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_M_COMPANY_SERVICE_29JUL" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_TARIFF
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TARIFF" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF" MODIFY ("TYPE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF" MODIFY ("RATE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF" ADD CONSTRAINT "M_TARIFF_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_12
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_12" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GRID_CONNECTIVITY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GRID_CONNECTIVITY" ADD CONSTRAINT "GC_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" MODIFY ("CREATED_DT" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE" ADD CONSTRAINT "T_EXS_BANKING_BALANCE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_18062020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_18062020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_18062020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_18062020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_18062020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_18062020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_11
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_11" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_PPA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_PPA" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_PPA" ADD CONSTRAINT "T_PPA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table MANUAL_GS_101SS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."MANUAL_GS_101SS" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."MANUAL_GS_101SS" MODIFY ("GEN_SERVICE_NUMBER" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."MANUAL_GS_101SS" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."MANUAL_GS_101SS" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."MANUAL_GS_101SS" MODIFY ("SUBSTATION_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."MANUAL_GS_101SS" MODIFY ("ORG_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_CHARGES_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_CHARGES_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_SALE_ORDER_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table IMP_MC_MR_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_MC_MR_LINES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_MC_MR_LINES" ADD CONSTRAINT "IMP_MC_MR_LINES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 16384 NEXT 16384 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table R_TO_UPD_SEC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_TO_UPD_SEC" ADD CONSTRAINT "PK_GEN_NO" PRIMARY KEY ("GEN_NO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_030920
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_030920" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_030920" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_030920" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_030920" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_030920" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_ES_USAGE_SUMMARY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY" ADD CONSTRAINT "T_ES_USAGE_SUMMARY_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_01052020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01052020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01052020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01052020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01052020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_01052020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GC_CHECKLIST
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_CHECKLIST" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_CHECKLIST" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_CHECKLIST" ADD CONSTRAINT "GC_CHECKLIST_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_05
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_05" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_NOC_GENERATOR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR" ADD CONSTRAINT "T_NOC_GENERATOR_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_TOKEN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_TOKEN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."AUTH_TOKEN" ADD CONSTRAINT "AUTH_TOKEN_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table R_DISC_INT_ADJ
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_DISC_INT_ADJ" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_DISC_INT_ADJ" MODIFY ("READING_YR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_DISC_INT_ADJ" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_DISC_INT_ADJ" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_METER_CHANGE_FROM_AMR_HIS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_METER_CHANGE_FROM_AMR_HIS" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_039204390196
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_039204390196" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_039204390196" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_039204390196" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_039204390196" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_039204390196" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table DOC_INFO
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DOC_INFO" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GC_QUANTUM_ALLOCATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" ADD CONSTRAINT "GC_QUANTUM_ALLOCATION_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_SUBS_A
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SUBS_A" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_SUBS_A" MODIFY ("NAME" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_19
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_19" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_CS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_CS" ADD CONSTRAINT "T_CS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_SALE_ORDER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER" ADD CONSTRAINT "F_ENERGY_SALE_ORDER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER" ADD CONSTRAINT "F_ENERGY_SALE_ORDER_UK" UNIQUE ("T_ENERGY_SALE_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table HT_SERVICE_MAS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."HT_SERVICE_MAS" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."HT_SERVICE_MAS" MODIFY ("CIRCLE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_NOC_GENERATOR_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR_LINE" ADD CONSTRAINT "T_NOC_GENERATOR_LINE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_BKB4FIX_280619" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_BKB4FIX_280619" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_BKB4FIX_280619" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_BKB4FIX_280619" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_TRADE_RELATIOSHIP_28022021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIOSHIP_28022021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIOSHIP_28022021" MODIFY ("M_SELLER_COMPANY_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TRADE_RELATIOSHIP_28022021" MODIFY ("M_BUYER_COMPANY_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_COMPANY_METER_CHANGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_COMPANY_METER_CHANGE" ADD CONSTRAINT "T_COMPANY_METER_CHANGE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE079224723396
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE079224723396" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE079224723396" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE079224723396" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE079224723396" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE079224723396" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_22
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_22" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_059414600129
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_059414600129" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_SALE_ORDER_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" ADD CONSTRAINT "F_ENERGY_SALE_ORDER_LINES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_CHARGE_DEFN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_CHARGE_DEFN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_CHARGE_DEFN" ADD CONSTRAINT "M_CHARGE_DEFN_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_ES_CHARGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_CHARGE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ES_CHARGE" ADD CONSTRAINT "T_ES_CHARGE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_011220
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_011220" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_011220" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_011220" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_011220" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_011220" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_081220
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_081220" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_081220" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_081220" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_081220" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_081220" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_CHARGES_070619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_CHARGES_070619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table HT_BANKING_032020_1012
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."HT_BANKING_032020_1012" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."HT_BANKING_032020_1012" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."HT_BANKING_032020_1012" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."HT_BANKING_032020_1012" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."HT_BANKING_032020_1012" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_07
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_07" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_17
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_17" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_PROCESS_LOG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_PROCESS_LOG" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_PROCESS_LOG" ADD CONSTRAINT "T_PROCESS_LOG_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_IEX_NOC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_IEX_NOC" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_IEX_NOC" ADD CONSTRAINT "T_IEX_NOC_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_220620
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_220620" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_220620" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_220620" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_220620" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_220620" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_21
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_21" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BK_UV_TBL_HISTORY_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_UV_TBL_HISTORY_SLOT" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_TARIFF_BKP02042019
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TARIFF_BKP02042019" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF_BKP02042019" MODIFY ("TYPE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF_BKP02042019" MODIFY ("RATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_10
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_10" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BK_IMPORT_METER_READING_02AUG
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("METER_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("MF" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("INIT_READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("FINAL_READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_SLOT1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_SLOT2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_SLOT3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_SLOT4" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_SLOT5" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_SLOT1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_SLOT2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_SLOT3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_SLOT4" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_SLOT5" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_RKVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_RKVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("IMP_KVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_IMPORT_METER_READING_02AUG" MODIFY ("EXP_KVAH" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_05042021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_05042021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_05042021" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_05042021" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_05042021" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_05042021" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_ES_INTENT_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_INTENT_LINE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_ES_INTENT_LINE" ADD CONSTRAINT "T_ES_INTENT_LINE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_GENERATOR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_GENERATOR" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_GENERATOR" MODIFY ("M_POWERPLANT_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_GENERATOR" ADD CONSTRAINT "M_GENERATOR_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_18
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_18" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table IMPORT_METER_READING
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("METER_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("MF" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("INIT_READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("FINAL_READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("READING_DT_STR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_SLOT1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_SLOT2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_SLOT3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_SLOT4" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_SLOT5" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_SLOT1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_SLOT2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_SLOT3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_SLOT4" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_SLOT5" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_RKVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_RKVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("IMP_KVAH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMPORT_METER_READING" MODIFY ("EXP_KVAH" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_SUBSTATION_LOSS_210121
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS_210121" MODIFY ("BATCH_KEY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS_210121" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS_210121" MODIFY ("M_SUBSTATION_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS_210121" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_SUBSTATION_LOSS_210121" MODIFY ("YEAR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_079204740038
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_079204740038" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_079204740038" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_079204740038" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_079204740038" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_079204740038" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table AUTH_USER_ARKAY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER_ARKAY" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table AUTH_USER_TYPE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER_TYPE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."AUTH_USER_TYPE" ADD CONSTRAINT "AUTH_USER_TYPE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_COMPANY_SERVICE2708
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE2708" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE2708" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GEN_STMT" ADD CONSTRAINT "T_GEN_STMT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_SIGNUP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SIGNUP" MODIFY ("M_ORG_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_SIGNUP" ADD CONSTRAINT "M_SIGNUP_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BK_INT_ADJUSTED_UNIT_09SEP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_INT_ADJUSTED_UNIT_09SEP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJUSTED_UNIT_09SEP" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJUSTED_UNIT_09SEP" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJUSTED_UNIT_09SEP" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJUSTED_UNIT_09SEP" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_30042020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_30042020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_30042020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_30042020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_30042020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_30042020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_JANFEB2020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_JANFEB2020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_JANFEB2020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_JANFEB2020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_JANFEB2020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_JANFEB2020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_FEEDER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_FEEDER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_FEEDER" MODIFY ("NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_FEEDER" ADD CONSTRAINT "M_FEEDER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 196608 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table F_AGREEMENT_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_14
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_14" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_PAYMENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_PAYMENT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_PAYMENT" ADD CONSTRAINT "T_ES_PAYMENTS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_TARIFF_REPORT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_TARIFF_REPORT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF_REPORT" MODIFY ("TYPE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_TARIFF_REPORT" MODIFY ("RATE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_INT_SURPLUS_APR01
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" MODIFY ("READING_DT" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_SURPLUS_APR01" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INT_ADJUSTED_UNIT_01052020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01052020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01052020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01052020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01052020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT_01052020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GEN_OTHER_CHARGES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_OTHER_CHARGES" ADD CONSTRAINT "T_GEN_OTHER_CHARGES_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ENERGY_ADJ_REP_19062020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020" MODIFY ("F_ENERGY_SALE_ORDER_LINE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table H_DELETE_TXN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("AUTH_USER_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("AUTH_USER_NAME" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("DEL_TXN_PURPOSE_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("STATUS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("DATE_TIME_STAMP" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("RESULT_DESC" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("COLUMN1" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("COLUMN2" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("COLUMN3" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."H_DELETE_TXN" MODIFY ("ENABLED" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table INT_ADJUSTED_UNIT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."INT_ADJUSTED_UNIT" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_INPRINCIPLE_APPLN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_USER_019104041981
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER_019104041981" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_ES_CHARGE_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_CHARGE_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table UV_TBL_HISTORY_SLOT_03FEB19
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_03FEB19" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BACKUP_F_ENERGY_ADJUSTMET_082020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BACKUP_F_ENERGY_ADJUSTMET_082020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_F_ENERGY_ADJUSTMET_082020" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_F_ENERGY_ADJUSTMET_082020" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_F_ENERGY_ADJUSTMET_082020" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BACKUP_F_ENERGY_ADJUSTMET_082020" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_LAPSED_BALANCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" MODIFY ("CREATED_DT" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_LAPSED_BALANCE" ADD CONSTRAINT "T_EXS_LAPSED_BALANCE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table IMP_TECHNICAL_DATA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_TECHNICAL_DATA" MODIFY ("REMARKS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_TECHNICAL_DATA" MODIFY ("M_SERVICE_NUMBER" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table NAME_CHANGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."NAME_CHANGE" ADD CONSTRAINT "SERVICENO_PK" PRIMARY KEY ("SERVICENO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ENERGY_ADJ_REP_19062020_MY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020_MY" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020_MY" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."ENERGY_ADJ_REP_19062020_MY" MODIFY ("F_ENERGY_SALE_ORDER_LINE_ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table OA_MANUAL_26022020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."OA_MANUAL_26022020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."OA_MANUAL_26022020" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_EXS_BANKING_BALANCE_30072020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_30072020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_30072020" MODIFY ("READING_MONTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_30072020" MODIFY ("READING_YEAR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_30072020" MODIFY ("CREATED_BY" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_EXS_BANKING_BALANCE_30072020" MODIFY ("CREATED_DT" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_INT_ADJ_UNIT_02SEP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_INT_ADJ_UNIT_02SEP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJ_UNIT_02SEP" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJ_UNIT_02SEP" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJ_UNIT_02SEP" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_INT_ADJ_UNIT_02SEP" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_BANKING_ACTIVITY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_BANKING_ACTIVITY" ADD CONSTRAINT "T_BANKING_ACTIVITY_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_METER_READING_HDR_019104041686
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_HDR_019104041686" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table SYS_EXPORT_SCHEMA_03
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."SYS_EXPORT_SCHEMA_03" ADD UNIQUE ("PROCESS_ORDER", "DUPLICATE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_POWERPLANT_181120
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_POWERPLANT_181120" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_METER_READING_SLOT_059414600125
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_SLOT_059414600125" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_BETA_WIND_FARM_POWERPLANT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_BETA_WIND_FARM_POWERPLANT" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table BK_F_ENERGY_ADJUSTMET_09SEP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET_09SEP" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET_09SEP" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET_09SEP" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET_09SEP" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."BK_F_ENERGY_ADJUSTMET_09SEP" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table F_ENERGY_ADJUSTMET_19052021
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_19052021" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_19052021" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_19052021" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_19052021" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."F_ENERGY_ADJUSTMET_19052021" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_INPRINCIPLE_APPLN_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_LINE_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_OAA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table AUTH_USER_TYPE_ACCESS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_USER_TYPE_ACCESS" ADD CONSTRAINT "AUTH_TYPE_ACCESS" UNIQUE ("TRANSACTION_TYPE_CODE", "USER_TYPE_CODE", "FUEL_GROUP_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GRID_CONN_APPLN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GRID_CONN_APPLN" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GRID_CONN_APPLN" MODIFY ("STATUS" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GRID_CONN_APPLN" ADD CONSTRAINT "T_GRID_CONN_APPLN_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_COMPANY_SERVICE_02JAN2020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE_02JAN2020" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE_02JAN2020" MODIFY ("COMP_SER_TYPE_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_DISC_F_ENERGY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_DISC_F_ENERGY" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_DISC_F_ENERGY" MODIFY ("READING_YR" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_DISC_F_ENERGY" MODIFY ("SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_DISC_F_ENERGY" MODIFY ("SUPLR_CODE" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table M_SIGNUP_TRADE_REL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SIGNUP_TRADE_REL" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_SIGNUP_TRADE_REL" ADD CONSTRAINT "M_SIGNUP_TRADE_REL_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 2097152 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_BANKING_BALANCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_BANKING_BALANCE" ADD CONSTRAINT "T_BANKING_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GEN_STMT_CHARGE_BKB4FIX_280619
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_CHARGE_BKB4FIX_280619" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table IMP_MR_HEADER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_MR_HEADER" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_MR_HEADER" MODIFY ("MR_SOURCE_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."IMP_MR_HEADER" ADD CONSTRAINT "IMP_MDMS_HEADER_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table T_GC_APPLICATION_STATUS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_APPLICATION_STATUS" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_APPLICATION_STATUS" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_APPLICATION_STATUS" ADD CONSTRAINT "GC_APPLICATION_STATUS_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table BK_ENERGY_SALE_APR01
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."BK_ENERGY_SALE_APR01" MODIFY ("ID" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table R_SURPLUS_CASES_FROM_HT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" MODIFY ("BUYER_SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" MODIFY ("SELLER_SERVICE_NO" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" MODIFY ("SELLER_TYPE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" MODIFY ("SELLER_NAME" NOT NULL DISABLE);
  ALTER TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" MODIFY ("READING_MNTH" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."R_SURPLUS_CASES_FROM_HT" MODIFY ("READING_YR" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_GC_GEN_UNIT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_GEN_UNIT" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_GEN_UNIT" MODIFY ("GC_ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_GC_GEN_UNIT" ADD CONSTRAINT "GC_GEN_UNIT_PK" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table UV_TBL_HISTORY_SLOT_READG_FEB2020
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."UV_TBL_HISTORY_SLOT_READG_FEB2020" MODIFY ("METERNO" NOT NULL ENABLE);
--------------------------------------------------------
--  Constraints for Table T_IPA_STANDING_CLEARACE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_IPA_STANDING_CLEARACE" MODIFY ("ID" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."T_IPA_STANDING_CLEARACE" ADD CONSTRAINT "T_IPA_STANDING_CLEARACE" PRIMARY KEY ("ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Constraints for Table M_LOV_DETAIL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_LOV_DETAIL" MODIFY ("M_LOV_CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_LOV_DETAIL" MODIFY ("CODE" NOT NULL ENABLE);
  ALTER TABLE "OPENACCESS"."M_LOV_DETAIL" ADD CONSTRAINT "M_LOV_DETAIL_PK" PRIMARY KEY ("CODE", "M_LOV_CODE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "SYSTEM"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table AUTH_TOKEN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."AUTH_TOKEN" ADD CONSTRAINT "AUTH_TOKEN_FK" FOREIGN KEY ("AUTH_USER_ID")
	  REFERENCES "OPENACCESS"."AUTH_USER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table DB
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DB" ADD CONSTRAINT "DB_F1" FOREIGN KEY ("CURR_DBINC_KEY")
	  REFERENCES "OPENACCESS"."DBINC" ("DBINC_KEY") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table DBINC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."DBINC" ADD CONSTRAINT "DBINC_F1" FOREIGN KEY ("DB_KEY")
	  REFERENCES "OPENACCESS"."DB" ("DB_KEY") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table F_AGREEMENT_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK5" FOREIGN KEY ("T_NOC_ID")
	  REFERENCES "OPENACCESS"."T_NOC" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK6" FOREIGN KEY ("T_CONSENT_ID")
	  REFERENCES "OPENACCESS"."T_CONSENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK3" FOREIGN KEY ("BUYER_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK7" FOREIGN KEY ("T_EWA_LINE_ID")
	  REFERENCES "OPENACCESS"."T_EWA_LINE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK2" FOREIGN KEY ("BUYER_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK10" FOREIGN KEY ("T_STANDING_CLEARENCE_ID")
	  REFERENCES "OPENACCESS"."T_STANDING_CLEARENCE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK4" FOREIGN KEY ("T_ES_INTENT_LINE_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT_LINE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK1" FOREIGN KEY ("BUYER_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK11" FOREIGN KEY ("F_AGREEMENT_ID")
	  REFERENCES "OPENACCESS"."F_AGREEMENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK9" FOREIGN KEY ("T_NOC_GENERATOR_LINE_ID")
	  REFERENCES "OPENACCESS"."T_NOC_GENERATOR_LINE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_AGREEMENT_LINE" ADD CONSTRAINT "F_AGREEMENT_LINE_FK8" FOREIGN KEY ("T_INPRINCIPLE_APPLN_LINE_ID")
	  REFERENCES "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table F_ENERGY_CHARGES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_CHARGES" ADD CONSTRAINT "F_ENERGY_CHARGES_FK" FOREIGN KEY ("F_ENERGY_SALE_ORDER_ID")
	  REFERENCES "OPENACCESS"."F_ENERGY_SALE_ORDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_ENERGY_CHARGES" ADD CONSTRAINT "F_ENERGY_CHARGES_FK1" FOREIGN KEY ("M_COMPANY_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table F_ENERGY_LEDGER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_LEDGER" ADD CONSTRAINT "F_ENERGY_LEDGER_FK4" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_ENERGY_LEDGER" ADD CONSTRAINT "F_ENERGY_LEDGER_FK1" FOREIGN KEY ("F_ENERGY_SALE_ORDER_ID")
	  REFERENCES "OPENACCESS"."F_ENERGY_SALE_ORDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."F_ENERGY_LEDGER" ADD CONSTRAINT "F_ENERGY_LEDGER_FK3" FOREIGN KEY ("M_COMPANY_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") DISABLE;
  ALTER TABLE "OPENACCESS"."F_ENERGY_LEDGER" ADD CONSTRAINT "F_ENERGY_LEDGER_FK2" FOREIGN KEY ("M_COMPANY_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table F_ENERGY_SALE_ORDER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER" ADD CONSTRAINT "F_ENERGY_SALE_ORDER_FK" FOREIGN KEY ("T_ENERGY_SALE_ID")
	  REFERENCES "OPENACCESS"."T_ENERGY_SALE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table F_ENERGY_SALE_ORDER_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."F_ENERGY_SALE_ORDER_LINES" ADD CONSTRAINT "F_ENERGY_SALE_ORDER_LINES_FK" FOREIGN KEY ("F_ENERGY_SALE_ORDER_ID")
	  REFERENCES "OPENACCESS"."F_ENERGY_SALE_ORDER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table IMP_MC_MR_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_MC_MR_LINES" ADD CONSTRAINT "IMP_MC_MR_LINES_IMP_MC_MR_HEADER_FK" FOREIGN KEY ("IMP_MC_MR_HEADER_ID")
	  REFERENCES "OPENACCESS"."IMP_MC_MR_HEADER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table IMP_MR_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."IMP_MR_LINES" ADD CONSTRAINT "IMP_MR_LINES_IMP_MR_HEADER_FK" FOREIGN KEY ("IMP_MR_HEADER_ID")
	  REFERENCES "OPENACCESS"."IMP_MR_HEADER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_CHARGES_MAP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_CHARGES_MAP" ADD CONSTRAINT "M_CHARGES_MAP_FK" FOREIGN KEY ("M_CHARGE_ID")
	  REFERENCES "OPENACCESS"."M_CHARGE_DEFN" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_COMPANY_METER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_METER" ADD CONSTRAINT "M_COMPANY_METER_M_SERVICE_FK" FOREIGN KEY ("M_COMPANY_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_COMPANY_SERVICE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" ADD CONSTRAINT "M_SERVICE_M_FEEDER_FK" FOREIGN KEY ("M_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" ADD CONSTRAINT "M_SERVICE_M_COMPANY_FK" FOREIGN KEY ("M_COMPANY_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_COMPANY_SERVICE" ADD CONSTRAINT "M_SERVICE_M_ORG_FK" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_GENERATOR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_GENERATOR" ADD CONSTRAINT "M_GENERATOR_M_POWERPLANT_FK" FOREIGN KEY ("M_POWERPLANT_ID")
	  REFERENCES "OPENACCESS"."M_POWERPLANT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_POWERPLANT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_POWERPLANT" ADD CONSTRAINT "M_POWERPLANT_M_SUBSTATION_FK" FOREIGN KEY ("M_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_POWERPLANT" ADD CONSTRAINT "M_POWERPLANT_M_SERVICE_FK" FOREIGN KEY ("M_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_POWERPLANT" ADD CONSTRAINT "M_POWERPLANT_M_ORG_FK" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_SIGNUP
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SIGNUP" ADD CONSTRAINT "M_SIGNUP_M_SUBSTATION_FK" FOREIGN KEY ("M_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_SIGNUP" ADD CONSTRAINT "M_SIGNUP_M_ORG_FK" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_SIGNUP" ADD CONSTRAINT "M_SIGNUP_M_FEEDER_FK" FOREIGN KEY ("M_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_SIGNUP_TRADE_REL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SIGNUP_TRADE_REL" ADD CONSTRAINT "M_SIGNUP_TRADE_REL_FK" FOREIGN KEY ("M_BUYER_COMPANY_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_SIGNUP_TRADE_REL" ADD CONSTRAINT "M_SIGNUP_TRADE_REL_FK2" FOREIGN KEY ("M_SIGNUP_ID")
	  REFERENCES "OPENACCESS"."M_SIGNUP" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."M_SIGNUP_TRADE_REL" ADD CONSTRAINT "M_SIGNUP_TRADE_REL_FK1" FOREIGN KEY ("M_BUYER_COMP_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_SUBSTATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_SUBSTATION" ADD CONSTRAINT "M_SUBSTATION_M_ORG_FK" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table M_USER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."M_USER" ADD CONSTRAINT "M_USER_M_COMPANY_FK" FOREIGN KEY ("M_COMPANY_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY" ("ID") DISABLE;
  ALTER TABLE "OPENACCESS"."M_USER" ADD CONSTRAINT "M_USER_M_ORG_FK" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") DISABLE;
--------------------------------------------------------
--  Ref Constraints for Table TMP_GEN_STMT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT" ADD CONSTRAINT "TMP_GEN_STMT_FK" FOREIGN KEY ("M_COMPANY_METER_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_METER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TMP_GEN_STMT_CHARGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT_CHARGE" ADD CONSTRAINT "TMP_GEN_STMT_CHARGE_FK" FOREIGN KEY ("TMP_GEN_STMT_ID")
	  REFERENCES "OPENACCESS"."TMP_GEN_STMT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TMP_GEN_STMT_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."TMP_GEN_STMT_SLOT" ADD CONSTRAINT "TMP_GEN_STMT_SLOT_FK" FOREIGN KEY ("TMP_GEN_STMT_ID")
	  REFERENCES "OPENACCESS"."TMP_GEN_STMT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_BANKING_ACTIVITY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_BANKING_ACTIVITY" ADD CONSTRAINT "T_BANKING_ACTIVITY_FK" FOREIGN KEY ("T_ENERGY_SALE_ID")
	  REFERENCES "OPENACCESS"."T_ENERGY_SALE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_BANKING_BALANCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_BANKING_BALANCE" ADD CONSTRAINT "T_BANKING_FK" FOREIGN KEY ("M_COMPANY_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_COMPANY_METER_CHANGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_COMPANY_METER_CHANGE" ADD CONSTRAINT "T_COMPANY_METER_CHANGE_FK" FOREIGN KEY ("M_COMPANY_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_COMPANY_NAME_CHANGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_COMPANY_NAME_CHANGE" ADD CONSTRAINT "T_COMPANY_NAME_CHANGE_FK" FOREIGN KEY ("M_COMPANY_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_CONSENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK3" FOREIGN KEY ("BUYER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK2" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK5" FOREIGN KEY ("DRAWAL_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK6" FOREIGN KEY ("DRAWAL_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK8" FOREIGN KEY ("INJECTION_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK4" FOREIGN KEY ("SELLER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CONSENT" ADD CONSTRAINT "T_CONSENT_FK7" FOREIGN KEY ("INJECTION_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_CS_ID_TABLEA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEA" ADD CONSTRAINT "T_CS_ID_TABLEA_FK" FOREIGN KEY ("T_CS_ID")
	  REFERENCES "OPENACCESS"."T_CS" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_CS_ID_TABLEB
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_ID_TABLEB" ADD CONSTRAINT "T_CS_ID_TABLEB_FK" FOREIGN KEY ("T_CS_ID")
	  REFERENCES "OPENACCESS"."T_CS" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_CS_LOAN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_LOAN" ADD CONSTRAINT "T_CS_LOAN_FK" FOREIGN KEY ("T_CS_ID")
	  REFERENCES "OPENACCESS"."T_CS" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_CS_QUANTUM_ALLOCATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" ADD CONSTRAINT "T_CS_QUANTUM_ALLOCATION_FK" FOREIGN KEY ("T_CS_ID")
	  REFERENCES "OPENACCESS"."T_CS" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" ADD CONSTRAINT "T_CS_QUANTUM_ALLOCATION_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_CS_QUANTUM_ALLOCATION" ADD CONSTRAINT "T_CS_QUANTUM_ALLOCATION_FK2" FOREIGN KEY ("BUYER_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ENERGY_SALE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE" ADD CONSTRAINT "T_ENERGY_SALE_FK2" FOREIGN KEY ("SELLER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE" ADD CONSTRAINT "T_ENERGY_SALE_FK3" FOREIGN KEY ("T_GEN_STMT_ID")
	  REFERENCES "OPENACCESS"."T_GEN_STMT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ENERGY_SALE" ADD CONSTRAINT "T_ENERGY_SALE_FK1" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_EPA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EPA" ADD CONSTRAINT "T_EPA_FK2" FOREIGN KEY ("SELLER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EPA" ADD CONSTRAINT "T_EPA_FK1" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EPA" ADD CONSTRAINT "T_EPA_FK" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_EPA_LINES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EPA_LINES" ADD CONSTRAINT "T_EPA_LINES_FK" FOREIGN KEY ("T_EPA_ID")
	  REFERENCES "OPENACCESS"."T_EPA" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EPA_LINES" ADD CONSTRAINT "T_EPA_LINES_FK1" FOREIGN KEY ("M_GENERATOR_ID")
	  REFERENCES "OPENACCESS"."M_GENERATOR" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ES_CHARGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_CHARGE" ADD CONSTRAINT "T_ES_CHARGE_FK" FOREIGN KEY ("T_ENERGY_SALE_ID")
	  REFERENCES "OPENACCESS"."T_ENERGY_SALE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ES_CHARGE" ADD CONSTRAINT "T_ES_CHARGE_FK1" FOREIGN KEY ("M_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ES_INTENT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_INTENT" ADD CONSTRAINT "T_ES_INTENT_FK1" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ES_INTENT_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_INTENT_LINE" ADD CONSTRAINT "T_ES_INTENT_LINE_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ES_INTENT_LINE" ADD CONSTRAINT "T_ES_INTENT_LINE_FK2" FOREIGN KEY ("T_EST_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ES_MULTIADD_HEADER
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_MULTIADD_HEADER" ADD CONSTRAINT "T_ES_MULTIADD_HEADER_FK" FOREIGN KEY ("T_ES_ID")
	  REFERENCES "OPENACCESS"."T_ENERGY_SALE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ES_USAGE_DETAIL
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_USAGE_DETAIL" ADD CONSTRAINT "T_ES_USAGE_DETAIL_FK2" FOREIGN KEY ("T_ENERGY_SALE_ID")
	  REFERENCES "OPENACCESS"."T_ENERGY_SALE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ES_USAGE_DETAIL" ADD CONSTRAINT "T_ES_USAGE_DETAIL_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_ES_USAGE_SUMMARY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY" ADD CONSTRAINT "T_ES_USAGE_SUMMARY_FK2" FOREIGN KEY ("T_ENERGY_SALE_ID")
	  REFERENCES "OPENACCESS"."T_ENERGY_SALE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY" ADD CONSTRAINT "T_ES_USAGE_SUMMARY_FK" FOREIGN KEY ("BUYER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_ES_USAGE_SUMMARY" ADD CONSTRAINT "T_ES_USAGE_SUMMARY_FK1" FOREIGN KEY ("BUYER_END_SS_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_EWA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EWA" ADD CONSTRAINT "T_EWA_FK1" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EWA" ADD CONSTRAINT "T_EWA_FK" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EWA" ADD CONSTRAINT "T_EWA_FK2" FOREIGN KEY ("SELLER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_EWA_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_EWA_LINE" ADD CONSTRAINT "T_EWA_LINE_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EWA_LINE" ADD CONSTRAINT "T_EWA_LINE_FK" FOREIGN KEY ("T_EWA_ID")
	  REFERENCES "OPENACCESS"."T_EWA" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_EWA_LINE" ADD CONSTRAINT "T_EWA_LINE_FK2" FOREIGN KEY ("BUYER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_APPLICATION_STATUS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_APPLICATION_STATUS" ADD CONSTRAINT "GC_APPLICATION_STATUS_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_CHECKLIST
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_CHECKLIST" ADD CONSTRAINT "GC_CHECKLIST_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_GEN_UNIT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_GEN_UNIT" ADD CONSTRAINT "GC_GEN_UNIT_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_ID_TABLEA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEA" ADD CONSTRAINT "GC_ID_TABLEA_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_ID_TABLEB
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_ID_TABLEB" ADD CONSTRAINT "GC_ID_TABLEB_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_LOAN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_LOAN" ADD CONSTRAINT "GC_LOAN_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_QUANTUM_ALLOCATION
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" ADD CONSTRAINT "GC_QUANTUM_ALLOCATION_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" ADD CONSTRAINT "GC_QUANTUM_ALLOCATION_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_GC_QUANTUM_ALLOCATION" ADD CONSTRAINT "GC_QUANTUM_ALLOCATION_FK2" FOREIGN KEY ("BUYER_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GC_TRANSFORMERS
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GC_TRANSFORMERS" ADD CONSTRAINT "GC_TRANSFORMERS_FK" FOREIGN KEY ("GC_ID")
	  REFERENCES "OPENACCESS"."T_GRID_CONNECTIVITY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GEN_OTHER_CHARGES
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_OTHER_CHARGES" ADD CONSTRAINT "T_GEN_OTHER_CHARGES_FK1" FOREIGN KEY ("M_COMPANY_SERVICE_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GEN_STMT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT" ADD CONSTRAINT "T_GEN_STMT_FK" FOREIGN KEY ("M_COMPANY_METER_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_METER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GEN_STMT_CHARGE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_CHARGE" ADD CONSTRAINT "T_GEN_STMT_CHARGE_FK" FOREIGN KEY ("T_GEN_STMT_ID")
	  REFERENCES "OPENACCESS"."T_GEN_STMT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GEN_STMT_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GEN_STMT_SLOT" ADD CONSTRAINT "T_GEN_STMT_SLOT_FK" FOREIGN KEY ("T_GEN_STMT_ID")
	  REFERENCES "OPENACCESS"."T_GEN_STMT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_GRID_CONNECTIVITY
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_GRID_CONNECTIVITY" ADD CONSTRAINT "GC_FK2" FOREIGN KEY ("FINAL_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_GRID_CONNECTIVITY" ADD CONSTRAINT "GC_FK1" FOREIGN KEY ("FINAL_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_GRID_CONNECTIVITY" ADD CONSTRAINT "GC_FK" FOREIGN KEY ("M_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_IEX_NOC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_IEX_NOC" ADD CONSTRAINT "T_IEX_NOC_FK2" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_IEX_NOC" ADD CONSTRAINT "T_IEX_NOC_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_INPRINCIPLE_APPLN
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_FK1" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_FK2" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_INPRINCIPLE_APPLN_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_LINE_FK2" FOREIGN KEY ("BUYER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_LINE_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_INPRINCIPLE_APPLN_LINE" ADD CONSTRAINT "T_INPRINCIPLE_APPLN_LINE_FK" FOREIGN KEY ("T_INPRINCIPLE_APPLN_ID")
	  REFERENCES "OPENACCESS"."T_INPRINCIPLE_APPLN" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_IPA_STANDING_CLEARACE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_IPA_STANDING_CLEARACE" ADD CONSTRAINT "T_IPA_STANDING_CLEARACE_FK2" FOREIGN KEY ("T_IPA_ID")
	  REFERENCES "OPENACCESS"."T_INPRINCIPLE_APPLN" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_IPA_STANDING_CLEARACE" ADD CONSTRAINT "T_IPA_STANDING_CLEARACE_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_METER_READING_HDR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_HDR" ADD CONSTRAINT "T_METER_READING_FK1" FOREIGN KEY ("M_COMPANY_METER_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_METER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_METER_READING_SLOT
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_METER_READING_SLOT" ADD CONSTRAINT "T_METER_READING_SLOT_FK1" FOREIGN KEY ("T_METER_READING_HDR_ID")
	  REFERENCES "OPENACCESS"."T_METER_READING_HDR" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_NEW_SERVICE_EXCESS_BANKING
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NEW_SERVICE_EXCESS_BANKING" ADD CONSTRAINT "T_NEW_SERVICE_EXCESS_BANKING_FK" FOREIGN KEY ("M_COMPANY_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_NOC
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NOC" ADD CONSTRAINT "T_NOC_FK2" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_NOC" ADD CONSTRAINT "T_NOC_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_NOC_GENERATOR
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR" ADD CONSTRAINT "T_NOC_GENERATOR_FK3" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR" ADD CONSTRAINT "T_NOC_GENERATOR_FK4" FOREIGN KEY ("M_SUBSTATION_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR" ADD CONSTRAINT "T_NOC_GENERATOR_FK1" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR" ADD CONSTRAINT "T_NOC_GENERATOR_FK2" FOREIGN KEY ("M_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_NOC_GENERATOR_LINE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR_LINE" ADD CONSTRAINT "T_NOC_GENERATOR_LINE_FK2" FOREIGN KEY ("BUYER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR_LINE" ADD CONSTRAINT "T_NOC_GENERATOR_LINE_FK" FOREIGN KEY ("T_NOC_GENERATOR_ID")
	  REFERENCES "OPENACCESS"."T_NOC_GENERATOR" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_NOC_GENERATOR_LINE" ADD CONSTRAINT "T_NOC_GENERATOR_LINE_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_OAA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK2" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK5" FOREIGN KEY ("DRAWAL_TRANS_SS_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK6" FOREIGN KEY ("DRAWAL_DIST_SS_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK10" FOREIGN KEY ("INJECTION_TRANS_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK8" FOREIGN KEY ("INJECTION_TRANS_SS_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK9" FOREIGN KEY ("INJECTION_DIST_SS_ID")
	  REFERENCES "OPENACCESS"."M_SUBSTATION" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK3" FOREIGN KEY ("BUYER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK7" FOREIGN KEY ("DRAWAL_TRANS_FEEDER_ID")
	  REFERENCES "OPENACCESS"."M_FEEDER" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_OAA" ADD CONSTRAINT "T_OAA_FK4" FOREIGN KEY ("SELLER_END_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_PPA
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_PPA" ADD CONSTRAINT "T_PPA_FK1" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_PPA" ADD CONSTRAINT "T_PPA_FK2" FOREIGN KEY ("SELLER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_PPA" ADD CONSTRAINT "T_PPA_FK" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table T_STANDING_CLEARENCE
--------------------------------------------------------

  ALTER TABLE "OPENACCESS"."T_STANDING_CLEARENCE" ADD CONSTRAINT "T_STANDING_CLEARENCE_FK1" FOREIGN KEY ("M_ORG_ID")
	  REFERENCES "OPENACCESS"."M_ORG" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_STANDING_CLEARENCE" ADD CONSTRAINT "T_STANDING_CLEARENCE_FK2" FOREIGN KEY ("T_ES_INTENT_ID")
	  REFERENCES "OPENACCESS"."T_ES_INTENT" ("ID") ENABLE;
  ALTER TABLE "OPENACCESS"."T_STANDING_CLEARENCE" ADD CONSTRAINT "T_STANDING_CLEARENCE_FK" FOREIGN KEY ("BUYER_COMP_SERV_ID")
	  REFERENCES "OPENACCESS"."M_COMPANY_SERVICE" ("ID") ENABLE;
