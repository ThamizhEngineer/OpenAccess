CREATE OR REPLACE package dbms_rcvman authid current_user is
 
--
 
--
--
--
 
TRUE#  CONSTANT number := 1;
FALSE# CONSTANT number := 0;
 
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
 
COPY                  CONSTANT NUMBER :=  1; -- any image copy of a file
FULL_DF_BACKUP        CONSTANT NUMBER :=  2; -- datafile in a full backup set
INCREMENTAL_DF_BACKUP CONSTANT NUMBER :=  3; -- datafile in an incr backup set
BACKUP                CONSTANT NUMBER :=  4; -- any file in a backup set
--
OFFLINE_RANGE         CONSTANT NUMBER :=  5; -- an offline range
CUMULATIVE            CONSTANT NUMBER :=  6; -- cumulative incremental
--
PROXY                 CONSTANT NUMBER :=  7; -- any proxy copy of a file
NONPROXY              CONSTANT NUMBER  := 9; -- any img, bs other than proxy
AVMCOPY               CONSTANT NUMBER := 10; -- only avm image copy of a file
SPARSE                CONSTANT NUMBER := 11; -- for sparse backup
NONSPARSE             CONSTANT NUMBER := 12; -- for nonsparse backup
 
--
 
implicitOfflRange CONSTANT NUMBER := 2**0;
cleanRange        CONSTANT NUMBER := 2**1;
applyOfflRange    CONSTANT NUMBER := 2**2;
dfCopy            CONSTANT NUMBER := 2**3;
proxyFull         CONSTANT NUMBER := 2**4;
buSet             CONSTANT NUMBER := 2**5;
applyIncremental  CONSTANT NUMBER := 2**6;
redo              CONSTANT NUMBER := 2**7;
 
--
maxKind           CONSTANT NUMBER := redo;            -- last real kind above
allKind           CONSTANT NUMBER := (maxKind*2) - 1; -- all real backup types
fullKind          CONSTANT NUMBER := dfCopy + proxyFull + buSet;
tagKind           CONSTANT NUMBER := fullKind + applyIncremental;
 
--
deletedKind       CONSTANT NUMBER := maxKind*2;      -- action deleted
 
--
--
--
 
BSavailable     CONSTANT BINARY_INTEGER := 2**0;
BSunavailable   CONSTANT BINARY_INTEGER := 2**1;
BSdeleted       CONSTANT BINARY_INTEGER := 2**2;
BSexpired       CONSTANT BINARY_INTEGER := 2**3;
--
--
--
--
BSpartial_avail CONSTANT BINARY_INTEGER := 2**4;
 
 
--
--
--
BSdatafile_full  CONSTANT BINARY_INTEGER := 2**0;
BSdatafile_incr  CONSTANT BINARY_INTEGER := 2**1;
BSarchivelog     CONSTANT BINARY_INTEGER := 2**2;
 
--
--
--
BScfile_all      CONSTANT BINARY_INTEGER := 2**0;      -- shouldn't be altered
BScfile_auto     CONSTANT BINARY_INTEGER := 2**1;
 
--
--
--
 
TYPE dfRec_t IS RECORD
(
   dfNumber             number,
   dfCreationSCN        number,
   dfCreationTime       date,
   fileName             varchar2(1024),
   tsName               varchar2(30),
   tsNumber             number,
   status               number,
   blocks               number,
   blockSize            number,
   kbytes               number,
   unrecovSCN           number,
   stopSCN              number,
   readOnly             number,
   rfNumber             number,
   inBackup             number,     -- if greater than 0 then
--
   auxName              varchar2(1024),
   dbincKey             number,
   dfOfflineSCN         number, 
   dfOnlineSCN          number, 
   dfOnlineTime         date,
   encrypt              number,     -- encrypt value 1=ON, 2=OFF, 3=CLEAR
   foreignDbid          number,         -- foreign database id
   pluggedRonly         binary_integer, -- 1 for read-only. Otherwise, 0
   pluginSCN            number,         -- plugin change#
   pluginRlgSCN         number,         -- plugin resetlogs_change#
   pluginRlgTime        date,           -- plugin resetlogs_time
   newDfCreationSCN     number,         -- plugin scn or creation scn
   creation_thread      number,         -- creation thread
   creation_size        number,         -- creation size
   pdbId                number,         -- pdbid
   pdbKey               number,         -- pdbKey
   pdbName              varchar2(128),  -- pdbname
   pdbClosed            number,         -- pdbclosed
   pdbForeignDbid       number, -- dbid of PDB from which this file came from
   noBackupPdb          number          -- this PDB is excluded from backup
);
 
TYPE prePluginDfRec_t IS RECORD
(
   dfNumber             number,
   pdbId                number,
   prePluginDfNumber    number
);
   
--
--
--
 
TYPE tfRec_t IS RECORD
(
   tfNumber             number,
   tfCreationSCN        number,
   tfCreationTime       date,
   fileName             varchar2(1024),
   tsName               varchar2(30),
   tsNumber             number,
   status               number,
   isSFT                varchar2(3),
   blocks               number,
   blockSize            number,
   maxSize              number,
   nextSize             number,
   rfNumber             number,
   dbincKey             number,
   pdbId                number,
   pdbKey               number,
   pdbName              varchar2(128)
);
 
--
--
--
 
TYPE alRec_t IS RECORD
(
   key                  number,
   recid                number,
   stamp                number,
   thread               number,
   sequence             number,
   fileName             varchar2(1024),
   lowSCN               number,
   lowTime              date,
   nextSCN              number,
   nextTime             date,
   rlgSCN               number,
   rlgTime              date,
   blocks               number,
   blockSize            number,
   status               varchar2(1),
   compTime             date,
   duplicate            number,
   isrdf                varchar2(3),
   compressed           varchar2(3),
   stby                 varchar2(1),
   terminal             varchar2(3),
   site_key             number,
   site_key_order_col   number,
   source_dbid          number
);
 
--
--
--
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
 
--
 
--
--
--
 
TYPE rcvRec_t IS RECORD
(
--
 
   type_con             number,         -- recovery container type
   key_con              number,         -- primary key
   recid_con            number,         -- recid
   stamp_con            number,         -- stamp
   setStamp_con         number,         -- set count if backup set (null)
   setCount_con         number,         -- set stamp if backup set (null)
   bsRecid_con          number,         -- backup set recid (null)
   bsStamp_con          number,         -- backup set stamp (null)
   bsKey_con            number,         -- backup set key (null)
   bsLevel_con          number,         -- backup set level (null)
   bsType_con           varchar2(1),    -- backup set type
   elapseSecs_con       number,         -- backup set elapse seconds (null)
   pieceCount_con       number,         -- backup set piece count (null)
   fileName_con         varchar2(1024), -- filename if a copy (or) piece (null)
   tag_con              varchar2(32),   -- tag (null)
--
--
   copyNumber_con       number,         -- backup set copy# (null) maxlimit 256
--
   status_con           varchar2(1),    -- status (null)
   blocks_con           number,         -- size of file in blocks (null)
   blockSize_con        number,         -- block size (null)
   deviceType_con       varchar2(255),  -- device type required (null)
--
--
   compTime_con         date,           -- completion time
   cfCreationTime_con   date,           -- controlfile creation time if
--
   pieceNumber_con      number,
   bpCompTime_con       date,
   bpCompressed_con     varchar2(3),
 
   multi_section_con    varchar2(1),    -- multi-section backup piece
 
--
 
   type_act             number,         -- recovery action type
   fromSCN_act          number,
   toSCN_act            number,
   toTime_act           date,
   rlgSCN_act           number,
   rlgTime_act          date,
   dbincKey_act         number,
   level_act            number,
   section_size_act     number,
 
--
 
   dfNumber_obj         number,
   dfCreationSCN_obj    number,
   cfSequence_obj       number,        -- controlfile autobackup sequence
   cfDate_obj           date,          -- controlfile autobackup date
   logSequence_obj      number,
   logThread_obj        number,
   logRlgSCN_obj        number,
   logRlgTime_obj       date,
   logLowSCN_obj        number,
   logLowTime_obj       date,
   logNextSCN_obj       number,
   logNextTime_obj      date,
   logTerminal_obj      varchar2(3),
   cfType_obj           varchar2(1),   -- controlfile type ('B' or 'S')
   pdbKey_obj           number,
 
--
   keep_options         number,
   keep_until           date,
 
--
 
   afzSCN_act           number,
   rfzTime_act          date,
   rfzSCN_act           number,
 
--
   media_con            varchar2(80),    -- media volume name for backup piece
 
   isrdf_con            varchar2(3),
 
--
   site_key_con         number,
 
--
   foreignDbid_obj      number,         -- foreign database id
   pluggedRonly_obj     binary_integer, -- 1 for read-only. Otherwise, 0
   pluginSCN_obj        number,         -- plugin change#
   pluginRlgSCN_obj     number,         -- plugin resetlogs change#
   pluginRlgTime_obj    date,           -- plugin resetlogs time
 
--
   newDfCreationSCN_obj number,         -- plugin scn or creation scn
   newToSCN_act         number,         -- plugin scn or checkpoint scn
   newRlgSCN_act        number,         -- plugin rlgscn or rlgscn
   newRlgTime_act       date,           -- plugin rlgtime or rlgtime
 
--
   sfDbUniqueName_obj   varchar2(30),
 
--
   sparse_backup_con    varchar2(3),    -- whether sparse or nonsparse backup
   ppl_pdb_id_con       number,         -- preplugin pdb id
   ppl_cdb_dbid_con     number          -- preplugin cdb database id
);
 
--
--
--
 
--
--
--
--
--
--
--
--
 
--
 
offlineRangeRec_con_t   CONSTANT NUMBER := 2**0;
proxyCopy_con_t         CONSTANT NUMBER := 2**1;
imageCopy_con_t         CONSTANT NUMBER := 2**2;
backupSet_con_t         CONSTANT NUMBER := 2**3;
addredo_con_t           CONSTANT NUMBER := 2**4;
deleted_con_t           CONSTANT NUMBER := 2**8;
datafile_con_t          CONSTANT NUMBER := 2**9;
avmImageCopy_con_t      CONSTANT NUMBER := 2**10;
 
--
backupMask_con_t        CONSTANT NUMBER := proxyCopy_con_t + imageCopy_con_t +
                                           backupSet_con_t;
tagMask_con_t           CONSTANT NUMBER := proxyCopy_con_t + imageCopy_con_t +
                                           backupSet_con_t;
 
--
--
--
 
full_act_t              CONSTANT NUMBER := 2**0;
incremental_act_t       CONSTANT NUMBER := 2**1;
redo_act_t              CONSTANT NUMBER := 2**2;
offlineRange_act_t      CONSTANT NUMBER := 2**3;
cleanRange_act_t        CONSTANT NUMBER := 2**4;
implicitRange_act_t     CONSTANT NUMBER := 2**5;
spanningRange_act_t     CONSTANT NUMBER := 2**6;
createdatafile_act_t    CONSTANT NUMBER := 2**7;
 
--
--
--
 
--
--
--
 
getCfCopy               CONSTANT NUMBER := 0;
getDfCopy               CONSTANT NUMBER := 1;
getAnyProxy             CONSTANT NUMBER := 2;
getCfBackup             CONSTANT NUMBER := 3;
listCfCopy              CONSTANT NUMBER := 4;
listDfCopy              CONSTANT NUMBER := 5;
listCfBackup            CONSTANT NUMBER := 6;
listDfBackup            CONSTANT NUMBER := 7;
listAlBackup            CONSTANT NUMBER := 8;
listDfProxy             CONSTANT NUMBER := 9;
getRecovAction          CONSTANT NUMBER := 10;
getAlBackup             CONSTANT NUMBER := 11;
listAlCopy              CONSTANT NUMBER := 12;
listBSet                CONSTANT NUMBER := 13;
getSfBackup             CONSTANT NUMBER := 14;
listSfBackup            CONSTANT NUMBER := 15;
getAllBSet              CONSTANT NUMBER := 16;
listAlProxy             CONSTANT NUMBER := 17;
getRangeAlBackup        CONSTANT NUMBER := 18;
 
--
--
--
--
--
--
unknownCmd_t            CONSTANT BINARY_INTEGER := 0;
recoverCmd_t            CONSTANT BINARY_INTEGER := 1;
rcvCopyCmd_t            CONSTANT BINARY_INTEGER := 2;
obsoleteCmd_t           CONSTANT BINARY_INTEGER := 3;
restoreCmd_t            CONSTANT BINARY_INTEGER := 4;
blkRestoreCmd_t         CONSTANT BINARY_INTEGER := 5;
 
--
--
--
--
--
--
stuckMemorySize CONSTANT NUMBER := 50 * 1024 * 1024;
 
--
--
--
 
TYPE bsRec_t IS RECORD
(
   recid                number,
   stamp                number,
   key                  number,
   setStamp             number,
   setCount             number,
   bsType               varchar2(1),
   level                number,
   elapseSecs           number,
   compTime             date,
   status               varchar2(1),
   pieceCount           number,
   keep_options         number,
   keep_until           date,
   multi_section        varchar2(1),
   ppl_pdb_id           number,         -- preplugin pdb id
   ppl_cdb_dbid         number          -- preplugin cdb database id
);
 
--
--
--
 
TYPE bpRec_t IS RECORD
(
   recid                number,
   stamp                number,
   key                  number,
   bskey                number,
   setStamp             number,
   setCount             number,
   bsType               varchar2(1),
   pieceNumber          number,
   copyNumber           number,
   status               varchar2(1),
   compTime             date,
   handle               varchar2(1024),
   tag                  varchar2(32),
   deviceType           varchar2(255),
   media                varchar2(80),
   bytes                number,
   compressed           varchar2(3),
   site_key             number,
   vb_key               number,
   am_access            varchar2(1), -- need for 12.0 compatibility
   ba_access            varchar2(1),
   ppl_pdb_id           number,         -- preplugin pdb id
   ppl_cdb_dbid         number          -- preplugin cdb database id
);
 
--
--
--
 
TYPE validBackupSetRec_t IS RECORD
(
   deviceType   varchar2(255),
   tag          varchar2(32),                   -- may be null
   order1       number,                         -- preference hint
   copyNumber   number,                         -- null if code 2 or 3
   code         number                          -- 1 => same copy#
--
--
--
);
 
bsRecCacheEnabled   constant boolean := TRUE;  -- FALSE to use pre10i method
bsRecCacheLowLimit  constant number  := 2048;  -- minimum cache size
bsRecCacheHighLimit constant number  := 32768; -- maximum cache size
 
 
TYPE incarnation_t IS RECORD
(
INCARNATION#                                       NUMBER,
RESETLOGS_CHANGE#                                  NUMBER,
RESETLOGS_TIME                                     DATE,
PRIOR_RESETLOGS_CHANGE#                            NUMBER,
PRIOR_RESETLOGS_TIME                               DATE,
STATUS                                             VARCHAR2(7),
RESETLOGS_ID                                       NUMBER,
PRIOR_INCARNATION#                                 NUMBER
);
 
TYPE pdb_incarnation_t IS RECORD
(
CON_ID                                             NUMBER,
PDBINC_KEY                                         NUMBER,
INCSCN                                             NUMBER,
ERSCN                                              NUMBER,
STATUS                                             VARCHAR2(7)
);
 
--
--
--
TYPE bhistoryRec_t IS RECORD
(
   dfNumber        number,
   create_scn      number,
   reset_scn       number,
   reset_time      date,
   ckp_scn         number,
   ckp_time        date,
   stop_scn        number,
   logThread       number,
   logSequence     number,
   setStamp        number,
   setCount        number,
   compTime        date,
   nbackups        number,
   logTerminal     varchar2(3),
   next_scn        number,
   pluggedRonly    binary_integer, -- 1 for read-only. Otherwise, 0
   pluginSCN       number,
   pluginRlgSCN    number,
   pluginRlgTime   date,
   newcreate_scn   number,    -- create_scn or pluginSCN
   newreset_scn    number,    -- reset_scn  or pluginRlgSCN
   newreset_time   date       -- reset_time or pluginRlgTime
);
 
--
--
--
TYPE agedFileRec_t IS RECORD
(
   type           number,
   key            number,
   stamp          number
);
 
--
--
--
 
--
--
--
backupset_txt      CONSTANT VARCHAR2(16) := 'BACKUP SET';
copy_txt           CONSTANT VARCHAR2(16) := 'COPY';
proxycopy_txt      CONSTANT VARCHAR2(16) := 'PROXY COPY';
datafile_txt       CONSTANT VARCHAR2(16) := 'DATAFILE';
spfile_txt         CONSTANT VARCHAR2(16) := 'SPFILE';
archivedlog_txt    CONSTANT VARCHAR2(16) := 'ARCHIVED LOG';
controlfile_txt    CONSTANT VARCHAR2(16) := 'CONTROLFILE';
piece_txt          CONSTANT VARCHAR2(16) := 'PIECE';
available_txt      CONSTANT VARCHAR2(16) := 'AVAILABLE';
unavailable_txt    CONSTANT VARCHAR2(16) := 'UNAVAILABLE';
expired_txt        CONSTANT VARCHAR2(16) := 'EXPIRED';
deleted_txt        CONSTANT VARCHAR2(16) := 'DELETED';
other_txt          CONSTANT VARCHAR2(16) := 'OTHER';
full_txt           CONSTANT VARCHAR2(16) := 'FULL';
incr1_txt          CONSTANT VARCHAR2(16) := 'INCR1';
incr2_txt          CONSTANT VARCHAR2(16) := 'INCR2';
incr3_txt          CONSTANT VARCHAR2(16) := 'INCR3';
incr4_txt          CONSTANT VARCHAR2(16) := 'INCR4';
incr_txt           CONSTANT VARCHAR2(16) := 'INCR';        -- level unknown
 
--
--
--
--
--
--
--
TYPE lbRec_t IS RECORD
(
   list_order1        NUMBER,       -- just hint to correctly order records
 
   list_order2        NUMBER,       -- just hint to correctly order records
 
   pkey               NUMBER,       -- primary key
--
--
--
   backup_type        VARCHAR2(32),  -- Type of the backup:
--
--
--
 
--
--
--
   file_type           VARCHAR2(32), -- Type of the file:
--
--
--
--
--
 
--
--
   keep               VARCHAR2(3),
   keep_until         DATE,
   keep_options       VARCHAR2(13),
   status             VARCHAR2(16),   -- Status of the piece/copy:
--
--
--
--
   fname              VARCHAR2(1024), -- piece or copy name
   tag                VARCHAR2(32),   -- piece or copy tag
   media              VARCHAR2(80),
   recid              NUMBER,
   stamp              NUMBER,
   device_type        VARCHAR2(255),
   block_size         NUMBER,
   completion_time    DATE,
   is_rdf             VARCHAR2(3),
   compressed         VARCHAR2(3),
   obsolete           VARCHAR2(3),
   keep_for_dbpitr    VARCHAR2(3),
   bytes              NUMBER,
 
--
--
   bs_key                NUMBER,        
   bs_count              NUMBER,        
   bs_stamp              NUMBER,        
   bs_type               VARCHAR2(32), -- Type of the backup set:
--
--
   bs_incr_type          VARCHAR2(32), 
   bs_pieces             NUMBER,
   bs_copies             NUMBER,
   bs_completion_time    DATE,
   bs_status             VARCHAR2(16),   -- Status of the backup set:
--
--
--
--
   bs_bytes              NUMBER,
   bs_compressed         VARCHAR2(3),    -- If backup set is compressed:
--
--
--
 
   bs_tag                VARCHAR2(1024), -- List of all tags of pieces.
--
--
 
   bs_device_type        VARCHAR2(255),  -- List of device types of pieces. 
--
 
--
--
   bp_piece#             NUMBER,
   bp_copy#              NUMBER,
   bp_vb_key             NUMBER,
   bp_ba_access          VARCHAR2(1),
   bp_lib_key            NUMBER,
 
--
--
   df_file#                  NUMBER,
   df_ts#                    NUMBER,
   df_plugin_change#         NUMBER,
   df_foreign_dbid           NUMBER,
   df_tablespace             VARCHAR2(30),
   df_resetlogs_change#      NUMBER,
   df_creation_change#       NUMBER,
   df_checkpoint_change#     NUMBER,
   df_ckp_mod_time           DATE, 
   df_incremental_change#    NUMBER,
   
--
--
   rl_thread#            NUMBER,
   rl_sequence#          NUMBER,
   rl_resetlogs_change#  NUMBER,
   rl_first_change#      NUMBER,
   rl_first_time         DATE,
   rl_next_change#       NUMBER,
   rl_next_time          DATE,
 
--
   sf_db_unique_name     VARCHAR2(30),
 
--
   con_id                NUMBER
);
 
--
--
--
TYPE lbDfRec_t IS RECORD
(
   dfRec                dfRec_t,
--
--
--
--
--
   fullmin_scn           NUMBER,
   fullmin_rlgscn        NUMBER,
 
--
--
--
--
--
   incrmin_scn           NUMBER,
   incrmin_rlgscn        NUMBER,
 
--
--
--
--
--
   logmin_scn            NUMBER,
   logmin_rlgscn         NUMBER
);
 
TYPE lbDfRecTab_t  IS TABLE     OF lbDfRec_t      INDEX BY BINARY_INTEGER;
TYPE lbRecTab_t    IS TABLE     OF lbRec_t        INDEX BY BINARY_INTEGER;
TYPE lbRecVar_t    IS VARRAY(1) OF lbRec_t;
TYPE rcvRecTabI_t  IS TABLE     OF rcvRec_t       INDEX BY BINARY_INTEGER;
TYPE rcvRecTabII_t IS TABLE     OF rcvRecTabI_t   INDEX BY BINARY_INTEGER;
TYPE dfRecTab_t    IS TABLE     OF dfRec_t        INDEX BY BINARY_INTEGER;
TYPE numTab_t      IS TABLE     OF number         INDEX BY BINARY_INTEGER;
TYPE lbCursor_t    IS REF                         CURSOR;
 
--
--
--
--
--
TYPE lbState_t   IS RECORD
  (
--
--
--
   lbRecOutTab        lbRecTab_t,
   lbRecOutTab_count  binary_integer,
 
--
--
   lbRecTmpTab        lbRecTab_t,
 
--
   lbRecCmn           lbRec_t,
 
--
--
   lbDfRecTabUs       lbDfRecTab_t,
 
--
--
   lbDfRecTab         dfRecTab_t,
 
--
--
   lbMaxDfNumber      number,
 
--
   lbNowTime          date,
 
--
--
   lbPieceCountTab    numTab_t,
   lbCopyCount        binary_integer,
 
--
--
   lbMkTab            rcvRecTabII_t,
 
--
--
   lbMkITab           rcvRecTabII_t,
 
--
--
--
--
--
--
--
--
--
   lbMinGrsp         number,
 
--
--
--
--
--
   lbFbUntilTime     date,
 
--
--
--
--
   lbRlKeepRlgSCN     number,
 
--
--
--
--
--
--
   lbRlKeepSCN        number,
 
--
--
--
--
--
   lbObsoleteRetention boolean,
   lbKeepForDBPITR     boolean,
   lbObsoleteKeep      boolean,
 
   lbNeedObsoleteData  boolean
 );
 
--
--
--
lbStatePck   lbState_t;
 
--
--
--
 
--
--
--
--
--
--
--
--
 
TYPE restoreRange_t IS RECORD
(
   lowTime       DATE,
   highTime      DATE,
   startScn      NUMBER,
   lowScn        NUMBER,
   highScn       NUMBER,
   lowDbIncKey   NUMBER,
   highDbIncKey  NUMBER,
   lowRlgScn     NUMBER,
   highRlgScn    NUMBER,
   lowRlgTime    DATE,
   highRlgTime   DATE,
   rcvStartScn   NUMBER,
   rcvStartTime  DATE,
   isValidRange  BOOLEAN,
   cfBkupFound   BOOLEAN,
   con_id        NUMBER
);
 
TYPE restoreRangeTab_t IS TABLE OF restoreRange_t INDEX BY BINARY_INTEGER;
 
--
 
TYPE failureRec_t IS RECORD
(
   priority      VARCHAR2(8),
   failureId     NUMBER,
   parentId      NUMBER,
   childCount    NUMBER,
   description   VARCHAR2(1024),
   timeDetected  DATE,
   status        VARCHAR2(12),
   impacts       VARCHAR2(1024)
);
 
TYPE repairRec_t IS RECORD
(
   type          NUMBER,
   failureidx    NUMBER,
   repairidx     NUMBER,
   description   VARCHAR2(1024)
);
 
TYPE repairParmsRec_t IS RECORD
(
   type          NUMBER,
   failureidx    NUMBER,
   repairidx     NUMBER,
   name          VARCHAR2(256),
   value         VARCHAR2(512)
);
 
TYPE repairOptionRec_t IS RECORD
(
   optionidx     NUMBER,
   description   VARCHAR2(1024)
);
 
TYPE repairStepRec_t IS RECORD
(
   type           NUMBER,
   failureidx     NUMBER,
   repairidx      NUMBER,
   repairstepidx  NUMBER,
   workingrepair  NUMBER,
   description    VARCHAR2(1024),
   repairscript   VARCHAR2(1024)
);
    
--
--
--
TYPE pdbNameRec_t IS RECORD
(
   pdbId    NUMBER,
   name     VARCHAR2(128)
);
 
TYPE pdbFileRec_t IS RECORD
(
   pdbId    NUMBER,
   file#    NUMBER,
   stopSCN  NUMBER
);
 
cdbRoot_txt  CONSTANT VARCHAR2(8) := 'CDB$ROOT';
 
--
--
--
 
--
--
--
 
FUNCTION dumpState(
   lineno IN number)
RETURN varchar2;
 
PROCEDURE dumpPkgState(msg in varchar2 default null);
 
PROCEDURE setDebugOn;
 
PROCEDURE setDebugOff;
 
--
--
--
--
--
--
--
 
PROCEDURE initialize(rman_vsn IN number);
 
--
--
--
 
PROCEDURE set_package_constants;
 
--
--
--
 
FUNCTION stamp2date(stamp IN number) RETURN date;
 
--
--
--
PROCEDURE getCurrentIncarnation(
   db_id          IN  number
  ,reset_scn      OUT number
  ,reset_time     OUT date);
 
--
--
--
 
--
--
--
--
--
--
--
--
 
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE setDatabase(
   db_name    IN varchar2
  ,reset_scn  IN number
  ,reset_time IN date
  ,db_id      IN number
  ,db_unique_name IN varchar2 default NULL
  ,site_aware IN boolean default FALSE
  ,dummy_instance  IN boolean default FALSE
  ,ors_instance    IN boolean default FALSE);
 
--
--
--
FUNCTION getDbUniqueName(
   db_id      IN number)
RETURN varchar2;
 
--
FUNCTION getDbKey RETURN NUMBER;
 
--
FUNCTION getMinRcvStartScn RETURN NUMBER;
 
--
PROCEDURE resetDbKey;
 
--
--
FUNCTION DbUniqueNameIsStandby
RETURN NUMBER;
 
--
--
PROCEDURE setCanConvertCf(flag IN boolean);
 
--
--
PROCEDURE setDbincKey(
   key IN number);
 
--
--
--
 
FUNCTION getParentIncarnation(
   resetlogs_change# IN OUT number
  ,resetlogs_time    IN OUT date)
RETURN number;
 
--
--
--
--
 
PROCEDURE getCheckpoint(
   scn OUT number
  ,seq OUT number);
 
--
--
 
PROCEDURE getCheckpoint(
   scn       OUT number
  ,seq       OUT number
  ,ckp_key_1 OUT number
  ,ckp_key_2 OUT number);
 
--
--
--
PROCEDURE SetGetSinceLastBackedAL(ntimes  IN number DEFAULT 1,
                                  devtype IN varchar2 DEFAULT NULL,
                                  sbpscn  IN number);
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE setCompletedRange(
   after  IN date
  ,before IN date);
 
PROCEDURE setLikePattern(
   pattern IN varchar2);
 
PROCEDURE setcanApplyAnyRedo(
   flag IN boolean);
 
--
PROCEDURE setBigScnAware;
 
--
PROCEDURE setAllFlag(
   flag IN boolean);
 
PROCEDURE setAllIncarnations(
   flag IN boolean);
 
PROCEDURE setUntilTime(
   unttime IN date);
 
--
--
--
--
--
--
PROCEDURE setUntilScn(
   scn     IN number
  ,rlgscn  IN number  DEFAULT NULL
  ,rlgtime IN date    DEFAULT NULL
  ,flbrp   IN boolean DEFAULT FALSE
  ,rpoint  IN boolean DEFAULT FALSE);
 
PROCEDURE setUntilLog(
   sequence# IN number
  ,thread#   IN number);
 
PROCEDURE setToLog(
   sequence# IN number
  ,thread#   IN number);
 
PROCEDURE setUntilResetlogs;
 
PROCEDURE setGuid(guid IN varchar2 DEFAULT NULL);
 
FUNCTION getUntilTime return date;
 
FUNCTION getUntilScn return number;
 
PROCEDURE resetUntil;
 
--
--
--
--
--
--
--
 
PROCEDURE setFrom(
   restorefrom IN number DEFAULT NULL);
 
--
--
--
--
--
--
PROCEDURE setSparseness(
   sparseness IN number DEFAULT NULL);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE setDeviceType(
   type IN varchar2);
 
--
--
 
PROCEDURE setStandby(
   stby IN boolean);
 
PROCEDURE setDeviceTypeAny;
 
--
 
PROCEDURE resetDeviceType;
 
--
--
--
--
--
--
--
--
 
PROCEDURE setTag(tag IN varchar2 DEFAULT NULL);
 
--
--
--
--
--
--
--
 
PROCEDURE setRecoveryDestFile(onlyrdf IN BOOLEAN);
 
--
--
--
--
--
--
--
--
--
PROCEDURE setOrsFile(localOnly IN BOOLEAN, libKey IN NUMBER);
 
--
--
--
--
--
PROCEDURE setSiteName(db_unique_name IN VARCHAR2, for_realfiles IN NUMBER);
 
--
PROCEDURE clrSiteName;
 
--
FUNCTION getSiteName(site_key IN NUMBER) RETURN VARCHAR2;
 
--
FUNCTION getSiteKey(db_unique_name IN VARCHAR2) RETURN NUMBER;
 
--
PROCEDURE setArchiveFileScopeAttributes(logs_shared IN NUMBER);
 
--
PROCEDURE setFirstFullBckScopeAttributes(baseline_cap IN NUMBER);
 
--
PROCEDURE setBackupFileScopeAttributes(
                 disk_backups_shared IN NUMBER,
                 tape_backups_shared IN NUMBER);
 
--
--
 
PROCEDURE resetAll(transclause IN BOOLEAN DEFAULT TRUE);
 
--
--
--
 
--
--
 
findValidBackupSetRcvRec rcvRec_t;              -- place to save a rcvRec_t
 
PROCEDURE findValidBackupSet(
   backupSetRec            IN     rcvRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL); -- for compat.
 
findValidBackupSetBsRec  bsRec_t;               -- place to save a bsRec_t
 
--
PROCEDURE findValidBackupSet(
   backupSetRec            IN     bsRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL); -- for compat.
 
FUNCTION getValidBackupSet(
   validBackupSetRec            OUT NOCOPY validBackupSetRec_t
  ,checkDeviceIsAllocated       IN  number DEFAULT FALSE#)
RETURN number;                                  -- TRUE# -> got a record
--
 
--
--
--
 
--
--
--
--
--
--
 
FUNCTION getRcvRec(
   funCode      IN number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,callAgain    OUT number)
RETURN number;
 
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateDatabase(
   sinceUntilSCN IN number DEFAULT NULL);
 
PROCEDURE skipTableSpace(
   tsName  IN varchar2
  ,pdbId   IN number DEFAULT 0);
 
PROCEDURE translateTablespace(
   ts_name IN varchar2, pdb_id IN number DEFAULT 0);
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateDataFile(
   fname IN varchar2);
 
PROCEDURE translateDatafile(
   fno   IN number);
 
PROCEDURE translateDatafile(
   fno    IN number
  ,ckpscn IN number);
 
--
--
 
PROCEDURE translateAllDatafile;
 
PROCEDURE translateCorruptList;
 
PROCEDURE getDatafile(
   dfRec     OUT NOCOPY dfRec_t
  ,oldClient IN  boolean DEFAULT FALSE);
 
--
PROCEDURE getDataFile(
   file#        OUT number
  ,crescn       OUT number
  ,creation_time OUT date
  ,fname        OUT varchar2
  ,ts_name      OUT varchar2
  ,status       OUT number
  ,blksize      OUT number
  ,kbytes       OUT number
  ,blocks       OUT number
  ,unrecoverable_change# OUT number
  ,stop_change# OUT number
  ,read_only    OUT number);
 
--
--
--
--
--
 
PROCEDURE translatePrePluginDf(con_id IN number);
 
FUNCTION getPrePluginDf(
   prePluginDfRec OUT NOCOPY prePluginDfRec_t)
RETURN NUMBER;
 
--
--
--
--
--
PROCEDURE translateTempfile;
 
PROCEDURE translateTempfile(fname IN varchar2);
 
PROCEDURE translateTempfile(fno IN number);
 
--
--
--
PROCEDURE getTempfile(tfRec OUT NOCOPY tfRec_t);
 
--
--
--
 
--
--
 
PROCEDURE translateOnlineLogs(srls IN number DEFAULT 0);
 
PROCEDURE getOnlineLog(
   fname        OUT varchar2
  ,thread#      OUT number
  ,group#       OUT number);
 
--
--
--
 
--
--
 
--
--
--
--
 
--
--
--
--
 
--
--
--
--
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
PROCEDURE getArchivedLog(
   alRec       OUT NOCOPY alRec_t
  ,closeCursor IN  boolean DEFAULT FALSE);
 
PROCEDURE translateArchivedLogKey(
   al_key       IN  number
  ,available    IN  number       DEFAULT 1 -- ignored (for compatability)
  ,unavailable  IN  number       DEFAULT 1 -- ignored (for compatability)
  ,deleted      IN  number       DEFAULT 1 -- ignored (for compatability)
  ,online       IN  number       DEFAULT 1 -- ignored (for compatability)
  ,recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,fname        OUT varchar2
  ,needstby     IN number        DEFAULT NULL);
 
PROCEDURE translateArchivedLogName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,deleted      IN number         DEFAULT NULL   -- for compatability
  ,online       IN number                        -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,needstby     IN number         DEFAULT NULL); -- for compatability
 
--
--
--
--
--
 
PROCEDURE translateArchivedLogSeqRange(
   thread#      IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number                          -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0        -- for compatability
  ,incarn       IN number         DEFAULT NULL);   -- for compatibility
 
PROCEDURE translateArchivedLogTimeRange(
   thread#      IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number                          -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0        -- for compatability
  ,incarn       IN number         DEFAULT NULL);   -- for compatibility
 
PROCEDURE translateArchivedLogSCNRange(
   thread#      IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL
  ,doingRecovery IN  number DEFAULT FALSE#
  ,onlyrdf      IN binary_integer DEFAULT 0        -- for compatability
  ,reset_scn    IN number         DEFAULT NULL     -- for compatability
  ,reset_time   IN date           DEFAULT NULL     -- for compatability
  ,sequence#    IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0        -- for compatability
  ,incarn       IN number         DEFAULT NULL);   -- for compatibility
 
PROCEDURE translateArchivedLogPattern(
   pattern      IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatability
  ,unavailable  IN number         DEFAULT NULL     -- for compatability
  ,deleted      IN number         DEFAULT NULL     -- for compatability
  ,online       IN number                          -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatability
  ,needstby     IN number         DEFAULT NULL     -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0);      -- for compatability
 
PROCEDURE translateArchivedLogCancel;
 
 
--
PROCEDURE sv_setSessionKey(skey IN NUMBER);
PROCEDURE sv_setSessionTimeRange(fromTime IN DATE, untilTime IN DATE);
 
FUNCTION sv_getSessionKey RETURN NUMBER;
FUNCTION sv_getSessionfromTimeRange RETURN DATE;
FUNCTION sv_getSessionUntilTimeRange RETURN DATE;
 
--
--
--
 
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE getArchivedLog(
   recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,nxt_scn      OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,blocks       OUT number);
 
--
--
--
 
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateControlFileCopyName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL -- for compatability
  ,unavailable  IN number         DEFAULT NULL -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL -- for compatability
  ,onlyone      IN number         DEFAULT 1);
 
PROCEDURE translateControlFileCopyTag(
   cftag        IN varchar2
  ,available    IN number         DEFAULT NULL -- for compatability
  ,unavailable  IN number         DEFAULT NULL -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL -- for compatability
  ,onlyone      IN number         DEFAULT 1);
 
PROCEDURE translateControlFileCopyKey(
   key          IN number
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL);  -- for compatability
 
 
PROCEDURE getControlFileCopy(
   rcvRec       IN OUT NOCOPY rcvRec_t);
 
--
PROCEDURE getControlFileCopy(
   recid        OUT number
  ,stamp        OUT number
  ,reset_scn    OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number);
 
--
--
--
 
PROCEDURE getDataFileCopy(
   rcvRec       OUT NOCOPY rcvRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE);
 
--
--
 
--
--
 
--
--
--
--
--
 
--
--
--
 
--
--
--
--
--
--
 
--
--
--
--
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL); -- for compatability
 
--
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,file#        OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,create_scn   OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number
  ,blocks       OUT number);
 
PROCEDURE translateDataFileCopyName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,onlyone      IN number         DEFAULT 1
  ,pluginSCN    IN number         DEFAULT 0);
 
PROCEDURE translateDataFileCopyTag(
   tag          IN varchar2
  ,available    IN number         DEFAULT NULL     -- for compatibility
  ,unavailable  IN number         DEFAULT NULL     -- for compatibility
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL     -- for compatibility
  ,pluginSCN    IN number         DEFAULT 0
  ,onlytc       IN binary_integer DEFAULT FALSE#); -- for compatibility
 
PROCEDURE translateDataFileCopyFno(
   fno          IN number
  ,available    IN number         DEFAULT NULL
  ,unavailable  IN number         DEFAULT NULL
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL
  ,pluginSCN    IN number         DEFAULT 0);
 
PROCEDURE translateDataFileCopy(
   duplicates   IN number
  ,statusMask   IN binary_integer
  ,onlyrdf      IN binary_integer
  ,pluginSCN    IN number         DEFAULT 0);
 
--
PROCEDURE translateDatafileCancel;
 
--
PROCEDURE getDataFileCopy(
   recid        OUT number
  ,stamp        OUT number
  ,file#        OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,create_scn   OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number
  ,blocks       OUT number);
 
--
--
--
 
PROCEDURE getProxyCopy(
   rcvRec       OUT NOCOPY rcvRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE);
 
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL); -- for compatability
 
--
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2);
 
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL); -- for compatability
 
--
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number);
 
PROCEDURE translateProxyCopyTag(
   tag          IN varchar2
  ,device_type  IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL); -- for compatability
 
PROCEDURE translateProxyCopyGuid(
   guid         IN varchar2
  ,device_type  IN varchar2
  ,statusMask   IN binary_integer);
 
--
--
--
--
 
--
--
 
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE getProxyCopy(
   recid OUT number
  ,stamp OUT number
  ,handle OUT varchar2);
 
--
--
--
 
PROCEDURE getBackupPiece(
   bpRec        OUT NOCOPY bpRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE);
 
PROCEDURE translateBackupPieceKey(
   key         IN  number
  ,available   IN  number            DEFAULT TRUE#
  ,unavailable IN  number            DEFAULT TRUE#
  ,expired     IN  number            DEFAULT TRUE#
  ,statusMask  IN  binary_integer    DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceKey(                        -- only used in 8.1.6
   bp_key       IN  number
  ,available    IN  number
  ,unavailable  IN  number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number);
 
PROCEDURE translateBackupPieceHandle(
   handle      IN  varchar2
  ,deviceType  IN  varchar2
  ,available   IN  number            DEFAULT NULL     -- for compatability
  ,unavailable IN  number            DEFAULT NULL     -- for compatability
  ,expired     IN  number            DEFAULT NULL     -- for compatability
  ,statusMask  IN  binary_integer    DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceHandle(                     -- only used in 8.1.6
   handle       IN  varchar2
  ,device_type  IN  varchar2
  ,available    IN  number
  ,unavailable  IN  number
  ,recid        OUT number
  ,stamp        OUT number
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number);
 
PROCEDURE translateBackupPieceTag(
   tag          IN varchar2
  ,available    IN number             DEFAULT NULL     -- for compatability
  ,unavailable  IN number             DEFAULT NULL     -- for compatability
  ,statusMask   IN binary_integer     DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceGuid(
   guid         IN varchar2
  ,statusMask   IN binary_integer);
 
PROCEDURE translateBackupPieceBSKey(
   key          IN number
  ,tag          IN varchar2           DEFAULT NULL
  ,deviceType   IN varchar2           DEFAULT NULL
  ,pieceCount   IN number
  ,duplicates   IN number             DEFAULT TRUE#
  ,copyNumber   IN number             DEFAULT NULL
  ,available    IN number             DEFAULT TRUE#
  ,unavailable  IN number             DEFAULT FALSE#
  ,deleted      IN number             DEFAULT FALSE#
  ,expired      IN number             DEFAULT FALSE#
  ,statusMask   IN binary_integer     DEFAULT NULL);   -- for compatability
 
PROCEDURE translateBackupPieceBsKey(
   startBsKey   IN number
  ,tag          IN varchar2        DEFAULT NULL
  ,statusMask   IN binary_integer  DEFAULT NULL);
--
--
   
PROCEDURE translateSeekBpBsKey(
   bsKey        IN number
  ,deviceType   IN varchar2
  ,pieceCount   IN number
  ,duplicates   IN number   DEFAULT TRUE#
  ,copyNumber   IN number   DEFAULT NULL);
--
--
--
--
--
--
--
--
--
 
PROCEDURE translateBpBsKeyCancel;
--
--
--
 
--
PROCEDURE translateBackupSetKey(
   bs_key          IN  number
  ,device_type     IN  varchar2
  ,available       IN  number
  ,unavailable     IN  number
  ,deleted         IN  number
  ,duplicates      IN  number
  ,backup_type     OUT varchar2
  ,recid           OUT number
  ,stamp           OUT number
  ,set_stamp       OUT number
  ,set_count       OUT number
  ,bslevel         OUT number
  ,completion_time OUT date);
 
--
PROCEDURE translateBackupSetKey(
   bs_key      IN  number
  ,device_type IN  varchar2
  ,available   IN  number
  ,unavailable IN  number
  ,deleted     IN  number
  ,duplicates  IN  number
  ,backup_type OUT varchar2
  ,recid       OUT number
  ,stamp       OUT number);
 
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2
  ,bs_key      OUT number
  ,bslevel     OUT number
  ,completed   OUT date);
 
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE getBackupPiece(
   recid      OUT number
  ,stamp      OUT number
  ,bpkey      OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,piece#     OUT number
  ,copy#      OUT number
  ,status     OUT varchar2
  ,completion OUT date
  ,handle     OUT varchar2);
 
--
PROCEDURE getBackupPiece(
   recid      OUT number
  ,stamp      OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,piece#     OUT number
  ,handle     OUT varchar2);
 
--
--
--
 
PROCEDURE translateBackupSetKey(
   key        IN  number
  ,bsRec      OUT NOCOPY bsRec_t);
 
PROCEDURE translateAllBackupSet(
   backupType            IN  binary_integer
  ,tag                   IN  varchar2
  ,statusMask            IN  binary_integer
  ,completedAfter        IN  date
  ,completedBefore       IN  date
  ,onlyrdf               IN  binary_integer DEFAULT 0);
 
PROCEDURE getAllBackupSet(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
--
--
 
FUNCTION translatePdb2Name(
   pdbId IN NUMBER)
RETURN VARCHAR2;
 
--
--
--
 
--
--
--
--
--
--
PROCEDURE findControlfileBackup(
   allCopies      IN boolean default FALSE,
   allBackups     IN boolean default FALSE,
   allIncarnation IN boolean default FALSE,
   fromSCN        IN number  default 0,
   pdbid          IN number  default 0);
 
--
--
FUNCTION getControlfileBackup(
   rcvRec     OUT NOCOPY rcvRec_t)
RETURN number;
 
--
FUNCTION getPrimaryDfName(fno IN NUMBER) RETURN VARCHAR2;
 
--
--
--
--
 
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number)
RETURN number;
 
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number
  ,rlg_scn      OUT number
  ,blksize      OUT number)
RETURN number;
 
--
--
--
 
PROCEDURE findRangeArchivedLogBackup(
   minthread    IN number
  ,minsequence  IN number
  ,minlowSCN    IN number
  ,maxthread    IN number
  ,maxsequence  IN number
  ,maxlowSCN    IN number
  ,allCopies    IN boolean default FALSE);
 
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE findArchivedLogBackup(
   thread    IN number
  ,sequence  IN number
  ,lowSCN    IN number
  ,allCopies IN boolean default FALSE);
 
--
--
--
--
--
--
--
--
--
 
--
FUNCTION getArchivedLogBackup(
   rcvRec       OUT NOCOPY rcvRec_t)
RETURN binary_integer;
 
--
FUNCTION findArchivedLogBackup(
   thread#    IN  number
  ,sequence#  IN  number
  ,low_scn    IN  number
  ,type       OUT number
  ,recid      OUT number
  ,stamp      OUT number
  ,device_type OUT varchar2)
RETURN number;
 
--
--
--
 
--
--
--
--
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE
  ,redundancy IN number  default NULL
  ,rmanCmd    IN number  default unknownCmd_t);
 
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE
  ,redundancy IN number  default NULL
  ,rmanCmd    IN number  default unknownCmd_t
  ,scn_warn  OUT number);
 
--
--
FUNCTION getSpfileBackup(
   rcvRec       OUT NOCOPY rcvRec_t
  ,redundancy   IN         number default NULL
  ,rmanCmd      IN         number default unknownCmd_t)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateControlfileCopy(
   tag             IN  varchar2
  ,completedAfter  IN  date
  ,completedBefore IN  date
  ,statusMask      IN  binary_integer   DEFAULT
                       BSavailable+BSunavailable+BSexpired
  ,liststby        IN  binary_integer   DEFAULT NULL -- default for 8.1
  ,file_pattern    IN varchar2       DEFAULT NULL);
 
PROCEDURE listGetControlfileCopy(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetControlfileCopy(
   bcfkey     OUT number
  ,ckpscn     OUT number
  ,ckptime    OUT date
  ,status     OUT varchar2
  ,completion OUT date
  ,fname      OUT varchar2)
RETURN number;
 
PROCEDURE listTranslateDataFileCopy(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT BSavailable+BSunavailable
--
  ,pluginSCN         IN number          DEFAULT 0);
 
PROCEDURE listGetDataFileCopy(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetDataFileCopy(
   cdf_key            OUT number
  ,status             OUT varchar2
  ,fname              OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number;
 
PROCEDURE listTranslateArchivedLogCopy(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                       BSavailable+BSunavailable+BSexpired  -- 8.0/8.1 defaults
  ,needstby          IN number          DEFAULT NULL);
 
PROCEDURE listGetArchivedLogCopy(
   rcvRec       OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetArchivedLogCopy(
   al_key          OUT number
  ,status          OUT varchar2
  ,fname           OUT varchar2
  ,completion_time OUT date)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateControlfileBackup(
   tag             IN  varchar2
  ,completedAfter  IN  date
  ,completedBefore IN  date
  ,statusMask      IN  binary_integer   DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,autobackup      IN  binary_integer    DEFAULT BScfile_all
  ,liststby        IN  binary_integer    DEFAULT NULL);
 
PROCEDURE listGetControlfileBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetControlfileBackup(
   bskey      OUT number,
   ckpscn     OUT number,
   ckptime    OUT date)
RETURN number;
 
PROCEDURE listTranslateSpfileBackup(
   completedAfter  IN  date
  ,completedBefore IN  date);
 
PROCEDURE listGetSpfileBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
PROCEDURE listTranslateDataFileBackup(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,pluginSCN         IN number          DEFAULT 0);
 
PROCEDURE listGetDataFileBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetDataFileBackup(
   bs_key             OUT number
  ,backup_type        OUT varchar2
  ,incremental_level  OUT number
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number;
 
--
PROCEDURE translateBackupFile(
   bs_recid    IN  number
  ,bs_stamp    IN  number
  ,fno         IN  number
  ,bskey       OUT number
  ,inclevel    OUT number
  ,backup_type OUT varchar2
  ,completed   OUT date);
 
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,completedAfter    IN date           DEFAULT NULL
  ,completedBefore   IN date           DEFAULT NULL
  ,statusMask        IN binary_integer DEFAULT
                      BSavailable+BSunavailable+BSexpired); -- 8.0/8.1 defaults
 
PROCEDURE listGetArchivedLogBackup(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,completion_time OUT date)
RETURN number;
 
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#      IN number   DEFAULT NULL
  ,lowseq       IN number   DEFAULT NULL
  ,highseq      IN number   DEFAULT NULL
  ,lowscn       IN number   DEFAULT NULL
  ,highscn      IN number   DEFAULT NULL
  ,from_time    IN date     DEFAULT NULL
  ,until_time   IN date     DEFAULT NULL
  ,pattern      IN varchar2 DEFAULT NULL);
 
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,thread#         OUT number
  ,sequence#       OUT number
  ,first_change#   OUT number
  ,next_change#    OUT number
  ,first_time      OUT date
  ,next_time       OUT date)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateBackupsetFiles(
   bs_key          IN  number);
 
PROCEDURE listGetBackupsetFiles(
   rcvRec          OUT NOCOPY rcvRec_t);
 
--
--
--
 
--
PROCEDURE listTranslateProxyDataFile(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL 
  ,statusMask        IN binary_integer  DEFAULT
                       BSavailable+BSunavailable+BSexpired
  ,liststby          IN binary_integer  DEFAULT NULL -- default for 8.1
  ,pluginSCN         IN number          DEFAULT 0);
 
PROCEDURE listGetProxyDataFile(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
FUNCTION listGetProxyDataFile(
   xdf_key            OUT number
  ,recid              OUT number
  ,stamp              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number;
 
--
--
--
--
--
--
--
--
PROCEDURE listTranslateProxyDFRecid(
   recid              IN number
  ,stamp              IN number
  ,xdf_key            OUT number
  ,file#              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date);
 
PROCEDURE listTranslateProxyArchivedLog(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                                        BSavailable+BSunavailable+BSexpired);
 
PROCEDURE listGetProxyArchivedLog(
   rcvRec OUT NOCOPY rcvRec_t);
 
--
--
--
 
PROCEDURE listTranslateDBIncarnation(
   db_name       IN varchar2 DEFAULT NULL,
   all_databases IN number  DEFAULT 0);
 
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date
  ,dbinc_status      OUT varchar2)
RETURN number;
 
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date)
RETURN number;
 
--
--
--
 
PROCEDURE listTranslateDBSite(
   db_name      IN varchar2 DEFAULT NULL,
   alldbs       IN binary_integer DEFAULT 1);
 
FUNCTION listGetDBSite(
   db_key            OUT number
  ,db_id             OUT number
  ,db_name           OUT varchar2
  ,db_role           OUT varchar2
  ,db_unique_name    OUT varchar2)
RETURN number;
 
--
--
--
 
PROCEDURE listRollbackSegTableSpace;
 
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2)
RETURN number;
 
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2
  ,pdbname           OUT varchar2)
RETURN number;
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
 
FUNCTION getIncrementalScn(
   file#        IN number
  ,create_scn   IN number
  ,reset_scn    IN number
  ,reset_time   IN date
  ,incr_level   IN number
  ,cumulative   IN number
  ,sourcemask   IN number   DEFAULT NULL 
  ,tag          IN varchar2 DEFAULT NULL
  ,pluginSCN    IN number   DEFAULT 0)
RETURN number;
 
--
--
--
--
--
--
--
--
--
--
--
 
PROCEDURE getIncrementalScn(
   first        IN  boolean                  -- open the cursor if this is TRUE
  ,file#        IN  number
  ,create_scn   IN  number
  ,reset_scn    IN  number
  ,reset_time   IN  date
  ,incr_level   IN  number
  ,cumulative   IN  number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,sourcemask   IN  number    DEFAULT NULL
  ,tag          IN  varchar2  DEFAULT NULL 
  ,pluginSCN    IN  number    DEFAULT 0
  ,keep         IN  boolean   DEFAULT NULL);
 
 
--
--
--
 
PROCEDURE findOfflineRangeCopy(
   offr_recid   IN number
  ,offr_ckpscn  IN number
  ,cf_cretime   IN date
  ,dbinc_key    IN number);
 
PROCEDURE getOfflineRangeCopy(
   rcvRec       OUT  NOCOPY rcvRec_t);
 
--
FUNCTION getOfflineRangeCopy
RETURN varchar2;
 
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
 
--
--
--
 
--
--
--
 
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number
  ,availableMask        IN binary_integer
  ,fullBackups          IN number DEFAULT NULL);
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number);
 
--
PROCEDURE setRAflags(
   kindMask    IN number
  ,allRecords  IN boolean);
 
FUNCTION computeRecoveryActions(
fno        IN number,   -- Datafile number.
crescn     IN number,   -- Datafile creation SCN.
df_rlgscn  IN number    -- Datafile resetlogs SCN.  Null if this is a RESTORE
   default null,        -- command, else this is the value in the datafile
--
df_rlgtime IN date      -- Datafile resetlogs time.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
df_ckpscn  IN number    -- Datafile checkpoint SCN.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
offlscn    IN number    -- kccfeofs (may be null).
   default 0,
onlscn     IN number    -- kccfeonc (null if offlscn is null).
   default 0,
onltime    IN date      -- kccfeonc_time
   default null,
cleanscn   IN number    -- kccfecps if either SOR or WCC set, else null.
   default 0,
clean2scn  IN number    -- CF ckpt SCN if WCC set, infinity if SOR bit set
   default 0,           -- else null.
clean2time IN date      -- cf ckpt time if WCC, SYSDATE if SOR
   default null,
allowfuzzy IN boolean   -- TRUE if can be fuzzy at until SCN/time, FALSE if
  default FALSE,        -- not.  default is FALSE.
partial_rcv IN boolean  -- TRUE if can do partial recovery, FALSE if not
  default FALSE,
cf_scn     IN number    -- controlfile checkpoint SCN (NULL if none mounted)
  default NULL,
cf_cretime IN date      -- controlfile creation time (NULL if none mounted)
  default NULL,
cf_offrrid IN number    -- recid of oldest offline range in controlfile
  default NULL,         -- (NULL if none mounted)
allCopies  IN boolean   -- if TRUE, then stack all valid copies of a bu set
  default FALSE,
df_cretime IN date      -- datafile creation time
  default NULL,
rmanCmd    IN binary_integer
  default unknownCmd_t,
foreignDbid   IN number
  default 0,
pluggedRonly  IN binary_integer
  default 0,
pluginSCN     IN number
  default 0,
pluginRlgSCN  IN number
  default 0,
pluginRlgTime IN date 
  default NULL,
creation_thread IN number
  default NULL,
creation_size   IN number
  default NULL,
pdbId           IN number
  default 1,
pdbForeignDbid  IN number
  default 0
) return binary_integer;
 
--
--
--
 
--
 
SUCCESS     CONSTANT binary_integer := 0;
UNAVAILABLE CONSTANT binary_integer := 1;
AVAILABLE   CONSTANT binary_integer := 2;
RESTORABLE  CONSTANT binary_integer := 3;
NO_ACTION   CONSTANT binary_integer := 4;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
FUNCTION getRecoveryAction(
   action OUT NOCOPY rcvRec_t)
RETURN binary_integer;
 
--
FUNCTION getRecoveryAction(
   kind       OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,recid      OUT number
  ,stamp      OUT number
  ,fname      OUT varchar2
  ,blocksize  OUT number
  ,blocks     OUT number
  ,devtype    OUT varchar2
  ,from_scn   OUT number
  ,to_scn     OUT number
  ,to_time    OUT date
  ,rlgscn     OUT number
  ,rlgtime    OUT date
  ,cfcretime  OUT date
  ,dbinc_key  OUT number)
RETURN binary_integer;
 
PROCEDURE printRecoveryActions;
 
PROCEDURE trimRecoveryActions(
   maxActions           IN number
  ,containerMask        IN number
  ,actionMask           IN number);
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
PROCEDURE reportTranslateDFDel ;
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number)
RETURN number;
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number
  ,key                 OUT number
  ,completion_time     OUT date)
RETURN number;
 
--
--
--
 
FUNCTION getCloneName(
   fno    IN number
  ,crescn IN number
  ,pluscn IN number DEFAULT 0)
RETURN varchar2;
 
 
--
--
--
 
FUNCTION wasFileOffline(
   fno    IN number
  ,untilscn IN number)
RETURN number;
 
--
--
--
 
procedure getConfig(
   conf#          OUT    number
  ,name           IN OUT varchar2
  ,value          IN OUT varchar2
  ,first          IN     boolean);
 
--
--
--
 
FUNCTION getmaxcopyno(
   bsstamp         IN    number
  ,bscount         IN    number)
RETURN number;
 
--
--
--
 
PROCEDURE bmrAddCorruptTable(
   dfnumber    OUT number
  ,blknumber   OUT number
  ,range       OUT number
  ,first       IN  boolean);
 
--
--
--
 
PROCEDURE getDfBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,recentbackup    IN   boolean DEFAULT FALSE  -- get no: recent backups
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
PROCEDURE getAlBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
PROCEDURE getBsBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,set_stamp       IN   number DEFAULT NULL
  ,set_count       IN   number DEFAULT NULL
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
PROCEDURE getDcBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL);
 
--
PROCEDURE getBackupHistory(
   dfRec            IN  dfRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date);
 
--
PROCEDURE getBackupHistory(
   alRec            IN  alRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date);
 
PROCEDURE getBackupHistory(
   bpRec            IN  bpRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date
  ,toDest1          IN  varchar2 DEFAULT NULL
  ,toDest2          IN  varchar2 DEFAULT NULL
  ,toDest3          IN  varchar2 DEFAULT NULL
  ,toDest4          IN  varchar2 DEFAULT NULL);
 
--
--
--
 
FUNCTION getPackageVersion
RETURN varchar2;
 
--
--
--
FUNCTION isStatusMatch(status      IN VARCHAR2,
                       mask        IN NUMBER) RETURN NUMBER;
FUNCTION isDeviceTypeAllocated(deviceType IN varchar2)
                      RETURN NUMBER;
FUNCTION isBackupTypeMatch(btype       IN VARCHAR2,
                           mask        IN binary_integer)
                                              RETURN NUMBER;
--
--
--
PROCEDURE setRcvRecBackupAge(age IN number);
 
--
--
--
PROCEDURE resetthisBackupAge;
 
--
--
--
 
PROCEDURE getRetentionPolicy(recovery_window OUT number
                            ,redundancy      OUT number);
--
--
--
--
 
FUNCTION listBackup(lbRecOut         OUT     NOCOPY lbRec_t
                   ,firstCall        IN      boolean
                   ,only_obsolete    IN      boolean
                   ,redundancy       IN      number
                   ,piped_call       IN      boolean
                   ,lbCursor         IN  OUT NOCOPY lbCursor_t
                   ,lbState          IN  OUT NOCOPY lbState_t
                   ,extRlKeepSCN     IN      number DEFAULT NULL)
  RETURN boolean;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
 
--
 
FUNCTION getRestoreRangeSet(restoreRangeTab OUT restoreRangeTab_t
                           ,opCode  IN  varchar2
                           ,db_id   IN  number)
    
  RETURN boolean;
 
--
 
PROCEDURE setNeedObsoleteData(NeedObsoleteData IN boolean DEFAULT TRUE);
--
--
 
--
 
--
--
PROCEDURE getCopyofDatafile(
   first          IN      boolean     -- TRUE if this is the first time called
  ,itag           IN      varchar2    -- tag that the copy should have or NULL
  ,fno            OUT     number      -- datafile number
  ,crescn         OUT     number      -- creation scn of the datafile
  ,rlogscn        OUT     number      -- resetlogs scn of the datafile
  ,rlgtime        OUT     date        -- resetlogs time of the datafile
  ,recid          OUT     binary_integer -- recid of the latest datafilecopy
  ,stamp          OUT     binary_integer -- stamp of the latest datafilecopy
  ,name           OUT     varchar2    -- name of the datafilecopy
  ,otag           OUT     varchar2    -- tag of the datafilecopy
  ,status         OUT     varchar2    -- status of the datafilecopy
  ,nblocks        OUT     binary_integer -- number of blocks of datafilecopy
  ,bsz            OUT     binary_integer -- blocksize of the datafilecopy
  ,ctime          OUT     date        -- creation time of the datafilecopy
  ,toscn          OUT     number      -- checkpoint scn of the datafilecopy
  ,totime         OUT     date        -- checkpoint time of the datafilecopy
  ,pluggedRonly   OUT     binary_integer -- 1 for read-only. Otherwise, 0
  ,pluginSCN      OUT     number      -- plugin scn
  ,pluginRlgSCN   OUT     number      -- resetlogs when datafile was plugged
  ,pluginRlgTime  OUT     date);      -- resetlog time when df was plugged
 
--
--
--
--
 
PROCEDURE getCopyofDatafile(
   dfnumber       IN      number      -- datafile number
  ,itag           IN      varchar2    -- tag that the copy should have or NULL
  ,crescn         IN  OUT number      -- creation scn of the datafile
  ,rlogscn        IN  OUT number      -- resetlogs scn of the datafile
  ,rlgtime        IN  OUT date        -- resetlogs time of the datafile
  ,recid          OUT     binary_integer -- recid of the latest datafilecopy
  ,stamp          OUT     binary_integer -- stamp of the latest datafilecopy
  ,name           OUT     varchar2    -- name of the datafilecopy
  ,otag           OUT     varchar2    -- tag of the datafilecopy
  ,status         OUT     varchar2    -- status of the datafilecopy
  ,nblocks        OUT     binary_integer -- number of blocks of datafilecopy
  ,bsz            OUT     binary_integer -- blocksize of the datafilecopy
  ,ctime          OUT     date        -- creation time of the datafilecopy
  ,toscn          OUT     number      -- checkpoint scn of the datafilecopy
  ,totime         OUT     date        -- checkpoint time of the datafilecopy
  ,pluggedRonly   OUT     binary_integer -- 1 for read-only. Otherwise, 0
  ,pluginSCN      IN      number);    -- plugin scn
 
--
--
--
--
 
PROCEDURE getCopyofDatafile(
   dfnumber    IN  number          -- datafile number
  ,itag        IN  varchar2        -- tag that the copy should have or NULL
  ,crescn      IN  number          -- creation scn of the datafile
  ,rlogscn     IN  number          -- resetlogs scn of the datafile
  ,rlgtime     IN  date            -- resetlogs time of the datafile
  ,recid       OUT binary_integer  -- recid of the latest datafilecopy
  ,stamp       OUT binary_integer  -- stamp of the latest datafilecopy
  ,name        OUT varchar2        -- name of the datafilecopy
  ,otag        OUT varchar2        -- tag of the datafilecopy
  ,status      OUT varchar2        -- status of the datafilecopy
  ,nblocks     OUT binary_integer  -- number of blocks of the datafilecopy
  ,bsz         OUT binary_integer  -- blocksize of the datafilecopy
  ,ctime       OUT date            -- creation time of the datafilecopy
  ,toscn       OUT number          -- checkpoint scn of the datafilecopy
  ,totime      OUT date);          -- checkpoint time of the datafilecopy
 
--
--
--
PROCEDURE getdropOSFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t);
 
PROCEDURE getBackedUpFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t);
 
--
--
PROCEDURE getRedoLogDeletionPolicy(
   policy        OUT varchar2);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE setRedoLogDeletionPolicy(
   policy  IN  varchar2
  ,alldest IN  number);
 
--
--
--
--
--
FUNCTION validateStandbyConfig(
   policy  IN  varchar2
  ,alldest IN  number)
RETURN NUMBER;
 
--
--
--
--
--
--
--
--
--
--
PROCEDURE getSCNForAppliedPolicy(
   minscn    OUT  number
  ,rlgscn    OUT  number);
 
--
--
--
--
--
--
--
--
PROCEDURE getAppliedAl(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t);
 
--
--
--
--
--
PROCEDURE getRequiredSCN(
   reqscn   OUT  number
  ,rlgscn   OUT  number
  ,streams  IN   number DEFAULT 0
  ,alldest  IN   number DEFAULT 0);
 
--
--
PROCEDURE getAppliedSCN(
   appscn   OUT  number
  ,rlgscn   OUT  number
  ,alldest  IN   number);
 
--
--
FUNCTION isTranslatedFno(fno IN number) RETURN NUMBER;
 
--
--
FUNCTION isBsRecCacheMatch(
   key         IN   number
  ,deviceType  IN   varchar2
  ,tag         IN   varchar2
  ,status      IN   varchar2)
RETURN NUMBER;
 
--
PROCEDURE resetReclRecid;
 
--
PROCEDURE setReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number);
 
--
--
FUNCTION IsReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number)
RETURN NUMBER;
 
--
--
FUNCTION getSpaceRecl(ceilAsm IN binary_integer default 0) RETURN NUMBER;
 
--
PROCEDURE getRestorePoint(
   name         IN varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number);
 
--
PROCEDURE getRestorePoint(
   name         IN varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number
  ,con_id       IN number
  ,clean        OUT number
  ,out_con_id   OUT number);
 
--
PROCEDURE listTranslateRestorePoint(
  name          IN  varchar2);
 
--
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2);
 
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2
  ,pdbname      OUT varchar2);
 
--
--
--
FUNCTION Num2DisplaySize(input_size IN NUMBER) return VARCHAR2;
 
--
FUNCTION Sec2DisplayTime(input_secs IN NUMBER) return VARCHAR2;
 
FUNCTION getEncryptTSCount RETURN BINARY_INTEGER;
 
--
--
--
--
PROCEDURE setArchivedLogRecord(
   thread#   IN  number
  ,sequence# IN  number
  ,first     IN  boolean);
 
--
--
--
PROCEDURE setCanHandleTransportableTbs(
   flag IN boolean);
 
--
--
FUNCTION getArchivedNextSCN RETURN NUMBER;
 
--
--
FUNCTION isArchivedLogMissing(fromSCN IN NUMBER, untilSCN IN NUMBER)
  RETURN NUMBER;
 
--
--
FUNCTION getNextAvailableSCN(fromScn           IN  NUMBER, 
                             nextAvailableSCN  OUT  NUMBER,
                             isOrs             IN   NUMBER)
  RETURN BOOLEAN;
 
--
FUNCTION findLogBreakPoint(logBreakPointScn        OUT NUMBER,
                           logBreakPointTime       OUT DATE,
                           logBreakPointDbIncKey   OUT NUMBER,
                           logBreakPointRlgScn     OUT NUMBER,
                           logBreakPointRlgTime    OUT DATE,
                           fromSCN                 IN  NUMBER,
                           untilSCN                IN  NUMBER,
                           isOrs                   IN  NUMBER)
  RETURN boolean;
 
--
--
FUNCTION getMaxRedoSCN(maxScn      OUT NUMBER,
                       maxTime     OUT DATE,
                       maxDbIncKey OUT NUMBER,
                       maxRlgScn   OUT NUMBER,
                       maxRlgTime  OUT DATE,
                       isOrs       IN  NUMBER)
   RETURN boolean;
 
--
PROCEDURE setRestoreRangeDevTyp(typ IN VARCHAR2);
 
--
PROCEDURE resetRestoreRangeDevTyp;
 
--
--
--
 
--
--
FUNCTION getDropSCN(dfNum        IN NUMBER,
                    creScn       IN  NUMBER,
                    creTime      IN  DATE,
                    plugScn      IN  NUMBER,
                    foreignDbId  IN  NUMBER,
                    dropScn      OUT NUMBER,
                    dropTime     OUT DATE,
                    dropDbIncKey OUT NUMBER,
                    dropRlgScn   OUT NUMBER,
                    dropRlgTime  OUT DATE)
RETURN boolean;
 
--
--
--
FUNCTION getIncarnationKey(untilSCN IN NUMBER) RETURN NUMBER;
 
--
--
PROCEDURE setDbidTransClause(dbid IN number);
 
--
--
FUNCTION isTranslatedDbid(dbid IN number) RETURN NUMBER;
 
--
--
FUNCTION getMaxScn RETURN number;
 
FUNCTION getMaxScn(logmaxnt OUT date) RETURN NUMBER;
 
FUNCTION getActualDbinc RETURN number;
--
--
--
--
--
--
 
PROCEDURE setStdbyCtrlScn(ctrlSCN IN NUMBER);
--
--
 
FUNCTION translatePdbName(pdbName IN VARCHAR2) RETURN NUMBER;
--
 
PROCEDURE resetPdbIdList;
--
 
PROCEDURE setPdbId(pdbId IN NUMBER, first IN BOOLEAN);
--
--
 
FUNCTION isTranslatedPdbId(pdbId IN NUMBER) RETURN NUMBER;
--
--
 
FUNCTION isPdbScnOrphan(untilSCN IN NUMBER, pdbId IN NUMBER) RETURN NUMBER;
--
--
 
FUNCTION setLocalOrsSiteKey(db_id IN NUMBER) RETURN boolean;
--
 
PROCEDURE resetLocalOrsSiteKey;
--
 
FUNCTION isNoBackupPdb(pdbname IN VARCHAR2) RETURN NUMBER;
--
 
--
--
--
 
PROCEDURE listApplicationPdbs(root_con_id IN  number);
--
 
FUNCTION listGetAppPdb(pdb_name OUT varchar2) RETURN NUMBER;
--
 
--
 
pragma TIMESTAMP('2000-03-12:13:51:00');
 
END; -- dbms_rcvman or x$dbms_rcvman
 



CREATE OR REPLACE PACKAGE BODY dbms_rcvman IS
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
--
--
--
 
 
MAXSCNVAL  CONSTANT number := 9e125; -- guaranteed higher than any SCN
UB6MAXVAL  CONSTANT number := 281474976710655;
UB8MAXVAL  CONSTANT number := 18446744073709551615;
MAXSEQVAL  CONSTANT number := 2**32-1;
MINDATEVAL CONSTANT date   := to_date('01/01/1900','MM/DD/YYYY');
MAXDATEVAL CONSTANT date   := to_date('12/31/9999','MM/DD/YYYY');
CONST2GVAL CONSTANT number := 2**31;
CONST4GVAL CONSTANT number := 2**32;
 
--
KEEP_NO      CONSTANT number := 0;
KEEP_LOGS    CONSTANT number := 256;
KEEP_NOLOGS  CONSTANT number := 512;
KEEP_CONSIST CONSTANT number := 1024;
 
DEB_UNDEF  CONSTANT number := 0;
DEB_PRINT  CONSTANT number := 0;
DEB_ENTER  CONSTANT number := 1;
DEB_EXIT   CONSTANT number := 2;
DEB_IN     CONSTANT number := 3;
DEB_OPEN   CONSTANT number := 4;
DEB_DEF_PNAME CONSTANT varchar2(50) := 'prvtrmnu';
 
--
BACKUP_SPARSENESS_UNSPECIFIED CONSTANT number := 0;
BACKUP_SPARSENESS_SPARSE      CONSTANT number := 1;
BACKUP_SPARSENESS_NONSPARSE   CONSTANT number := 2;
 
--
--
--
 
--
--
--
highscnval            number := UB6MAXVAL;
 
this_db_key         number := NULL;
this_dbinc_key      number := NULL;
this_reset_scn      number := NULL;
this_reset_time     date;
this_db_unique_name node.db_unique_name%TYPE;  -- used only to identify rows of
this_site_key       number := NULL;        -- configuration and flashback tbl
--
--
this_dummy_instance boolean := FALSE;
this_stdby_controlfile_scn number := NULL;  -- standby controlfile scn used
--
 
--
--
--
--
--
--
--
--
translation_site_key NUMBER := NULL;      -- Never NULL
 
realf_site_key      number := NULL;        -- override df/tf/online log txln
user_site_key       number := NULL;        -- override log/backups/conf/rp txln
user_db_unique_name node.db_unique_name%TYPE; -- corresponds to user_site_key 
client_site_aware   number := 0;
 
--
--
--
--
--
--
logs_shared           number := 0; -- used only when client_site_aware is 1
disk_backups_shared   number := 1; -- indicates shared accross all sites
tape_backups_shared   number := 1; -- indicates shared accross all sites
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
TYPE incarnation_set_c IS TABLE OF rc_database_incarnation%ROWTYPE
         index by binary_integer;
inc_list incarnation_set_c;  -- 0th one is current incarnation, see setDatabase
max_inc_idx binary_integer;
currInc     binary_integer;  -- temp variable used to keep track of incarnation
 
--
TYPE pdb_incarnation_set_t IS TABLE OF pdb_incarnation_t
   index by binary_integer;
TYPE pdb_incarnation_coll_t IS TABLE OF pdb_incarnation_set_t
   index by binary_integer;
pdb_inc_list pdb_incarnation_coll_t; -- 0th one is current sub incarnation
 
type pnames is table of varchar2(50) index by binary_integer;
pname_i         number :=0;
last_pnames     pnames;
debug           boolean := FALSE;
rsdebug         boolean := NULL;
 
--
--
--
--
--
--
--
--
this_baseline_cap      number;
this_baseline_cap_scn  number := NULL;
 
--
--
--
 
TYPE rcvRecTab_t IS TABLE OF rcvRec_t;          -- recovery record stack type
 
rcvRecStack rcvRecTab_t := rcvRecTab_t();       -- recovery record stack
 
--
--
--
 
TYPE versionList_t IS TABLE OF varchar2(11) INDEX BY binary_integer;
 
versionList             versionList_t;
versionMaxIndex         binary_integer;
versionCounter          binary_integer;
 
--
--
--
 
catalogVersion CONSTANT VARCHAR2(11) := '12.02.00.01';
 
--
getParentIncarnationKey number;
 
--
--
--
 
allIncarnations number;                 -- allow records from non-current
--
 
ignoreCreationSCN number;               -- a stupid flag that is here
--
--
--
--
 
--
lbacked_al_next_scn        NUMBER;
standby_became_primary_scn NUMBER;
 
--
--
TYPE lognames_set_c IS TABLE OF al.fname%TYPE
         index by binary_integer;
lognames_list lognames_set_c;  -- All the log names returned for same logseq
max_lognames_idx binary_integer;
 
--
--
--
--
canApplyAnyRedo number := FALSE#;
 
--
--
--
--
craGetAllCfBackups number := FALSE#;
 
--
--
--
canConvert_Cf number := FALSE#;
 
redoRec      rcvRec_t;
 
untilSCN        number;
untilTime       date;
rpoint_set      boolean;
 
restoreSource   number;
restoreSparse   number := BACKUP_SPARSENESS_UNSPECIFIED;
restoreTag      bp.tag%TYPE;
 
onlyStandby     number;
 
--
--
--
 
TYPE deviceList_t IS TABLE OF rc_backup_piece.device_type%TYPE
     INDEX BY binary_integer;
 
deviceList      deviceList_t;
deviceCount     number;
diskDevice      boolean;
anyDevice       number;
 
--
--
--
recoveryDestFile  boolean;
 
--
--
--
localOrsSiteKey number := null;
 
--
--
--
restoreRangeDevTyp varchar2(10) := null;
 
--
--
--
orsLocalFile  boolean := null;
orsLibKey     number  := null;
orsAnyFile    boolean := null;
 
--
--
--
--
--
--
--
--
--
redoLogDeletionPolicyType  varchar2(512) := 'TO NONE';
 
--
--
--
extendFullSCN  CONSTANT BINARY_INTEGER := 2**0;
extendIncrSCN  CONSTANT BINARY_INTEGER := 2**1;
extendLogSCN   CONSTANT BINARY_INTEGER := 2**2;
extendAllSCN   CONSTANT BINARY_INTEGER :=
   extendFullSCN + extendIncrSCN + extendLogSCN;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
noHint constant binary_integer         := 0;
redundantHint constant binary_integer  := 1;
localityHint constant binary_integer   := 2;
 
TYPE cacheBsRecRow_t IS RECORD
(
   deviceindx   binary_integer,    -- index into cacheBsRecTable.devicelist
   tag          varchar2(32),      -- may be null
   copyNumber   binary_integer,    -- null if code 2 or 3
   code         binary_integer     -- 1 => same copy#
--
--
);
TYPE cacheBsRecIndex_t IS TABLE OF cacheBsRecRow_t INDEX BY BINARY_INTEGER;
TYPE cacheBsRecHash_t IS RECORD
(
   bskey       number,             -- backupset key
   mixcopy     boolean := FALSE,   -- TRUE if mixcopy can make set usuable
   copy        cacheBsRecIndex_t   -- list of copies
);
TYPE cacheBsRecHashList_t IS TABLE OF cacheBsRecHash_t INDEX BY BINARY_INTEGER;
TYPE cacheBsRecBsKey_t IS RECORD
(
   bsindex     binary_integer := 1,    -- index into bslist
   bslist      cacheBsRecHashList_t    -- list of backupset keys in hash table
);
TYPE cacheBsRec_t IS TABLE OF cacheBsRecBsKey_t INDEX BY BINARY_INTEGER;
TYPE cacheBsRecTable_t IS RECORD
(
   initlimit   boolean := FALSE,              -- is limit initialized?
   limit       number  := bsRecCacheLowLimit, -- cache size
   chit        number  := 0,                  -- no: of hits in cache
   mixcopy     boolean := FALSE,              -- does cache have mix of copyno?
   minbskey    number  := 0,                  -- minimum valid bskey
 
   hint        binary_integer := noHint, -- access pattern hint
--
--
--
--
   devicetype  rc_backup_piece.device_type%TYPE,
   mask        binary_integer,
   tag         rc_backup_piece.tag%TYPE,
 
   devicelist  deviceList_t,       -- list of devices
   devicecount binary_integer := 0,
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
   bsRec    cacheBsRec_t,
 
--
--
--
   hitindex    binary_integer := 1,     -- index into hit list
   hitlist     numTab_t
--
--
--
--
--
--
--
--
--
--
--
);
cacheBsRecTable  cacheBsRecTable_t;
 
TYPE cacheRequest_t IS RECORD
(
   bskey                  number,
   icopy                  binary_integer
);
findValidCacheRequest     cacheRequest_t;
 
--
--
--
 
TYPE rcvRecStackState_t IS RECORD
(
   lowAction   number,                  -- action with lowest from_scn on
--
--
--
--
--
   savePoint   number,                  -- most recently added full_act_t
   fullBackups number,                  -- number of full_act_t
   top         number                   -- top of stack at start of a recursive
--
--
);
 
rcvRecStackState        rcvRecStackState_t;
 
--
--
--
 
computeRA_allRecords    number;         -- do not stop at first full backup and
--
 
computeRA_fullBackups   number;         -- stop when reached these many full
--
 
computeRA_restorable    boolean;        -- cannot recover the datafile we've
--
--
--
 
computeRA_available     boolean;        -- there is a backup available on
--
 
computeRA_availableMask binary_integer;
 
computeRA_rcvCopy_avail boolean;        -- there is a backup available on
--
--
--
 
--
action_OK                number := 0;
action_FAIL              number := 1;
action_SKIP              number := 2;
action_OLD_REDO          number := 3;
action_WRONG_INCARNATION number := 4;
action_OLD_INC_REDO      number := 5;
 
old_redo exception;                     -- redo from old incarnation
pragma exception_init(old_redo, -20501);
 
--
--
--
 
getRA_containerMask     number;
getRA_actionMask        number;
getRA_likePattern       cdf.fname%TYPE;
 
getRA_completedAfter    date;
getRA_completedBefore   date;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
rcvRecBackupAge         number;      -- requested age of backup
thisBackupAge           number;      -- current age of backup
getBS_status            number;      -- status of current backup
 
--
--
--
tc_thread               number;
tc_fromTime             date;
tc_toTime               date;
tc_fromSCN              number;
tc_toSCN                number;
tc_fromSeq              number;
tc_toSeq                number;
tc_pattern              varchar2(512);
 
TYPE fileTab_t IS TABLE of boolean index by binary_integer;
tc_fno                  fileTab_t;
tc_database             number;
 
TYPE sequenceTab_t IS TABLE of boolean index by binary_integer;
TYPE threadseqTab_t IS TABLE of sequenceTab_t index by binary_integer;
tc_threadSeq            threadSeqTab_t;
 
TYPE dbidTab_t IS TABLE OF boolean index by binary_integer;
tc_dbid                 dbidTab_t;
tc_anydbid              number;
 
--
--
--
--
--
canHandleTransportableTbs number := FALSE#;
 
guidQualifier        varchar2(32);
guid2pdbkeyQualifier number;
 
--
--
--
actual_dbinc_key number := NULL; -- see comments on getActualDbinc
 
--
--
SESSION_KEY number;
SESSION_FROMTIME DATE;
SESSION_UNTILTIME DATE;
 
--
--
--
--
--
--
--
lb_NeedObsoleteData   number := TRUE#;
CURSOR listBackup_c
RETURN lbRec_t IS
   SELECT
--
           bs.bs_key               list_order1,
           0                       list_order2,
           bs.bs_key               pkey,
           backupset_txt           backup_type,
           backupset_txt           file_type,
           decode(bs.keep_options,
                  0, 'NO',
                     'YES')        keep,
           bs.keep_until           keep_until,
           decode(bs.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         null)     keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bs.bs_recid             recid,
           bs.bs_stamp             stamp,
           null                    device_type,
           0                       block_size,
           bs.completion_time      completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           bs.bs_key               bs_key,
           bs.set_count            bs_count,
           bs.set_stamp            bs_stamp,
           decode(bs.bck_type,
                  'L', archivedlog_txt,
                       datafile_txt)
                                   bs_type,
           decode(bs.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(bs.bck_type, 'I', incr_txt, full_txt))
                                   bs_incr_type,
           bs.pieces               bs_pieces,
           null                    bs_copies,
           bs.completion_time      bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM  bs
    WHERE bs.db_key     = this_db_key
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
   SELECT
--
           bp.bs_key               list_order1,
           1                       list_order2,
           bp.bp_key               pkey,
           backupset_txt           backup_type,
           piece_txt               file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(bp.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           bp.handle               fname,
           bp.tag                  tag,
           bp.media                media,
           bp.bp_recid             recid,
           bp.bp_stamp             stamp,
           bp.device_type          device_type,
           0                       block_size,
           bp.completion_time      completion_time,
           bp.is_recovery_dest_file
                                   is_rdf,
           bp.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bp.bytes                bytes,
           bp.bs_key               bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           bp.piece#               bp_piece#,
           bp.copy#                bp_copy#,
           bp.vb_key               bp_vb_key,
           bp.ba_access            bp_ba_access,
           bp.lib_key              bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bp
    WHERE bp.db_key = this_db_key
      AND bp.status != 'D'
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           bdf.bs_key              list_order1,
           2                       list_order2,
           bdf.bdf_key             pkey,
           backupset_txt           backup_type,
           datafile_txt            file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bdf.bdf_recid           recid,
           bdf.bdf_stamp           stamp,
           null                    device_type,
           bdf.block_size          block_size,
           bdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bdf.block_size * bdf.blocks
                                   bytes,
           bdf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           decode(bdf.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(greatest(bdf.create_scn, bdf.incr_scn),
                         bdf.create_scn, full_txt, incr_txt))
                                   bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           bdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           bdf.create_scn          df_creation_change#,
           bdf.ckp_scn             df_checkpoint_change#,
           bdf.ckp_time            df_ckp_mod_time,
           bdf.incr_scn            df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bdf.dbinc_key
 
   UNION ALL
   SELECT
--
           bcf.bs_key              list_order1,
           2                       list_order2,
           bcf.bcf_key             pkey,
           backupset_txt           backup_type,
           controlfile_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bcf.bcf_recid           recid,
           bcf.bcf_stamp           stamp,
           null                    device_type,
           bcf.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bcf.block_size * bcf.blocks
                                   bytes,
           bcf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           bcf.ckp_scn             df_checkpoint_change#,
           bcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bcf.dbinc_key
 
   UNION ALL
   SELECT
--
           brl.bs_key              list_order1,
           2                       list_order2,
           brl.brl_key             pkey,
           backupset_txt           backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           brl.brl_recid           recid,
           brl.brl_stamp           stamp,
           null                    device_type,
           brl.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           brl.block_size * brl.blocks
                                   bytes,
           brl.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           brl.thread#             rl_thread#,
           brl.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           brl.low_scn             rl_first_change#,
           brl.low_time            rl_first_time,
           brl.next_scn            rl_next_change#,
           brl.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM brl, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = brl.dbinc_key
 
   UNION ALL
   SELECT
--
           bsf.bs_key              list_order1,
           2                       list_order2,
           bsf.bsf_key             pkey,
           backupset_txt           backup_type,
           spfile_txt              file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bsf.bsf_recid           recid,
           bsf.bsf_stamp           stamp,
           null                    device_type,
           0                       block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bsf.bytes               bytes,
           bsf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           0                       df_resetlogs_change#,
           0                       df_creation_change#,
           0                       df_checkpoint_change#,
           bsf.modification_time   df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           db_unique_name          sf_db_unique_name,
           null                    con_id
     FROM bsf
    WHERE bsf.db_key     = this_db_key
 
   UNION ALL
   SELECT
--
           cdf.cdf_key             list_order1,
           -1                      list_order2,
           cdf.cdf_key             pkey,
           copy_txt                backup_type,
           datafile_txt            file_type,
           decode(cdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           cdf.keep_until          keep_until,
           decode(cdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(cdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           cdf.fname               fname,
           cdf.tag                 tag,
           null                    media,
           cdf.cdf_recid           recid,
           cdf.cdf_stamp           stamp,
           'DISK'                  device_type,
           cdf.block_size          block_size,
           cdf.completion_time     completion_time,
           cdf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           cdf.block_size * cdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           cdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           cdf.create_scn          df_creation_change#,
           cdf.ckp_scn             df_checkpoint_change#,
           cdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM cdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = cdf.dbinc_key
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
   UNION ALL
   SELECT
--
           ccf.ccf_key             list_order1,
           -1                      list_order2,
           ccf.ccf_key             pkey,
           copy_txt                backup_type,
           controlfile_txt         file_type,
           decode(ccf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           ccf.keep_until          keep_until,
           decode(ccf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(ccf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           ccf.fname               fname,
           ccf.tag                 tag,
           null                    media,
           ccf.ccf_recid           recid,
           ccf.ccf_stamp           stamp,
           'DISK'                  device_type,
           ccf.block_size          block_size,
           ccf.completion_time     completion_time,
           ccf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           ccf.ckp_scn             df_checkpoint_change#,
           ccf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM ccf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = ccf.dbinc_key
      AND ((user_site_key  = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           al.al_key               list_order1,
           -1                      list_order2,
           al.al_key               pkey,
           copy_txt                backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(al.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           al.fname                fname,
           null                    tag,
           null                    media,
           al.al_recid             recid,
           al.al_stamp             stamp,
           'DISK'                  device_type,
           al.block_size           block_size,
           al.completion_time      completion_time,
           al.is_recovery_dest_file
                                   is_rdf,
           al.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           al.block_size * al.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           al.thread#              rl_thread#,
           al.sequence#            rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           al.low_scn              rl_first_change#,
           al.low_time             rl_first_time,
           al.next_scn             rl_next_change#,
           al.next_time            rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM dbinc,
          al
          LEFT OUTER JOIN
          grsp
          ON al.next_scn   >= grsp.from_scn
         AND al.low_scn    <= (grsp.to_scn + 1)
         AND al.dbinc_key   = grsp.dbinc_key
         AND grsp.from_scn <= grsp.to_scn   -- filter clean grp
         AND grsp.from_scn != 0
         AND grsp.guaranteed = 'YES'
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = al.dbinc_key
      AND al.archived = 'Y'
      AND grsp.from_scn is null
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = al.site_key) OR
             (user_site_key IS NULL AND
              (logs_shared = TRUE# OR
               this_site_key = nvl(al.site_key, this_site_key))))) OR
           (client_site_aware = FALSE#))
 
   UNION ALL
   SELECT
--
           xdf.xdf_key             list_order1,
           -1                      list_order2,
           xdf.xdf_key             pkey,
           proxycopy_txt           backup_type,
           datafile_txt            file_type,
           decode(xdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xdf.keep_until          keep_until,
           decode(xdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xdf.handle              fname,
           xdf.tag                 tag,
           xdf.media               media,
           xdf.xdf_recid           recid,
           xdf.xdf_stamp           stamp,
           xdf.device_type         device_type,
           xdf.block_size          block_size,
           xdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xdf.block_size * xdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           xdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           xdf.create_scn          df_creation_change#,
           xdf.ckp_scn             df_checkpoint_change#,
           xdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xdf.dbinc_key
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
   UNION ALL
   SELECT
--
           xcf.xcf_key             list_order1,
           -1                      list_order2,
           xcf.xcf_key             pkey,
           proxycopy_txt           backup_type,
           controlfile_txt         file_type,
           decode(xcf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xcf.keep_until          keep_until,
           decode(xcf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xcf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xcf.handle              fname,
           xcf.tag                 tag,
           xcf.media               media,
           xcf.xcf_recid           recid,
           xcf.xcf_stamp           stamp,
           xcf.device_type         device_type,
           xcf.block_size          block_size,
           xcf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           xcf.ckp_scn             df_checkpoint_change#,
           xcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xcf.dbinc_key
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           xal.xal_key             list_order1,
           -1                      list_order2,
           xal.xal_key             pkey,
           proxycopy_txt           backup_type,
           archivedlog_txt         file_type,
           decode(xal.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xal.keep_until          keep_until,
           decode(xal.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xal.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xal.handle              fname,
           xal.tag                 tag,
           xal.media               media,
           xal.xal_recid           recid,
           xal.xal_stamp           stamp,
           xal.device_type         device_type,
           xal.block_size          block_size,
           xal.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xal.block_size * xal.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           xal.thread#             rl_thread#,
           xal.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           xal.low_scn             rl_first_change#,
           xal.low_time            rl_first_time,
           xal.next_scn            rl_next_change#,
           xal.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xal, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = xal.dbinc_key
      AND ((user_site_key   = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
   ORDER BY list_order1, list_order2, bp_piece#;
 
--
--
--
 
--
--
--
--
 
CURSOR findControlfileBackup_c(
   sourcemask           IN     number
  ,currentIncarnation   IN     number         DEFAULT TRUE#
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,untilSCN             IN     number         DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable
--
  ,needstby             IN     number         DEFAULT NULL
  ,typemask             IN     binary_integer DEFAULT BScfile_all
  ,fromSCN              IN     number         DEFAULT 0
--
)
RETURN rcvRec_t IS
   SELECT imageCopy_con_t       type_con,
          ccf_key               key_con,
          ccf_recid             recid_con,
          ccf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- ccf doesn't have blocks
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          create_time           cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          ccf.ckp_scn           toSCN_act,
          ccf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          ccf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          ccf.pdb_key           pdbKey_obj,
 
          ccf.keep_options      keep_options,
          ccf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM ccf, dbinc
   WHERE dbinc.db_key = this_db_key            -- belongs to this database
     AND dbinc.dbinc_key = ccf.dbinc_key
     AND (findControlfileBackup_c.currentIncarnation = FALSE# OR
          this_dbinc_key = ccf.dbinc_key)
     AND (findControlfileBackup_c.tag is NULL OR
          findControlfileBackup_c.tag = tag)
     AND (findControlfileBackup_c.pattern is NULL OR
          fname LIKE replace(replace(findControlfileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findControlfileBackup_c.completedAfter is NULL OR
          completion_time >= findControlfileBackup_c.completedAfter)
     AND (findControlfileBackup_c.completedBefore is NULL OR
          completion_time <= findControlfileBackup_c.completedBefore)
     AND (findControlfileBackup_c.untilSCN is NULL OR
          ccf.ckp_scn <= findControlfileBackup_c.untilSCN)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
     AND (needstby is NULL OR
          nvl(controlfile_type,'B') = decode(needstby, TRUE#, 'S', 'B') OR
          canConvert_Cf = TRUE#)
     AND (sourcemask is NULL OR bitand(sourcemask, imageCopy_con_t) != 0)
     AND ((user_site_key = ccf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(ccf.site_key, this_site_key)))))
     AND ccf.ckp_scn >= findControlfileBackup_c.fromSCN
     AND (guidQualifier IS NULL OR ccf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xcf_key               key_con,
          xcf_recid             recid_con,
          xcf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- xcf doesn't have blocks
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xcf.ckp_scn           toSCN_act,
          xcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          xcf.pdb_key           pdbKey_obj,
 
          xcf.keep_options      keep_options,
          xcf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xcf, dbinc
   WHERE db_key = this_db_key          -- belongs to this database
     AND dbinc.dbinc_key = xcf.dbinc_key
     AND (findControlfileBackup_c.currentIncarnation = FALSE# OR
          this_dbinc_key = xcf.dbinc_key)
     AND (findControlfileBackup_c.tag is NULL OR
          findControlfileBackup_c.tag = tag)
     AND (findControlfileBackup_c.pattern is NULL OR
          handle LIKE replace(replace(findControlfileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findControlfileBackup_c.completedAfter is NULL OR
          completion_time >= findControlfileBackup_c.completedAfter)
     AND (findControlfileBackup_c.completedBefore is NULL OR
          completion_time <= findControlfileBackup_c.completedBefore)
     AND (findControlfileBackup_c.untilSCN is NULL OR
          xcf.ckp_scn <= findControlfileBackup_c.untilSCN)
     AND decode(statusMask, BSavailable,
                decode(status, 'A', TRUE#, FALSE#),
                isStatusMatch(status, statusMask)) = TRUE#
     AND (needstby is NULL OR
          nvl(controlfile_type,'B') = decode(needstby, TRUE#, 'S', 'B') OR
          canConvert_Cf = TRUE#)
     AND (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
     AND ((user_site_key  = xcf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xcf.site_key, this_site_key)))))
     AND xcf.ckp_scn >= findControlfileBackup_c.fromSCN
     AND (guidQualifier IS NULL OR xcf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT backupSet_con_t       type_con,
          bcf_key               key_con,
          bcf_recid             recid_con,
          bcf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          bcf.blocks            blocks_con,
          bcf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          bcf.create_time       cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          bcf.ckp_scn           toSCN_act,
          bcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          bcf.autobackup_sequence
                                cfSequence_obj,
          bcf.autobackup_date   cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          bcf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bs, bcf, dbinc
   WHERE dbinc.db_key = this_db_key            -- belongs to this database
     AND bs.db_key = this_db_key               -- belongs to this database
     AND bcf.dbinc_key = dbinc.dbinc_key       -- join bcf and dbinc
     AND bcf.bs_key = bs.bs_key                -- join bcf and bs
     AND bs.bck_type != 'L'                    -- ignore archivelog backups
     AND (findControlfileBackup_c.currentIncarnation = FALSE# OR
          this_dbinc_key = bcf.dbinc_key)
     AND (findControlfileBackup_c.completedAfter is NULL OR
          bs.completion_time >= findControlfileBackup_c.completedAfter)
     AND (findControlfileBackup_c.completedBefore is NULL OR
          bs.completion_time <= findControlfileBackup_c.completedBefore)
     AND (findControlfileBackup_c.untilSCN is NULL OR
          bcf.ckp_scn <= findControlfileBackup_c.untilSCN)
     AND (needstby is NULL OR
          nvl(controlfile_type,'B') = decode(needstby, TRUE#, 'S', 'B') OR
          canConvert_Cf = TRUE#)
     AND ((typemask = 0 AND bcf.autobackup_date IS NULL)  OR -- no autobackups
          (bitand(typemask, BScfile_all) != 0)            OR -- all backups
          (bcf.autobackup_date IS NOT NULL AND             -- only autobackups
           bitand(typemask, BScfile_auto) != 0))
     AND (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
     AND (bs.site_key IS NULL         OR -- always return null site_key
          user_site_key = bs.site_key OR -- user interested in one site
          (user_site_key IS NULL AND     -- return rows per access attr
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key)))
     AND bcf.ckp_scn >= findControlfileBackup_c.fromSCN
     AND (guidQualifier IS NULL OR bcf.pdb_key = guid2pdbKeyQualifier)
 
   ORDER BY toSCN_act desc,
            stamp_con desc;
 
--
--
--
 
CURSOR findSpfileBackup_c(
   completedAfter        IN     date           DEFAULT NULL
  ,completedBefore       IN     date           DEFAULT NULL
  ,untilTime             IN     date           DEFAULT NULL
  ,rmanCmd               IN     number         DEFAULT unknownCmd_t)
RETURN rcvRec_t IS
--
   SELECT backupSet_con_t       type_con,
          bsf_key               key_con,
          bsf_recid             recid_con,
          bsf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          0                     blocks_con,
          0                     blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          0                     toSCN_act,
          nvl(modification_time, bs.completion_time)     toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bsf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          db_unique_name        sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bsf, bs, db
--
--
--
    WHERE rmanCmd != obsoleteCmd_t
      AND bsf.bs_key = bs.bs_key                -- join bsf and bs
      AND bs.bck_type != 'L'                    -- ignore archivelog backups
      AND bs.db_key = this_db_key               -- belongs to this database
      AND bsf.db_key = db.db_key                -- join bsf and db
      AND (findSpfileBackup_c.completedAfter is NULL OR
           bs.completion_time >= findSpfileBackup_c.completedAfter)
      AND (findSpfileBackup_c.completedBefore is NULL OR
           bs.completion_time <= findSpfileBackup_c.completedBefore)
      AND (findSpfileBackup_c.untilTime is NULL OR
           nvl(modification_time,bs.start_time)
               <= findSpfileBackup_c.untilTime)
      AND (rmanCmd != restoreCmd_t OR
           (rmanCmd = restoreCmd_t AND
            (bsf.db_unique_name is NULL OR
             nvl(user_db_unique_name, this_db_unique_name) =
              bsf.db_unique_name)))
      AND (bs.site_key IS NULL         OR -- always return null site_key
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key))
     AND (guidQualifier IS NULL OR bsf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
--
   SELECT backupSet_con_t       type_con,
          bsf_key               key_con,
          bsf_recid             recid_con,
          bsf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          0                     blocks_con,
          0                     blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          0                     toSCN_act,
          nvl(modification_time, bs.completion_time)     toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bsf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          db_unique_name        sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bsf, bs, db,
          (SELECT bs_key,
                  count(distinct piece#) pieces
             FROM  bp
            WHERE rmanCmd = obsoleteCmd_t
              AND bp.db_key  = this_db_key         -- this database
              AND bp.status  = 'A'
              AND (anyDevice = TRUE# OR
                   isDeviceTypeAllocated(bp.device_type) = TRUE#)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared=TRUE# AND bp.device_type='DISK') OR
                     (tape_backups_shared=TRUE# AND bp.device_type<>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
         GROUP BY bs_key, device_type) bp
--
--
--
    WHERE rmanCmd = obsoleteCmd_t
      AND bsf.bs_key = bs.bs_key                -- join bsf and bs
      AND bs.bck_type != 'L'                    -- ignore archivelog backups
      AND bs.db_key = this_db_key               -- belongs to this database
      AND bs.bs_key = bp.bs_key                 -- join bs and bp
      AND bs.pieces = bp.pieces
      AND bsf.db_key = db.db_key                -- join bsf and db
      AND (findSpfileBackup_c.completedAfter is NULL OR
           bs.completion_time >= findSpfileBackup_c.completedAfter)
      AND (findSpfileBackup_c.completedBefore is NULL OR
           bs.completion_time <= findSpfileBackup_c.completedBefore)
      AND (findSpfileBackup_c.untilTime is NULL OR
           nvl(modification_time,bs.start_time)
               <= findSpfileBackup_c.untilTime)
     AND (guidQualifier IS NULL OR bsf.pdb_key = guid2pdbKeyQualifier)
 
    ORDER BY toTime_act desc, -- for finding best backup
             stamp_con desc;  -- to get most recent
 
--
--
--
getDatafileBackupLast   rcvRec_t;
 
CURSOR findDatafileBackup_c(
   sourcemask           IN     number
  ,fno                  IN     number         DEFAULT NULL
  ,crescn               IN     number         DEFAULT NULL
--
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,reset_scn            IN     number         DEFAULT NULL
  ,reset_time           IN     date           DEFAULT NULL
  ,level                IN     number         DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,untilSCN             IN     number         DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable
--
  ,onlyrdf              IN     binary_integer DEFAULT 0
--
  ,duplicates           IN     number         DEFAULT NULL
  ,onlytc               IN     binary_integer DEFAULT FALSE#
--
  ,pluginSCN            IN     number         DEFAULT 0
  ,allowCumuLevelN      IN     binary_integer DEFAULT FALSE#
--
)
 
RETURN rcvRec_t IS
 
   SELECT imageCopy_con_t       type_con,
          cdf.cdf_key           key_con,
          cdf.cdf_recid         recid_con,
          cdf.cdf_stamp         stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          cdf.fname             fileName_con,
          cdf.tag               tag_con,
          to_number(null)       copyNumber_con,
          cdf.status            status_con,
          cdf.blocks            blocks_con,
          cdf.block_size        blockSize_con,
          'DISK'                deviceType_con,
          cdf.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          cdf.ckp_scn           toSCN_act,
          cdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          cdf.dbinc_key         dbincKey_act,
          cdf.incr_level        level_act,
          0                     section_size_act,
 
          cdf.file#             dfNumber_obj,
          cdf.create_scn        dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          cdf.pdb_key           pdbKey_obj,
 
          cdf.keep_options      keep_options,
          cdf.keep_until        keep_until,
 
          cdf.abs_fuzzy_scn     afzSCN_act,
          cdf.rcv_fuzzy_time    rfzTime_act,
          cdf.rcv_fuzzy_scn     rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          cdf.foreign_dbid      foreignDbid_obj,
          decode(cdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          cdf.plugin_scn        pluginSCN_obj,
          cdf.plugin_reset_scn  pluginRlgSCN_obj,
          cdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          decode(cdf.plugged_readonly, 'NO', cdf.ckp_scn,
                 cdf.plugin_scn)
                                newToSCN_act,
          decode(cdf.plugin_scn, 0, dbinc.reset_scn,
                 cdf.plugin_reset_scn)
                                newRlgSCN_act,
          decode(cdf.plugin_scn, 0, dbinc.reset_time,
                 cdf.plugin_reset_time)
                                newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          cdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM cdf, dbinc,
          (SELECT DISTINCT max(cdf_recid) duprecid
             FROM cdf, dbinc
            WHERE (findDatafileBackup_c.tag is NULL OR
                   tag = findDatafileBackup_c.tag)
              AND cdf.dbinc_key = dbinc.dbinc_key
              AND dbinc.db_key  = this_db_key
              AND (findDatafileBackup_c.pattern is NULL OR
                   cdf.fname
                     LIKE replace(replace(findDatafileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                      ESCAPE '*')
         GROUP BY cdf.file#, cdf.create_scn, dbinc.reset_scn,
                  dbinc.reset_time, cdf.ckp_time, cdf.ckp_scn,
                  cdf.abs_fuzzy_scn, cdf.rcv_fuzzy_scn,
                  cdf.bck_fuzzy, cdf.onl_fuzzy, dbinc.db_key,
                  cdf.plugin_scn, cdf.plugin_reset_scn,
                  cdf.plugin_reset_time) dup
   WHERE cdf.cdf_recid = dup.duprecid(+)
     AND (sourcemask is NULL OR bitand(sourcemask, imageCopy_con_t) != 0)
     AND (dbinc.db_key = this_db_key)            -- belongs to this database
     AND (dbinc.dbinc_key = cdf.dbinc_key)       -- join cdf and dbinc
     AND (findDatafileBackup_c.reset_scn is NULL OR
          canApplyAnyRedo = TRUE# OR
          (cdf.plugged_readonly = 'NO' AND
           findDatafileBackup_c.reset_scn = dbinc.reset_scn AND
           findDatafileBackup_c.reset_time = dbinc.reset_time) OR
          (cdf.plugged_readonly = 'YES' AND
           findDatafileBackup_c.reset_scn = cdf.plugin_reset_scn AND
           findDatafileBackup_c.reset_time = cdf.plugin_reset_time))
     AND cdf.file# = nvl(findDatafileBackup_c.fno, cdf.file#)
--
--
     AND cdf.file# != 0                           -- no ctrl bkps
     AND (onlytc = FALSE#     OR
          tc_database = TRUE# OR
          isTranslatedFno(cdf.file#) = TRUE#)     -- only tnslated files
     AND ((findDatafileBackup_c.pluginSCN = 0  AND
           cdf.plugin_scn = 0                  AND
           cdf.create_scn = findDatafileBackup_c.crescn)
          OR
          (findDatafileBackup_c.pluginSCN != 0 AND
           cdf.plugin_scn = findDatafileBackup_c.pluginSCN)
          OR
          (findDatafileBackup_c.pluginSCN = 0 AND
           findDatafileBackup_c.crescn IS NULL))
     AND decode(statusMask, BSavailable,
                decode(status, 'A', TRUE#, FALSE#),
                isStatusMatch(status, statusMask)) = TRUE#
     AND (findDatafileBackup_c.tag is NULL OR
          tag = findDatafileBackup_c.tag)
     AND (findDatafileBackup_c.pattern is NULL OR
          cdf.fname LIKE replace(replace(findDatafileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findDatafileBackup_c.completedAfter is NULL OR
          cdf.completion_time >= findDatafileBackup_c.completedAfter)
     AND (findDatafileBackup_c.completedBefore is NULL OR
          cdf.completion_time <= findDatafileBackup_c.completedBefore)
     AND (findDatafileBackup_c.untilSCN is NULL OR
          (cdf.plugged_readonly = 'NO' AND
           cdf.ckp_scn <= findDatafileBackup_c.untilSCN) OR
          (cdf.plugged_readonly = 'YES' AND
           cdf.plugin_scn <= findDatafileBackup_c.untilSCN))
     AND (findDatafileBackup_c.level is NULL OR
          cdf.incr_level <= findDatafileBackup_c.level)
     AND (findDatafileBackup_c.onlyrdf = 0 OR
          cdf.is_recovery_dest_file = 'YES')
     AND (duplicates IS NULL OR duplicates = TRUE# OR
          (duplicates = FALSE# AND duprecid IS NOT NULL))
     AND ((user_site_key = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
     AND (guidQualifier IS NULL OR cdf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xdf.xdf_key           key_con,
          xdf.xdf_recid         recid_con,
          xdf.xdf_stamp         stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          xdf.handle            fileName_con,
          xdf.tag               tag_con,
          to_number(null)       copyNumber_con,
          xdf.status            status_con,
          xdf.blocks            blocks_con,
          xdf.block_size        blockSize_con,
          xdf.device_type       deviceType_con,
          xdf.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xdf.ckp_scn           toSCN_act,
          xdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xdf.dbinc_key         dbincKey_act,
          xdf.incr_level        level_act,
          0                     section_size_act,
 
          xdf.file#             dfNumber_obj,
          xdf.create_scn        dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          xdf.pdb_key           pdbKey_obj,
 
          xdf.keep_options      keep_options,
          xdf.keep_until        keep_until,
 
          xdf.abs_fuzzy_scn     afzSCN_act,
          xdf.rcv_fuzzy_time    rfzTime_act,
          xdf.rcv_fuzzy_scn     rfzSCN_act,
          xdf.media             media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          xdf.foreign_dbid      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          xdf.plugin_scn        pluginSCN_obj,
          xdf.plugin_reset_scn  pluginRlgSCN_obj,
          xdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          decode(xdf.plugged_readonly, 'NO', xdf.ckp_scn,
                 xdf.plugin_scn)
                                newToSCN_act,
          decode(xdf.plugin_reset_scn, 0, dbinc.reset_scn,
                 xdf.plugin_reset_scn)
                                newRlgSCN_act,
          nvl(xdf.plugin_reset_time, dbinc.reset_time)
                                newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xdf, dbinc
   WHERE (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
     AND (findDatafileBackup_c.onlyrdf = 0)
     AND (dbinc.db_key = this_db_key)            -- belongs to this database
     AND (dbinc.dbinc_key = xdf.dbinc_key)       -- join xdf and dbinc
     AND (findDatafileBackup_c.reset_scn is NULL OR
          canApplyAnyRedo = TRUE# OR
          (xdf.plugged_readonly = 'NO' AND
           findDatafileBackup_c.reset_scn = dbinc.reset_scn AND
           findDatafileBackup_c.reset_time = dbinc.reset_time) OR
          (xdf.plugged_readonly = 'YES' AND
           findDatafileBackup_c.reset_scn = xdf.plugin_reset_scn AND
           findDatafileBackup_c.reset_time = xdf.plugin_reset_time))
     AND xdf.file# = nvl(findDatafileBackup_c.fno, xdf.file#)
     AND xdf.file# != 0                         -- no ctrl bkps
     AND (onlytc = FALSE#     OR
          tc_database = TRUE# OR
          isTranslatedFno(xdf.file#) = TRUE#)   -- only tnslated files
     AND ((findDatafileBackup_c.pluginSCN = 0  AND
           xdf.plugin_scn = 0                  AND
           xdf.create_scn = findDatafileBackup_c.crescn)
          OR
          (findDatafileBackup_c.pluginSCN != 0 AND
           xdf.plugin_scn = findDatafileBackup_c.pluginSCN)
          OR
          (findDatafileBackup_c.pluginSCN = 0 AND
           findDatafileBackup_c.crescn IS NULL))
     AND decode(statusMask, BSavailable,
                decode(xdf.status, 'A', TRUE#, FALSE#),
                isStatusMatch(xdf.status, statusMask)) = TRUE#
     AND (findDatafileBackup_c.tag is NULL OR
          xdf.tag = findDatafileBackup_c.tag)
     AND (findDatafileBackup_c.pattern is NULL OR
          xdf.handle LIKE replace(replace(findDatafileBackup_c.pattern,
                                     '*','**'), '_', '*_')
                    ESCAPE '*')
     AND (findDatafileBackup_c.completedAfter is NULL OR
          xdf.completion_time >= findDatafileBackup_c.completedAfter)
     AND (findDatafileBackup_c.completedBefore is NULL OR
          xdf.completion_time <= findDatafileBackup_c.completedBefore)
     AND (findDatafileBackup_c.untilSCN is NULL OR
          (xdf.plugged_readonly = 'NO' AND
           xdf.ckp_scn <= findDatafileBackup_c.untilSCN) OR
          (xdf.plugged_readonly = 'YES' AND
           xdf.plugin_scn <= findDatafileBackup_c.untilSCN))
     AND (findDatafileBackup_c.level is NULL OR
          xdf.incr_level <= findDatafileBackup_c.level)
     AND dbinc.db_key=this_db_key
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
     AND (guidQualifier IS NULL OR xdf.pdb_key = guid2pdbKeyQualifier)
 
   UNION ALL
 
   SELECT backupSet_con_t       type_con,
          bdf.bdf_key           key_con,
          bdf.bdf_recid             recid_con,
          bdf.bdf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid              bsRecid_con,
          bs.bs_stamp              bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level  bsLevel_con,
          bs.bck_type        bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          bdf.blocks            blocks_con,
          bdf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          decode(bdf.incr_scn, 0, full_act_t, incremental_act_t)
                                type_act,
          bdf.incr_scn          fromSCN_act,
          bdf.ckp_scn           toSCN_act,
          bdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bdf.dbinc_key         dbincKey_act,
          bdf.incr_level        level_act,
          bdf.section_size      section_size_act,
 
          bdf.file#             dfNumber_obj,
          bdf.create_scn        dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bdf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          bdf.abs_fuzzy_scn     afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          bdf.foreign_dbid      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          bdf.plugin_scn        pluginSCN_obj,
          bdf.plugin_reset_scn  pluginRlgSCN_obj,
          bdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          decode(bdf.plugged_readonly, 'NO', bdf.ckp_scn,
                 bdf.plugin_scn)
                                newToSCN_act,
          decode(bdf.plugin_scn, 0, dbinc.reset_scn,
                 bdf.plugin_reset_scn)
                                newRlgSCN_act,
          decode(bdf.plugin_scn, 0, dbinc.reset_time,
                 bdf.plugin_reset_time)
                                newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          bdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
--
--
--
     FROM  bs, bdf, dbinc
   WHERE (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
     AND (findDatafileBackup_c.onlyrdf = 0)
     AND (dbinc.db_key = this_db_key)            -- belongs to this database
     AND (bs.db_key = this_db_key)               -- belongs to this database
     AND (bdf.dbinc_key = dbinc.dbinc_key)       -- join bdf and dbinc
     AND (bdf.bs_key = bs.bs_key)                -- join bdf and bs
     AND bs.bck_type != 'L'                      -- only datafile backups
     AND (findDatafileBackup_c.reset_scn is NULL  OR
          canApplyAnyRedo = TRUE# OR
          (bdf.plugged_readonly = 'NO' AND
           findDatafileBackup_c.reset_scn  = dbinc.reset_scn AND
           findDatafileBackup_c.reset_time = dbinc.reset_time) OR
          (bdf.plugged_readonly = 'YES' AND
           findDatafileBackup_c.reset_scn  = bdf.plugin_reset_scn AND
           findDatafileBackup_c.reset_time = bdf.plugin_reset_time))
     AND bdf.file# = nvl(findDatafileBackup_c.fno, bdf.file#)
     AND bdf.file# != 0                              -- no ctrl bkps
     AND (onlytc = FALSE#     OR
          tc_database = TRUE# OR
          isTranslatedFno(bdf.file#) = TRUE#)        -- only tnslated files
     AND ((findDatafileBackup_c.pluginSCN = 0  AND
           bdf.plugin_scn = 0                  AND
           bdf.create_scn = findDatafileBackup_c.crescn)
          OR
          (findDatafileBackup_c.pluginSCN != 0 AND
           bdf.plugin_scn = findDatafileBackup_c.pluginSCN)
          OR
          (findDatafileBackup_c.pluginSCN = 0 AND
           findDatafileBackup_c.crescn IS NULL))
     AND (findDatafileBackup_c.completedAfter is NULL OR
          bs.completion_time >= findDatafileBackup_c.completedAfter)
     AND (findDatafileBackup_c.completedBefore is NULL OR
          bs.completion_time <= findDatafileBackup_c.completedBefore)
     AND (findDatafileBackup_c.untilSCN is NULL OR
          (bdf.plugged_readonly = 'NO' AND
           bdf.ckp_scn <= findDatafileBackup_c.untilSCN) OR
          (bdf.plugged_readonly = 'YES' AND
           bdf.plugin_scn <= findDatafileBackup_c.untilSCN))
--
--
--
--
--
--
--
     AND (findDatafileBackup_c.level is NULL OR
         bdf.incr_level <= findDatafileBackup_c.level OR
         (findDatafileBackup_c.allowCumuLevelN = TRUE# AND
          bdf.create_scn = bdf.incr_scn AND
          bdf.foreign_dbid = 0))
     AND (bs.site_key IS NULL         OR -- always return null site_key
          user_site_key = bs.site_key OR -- user interested in one site
          (user_site_key IS NULL AND     -- return rows per access attr
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key)))
     AND (guidQualifier IS NULL OR bdf.pdb_key = guid2pdbKeyQualifier)
 
  ORDER BY  dfNumber_obj,         -- dfNumber_obj
            newRlgSCN_act  desc,  -- rlgSCN_act, last incarnation first
            newRlgTime_act desc,  -- rlgTime_act
            newToSCN_act   desc,  -- toSCN_act
            stamp_con      desc;  -- stamp_con
 
 
CURSOR findDatafileCopyKey(
   copyKey              IN     number
  ,statusMask           IN     binary_integer)
RETURN rcvRec_t IS
--
   SELECT imageCopy_con_t       type_con,
          cdf_key               key_con,
          cdf_recid             recid_con,
          cdf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          cdf.ckp_scn           toSCN_act,
          cdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          cdf.dbinc_key         dbincKey_act,
          incr_level            level_act,
          0                     section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          cdf.pdb_key           pdbKey_obj,
 
          cdf.keep_options      keep_options,
          cdf.keep_until        keep_until,
 
          cdf.abs_fuzzy_scn     afzSCN_act,
          cdf.rcv_fuzzy_time    rfzTime_act,
          cdf.rcv_fuzzy_scn     rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          cdf.foreign_dbid      foreignDbid_obj,
          decode(cdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          cdf.plugin_scn        pluginSCN_obj,
          cdf.plugin_reset_scn  pluginRlgSCN_obj,
          cdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          cdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM cdf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = cdf.dbinc_key       -- join cdf and dbinc
      AND (findDatafileCopyKey.copyKey = cdf_key)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
 
    ORDER BY dfNumber_obj,              -- for duplicate filtering
             decode(pluggedRonly_obj, 0, toSCN_act, pluginSCN_obj) desc,
--
             stamp_con desc;            -- to get most recent
 
CURSOR findControlFileCopyKey(
   copyKey              IN     number
  ,statusMask           IN     binary_integer)
RETURN rcvRec_t IS
--
   SELECT imageCopy_con_t       type_con,
          ccf_key               key_con,
          ccf_recid             recid_con,
          ccf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          create_time           cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          ccf.ckp_scn           toSCN_act,
          ccf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          ccf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          ccf.pdb_key           pdbKey_obj,
 
          ccf.keep_options      keep_options,
          ccf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM ccf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = ccf.dbinc_key       -- join cdf and dbinc
      AND (findControlFileCopyKey.copyKey = ccf_key)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
    ORDER BY toSCN_act desc,            -- for tag translation
             stamp_con desc;            -- to get most recent
 
 
 
CURSOR findBackupsetFiles(
   bskey                IN     number)
RETURN rcvRec_t IS
--
   SELECT backupSet_con_t       type_con,
          bdf_key               key_con,
          bdf_recid             recid_con,
          bdf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          bdf.blocks            blocks_con,
          bdf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          decode(bdf.incr_scn, 0, full_act_t, incremental_act_t)
                                type_act,
          bdf.incr_scn          fromSCN_act,
          bdf.ckp_scn           toSCN_act,
          bdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bdf.dbinc_key         dbincKey_act,
          bdf.incr_level        level_act,
          bdf.section_size      section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bdf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          bdf.abs_fuzzy_scn     afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          bdf.foreign_dbid      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          bdf.plugin_scn        pluginSCN_obj,
          bdf.plugin_reset_scn  pluginRlgSCN_obj,
          bdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          bdf.sparse_backup     sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bdf, bs, dbinc
    WHERE (allIncarnations = TRUE# OR
           canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
      AND dbinc.db_key     = this_db_key        -- belongs to this database
      AND dbinc.dbinc_key  = bdf.dbinc_key      -- join bdf and dbinc
      AND bdf.bs_key       = bs.bs_key          -- join bdf and bs
      AND bs.bs_key        = bskey
      AND bs.bck_type     != 'L'                -- only datafile backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
    UNION ALL
--
   SELECT backupSet_con_t       type_con,
          bcf_key               key_con,
          bcf_recid             recid_con,
          bcf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          nvl(bcf.blocks,0)     blocks_con,
          bcf.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          bcf.ckp_scn           toSCN_act,
          bcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          bcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          bcf.autobackup_sequence
                                cfSequence_obj,
          bcf.autobackup_date   cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                 cfType_obj,
          bcf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bcf, bs, dbinc
    WHERE (allIncarnations = TRUE# OR
           canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
      AND dbinc.db_key     = this_db_key        -- belongs to this database
      AND dbinc.dbinc_key  = bcf.dbinc_key      -- join bcf and dbinc
      AND bcf.bs_key       = bs.bs_key          -- join bcf and bs
      AND bs.bs_key        = bskey
      AND bs.bck_type     != 'L'                -- ignore archivelog backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
    UNION ALL
--
   SELECT backupSet_con_t       type_con,
          bsf_recid             key_con,
          bsf_recid             recid_con,
          bsf_stamp             stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          0                     blocks_con,
          0                     blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          0                     toSCN_act,
          modification_time     toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          bsf.pdb_key           pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bsf, bs, db
    WHERE bsf.bs_key = bs.bs_key                -- join bsf and bs
      AND bs.db_key = this_db_key               -- belongs to this database
      AND bsf.db_key = db.db_key                -- join bsf and db
      AND bs.bs_key = bskey
      AND bs.bck_type != 'L'                    -- ignore archivelog backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
    UNION ALL
--
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM brl, bs, dbinc
    WHERE (allIncarnations = TRUE# OR
           canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
      AND dbinc.db_key     = this_db_key        -- belongs to this database
      AND dbinc.dbinc_key  = brl.dbinc_key      -- join brl and dbinc
      AND brl.bs_key       = bs.bs_key          -- join brl and bs
      AND bs.bs_key        = bskey
      AND bs.bck_type      = 'L'                -- only archivelog backups
      AND (bs.site_key IS NULL         OR       -- always return null site_key
           user_site_key = bs.site_key OR       -- user interested in one site
           (user_site_key IS NULL AND           -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
--
    ORDER BY dfNumber_obj,
             logThread_obj,
             logSequence_obj,
             logTerminal_obj desc;
 
--
--
--
 
CURSOR findProxyCopy(
   tag                  IN     varchar2       DEFAULT NULL
  ,handle               IN     varchar2       DEFAULT NULL
  ,deviceType           IN     varchar2       DEFAULT NULL
  ,statusMask           IN     binary_integer
  ,pdbKey               IN     number         DEFAULT NULL
  ,guid                 IN     varchar2       DEFAULT NULL)
RETURN rcvRec_t IS
   SELECT proxyCopy_con_t       type_con,
          xdf_key               key_con,
          xdf_recid             recid_con,
          xdf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xdf.ckp_scn           toSCN_act,
          xdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xdf.dbinc_key         dbincKey_act,
          incr_level            level_act,
          0                     section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          xdf.pdb_key           pdbKey_obj,
 
          xdf.keep_options      keep_options,
          xdf.keep_until        keep_until,
 
          xdf.abs_fuzzy_scn     afzSCN_act,
          xdf.rcv_fuzzy_time    rfzTime_act,
          xdf.rcv_fuzzy_scn     rfzSCN_act,
          xdf.media             media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          xdf.foreign_dbid      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          xdf.plugin_scn        pluginSCN_obj,
          xdf.plugin_reset_scn  pluginRlgSCN_obj,
          xdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xdf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = xdf.dbinc_key       -- join xdf and dbinc
      AND (findProxyCopy.tag IS NULL OR
           findProxyCopy.tag = tag)
      AND (findProxyCopy.handle IS NULL OR
           findProxyCopy.handle = handle)
      AND (findProxyCopy.deviceType IS NULL OR
           findProxyCopy.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
      AND (guid IS NULL OR findProxyCopy.pdbKey = xdf.pdb_key)
 
    UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xcf_key               key_con,
          xcf_recid             recid_con,
          xcf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- xcf doesn't have blocks
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xcf.ckp_scn           toSCN_act,
          xcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          xcf.pdb_key           pdbKey_obj,
 
          xcf.keep_options      keep_options,
          xcf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xcf, dbinc
    WHERE db_key = this_db_key          -- belongs to this database
      AND dbinc.dbinc_key = xcf.dbinc_key       -- join dbinc and xcf
      AND (findProxyCopy.tag IS NULL OR
           findProxyCopy.tag = tag)
      AND (findProxyCopy.handle IS NULL OR
           findProxyCopy.handle = handle)
      AND (findProxyCopy.deviceType IS NULL OR
           findProxyCopy.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
      AND (guid IS NULL OR findProxyCopy.pdbKey = xcf.pdb_key)
 
    UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          -1                    dfNumber_obj,         -- to sort last
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xal, dbinc
    WHERE db_key = this_db_key                  -- belongs to this database
      AND dbinc.dbinc_key = xal.dbinc_key       -- join dbinc and xal
--
      AND (findProxyCopy.tag IS NULL OR
           findProxyCopy.tag = tag)
      AND (findProxyCopy.handle IS NULL OR
           findProxyCopy.handle = handle)
      AND (findProxyCopy.deviceType IS NULL OR
           findProxyCopy.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
      AND (findProxyCopy.guid IS NULL)
 
    ORDER BY dfnumber_obj;
 
CURSOR findProxyCopyKey(
   key                  IN     number         DEFAULT NULL
  ,deviceType           IN     varchar2       DEFAULT NULL
  ,statusMask           IN     binary_integer)
RETURN rcvRec_t IS
   SELECT proxyCopy_con_t       type_con,
          xdf_key               key_con,
          xdf_recid             recid_con,
          xdf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xdf.ckp_scn           toSCN_act,
          xdf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xdf.dbinc_key         dbincKey_act,
          incr_level            level_act,
          0                     section_size_act,
 
          file#                 dfNumber_obj,
          create_scn            dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          xdf.pdb_key           pdbKey_obj,
 
          xdf.keep_options      keep_options,
          xdf.keep_until        keep_until,
 
          xdf.abs_fuzzy_scn     afzSCN_act,
          xdf.rcv_fuzzy_time    rfzTime_act,
          xdf.rcv_fuzzy_scn     rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          xdf.foreign_dbid      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly_obj,
          xdf.plugin_scn        pluginSCN_obj,
          xdf.plugin_reset_scn  pluginRlgSCN_obj,
          xdf.plugin_reset_time pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xdf, dbinc
    WHERE dbinc.db_key = this_db_key            -- belongs to this database
      AND dbinc.dbinc_key = xdf.dbinc_key       -- join xdf and dbinc
      AND (findProxyCopyKey.key = xdf_key)
      AND (findProxyCopyKey.deviceType IS NULL OR
           findProxyCopyKey.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
 
    UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xcf_key               key_con,
          xcf_recid             recid_con,
          xcf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- xcf doesn't have blocks
          block_size            blockSize_con,
          device_type           deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          xcf.ckp_scn           toSCN_act,
          xcf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          xcf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          nvl(controlfile_type, 'B')
                                cfType_obj,
          xcf.pdb_key           pdbKey_obj,
 
          xcf.keep_options      keep_options,
          xcf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM xcf, dbinc
    WHERE db_key = this_db_key          -- belongs to this database
      AND dbinc.dbinc_key = xcf.dbinc_key       -- join dbinc and xcf
      AND (findProxyCopyKey.key = xcf_key)
      AND (findProxyCopyKey.deviceType IS NULL OR
           findProxyCopyKey.deviceType = device_type)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
   UNION ALL
 
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
      FROM xal, dbinc
    WHERE db_key = this_db_key                  -- belongs to this database
      AND dbinc.dbinc_key = xal.dbinc_key       -- join dbinc and xal
      AND (findProxyCopyKey.key = xal_key)
      AND (findProxyCopyKey.deviceType IS NULL OR
           findProxyCopyKey.deviceType = device_type)
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#;
 
 
--
--
--
--
--
--
--
--
--
 
CURSOR findArchivedLogCopy(
   currentIncarnation   IN     number
  ,thread               IN     number
  ,sequence             IN     number
  ,lowSCN               IN     number
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,statusMask           IN     binary_integer
  ,needstby             IN     number         DEFAULT NULL)
RETURN rcvRec_t IS
--
   SELECT imageCopy_con_t       type_con,
          al_key                key_con,
          recid                 recid_con,
          stamp                 stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          name                  fileName_con,
          to_date(null)         tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          blocks                blocks_con,
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc_key             dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          sequence#             logSequence_obj,
          thread#               logThread_obj,
          resetlogs_change#     logRlgSCN_obj,
          resetlogs_time        logRlgTime_obj,
          first_change#         logLowSCN_obj,
          first_time            logLowTime_obj,
          next_change#          logNextSCN_obj,
          next_time             logNextTime_obj,
          terminal              logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM rc_archived_log
    WHERE db_key = this_db_key                    -- belongs to this database
      AND(findArchivedLogCopy.currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc_key)
      AND (thread IS NULL OR thread# = thread)
      AND (sequence IS NULL OR sequence# = sequence)
      AND (lowSCN IS NULL OR first_change# = lowSCN)
--
--
--
--
      AND (pattern IS NULL OR name LIKE pattern)
      AND (completedAfter IS NULL OR completion_time >= completedAfter)
      AND (completedBefore IS NULL OR completion_time <= completedBefore)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby is NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
--
      AND (archived = 'YES')
      AND (tc_thread IS NULL   OR thread# = tc_thread)
      AND (tc_fromSeq IS NULL  OR sequence# >= tc_fromSeq)
      AND (tc_toSeq IS NULL    OR sequence# <= tc_toSeq)
      AND (tc_fromSCN IS NULL  OR next_change# > tc_fromSCN)
      AND (tc_toSCN IS NULL    OR first_change# < tc_toSCN)
      AND (tc_pattern IS NULL  OR name like tc_pattern)
      AND (tc_fromTime IS NULL OR next_time > tc_fromTime)
      AND (tc_toTime IS NULL   OR first_time <= tc_toTime)
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal desc, stamp_con desc;
 
CURSOR findArcLogBackup(
   sourcemask           IN     number
  ,currentIncarnation   IN     number         DEFAULT TRUE#
  ,thread               IN     number
  ,sequence             IN     number
  ,lowSCN               IN     number
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable)
RETURN rcvRec_t IS
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM brl, bs, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND (thread IS NULL OR brl.thread# = thread)
      AND (sequence IS NULL OR brl.sequence# = sequence)
      AND (lowSCN IS NULL OR brl.low_scn = lowSCN)
      AND dbinc.dbinc_key = brl.dbinc_key      -- join dbinc, brl
      AND bs.bs_key       = brl.bs_key         -- join bs, brl
      AND bs.bck_type     = 'L'                -- only archivelog backups
--
--
      AND (completedAfter  IS NULL OR bs.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR bs.completion_time <= completedBefore)
      AND (tc_thread IS NULL       OR brl.thread# = tc_thread)
      AND (tc_fromSeq IS NULL      OR brl.sequence# >= tc_fromSeq)
      AND (tc_toSeq IS NULL        OR brl.sequence# <= tc_toSeq)
      AND (tc_fromSCN IS NULL      OR brl.next_scn > tc_fromSCN)
      AND (tc_toSCN IS NULL        OR brl.low_scn < tc_toSCN)
      AND (tc_fromTime IS NULL     OR brl.next_time > tc_fromTime)
      AND (tc_toTime IS NULL       OR brl.low_time <= tc_toTime)
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
 
--
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          xal.keep_options      keep_options,
          xal.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
      FROM xal, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND (thread IS NULL OR xal.thread# = thread)
      AND (sequence IS NULL OR xal.sequence# = sequence)
      AND (lowSCN IS NULL OR xal.low_scn = lowSCN)
      AND dbinc.dbinc_key = xal.dbinc_key      -- join dbinc, xal
      AND decode(statusMask, BSavailable,
                 decode(xal.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(xal.status, statusMask)) = TRUE#
      AND (findArcLogBackup.tag is NULL OR
           tag = findArcLogBackup.tag)
      AND (findArcLogBackup.pattern IS NULL OR
           xal.handle LIKE findArcLogBackup.pattern)
      AND (completedAfter  IS NULL OR xal.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR xal.completion_time <= completedBefore)
      AND (tc_thread IS NULL       OR xal.thread# = tc_thread)
      AND (tc_fromSeq IS NULL      OR xal.sequence# >= tc_fromSeq)
      AND (tc_toSeq IS NULL        OR xal.sequence# <= tc_toSeq)
      AND (tc_fromSCN IS NULL      OR xal.next_scn > tc_fromSCN)
      AND (tc_toSCN IS NULL        OR xal.low_scn < tc_toSCN)
      AND (tc_fromTime IS NULL     OR xal.next_time > tc_fromTime)
      AND (tc_toTime IS NULL       OR xal.low_time <= tc_toTime)
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
    ORDER BY logRlgSCN_obj,
             logRlgTime_obj,
             logThread_obj,
             logSequence_obj,
             logTerminal_obj desc,
             stamp_con desc;
 
--
--
--
CURSOR findRangeArcLogBackup(
   sourcemask           IN     number
  ,currentIncarnation   IN     number         DEFAULT TRUE#
  ,minthread            IN     number
  ,minsequence          IN     number
  ,minlowSCN            IN     number
  ,maxthread            IN     number
  ,maxsequence          IN     number
  ,maxlowSCN            IN     number
  ,tag                  IN     varchar2       DEFAULT NULL
  ,pattern              IN     varchar2       DEFAULT NULL
  ,completedAfter       IN     date           DEFAULT NULL
  ,completedBefore      IN     date           DEFAULT NULL
  ,statusMask           IN     binary_integer DEFAULT BSavailable)
RETURN rcvRec_t IS
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM brl, bs, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, backupSet_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND brl.thread# between minthread and maxthread
      AND brl.sequence# between minsequence and maxsequence
      AND brl.low_scn between minlowSCN and maxlowSCN
      AND dbinc.dbinc_key = brl.dbinc_key      -- join dbinc, brl
      AND bs.bs_key       = brl.bs_key         -- join bs, brl
      AND bs.bck_type     = 'L'                -- only archivelog backups
--
--
      AND (completedAfter  IS NULL OR bs.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR bs.completion_time <= completedBefore)
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
 
--
   SELECT proxyCopy_con_t       type_con,
          xal_key               key_con,
          xal_recid             recid_con,
          xal_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          handle                fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          xal.status            status_con,
          xal.blocks            blocks_con,
          xal.block_size        blockSize_con,
          xal.device_type       deviceType_con,
          xal.completion_time   compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          redo_act_t            type_act,
          0                     fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          xal.sequence#         logSequence_obj,
          xal.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          xal.low_scn           logLowSCN_obj,
          xal.low_time          logLowTime_obj,
          xal.next_scn          logNextSCN_obj,
          xal.next_time         logNextTime_obj,
          xal.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          media                 media_con,
          'NO'                  isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
      FROM xal, dbinc
    WHERE (sourcemask is NULL OR bitand(sourcemask, proxyCopy_con_t) != 0)
      AND  dbinc.db_key = this_db_key             -- belongs to this database
      AND (currentIncarnation = FALSE# OR
           canApplyAnyRedo = TRUE# OR
           this_dbinc_key = dbinc.dbinc_key)
      AND xal.thread# between minthread and maxthread
      AND xal.sequence# between minsequence and maxsequence
      AND xal.low_scn between minlowSCN and maxlowSCN
      AND dbinc.dbinc_key = xal.dbinc_key      -- join dbinc, xal
      AND decode(statusMask, BSavailable,
                 decode(xal.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(xal.status, statusMask)) = TRUE#
      AND (findRangeArcLogBackup.tag is NULL OR
           tag = findRangeArcLogBackup.tag)
      AND (findRangeArcLogBackup.pattern IS NULL OR
           xal.handle LIKE findRangeArcLogBackup.pattern)
      AND (completedAfter  IS NULL OR xal.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR xal.completion_time <= completedBefore)
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
    ORDER BY logRlgSCN_obj desc,
             logRlgTime_obj desc,
             logLowSCN_obj desc,
             logTerminal_obj desc, -- records marked 'YES' must be first
             stamp_con desc;
 
CURSOR findAllBackupPiece(
   backupType           IN     binary_integer
  ,tag                  IN     varchar2
  ,statusMask           IN     binary_integer
  ,completedAfter       IN     date
  ,completedBefore      IN     date
  ,onlyrdf              IN     binary_integer)
RETURN rcvRec_t IS
   SELECT backupset_con_t       type_con,
          bp.bp_key             key_con,
          bp.bp_recid           recid_con,
          bp.bp_stamp           stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          bs.incr_level         bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          bp.handle             fileName_con,
          bp.tag                tag_con,
          bp.copy#              copyNumber_con,
          bp.status             status_con,
          ceil(bp.bytes / bs.block_size)
                                blocks_con,
          bs.block_size         blockSize_con,
          bp.device_type        deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          bp.piece#             pieceNumber_con,
          bp.completion_time    bpCompTime_con,
          bp.compressed         bpCompressed_con,
          multi_section         multi_section_con,
 
          to_number(null)       type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          to_number(null)       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          bs.keep_options       keep_options,
          bs.keep_until         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          bp.media              media_con,
          is_recovery_dest_file isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM bp, bs
    WHERE (bp.bs_key = bs.bs_key)       -- join bp and bs
      AND (bs.db_key = this_db_key)     -- this database
      AND (bp.status != 'D')
      AND (completedAfter IS NULL OR bs.completion_time >= completedAfter)
      AND (completedBefore IS NULL OR bs.completion_time <= completedBefore)
      AND (findAllBackupPiece.tag IS NULL or bp.tag = findAllBackupPiece.tag)
      AND (anyDevice = TRUE# OR isDeviceTypeAllocated(bp.device_type) = TRUE#)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND (findAllBackupPiece.backupType IS NULL OR
           isBackupTypeMatch(bs.bck_type, backupType) = TRUE#)
      AND (findAllBackupPiece.onlyrdf = 0 OR
           bp.is_recovery_dest_file = 'YES')
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
    ORDER BY bs.bs_key, bp.device_type, bp.tag, bp.copy#, bp.piece#;
 
--
--
--
 
getValidBackupSetLast   validBackupSetRec_t;
 
getValidBackupSetCursor varchar2(30);    -- to indicate what cursor was used
 
--
--
--
--
 
--
--
--
 
--
--
--
 
CURSOR findValidBackupSet_c(
   bsKey                   IN number
  ,pieceCount              IN number
  ,deviceType              IN varchar2 DEFAULT NULL
  ,tag                     IN varchar2 DEFAULT NULL
  ,mask                    IN binary_integer)
RETURN dbms_rcvman.validBackupSetRec_t IS
 
--
--
--
--
--
--
 
--
--
   SELECT device_type, tag,
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          copy#, 1
     FROM rc_backup_piece
    WHERE bs_key = findValidBackupSet_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND (findValidBackupSet_c.tag IS NULL OR
           findValidBackupSet_c.tag = tag)
      AND (findValidBackupSet_c.deviceType IS NULL OR
           findValidBackupSet_c.deviceType = device_type)
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (localOrsSiteKey IS NULL OR 
           (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Disk', 'Local')) OR 
           (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Tape', 'Replication') AND 
            localOrsSiteKey = rc_backup_piece.site_key))
    GROUP BY device_type, tag, copy#
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = findValidBackupSet_c.pieceCount) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= findValidBackupSet_c.pieceCount))
 
    UNION ALL
 
--
--
--
   SELECT device_type, tag,
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          to_number(null), 2
     FROM rc_backup_piece
    WHERE bs_key = findValidBackupSet_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND (findValidBackupSet_c.tag IS NULL OR
           findValidBackupSet_c.tag = tag)
      AND (findValidBackupSet_c.deviceType IS NULL OR
           findValidBackupSet_c.deviceType = device_type)
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (localOrsSiteKey IS NULL OR 
           (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Disk', 'Local')) OR 
           (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Tape', 'Replication') AND
            localOrsSiteKey = rc_backup_piece.site_key))
    GROUP BY device_type, tag
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = findValidBackupSet_c.pieceCount) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= findValidBackupSet_c.pieceCount))
 
    UNION ALL
 
--
--
--
--
--
--
--
   SELECT device_type, to_char(null),
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          to_number(null), 3
     FROM rc_backup_piece
    WHERE bs_key = findValidBackupSet_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND (findValidBackupSet_c.tag IS NULL OR
           findValidBackupSet_c.tag = tag)
      AND (findValidBackupSet_c.deviceType IS NULL OR
           findValidBackupSet_c.deviceType = device_type)
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (localOrsSiteKey IS NULL OR 
           (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Disk', 'Local')) OR 
           (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
            rc_backup_piece.ba_access IN ('Tape', 'Replication') AND
            localOrsSiteKey = rc_backup_piece.site_key))
    GROUP BY device_type
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = findValidBackupSet_c.pieceCount) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= findValidBackupSet_c.pieceCount))
    ORDER BY 1,2,3,4,5;
 
--
--
--
CURSOR findValidBackupSet1P_c(
   bsKey                   IN number
  ,pieceCount              IN number
  ,deviceType              IN varchar2 DEFAULT NULL
  ,tag                     IN varchar2 DEFAULT NULL
  ,mask                    IN binary_integer)
RETURN validBackupSetRec_t IS
 
--
--
--
--
--
--
--
--
--
   SELECT device_type, tag,
          decode(ba_access, 'Replication', 3, 'Tape', 2, nvl2(vb_key, 1, 0)),
          copy#, 1
      FROM rc_backup_piece
   WHERE bs_key = findValidBackupSet1P_c.bsKey
      AND decode(mask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, mask)) = TRUE#
      AND ((user_site_key = rc_backup_piece.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND
              rc_backup_piece.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND
              rc_backup_piece.device_type <> 'DISK') OR
             (this_site_key = nvl(rc_backup_piece.site_key, this_site_key)))))
      AND (findValidBackupSet1P_c.tag IS NULL OR
           findValidBackupSet1P_c.tag = tag)
      AND (findValidBackupSet1P_c.deviceType IS NULL OR
           findValidBackupSet1P_c.deviceType = device_type) ;
 
--
--
--
 
--
--
--
--
 
CURSOR findBackupPiece_c(
   tag          IN     varchar2 DEFAULT NULL
  ,handle       IN     varchar2 DEFAULT NULL
  ,deviceType   IN     varchar2 DEFAULT NULL
  ,copyNumber   IN     number   DEFAULT NULL
  ,statusMask   IN     binary_integer
  ,pdbKey       IN     number   DEFAULT NULL
  ,guid         IN     varchar2 DEFAULT NULL)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key               -- belongs to this db
      AND bs.db_key = this_db_key               -- belongs to this db
      AND bp.bs_key = bs.bs_key                 -- join bp and bs
      AND bp.status != 'D'
      AND (findBackupPiece_c.tag IS NULL OR
           tag = findBackupPiece_c.tag)
      AND (findBackupPiece_c.handle IS NULL OR
           handle = findBackupPiece_c.handle)
      AND (findBackupPiece_c.deviceType IS NULL OR
           device_type = findBackupPiece_c.deviceType)
      AND (findBackupPiece_c.copyNumber IS NULL OR
           copy# = findBackupPiece_c.copyNumber)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
      AND (guid IS NULL OR pdbKey = bp.pdb_key)
--
--
    ORDER BY piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
CURSOR findBackupPieceBpKey(
   bpKey        IN     number
  ,tag          IN     varchar2 DEFAULT NULL
  ,handle       IN     varchar2 DEFAULT NULL
  ,deviceType   IN     varchar2 DEFAULT NULL
  ,copyNumber   IN     number   DEFAULT NULL
  ,statusMask   IN     binary_integer)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key
      AND bs.db_key = this_db_key
      AND bp.status != 'D'
      AND bp.bs_key = bs.bs_key
      AND (bp_key = findBackupPieceBpKey.bpkey)
      AND (findBackupPieceBpKey.tag IS NULL OR
           tag = findBackupPieceBpKey.tag)
      AND (findBackupPieceBpKey.handle IS NULL OR
           handle = findBackupPieceBpKey.handle)
      AND (findBackupPieceBpKey.deviceType IS NULL OR
           device_type = findBackupPieceBpKey.deviceType)
      AND (findBackupPieceBpKey.copyNumber IS NULL OR
           copy# = findBackupPieceBpKey.copyNumber)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
--
    ORDER BY piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
CURSOR findBackupPieceBsKey1(
   bsKey        IN     number
  ,tag          IN     varchar2 DEFAULT NULL
  ,handle       IN     varchar2 DEFAULT NULL
  ,deviceType   IN     varchar2 DEFAULT NULL
  ,copyNumber   IN     number   DEFAULT NULL
  ,statusMask   IN     binary_integer)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key
      AND bs.db_key = this_db_key
      AND bp.status != 'D'
      AND bp.bs_key = bs.bs_key
      AND (bs.bs_key = findBackupPieceBsKey1.bsKey)
      AND (findBackupPieceBsKey1.tag IS NULL OR
           tag = findBackupPieceBsKey1.tag)
      AND (findBackupPieceBsKey1.handle IS NULL OR
           handle = findBackupPieceBsKey1.handle)
      AND (findBackupPieceBsKey1.deviceType IS NULL OR
           device_type = findBackupPieceBsKey1.deviceType)
      AND (findBackupPieceBsKey1.copyNumber IS NULL OR
           copy# = findBackupPieceBsKey1.copyNumber)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
--
    ORDER BY piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
CURSOR findBackupPieceBsKey2(
   startBsKey     IN      number
  ,tag            IN      varchar2
  ,statusMask     IN      binary_integer)
RETURN bpRec_t IS
   SELECT bp_recid,
          bp_stamp,
          bp_key,
          bp.bs_key,
          set_stamp,
          set_count,
          bs.bck_type,
          piece#,
          copy#,
          bp.status,
          bp.completion_time,
          handle,
          tag,
          device_type,
          media,
          bytes,
          compressed,
          bs.site_key,
          bp.vb_key,
          bp.ba_access am_access,
          bp.ba_access,
          0 ppl_pdb_id,
          0 ppl_cdb_dbid
     FROM bp, bs
    WHERE bp.db_key = this_db_key
      AND bs.db_key = this_db_key
      AND bp.status != 'D'
      AND bp.bs_key = bs.bs_key
      AND (bs.bs_key >= startBsKey)
      AND (findBackupPieceBsKey2.tag IS NULL OR
           bp.tag = findBackupPieceBsKey2.tag)
      AND decode(statusMask, BSavailable,
                 decode(bp.status, 'A', TRUE#, FALSE#),
                 isStatusMatch(bp.status, statusMask)) = TRUE#
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
--
--
    ORDER BY bs.bs_key, device_type,
             piece#, decode(ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0)),
             copy# desc, bp_stamp desc;
 
--
--
--
 
TYPE noRows_t IS RECORD
(
   error        number,                 -- error number
   msg          varchar2(100)           -- error msg
);
 
--
--
TYPE tablespace_t IS RECORD
(
   name   rc_tablespace.name%TYPE, -- tablespace name
   pdbId  number                   -- pdb id
);
TYPE tablespaceList_t IS TABLE OF tablespace_t INDEX BY BINARY_INTEGER;
skipTablespaceList    tablespaceList_t;
 
--
TYPE pdbNameList_t is table of number index by rc_pdbs.name%TYPE;
pdbNameList           pdbNameList_t;
 
--
--
TYPE pdbIdList_t is table of boolean index by binary_integer;
pdbIdList             pdbIdList_t;
 
--
TYPE pdbFileList_t is table of pdbFileRec_t index by binary_integer;
pdbFileList           pdbFileList_t;
 
--
--
--
 
getDatafileCursor varchar2(30);         -- pointer to current cursor
getDatafileNoRows noRows_t;             -- Set by function that opens cursor
getDatafileLast   dfRec_t;              -- The last row returned
 
--
--
--
--
--
--
--
--
CURSOR translateDatabase_c(
   fromSCN number,
   toSCN   number)
RETURN dfRec_t IS
   SELECT rcd.file#, rcd.creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          rcd.dbinc_key,
          offr.offline_scn, offr.online_scn, offr.online_time,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd, offr
    WHERE db_key = this_db_key AND                  -- belongs to this database
          rcd.dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          offr.file#(+) = rcd.file# AND         -- outer join with offr
          offr.create_scn(+) = creation_change# AND
          offr.dbinc_key(+) = this_dbinc_key AND
          offr.offr_stamp(+) = 0 AND          -- only offline ranges from kccfe
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) <= toSCN AND
          (drop_change# is null OR drop_change# > fromSCN) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
--
--
          (nvl(realf_site_key, translation_site_key) = site_key)
    ORDER BY rcd.file#;
 
CURSOR translateDatabaseOfPdbId_c(
   fromSCN number,
   toSCN   number,
   pdbId   number)
RETURN dfRec_t IS
   SELECT rcd.file#, rcd.creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          rcd.dbinc_key,
          offr.offline_scn, offr.online_scn, offr.online_time,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd, offr
    WHERE db_key = this_db_key AND                  -- belongs to this database
          rcd.dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          offr.file#(+) = rcd.file# AND         -- outer join with offr
          offr.create_scn(+) = creation_change# AND
          offr.dbinc_key(+) = this_dbinc_key AND
          offr.offr_stamp(+) = 0 AND          -- only offline ranges from kccfe
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) <= toSCN AND
          (drop_change# is null OR drop_change# > fromSCN) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
--
--
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          con_id = translateDatabaseOfPdbId_c.pdbId
    ORDER BY rcd.file#;
 
CURSOR translateDatabaseOfPdbIdL_c(
   fromSCN number,
   toSCN   number)
RETURN dfRec_t IS
   SELECT rcd.file#, rcd.creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          rcd.dbinc_key,
          offr.offline_scn, offr.online_scn, offr.online_time,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd, offr
    WHERE db_key = this_db_key AND                  -- belongs to this database
          rcd.dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          offr.file#(+) = rcd.file# AND         -- outer join with offr
          offr.create_scn(+) = creation_change# AND
          offr.dbinc_key(+) = this_dbinc_key AND
          offr.offr_stamp(+) = 0 AND          -- only offline ranges from kccfe
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) <= toSCN AND
          (drop_change# is null OR drop_change# > fromSCN) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
--
--
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          isTranslatedPdbId(con_id) = TRUE#
    ORDER BY rcd.file#;
 
--
--
CURSOR translateTablespace_c(
   tsName  varchar2
  ,pdbId   number)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd 
    WHERE db_key = this_db_key AND              -- part of this db
          tablespace_name = translateTablespace_c.tsName AND
          dbinc_key = this_dbinc_key AND
          (this_stdby_controlfile_scn is NULL OR 
           decode(rcd.plugin_change#, 0, rcd.creation_change#, 
                  rcd.plugin_change#) <= this_stdby_controlfile_scn) AND
          ((untilSCN is null AND drop_change# is null) OR
           ((decode(plugin_change#, 0, creation_change#,
                    plugin_change#) <= untilSCN) AND
            (drop_change# is null or drop_change# > untilSCN))) AND
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
          con_id = translateTablespace_c.pdbId
    ORDER BY file#;
 
--
--
 
CURSOR translateDatafileName(
   fileName varchar2)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd 
    WHERE db_key = this_db_key AND              -- belongs to this database
          name = translateDatafilename.fileName AND -- filename matches
          dbinc_key = this_dbinc_key AND
          drop_change# is null AND      -- filename currently part of db
          (untilSCN is null OR
           decode(plugin_change#, 0, creation_change#,
                  plugin_change#) < untilSCN) AND
--
          ((untilSCN is null) OR         -- no until clause
           ((untilTime is not null) AND NOT EXISTS
            (SELECT 1
               FROM rci_datafile_this_dbinc 
              WHERE dbinc_key = this_dbinc_key AND
                    name = translateDatafilename.fileName AND
                    (plugin_change# != 0 OR
                     nvl(creation_time, MINDATEVAL) < untilTime) AND
                    drop_time > untilTime AND
                    (nvl(realf_site_key, translation_site_key) = site_key))) OR
           ((untilSCN is not null) AND NOT EXISTS
            (SELECT 1
               FROM rci_datafile_this_dbinc
              WHERE dbinc_key = this_dbinc_key AND
                    name = translateDatafilename.fileName AND
                    decode(plugin_change#, 0, creation_change#,
                           plugin_change#) < untilSCN AND
                    drop_change# > untilSCN AND
                    (nvl(realf_site_key, translation_site_key)=site_key)))) AND
          (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO');
 
--
--
 
CURSOR translateDatafileNumber(
   fno  number)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd
    WHERE db_key = this_db_key AND              -- belongs to this database
          file# = translateDataFileNumber.fno AND       -- filenumber matches
          dbinc_key = this_dbinc_key AND
          ((untilSCN is null AND drop_change# is null) OR
           ((nvl(creation_time, MINDATEVAL) < untilTime OR
             decode(plugin_change#, 0, creation_change#,
                    plugin_change#) < untilSCN) AND
            (drop_time > untilTime OR
             drop_change# > untilSCN OR
             drop_change# is null))) AND
          (nvl(realf_site_key, translation_site_key) = site_key) AND
          (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO');
 
--
--
 
CURSOR translateDatafileCheckpoint(
   fno          number
  ,ckpSCN       number)
RETURN dfRec_t IS
   SELECT file#, creation_change#, creation_time,
          name, tablespace_name, ts#,
          null, blocks, block_size, bytes / 1024,
          null, stop_change#, read_only, rfile#,
          decode(included_in_database_backup, 'YES', 1, 0),
          aux_name,
          dbinc_key,
          NULL, NULL, NULL,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd
    WHERE db_key = this_db_key                  -- belongs to this database
      AND file# = translateDatafileCheckpoint.fno       -- filenumber matches
      AND dbinc_key = this_dbinc_key
      AND translateDatafileCheckpoint.ckpSCN >=
          decode(plugin_change#, 0, creation_change#, plugin_change#)
      AND (drop_change# IS NULL OR
           translateDatafileCheckpoint.ckpSCN < drop_change#)
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key);
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
CURSOR translateAllDf_c
RETURN dfRec_t IS
   SELECT DISTINCT
          file#                 dfNumber,
          creation_change#      dfCreationSCN,
          creation_time         dfCreationTime,
          name                  fileName,
          tablespace_name       tsName,
          ts#                   tsNumber,
          to_char(null)         status,
          blocks                blocks,
          block_size            blockSize,
          bytes / 1024          kbytes,
          to_number(null)       unrecovSCN,
          stop_change#          stopSCN,
          FALSE#                readOnly,
          rfile#                rfNumber,
          decode(included_in_database_backup, 'YES', 1, 0)
                                inBackup,
          aux_name              auxNAme,
          dbinc_key             dbincKey,
          NULL                  dfOfflineSCN,
          NULL                  dfOnlineSCN,
          NULL                  dfOnlineTime,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile rcd
    WHERE db_key = this_db_key
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key)
    ORDER BY file#, decode(dbinc_key, this_dbinc_key, 0, 1),
             newDfCreationSCN desc;
 
CURSOR translateAllDfOfPdbId_c(
   pdbId number)
RETURN dfRec_t IS
   SELECT DISTINCT
          file#                 dfNumber,
          creation_change#      dfCreationSCN,
          creation_time         dfCreationTime,
          name                  fileName,
          tablespace_name       tsName,
          ts#                   tsNumber,
          to_char(null)         status,
          blocks                blocks,
          block_size            blockSize,
          bytes / 1024          kbytes,
          to_number(null)       unrecovSCN,
          stop_change#          stopSCN,
          FALSE#                readOnly,
          rfile#                rfNumber,
          decode(included_in_database_backup, 'YES', 1, 0)
                                inBackup,
          aux_name              auxNAme,
          dbinc_key             dbincKey,
          NULL                  dfOfflineSCN,
          NULL                  dfOnlineSCN,
          NULL                  dfOnlineTime,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile rcd
    WHERE db_key = this_db_key
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key)
      AND con_id = translateAllDfOfPdbId_c.pdbId
    ORDER BY file#, decode(dbinc_key, this_dbinc_key, 0, 1),
             newDfCreationSCN desc;
 
CURSOR translateAllDfOfPdbIdL_c
RETURN dfRec_t IS
   SELECT DISTINCT
          file#                 dfNumber,
          creation_change#      dfCreationSCN,
          creation_time         dfCreationTime,
          name                  fileName,
          tablespace_name       tsName,
          ts#                   tsNumber,
          to_char(null)         status,
          blocks                blocks,
          block_size            blockSize,
          bytes / 1024          kbytes,
          to_number(null)       unrecovSCN,
          stop_change#          stopSCN,
          FALSE#                readOnly,
          rfile#                rfNumber,
          decode(included_in_database_backup, 'YES', 1, 0)
                                inBackup,
          aux_name              auxNAme,
          dbinc_key             dbincKey,
          NULL                  dfOfflineSCN,
          NULL                  dfOnlineSCN,
          NULL                  dfOnlineTime,
          decode(encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          decode(rcd.plugin_change#, 0, rcd.creation_change#,
                 rcd.plugin_change#) newDfCreationSCN,
          creation_thread,
          creation_size,
          con_id pdbId,
          pdb_key pdbKey,
          pdb_name pdbName,
          pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile rcd
    WHERE db_key = this_db_key
      AND (canHandleTransportableTbs = TRUE# OR plugged_readonly = 'NO')
      AND (nvl(realf_site_key, translation_site_key) = site_key)
      AND isTranslatedPdbId(con_id) = TRUE#
    ORDER BY file#, decode(dbinc_key, this_dbinc_key, 0, 1),
             newDfCreationSCN desc;
 
--
--
CURSOR translateCorruptList_c
RETURN dfRec_t IS
   SELECT DISTINCT
          rcd.file#, rcd.creation_change#, rcd.creation_time,
          rcd.name, rcd.tablespace_name, rcd.ts#,
          null, rcd.blocks, rcd.block_size, rcd.bytes / 1024,
          null, rcd.stop_change#, rcd.read_only, rcd.rfile#,
          decode(rcd.included_in_database_backup, 'YES', 1, 0),
          aux_name, rcd.dbinc_key, NULL, NULL, NULL,
          decode(rcd.encrypt_in_backup, 'ON', 1, 'OFF',2, 3) encrypt,
--
          rcd.foreign_dbid,
          decode(rcd.plugged_readonly, 'YES', 1, 0),
          rcd.plugin_change#,
          rcd.plugin_resetlogs_change#,
          rcd.plugin_resetlogs_time,
          to_number(null) newDfCreationSCN,
          rcd.creation_thread,
          rcd.creation_size,
          rcd.con_id pdbId,
          rcd.pdb_key pdbKey,
          rcd.pdb_name pdbName,
          rcd.pdb_closed pdbClosed,
          rcd.pdb_foreign_dbid pdbForeignDbid,
          decode(rcd.pdb_nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_datafile_this_dbinc rcd,
          (select distinct file#
             from rc_database_block_corruption
            where dbinc_key = this_dbinc_key
              and corruption_type != 'NOLOGGING') bc
    WHERE rcd.db_key = this_db_key AND          -- belongs to this database
          rcd.file# = bc.file# AND              -- filenumber matches
          rcd.dbinc_key = this_dbinc_key AND
          (canHandleTransportableTbs = TRUE# OR
           rcd.plugged_readonly = 'NO') AND
          ((untilSCN is null AND rcd.drop_change# is null) OR
           ((nvl(rcd.creation_time, MINDATEVAL) < untilTime OR
             decode(rcd.plugin_change#, 0, rcd.creation_change#,
                    rcd.plugin_change#) < untilSCN) AND
            (rcd.drop_time > untilTime OR
             rcd.drop_change# > untilSCN OR
             rcd.drop_change# is null))) AND
          (nvl(realf_site_key, translation_site_key) = site_key)
     ORDER BY rcd.file#;  -- do not change this as krmkcortr is
--
 
--
--
--
getTempfileCursor varchar2(30);         -- pointer to current cursor
 
--
--
--
--
CURSOR translateTempfile_c
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    ORDER BY file#;
 
CURSOR translateTempfileOfPdbId_c(
   pdbId number)
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    AND con_id = translateTempfileOfPdbId_c.pdbId
    ORDER BY file#;
 
CURSOR translateTempfileOfPdbIdL_c
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    AND isTranslatedPdbId(con_id) = TRUE#
    ORDER BY file#;
 
CURSOR translateTempfileName_c(fileName IN varchar2)
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND name = translateTempfileName_c.fileName -- filename matches
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    ORDER BY file#;
 
CURSOR translateTempfileNumber_c(fno IN number)
RETURN tfRec_t IS
   SELECT file#              tfNumber,
          creation_change#   tfCreationSCN,
          creation_time      tfCreationTime,
          name               fileName,
          tablespace_name    tsName,
          ts#                tsNumber,
          decode(autoextend, 'ON', 16, 0)
                             status,
          bigfile            isSFT,
          blocks             blocks,
          block_size         blockSize,
          maxsize            maxSize,
          nextsize           nextSize,
          rfile#             rfNumber,
          dbinc_key          dbincKey,
          con_id             pdbId,
          pdb_key            pdbKey,
          pdb_name           pdbName
   FROM rc_tempfile
  WHERE dbinc_key = this_dbinc_key         -- belongs to this incarnation
    AND drop_change# is NULL               -- tempfile exists now
    AND (untilSCN is NULL OR
         ((tablespace_creation_change# < untilSCN OR
           nvl(tablespace_creation_time, MINDATEVAL) < untilTime) AND
          tablespace_drop_change# IS NULL))
    AND file# = translateTempfileNumber_c.fno -- filenumber matches
    AND (nvl(realf_site_key, translation_site_key) = site_key)
    AND name is not NULL
    ORDER BY file#;
 
--
--
--
 
CURSOR translateOnlineLogs_c(srls IN number) IS
   SELECT thread#, group#, name
     FROM rc_redo_log
    WHERE dbinc_key = this_dbinc_key
     AND (nvl(realf_site_key, translation_site_key) = site_key)
     AND  ((type = 'ONLINE' AND srls = 0) OR
           (type = 'STANDBY' AND srls = 1))
    ORDER BY thread#, group#, name;
 
--
--
--
 
getArchivedLogNoRows            noRows_t;
getArchivedLogDuplicates        number;         -- Duplicate filtering flag
getArchivedLogLast              alRec_t;        -- used for duplicate filtering
getArchivedLogCursor            varchar2(40);
getArchivedLogDoingRecovery     number;        -- for filtering orphan logs
getArchivedLogOnlyrdf           number := 0;
getrcvRecLast                   rcvRec_t;
 
CURSOR translateArcLogKey(
   alKey        IN     number)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND archived = 'YES'
      AND al_key = translateArcLogKey.alKey;
 
CURSOR translateArcLogName(
   fname        IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number                       -- IGNORED!
  ,needstby     IN number  DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND name = translateArcLogName.fname
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby is NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
    ORDER BY is_recovery_dest_file desc, stamp desc;
 
CURSOR translateArcLogSeqRange(
   thread#      IN number
  ,incarn       IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number                       -- IGNORED!
  ,needstby     IN number  DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND dbinc_key = DECODE (translateArcLogSeqRange.incarn,
                                            -1, this_dbinc_key,
                                            0, dbinc_key,
                                            translateArcLogSeqRange.incarn)
      AND (translateArcLogSeqRange.thread# IS NULL OR
           thread# = translateArcLogSeqRange.thread#)
      AND sequence# between nvl(fromseq#, 0)
                        and nvl(toseq#, MAXSEQVAL)
      AND (pattern is null OR name like pattern)
      AND isstatusMatch(status,statusMask) = TRUE#
      AND archived = 'YES'  -- this will also filter out cleared logs
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             nvl(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
    ORDER BY thread#, sequence#, terminal DESC,
             is_recovery_dest_file DESC, stamp DESC;
 
--
CURSOR translateArcLogSeqRange2(
   thread#      IN number
  ,incarn       IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,statusMask   IN binary_integer  -- must atleast have BSdeleted
  ,online       IN number
  ,needstby     IN number  DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND dbinc_key = DECODE (translateArcLogSeqRange2.incarn,
                                            -1, this_dbinc_key,
                                            0, dbinc_key,
                                            translateArcLogSeqRange2.incarn)
      AND (translateArcLogSeqRange2.thread# IS NULL OR
           thread# = translateArcLogSeqRange2.thread#)
      AND sequence# between NVL(fromseq#, 0)
                        and NVL(toseq#, MAXSEQVAL)
      AND (archived = 'YES' OR     -- this will also filter out cleared logs
           (online = TRUE#
            and archived = 'NO'
            and name IS NOT NULL))
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
      AND isstatusMatch(status,statusMask) = TRUE#
 
    UNION ALL
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last (desc)
          brl.thread#,
          brl.sequence#,
          TO_CHAR(NULL),
          brl.low_scn,
          brl.low_time,
          brl.next_scn,
          brl.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          brl.blocks,
          brl.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          brl.terminal,
          0,
          0 site_key_order_col,
          0 source_dbid
     FROM brl, dbinc
    WHERE brl.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND brl.dbinc_key = DECODE (translateArcLogSeqRange2.incarn,
                                          -1, this_dbinc_key,
                                          0, brl.dbinc_key,
                                          translateArcLogSeqRange2.incarn)
      AND (translateArcLogSeqRange2.thread# IS NULL OR
           brl.thread# = translateArcLogSeqRange2.thread#)
      AND brl.sequence# BETWEEN NVL(fromseq#, 0)
                        AND NVL(toseq#, MAXSEQVAL)
--
--
 
    UNION                      -- to filter duplicates between brl and xal
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last (desc)
          xal.thread#,
          xal.sequence#,
          TO_CHAR(NULL),
          xal.low_scn,
          xal.low_time,
          xal.next_scn,
          xal.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          xal.blocks,
          xal.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          xal.terminal,
          xal.site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM xal, dbinc
    WHERE xal.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND xal.dbinc_key = DECODE (translateArcLogSeqRange2.incarn,
                                          -1, this_dbinc_key,
                                          0, xal.dbinc_key,
                                          translateArcLogSeqRange2.incarn)
      AND (translateArcLogSeqRange2.thread# IS NULL OR
           xal.thread# = translateArcLogSeqRange2.thread#)
      AND xal.sequence# BETWEEN NVL(fromseq#, 0)
                        AND NVL(toseq#, MAXSEQVAL)
--
--
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = NVL(xal.site_key, this_site_key)))))
 
--
--
    ORDER BY     4,       5,       21 DESC,                   18 DESC, 3 DESC;
 
--
CURSOR translateArcLogTimeRange(
   thread#      IN number
  ,incarn       IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number               -- IGNORED!
  ,needstby     IN number   DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR dbinc_key = this_dbinc_key)
      AND dbinc_key = DECODE (translateArcLogTimeRange.incarn,
                                       -1, this_dbinc_key,
                                       0, dbinc_key,
                                       translateArcLogTimeRange.incarn)
      AND (translateArcLogTimeRange.thread# IS NULL OR
           thread# = translateArcLogTimeRange.thread#)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND first_time  <= NVL(toTime, MAXDATEVAL)
      AND (pattern IS NULL OR name LIKE pattern)
      AND DECODE(statusMask, BSavailable,
                 DECODE(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND archived = 'YES'  -- this will also filter out cleared logs
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             nvl(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal DESC, is_recovery_dest_file DESC, stamp DESC;
 
--
--
CURSOR translateArcLogTimeRange2(
   thread#      IN number
  ,incarn       IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,statusMask   IN binary_integer  -- must atleast have BSdeleted
  ,online       IN number
  ,needstby     IN number   DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          DECODE(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR dbinc_key = this_dbinc_key)
      AND dbinc_key = DECODE (translateArcLogTimeRange2.incarn,
                                       -1, this_dbinc_key,
                                       0, dbinc_key,
                                       translateArcLogTimeRange2.incarn)
      AND (translateArcLogTimeRange2.thread# IS NULL OR
           thread# = translateArcLogTimeRange2.thread#)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND first_time  <= NVL(toTime, MAXDATEVAL)
      AND (archived = 'YES' OR   -- this will also filter out cleared logs
           (online = TRUE#
            AND archived = 'NO'
            AND name IS NOT NULL
            AND resetlogs_change# = this_reset_scn
            AND resetlogs_time = this_reset_time))
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             NVL(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
      AND isstatusMatch(status,statusMask) = TRUE#
 
    UNION ALL
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          thread#,
          sequence#,
          TO_CHAR(NULL),
          low_scn,
          low_time,
          next_scn,
          next_time,
          reset_scn,
          reset_time,
          blocks,
          block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          terminal,
          0,
          0 site_key_order_col,
          0 source_dbid
     FROM brl, dbinc
    WHERE brl.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR brl.dbinc_key = this_dbinc_key)
      AND dbinc.dbinc_key = DECODE (translateArcLogTimeRange2.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc.dbinc_key,
                                             translateArcLogTimeRange2.incarn)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND low_time  <= NVL(toTime, MAXDATEVAL)
      AND (translateArcLogTimeRange2.thread# IS NULL OR
           thread# = translateArcLogTimeRange2.thread#)
--
--
 
    UNION                      -- to filter duplicates between brl and xal
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          thread#,
          sequence#,
          TO_CHAR(NULL),
          low_scn,
          low_time,
          next_scn,
          next_time,
          reset_scn,
          reset_time,
          blocks,
          block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM xal, dbinc
    WHERE xal.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND (canApplyAnyRedo = TRUE# OR xal.dbinc_key = this_dbinc_key)
      AND dbinc.dbinc_key = DECODE (translateArcLogTimeRange2.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc.dbinc_key,
                                             translateArcLogTimeRange2.incarn)
      AND next_time >  NVL(fromTime, MINDATEVAL)
      AND low_time  <= NVL(toTime, MAXDATEVAL)
      AND (translateArcLogTimeRange2.thread# IS NULL OR
           thread# = translateArcLogTimeRange2.thread#)
--
--
--
--
--
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = NVL(xal.site_key, this_site_key)))))
 
    ORDER BY        11,         12,       4,       5,
                       21 DESC,     18 DESC,  3 DESC;
 
--
--
CURSOR translateArcLogSCNRange(
   thread#      IN number
  ,incarn       IN number
  ,sequence#    IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number
  ,needstby     IN number  DEFAULT NULL
  ,reset_scn    IN number
  ,reset_time   IN date)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          DECODE(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange.reset_scn IS NULL OR
              (translateArcLogSCNRange.reset_scn = resetlogs_change# AND
               translateArcLogSCNRange.reset_time = resetlogs_time))) OR
           (dbinc_key = this_dbinc_key))
      AND dbinc_key = DECODE (translateArcLogSCNRange.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc_key,
                                             translateArcLogSCNRange.incarn)
      AND (translateArcLogSCNRange.thread# IS NULL OR
           thread# = translateArcLogSCNRange.thread#)
      AND (translateArcLogSCNRange.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange.sequence#)
      AND next_change# > NVL(fromSCN, 0)
      AND first_change#  < NVL(toSCN, MAXSCNVAL)
      AND (pattern IS NULL OR name LIKE pattern)
      AND decode(statusMask, BSavailable,
                 DECODE(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND (archived = 'YES' OR      -- this will also filter out cleared logs
           (online = TRUE#
            and archived = 'NO'
            and name IS NOT NULL
            and resetlogs_change# = this_reset_scn
            and resetlogs_time = this_reset_time))
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = NVL(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby IS NULL OR
             NVL(is_standby, 'NO') = DECODE(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal DESC, is_recovery_dest_file DESC, stamp DESC;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
CURSOR translateArcLogSCNRange2(
   thread#      IN number
  ,incarn       IN number
  ,sequence#    IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,toTime       IN date
  ,statusMask   IN binary_integer  -- must atleast have BSdeleted
  ,online       IN number
  ,needstby     IN number  DEFAULT NULL  -- IGNORED
  ,reset_scn    IN number
  ,reset_time   IN date)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          DECODE(next_change#, highscnval, -2, stamp) stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          DECODE(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          DECODE(next_change#, highscnval, -1,
                 DECODE(site_key, this_site_key, 1, 0)) site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange2.reset_scn IS NULL OR
              (translateArcLogSCNRange2.reset_scn = resetlogs_change# AND
               translateArcLogSCNRange2.reset_time = resetlogs_time))) OR
           (dbinc_key = this_dbinc_key))
      AND dbinc_key = DECODE (translateArcLogSCNRange2.incarn,
                                             -1, this_dbinc_key,
                                             0, dbinc_key,
                                             translateArcLogSCNRange2.incarn)
      AND (translateArcLogSCNRange2.thread# IS NULL OR
           thread# = translateArcLogSCNRange2.thread#)
      AND (translateArcLogSCNRange2.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange2.sequence#)
      AND next_change# > NVL(fromSCN, 0)
      AND first_change#  < NVL(toSCN, MAXSCNVAL)
      AND (toTime IS NULL OR first_time < toTime)
      AND (archived = 'YES' OR   -- this will also filter out cleared logs
           (online = TRUE#
            and archived = 'NO'
            and name IS NOT NULL
            and resetlogs_change# = this_reset_scn
            and resetlogs_time = this_reset_time))
      AND isstatusMatch(status,statusMask) = TRUE#
 
    UNION ALL
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          brl.thread#,
          brl.sequence#,
          TO_CHAR(NULL),
          brl.low_scn,
          brl.low_time,
          brl.next_scn,
          brl.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          brl.blocks,
          brl.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          brl.terminal,
          0,
          0 site_key_order_col,
          0 source_dbid
     FROM brl, dbinc
    WHERE brl.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange2.reset_scn IS NULL OR
               (translateArcLogSCNRange2.reset_scn = dbinc.reset_scn AND
                translateArcLogSCNRange2.reset_time = dbinc.reset_time))) OR
           (dbinc.dbinc_key = this_dbinc_key))
      AND brl.dbinc_key = DECODE (translateArcLogSCNRange2.incarn,
                                               -1, this_dbinc_key,
                                               0, brl.dbinc_key,
                                               translateArcLogSCNRange2.incarn)
      AND (translateArcLogSCNRange2.thread# IS NULL OR
           thread# = translateArcLogSCNRange2.thread#)
      AND (translateArcLogSCNRange2.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange2.sequence#)
      AND next_scn > NVL(fromSCN, 0)
      AND low_scn  < NVL(toSCN, MAXSCNVAL)
      AND (toTime IS NULL OR low_time < toTime)
--
--
 
    UNION                      -- to filter duplicates between brl and xal
 
   SELECT DISTINCT                              -- to filter duplicates
          TO_NUMBER(NULL),
          TO_NUMBER(NULL),
          -1,                                   -- to sort last
          xal.thread#,
          xal.sequence#,
          TO_CHAR(NULL),
          xal.low_scn,
          xal.low_time,
          xal.next_scn,
          xal.next_time,
          dbinc.reset_scn,
          dbinc.reset_time,
          xal.blocks,
          xal.block_size,
          'D',
          TO_DATE(NULL),
          0,
          'NO',
          'NO',
          'N',
          xal.terminal,
          xal.site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM xal, dbinc
    WHERE xal.dbinc_key = dbinc.dbinc_key       -- join condition
      AND dbinc.db_key = this_db_key
      AND ((canApplyAnyRedo = TRUE# AND
              (translateArcLogSCNRange2.reset_scn IS NULL OR
              (translateArcLogSCNRange2.reset_scn = dbinc.reset_scn AND
               translateArcLogSCNRange2.reset_time = dbinc.reset_time))) OR
           (dbinc.dbinc_key = this_dbinc_key))
      AND xal.dbinc_key = DECODE (translateArcLogSCNRange2.incarn,
                                        -1, this_dbinc_key,
                                        0, xal.dbinc_key,
                                        translateArcLogSCNRange2.incarn)
      AND (translateArcLogSCNRange2.thread# IS NULL OR
           thread# = translateArcLogSCNRange2.thread#)
      AND (translateArcLogSCNRange2.sequence# IS NULL OR
           sequence# = translateArcLogSCNRange2.sequence#)
      AND next_scn > NVL(fromSCN, 0)
      AND low_scn  < NVL(toSCN, MAXSCNVAL)
      AND (toTime IS NULL OR low_time < toTime)
--
--
      AND ((user_site_key  = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = NVL(xal.site_key, this_site_key)))))
 
--
--
--
    ORDER BY         11,         12,       4,       5, 21 DESC,
                     23 DESC,      18 DESC,  3 DESC;
 
CURSOR translateArcLogPattern(
   pattern      IN varchar2
  ,statusMask   IN binary_integer
  ,online       IN number                       -- IGNORED!
  ,needstby     IN number   DEFAULT NULL)
RETURN alRec_t IS
   SELECT al_key,
          recid,
          stamp,
          thread#,
          sequence#,
          name,
          first_change#,
          first_time,
          next_change#,
          next_time,
          resetlogs_change#,
          resetlogs_time,
          blocks,
          block_size,
          status,
          completion_time,
          0,
          is_recovery_dest_file,
          compressed,
          decode(is_standby, 'YES', 'Y', 'N') stby,
          terminal,
          site_key,
          0 site_key_order_col,
          0 source_dbid
     FROM rc_archived_log
    WHERE (canApplyAnyRedo = TRUE# OR dbinc_key = this_dbinc_key)
      AND db_key = this_db_key
      AND (pattern is null or name like pattern)
      AND decode(statusMask, BSavailable,
                 decode(status, 'A', TRUE#, FALSE#),
                 isStatusMatch(status, statusMask)) = TRUE#
      AND archived = 'YES'
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(site_key, this_site_key)))))) OR
           (client_site_aware = FALSE# AND
            (needstby is NULL OR
             nvl(is_standby, 'NO') = decode(needstby, TRUE#, 'YES', 'NO') OR
             (terminal = 'YES') OR
             (first_change# >= lbacked_al_next_scn AND
              first_change# <= standby_became_primary_scn))))
--
    ORDER BY resetlogs_change#, resetlogs_time, thread#, sequence#,
             terminal desc, is_recovery_dest_file desc, stamp desc;
 
--
--
--
 
getControlFileCopySingleRow     boolean;
getControlFileCopyCursor        varchar2(30);
 
--
--
--
 
getDatafileCopyCursor           varchar2(30);
getDatafileCopyNoRows           noRows_t;
getDatafileCopyDuplicates       number;   -- match file number
getDatafileCopyLast             rcvRec_t;
getDatafileCopySingleRow        boolean;
getDatafileCopyLatestOnly       boolean;
 
--
--
--
 
getProxyCopyCursor              varchar2(30);
getProxyCopyNoRows              noRows_t;
getProxyCopyByHandle            boolean;
 
--
--
--
 
getBackupPieceCursor            varchar2(30);
getBackupPieceNoRows            noRows_t;
getBackupPieceDuplicates        number; -- TRUE# -> duplicates OK
--
getBackupPieceLast              bpRec_t;
--
--
getBackupPieceDeviceType        bp.device_type%TYPE;
getBackupPieceExpectedPieces    number;
getBackupPiecePieceCount        number;
getBackupPieceByHandle          boolean;
getBackupPieceAvailableMask     binary_integer;
getBackupPieceSeekLast          bpRec_t;
getBackupPieceCopyNumber        number;
getBackupPieceBskey             number;
 
--
--
--
findSpfileBackupCursor          boolean; -- TRUE# -> cursor opened
findControlfileBackupCursor     boolean; -- TRUE# -> cursor opened
 
 
--
--
--
 
listGetBackupTag                bp.tag%TYPE;
listGetBackupAvailableMask      binary_integer;
 
listGetProxyDatafileCursor      varchar2(30);
 
 
--
--
 
CURSOR lbal2(thread#       number,
             lowseq        number,
             highseq       number,
             lowscn        number,
             highscn       number,
             from_time     date  ,
             until_time    date)
RETURN rcvRec_t IS
   SELECT backupSet_con_t       type_con,
          brl.brl_key           key_con,
          brl.brl_recid         recid_con,
          brl.brl_stamp         stamp_con,
          bs.set_stamp          setStamp_con,
          bs.set_count          setCount_con,
          bs.bs_recid           bsRecid_con,
          bs.bs_stamp           bsStamp_con,
          bs.bs_key             bsKey_con,
          to_number(null)       bsLevel_con,
          bs.bck_type           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                elapseSecs_con,
          bs.pieces             pieceCount_con,
          to_char(null)         fileName_con,
          to_char(null)         tag_con,
          to_number(null)       copyNumber_con,
          to_char(null)         status_con,
          brl.blocks            blocks_con,
          brl.block_size        blockSize_con,
          to_char(null)         deviceType_con,
          bs.completion_time    compTime_con,
          to_date(null)         cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          multi_section         multi_section_con,
 
          full_act_t            type_act,
          to_number(null)       fromSCN_act,
          to_number(null)       toSCN_act,
          to_date(null)         toTime_act,
          to_number(null)       rlgSCN_act,
          to_date(null)         rlgTime_act,
          dbinc.dbinc_key       dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          to_number(null)       dfNumber_obj,
          to_number(null)       dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          brl.sequence#         logSequence_obj,
          brl.thread#           logThread_obj,
          dbinc.reset_scn       logRlgSCN_obj,
          dbinc.reset_time      logRlgTime_obj,
          brl.low_scn           logLowSCN_obj,
          brl.low_time          logLowTime_obj,
          brl.next_scn          logNextSCN_obj,
          brl.next_time         logNextTime_obj,
          brl.terminal          logTerminal_obj,
          to_char(null)         cfType_obj,
          to_number(null)       pdbKey_obj,
 
          to_number(null)       keep_options,
          to_date(null)         keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          'NO'                  isrdf_con,
          bs.site_key           site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
  from  brl, bs, dbinc
  where dbinc.db_key    = this_db_key      -- this database
  and   dbinc.dbinc_key = brl.dbinc_key    -- join dbinc, brl
  and   bs.bs_key       = brl.bs_key       -- join bs, brl
  and  (lbal2.thread# is null or brl.thread# = lbal2.thread#)
  and  (brl.sequence# between nvl(lbal2.lowseq, 0)
                     and     nvl(lbal2.highseq, MAXSEQVAL))
  and  (lowscn        is null or brl.low_scn >= lowscn)
  and  (highscn       is null or brl.next_scn<  highscn)
  and  (from_time     is null or bs.completion_time >= from_time)
  and  (until_time    is null or bs.completion_time <= until_time)
--
  and   bs.status != 'D'
  and   bs.bck_type = 'L'                  -- only archivelog backups
  order by bs.bs_key, brl.thread#, brl.sequence#, brl.terminal desc;
 
CURSOR ldbi(
   db_name varchar2,
   all_databases number)
IS
   SELECT db_key, dbinc_key, name, dbid, current_incarnation,
          resetlogs_change#, resetlogs_time, status dbinc_status
     FROM rc_database_incarnation
    WHERE (all_databases = 1) OR -- user wants all database incarnations
          ((all_databases = 0) AND
           ((name = ldbi.db_name) OR -- user asked for specific database
            (db_name is NULL AND this_db_key=db_key))) -- user wants mounted db
    ORDER BY db_key, resetlogs_change#, dbinc_key;
 
CURSOR lnni(
   db_name varchar2,
   alldbs  number)
IS
   SELECT node.db_key, dbid, name, database_role, db_unique_name
     FROM rc_database, node
    WHERE rc_database.db_key = node.db_key
      AND ((alldbs = 1) OR
           (lnni.db_name IS NOT NULL AND upper(lnni.db_name) = name) OR
           (lnni.db_name IS NULL AND this_db_key = node.db_key))
      AND substr(nvl(db_unique_name, 'A'),1,1) <> '$'
    ORDER BY dbid, database_role;
--
 
CURSOR lrtbs
IS
   SELECT DISTINCT ts.ts#, ts.ts_name, pdbinc.name
     FROM ts, tsatt, ckp, rci_pdbinc_this_dbinc pdbinc
 
--
    WHERE pdbinc.dbinc_key = this_dbinc_key 
      AND ts.pdbinc_key    = pdbinc.pdbinc_key
      AND (untilSCN is NULL or pdbinc.create_scn < untilSCN)
      AND (pdbinc.drop_scn is NULL or pdbinc.drop_scn > untilSCN)
      AND ts.dbinc_key     = tsatt.dbinc_key
      AND ts.ts#           = tsatt.ts#
      AND ts.pdbinc_key    = tsatt.pdbinc_key
      AND ts.create_scn    = tsatt.create_scn
--
--
--
      AND ckp.ckp_key(+)   = tsatt.end_ckp_key
 
--
      AND ts.dbinc_key     = this_dbinc_key
 
--
--
--
      AND (ts.create_scn < untilSCN or untilSCN is NULL)
 
--
--
--
--
--
      AND (ts.drop_scn > untilSCN or ts.drop_scn is NULL)
 
--
--
--
--
      AND (ckp.ckp_scn > untilSCN or ckp.ckp_scn is NULL)
 
--
--
      AND tsatt.rbs_count > 0
    ORDER BY 1,    -- ts#
             3;    -- pdbname
 
--
--
--
 
rcvRec_last     rcvRec_t;                       -- last record returned from:
--
--
 
--
--
--
 
CURSOR getOfflineRangeCopy_c(
   offrRecid    number
  ,offrCkpSCN   number
  ,cfCreTime    date
  ,dbincKey     number)
RETURN rcvRec_t IS
   SELECT imageCopy_con_t       type_con,
          ccf_key               key_con,
          ccf_recid             recid_con,
          ccf_stamp             stamp_con,
          to_number(null)       setStamp_con,
          to_number(null)       setCount_con,
          to_number(null)       bsRecid_con,
          to_number(null)       bsStamp_con,
          to_number(null)       bsKey_con,
          to_number(null)       bsLevel_con,
          to_char(null)         bsType_con,
          to_number(null)       elapseSecs_con,
          to_number(null)       pieceCount_con,
          fname                 fileName_con,
          tag                   tag_con,
          to_number(null)       copyNumber_con,
          status                status_con,
          to_number(null)       blocks_con,     -- ccf doesn't have blocks
          block_size            blockSize_con,
          'DISK'                deviceType_con,
          completion_time       compTime_con,
          create_time           cfCreationTime_con,
          to_number(null)       pieceNumber_con,
          to_date(null)         bpCompTime_con,
          to_char(null)         bpCompressed_con,
          to_char(null)         multi_section_con,
 
          full_act_t            type_act,
          0                     fromSCN_act,
          ccf.ckp_scn           toSCN_act,
          ccf.ckp_time          toTime_act,
          dbinc.reset_scn       rlgSCN_act,
          dbinc.reset_time      rlgTime_act,
          ccf.dbinc_key         dbincKey_act,
          to_number(null)       level_act,
          0                     section_size_act,
 
          0                     dfNumber_obj,
          0                     dfCreationSCN_obj,
          to_number(null)       cfSequence_obj,
          to_date(null)         cfDate_obj,
          to_number(null)       logSequence_obj,
          to_number(null)       logThread_obj,
          to_number(null)       logRlgSCN_obj,
          to_date(null)         logRlgTime_obj,
          to_number(null)       logLowSCN_obj,
          to_date(null)         logLowTime_obj,
          to_number(null)       logNextSCN_obj,
          to_date(null)         logNextTime_obj,
          to_char(null)         logTerminal_obj,
          to_char(null)         cfType_obj,
          ccf.pdb_key           pdbKey_obj,
 
          ccf.keep_options      keep_options,
          ccf.keep_until        keep_until,
 
          to_number(null)       afzSCN_act,
          to_date(null)         rfzTime_act,
          to_number(null)       rfzSCN_act,
          to_char(null)         media_con,
          is_recovery_dest_file isrdf_con,
          site_key              site_key_con,
          0                     foreignDbid_obj,
          0                     pluggedRonly_obj,
          0                     pluginSCN_obj,
          0                     pluginRlgSCN_obj,
          to_date(null)         pluginRlgTime_obj,
 
          to_number(null)       newDfCreationSCN_obj,
          to_number(null)       newToSCN_act,
          to_number(null)       newRlgSCN_act,
          to_date(null)         newRlgTime_act,
          to_char(null)         sfDbUniqueName_obj,
          to_char(null)         sparse_backup_con,
          0                     ppl_pdb_id_con,
          0                     ppl_cdb_dbid_con
     FROM ccf, dbinc
    WHERE dbinc.dbinc_key = getOfflineRangeCopy_c.dbincKey
      AND dbinc.dbinc_key = ccf.dbinc_key
      AND getOfflineRangeCopy_c.cfCretime = create_time
      AND getOfflineRangeCopy_c.offrCkpSCN < ccf.ckp_scn
      AND getOfflineRangeCopy_c.offrRecid >= min_offr_recid
      AND status = 'A'
      AND ((user_site_key = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
    ORDER BY stamp_con desc;
 
--
--
 
cursor rddf is
 
--
 
  select 2 preference,
         file#, COPY filetype, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0 incremental_change#,
         decode(decode(online_fuzzy,'NO',0,1)+decode(backup_fuzzy,'NO',0,1),
            0,greatest(nvl(absolute_fuzzy_change#,0),
                       nvl(recovery_fuzzy_change#,0)),
            maxscnval) fuzzy_change#,
            recid, stamp, name, 0 set_stamp, 0 set_count, cdf_key key,
            completion_time, 'DISK' device_type
  from rc_datafile_copy
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key = rc_datafile_copy.site_key) OR
         (user_site_key IS NULL AND
          ((disk_backups_shared = TRUE#) OR
           (this_site_key = nvl(rc_datafile_copy.site_key, this_site_key)))))
 
  union all
 
--
 
  select 3,
         file#, PROXY, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0,
         decode(decode(online_fuzzy,'NO',0,1)+decode(backup_fuzzy,'NO',0,1),
            0,greatest(nvl(absolute_fuzzy_change#,0),
                       nvl(recovery_fuzzy_change#,0)),
            maxscnval),
            recid, stamp, handle, 0, 0, xdf_key, completion_time, device_type
  from rc_proxy_datafile
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key  = rc_proxy_datafile.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(rc_proxy_datafile.site_key, this_site_key)))))
 
  union all
 
--
 
  select decode(bs.bck_type, 'D', 4,
                             'I', 5),
         file#,
         decode(bs.bck_type, 'D', FULL_DF_BACKUP,
                             'I', INCREMENTAL_DF_BACKUP),
         bdf.ckp_scn, bdf.ckp_time,
         dbinc.reset_scn, dbinc.reset_time, bdf.incr_scn,
         nvl(bdf.abs_fuzzy_scn,0),
         bs.bs_recid, bs.bs_stamp, null, bs.set_stamp, bs.set_count, bs.bs_key,
         bs.completion_time, null
  from bdf, bs, dbinc
  where dbinc.db_key    = this_db_key          -- this database
  and   dbinc.dbinc_key = bdf.dbinc_key        -- join dbinc, bdf
  and   bdf.bs_key      = bs.bs_key            -- join bdf, bs
  and   bs.status      != 'D'
  and   bs.bck_type    != 'L'                  -- only datafile backups
  and   (bs.site_key IS NULL         OR        -- always return null site_key
         user_site_key = bs.site_key OR        -- user interested in one site
         (user_site_key IS NULL AND            -- return rows per access attr
          (disk_backups_shared = TRUE# OR
           tape_backups_shared = TRUE# OR
           this_site_key = bs.site_key)))
 
  union all
 
--
 
  select 2,
         0, COPY, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0, 0, recid, stamp, name, 0, 0,
         ccf_key, completion_time, 'DISK'
  from rc_controlfile_copy
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key = rc_controlfile_copy.site_key) OR
         (user_site_key IS NULL AND
          ((disk_backups_shared = TRUE#) OR
           (this_site_key = nvl(rc_controlfile_copy.site_key,this_site_key)))))
 
  union all
 
--
 
  select 3,
         0, PROXY, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, 0, 0, recid, stamp, handle, 0, 0,
         xcf_key, completion_time, device_type
  from rc_proxy_controlfile
  where db_key = this_db_key
    and status != 'D'
    and ((user_site_key  = rc_proxy_controlfile.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key =nvl(rc_proxy_controlfile.site_key,this_site_key)))))
 
  union all
 
--
 
  select 4,
         0, FULL_DF_BACKUP,
         bcf.ckp_scn, bcf.ckp_time, dbinc.reset_scn, dbinc.reset_time,
         0, 0, bs.bs_recid, bs.bs_stamp, null,
         bs.set_stamp, bs.set_count, bs.bs_key, bs.completion_time, null
  from bcf, bs, dbinc
  where dbinc.db_key = this_db_key              -- this database
  and   dbinc.dbinc_key = bcf.dbinc_key         -- join dbinc, bcf
  and   bcf.bs_key = bs.bs_key                  -- join bcf, bs
  and   bs.status != 'D'
  and   bs.bck_type != 'L'                      -- ignore archivelog backups
  and   (bs.site_key IS NULL         OR         -- always return null site_key
         user_site_key = bs.site_key OR         -- user interested in one site
         (user_site_key IS NULL AND             -- return rows per access attr
          (disk_backups_shared = TRUE# OR
           tape_backups_shared = TRUE# OR
           this_site_key = bs.site_key)))
 
  union all
 
--
 
  select 1,
         file#, OFFLINE_RANGE, online_change#, online_time,
         resetlogs_change#, resetlogs_time, offline_change#, 0,
         recid, stamp, null, 0, 0, 0, online_time, null
  from rc_offline_range ofr
  where ofr.db_key = this_db_key
 
--
--
 
  order by 2 asc,  -- file#
           4 desc, -- checkpoint_change#
           1 asc,  -- preference
          15 desc; -- completion_time, to break ties if all else is equal
 
--
--
--
--
CURSOR translateDatabaseCorruption_c(dfnumber IN number)
IS
   SELECT file#, block#, blocks
     FROM rc_database_block_corruption bc
    WHERE bc.db_key = this_db_key AND           -- belongs to this database
          bc.dbinc_key = this_dbinc_key AND
          bc.file# = nvl(translateDatabaseCorruption_c.dfnumber, bc.file#) AND
          bc.corruption_type != 'NOLOGGING'
    ORDER BY file#, block#;   -- order same as in translateCorruptList_c.
--
--
--
 
 
--
--
--
 
CURSOR cntConfig_c
IS
   SELECT COUNT(*) FROM CONF
   WHERE db_key         = this_db_key
   AND   db_unique_name = nvl(user_db_unique_name, this_db_unique_name);
 
CURSOR getPrimarySite_c
IS
   SELECT db_unique_name FROM NODE
   WHERE db_key        = this_db_key
   AND   database_role = 'PRIMARY';
 
CURSOR findConfig_c(
   name varchar2,
   value varchar2,
   db_unique_name varchar2)
IS
    SELECT conf#, name, value
    FROM   rc_rman_configuration rm
    WHERE  db_key = this_db_key                  -- part of this database
    AND    (findConfig_c.name is null OR
            UPPER(findConfig_c.name) = UPPER(rm.name)) AND
           (findConfig_c.value is null OR
            UPPER(findConfig_c.value) = UPPER(rm.value)) AND
--
           ((nvl(findConfig_c.db_unique_name, rm.db_unique_name) =
             rm.db_unique_name) OR
            rm.db_unique_name IS NULL)                  -- generic conf rows
    ORDER BY conf#;
--
--
 
--
--
--
 
getLastBackupHistory bhistoryRec_t;
 
--
CURSOR dfBackupHistory_c1(
   file#       IN   number
  ,crescn      IN   number
  ,device_type IN   varchar2)
RETURN bhistoryRec_t IS
   SELECT
      bdf.file#                dfNumber,
      bdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bdf.ckp_scn              ckp_scn,
      bdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM bdf,
        dbinc,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT /*+no_merge*/ file#, create_scn, stop_scn, pdbinc_key
           FROM df
          WHERE create_scn = dfBackupHistory_c1.crescn
            AND file#      = dfBackupHistory_c1.file#
            AND dbinc_key  = this_dbinc_key) df,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (dfBackupHistory_c1.device_type IS NULL OR
                 dfBackupHistory_c1.device_type = bp.device_type)
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bdf.dbinc_key    = dbinc.dbinc_key       -- join dbinc, bdf
     AND dbinc.db_key     = this_db_key           -- this database
     AND bdf.create_scn   = df.create_scn         -- create scn match
     AND bdf.file#        = df.file#              -- join bdf, df
     AND bdf.bs_key       = bs.bs_key             -- join bdf, bs
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND bdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      cdf.file#                dfNumber,
      cdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      cdf.ckp_scn              ckp_scn,
      cdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      cdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM cdf,
        dbinc,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT /*+no_merge */ file#, create_scn, stop_scn, pdbinc_key
           FROM df
          WHERE create_scn = dfBackupHistory_c1.crescn
            AND file#      = dfBackupHistory_c1.file#
            AND dbinc_key  = this_dbinc_key) df
   WHERE cdf.dbinc_key   = dbinc.dbinc_key       -- join dbinc, cdf
     AND dbinc.db_key    = this_db_key           -- this database
     AND cdf.create_scn  = df.create_scn         -- create scn match
     AND cdf.file#       = df.file#              -- join cdf, df
     AND cdf.status      = 'A'                   -- available copy
     AND (dfBackupHistory_c1.device_type IS NULL OR
          dfBackupHistory_c1.device_type = 'DISK')
     AND ((user_site_key = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = dbinc.dbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND cdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      xdf.file#                dfNumber,
      xdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      xdf.ckp_scn              ckp_scn,
      xdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM xdf,
        dbinc,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT /*+no_merge*/ file#, create_scn, stop_scn, pdbinc_key
           FROM df
          WHERE create_scn = dfBackupHistory_c1.crescn
            AND file#      = dfBackupHistory_c1.file#
            AND dbinc_key  = this_dbinc_key) df
   WHERE xdf.dbinc_key   = dbinc.dbinc_key       -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key           -- this database
     AND xdf.create_scn  = df.create_scn         -- create scn match
     AND xdf.file#       = df.file#              -- join xdf, df
     AND xdf.status      = 'A'                   -- available proxy df
     AND (dfBackupHistory_c1.device_type IS NULL OR
          dfBackupHistory_c1.device_type = xdf.device_type)
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND xdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
--
   ORDER BY  dfNumber,
             create_scn,
             reset_scn,
             reset_time,
             ckp_scn  desc,
             stop_scn desc,
             compTime;
 
CURSOR dfBackupHistory_c2(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      bdf.file#                dfNumber,
      bdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bdf.ckp_scn              ckp_scn,
      bdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(bdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      bdf.plugin_scn           pluginSCN,
      bdf.plugin_reset_scn     pluginRlgSCN,
      bdf.plugin_reset_time    pluginRlgTime,
      decode(bdf.plugin_scn, 0,
             bdf.create_scn, bdf.plugin_scn)
                               newcreate_scn,
      decode(bdf.plugin_reset_scn, 0,
             dbinc.reset_scn, bdf.plugin_reset_scn)
                               newreset_scn,
      nvl(bdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM bdf,
        dbinc,
        df,
        rci_pdbinc_this_dbinc pdbinc,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
            AND (dfBackupHistory_c2.cmd is null OR       -- bug 6658764
                 dfBackupHistory_c2.cmd != 'B' OR
                 (dfBackupHistory_c2.cmd = 'B' AND       -- Backup command and
                  (dfBackupHistory_c2.ktag is null AND   -- nokeep cmd matches
                   bs.keep_options = 0) OR               -- nokeep backup or
                  (dfBackupHistory_c2.ktag = bp.tag and  -- keep backup cmd tag
                   bs.keep_options != 0)))               -- matches keep backup
            AND (dfBackupHistory_c2.device_type IS NULL OR
                 dfBackupHistory_c2.device_type = bp.device_type)
            AND ((dfBackupHistory_c2.pattern1 IS NULL AND
                  dfBackupHistory_c2.pattern2 IS NULL AND
                  dfBackupHistory_c2.pattern3 IS NULL AND
                  dfBackupHistory_c2.pattern4 IS NULL) OR
                 (bp.handle LIKE dfBackupHistory_c2.pattern1 OR
                  bp.handle LIKE dfBackupHistory_c2.pattern2 OR
                  bp.handle LIKE dfBackupHistory_c2.pattern3 OR
                  bp.handle LIKE dfBackupHistory_c2.pattern4))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bdf.dbinc_key   = dbinc.dbinc_key       -- join dbinc, bdf
     AND dbinc.db_key    = this_db_key           -- this database
     AND df.dbinc_key    = this_dbinc_key        -- this incarnation
     AND ((df.plugin_scn = 0  AND                -- create/plugin scn match
           bdf.plugin_scn = 0 AND
           bdf.create_scn = df.create_scn) OR
          (df.plugin_scn != 0 AND
           bdf.plugin_scn = df.plugin_scn))
     AND bdf.file#       = df.file#              -- join bdf, df
     AND bdf.bs_key      = bs.bs_key             -- join bdf, bs
     AND (tc_database = TRUE# OR isTranslatedFno(df.file#) = TRUE#)
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND bdf.ckp_scn NOT BETWEEN                 -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      cdf.file#                dfNumber,
      cdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      cdf.ckp_scn              ckp_scn,
      cdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      cdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(cdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      cdf.plugin_scn           pluginSCN,
      cdf.plugin_reset_scn     pluginRlgSCN,
      cdf.plugin_reset_time    pluginRlgTime,
      decode(cdf.plugin_scn, 0,
             cdf.create_scn, cdf.plugin_scn)
                               newcreate_scn,
      decode(cdf.plugin_reset_scn, 0,
             dbinc.reset_scn, cdf.plugin_reset_scn)
                               newreset_scn,
      nvl(cdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM cdf,
        dbinc,
        df,
        rci_pdbinc_this_dbinc pdbinc
   WHERE cdf.dbinc_key   = dbinc.dbinc_key       -- join dbinc, cdf
     AND dbinc.db_key    = this_db_key           -- this database
     AND df.dbinc_key    = this_dbinc_key        -- this incarnation
     AND ((df.plugin_scn = 0  AND                -- create/plugin scn match
           cdf.plugin_scn = 0 AND
           cdf.create_scn = df.create_scn) OR
          (df.plugin_scn != 0 AND
           cdf.plugin_scn = df.plugin_scn))
     AND cdf.file#       = df.file#              -- join cdf, df
     AND cdf.status      = 'A'                   -- available copy
     AND (tc_database = TRUE# OR isTranslatedFno(df.file#) = TRUE#)
     AND (dfBackupHistory_c2.cmd is null OR        -- bug 6658764
          dfBackupHistory_c2.cmd != 'B' OR
          (dfBackupHistory_c2.cmd = 'B' AND        -- Backup command and
           (dfBackupHistory_c2.ktag is null AND    -- nokeep cmd matches
            cdf.keep_options = 0) OR               -- nokeep backup or
           (dfBackupHistory_c2.ktag = cdf.tag and  -- keep backup cmd tag
            cdf.keep_options != 0)))               -- matches keep backup
     AND (dfBackupHistory_c2.device_type IS NULL OR
          dfBackupHistory_c2.device_type = 'DISK')
     AND ((dfBackupHistory_c2.pattern1 IS NULL AND
           dfBackupHistory_c2.pattern2 IS NULL AND
           dfBackupHistory_c2.pattern3 IS NULL AND
           dfBackupHistory_c2.pattern4 IS NULL) OR
          (cdf.fname LIKE dfBackupHistory_c2.pattern1 OR
           cdf.fname LIKE dfBackupHistory_c2.pattern2 OR
           cdf.fname LIKE dfBackupHistory_c2.pattern3 OR
           cdf.fname LIKE dfBackupHistory_c2.pattern4))
     AND ((user_site_key = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND cdf.ckp_scn NOT BETWEEN                   -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
   UNION ALL
 
   SELECT
      xdf.file#                dfNumber,
      xdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      xdf.ckp_scn              ckp_scn,
      xdf.ckp_time             ckp_time,
      nvl(df.stop_scn, 0)      stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(xdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      xdf.plugin_scn           pluginSCN,
      xdf.plugin_reset_scn     pluginRlgSCN,
      xdf.plugin_reset_time    pluginRlgTime,
      decode(xdf.plugin_scn, 0,
             xdf.create_scn, xdf.plugin_scn)
                               newcreate_scn,
      decode(xdf.plugin_reset_scn, 0,
             dbinc.reset_scn, xdf.plugin_reset_scn)
                               newreset_scn,
      nvl(xdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM xdf,
        dbinc,
        df,
        rci_pdbinc_this_dbinc pdbinc
   WHERE xdf.dbinc_key   = dbinc.dbinc_key       -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key           -- this database
     AND df.dbinc_key    = this_dbinc_key        -- this incarnation
     AND ((df.plugin_scn = 0  AND                -- create/plugin scn match
           xdf.plugin_scn = 0 AND
           xdf.create_scn = df.create_scn) OR
          (df.plugin_scn != 0 AND
           xdf.plugin_scn = df.plugin_scn))
     AND xdf.file#       = df.file#              -- join xdf, df
     AND xdf.status      = 'A'                   -- available proxy df
     AND (tc_database = TRUE# OR isTranslatedFno(df.file#) = TRUE#)
     AND (dfBackupHistory_c2.cmd is null OR        -- bug 6658764
          dfBackupHistory_c2.cmd != 'B' OR
          (dfBackupHistory_c2.cmd = 'B' AND        -- Backup command and
           (dfBackupHistory_c2.ktag is null AND    -- nokeep cmd matches
            xdf.keep_options = 0) OR               -- nokeep backup or
           (dfBackupHistory_c2.ktag = xdf.tag and  -- keep backup cmd tag
            xdf.keep_options != 0)))               -- matches keep backup
     AND (dfBackupHistory_c2.device_type IS NULL OR
          dfBackupHistory_c2.device_type = xdf.device_type)
     AND ((dfBackupHistory_c2.pattern1 IS NULL AND
           dfBackupHistory_c2.pattern2 IS NULL AND
           dfBackupHistory_c2.pattern3 IS NULL AND
           dfBackupHistory_c2.pattern4 IS NULL) OR
          (xdf.handle LIKE dfBackupHistory_c2.pattern1 OR
           xdf.handle LIKE dfBackupHistory_c2.pattern2 OR
           xdf.handle LIKE dfBackupHistory_c2.pattern3 OR
           xdf.handle LIKE dfBackupHistory_c2.pattern4))
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
     AND df.pdbinc_key    = pdbinc.pdbinc_key
     AND pdbinc.dbinc_key = this_dbinc_key
     AND xdf.ckp_scn NOT BETWEEN                  -- filter out orphan backups
         pdbinc.next_inc_scn AND pdbinc.next_end_reset_scn
 
--
   ORDER BY  dfNumber,
             newcreate_scn,
             newreset_scn,
             newreset_time,
             ckp_scn desc,
             stop_scn desc,
             compTime desc;  --bug 8412297
 
CURSOR dcBackupHistory_c(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      bdf.file#                dfNumber,
      bdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bdf.ckp_scn              ckp_scn,
      bdf.ckp_time             ckp_time,
      cdf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(bdf.plugged_readonly, 'YES', 1, 0)
                               pluggedRonly,
      bdf.plugin_scn           pluginSCN,
      bdf.plugin_reset_scn     pluginRlgSCN,
      bdf.plugin_reset_time    pluginRlgTime,
      decode(bdf.plugin_scn, 0,
             bdf.create_scn, bdf.plugin_scn)
                               newcreate_scn,
      decode(bdf.plugin_reset_scn, 0,
             dbinc.reset_scn, bdf.plugin_reset_scn)
                               newreset_scn,
      nvl(bdf.plugin_reset_time, dbinc.reset_time)
                               newreset_time
   FROM bdf,
        dbinc,
        (SELECT DISTINCT
                cdf.file#, cdf.create_scn, cdf.plugin_scn,
                cdf.plugged_readonly, cdf.ckp_scn, cdf.ckp_time, cdf.dbinc_key
           FROM cdf, dbinc
          WHERE cdf.dbinc_key = dbinc.dbinc_key
            AND dbinc.db_key  = this_db_key
            AND ((user_site_key = cdf.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE#) OR
                   (this_site_key = nvl(cdf.site_key, this_site_key)))))
            AND cdf.status    = 'A') cdf,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (dcBackupHistory_c.cmd is null OR       -- bug 6658764
                 dcBackupHistory_c.cmd != 'B' OR
                 (dcBackupHistory_c.cmd = 'B' AND       -- Backup command and
                  (dcBackupHistory_c.ktag is null AND   -- nokeep cmd matches
                   bs.keep_options = 0) OR              -- nokeep backup or
                  (dcBackupHistory_c.ktag = bp.tag and  -- keep backup cmd tag
                   bs.keep_options != 0)))              -- matches keep backup
            AND (dcBackupHistory_c.device_type IS NULL OR
                 dcBackupHistory_c.device_type = bp.device_type)
            AND ((dcBackupHistory_c.pattern1 IS NULL AND
                  dcBackupHistory_c.pattern2 IS NULL AND
                  dcBackupHistory_c.pattern3 IS NULL AND
                  dcBackupHistory_c.pattern4 IS NULL) OR
                 (bp.handle LIKE dcBackupHistory_c.pattern1 OR
                  bp.handle LIKE dcBackupHistory_c.pattern2 OR
                  bp.handle LIKE dcBackupHistory_c.pattern3 OR
                  bp.handle LIKE dcBackupHistory_c.pattern4))
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bdf.dbinc_key  = dbinc.dbinc_key       -- join dbinc, bdf
     AND dbinc.db_key   = this_db_key           -- this database (all inc)
     AND cdf.plugin_scn = bdf.plugin_scn
     AND cdf.plugged_readonly = bdf.plugged_readonly
     AND bdf.create_scn = cdf.create_scn        -- create scn match
     AND bdf.file#      = cdf.file#             -- join bdf, cdf
     AND bdf.ckp_scn    = cdf.ckp_scn
     AND bdf.ckp_time   = cdf.ckp_time
     AND bdf.dbinc_key  = cdf.dbinc_key
     AND (bdf.incr_scn  = 0 OR
          bdf.incr_scn  = cdf.create_scn)       -- full backup
     AND bdf.bs_key     = bs.bs_key             -- join bdf, bs
 
   UNION ALL
 
   SELECT
      0                        dfNumber,
      0                        create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      bcf.ckp_scn              ckp_scn,
      bcf.ckp_time             ckp_time,
      ccf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      0                        newcreate_scn,
      dbinc.reset_scn          newreset_scn,
      dbinc.reset_time         newreset_time
   FROM bcf,
        dbinc,
        (SELECT DISTINCT
                ccf.ckp_scn, ccf.ckp_time, ccf.dbinc_key
           FROM ccf, dbinc
          WHERE ccf.dbinc_key = dbinc.dbinc_key
            AND dbinc.db_key  = this_db_key
            AND ccf.status    = 'A') ccf,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  != 'L'              -- ignore al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (dcBackupHistory_c.cmd is null OR       -- bug 6658764
                 dcBackupHistory_c.cmd != 'B' OR
                 (dcBackupHistory_c.cmd = 'B' AND       -- Backup command and
                  (dcBackupHistory_c.ktag is null AND   -- nokeep cmd matches
                   bs.keep_options = 0) OR              -- nokeep backup or
                  (dcBackupHistory_c.ktag = bp.tag and  -- keep backup cmd tag
                   bs.keep_options != 0)))              -- matches keep backup
            AND (dcBackupHistory_c.device_type IS NULL OR
                 dcBackupHistory_c.device_type = bp.device_type)
            AND ((dcBackupHistory_c.pattern1 IS NULL AND
                  dcBackupHistory_c.pattern2 IS NULL AND
                  dcBackupHistory_c.pattern3 IS NULL AND
                  dcBackupHistory_c.pattern4 IS NULL) OR
                 (bp.handle LIKE dcBackupHistory_c.pattern1 OR
                  bp.handle LIKE dcBackupHistory_c.pattern2 OR
                  bp.handle LIKE dcBackupHistory_c.pattern3 OR
                  bp.handle LIKE dcBackupHistory_c.pattern4))
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE bcf.dbinc_key  = dbinc.dbinc_key       -- join dbinc, bcf
     AND dbinc.db_key   = this_db_key           -- this database (all inc)
     AND bcf.ckp_scn    = ccf.ckp_scn
     AND bcf.ckp_time   = ccf.ckp_time
     AND bcf.dbinc_key  = ccf.dbinc_key
     AND bcf.bs_key     = bs.bs_key             -- join bcf, bs
 
   UNION ALL
 
   SELECT
      cdf.file#                dfNumber,
      cdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      cdf.ckp_scn              ckp_scn,
      cdf.ckp_time             ckp_time,
      cdf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      cdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(cdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly,
      cdf.plugin_scn            pluginSCN,
      cdf.plugin_reset_scn      pluginRlgSCN,
      cdf.plugin_reset_time     pluginRlgTime,
      decode(cdf.plugin_scn, 0,
             cdf.create_scn, cdf.plugin_scn)
                                newcreate_scn,
      decode(cdf.plugin_reset_scn, 0,
             dbinc.reset_scn, cdf.plugin_reset_scn)
                                newreset_scn,
      nvl(cdf.plugin_reset_time, dbinc.reset_time)
                                newreset_time
   FROM cdf, dbinc
   WHERE cdf.dbinc_key   = dbinc.dbinc_key        -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key            -- this database (all inc)
     AND cdf.status      = 'A'                    -- available backup
     AND (dcBackupHistory_c.cmd is null OR        -- bug 6658764
          dcBackupHistory_c.cmd != 'B' OR
          (dcBackupHistory_c.cmd = 'B' AND        -- Backup command and
           (dcBackupHistory_c.ktag is null AND    -- nokeep cmd matches
            cdf.keep_options = 0) OR              -- nokeep backup or
           (dcBackupHistory_c.ktag = cdf.tag and  -- keep backup cmd tag
            cdf.keep_options != 0)))              -- matches keep backup
     AND (dcBackupHistory_c.device_type IS NULL OR
          dcBackupHistory_c.device_type = 'DISK')
     AND (dcBackupHistory_c.pattern1 IS NOT NULL OR
          dcBackupHistory_c.pattern2 IS NOT NULL OR
          dcBackupHistory_c.pattern3 IS NOT NULL OR
          dcBackupHistory_c.pattern4 IS NOT NULL)
     AND (cdf.fname LIKE dcBackupHistory_c.pattern1 OR
          cdf.fname LIKE dcBackupHistory_c.pattern2 OR
          cdf.fname LIKE dcBackupHistory_c.pattern3 OR
          cdf.fname LIKE dcBackupHistory_c.pattern4)
     AND ((user_site_key  = cdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(cdf.site_key, this_site_key)))))
 
   UNION ALL
 
   SELECT
      xdf.file#                dfNumber,
      xdf.create_scn           create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      xdf.ckp_scn              ckp_scn,
      xdf.ckp_time             ckp_time,
      cdf.ckp_scn              stop_scn,
      to_number(null)          logThread,
      to_number(null)          logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xdf.completion_time      compTime,
      0                        nbackups,
      to_char(null)            logTerminal,
      to_number(null)          next_scn,
      decode(xdf.plugged_readonly, 'YES', 1, 0)
                                pluggedRonly,
      xdf.plugin_scn            pluginSCN,
      xdf.plugin_reset_scn      pluginRlgSCN,
      xdf.plugin_reset_time     pluginRlgTime,
      decode(xdf.plugin_scn, 0,
             xdf.create_scn, xdf.plugin_scn)
                                newcreate_scn,
      decode(xdf.plugin_reset_scn, 0,
             dbinc.reset_scn, xdf.plugin_reset_scn)
                                newreset_scn,
      nvl(xdf.plugin_reset_time, dbinc.reset_time)
                                newreset_time
   FROM xdf,
        dbinc,
        (SELECT DISTINCT
                cdf.file#, cdf.create_scn, cdf.plugin_scn,
                cdf.plugged_readonly, cdf.ckp_scn, cdf.ckp_time, cdf.dbinc_key
           FROM cdf, dbinc
          WHERE cdf.dbinc_key = dbinc.dbinc_key
            AND dbinc.db_key  = this_db_key
            AND cdf.status    = 'A') cdf
   WHERE xdf.dbinc_key   = dbinc.dbinc_key         -- join xdf, dbinc
     AND dbinc.db_key    = this_db_key             -- this database (all inc)
     AND xdf.file#       = cdf.file#               -- join xdf, cdf
     AND xdf.plugged_readonly = cdf.plugged_readonly
     AND xdf.plugin_scn  = cdf.plugin_scn
     AND xdf.create_scn  = cdf.create_scn          -- create scn match
     AND xdf.dbinc_key   = cdf.dbinc_key
     AND xdf.ckp_scn     = cdf.ckp_scn
     AND xdf.ckp_time    = cdf.ckp_time
     AND xdf.status      = 'A'                     -- available proxy df
     AND (dcBackupHistory_c.cmd is null OR        -- bug 6658764
          dcBackupHistory_c.cmd != 'B' OR
          (dcBackupHistory_c.cmd = 'B' AND        -- Backup command and
           (dcBackupHistory_c.ktag is null AND    -- nokeep cmd matches
            xdf.keep_options = 0) OR              -- nokeep backup or
           (dcBackupHistory_c.ktag = xdf.tag and  -- keep backup cmd tag
            xdf.keep_options != 0)))              -- matches keep backup
     AND (dcBackupHistory_c.device_type IS NULL OR
          dcBackupHistory_c.device_type = xdf.device_type)
     AND ((dcBackupHistory_c.pattern1 IS NULL AND
           dcBackupHistory_c.pattern2 IS NULL AND
           dcBackupHistory_c.pattern3 IS NULL AND
           dcBackupHistory_c.pattern4 IS NULL) OR
          (xdf.handle LIKE dcBackupHistory_c.pattern1 OR
           xdf.handle LIKE dcBackupHistory_c.pattern2 OR
           xdf.handle LIKE dcBackupHistory_c.pattern3 OR
           xdf.handle LIKE dcBackupHistory_c.pattern4))
     AND ((user_site_key  = xdf.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xdf.site_key, this_site_key)))))
--
   ORDER BY  dfNumber,
             newcreate_scn,
             newreset_scn,
             newreset_time,
             ckp_scn         desc,
             stop_scn        desc,
             compTime;
 
--
CURSOR alBackupHistory_c1(
   thread#     IN number,
   sequence#   IN number,
   device_type IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      brl.thread#              logThread,
      brl.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      brl.terminal             logTerminal,
      brl.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM brl,
        dbinc,
        (SELECT /*+no_merge*/ DISTINCT thread#, sequence#
           FROM al
          WHERE al.thread#   = alBackupHistory_c1.thread#
            AND al.sequence# = alBackupHistory_c1.sequence#
            AND al.dbinc_key = this_dbinc_key
            AND al.status    = 'A'
            AND al.archived  = 'Y') al,
        (SELECT bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  = 'L'               -- only al backups
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (alBackupHistory_c1.device_type IS NULL OR
                 alBackupHistory_c1.device_type = bp.device_type)
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE dbinc.dbinc_key = this_dbinc_key           -- this incarnation
     AND brl.dbinc_key   = dbinc.dbinc_key          -- join brl, dbinc
     AND dbinc.db_key    = this_db_key
     AND brl.thread#     = al.thread#              -- join brl and al
     AND brl.sequence#   = al.sequence#
     AND brl.dbinc_key   = this_dbinc_key
     AND brl.bs_key      = bs.bs_key               -- join brl,bs
 
   UNION ALL
 
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          crescn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      xal.thread#              logThread,
      xal.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xal.completion_time      compTime,
      0                        nbackups,
      xal.terminal             logTerminal,
      xal.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM xal,
        dbinc,
        (SELECT /*+no_merge*/ DISTINCT thread#, sequence#
           FROM al
          WHERE al.thread#   = alBackupHistory_c1.thread#
            AND al.sequence# = alBackupHistory_c1.sequence#
            AND al.dbinc_key = this_dbinc_key
            AND al.status    = 'A'
            AND al.archived  = 'Y') al
   WHERE xal.dbinc_key  = dbinc.dbinc_key          -- join xal, dbinc
     AND dbinc.db_key   = this_db_key              -- this database
     AND xal.thread#    = al.thread#
     AND xal.sequence#  = al.sequence#
     AND xal.dbinc_key  = this_dbinc_key
     AND xal.status     = 'A'
     AND (alBackupHistory_c1.device_type IS NULL OR
          alBackupHistory_c1.device_type = xal.device_type)
     AND ((user_site_key  = xal.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
--
   ORDER BY reset_scn,
            reset_time,
            logThread,
            logSequence,
            logTerminal desc,
            compTime;
 
CURSOR alBackupHistory_c2(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          create_scn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      brl.thread#              logThread,
      brl.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      bs.completion_time       compTime,
      0                        nbackups,
      brl.terminal             logTerminal,
      brl.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM brl,
        dbinc,
        (SELECT DISTINCT al.thread#, al.sequence#, al.dbinc_key
           FROM al, dbinc
          WHERE dbinc.dbinc_key = al.dbinc_key
            AND dbinc.db_key    = this_db_key
            AND al.status       = 'A'
            AND al.archived     = 'Y'
            AND (tc_thread IS NULL   OR al.thread# = tc_thread)
            AND (tc_fromSeq IS NULL  OR al.sequence# >= tc_fromSeq)
            AND (tc_toSeq IS NULL    OR al.sequence# <= tc_toSeq)
            AND (tc_fromSCN IS NULL  OR al.next_scn > tc_fromSCN)
            AND (tc_toSCN IS NULL    OR al.low_scn < tc_toSCN)
            AND (tc_pattern IS NULL  OR al.fname like tc_pattern)
            AND (tc_fromTime IS NULL OR al.next_time > tc_fromTime)
            AND (tc_toTime IS NULL   OR al.low_time <= tc_toTime)) al,
        (SELECT DISTINCT
                bs.bs_key,
                bs.completion_time
           FROM bs, bp
          WHERE bp.status    = 'A'               -- only available pieces
            AND bs.bck_type  = 'L'               -- only al backups
            AND bs.status    = 'A'               -- available backupset
            AND bs.bs_key    = bp.bs_key         -- join bs, bp
            AND bs.db_key    = this_db_key       -- this database
            AND bp.db_key    = this_db_key       -- this database
            AND (alBackupHistory_c2.cmd is null OR       -- bug 6658764
                 (alBackupHistory_c2.cmd != 'B' AND
                  alBackupHistory_c2.cmd != 'D') OR
                 ((alBackupHistory_c2.cmd = 'B' OR       -- Backup command or
                   alBackupHistory_c2.cmd = 'D') AND     -- Delete command and
                  ((alBackupHistory_c2.ktag is null AND  -- nokeep cmd matches
                    bs.keep_options = 0) OR              -- nokeep backup or
                   (alBackupHistory_c2.ktag = bp.tag AND -- keep backup cmd tag
                    bs.keep_options != 0))))             -- matches keep backup
            AND (alBackupHistory_c2.device_type IS NULL OR
                 alBackupHistory_c2.device_type = bp.device_type)
            AND ((alBackupHistory_c2.pattern1 IS NULL AND
                  alBackupHistory_c2.pattern2 IS NULL AND
                  alBackupHistory_c2.pattern3 IS NULL AND
                  alBackupHistory_c2.pattern4 IS NULL) OR
                 (bp.handle LIKE alBackupHistory_c2.pattern1 OR
                  bp.handle LIKE alBackupHistory_c2.pattern2 OR
                  bp.handle LIKE alBackupHistory_c2.pattern3 OR
                  bp.handle LIKE alBackupHistory_c2.pattern4))
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
        GROUP BY bs.bs_key, bp.device_type, bp.copy#,
                 bs.pieces, bs.completion_time
          HAVING count(distinct bp.piece#) = bs.pieces) bs
   WHERE (canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
     AND brl.dbinc_key   = dbinc.dbinc_key         -- join brl, dbinc
     AND dbinc.db_key    = this_db_key
     AND brl.thread#     = al.thread#              -- join brl and al
     AND brl.sequence#   = al.sequence#
     AND brl.dbinc_key   = al.dbinc_key
     AND brl.bs_key      = bs.bs_key               -- join brl,bs
 
   UNION ALL
 
   SELECT
      to_number(null)          dfNumber,
      to_number(null)          crescn,
      dbinc.reset_scn          reset_scn,
      dbinc.reset_time         reset_time,
      to_number(null)          ckp_scn,
      to_date(null)            ckp_time,
      to_number(null)          stop_scn,
      xal.thread#              logThread,
      xal.sequence#            logSequence,
      to_number(null)          setStamp,
      to_number(null)          setCount,
      xal.completion_time      compTime,
      0                        nbackups,
      xal.terminal             logTerminal,
      xal.next_scn             next_scn,
      0                        pluggedRonly,
      0                        pluginSCN,
      0                        pluginRlgSCN,
      to_date(null)            pluginRlgTime,
      to_number(null)          newcreate_scn,
      to_number(null)          newreset_scn,
      to_date(null)            newreset_time
   FROM xal,
        dbinc,
        (SELECT DISTINCT al.thread#, al.sequence#, al.dbinc_key
           FROM al, dbinc
          WHERE dbinc.dbinc_key = al.dbinc_key
            AND dbinc.db_key    = this_db_key
            AND al.status       = 'A'
            AND al.archived     = 'Y'
            AND (tc_thread IS NULL   OR al.thread# = tc_thread)
            AND (tc_fromSeq IS NULL  OR al.sequence# >= tc_fromSeq)
            AND (tc_toSeq IS NULL    OR al.sequence# <= tc_toSeq)
            AND (tc_fromSCN IS NULL  OR al.next_scn > tc_fromSCN)
            AND (tc_toSCN IS NULL    OR al.low_scn < tc_toSCN)
            AND (tc_pattern IS NULL  OR al.fname like tc_pattern)
            AND (tc_fromTime IS NULL OR al.next_time > tc_fromTime)
            AND (tc_toTime IS NULL   OR al.low_time <= tc_toTime)) al
   WHERE (canApplyAnyRedo = TRUE# OR dbinc.dbinc_key = this_dbinc_key)
     AND xal.dbinc_key  = dbinc.dbinc_key          -- join xal, dbinc
     AND dbinc.db_key   = this_db_key              -- this database
     AND xal.thread#    = al.thread#
     AND xal.sequence#  = al.sequence#
     AND xal.dbinc_key  = al.dbinc_key
     AND xal.status     = 'A'
     AND (alBackupHistory_c2.cmd is null OR       -- bug 6658764
          (alBackupHistory_c2.cmd != 'B' AND
           alBackupHistory_c2.cmd != 'D') OR
          ((alBackupHistory_c2.cmd = 'B' OR        -- Backup command or
            alBackupHistory_c2.cmd = 'D') AND      -- Delete command and
           ((alBackupHistory_c2.ktag is null AND   -- nokeep cmd matches
             xal.keep_options = 0) OR              -- nokeep backup or
            (alBackupHistory_c2.ktag = xal.tag AND -- keep backup cmd tag
             xal.keep_options != 0))))             -- matches keep backup
     AND (alBackupHistory_c2.device_type IS NULL OR
          alBackupHistory_c2.device_type = xal.device_type)
     AND ((alBackupHistory_c2.pattern1 IS NULL AND
           alBackupHistory_c2.pattern2 IS NULL AND
           alBackupHistory_c2.pattern3 IS NULL AND
           alBackupHistory_c2.pattern4 IS NULL) OR
          (xal.handle LIKE alBackupHistory_c2.pattern1 OR
           xal.handle LIKE alBackupHistory_c2.pattern2 OR
           xal.handle LIKE alBackupHistory_c2.pattern3 OR
           xal.handle LIKE alBackupHistory_c2.pattern4))
     AND ((user_site_key  = xal.site_key) OR
          (user_site_key IS NULL AND
           ((tape_backups_shared = TRUE#) OR
            (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
--
   ORDER BY reset_scn,
            reset_time,
            logThread,
            logSequence,
            logTerminal desc,
            compTime;
 
CURSOR bsBackupHistory_c1(
   set_stamp   IN   number
  ,set_count   IN   number
  ,device_type IN   varchar2
  ,pattern1    IN   varchar2
  ,pattern2    IN   varchar2
  ,pattern3    IN   varchar2
  ,pattern4    IN   varchar2
  )
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)           dfNumber,
      to_number(null)           create_scn,
      to_number(null)           reset_scn,
      to_date(null)             reset_time,
      to_number(null)           ckp_scn,
      to_date(null)             ckp_time,
      to_number(null)           stop_scn,
      to_number(null)           logThread,
      to_number(null)           logSequence,
      bs.set_stamp              setStamp,
      bs.set_count              setCount,
      max(bp.completion_time)   compTime,
      0                         nbackups,
      to_char(null)             logTerminal,
      to_number(null)           next_scn,
      0                         pluggedRonly,
      0                         pluginSCN,
      0                         pluginRlgSCN,
      to_date(null)             pluginRlgTime,
      to_number(null)           newcreate_scn,
      to_number(null)           newreset_scn,
      to_date(null)             newreset_time
     FROM bs,
          bp
     WHERE bs.db_key       = this_db_key             -- this database
       AND bp.bs_key       = bs.bs_key               -- join bs, bp
       AND bs.set_stamp    = bsBackupHistory_c1.set_stamp
       AND bs.set_count    = bsBackupHistory_c1.set_count
       AND bs.status       = 'A'
       AND bp.status      != 'D'
       AND (bsBackupHistory_c1.device_type IS NULL OR
            bsBackupHistory_c1.device_type = bp.device_type)
       AND ((bsBackupHistory_c1.pattern1 IS NULL AND
             bsBackupHistory_c1.pattern2 IS NULL AND
             bsBackupHistory_c1.pattern3 IS NULL AND
             bsBackupHistory_c1.pattern4 IS NULL) OR
            (bp.handle LIKE bsBackupHistory_c1.pattern1 OR
             bp.handle LIKE bsBackupHistory_c1.pattern2 OR
             bp.handle LIKE bsBackupHistory_c1.pattern3 OR
             bp.handle LIKE bsBackupHistory_c1.pattern4))
       AND ((user_site_key = bp.site_key) OR
            (user_site_key IS NULL AND
             ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
              (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
              (this_site_key = nvl(bp.site_key, this_site_key)))))
  GROUP BY bs.set_stamp, bs.set_count, bs.pieces,
           bp.copy#, bp.device_type
    HAVING count(distinct bp.piece#) = bs.pieces
 
--
   ORDER BY setStamp, setCount, compTime;
 
CURSOR bsBackupHistory_c2(
   device_type  IN varchar2
  ,cmd          IN varchar2
  ,ktag         IN varchar2
  ,pattern1     IN varchar2
  ,pattern2     IN varchar2
  ,pattern3     IN varchar2
  ,pattern4     IN varchar2)
RETURN bhistoryRec_t IS
   SELECT
      to_number(null)           dfNumber,
      to_number(null)           create_scn,
      to_number(null)           reset_scn,
      to_date(null)             reset_time,
      to_number(null)           ckp_scn,
      to_date(null)             ckp_time,
      to_number(null)           stop_scn,
      to_number(null)           logThread,
      to_number(null)           logSequence,
      bs.set_stamp              setStamp,
      bs.set_count              setCount,
      max(bp.completion_time)   compTime,
      0                         nbackups,
      to_char(null)             logTerminal,
      to_number(null)           next_scn,
      0                         pluggedRonly,
      0                         pluginSCN,
      0                         pluginRlgSCN,
      to_date(null)             pluginRlgTime,
      to_number(null)           newcreate_scn,
      to_number(null)           newreset_scn,
      to_date(null)             newreset_time
   FROM bs,
        bp
     WHERE bs.db_key       = this_db_key             -- this database
       AND bp.bs_key       = bs.bs_key               -- join bs, bp
       AND bs.status       = 'A'
       AND bp.status      != 'D'
       AND (bsBackupHistory_c2.device_type IS NULL OR
            bsBackupHistory_c2.device_type = bp.device_type)
       AND ((bsBackupHistory_c2.pattern1 IS NULL AND
             bsBackupHistory_c2.pattern2 IS NULL AND
             bsBackupHistory_c2.pattern3 IS NULL AND
             bsBackupHistory_c2.pattern4 IS NULL) OR
            (bp.handle LIKE bsBackupHistory_c2.pattern1 OR
             bp.handle LIKE bsBackupHistory_c2.pattern2 OR
             bp.handle LIKE bsBackupHistory_c2.pattern3 OR
             bp.handle LIKE bsBackupHistory_c2.pattern4))
       AND ((user_site_key = bp.site_key) OR
            (user_site_key IS NULL AND
             ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
              (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
              (this_site_key = nvl(bp.site_key, this_site_key)))))
  GROUP BY bs.set_stamp, bs.set_count, bs.pieces,
           bp.copy#, bp.device_type
    HAVING count(distinct bp.piece#) = bs.pieces
 
--
   ORDER BY setStamp, setCount, compTime;
 
--
--
--
CURSOR getCopyofDatafile_c2(
   itag        varchar2
)
IS
   SELECT /*+ first_rows */
      file#,
      creation_change#,
      resetlogs_change#,
      resetlogs_time,
      recid,
      stamp,
      name,
      tag,
      status,
      blocks,
      block_size,
      completion_time,
      checkpoint_change#,
      checkpoint_time,
      decode(plugged_readonly, 'YES', 1, 0) pluggedRonly,
      plugin_change#,
      plugin_resetlogs_change#,
      plugin_resetlogs_time
   FROM
      rc_datafile_copy
   WHERE status            = 'A'
     AND (itag is NULL or tag = itag)
     AND (tc_database = TRUE# OR
          isTranslatedFno(file#) = TRUE#)   -- only translated files
     AND ((user_site_key = rc_datafile_copy.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(rc_datafile_copy.site_key, this_site_key)))))
  ORDER BY file#, decode(plugged_readonly, 'YES',
                  plugin_change#, checkpoint_change#) desc, recid desc;
 
--
--
--
--
CURSOR getCopyofDatafile_c(
   dfnumber    number
  ,itag        varchar2
  ,crescn      number
  ,rlgscn      number
  ,rlgtime     date
  ,pluginSCN   number
)
IS
   SELECT /*+ first_rows */
      recid,
      stamp,
      name,
      tag,
      status,
      blocks,
      block_size,
      completion_time,
      checkpoint_change#,
      checkpoint_time,
      creation_change#,
      resetlogs_change#,
      resetlogs_time,
      decode(plugged_readonly, 'YES', 1, 0) pluggedRonly
   FROM
      rc_datafile_copy
   WHERE status            = 'A'
     AND (itag is NULL or tag = itag)
     AND file#             = dfnumber
     AND ((pluginSCN = 0 AND creation_change# = crescn) OR
          (pluginSCN != 0 AND plugin_change# = pluginSCN))
     AND ((plugged_readonly = 'NO' AND
           resetlogs_change# = rlgscn AND
           resetlogs_time    = rlgtime) OR
          (plugged_readonly = 'YES' AND
           plugin_resetlogs_change# = rlgscn AND
           plugin_resetlogs_time = rlgtime))
     AND ((user_site_key = rc_datafile_copy.site_key) OR
          (user_site_key IS NULL AND
           ((disk_backups_shared = TRUE#) OR
            (this_site_key = nvl(rc_datafile_copy.site_key, this_site_key)))))
 
  ORDER BY
      decode(plugged_readonly, 'YES',
             plugin_change#, checkpoint_change#) desc;
 
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
TYPE rcvRecCursor_t IS RECORD
(
   currc1         rcvRec_t,            -- current fetched rcvRecCursor1_c data
   reqfno         number,              -- requested file number
   reqcrescn      number,              -- requested file number's create scn
   reqpluginSCN   number,              -- requested file number's plugin scn
   excludeAction  binary_integer       -- type of action that is excluded
);
rcvRecCursor rcvRecCursor_t;
 
CURSOR rcvRecCursor1_c(
rmanCmd       IN binary_integer
)
RETURN rcvRec_t IS
 
--
 
   SELECT offlineRangeRec_con_t                 type_con,
          offr.offr_key                         key_con,
          offr.offr_recid                       recid_con,
          offr.offr_stamp                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          offr.cf_create_time                   cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          offlineRange_act_t                    type_act,
          offr.offline_scn                      fromSCN_act,
          offr.online_scn                       toSCN_act,
          offr.online_time                      toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          offr.file#                            dfNumber_obj,
          offr.create_scn                       dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          offr.create_scn                       newDfCreationSCN_obj,
          offr.online_scn                       newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM offr, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(offr.file#) = TRUE#)
      AND (untilSCN is null OR offr.online_scn < untilSCN)
--
--
--
--
--
--
      AND offr.cf_create_time is not null
--
      AND offr.offr_stamp <> 0          -- stamp = 0 -> from kccfe
      AND offr.dbinc_key  = this_dbinc_key
      AND offr.dbinc_key = dbinc.dbinc_key
 
   UNION ALL
 
--
 
   SELECT imageCopy_con_t                       type_con,
          cdf.cdf_key                           key_con,
          cdf.cdf_recid                         recid_con,
          cdf.cdf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          cdf.fname                             fileName_con,
          cdf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          cdf.status                            status_con,
          cdf.blocks                            blocks_con,
          cdf.block_size                        blockSize_con,
          'DISK'                                deviceType_con,
          cdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          cdf.ckp_scn                           toSCN_act,
          cdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          cdf.incr_level                        level_act,
          0                                     section_size_act,
 
          cdf.file#                             dfNumber_obj,
          cdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          cdf.pdb_key                           pdbKey_obj,
 
          cdf.keep_options                      keep_options,
          cdf.keep_until                        keep_until,
 
          cdf.abs_fuzzy_scn                     afzSCN_act,
          cdf.rcv_fuzzy_time                    rfzTime_act,
          cdf.rcv_fuzzy_scn                     rfzSCN_act,
          to_char(null)                         media_con,
          cdf.is_recovery_dest_file             isrdf_con,
          site_key                              site_key_con,
          cdf.foreign_dbid                      foreignDbid_obj,
          decode(cdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          cdf.plugin_scn                        pluginSCN_obj,
          cdf.plugin_reset_scn                  pluginRlgSCN_obj,
          cdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(cdf.plugin_scn, 0, cdf.create_scn,
                 cdf.plugin_scn)                newDfCreation_obj,
          decode(cdf.plugged_readonly, 'NO', cdf.ckp_scn,
                 cdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          cdf.sparse_backup                     sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM cdf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(cdf.file#) = TRUE#)
      AND (untilSCN is null OR
           (cdf.plugged_readonly = 'NO' AND
            greatest(cdf.ckp_scn, cdf.abs_fuzzy_scn,
                     cdf.rcv_fuzzy_scn) <= untilSCN) OR
           (cdf.plugged_readonly = 'YES' AND
            cdf.plugin_scn <= untilSCN))
      AND cdf.status = 'A'
      AND (restoreSource is NULL                        OR
           bitand(restoreSource, imageCopy_con_t) != 0)
      AND cdf.dbinc_key = dbinc.dbinc_key
      AND dbinc.db_key = this_db_key
      AND rmanCmd != recoverCmd_t
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
      AND (cdf.file# = 0 OR -- backup mode is not applicable for control files
           restoreSparse = BACKUP_SPARSENESS_UNSPECIFIED     OR
           (restoreSparse = BACKUP_SPARSENESS_SPARSE AND
            cdf.sparse_backup = 'YES')                       OR
           (restoreSparse = BACKUP_SPARSENESS_NONSPARSE AND
            cdf.sparse_backup = 'NO'))
 
   UNION ALL
 
--
 
   SELECT imageCopy_con_t                       type_con,
          ccf.ccf_key                           key_con,
          ccf.ccf_recid                         recid_con,
          ccf.ccf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          ccf.fname                             fileName_con,
          ccf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          ccf.status                            status_con,
          to_number(null)                       blocks_con,
          ccf.block_size                        blockSize_con,
          'DISK'                                deviceType_con,
          ccf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          ccf.ckp_scn                           toSCN_act,
          ccf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(ccf.controlfile_type, 'B')        cfType_obj,
          ccf.pdb_key                           pdbKey_obj,
 
          ccf.keep_options                      keep_options,
          ccf.keep_until                        keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          is_recovery_dest_file                 isrdf_con,
          site_key                              site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          ccf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM ccf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(0) = TRUE#)
      AND (untilSCN is null OR
           ccf.ckp_scn <= untilSCN)
      AND ccf.status = 'A'
      AND (restoreSource is NULL                        OR
           bitand(restoreSource, imageCopy_con_t) != 0)
      AND ccf.dbinc_key = dbinc.dbinc_key
      AND dbinc.db_key = this_db_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND ((user_site_key = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bdf.bdf_key                           key_con,
          bdf.bdf_recid                         recid_con,
          bdf.bdf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          bs.incr_level                         bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          bdf.blocks                            blocks_con,
          bdf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          decode(bdf.incr_scn,
                 0, full_act_t,
                 bdf.create_scn,
                 decode(rmanCmd,
                        rcvCopyCmd_t,
                        incremental_act_t,
                        recoverCmd_t,
                        incremental_act_t,
                        full_act_t),
                 incremental_act_t)             type_act,
          decode(bdf.incr_scn,
                 bdf.create_scn,
                 decode(rmanCmd,
                        rcvCopyCmd_t,
                        bdf.incr_scn,
                        recoverCmd_t,
                        bdf.incr_scn,
                        0),
                 bdf.incr_scn)                  fromSCN_act,
          bdf.ckp_scn                           toSCN_act,
          bdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          bdf.incr_level                        level_act,
          bdf.section_size                      section_size_act,
 
          bdf.file#                             dfNumber_obj,
          bdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          bdf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          bdf.abs_fuzzy_scn                     afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          bdf.foreign_dbid                      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          bdf.plugin_scn                        pluginSCN_obj,
          bdf.plugin_reset_scn                  pluginRlgSCN_obj,
          bdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(bdf.plugin_scn, 0, bdf.create_scn,
                 bdf.plugin_scn)                newDfCreationSCN_obj,
          decode(bdf.plugged_readonly, 'NO', bdf.ckp_scn,
                 bdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          bdf.sparse_backup                     sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bdf, bs, dbinc
--
--
--
    WHERE rmanCmd != obsoleteCmd_t
      AND (tc_database = TRUE# OR isTranslatedFno(bdf.file#) = TRUE#)
      AND bs.status = 'A'
      AND bs.bck_type != 'L'               -- only datafile backups
      AND (untilSCN IS NULL OR
           (bdf.plugged_readonly = 'NO' AND
            greatest(bdf.ckp_scn, bdf.abs_fuzzy_scn) <= untilSCN) OR
           (bdf.plugged_readonly = 'YES' AND
            bdf.plugin_scn <= untilSCN))
      AND dbinc.dbinc_key  = bdf.dbinc_key   -- join dbinc, bdf
      AND bs.bs_key        = bdf.bs_key      -- join bs, bdf
      AND dbinc.db_key     = this_db_key
      AND (rmanCmd = rcvCopyCmd_t OR -- use incr for recover copy cmd
           rmanCmd = recoverCmd_t OR
           (restoreSource IS NULL OR
            bitand(restoreSource, backupSet_con_t) != 0))
      AND (bdf.file# = 0 OR -- backup mode is not applicable for control files
           restoreSparse = BACKUP_SPARSENESS_UNSPECIFIED      OR
           (restoreSparse = BACKUP_SPARSENESS_SPARSE AND
            bdf.sparse_backup = 'YES')                        OR
           (restoreSparse = BACKUP_SPARSENESS_NONSPARSE AND
            bdf.sparse_backup = 'NO'))
      AND ((rmanCmd = rcvCopyCmd_t AND bdf.incr_scn > 0)               OR
           (rmanCmd = recoverCmd_t AND bdf.incr_scn > 0)               OR
           (rmanCmd IN (restoreCmd_t, blkRestoreCmd_t) AND
            bdf.incr_scn <= bdf.create_scn)                            OR
           (rmanCmd = unknownCmd_t))
      AND (bs.site_key IS NULL         OR -- always return null site_key
           user_site_key = bs.site_key OR -- user interested in one site
           (user_site_key IS NULL AND     -- return rows per access attr
            (disk_backups_shared = TRUE# OR
             tape_backups_shared = TRUE# OR
             this_site_key = bs.site_key)))
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bdf.bdf_key                           key_con,
          bdf.bdf_recid                         recid_con,
          bdf.bdf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          bs.incr_level                         bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          bdf.blocks                            blocks_con,
          bdf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          decode(bdf.incr_scn,
                 0, full_act_t,
                 bdf.create_scn,
                 full_act_t,
                 incremental_act_t)             type_act,
          bdf.incr_scn                          fromSCN_act,
          bdf.ckp_scn                           toSCN_act,
          bdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          bdf.incr_level                        level_act,
          bdf.section_size                      section_size_act,
 
          bdf.file#                             dfNumber_obj,
          bdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          bdf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          bdf.abs_fuzzy_scn                     afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          bdf.foreign_dbid                      foreignDbid_obj,
          decode(bdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          bdf.plugin_scn                        pluginSCN_obj,
          bdf.plugin_reset_scn                  pluginRlgSCN_obj,
          bdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(bdf.plugin_scn, 0, bdf.create_scn,
                 bdf.plugin_scn)                newDfCreationSCN_obj,
          decode(bdf.plugged_readonly, 'NO', bdf.ckp_scn,
                 bdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          bdf.sparse_backup                     sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bdf, bs, dbinc,
          (SELECT bs_key,
                  count(distinct piece#) pieces
             FROM  bp
            WHERE rmanCmd = obsoleteCmd_t
              AND bp.db_key  = this_db_key         -- this database
              AND bp.status  = 'A'
              AND (anyDevice = TRUE# OR
                   isDeviceTypeAllocated(bp.device_type) = TRUE#)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared =TRUE# AND bp.device_type='DISK') OR
                     (tape_backups_shared =TRUE# AND bp.device_type<>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
           GROUP BY bs_key, device_type) bp
--
--
--
    WHERE rmanCmd = obsoleteCmd_t
--
--
--
      AND bs.status = 'A'
      AND bs.bck_type != 'L'                 -- only datafile backups
      AND (untilSCN IS NULL OR
           (bdf.plugged_readonly = 'NO' AND
            greatest(bdf.ckp_scn, bdf.abs_fuzzy_scn) <= untilSCN) OR
           (bdf.plugged_readonly = 'YES' AND
            bdf.plugin_scn <= untilSCN))
      AND dbinc.dbinc_key  = bdf.dbinc_key   -- join dbinc, bdf
      AND bs.bs_key        = bdf.bs_key      -- join bs, bdf
      AND dbinc.db_key     = this_db_key
      AND (restoreSource IS NULL OR
           bitand(restoreSource, backupSet_con_t) != 0)
      AND (bdf.file# = 0 OR -- backup mode is not applicable for control files
           restoreSparse = BACKUP_SPARSENESS_UNSPECIFIED      OR
           (restoreSparse = BACKUP_SPARSENESS_SPARSE AND
            bdf.sparse_backup = 'YES')                        OR
           (restoreSparse = BACKUP_SPARSENESS_NONSPARSE AND
            bdf.sparse_backup = 'NO'))
      AND bp.bs_key        = bs.bs_key
      AND bp.pieces        = bs.pieces
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bcf.bcf_key                           key_con,
          bcf.bcf_recid                         recid_con,
          bcf.bcf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          0                                     bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          bcf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bs.completion_time                    compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          bcf.ckp_scn                           toSCN_act,
          bcf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(bcf.controlfile_type, 'B')        cfType_obj,
          bcf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          bcf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bcf, bs, dbinc
--
--
--
    WHERE rmanCmd != obsoleteCmd_t
      AND (tc_database = TRUE# OR isTranslatedFno(0) = TRUE#)
      AND bs.status = 'A'
      AND bs.bck_type != 'L'                 -- ignore archivelog backups
      AND (untilSCN IS NULL OR
           bcf.ckp_scn <= untilSCN)
      AND (restoreSource IS NULL OR
           bitand(restoreSource, backupSet_con_t) != 0)
      AND dbinc.dbinc_key  = bcf.dbinc_key   -- join dbinc, bcf
      AND bs.bs_key        = bcf.bs_key      -- join bs, bcf
      AND dbinc.db_key     = this_db_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND (bs.site_key IS NULL         OR    -- always return null site_key
           user_site_key = bs.site_key OR    -- user interested in one site
          (user_site_key IS NULL AND         -- return rows per access attr
           (disk_backups_shared = TRUE# OR
            tape_backups_shared = TRUE# OR
            this_site_key = bs.site_key)))
 
   UNION ALL
 
--
--
 
   SELECT backupSet_con_t                       type_con,
          bcf.bcf_key                           key_con,
          bcf.bcf_recid                         recid_con,
          bcf.bcf_stamp                         stamp_con,
          bs.set_stamp                          setStamp_con,
          bs.set_count                          setCount_con,
          bs.bs_recid                           bsRecid_con,
          bs.bs_stamp                           bsStamp_con,
          bs.bs_key                             bsKey_con,
          0                                     bsLevel_con,
          bs.bck_type                           bsType_con,
          abs((bs.completion_time - bs.start_time) * 86400)
                                                elapseSecs_con,
          bs.pieces                             pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          bcf.block_size                        blockSize_con,
          to_char(null)                         deviceType_con,
          bs.completion_time                    compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          multi_section                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          bcf.ckp_scn                           toSCN_act,
          bcf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(bcf.controlfile_type, 'B')        cfType_obj,
          bcf.pdb_key                           pdbKey_obj,
 
          bs.keep_options                       keep_options,
          bs.keep_until                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          bs.site_key                           site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          bcf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM bcf, bs, dbinc,
          (SELECT bs_key,
                  count(distinct piece#) pieces
             FROM  bp
            WHERE rmanCmd = obsoleteCmd_t
              AND bp.db_key  = this_db_key         -- this database
              AND bp.status  = 'A'
              AND (anyDevice = TRUE# OR
                   isDeviceTypeAllocated(bp.device_type) = TRUE#)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared =TRUE# AND bp.device_type ='DISK') OR
                     (tape_backups_shared =TRUE# AND bp.device_type<>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
         GROUP BY bs_key, device_type) bp
--
--
--
    WHERE rmanCmd = obsoleteCmd_t
--
--
--
      AND bs.status = 'A'
      AND bs.bck_type != 'L'                 -- ignore archivelog backups
      AND (untilSCN IS NULL OR
           bcf.ckp_scn <= untilSCN)
      AND (restoreSource IS NULL OR
           bitand(restoreSource, backupSet_con_t) != 0)
      AND dbinc.dbinc_key  = bcf.dbinc_key   -- join dbinc, bcf
      AND bs.bs_key        = bcf.bs_key      -- join bs, bcf
      AND dbinc.db_key     = this_db_key
      AND bs.bs_key        = bp.bs_key       -- join bp, bs
      AND bp.pieces        = bs.pieces
 
   UNION ALL
 
--
 
   SELECT proxyCopy_con_t                       type_con,
          xdf.xdf_key                           key_con,
          xdf.xdf_recid                         recid_con,
          xdf.xdf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          xdf.handle                            fileName_con,
          xdf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          xdf.status                            status_con,
          xdf.blocks                            blocks_con,
          xdf.block_size                        blockSize_con,
          xdf.device_type                       deviceType_con,
          xdf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          xdf.ckp_scn                           toSCN_act,
          xdf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          xdf.file#                             dfNumber_obj,
          xdf.create_scn                        dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          xdf.pdb_key                           pdbKey_obj,
 
          keep_options                          keep_options,
          keep_until                            keep_until,
 
          xdf.abs_fuzzy_scn                     afzSCN_act,
          xdf.rcv_fuzzy_time                    rfzTime_act,
          xdf.rcv_fuzzy_scn                     rfzSCN_act,
          xdf.media                             media_con,
          'NO'                                  isrdf_con,
          site_key                              site_key_con,
          xdf.foreign_dbid                      foreignDbid_obj,
          decode(xdf.plugged_readonly, 'YES', 1, 0)
                                                pluggedRonly_obj,
          xdf.plugin_scn                        pluginSCN_obj,
          xdf.plugin_reset_scn                  pluginRlgSCN_obj,
          xdf.plugin_reset_time                 pluginRlgTime_obj,
 
          decode(xdf.plugin_scn, 0, xdf.create_scn,
                 xdf.plugin_scn)                newDfCreationSCN_obj,
          decode(xdf.plugged_readonly, 'NO', xdf.ckp_scn,
                 xdf.plugin_scn)                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM xdf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(xdf.file#) = TRUE#)
      AND (untilSCN IS NULL OR
           (xdf.plugged_readonly = 'NO' AND
            greatest(xdf.ckp_scn, xdf.abs_fuzzy_scn,
                     xdf.rcv_fuzzy_scn) <= untilSCN) OR
           (xdf.plugged_readonly = 'YES' AND
            xdf.plugin_scn <= untilSCN))
      AND xdf.status = 'A'
      AND (restoreSource is NULL OR
           bitand(restoreSource, proxyCopy_con_t) != 0)
      AND dbinc.db_key = this_db_key
      AND xdf.dbinc_key = dbinc.dbinc_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
 
    UNION ALL
 
--
 
   SELECT proxyCopy_con_t                       type_con,
          xcf.xcf_key                           key_con,
          xcf.xcf_recid                         recid_con,
          xcf.xcf_stamp                         stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          xcf.handle                            fileName_con,
          xcf.tag                               tag_con,
          to_number(null)                       copyNumber_con,
          xcf.status                            status_con,
          to_number(null)                       blocks_con,
          xcf.block_size                        blockSize_con,
          xcf.device_type                       deviceType_con,
          xcf.completion_time                   compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          full_act_t                            type_act,
          0                                     fromSCN_act,
          xcf.ckp_scn                           toSCN_act,
          xcf.ckp_time                          toTime_act,
          dbinc.reset_scn                       rlgSCN_act,
          dbinc.reset_time                      rlgTime_act,
          dbinc.dbinc_key                       dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          0                                     dfNumber_obj,
          0                                     dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          nvl(xcf.controlfile_type, 'B')        cfType_obj,
          xcf.pdb_key                           pdbKey_obj,
 
          xcf.keep_options                      keep_options,
          xcf.keep_until                        keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          xcf.media                             media_con,
          'NO'                                  isrdf_con,
          site_key                              site_key_con,
          0                                     foreignDbid_obj,
          0                                     pluggedRonly_obj,
          0                                     pluginSCN_obj,
          0                                     pluginRlgSCN_obj,
          to_date(null)                         pluginRlgTime_obj,
 
          0                                     newDfCreationSCN_obj,
          xcf.ckp_scn                           newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM xcf, dbinc
    WHERE (tc_database = TRUE# OR isTranslatedFno(0) = TRUE#)
      AND (untilSCN IS NULL OR
           xcf.ckp_scn <= untilSCN)
      AND xcf.status = 'A'
      AND (restoreSource is NULL OR
           bitand(restoreSource, proxyCopy_con_t) != 0)
      AND dbinc.db_key = this_db_key
      AND xcf.dbinc_key = dbinc.dbinc_key
      AND rmanCmd NOT IN (recoverCmd_t, blkRestoreCmd_t)
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
    ORDER BY dfNumber_obj         asc,
             newDfCreationSCN_obj asc,
             newToSCN_act         desc,
             fromSCN_act          asc,
             type_con             asc,
             setStamp_con         desc,     /* better value, but may be null */
             setCount_con         desc,       /* ensures uniqueness with ORS */
             stamp_con            desc;      /* needed when setStamp is null */
 
    /* ORS Preference: Latest backup is returned first. Since virtual copy
    ** has higher set_count, they go first in the restore list than file chunks.
    ** We really don't have the meta-data here to find out whether the piece
    ** exists on tape, replication or file chunk to sort it out. This
    ** requires another join with bp table which is expensive.
    */
 
--
CURSOR rcvRecCursor1Filter_c(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,c1rec         IN     rcvRec_t
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date
  ,rmanCmd       IN     binary_integer)
RETURN rcvRec_t IS
 
--
 
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = offlineRangeRec_con_t
     AND rcvRecCursor1Filter_c.pluggedRonly = 0
     AND c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey
     AND (rcvRecCursor1Filter_c.dfCkpSCN is null OR
          rcvRecCursor1Filter_c.dfCkpSCN <= c1rec.fromSCN_act)
     AND (rcvRecCursor1Filter_c.targetSCN is null OR
          c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN)
 
   UNION ALL
 
--
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = imageCopy_con_t
      AND ((canApplyAnyRedo = TRUE# AND c1rec.dfNumber_obj <> 0) OR
           (craGetAllCfBackups = TRUE# AND c1rec.dfNumber_obj = 0) OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginRlgSCN_obj = rcvRecCursor1Filter_c.dbincRlgSCN AND
            c1rec.pluginRlgTime_obj = rcvRecCursor1Filter_c.dbincRlgTime))
      AND (rcvRecCursor1Filter_c.dfCkpSCN is null OR
           rmanCmd = blkRestoreCmd_t OR
           rcvRecCursor1Filter_c.dfCkpSCN <= c1rec.toSCN_act)
      AND (rcvRecCursor1Filter_c.targetSCN is null OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginSCN_obj <= rcvRecCursor1Filter_c.targetSCN))
      AND (restoreTag is NULL OR
           c1rec.tag_con = restoreTag OR
           computeRA_allRecords = TRUE#)
      AND ((c1rec.foreignDbid_obj = rcvRecCursor1Filter_c.foreignDbid) OR
           (c1rec.foreignDbid_obj = 0 AND
            c1rec.pluginSCN_obj = 0   AND
            rcvRecCursor1Filter_c.pluginSCN = 0))
--
--
--
   UNION ALL
 
--
 
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = backupSet_con_t
      AND ((canApplyAnyRedo     = TRUE# AND c1rec.dfNumber_obj <> 0) OR
           (craGetAllCfBackups = TRUE# AND c1rec.dfNumber_obj = 0) OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginRlgSCN_obj = rcvRecCursor1Filter_c.dbincRlgSCN AND
            c1rec.pluginRlgTime_obj = rcvRecCursor1Filter_c.dbincRlgTime))
      AND (rcvRecCursor1Filter_c.dfCkpSCN IS NULL OR
           rmanCmd = blkRestoreCmd_t OR
           rcvRecCursor1Filter_c.dfCkpSCN < c1rec.toSCN_act)
      AND (rcvRecCursor1Filter_c.targetSCN IS NULL OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginSCN_obj <= rcvRecCursor1Filter_c.targetSCN))
      AND ((c1rec.foreignDbid_obj = rcvRecCursor1Filter_c.foreignDbid) OR
           (c1rec.foreignDbid_obj = 0 AND
            c1rec.pluginSCN_obj = 0   AND
            rcvRecCursor1Filter_c.pluginSCN = 0))
--
--
--
   UNION ALL
 
--
 
   SELECT c1rec.type_con                        type_con,
          c1rec.key_con                         key_con,
          c1rec.recid_con                       recid_con,
          c1rec.stamp_con                       stamp_con,
          c1rec.setStamp_con                    setStamp_con,
          c1rec.setCount_con                    setCount_con,
          c1rec.bsRecid_con                     bsRecid_con,
          c1rec.bsStamp_con                     bsStamp_con,
          c1rec.bsKey_con                       bsKey_con,
          c1rec.bsLevel_con                     bsLevel_con,
          c1rec.bsType_con                      bsType_con,
          c1rec.elapseSecs_con                  elapseSecs_con,
          c1rec.pieceCount_con                  pieceCount_con,
          c1rec.fileName_con                    fileName_con,
          c1rec.tag_con                         tag_con,
          c1rec.copyNumber_con                  copyNumber_con,
          c1rec.status_con                      status_con,
          c1rec.blocks_con                      blocks_con,
          c1rec.blockSize_con                   blockSize_con,
          c1rec.deviceType_con                  deviceType_con,
          c1rec.compTime_con                    compTime_con,
          c1rec.cfCreationTime_con              cfCreationTime_con,
          c1rec.pieceNumber_con                 pieceNumber_con,
          c1rec.bpCompTime_con                  bpCompTime_con,
          c1rec.bpCompressed_con                bpCompressed_con,
          c1rec.multi_section_con               multi_section_con,
 
          c1rec.type_act                        type_act,
          c1rec.fromSCN_act                     fromSCN_act,
          c1rec.toSCN_act                       toSCN_act,
          c1rec.toTime_act                      toTime_act,
          c1rec.rlgSCN_act                      rlgSCN_act,
          c1rec.rlgTime_act                     rlgTime_act,
          c1rec.dbincKey_act                    dbincKey_act,
          c1rec.level_act                       level_act,
          c1rec.section_size_act                section_size_act,
 
          c1rec.dfNumber_obj                    dfNumber_obj,
          c1rec.dfCreationSCN_obj               dfCreationSCN_obj,
          c1rec.cfSequence_obj                  cfSequence_obj,
          c1rec.cfDate_obj                      cfDate_obj,
          c1rec.logSequence_obj                 logSequence_obj,
          c1rec.logThread_obj                   logThread_obj,
          c1rec.logRlgSCN_obj                   logRlgSCN_obj,
          c1rec.logRlgTime_obj                  logRlgTime_obj,
          c1rec.logLowSCN_obj                   logLowSCN_obj,
          c1rec.logLowTime_obj                  logLowTime_obj,
          c1rec.logNextSCN_obj                  logNextSCN_obj,
          c1rec.logNextTime_obj                 logNextTime_obj,
          c1rec.logTerminal_obj                 logTerminal_obj,
          c1rec.cfType_obj                      cfType_obj,
          c1rec.pdbKey_obj                      pdbKey_obj,
 
          c1rec.keep_options                    keep_options,
          c1rec.keep_until                      keep_until,
 
          c1rec.afzSCN_act                      afzSCN_act,
          c1rec.rfzTime_act                     rfzTime_act,
          c1rec.rfzSCN_act                      rfzSCN_act,
          c1rec.media_con                       media_con,
          c1rec.isrdf_con                       isrdf_con,
          c1rec.site_key_con                    site_key_con,
          c1rec.foreignDbid_obj                 foreignDbid_obj,
          c1rec.pluggedRonly_obj                pluggedRonly_obj,
          c1rec.pluginSCN_obj                   pluginSCN_obj,
          c1rec.pluginRlgSCN_obj                pluginRlgSCN_obj,
          c1rec.pluginRlgTime_obj               pluginRlgTime_obj,
 
          c1rec.newDfCreationSCN_obj            newDfCreationSCN_obj,
          c1rec.newToSCN_act                    newToSCN_act,
          c1rec.newRlgSCN_act                   newRlgSCN_act,
          c1rec.newRlgTime_act                  newRlgTime_act,
          c1rec.sfDbUniqueName_obj              sfDbUniqueName_obj,
          c1rec.sparse_backup_con               sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1rec.type_con = proxyCopy_con_t
      AND rmanCmd != blkRestoreCmd_t
      AND ((canApplyAnyRedo     = TRUE# AND c1rec.dfNumber_obj <> 0) OR
           (craGetAllCfBackups = TRUE# AND c1rec.dfNumber_obj = 0) OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.dbincKey_act = rcvRecCursor1Filter_c.dbincKey) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginRlgSCN_obj = rcvRecCursor1Filter_c.dbincRlgSCN AND
            c1rec.pluginRlgTime_obj = rcvRecCursor1Filter_c.dbincRlgTime))
      AND (rcvRecCursor1Filter_c.dfCkpSCN IS NULL OR
           rcvRecCursor1Filter_c.dfCkpSCN < c1rec.toSCN_act)
      AND (rcvRecCursor1Filter_c.targetSCN IS NULL OR
           (c1rec.pluggedRonly_obj = 0 AND
            c1rec.toSCN_act <= rcvRecCursor1Filter_c.targetSCN) OR
           (c1rec.pluggedRonly_obj != 0 AND
            c1rec.pluginSCN_obj <= rcvRecCursor1Filter_c.targetSCN))
      AND (restoreTag is NULL OR
           c1rec.tag_con = restoreTag OR
           computeRA_allRecords = TRUE#)
      AND ((c1rec.foreignDbid_obj = rcvRecCursor1Filter_c.foreignDbid) OR
           (c1rec.foreignDbid_obj = 0 AND
            c1rec.pluginSCN_obj = 0   AND
            rcvRecCursor1Filter_c.pluginSCN = 0));
--
--
--
 
CURSOR rcvRecCursor2_c(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,c1frec        IN     rcvRec_t
  ,excludeAction IN     binary_integer
  ,foreignDbid    IN    number
  ,pluggedRonly   IN    binary_integer
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date)
RETURN rcvRec_t IS
 
--
 
   SELECT c1frec.type_con                       type_con,
          c1frec.key_con                        key_con,
          c1frec.recid_con                      recid_con,
          c1frec.stamp_con                      stamp_con,
          c1frec.setStamp_con                   setStamp_con,
          c1frec.setCount_con                   setCount_con,
          c1frec.bsRecid_con                    bsRecid_con,
          c1frec.bsStamp_con                    bsStamp_con,
          c1frec.bsKey_con                      bsKey_con,
          c1frec.bsLevel_con                    bsLevel_con,
          c1frec.bsType_con                     bsType_con,
          c1frec.elapseSecs_con                 elapseSecs_con,
          c1frec.pieceCount_con                 pieceCount_con,
          c1frec.fileName_con                   fileName_con,
          c1frec.tag_con                        tag_con,
          c1frec.copyNumber_con                 copyNumber_con,
          c1frec.status_con                     status_con,
          c1frec.blocks_con                     blocks_con,
          c1frec.blockSize_con                  blockSize_con,
 
          c1frec.deviceType_con                 deviceType_con,
          c1frec.compTime_con                   compTime_con,
          c1frec.cfCreationTime_con             cfCreationTime_con,
          c1frec.pieceNumber_con                pieceNumber_con,
          c1frec.bpCompTime_con                 bpCompTime_con,
          c1frec.bpCompressed_con               bpCompressed_con,
          c1frec.multi_section_con              multi_section_con,
 
          c1frec.type_act                       type_act,
          c1frec.fromSCN_act                    fromSCN_act,
          c1frec.toSCN_act                      toSCN_act,
          c1frec.toTime_act                     toTime_act,
          c1frec.rlgSCN_act                     rlgSCN_act,
          c1frec.rlgTime_act                    rlgTime_act,
          c1frec.dbincKey_act                   dbincKey_act,
          c1frec.level_act                      level_act,
          c1frec.section_size_act               section_size_act,
 
          c1frec.dfNumber_obj                   dfNumber_obj,
          c1frec.dfCreationSCN_obj              dfCreationSCN_obj,
          c1frec.cfSequence_obj                 cfSequence_obj,
          c1frec.cfDate_obj                     cfDate_obj,
          c1frec.logSequence_obj                logSequence_obj,
          c1frec.logThread_obj                  logThread_obj,
          c1frec.logRlgSCN_obj                  logRlgSCN_obj,
          c1frec.logRlgTime_obj                 logRlgTime_obj,
          c1frec.logLowSCN_obj                  logLowSCN_obj,
          c1frec.logLowTime_obj                 logLowTime_obj,
          c1frec.logNextSCN_obj                 logNextSCN_obj,
          c1frec.logNextTime_obj                logNextTime_obj,
          c1frec.logTerminal_obj                logTerminal_obj,
          c1frec.cfType_obj                     cfType_obj,
          c1frec.pdbKey_obj                     pdbKey_obj,
 
          c1frec.keep_options                   keep_options,
          c1frec.keep_until                     keep_until,
 
          c1frec.afzSCN_act                     afzSCN_act,
          c1frec.rfzTime_act                    rfzTime_act,
          c1frec.rfzSCN_act                     rfzSCN_act,
          c1frec.media_con                      media_con,
          c1frec.isrdf_con                      isrdf_con,
          c1frec.site_key_con                   site_key_con,
          c1frec.foreignDbid_obj                foreignDbid_obj,
          c1frec.pluggedRonly_obj               pluggedRonly_obj,
          c1frec.pluginSCN_obj                  pluginSCN_obj,
          c1frec.pluginRlgSCN_obj               pluginRlgSCN_obj,
          c1frec.pluginRlgTime_obj              pluginRlgTime_obj,
 
          c1frec.newDfCreationSCN_obj           newDfCreationSCN_obj,
          c1frec.newToSCN_act                   newToSCN_act,
          c1frec.newRlgSCN_act                  newRlgSCN_act,
          c1frec.newRlgTime_act                 newRlgTime_act,
          c1frec.sfDbUniqueName_obj             sfDbUniqueName_obj,
          c1frec.sparse_backup_con              sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE c1frec.type_con is not null
 
   UNION ALL
 
--
--
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          implicitRange_act_t                   type_act,
          rcvRecCursor2_c.offlSCN               fromSCN_act,
          rcvRecCursor2_c.onlSCN                toSCN_act,
          rcvRecCursor2_c.onlTime               toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          rcvRecCursor2_c.onlSCN                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction,implicitRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND offlSCN <> 0
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.offlSCN)
      AND (rcvRecCursor2_c.onlSCN >=   -- belongs to this incarnation
           rcvRecCursor2_c.dbincRlgSCN)
      AND (rcvRecCursor2_c.targetSCN is null OR
           rcvRecCursor2_c.onlscn <=   -- don't advance ckpt beyond
           rcvRecCursor2_c.targetSCN)  -- targetSCN
      AND (untilSCN is null OR        -- don't advance ckpt beyond until scn
           rcvRecCursor2_c.onlSCN < untilSCN)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          cleanRange_act_t                      type_act,
          rcvRecCursor2_c.cleanSCN              fromSCN_act,
          rcvRecCursor2_c.clean2SCN             toSCN_act,
          rcvRecCursor2_c.clean2Time            toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          rcvRecCursor2_c.clean2SCN             newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, cleanRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND rcvRecCursor2_c.cleanscn <> 0
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.cleanscn)
      AND -- belongs to this incarnation
          (rcvRecCursor2_c.clean2scn >=
           rcvRecCursor2_c.dbincRlgSCN)
      AND -- ignore if starts beyond target
          (rcvRecCursor2_c.targetscn is null OR
           rcvRecCursor2_c.cleanscn <
           rcvRecCursor2_c.targetSCN)
      AND -- If clean2scn is infinite, then we processed this when scanning
--
          (rcvRecCursor2_c.targetSCN is null OR
           rcvRecCursor2_c.clean2SCN <=
           rcvRecCursor2_c.targetSCN)
      AND -- don't advance ckpt beyond until scn, unless we don't know
--
          (untilscn is null OR
           rcvRecCursor2_c.clean2SCN <= untilSCN OR
           rcvRecCursor2_c.clean2SCN = highscnval)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
          
          cleanRange_act_t                      type_act,
          rcvRecCursor2_c.pluginSCN             fromSCN_act,
          rcvRecCursor2_c.clean2SCN             toSCN_act,
          rcvRecCursor2_c.clean2Time            toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          rcvRecCursor2_c.clean2SCN             newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
 FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, cleanRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 1
      AND rcvRecCursor2_c.cleanscn <> 0
      AND rcvRecCursor2_c.cleanscn <= rcvRecCursor2_c.pluginSCN
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.pluginSCN)
      AND -- belongs to this incarnation
          (rcvRecCursor2_c.clean2scn >=
           rcvRecCursor2_c.dbincRlgSCN)
      AND -- ignore if starts beyond target
          (rcvRecCursor2_c.targetscn is null OR
           rcvRecCursor2_c.pluginSCN <
           rcvRecCursor2_c.targetSCN)
      AND -- If clean2scn is infinite, then we processed this when scanning
--
          (rcvRecCursor2_c.targetSCN is null OR
           rcvRecCursor2_c.clean2SCN <=
           rcvRecCursor2_c.targetSCN)
      AND -- don't advance ckpt beyond until scn, unless we don't know
--
          (untilscn is null OR
           rcvRecCursor2_c.clean2SCN <= untilSCN OR
           rcvRecCursor2_c.clean2SCN = highscnval)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          cleanRange_act_t                      type_act,
          rcvRecCursor2_c.pluginSCN             fromSCN_act,
          rcvRecCursor2_c.crescn                toSCN_act,
          to_date(null)                         toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          crescn                                newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, cleanRange_act_t) = 0
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND rcvRecCursor2_c.pluginSCN <> 0
      AND (rcvRecCursor2_c.dfCkpSCN is null OR
           rcvRecCursor2_c.dfCkpSCN <=
           rcvRecCursor2_c.pluginSCN)
      AND -- belongs to this incarnation
          (crescn >= rcvRecCursor2_c.dbincRlgSCN)
      AND (rcvRecCursor2_c.targetSCN is null OR
           crescn <=   -- don't advance ckpt beyond
           rcvRecCursor2_c.targetSCN)  -- targetSCN
      AND -- don't advance ckpt beyond until scn, unless we don't know
--
          (untilscn is null OR crescn < untilSCN)
 
   UNION ALL
 
   SELECT offlineRangeRec_con_t                 type_con,
          to_number(null)                       key_con,
          to_number(null)                       recid_con,
          to_number(null)                       stamp_con,
          to_number(null)                       setStamp_con,
          to_number(null)                       setCount_con,
          to_number(null)                       bsRecid_con,
          to_number(null)                       bsStamp_con,
          to_number(null)                       bsKey_con,
          to_number(null)                       bsLevel_con,
          to_char(null)                         bsType_con,
          to_number(null)                       elapseSecs_con,
          to_number(null)                       pieceCount_con,
          to_char(null)                         fileName_con,
          to_char(null)                         tag_con,
          to_number(null)                       copyNumber_con,
          to_char(null)                         status_con,
          to_number(null)                       blocks_con,
          to_number(null)                       blockSize_con,
          to_char(null)                         deviceType_con,
          to_date(null)                         compTime_con,
          to_date(null)                         cfCreationTime_con,
          to_number(null)                       pieceNumber_con,
          to_date(null)                         bpCompTime_con,
          to_char(null)                         bpCompressed_con,
          to_char(null)                         multi_section_con,
 
          spanningRange_act_t                   type_act,
          rcvRecCursor2_c.targetSCN             fromSCN_act,
          to_number(null)                       toSCN_act,
          to_date(null)                         toTime_act,
          rcvRecCursor2_c.dbincRlgSCN           rlgSCN_act,
 
          rcvRecCursor2_c.dbincRlgTime          rlgTime_act,
          rcvRecCursor2_c.dbincKey              dbincKey_act,
          to_number(null)                       level_act,
          0                                     section_size_act,
 
          fno                                   dfNumber_obj,
          crescn                                dfCreationSCN_obj,
          to_number(null)                       cfSequence_obj,
          to_date(null)                         cfDate_obj,
          to_number(null)                       logSequence_obj,
          to_number(null)                       logThread_obj,
          to_number(null)                       logRlgSCN_obj,
          to_date(null)                         logRlgTime_obj,
          to_number(null)                       logLowSCN_obj,
          to_date(null)                         logLowTime_obj,
          to_number(null)                       logNextSCN_obj,
          to_date(null)                         logNextTime_obj,
          to_char(null)                         logTerminal_obj,
          to_char(null)                         cfType_obj,
          to_number(null)                       pdbKey_obj,
 
          to_number(null)                       keep_options,
          to_date(null)                         keep_until,
 
          to_number(null)                       afzSCN_act,
          to_date(null)                         rfzTime_act,
          to_number(null)                       rfzSCN_act,
          to_char(null)                         media_con,
          'NO'                                  isrdf_con,
          0                                     site_key_con,
          rcvRecCursor2_c.foreignDbid           foreignDbid_obj,
          rcvRecCursor2_c.pluggedRonly          pluggedRonly_obj,
          rcvRecCursor2_c.pluginSCN             pluginSCN_obj,
          rcvRecCursor2_c.pluginRlgSCN          pluginRlgSCN_obj,
          rcvRecCursor2_c.pluginRlgTime         pluginRlgTime_obj,
 
          crescn                                newDfCreationSCN_obj,
          to_number(null)                       newToSCN_act,
          to_number(null)                       newRlgSCN_act,
          to_date(null)                         newRlgTime_act,
          to_char(null)                         sfDbUniqueName_obj,
          to_char(null)                         sparse_backup_con,
          0                                     ppl_pdb_id_con,
          0                                     ppl_cdb_dbid_con
     FROM dual
    WHERE bitand(rcvRecCursor2_c.excludeAction, spanningRange_act_t) = 0
--
--
      AND rcvRecCursor2_c.pluggedRonly = 0
      AND rcvRecCursor2_c.targetSCN <
          rcvRecCursor2_c.dbincRlgSCN
 
    ORDER BY newToSCN_act desc,
             fromSCN_act  desc,
             type_con     asc,
             stamp_con    desc;
 
--
--
--
CURSOR sinceLastBackedAL_c (devtype      IN VARCHAR2,
                            numofbackups IN NUMBER) IS
  SELECT * FROM
    (
    SELECT low_scn,
           next_scn,
           next_time,
           count(*) over
             (partition by sequence#, thread#, dbinc_key) nbackups
      FROM
      (
      SELECT sequence#,
             thread#,
             low_scn,
             next_scn,
             next_time,
             dbinc_key
        FROM brl,
          (SELECT UNIQUE bs.bs_key,
                         copy#,
                         pieces,
                         count(piece#) over
                           (partition by bs.bs_key, copy#) pieces_count,
                         device_type,
                         bs.completion_time
             FROM bs, bp
            WHERE bs.db_key   = this_db_key
              AND bp.status   = 'A'
              AND bs.bck_type = 'L'
              AND bs.bs_key   = bp.bs_key
              AND (devtype IS NULL OR devtype = device_type)
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared=TRUE# AND bp.device_type = 'DISK') OR
                     (tape_backups_shared=TRUE# AND bp.device_type <>'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
          ) allbs
        WHERE brl.bs_key         = allbs.bs_key
          AND allbs.pieces_count = allbs.pieces
 
      UNION ALL
 
      SELECT sequence#,
             thread#,
             first_change#,
             next_change#,
             next_time,
             dbinc_key
        FROM rc_proxy_archivedlog
       WHERE db_key = this_db_key
         AND status = 'A'
         AND (devtype IS NULL OR devtype = device_type)
      )
    )
    WHERE nbackups >= numofbackups
  ORDER BY next_time       DESC;
 
 
--
CURSOR restore_point_c (con_id IN NUMBER, name  IN VARCHAR2) IS
  SELECT r.name,
         r.dbinc_key dbinc#,
         scn,
         creation_time,
         restore_point_time,
         guarantee_flashback_database guaranteed,
         preserved,
         d.reset_scn,
         d.reset_time,
         pdb.con_id con_id,
         r.clean clean
  FROM rc_restore_point r, dbinc d, pdb, pdb_dbinc
  WHERE d.dbinc_key = r.dbinc_key
    AND site_key = nvl(user_site_key, this_site_key)
    AND (r.name = restore_point_c.name OR restore_point_c.name is null)
    AND pdb.db_key = this_db_key
    AND r.pdb_key = pdb.pdb_key
    AND pdb_dbinc.pdb_key = pdb.pdb_key
    AND pdb_dbinc.drop_scn IS NULL
    AND pdb_dbinc.dbinc_key = this_dbinc_key
  ORDER BY decode(pdb.con_id, restore_point_c.con_id, -1, pdb.con_id),
        scn, creation_time;
 
 
--
CURSOR translatePdbName_c IS
   SELECT con_id, name
     FROM rci_pdbinc_this_dbinc pdbinc
    WHERE pdbinc.dbinc_key  = this_dbinc_key
      AND (untilSCN IS NULL OR pdbinc.create_scn < untilSCN)
      AND (pdbinc.drop_scn IS NULL OR pdbinc.drop_scn > untilSCN)
      AND con_id > 1
 ORDER BY pdbinc.drop_scn desc;
 
--
CURSOR translatePdbFile_c(fromSCN IN number, toSCN IN number) IS
   SELECT con_id, file#, stop_change# stopSCN
     FROM rci_datafile_this_dbinc rcd
    WHERE rcd.dbinc_key  = this_dbinc_key
      AND decode(plugin_change#, 0, creation_change#, plugin_change#) <= toSCN
      AND (drop_change# is null OR drop_change# > fromSCN)
      AND (nvl(realf_site_key, translation_site_key) = site_key);
 
CURSOR translateNoBackupPdb_c(pdbname IN varchar2) IS
   SELECT decode(pdbinc.nobackup, 'Y', 1, 0) noBackupPdb
     FROM rci_pdbinc_this_dbinc pdbinc
    WHERE pdbinc.dbinc_key = this_dbinc_key
      AND pdbinc.name = translateNoBackupPdb_c.pdbname
      AND (untilSCN IS NULL OR pdbinc.create_scn < untilSCN)
      AND (pdbinc.drop_scn IS NULL OR pdbinc.drop_scn > untilSCN);
 
--
PROCEDURE debout(
   line IN varchar2
)
IS
    isrs            number;
BEGIN
--
--
   IF rsdebug IS NULL
   THEN
     SELECT COUNT(*) INTO isrs FROM user_tables WHERE table_name = 'BLOCKS';
     rsdebug := isrs > 0;
   END IF;
 
--
   IF rsdebug
   THEN
     EXECUTE IMMEDIATE 'BEGIN sys.kbrsi_icd.rsTrace(:1); END;' USING line;
   ELSE
     dbms_output.put_line(line);
   END IF;
 
EXCEPTION
   WHEN others THEN
     dbms_output.put_line(line);
END debout;
 
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
--
PROCEDURE deb(
   type IN number
  ,line IN varchar2 DEFAULT NULL
)
IS
    pname           varchar2(512);
    pref            varchar2(11) := 'DBGRCVMAN: ';
    dstr            varchar2(1000);
BEGIN
   IF (not debug) THEN
      RETURN;
   END IF;
 
   IF type = DEB_ENTER THEN
      pname := line;
      dstr := (pref||rpad(' ',pname_i)||'ENTERING '||pname);
      pname_i := pname_i + 1;
      last_pnames(pname_i) := pname;
   ELSIF type = DEB_IN THEN
      dstr := (pref||rpad(' ',pname_i+2)||last_pnames(pname_i)||
                           ' '||line);
   ELSIF type = DEB_EXIT THEN
      IF (pname_i >= 1) THEN
          pname := last_pnames(pname_i);
          pname_i := pname_i - 1;
      ELSE
          pname := DEB_DEF_PNAME;
      END IF;
      IF line is not NULL THEN
         dstr := (pref||rpad(' ', pname_i)||'EXITING '||pname||
                              ' '||line);
      ELSE
         dstr := (pref||rpad(' ', pname_i)||'EXITING '||pname);
      END IF;
   ELSIF type = DEB_OPEN THEN
      pname := last_pnames(pname_i);
      dstr := (pref||rpad(' ', pname_i)||'OPENING cursor '||
                           line||' in '||pname);
   ELSE
      dstr := (pref||line);
   END IF;
 
   debout(dstr);
 
EXCEPTION
   WHEN others THEN
      debout('caught exception during deb ' || substr(sqlerrm, 1, 512));
END;
 
FUNCTION bool2char(
   flag IN boolean)
RETURN varchar2 IS
BEGIN
   IF (flag) THEN
      RETURN 'TRUE';
   ELSE
      RETURN 'FALSE';
   END IF;
END bool2char;
 
--
--
--
 
--
PROCEDURE setAlTransClause(
   thread   IN NUMBER   DEFAULT NULL
  ,fromTime IN DATE     DEFAULT NULL
  ,toTime   IN DATE     DEFAULT NULL
  ,fromSCN  IN NUMBER   DEFAULT NULL
  ,toSCN    IN NUMBER   DEFAULT NULL
  ,fromSeq  IN NUMBER   DEFAULT NULL
  ,toSeq    IN NUMBER   DEFAULT NULL
  ,pattern  IN VARCHAR2 DEFAULT NULL)
IS
BEGIN
   tc_thread   := thread;
   tc_fromTime := fromTime;
   tc_toTime   := toTime;
   tc_fromSCN  := fromSCN;
   tc_toSCN    := toSCN;
   tc_fromSeq  := fromSeq;
   tc_toSeq    := toSeq;
   tc_pattern  := pattern;
   deb(DEB_PRINT, 'tc_thread='   || tc_thread);
   deb(DEB_PRINT, 'tc_fromSCN='  || fromSCN);
   deb(DEB_PRINT, 'tc_toSCN='    || toSCN);
   deb(DEB_PRINT, 'tc_fromSeq='  || fromSeq);
   deb(DEB_PRINT, 'tc_fromTime=' || fromTime);
   deb(DEB_PRINT, 'tc_toTime='   || toTime);
   deb(DEB_PRINT, 'tc_toSeq='    || toSeq);
   deb(DEB_PRINT, 'tc_pattern='  || pattern);
END setAlTransClause;
 
--
PROCEDURE setDfTransClause(
   fno IN NUMBER)
IS
BEGIN
   tc_fno(fno) := TRUE;
END setDfTransClause;
 
--
PROCEDURE setDBTransClause
IS
BEGIN
   deb(DEB_PRINT, 'tc_database=TRUE');
   tc_database := TRUE#;
END setDBTransClause;
 
--
PROCEDURE resetAlTransClause
IS
BEGIN
   tc_thread   := to_number(null);
   tc_fromTime := to_date(null);
   tc_toTime   := to_date(null);
   tc_fromSCN  := to_number(null);
   tc_toSCN    := to_number(null);
   tc_fromSeq  := to_number(null);
   tc_toSeq    := to_number(null);
   tc_pattern  := to_char(null);
   currInc     := -1;
   getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
   getArchivedLogOnlyrdf := 0;
   tc_threadSeq.delete;
END resetAlTransClause;
 
--
PROCEDURE resetDBTransClause
IS
BEGIN
   tc_database := FALSE#;
   tc_fno.delete;
END resetDBTransClause;
 
--
PROCEDURE resetDbidTransClause
IS
BEGIN
   tc_anydbid := FALSE#;
   tc_dbid.delete;
END resetDBidTransClause;
 
--
--
--
 
--
 
--
FUNCTION skipTableSpace(
   tsName   IN varchar2
  ,pdbId    IN number)
RETURN boolean IS
BEGIN
   deb(DEB_ENTER, 'skipTableSpace');
   FOR i in 1..skipTablespaceList.count LOOP
      IF (tsName = skipTablespaceList(i).name AND
          pdbId  = skipTablespaceList(i).pdbId) THEN
         deb(DEB_EXIT, 'with: TRUE');
         RETURN TRUE;
      END IF;
   END LOOP;
   deb(DEB_EXIT, 'with: FALSE');
   RETURN FALSE;
END;
 
--
FUNCTION isDeviceTypeAllocated(
   deviceType IN varchar2)
RETURN NUMBER IS
BEGIN
   IF (anyDevice = TRUE#) THEN
      RETURN TRUE#;
   END IF;
 
   FOR i IN 1..deviceCount LOOP
      IF deviceType = deviceList(i) THEN
         RETURN TRUE#;
      END IF;
   END LOOP;
 
   RETURN FALSE#;
END isDeviceTypeAllocated;
 
--
--
--
 
--
--
--
--
FUNCTION computeAvailableMask(
   available            IN number
  ,unavailable          IN number
  ,deleted              IN number
  ,expired              IN number
  ,partial_avail        IN number DEFAULT 0)
RETURN binary_integer IS
   rc           binary_integer := 0;
BEGIN
   deb(DEB_ENTER, 'computeAvailableMask');
   IF (available > 0) THEN
      rc := rc + dbms_rcvman.BSavailable;
   END IF;
   IF (unavailable > 0 ) THEN
      rc := rc + dbms_rcvman.BSunavailable;
   END IF;
   IF (deleted > 0 ) THEN
      rc := rc + dbms_rcvman.BSdeleted;
   END IF;
   IF (expired > 0 ) THEN
      rc := rc + dbms_rcvman.BSexpired;
   END IF;
   IF (partial_avail > 0 ) THEN
      rc := rc + dbms_rcvman.BSpartial_avail;
   END IF;
 
   deb(DEB_EXIT, 'with rc:'||to_char(rc));
   RETURN rc;
END computeAvailableMask;
 
--
FUNCTION validateBackupSet0(
   tag                     IN     varchar2 DEFAULT NULL
  ,tagMatchRequired        IN     boolean  DEFAULT TRUE
  ,checkDeviceIsAllocated  IN     boolean  DEFAULT TRUE
  ,validRec                OUT    NOCOPY validBackupSetRec_t)
RETURN binary_integer IS
   local        validBackupSetRec_t;
   rc           binary_integer;
   gotRecord    number;
BEGIN
   deb(DEB_ENTER, 'validateBackupSet0');
   <<validationLoop>>
   LOOP
      <<nextRow>>
      gotRecord := getValidBackupSet(validBackupSetRec      => local,
                                     checkDeviceIsAllocated => FALSE#);
 
      EXIT WHEN gotRecord = FALSE#;             -- cursor is closed already
 
      IF (checkDeviceIsAllocated) THEN
         IF (anyDevice = FALSE# AND
             isDeviceTypeAllocated(local.deviceType) = FALSE#) THEN
            deb(DEB_IN, 'device is not allocated');
--
--
            IF (rc IS NULL OR rc <> SUCCESS) THEN
               deb(DEB_IN, 'set rc to available');
               rc := dbms_rcvman.AVAILABLE;
            END IF;
            GOTO nextRow;
         END IF;
      END IF;
 
      validRec := local;                        -- set OUT mode arg
 
      IF (tag IS NOT NULL AND NOT tagMatchRequired) THEN
--
--
--
--
         IF (tag = local.tag) THEN
--
--
--
--
--
--
--
            deb(DEB_IN, 'tag matches');
            rc := SUCCESS;
            deb(DEB_IN, 'exiting loop with rc: SUCCESS');
            EXIT validationLoop;
         ELSE
--
--
--
            deb(DEB_IN, 'tag does not match, continuing search');
            rc := SUCCESS;
         END IF;
      ELSE
--
--
--
         rc := SUCCESS;
         deb(DEB_IN, 'exiting loop with rc: SUCCESS');
         EXIT validationLoop;
      END IF;
   END LOOP;
 
   IF (rc IS NULL) THEN
      deb(DEB_IN, 'rc is null, setting to unavailable');
      rc := dbms_rcvman.UNAVAILABLE;
   END IF;
 
   deb(DEB_EXIT, 'with rc:'||to_char(rc));
   RETURN rc;
 
END validateBackupSet0;
 
--
--
--
 
--
FUNCTION getRecStackCount
RETURN binary_integer IS
BEGIN
  RETURN rcvRecStack.count;
END getRecStackCount;
 
--
FUNCTION getRecFullCount
RETURN binary_integer IS
BEGIN
  RETURN rcvRecStackState.fullBackups;
END getRecFullCount;
 
--
PROCEDURE rcvRecPush(
   rcvRec IN rcvRec_t)
IS
BEGIN
   rcvRecStack.extend;
   deb(DEB_PRINT,'rcvRecPush:from_scn='||rcvRec.fromSCN_act||',to_scn='||rcvRec.toSCN_act||',rcvRecStackCount='||rcvRecStack.count);
   rcvRecStack(rcvRecStack.last) := rcvRec;
END rcvRecPush;
 
--
PROCEDURE rcvRecGet(
   indx   IN  number
  ,rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   rcvRec := rcvRecStack(indx);
END rcvRecGet;
 
--
PROCEDURE rcvRecTop(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   IF (rcvRecStack.count = 0) THEN
      rcvRec := NULL;
   ELSE
      rcvRecGet(rcvRecStack.count, rcvRec);
      deb(DEB_PRINT,'rcvRecPop:from_scn='||rcvRec.fromSCN_act||
                    ',to_scn='||rcvRec.toSCN_act||
                    ',rcvRecStackCount='||rcvRecStack.count );
   END IF;
END rcvRecTop;
 
--
PROCEDURE rcvRecPop(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   rcvRecTop(rcvRec);
   rcvRecStack.trim;
END rcvRecPop;
 
--
PROCEDURE rcvRecConvert(
   rcvRec IN OUT NOCOPY rcvRec_t)
IS
BEGIN
--
--
 
  rcvRec.recid_con      := nvl(rcvRec.recid_con, 0);
  rcvRec.stamp_con      := nvl(rcvRec.stamp_con, 0);
  rcvRec.setStamp_con   := nvl(rcvRec.setStamp_con, 0);
  rcvRec.setCount_con   := nvl(rcvRec.setCount_con, 0);
  rcvRec.fileName_con   := nvl(rcvRec.fileName_con, 'NULL');
  rcvRec.blockSize_con  := nvl(rcvRec.blockSize_con, 0);
  rcvRec.blocks_con     := nvl(rcvRec.blocks_con, 0);
  rcvRec.deviceType_con := nvl(rcvRec.deviceType_con, 'NULL');
END rcvRecConvert;
 
--
PROCEDURE printRcvRec(
   action  IN rcvRec_t
  ,summary IN boolean default FALSE)
IS
   l              varchar2(600);
   cfcretime      varchar2(100);
   action_deleted boolean;
 
   procedure prt(str in out varchar2) is begin
      if length(str) > 2 then
         deb(DEB_PRINT, str);
         str := ' ';
      end if;
   end;
BEGIN
 
--
--
--
   deb(DEB_PRINT, 'DUMPING RECOVERY CONTAINER');
--
   IF (action.type_con = backupSet_con_t) THEN
      IF (action.type_act = full_act_t) THEN
         deb(DEB_PRINT, ' Full Backup Set');
      ELSE
         deb(DEB_PRINT, ' Incremental Backup Set');
      END IF;
   ELSIF (action.type_con = proxyCopy_con_t) THEN
      deb(DEB_PRINT, ' Proxy Backup');
   ELSIF (action.type_con = imageCopy_con_t) THEN
      deb(DEB_PRINT, ' Datafile Copy');
   ELSIF (action.type_con = offlineRangeRec_con_t) THEN
      IF (action.type_act = offlineRange_act_t) THEN
         deb(DEB_PRINT, ' Offline Range Record');
      ELSIF (action.type_act = cleanRange_act_t) THEN
         deb(DEB_PRINT, ' Clean Range');
      ELSIF (action.type_act = implicitRange_act_t) THEN
         deb(DEB_PRINT, ' Implicit Offline Range');
      ELSIF (action.type_act = spanningRange_act_t) THEN
         deb(DEB_PRINT, ' Spanning Offline Range');
      ELSE
         deb(DEB_PRINT, ' Unknown Offline Range Action Type');
      END IF;
   ELSIF (action.type_con = datafile_con_t) THEN
      deb(DEB_PRINT, ' datafile container type');
   ELSIF (action.type_con = addredo_con_t) THEN
      deb(DEB_PRINT,'Add Redo');
   ELSE
      deb(DEB_PRINT, ' Unknown recovery container type');
   END IF;
 
--
   IF (action.type_con = backupSet_con_t) THEN
      deb(DEB_PRINT, '   bsKey=' || to_char(action.bsKey_con) ||
          '  bsRecid=' || to_char(action.bsRecid_con) ||
          '  bsStamp=' || to_char(action.bsStamp_con) ||
          '  setStamp=' || to_char(action.setStamp_con) ||
          '  setCount=' || to_char(action.setCount_con) ||
          '  site_key=' || to_char(action.site_key_con));
      deb(DEB_PRINT, '   bsLevel=' || to_char(action.bsLevel_con) ||
          '  bsType=' || action.bsType_con ||
          '  pieceCount=' || to_char(action.pieceCount_con));
      deb(DEB_PRINT, '   multi_section=' ||
                     nvl(action.multi_section_con, 'NULL'));
   ELSIF (action.type_con = proxyCopy_con_t OR
          action.type_con = imageCopy_con_t) THEN
      deb(DEB_PRINT, '   fileName=' || action.fileName_con);
      deb(DEB_PRINT, '   media=' || action.media_con);
   END IF;
 
   IF (summary) THEN
      RETURN;
   END IF;
 
--
   l := ' ';
 
--
   IF (action.key_con is not null) THEN
      l := l || '  key=' || to_char(action.key_con);
   END IF;
 
--
   IF (action.recid_con is not null) THEN
      l := l || '  recid=' || to_char(action.recid_con) ||
                '  stamp=' || to_char(action.stamp_con);
   END IF;
 
--
   IF (action.status_con is not null) THEN
      l := l || '  status=' || action.status_con;
   END IF;
 
   IF (action.type_con = imageCopy_con_t OR
       action.type_con = backupSet_con_t) THEN
      l := l || '  sparse_backup_con =' || action.sparse_backup_con;
   END IF;
 
 
   prt(l);
 
--
   IF (action.tag_con is not null) THEN
      l := l || '  tag=' || action.tag_con;
   END IF;
 
--
   IF (action.compTime_con is not null) THEN
      l := l || '  compTime=' || to_char(action.compTime_con);
   END IF;
 
   prt(l);
 
   IF (action.deviceType_con is not null) THEN
      l := l || '  deviceType=' || action.deviceType_con;
   END IF;
 
   IF (action.blocks_con is not null) THEN
      l := l || '  blocks=' || to_char(action.blocks_con) ||
           '  blockSize=' || to_char(action.blockSize_con);
   END IF;
 
   IF (action.cfCreationTime_con is not null) THEN
      l := l || '  cfCreationTime=' || to_char(action.cfCreationTime_con);
   END IF;
 
   IF (action.pieceNumber_con is not null) THEN
      l := l || '  pieceNumberl=' || to_char(action.pieceNumber_con);
   END IF;
 
   IF (action.bpCompTime_con is not null) THEN
      l := l || '  bpCompTime=' || to_char(action.bpCompTime_con);
   END IF;
 
   IF (action.bpCompressed_con is not null) THEN
      l := l || '  bpCompressed=' || to_char(action.bpCompressed_con);
   END IF;
 
   prt(l);
 
--
--
--
 
--
   IF (action.fromSCN_act is not null) THEN
      l := l || '  fromSCN=' || to_char(action.fromSCN_act);
   END IF;
 
--
   IF (action.toSCN_act is not null) THEN
      l := l || '  toSCN=' || to_char(action.toSCN_act) ||
           '  toTime=' || to_char(action.toTime_act);
   END IF;
 
--
   IF (action.level_act is not null) THEN
      l := l || '  level=' || to_char(action.level_act);
   END IF;
 
--
   IF (action.section_size_act is not null) THEN
      l := l || '  section_size=' || to_char(action.section_size_act);
   END IF;
 
   prt(l);
 
   IF (action.rlgSCN_act is not null) THEN
      l := l || '  rlgSCN=' || to_char(action.rlgSCN_act) ||
           '  rlgTime=' || to_char(action.rlgTime_act) ||
           '  dbincKey=' || to_char(action.dbincKey_act);
   END IF;
 
   prt(l);
 
   IF (action.afzSCN_act is not null) THEN
      l := l || '  afzSCN=' || to_char(action.afzSCN_act);
   END IF;
 
   prt(l);
 
   IF (action.rfzSCN_act is not null AND action.rfzSCN_act != 0) THEN
      l := l || '  rfzSCN=' || to_char(action.rfzSCN_act) ||
           '  rfzTime=' || nvl(to_char(action.rfzTime_act), 'NULL');
   END IF;
 
   prt(l);
 
--
--
--
 
   IF (action.pdbKey_obj IS NOT NULL) THEN
      l := l || ' pdbKey=' || to_char(action.pdbKey_obj);
   END IF;
 
   prt(l);
 
   IF (action.dfNumber_obj IS NOT NULL) THEN
      l := l || '  dfNumber=' || to_char(action.dfNumber_obj) ||
                '  creationSCN=' || to_char(action.dfCreationSCN_obj) ||
                '  pluginSCN=' || to_char(action.pluginSCN_obj) ||
                '  foreignDbid=' || to_char(action.foreignDbid_obj) ||
                '  pluggedRonly=' || to_char(action.pluggedRonly_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  cfType=' || nvl(action.cfType_obj, 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  keep_options=' || nvl(to_char(action.keep_options), 'NULL') ||
                '  keep_until='   || nvl(to_char(action.keep_until), 'NULL');
      deb(DEB_PRINT, l);
      IF (action.cfSequence_obj IS NOT NULL) THEN
         l := ' ';
         l := l || '  cfSequence=' || to_char(action.cfSequence_obj) ||
                   '  cfDate=' || nvl(to_char(action.cfDate_obj), 'NULL');
         deb(DEB_PRINT, l);
      END IF;
   ELSIF (action.logSequence_obj IS NOT NULL) THEN
      l := l || '  logSequence=' || to_char(action.logSequence_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logThread=' || to_char(action.logThread_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logLowSCN=' || to_char(action.logLowSCN_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logLowTime=' || to_char(action.logLowTime_obj);
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logNextSCN=' || nvl(to_char(action.logNextSCN_obj), 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logNextTime=' || nvl(to_char(action.logNextTime_obj), 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logTerminalEor=' || action.logTerminal_obj;
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logRlgSCN=' || nvl(to_char(action.logRlgSCN_obj), 'NULL');
      deb(DEB_PRINT, l);
      l := ' ';
      l := l || '  logRlgTime=' || nvl(to_char(action.logRlgTime_obj), 'NULL');
      deb(DEB_PRINT, l);
   ELSIF (action.toTime_act IS NOT NULL) THEN
      deb(DEB_PRINT, '  SPFILE');
      deb(DEB_PRINT, '  modification_time=' ||  to_char(action.toTime_act));
      deb(DEB_PRINT, '  db_unique_name=' || action.sfDbUniqueName_obj);
 
      l := ' ';
      l := l || '  keep_options=' || nvl(to_char(action.keep_options), 'NULL') ||
                '  keep_until='   || nvl(to_char(action.keep_until), 'NULL');
      deb(DEB_PRINT, l);
   ELSE
      deb(DEB_PRINT, '  Unknown Recovery Object');
   END IF;
 
EXCEPTION
   WHEN OTHERS THEN
   deb(DEB_PRINT, 'printRcvRec: caught an exception, aborting print');
   RETURN;
END printRcvRec;
 
--
--
--
 
--
FUNCTION redoNeeded(
   action IN rcvRec_t)
RETURN boolean IS
BEGIN
   deb(DEB_ENTER, 'redoNeeded');
   IF (rcvRecStackState.lowAction > 0 AND   -- Have a non-full_act_t on stack?
       action.toSCN_act <
       rcvRecStack(rcvRecStackState.lowAction).fromSCN_act) THEN
      deb(DEB_EXIT, 'with: TRUE');
      RETURN TRUE;
   ELSE
      deb(DEB_EXIT, 'with: FALSE');
      RETURN FALSE;
   END IF;
END redoNeeded;
 
--
FUNCTION canAddRedo(
   isAncestor    IN boolean
  ,from_scn      IN number
  ,from_rlgscn   IN number
  ,to_action     IN rcvRec_t
  ,partial_rcv   IN boolean
  ,doingRecovery IN boolean)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'canAddRedo');
   IF (from_rlgscn = this_reset_scn) THEN
      IF (partial_rcv) THEN
         deb(DEB_EXIT, 'with: action_OK');
         RETURN action_OK;
      ELSE
--
--
--
--
--
--
--
--
--
--
--
--
         deb(DEB_EXIT, 'with: action_FAIL');
         RETURN action_FAIL;
      END IF;
   ELSE
      deb(DEB_IN, 'from_rlgscn=' || nvl(to_char(from_rlgscn), 'NULL') ||
          ' this_reset_scn=' || to_char(this_reset_scn));
      IF (isAncestor) THEN
         deb(DEB_IN, 'isAncestor is TRUE;');
         IF (canApplyAnyRedo = TRUE# AND
             from_scn >=
               nvl(inc_list(max_inc_idx-1).prior_resetlogs_change#,
                   inc_list(max_inc_idx-1).resetlogs_change#)) THEN
            deb(DEB_PRINT, 'canAddRedo: return action_OLD_INC_REDO');
            return action_OLD_INC_REDO;
         ELSE
--
--
--
--
--
--
--
--
--
--
--
--
--
--
            IF (doingRecovery) THEN
              deb(DEB_PRINT, 'with: action_OLD_REDO (doingRecovery)');
              RETURN action_OLD_REDO;
            ELSIF (allIncarnations = TRUE#) THEN
              deb(DEB_PRINT, 'canAddRedo: returning action_OK');
              RETURN action_OK;
            ELSE
              deb(DEB_PRINT, 'canAddRedo: returning action_OLD_REDO');
              RETURN action_OLD_REDO;
            END IF;
         END IF;
      ELSE
         deb(DEB_IN, 'isAncestor is FALSE;');
--
--
         deb(DEB_EXIT, 'with: action_OLD_REDO');
         RETURN action_OLD_REDO;
      END IF;
   END IF;
   deb(DEB_EXIT, 'with undefined status');
END canAddRedo;
 
--
FUNCTION addRedo(
   isAncestor    IN boolean
  ,from_scn      IN number
  ,from_rlgscn   IN number
  ,to_action     IN rcvRec_t
  ,partial_rcv   IN boolean
  ,doingRecovery IN boolean)
RETURN number IS
   canAdd      number;
BEGIN
   deb(DEB_ENTER, 'addRedo');
   deb(DEB_IN,'Enter - from_scn=' || from_scn|| ',from_rlgscn=' ||from_rlgscn);
 
   canAdd := canAddRedo(isAncestor, from_scn, from_rlgscn,
                        to_action, partial_rcv, doingRecovery);
   IF (canAdd = action_FAIL) THEN
--
--
--
--
--
--
 
--
--
--
--
--
--
      rcvRecStackState.lowAction := 0;
 
      rcvRecStack.trim(rcvRecStack.last -
                       greatest(rcvRecStackState.savePoint,
                                rcvRecStackState.top));
 
      deb(DEB_IN,'trimming savepoint1, rcvRecStackCount='|| rcvRecStack.count);
      deb(DEB_EXIT, 'with: action_FAIL');
      RETURN action_FAIL;
   ELSIF (canAdd = action_OK) THEN
      redoRec.type_act          := redo_act_t;
      redoRec.fromSCN_act       := from_scn;
      redoRec.toSCN_act         := to_action.fromSCN_act;
      redoRec.toTime_act        := to_date(null);
      redoRec.rlgSCN_act        := from_rlgscn;
      redoRec.dfNumber_obj      := to_action.dfNumber_obj;
      redoRec.dfCreationSCN_obj := to_action.dfCreationSCN_obj;
      redoRec.pluginSCN_obj     := 0;
      redoRec.pluggedRonly_obj  := 0;
      rcvRecPush(redoRec);
 
      deb(DEB_EXIT, 'with: action_OK');
      RETURN action_OK;
   ELSIF (canAdd = action_OLD_INC_REDO) THEN
      redoRec.type_con          := addredo_con_t;
      redoRec.type_act          := redo_act_t;
      redoRec.fromSCN_act       := from_scn;
      redoRec.toSCN_act         := to_action.fromSCN_act;
      redoRec.toTime_act        := to_date(null);
      redoRec.rlgSCN_act        := from_rlgscn;
      redoRec.dfNumber_obj      := to_action.dfNumber_obj;
      redoRec.dfCreationSCN_obj := to_action.dfCreationSCN_obj;
      redoRec.pluginSCN_obj     := 0;
      redoRec.pluggedRonly_obj  := 0;
 
      deb(DEB_EXIT, 'with: action_OLD_INC_REDO');
      RETURN action_OLD_INC_REDO;
   ELSE                                         -- ancestral incarnation
--
--
--
--
      deb(DEB_EXIT, 'with: action_OLD_REDO');
      RETURN action_OLD_REDO;
   END IF;
   deb(DEB_EXIT, 'with undefined status');
END addRedo;
 
--
--
FUNCTION isPdbScnOrphan(fromSCN IN NUMBER,
                        toSCN   IN NUMBER,
                        afzSCN  IN NUMBER,
                        pdbId   IN NUMBER)
RETURN BOOLEAN IS
--
   l_afzSCN NUMBER := nvl(greatest(afzSCN, toSCN), toSCN);
BEGIN
   IF (pdb_inc_list.exists(pdbId)) THEN
      FOR inc_idx in 0..pdb_inc_list(pdbId).count-1 LOOP
         IF ((fromSCN = 0 OR
              fromSCN > pdb_inc_list(pdbId)(inc_idx).erscn) AND
             (l_afzSCN > pdb_inc_list(pdbId)(inc_idx).erscn)) THEN
            EXIT;
         END IF;
 
         IF ((fromSCN  >= pdb_inc_list(pdbId)(inc_idx).incscn AND
              fromSCN  <= pdb_inc_list(pdbId)(inc_idx).erscn) OR
             (l_afzSCN >= pdb_inc_list(pdbId)(inc_idx).incscn AND
              l_afzSCN <= pdb_inc_list(pdbId)(inc_idx).erscn)) THEN
            deb(DEB_PRINT, 'isPdbScnOrphan: inc=' || inc_idx||
                           ',fromSCN =' || fromSCN ||
                           ',toSCN ='   || toSCN   ||
                           ',afzSCN ='  || nvl(afzSCN, '')  ||
                           ',incSCN ='  ||
                           pdb_inc_list(pdbId)(inc_idx).incscn ||
                           ',erscn=' ||
                           pdb_inc_list(pdbId)(inc_idx).erscn);
            deb(DEB_PRINT, 'isPdbScnOrphan: belongs to orphan branch ' ||
                           'of this sub incarnation:');
            RETURN TRUE;
         END IF;
      END LOOP;
   END IF;
 
   RETURN FALSE;
END isPdbScnOrphan;
 
--
--
--
FUNCTION CheckRecAction(
   action   IN rcvRec_t
  ,pdbId    IN number
  ,cleanSCN IN number)
RETURN number IS
   rlgSCN   number;
   rlgTime  date;
   toSCN    number;
   fromSCN  number;
   afzSCN   number;
   creSCN   number;
BEGIN
 
  IF (canApplyAnyRedo = FALSE#) THEN
     return SUCCESS;
  END IF;
 
  IF (action.pluggedRonly_obj != 0) THEN
     deb(DEB_PRINT, 'CheckRecAction called for plugged readonly action');
 
     rlgSCN  := action.pluginRlgSCN_obj;
     rlgTime := action.pluginRlgTime_obj;
 
     toSCN   := action.pluginSCN_obj;
     fromSCN := action.pluginSCN_obj;
     creSCN  := action.pluginSCN_obj;
  ELSE
     rlgSCN  := action.rlgSCN_act;
     rlgTime := action.rlgTime_act;
 
     toSCN   := action.toSCN_act;
     fromSCN := action.fromSCN_act;
     afzSCN  := action.afzSCN_act;
     creSCN  := action.dfCreationSCN_obj;
  END IF;
 
  deb(DEB_PRINT, ' CheckRecAction called '||
                   to_char(rlgTime,'MM/DD/RR HH24:MI:SS')||
                  '; rlgscn='||rlgSCN || '; pdbId=' || pdbId ||
                  '; cleanscn=' || nvl(to_char(cleanSCN), 'NULL'));
 
  IF (action.type_con = backupSet_con_t OR
      action.type_con = imageCopy_con_t OR
      action.type_con = proxyCopy_con_t OR
      action.type_con = offlineRangeRec_con_t) THEN
    FOR inc_idx in 0..max_inc_idx-1 LOOP
      IF (rlgSCN = inc_list(inc_idx).resetlogs_change#  AND
          rlgTime = inc_list(inc_idx).resetlogs_time ) THEN
        IF (inc_idx = 0 OR
            toSCN <= inc_list(inc_idx-1).resetlogs_change#) THEN
           deb(DEB_PRINT, 'CheckRecAction:matches inc='||inc_idx||
                          ',fromscn='|| fromSCN ||
                          ',toscn='  || toSCN   ||
                          ',afzSCN=' || nvl(afzSCN, ''));
           IF (pdbId > 1 AND
               isPdbScnOrphan(fromSCN, toSCN, afzSCN, pdbId)) THEN
              return action_SKIP;
           ELSE
              return SUCCESS;
           END IF;
        ELSE
           deb(DEB_PRINT, 'CheckRecAction: inc='||inc_idx||
                          ',toscn='||toSCN||
                          ' exceeds '||inc_list(inc_idx-1).resetlogs_change#);
           deb(DEB_PRINT, 'CheckRecAction:belongs to orphan branch ' ||
                          'of this incarnation:');
           return action_SKIP;
        END IF;
      END IF;
    END LOOP;
 
    deb(DEB_PRINT, 'CheckRecAction:not known to incarnation table');
 
--
    IF (nvl(afzSCN,0) = 0 AND toSCN = cleanSCN) THEN
       deb(DEB_PRINT, 'CheckRecAction: ok because backup ckpscn eq cleanscn');
       return SUCCESS;
    END IF;
  ELSE
     return SUCCESS;
  END IF;
 
--
--
--
  return action_SKIP;
END CheckRecAction;
 
--
FUNCTION isValidAction(action  IN rcvRec_t)
RETURN boolean IS
valid boolean := TRUE;
BEGIN
   IF (bitand(action.type_con, getRA_containerMask) = 0) THEN
      deb(DEB_PRINT, 'isValidAction: skipping non-selected container type');
      deb(DEB_PRINT, 'isValidAction: Container type : '|| action.type_con);
      deb(DEB_PRINT, 'isValidAction: Container Mask : '|| getRA_containerMask);
      valid := FALSE;                           -- then skip this action
   ELSIF (bitand(action.type_act, getRA_actionMask) = 0) THEN
      deb(DEB_PRINT, 'isValidAction: skipping non-selected action type');
      deb(DEB_PRINT, 'isValidAction: Action type : '|| action.type_act);
      deb(DEB_PRINT, 'isValidAction: Action Mask : '|| getRA_actionMask);
      valid := FALSE;                           -- then skip this action
   ELSIF (bitand(action.type_con, deleted_con_t) > 0) THEN
      deb(DEB_PRINT, 'isValidAction: deleted action skipped:');
      valid := FALSE;                             -- then skip this action
--
   ELSIF (computeRA_allRecords = TRUE# AND
          restoreTag is not null AND
          bitand(action.type_con, tagMask_con_t) > 0 AND
          (action.tag_con <> restoreTag OR action.tag_con is null)) THEN
      deb(DEB_PRINT, 'isValidAction: tag mismatch - skipped:');
      valid := FALSE;                             -- then skip this action
--
--
   ELSIF (getRA_completedAfter IS NOT NULL AND
          action.compTime_con < getRA_completedAfter) THEN
      deb(DEB_PRINT, 'isValidAction: compTime < completedAfter - skipped:');
      valid := FALSE;                             -- then skip this action
--
   ELSIF (getRA_completedBefore IS NOT NULL AND
          action.compTime_con > getRA_completedBefore) THEN
      deb(DEB_PRINT, 'isValidAction: compTime > completedBefore - skipped:');
      valid := FALSE;
--
   ELSIF (getRA_likePattern IS NOT NULL AND
          action.fileName_con NOT LIKE getRA_likePattern) THEN
      deb(DEB_PRINT, 'isValidAction: LikePattern not matched - skipped:');
      valid := FALSE;
   END IF;
 
   RETURN valid;
END isValidAction;
 
--
PROCEDURE resetrcvRecStack IS
BEGIN
   IF (rcvRecStack.count > 0) THEN
      rcvRecStack.trim(rcvRecStack.count);
   END IF;
 
   rcvRecStackState.lowAction   := 0;
   rcvRecStackState.savePoint   := 0;
   rcvRecStackState.fullBackups := 0;
   rcvRecStackState.top         := 0;
END resetrcvRecStack;
 
--
--
--
--
--
--
--
--
PROCEDURE fetchCursor1RecoveryAction(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,opcode        IN     binary_integer  -- 1 => seeknext, 2 => seekcurrent
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer  -- 1 => readonly, 0 => readwrite
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date
  ,rmanCmd       IN     binary_integer)
IS
  action    rcvRec_t;
  actCreSCN number;
  inpCreSCN number;
BEGIN
   deb(DEB_ENTER, 'fetchCursor1RecoveryAction');
   deb(DEB_IN, 'opcode=' || to_char(opcode));
 
--
   IF (rcvRecCursor1_c%NOTFOUND) THEN
      rcvRecCursor.currc1.type_con := to_number(null);
      deb(DEB_EXIT, 'no more records');
      RETURN;
   END IF;
 
   IF (pluginSCN != 0) THEN
      inpCreSCN := pluginSCN;
   ELSE
      inpCreSCN := creSCN;
   END IF;
 
--
   IF (opcode = 1) THEN
      goto seekNext;
   ELSIF (opcode = 2) THEN
      goto seekCurrent;
   ELSE
      raise_application_error(-20999, 'fetchCursor1RecoveryAction - 1');
   END IF;
 
--
<<seekNext>>
   deb(DEB_IN, 'seekNext');
   LOOP
      rcvRecCursor.currc1.type_con := to_number(null);
      FETCH rcvRecCursor1_c INTO rcvRecCursor.currc1;
      IF (rcvRecCursor1_c%NOTFOUND) THEN
         rcvRecCursor.currc1.type_con := to_number(null);
         deb(DEB_IN, 'no more records');
         EXIT;
      END IF;
      
--
      IF (rcvRecCursor.currc1.pluggedRonly_obj = 1) THEN
         deb(DEB_IN, 'rcvRecCursor1_c plugged read only object');
         deb(DEB_IN, 'adjust toSCN ' || rcvRecCursor.currc1.toSCN_act ||
             ' to pluginSCN ' || rcvRecCursor.currc1.pluginSCN_obj);
         rcvRecCursor.currc1.toSCN_act := rcvRecCursor.currc1.pluginSCN_obj;
      END IF;
 
      IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
         actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
      ELSE
         actCreSCN := rcvRecCursor.currc1.dfCreationSCN_obj;
      END IF;
      deb(DEB_IN, 'rcvRecCursor1_c record');
      printRcvRec(rcvRecCursor.currc1);
      IF (rcvRecCursor.currc1.dfNumber_obj > fno           OR
          (rcvRecCursor.currc1.dfNumber_obj = fno AND
           actCreSCN > inpCreSCN)                          OR
          (rcvRecCursor.currc1.dfNumber_obj = fno AND
           actCreSCN = inpCreSCN)) THEN
--
--
         EXIT;
      END IF;
      IF (debug) THEN
         deb(DEB_IN, 'skipped following record: summary');
         printRcvRec(rcvRecCursor.currc1, TRUE);
      END IF;
   END LOOP;
 
<<seekCurrent>>
   IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
      actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
   ELSE
      actCreScN := rcvRecCursor.currc1.dfCreationSCN_obj;
   END IF;
 
   IF (rcvRecCursor.currc1.type_con is null         OR
       rcvRecCursor.currc1.dfNumber_obj > fno       OR
       (rcvRecCursor.currc1.dfNumber_obj = fno AND
        actCreSCN > inpCreSCN)) THEN
      deb(DEB_EXIT, 'seekCurrent - beyond current fno, creSCN');
      RETURN;
   END IF;
 
   IF (rcvRecCursor.currc1.dfNumber_obj != fno OR
       actCreSCN != inpCreSCN) THEN
      raise_application_error(-20999, 'fetchCursor1RecoveryAction ' ||
               'dfNumber_obj=' || to_char(rcvRecCursor.currc1.dfNumber_obj) ||
               ' dfCreationSCN_obj=' || to_char(actCreSCN));
   END IF;
 
--
--
   IF (rmanCmd = blkRestoreCmd_t) THEN
      IF (rcvRecCursor.currc1.toSCN_act > targetSCN) THEN
         deb(DEB_IN, 'a. simple filter rejected - trying next');
         goto seekNext;
      END IF;
   ELSE
      IF (rcvRecCursor.currc1.toSCN_act < dfCkpSCN AND
          rcvRecCursor.currc1.fromSCN_act < dfCkpSCN) THEN
         deb(DEB_IN, 'b. simple filter rejected - trying next');
         goto seekNext;
      END IF;
   END IF;
 
--
   OPEN rcvRecCursor1Filter_c( dbincKey        => dbincKey
                              ,fno             => fno
                              ,creSCN          => creSCN
                              ,dfCkpSCN        => dfCkpSCN
                              ,dbincRlgSCN     => dbincRlgSCN
                              ,dbincRlgTime    => dbincRlgTime
                              ,offlSCN         => offlSCN
                              ,onlSCN          => onlSCN
                              ,onlTime         => onlTime
                              ,cleanSCN        => cleanSCN
                              ,clean2SCN       => clean2SCN
                              ,clean2Time      => clean2Time
                              ,targetSCN       => targetSCN
                              ,c1rec           => rcvRecCursor.currc1
                              ,foreignDbid     => foreignDbid
                              ,pluggedRonly    => pluggedRonly
                              ,pluginSCN       => pluginSCN
                              ,pluginRlgSCN    => pluginRlgSCN
                              ,pluginRlgTime   => pluginRlgTime
                              ,rmanCmd         => rmanCmd);
    FETCH rcvRecCursor1Filter_c INTO action;
    IF (rcvRecCursor1Filter_c%NOTFOUND) THEN
--
       CLOSE rcvRecCursor1Filter_c;
       deb(DEB_IN, 'real filter rejected - trying next');
       goto seekNext;
    END IF;
    CLOSE rcvRecCursor1Filter_c;
    deb(DEB_EXIT, 'filter accepted');
END fetchCursor1RecoveryAction;
 
--
FUNCTION fetchRecoveryAction(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,action        IN OUT NOCOPY rcvRec_t
  ,rmanCmd       IN     binary_integer
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer  -- 1 => readonly, 0 => readwrite
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date)
RETURN boolean IS
   top             rcvRec_t;
   c1frec          rcvRec_t;       -- filtered cursor1 record
   actCreSCN       number;
   inpCreSCN       number;
   actRlgSCN       number;
   topRlgSCN       number;
BEGIN
   deb(DEB_ENTER, 'fetchRecoveryAction');
 
   IF (pluginSCN != 0) THEN
      inpCreSCN := pluginSCN;
   ELSE
      inpCreSCN := creSCN;
   END IF;
 
   <<retry>>
   IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
      actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
   ELSE
      actCreSCN := rcvRecCursor.currc1.dfCreationSCN_obj;
   END IF;
 
   IF (rcvRecCursor.currc1.type_con is null          OR
       rcvRecCursor.currc1.dfNumber_obj != fno       OR
       actCreSCN != inpCreSCN) THEN
      c1frec.type_con := to_number(null);
   ELSE
      c1frec := rcvRecCursor.currc1;
   END IF;
 
   OPEN rcvRecCursor2_c( dbincKey        => dbincKey
                        ,fno             => fno
                        ,creSCN          => creSCN
                        ,dfCkpSCN        => dfCkpSCN
                        ,dbincRlgSCN     => dbincRlgSCN
                        ,dbincRlgTime    => dbincRlgTime
                        ,offlSCN         => offlSCN
                        ,onlSCN          => onlSCN
                        ,onlTime         => onlTime
                        ,cleanSCN        => cleanSCN
                        ,clean2SCN       => clean2SCN
                        ,clean2Time      => clean2Time
                        ,targetSCN       => targetSCN
                        ,c1frec          => c1frec
                        ,excludeAction   => rcvRecCursor.excludeAction
                        ,foreignDbid     => foreignDbid
                        ,pluggedRonly    => pluggedRonly
                        ,pluginSCN       => pluginSCN
                        ,pluginRlgSCN    => pluginRlgSCN
                        ,pluginRlgTime   => pluginRlgTime);
 
   FETCH rcvRecCursor2_c INTO action;
 
   IF (rcvRecCursor2_c%NOTFOUND) THEN
      action.type_con := NULL;
      action.type_act := NULL;
      CLOSE rcvRecCursor2_c;
      deb(DEB_EXIT, 'no_data_found with: FALSE');
      RETURN FALSE;
   END IF;
 
   IF (action.type_act = spanningRange_act_t  OR
       action.type_act = cleanRange_act_t     OR
       action.type_act = implicitRange_act_t)  THEN
--
      rcvRecCursor.excludeAction :=
                              rcvRecCursor.excludeAction + action.type_act;
   ELSE
--
      fetchCursor1RecoveryAction(
         dbincKey      => dbincKey
        ,fno           => fno
        ,creSCN        => creSCN
        ,dfCkpSCN      => dfCkpSCN
        ,dbincRlgSCN   => dbincRlgSCN
        ,dbincRlgTime  => dbincRlgTime
        ,offlSCN       => offlSCN
        ,onlSCN        => onlSCN
        ,onlTime       => onlTime
        ,cleanSCN      => cleanSCN
        ,clean2SCN     => clean2SCN
        ,clean2Time    => clean2Time
        ,targetSCN     => targetSCN
        ,opcode        => 1
        ,foreignDbid   => foreignDbid
        ,pluggedRonly  => pluggedRonly
        ,pluginSCN     => pluginSCN
        ,pluginRlgSCN  => pluginRlgSCN
        ,pluginRlgTime => pluginRlgTime
        ,rmanCmd       => rmanCmd);
   END IF;
 
   IF (action.compTime_con IS NULL AND          -- was null in 8.0.2
       action.type_con = backupSet_con_t) THEN
      action.compTime_con := stamp2date(action.bsStamp_con);
   END IF;
 
   IF (rmanCmd = obsoleteCmd_t AND action.type_act = incremental_act_t) THEN
      deb(DEB_PRINT, 'fetchRecoveryAction: incr backup set for obsolete cmd');
   ELSE
      IF (computeRA_allRecords = TRUE#) THEN
         CLOSE rcvRecCursor2_c;
         deb(DEB_EXIT, 'with TRUE');
         RETURN TRUE;
      END IF;
 
      IF (computeRA_fullBackups > 1) THEN
         CLOSE rcvRecCursor2_c;
         deb(DEB_EXIT, 'with TRUE');
         RETURN TRUE;
      END IF;
   END IF;
 
--
--
--
--
--
   IF (rcvRecStack.count > 0) THEN
      rcvRecTop(top);
      IF (action.pluginSCN_obj != 0) THEN
         actRlgSCN := action.pluginRlgSCN_obj;
      ELSE
         actRlgSCN := action.rlgSCN_act;
      END IF;
      IF (top.pluginSCN_obj != 0) THEN
         topRlgSCN := top.pluginRlgSCN_obj;
      ELSE
         topRlgSCN := top.rlgSCN_act;
      END IF;
      IF (not (action.fromSCN_act < top.fromSCN_act) AND
          actrlgSCN = toprlgSCN) THEN
         IF (debug) THEN
            deb(DEB_IN, 'discarding this action:');
            printRcvRec(action);
         END IF;
         CLOSE rcvRecCursor2_c;
         GOTO retry;
      END IF;
   END IF;
 
   CLOSE rcvRecCursor2_c;
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE;
END fetchRecoveryAction;
 
--
PROCEDURE openRecoveryActionCursor(
   dbincKey      IN     number
  ,fno           IN     number
  ,creSCN        IN     number
  ,dfCkpSCN      IN     number
  ,dbincRlgSCN   IN     number
  ,dbincRlgTime  IN     date
  ,offlSCN       IN     number
  ,onlSCN        IN     number
  ,onlTime       IN     date
  ,cleanSCN      IN     number
  ,clean2SCN     IN     number
  ,clean2Time    IN     date
  ,targetSCN     IN     number
  ,rmanCmd       IN     binary_integer
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date)
IS
  openCursor1   boolean := FALSE;     -- TRUE if cursor1 is to be opened
  opcode        binary_integer := 0;  -- seekNext or seekCurrent
  reqCreSCN     number;
  inpCreSCN     number;
  actCreSCN     number;
BEGIN
   deb(DEB_ENTER, 'openRecoveryActionCursor');
 
   IF (pluginSCN != 0) THEN
      inpCreSCN := pluginSCN;
   ELSE
      inpCreSCN := creSCN;
   END IF;
 
   deb(DEB_IN,'target scn is ' ||
       nvl(to_char(targetSCN), 'NULL') || ',creSCN=' || creSCN ||
       ',dfCkpSCN=' || dfCkpSCN || ',dbincRlgSCN=' || dbincRlgSCN ||
       ',offlSCN=' || offlSCN || ',onlSCN=' || onlSCN ||
       ',cleanSCN=' || cleanSCN || ',clean2SCN=' || clean2SCN ||
       ',fno=' || fno || ',pluginSCN=' || pluginSCN ||
       ',rmanCmd=' || rmanCmd);
 
   deb(DEB_IN, 'currc1.type_con=' ||
               nvl(to_char(rcvRecCursor.currc1.type_con),'NULL') ||
               ' currc1.fno=' ||
               nvl(to_char(rcvRecCursor.currc1.dfNumber_obj), 'NULL') ||
               ' currc1.crescn=' ||
               nvl(to_char(rcvRecCursor.currc1.dfCreationSCN_obj), 'NULL'));
 
   deb(DEB_IN, 'restoreSource=' || restoreSource ||
               ', restoreSparse='|| restoreSparse);
 
   IF (rcvRecCursor1_c%ISOPEN) THEN
      deb(DEB_IN, 'cursor1 already open');
      IF (tc_database = TRUE# OR isTranslatedFno(fno) = TRUE#) THEN
         deb(DEB_IN,'cursor1 translated');
         IF (rcvRecCursor.reqpluginSCN != 0) THEN
            reqCreSCN := rcvRecCursor.reqpluginSCN;
         ELSE
            reqCreSCN := rcvRecCursor.reqcrescn;
         END IF;
         IF (rcvRecCursor.currc1.pluginSCN_obj != 0) THEN
            actCreSCN := rcvRecCursor.currc1.pluginSCN_obj;
         ELSE
            actCreSCN := rcvRecCursor.currc1.dfCreationSCN_obj;
         END IF;
         IF ((rcvRecCursor.reqfno = fno AND reqCreSCN >= inpCreSCN) OR
             (rcvRecCursor.reqfno > fno)) THEN
--
--
            deb(DEB_IN, 'cursor1 unusable');
            openCursor1 := TRUE;
         ELSIF (rcvRecCursor.currc1.type_con is null    OR
                rcvRecCursor.currc1.dfNumber_obj < fno  OR
                (rcvRecCursor.currc1.dfNumber_obj = fno AND
                 actCreSCN < inpCreSCN)) THEN
               deb(DEB_IN,'reusing cursor1 after seek');
               opcode := 1; -- seekNext
         ELSIF (rcvRecCursor.currc1.dfNumber_obj = fno AND
                actCreSCN = inpCreSCN) THEN
            deb(DEB_IN,'reusing cursor1 with no seek');
            opcode := 2; -- seekCurrent
         ELSE
            deb(DEB_IN,'do nothing to cursor1');
         END IF;
      ELSE
         deb(DEB_IN,'cursor1 did not translate');
         openCursor1 := TRUE;
      END IF;
   ELSE
      deb(DEB_IN,'cursor1 not open yet');
      openCursor1 := TRUE;
   END IF;
 
   IF (openCursor1) THEN
      IF (rcvRecCursor1_c%ISOPEN) THEN
         CLOSE rcvRecCursor1_c;
      END IF;
 
      setDfTransClause(fno => fno);
      rcvRecCursor.currc1.type_con := to_number(null);
      deb(DEB_OPEN, 'rcvRecCursor1_c');
      OPEN rcvRecCursor1_c(rmanCmd => rmanCmd);
      opcode := 1;  -- seekNext
   END IF;
 
--
   IF (opcode != 0) THEN
      fetchCursor1RecoveryAction(
         dbincKey      => dbincKey
        ,fno           => fno
        ,creSCN        => creSCN
        ,dfCkpSCN      => dfCkpSCN
        ,dbincRlgSCN   => dbincRlgSCN
        ,dbincRlgTime  => dbincRlgTime
        ,offlSCN       => offlSCN
        ,onlSCN        => onlSCN
        ,onlTime       => onlTime
        ,cleanSCN      => cleanSCN
        ,clean2SCN     => clean2SCN
        ,clean2Time    => clean2Time
        ,targetSCN     => targetSCN
        ,opcode        => opcode
        ,foreignDbid   => foreignDbid
        ,pluggedRonly  => pluggedRonly
        ,pluginSCN     => pluginSCN
        ,pluginRlgSCN  => pluginRlgSCN
        ,pluginRlgTime => pluginRlgTime
        ,rmanCmd       => rmanCmd);
   END IF;
 
--
   rcvRecCursor.excludeAction := 0;
 
--
   rcvRecCursor.reqfno := fno;
   rcvRecCursor.reqcrescn := creSCN;
   rcvRecCursor.reqpluginSCN := pluginSCN;
 
--
   IF (rcvRecCursor1Filter_c%ISOPEN) THEN
      CLOSE rcvRecCursor1Filter_c;
   END IF;
 
   IF (rcvRecCursor2_c%ISOPEN) THEN
      CLOSE rcvRecCursor2_c;
   END IF;
 
   deb(DEB_EXIT);
END openRecoveryActionCursor;
 
--
 
FUNCTION trimRecoveryActions(
   maxActions           IN number
  ,containerMask        IN number
  ,actionMask           IN number)
RETURN NUMBER IS
   dummy     rcvRec_t;
   remaining number;
BEGIN
 
   deb(DEB_ENTER,'trimRecoveryActions[function](maxactions='||maxActions||')');
   IF (rcvRecStack.count > 0) THEN
      rcvRecPop(dummy);
      remaining := trimRecoveryActions(maxActions, containerMask, actionMask);
 
--
--
--
--
--
--
      IF ((bitand(dummy.type_con, containerMask) = 0) OR
           (bitand(dummy.type_act, actionMask) = 0)) THEN
--
--
         rcvRecPush(dummy);
         deb(DEB_EXIT, 'with: '||to_char(remaining));
         RETURN remaining;
      ELSE
         IF (remaining < maxActions) THEN
            rcvRecPush(dummy);          -- put back on stack
            deb(DEB_EXIT, 'with: '||to_char(remaining+1));
            RETURN remaining + 1;
         ELSE
--
            IF (debug) THEN
               deb(DEB_IN, 'deleting action:');
               printRcvRec(dummy);
               deb(DEB_EXIT, 'with: '||to_char(remaining));
            END IF;
 
            RETURN remaining;
         END IF;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with: 0');
      RETURN 0;
   END IF;
END trimRecoveryActions;
 
--
PROCEDURE setCraGetAllCfBackups(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'craGetAllCfBackups is set to TRUE');
      craGetAllCfBackups := TRUE#;
   ELSE
      deb(DEB_PRINT, 'craGetAllCfBackups is set to FALSE');
      craGetAllCfBackups := FALSE#;
   END IF;
END setCraGetAllCfBackups;
 
--
--
FUNCTION isTranslatedArchivedLog(
   thread#   IN  number
  ,sequence# IN  number) RETURN BOOLEAN
IS
  thrbck   binary_integer;
  seqbck   binary_integer;
BEGIN
--
   IF (thread# >= CONST2GVAL) THEN
      thrbck := CONST2GVAL - thread#;
   ELSE
      thrbck := thread#;
   END IF;
 
--
   IF (sequence# >= CONST2GVAL) THEN
      seqbck := CONST2GVAL - sequence#;
   ELSE
      seqbck := sequence#;
   END IF;
 
   IF NOT tc_threadSeq.exists(thrbck) THEN
      RETURN FALSE;
   ELSIF NOT tc_threadSeq(thrbck).exists(seqbck) THEN
      RETURN FALSE;
   ELSE
      RETURN TRUE;
   END IF;
END isTranslatedArchivedLog;
 
--
FUNCTION getRangeArchivedLogBackup(
   rcvRec  OUT NOCOPY rcvRec_t)
RETURN binary_integer IS
   local        rcvRec_t;
   BSstatus     number;
BEGIN
   deb(DEB_ENTER, 'getRangeArchivedLogBackup');
 
   IF (getRecStackCount = 0) THEN
--
--
      deb(DEB_EXIT, 'with: UNAVAILABLE');
      RETURN UNAVAILABLE;
   END IF;
 
   rcvRecPop(local);
--
--
   IF (local.status_con = '*') THEN
      local.status_con := 'A';
      BSstatus := AVAILABLE;
   ELSE
      BSstatus := SUCCESS;
   END IF;
 
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   IF (BSstatus = AVAILABLE) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
      RETURN AVAILABLE;
   ELSE
      deb(DEB_EXIT, 'with: SUCCESS');
      RETURN SUCCESS;
   END IF;
END getRangeArchivedLogBackup;
 
--
--
FUNCTION startWithPattern(
   toDest IN varchar2) RETURN VARCHAR2
IS
BEGIN
   IF (toDest IS NULL) THEN
      RETURN NULL;
   END IF;
 
   RETURN toDest || '%';
END startWithPattern;
 
 
--
--
PROCEDURE extendKeepSCN(lbDfRec    IN OUT NOCOPY lbDfRec_t,
                        toSCN      IN            number,
                        rlgSCN     IN            number,
                        extendMask IN            binary_integer,
                        force      IN            boolean,
                        dbgcomment IN            varchar2)
IS
BEGIN
   IF (bitand(extendMask, extendFullSCN) != 0) THEN
      IF (force OR toSCN < lbDfRec.fullmin_scn) THEN
         lbDfRec.fullmin_scn    := toSCN;
         lbDfRec.fullmin_rlgscn := rlgSCN;
         IF (debug) THEN
            deb(DEB_PRINT, dbgcomment || ': Extending fullmin_scn to '    ||
                to_char(toSCN));
            deb(DEB_PRINT, dbgcomment || ': Extending fullmin_rlgscn to ' ||
                nvl(to_char(rlgSCN), 'null'));
         END IF;
      END IF;
   END IF;
 
   IF (bitand(extendMask, extendIncrSCN) != 0) THEN
      IF (force OR toSCN < lbDfRec.incrmin_scn) THEN
         lbDfRec.incrmin_scn    := toSCN;
         lbDfRec.incrmin_rlgscn := rlgSCN;
         IF (debug) THEN
            deb(DEB_PRINT, dbgcomment || ': Extending incrmin_scn to '    || 
                to_char(toSCN));
            deb(DEB_PRINT, dbgcomment || ': Extending incrmin_rlgscn to ' || 
                nvl(to_char(rlgSCN), 'null'));
         END IF;
      END IF;
   END IF;
 
   IF (bitand(extendMask, extendLogSCN) != 0) THEN
      IF (force OR toSCN < lbDfRec.logmin_scn) THEN
         lbDfRec.logmin_scn    := toSCN;
         lbDfRec.logmin_rlgscn := rlgSCN;
         IF (debug) THEN
            deb(DEB_PRINT, dbgcomment || ': Extending logmin_scn to '    || 
                to_char(toSCN));
            deb(DEB_PRINT, dbgcomment || ': Extending logmin_rlgscn to ' || 
                nvl(to_char(rlgSCN), 'null'));
         END IF;
      END IF;
   END IF;
END extendKeepSCN;
 
--
PROCEDURE resetPdbNameList IS
BEGIN
   pdbNameList.delete;
END resetPdbNameList;
 
--
PROCEDURE initPdbNameList IS
   local    pdbNameRec_t;
BEGIN
   IF (pdbNameList.count != 0) THEN
      RETURN;
   END IF;
 
   IF (translatePdbName_c%ISOPEN) THEN
      raise_application_error(-20203, 'Translation already started');
   END IF;
 
   resetPdbNameList;
   OPEN translatePdbName_c;
 
<<nextRow>>
   FETCH translatePdbName_c INTO local;
   IF translatePdbName_c%NOTFOUND THEN
      CLOSE translatePdbName_c;
   ELSE
      pdbNameList(local.name) := local.pdbId;
      goto nextRow;
   END IF;
 
   pdbNameList(cdbRoot_txt) := 1;
END initPdbNameList;
 
--
PROCEDURE resetPdbFileList IS
BEGIN
   pdbFileList.delete;
END resetPdbFileList;
 
--
PROCEDURE initPdbFileList IS
   local    pdbFileRec_t;
BEGIN
   IF (pdbFileList.count != 0) THEN
      RETURN;
   END IF;
 
   IF (translatePdbFile_c%ISOPEN) THEN
      raise_application_error(-20203, 'Translation already started');
   END IF;
 
   deb(DEB_PRINT, 'initPdbFileList');
   resetPdbFileList;
   OPEN translatePdbFile_c(
          fromSCN => nvl(untilSCN, MAXSCNVAL),
          toSCN   => nvl(untilSCN, MAXSCNVAL));
 
<<nextRow>>
   FETCH translatePdbFile_c INTO local;
   IF translatePdbFile_c%NOTFOUND THEN
      CLOSE translatePdbFile_c;
   ELSE
      pdbFileList(local.file#) := local;
      goto nextRow;
   END IF;
 
   local.file#    := 0;
   local.pdbId    := 0;
   local.stopSCN  := null;
   pdbFileList(0) := local;
END initPdbFileList;
 
--
FUNCTION translatePdbFile(
   file#    IN  NUMBER
  ,cleanSCN OUT NUMBER)
RETURN NUMBER IS
   local  pdbFileRec_t;
BEGIN
   initPdbFileList;
 
   IF (pdbFileList.exists(file#)) THEN
      local    := pdbFileList(file#);
      cleanSCN := local.stopSCN;
   ELSE
      deb(DEB_PRINT, 'translatePdbFile could not find file# ' || file#);
      IF (NOT pdbFileList.exists(1)) THEN
         raise_application_error(-20999, 'internal error: translatePdbFile');
      END IF;
      local    := pdbFileList(1);
      cleanSCN := NULL;
   END IF;
   RETURN local.pdbId;
END translatePdbFile;
 
--
 
--
PROCEDURE resetBsRecCache(
   reload  IN boolean)
IS
BEGIN
   BEGIN
      deb(DEB_PRINT, '*****BsRecCache Statistics*****');
      deb(DEB_PRINT, 'Cache size=' || to_char(cacheBsRecTable.bsRec.count) ||
                      ' hit=' || to_char(cacheBsRecTable.chit));
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_PRINT, 'No statistics available');
   END;
 
   cacheBsRecTable.bsRec.delete;
   IF (NOT reload) THEN
      cacheBsRecTable.hitlist.delete;
      cacheBsRecTable.hitindex := 1;
      cacheBsRecTable.hint := noHint;
   END IF;
   cacheBSRecTable.chit := 0;
   cacheBsRecTable.mixcopy := FALSE;
   cacheBsRecTable.minbskey := 0;
END resetBsRecCache;
 
--
FUNCTION setCachedDeviceType(
   type IN varchar2)
RETURN binary_integer IS
BEGIN
   FOR i IN 1..cacheBsRecTable.devicecount LOOP
      IF cacheBsRecTable.devicelist(i) = type THEN
         RETURN i;
      END IF;
   END LOOP;
   cacheBsRecTable.devicecount := cacheBsRecTable.devicecount + 1;
   cacheBsRecTable.devicelist(cacheBsRecTable.devicecount) := type;
   RETURN cacheBsRecTable.devicecount;
END setCachedDeviceType;
 
 
--
PROCEDURE lkBsRecCache(
   bskey           IN    number
  ,icopy           IN    binary_integer
  ,bsrec           OUT   NOCOPY cacheBsRecRow_t)
IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   BEGIN
      FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
         IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
            bsrec := cacheBsRecTable.bsRec(sb4_bucket).bslist(i).copy(icopy);
            RETURN;
         END IF;
      END LOOP;
   EXCEPTION
      WHEN no_data_found THEN
         NULL;
   END;
 
   RAISE no_data_found;
END lkBsRecCache;
 
--
FUNCTION addKeyToBsRecCache(
   bskey           IN number)
RETURN BOOLEAN IS
   bsk             cacheBsRecBsKey_t;
   bslist          cacheBsRecHash_t;
   bucket          number;
   sb4_bucket      binary_integer;
   bsindex         binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
--
   IF (cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
         IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
            RETURN FALSE;
         END IF;
      END LOOP;
      bsindex := cacheBsRecTable.bsRec(sb4_bucket).bsindex;
   ELSE
      cacheBsRecTable.bsRec(sb4_bucket) := bsk;
      bsindex := cacheBsRecTable.bsRec(sb4_bucket).bsindex;
      cacheBsRecTable.bsRec(sb4_bucket).bslist(bsindex) := bslist;
   END IF;
 
--
   cacheBsRecTable.bsRec(sb4_bucket).bslist(bsindex).bskey := bskey;
   cacheBsRecTable.bsRec(sb4_bucket).bsindex := bsindex + 1;
   RETURN TRUE;
END addKeyToBsRecCache;
 
--
PROCEDURE addToBsRecCache(
   bskey           IN number
  ,icopy           IN binary_integer
  ,deviceindx      IN binary_integer
  ,tag             IN varchar2
  ,copyNumber      IN binary_integer
  ,code            IN binary_integer)
IS
   bsrec           cacheBsRecRow_t;
   bucket          number;
   sb4_bucket      binary_integer;
   bsindex         binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   bsrec.deviceindx := deviceindx;
   bsrec.tag := tag;
   bsrec.copyNumber := copyNumber;
   bsrec.code := code;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      raise_application_error(-20999, 'internal error: addToBsRecCache1');
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
         cacheBsRecTable.bsRec(sb4_bucket).bslist(i).copy(icopy) := bsrec;
         RETURN;
      END IF;
   END LOOP;
 
--
   raise_application_error(-20999, 'internal error: addToBsRecCache2');
END addToBsRecCache;
 
--
FUNCTION hitBsRecCache(
   bskey       IN   number
  ,deviceType  IN   varchar2
  ,tag         IN   varchar2
  ,mask        IN   binary_integer)
RETURN BOOLEAN IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
--
   IF (deviceType != cacheBsRecTable.deviceType AND
       (deviceType IS NOT NULL OR
        cacheBsRecTable.deviceType IS NOT NULL)) THEN
      RETURN FALSE;
   END IF;
 
--
   IF (nvl(tag, '  ') != nvl(cacheBsRecTable.tag, nvl(tag, '  '))) THEN
      RETURN FALSE;
   END IF;
 
--
   IF (mask != cacheBsRecTable.mask) THEN
      RETURN FALSE;
   END IF;
 
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      IF (bskey < cacheBsRecTable.minbskey) THEN
--
--
--
--
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
          cacheBsRecTable.chit := cacheBsRecTable.chit + 1;
--
         IF (cacheBsRecTable.hitindex > bsRecCacheLowLimit * 0.25) THEN
             cacheBsRecTable.hitindex := 1;
         END IF;
 
--
         cacheBsRecTable.hitlist(cacheBsRecTable.hitindex) := bskey;
         cacheBsRecTable.hitindex := cacheBsRecTable.hitindex + 1;
         RETURN TRUE;
      END IF;
   END LOOP;
 
   RETURN FALSE;
END hitBsRecCache;
 
--
FUNCTION canMixCopy(
   bskey IN   number)
RETURN BOOLEAN IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
   bucket := mod(bskey, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      raise_application_error(-20999, 'internal error: canMixCopy1');
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = bskey) THEN
         RETURN cacheBsRecTable.bsRec(sb4_bucket).bslist(i).mixCopy;
      END IF;
   END LOOP;
 
   raise_application_error(-20999, 'internal error: canMixCopy2');
END canMixCopy;
 
--
PROCEDURE loadBsRecCache(
   from_bsRec  IN   rcvRec_t
  ,deviceType  IN   varchar2 DEFAULT NULL
  ,tag         IN   varchar2 DEFAULT NULL
  ,mask        IN   binary_integer
  ,mixcopy     IN   number)
IS
--
--
--
--
--
--
 
--
--
 
--
--
--
--
--
--
--
 
   CURSOR loadBsRecCache_c IS
      SELECT bs.bs_key                             bskey,
             bp.device_type                        deviceType,
             bp.tag                                tag,
             bp.copy#                              copyNumber,
             1                                     code,
             decode(bp.ba_access, 'R', 3, 'T', 2, nvl2(vb_key, 1, 0))
                                                   order1,
             bs.pieces                             pieces
        FROM bp, bs
      WHERE loadBsRecCache.mixcopy = FALSE#
        AND bs.db_key = this_db_key
        AND bp.db_key = this_db_key
        AND bp.status != 'D'
        AND bp.bs_key = bs.bs_key
        AND isBsRecCacheMatch(bs.bs_key, bp.device_type, bp.tag,
                              bp.status) = TRUE#  -- See NOTE
        AND ((user_site_key = bp.site_key) OR
             (user_site_key IS NULL AND
              ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
               (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
               (this_site_key = nvl(bp.site_key, this_site_key)))))
    GROUP BY bs.bs_key, bs.pieces, bp.device_type, bp.tag, bp.copy#,
             bp.ba_access, bp.vb_key
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = bs.pieces) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= bs.pieces))
 
    UNION ALL
 
--
--
--
 
      SELECT bs.bs_key                             bskey,
             bp.device_type                        deviceType,
             bp.tag                                tag,
             to_number(null)                       copyNumber,
             2                                     code,
             0                                     order1,
             bs.pieces                             pieces
       FROM bp, bs
      WHERE loadBsRecCache.mixcopy = TRUE#
        AND bs.db_key = this_db_key
        AND bp.db_key = this_db_key
        AND bp.status != 'D'
        AND bp.bs_key = bs.bs_key
        AND isBsRecCacheMatch(bs.bs_key, bp.device_type, bp.tag,
                              bp.status) = TRUE#  -- See NOTE
        AND ((user_site_key = bp.site_key) OR
             (user_site_key IS NULL AND
              ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
               (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
               (this_site_key = nvl(bp.site_key, this_site_key)))))
    GROUP BY bs.bs_key, bs.pieces, bp.device_type, bp.tag
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = bs.pieces) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= bs.pieces))
 
    UNION ALL
 
--
--
--
 
      SELECT bs.bs_key                             bskey,
             bp.device_type                        deviceType,
             to_char(null)                         tag,
             to_number(null)                       copyNumber,
             3                                     code,
             0                                     order1,
             bs.pieces                             pieces
       FROM bp, bs
      WHERE loadBsRecCache.mixcopy = TRUE#
        AND bs.db_key = this_db_key
        AND bp.db_key = this_db_key
        AND bp.status != 'D'
        AND bp.bs_key = bs.bs_key
        AND isBsRecCacheMatch(bs.bs_key, bp.device_type, bp.tag,
                              bp.status) = TRUE#  -- See NOTE
        AND ((user_site_key = bp.site_key) OR
             (user_site_key IS NULL AND
              ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
               (tape_backups_shared = TRUE# AND bp.device_type <> 'DISK') OR
               (this_site_key = nvl(bp.site_key, this_site_key)))))
    GROUP BY bs.bs_key, bs.pieces, bp.device_type, bp.ba_access, bp.vb_key
   HAVING ((bitand(mask, dbms_rcvman.BSpartial_avail) = 0 AND
            count(DISTINCT piece#) = bs.pieces) OR
           (bitand(mask, dbms_rcvman.BSpartial_avail) <> 0 AND
            count(DISTINCT piece#) <= bs.pieces))
 
   ORDER BY 1,       -- bskey
            5,       -- code
            6;       -- order1
 
   CURSOR loadRedundDf_c IS
      SELECT bs_key
        FROM (SELECT bs_key, file#
                FROM bdf, dbinc
               WHERE dbinc.db_key = this_db_key
                 AND dbinc.dbinc_key = bdf.dbinc_key
                 AND file# >= nvl(from_bsRec.dfNumber_obj, 0)
              UNION ALL
              SELECT bs_key, 0 file#
                FROM bcf, dbinc
               WHERE dbinc.db_key = this_db_key
                 AND dbinc.dbinc_key = bcf.dbinc_key
                 AND nvl(from_bsRec.dfNumber_obj, 0) = 0
              UNION ALL
              SELECT bs_key, -1 file#
                FROM bsf
               WHERE from_bsRec.dfNumber_obj IS NULL
                 AND from_bsRec.fromSCN_act = 0
                 AND bsf.db_key = this_db_key)
       GROUP BY bs_key 
       ORDER BY min(file#),
                abs(bs_key - from_bsRec.bsKey_con);
 
   CURSOR loadRedundAl_c IS
      SELECT bs_key
        FROM (SELECT bs_key, thread#, sequence#
                FROM brl, dbinc
               WHERE dbinc.db_key = this_db_key
                 AND dbinc.dbinc_key = brl.dbinc_key
                 AND low_scn >= from_bsRec.logLowSCN_obj
                 AND ((thread# = from_bsRec.logThread_obj AND
                       sequence# >= from_bsRec.logSequence_obj) OR
                      (thread# > from_bsRec.logThread_obj)))
       GROUP BY bs_key 
       ORDER BY min(thread#),
                min(sequence#),
                abs(bs_key - from_bsRec.bsKey_con);
 
   CURSOR loadLocality_c(minbskey   IN number,
                         backupType IN varchar2) IS
      SELECT bs_key bskey
        FROM bs
       WHERE bs.db_key = this_db_key
         AND bs.bs_key >= loadLocality_c.minbskey
         AND (loadLocality_c.backupType IS NULL OR
              decode(bs.bck_type, 'L', 'L', 'D')=loadLocality_c.backupType)
      ORDER BY abs(bs_key - from_bsRec.bsKey_con);
 
   icopy            binary_integer := 0;
   bsrec            cacheBsRec_t;
   bsrow            cacheBsRecRow_t;
   prev_bskey       number := 0;
   low_bskey        number;
   deviceindx       binary_integer;
   addperset        binary_integer;     -- no: entries added to cache per set
   bslist           numTab_t;
   addstatus        boolean;
   freec            number;
   backupType       varchar2(1);
BEGIN
   deb(DEB_ENTER, 'loadBsRecCache');
   deb(DEB_IN, 'mixcopy=' || to_char(mixcopy));
 
--
   IF (NOT cacheBsRecTable.initlimit AND this_db_key IS NOT NULL) THEN
--
      SELECT count(*) INTO cacheBsRecTable.limit
        FROM bs, dbinc
       WHERE dbinc.db_key  = this_db_key    -- belongs to this database
         AND dbinc.db_key  = bs.db_key;     -- join bs and dbinc
 
      IF (cacheBsRecTable.limit > bsRecCacheHighLimit) THEN
         cacheBsRecTable.limit := bsRecCacheHighLimit;
      ELSIF (cacheBsRecTable.limit < bsRecCacheLowLimit) THEN
         cacheBsRecTable.limit := bsRecCacheLowLimit;
      END IF;
      cacheBsRecTable.initlimit := TRUE;
   END IF;
 
   IF (mixcopy = FALSE#) THEN
--
      resetBsRecCache(TRUE);
 
      cacheBsRecTable.bsRec := bsrec;
 
--
      cacheBsRecTable.tag := tag;
      cacheBsRecTable.deviceType := deviceType;
      cacheBsRecTable.mask := mask;
   ELSIF (cacheBsRecTable.mixcopy) THEN
      deb(DEB_EXIT, 'loadBsRecCache already loaded with mixcopy');
      RETURN;
   ELSE
      cacheBsRecTable.mixcopy := TRUE;
      FOR rec in loadBsRecCache_c LOOP
         deviceindx :=  setCachedDeviceType(rec.deviceType);
--
--
--
--
--
         <<mixCopyLoop>>
         FOR i in 1..255 LOOP
            BEGIN
               lkBsRecCache(bskey    => rec.bskey,
                            icopy    => i,
                            bsrec    => bsrow);
               EXIT mixCopyLoop WHEN (bsrow.deviceindx = deviceindx AND
                                      bsrow.code < rec.code);
            EXCEPTION
               WHEN no_data_found THEN
                  addToBsRecCache(bskey      => rec.bskey,
                                  icopy      => i,
                                  deviceindx => deviceindx,
                                  tag        => rec.tag,
                                  copyNumber => rec.copyNumber,
                                  code       => rec.code);
                  EXIT mixCopyLoop;
            END;
         END LOOP;
      END LOOP;
      deb(DEB_EXIT, 'loadBsRecCache loaded with mixcopy');
      RETURN;
   END IF;
 
--
   addstatus := addKeyToBsRecCache(bskey => from_bsRec.bsKey_con);
 
--
--
   IF (cacheBsRecTable.hint = redundantHint) THEN
      freec := cacheBsRecTable.limit;           -- only redundant
   ELSIF (cacheBsRecTable.hint = localityHint) THEN
      freec := 0;                               -- only locality
   ELSE
      freec := floor(cacheBsRecTable.limit/2);  -- redundant + locality
   END IF;
 
--
   IF (freec != 0) THEN
      IF (from_bsRec.dfNumber_obj IS NOT NULL OR
          from_bsRec.fromSCN_act = 0) THEN
         deb(DEB_IN, 'loadRedundDf_c');
         OPEN loadRedundDf_c;
         FETCH loadRedundDf_c BULK COLLECT
          INTO bslist LIMIT freec;
         CLOSE loadRedundDf_c;
      ELSIF (from_bsRec.logLowSCN_obj IS NOT NULL) THEN
         deb(DEB_IN, 'loadRedundAl_c');
         OPEN loadRedundAl_c;
         FETCH loadRedundAl_c BULK COLLECT
          INTO bslist LIMIT freec;
         CLOSE loadRedundAl_c; 
      END IF;
 
--
      FOR i in 1..bslist.count LOOP
         addstatus := addKeyToBsRecCache(bslist(i));
      END LOOP;
   END IF;
 
   freec := cacheBsRecTable.limit - bslist.count;
   bslist.delete;     -- free memory
 
--
   FOR i in 1..cacheBsRecTable.hitlist.count LOOP
      IF (addKeyToBsRecCache(cacheBsRecTable.hitlist(i))) THEN
         freec := freec - 1;
      END IF;
      EXIT WHEN (freec <= 0);
   END LOOP;
 
   IF (cacheBsRecTable.minbskey = 0) THEN
      BEGIN
         SELECT nvl(min(bp.bs_key), 0)
           INTO cacheBsRecTable.minbskey
           FROM bp
          WHERE bp.db_key = this_db_key
            AND bp.status != 'D'
            AND ((user_site_key = bp.site_key) OR
                 (user_site_key IS NULL AND
                  ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
                   (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
                   (this_site_key = nvl(bp.site_key, this_site_key)))))
            AND ((mask = BSavailable AND bp.status = 'A') OR
                 isStatusMatch(bp.status, mask) = TRUE#);
      EXCEPTION
          WHEN no_data_found THEN
             cacheBsRecTable.minbskey := 0;
      END;
   END IF;
 
--
--
   IF (freec > 0) THEN
      backupType := to_char(null);
      IF (cacheBsRecTable.hint = redundantHint) THEN
--
         BEGIN
            SELECT decode(bck_type, 'L', 'L', 'D')
              INTO backupType
              FROM bs
             WHERE bs_key = from_bsRec.bsKey_con;
         EXCEPTION
            WHEN no_data_found THEN
               backupType := 'D';
         END;
      END IF;
 
--
      OPEN loadLocality_c(cacheBsRecTable.minbskey, backupType);
      LOOP
         FETCH loadLocality_c BULK COLLECT
          INTO bslist LIMIT freec;
         FOR i in 1..bslist.count LOOP
            IF (addKeyToBsRecCache(bslist(i))) THEN
               freec := freec - 1;
            END IF;
         END LOOP;
         bslist.delete;     -- free memory
         EXIT WHEN (loadLocality_c%NOTFOUND OR freec <= 0);
      END LOOP;
      CLOSE loadLocality_c;
   END IF;
 
--
   FOR rec in loadBsRecCache_c LOOP
      deviceindx :=  setCachedDeviceType(rec.deviceType);
--
      IF (prev_bskey = rec.bskey AND
          prev_bskey != 0) THEN
         icopy := icopy + 1;
      ELSE
         icopy := 1;           -- start with index 1 because this is new set
      END IF;
 
      addToBsRecCache(bskey      => rec.bskey,
                      icopy      => icopy,
                      deviceindx => deviceindx,
                      tag        => rec.tag,
                      copyNumber => rec.copyNumber,
                      code       => rec.code);
 
--
      prev_bskey := rec.bskey;
   END LOOP;
 
   deb(DEB_IN, 'tag=' || nvl(cacheBsRecTable.tag, 'NULL') ||
               ' deviceType=' || nvl(cacheBsRecTable.deviceType, 'NULL') ||
               ' mask=' || to_char(mask));
 
--
   deb(DEB_IN, 'Cache contains ' || to_char(cacheBsRecTable.bsRec.count) ||
               ' buckets');
--
--
--
--
--
 
   deb(DEB_IN, 'Minimum bskey=' || to_char(cacheBsRecTable.minbskey));
 
   deb(DEB_EXIT);
END loadBsRecCache;
 
--
PROCEDURE cacheFindValidBackupSet(
   bsRec                IN     rcvRec_t
  ,deviceType           IN     varchar2 DEFAULT NULL
  ,tag                  IN     varchar2 DEFAULT NULL
  ,availableMask        IN     binary_integer)
IS
BEGIN
   deb(DEB_PRINT,'cacheFindValidBackupSet:' ||
       ' bskey =' || to_char(bsRec.bsKey_con) ||
       ' tag=' || nvl(tag, 'NULL') ||
       ' deviceType=' || nvl(deviceType, 'NULL') ||
       ' mask=' || to_char(availableMask));
 
   IF (NOT hitBsRecCache(bskey      => bsRec.bsKey_con,
                         deviceType => deviceType,
                         tag        => tag,
                         mask       => availableMask)) THEN
      loadBsRecCache(from_bsRec     => bsRec,
                     deviceType     => deviceType,
                     tag            => tag,
                     mask           => availableMask,
                     mixcopy        => FALSE#);
      cacheBsRecTable.chit := cacheBsRecTable.chit + 1;
   END IF;
 
   findValidCacheRequest.bskey := bsRec.bsKey_con;
   findValidCacheRequest.icopy := 0;
END cacheFindValidBackupSet;
 
--
FUNCTION cacheGetValidBackupSet(
   validBackupSetRec            OUT NOCOPY validBackupSetRec_t
  ,checkDeviceIsAllocated       IN  number DEFAULT FALSE#)
RETURN number IS
   local        validBackupSetRec_t;
   bsrec        cacheBsRecRow_t;
   nullbsrec    rcvRec_t;
BEGIN
 
<<nextRow>>
 
   findValidCacheRequest.icopy := findValidCacheRequest.icopy + 1;
   BEGIN
      lkBsRecCache(
         bskey      => findValidCacheRequest.bskey,
         icopy      => findValidCacheRequest.icopy,
         bsrec      => bsrec);
   EXCEPTION
      WHEN no_data_found THEN
--
         IF (findValidCacheRequest.icopy != 1) THEN
            RAISE;
         END IF;
 
         IF (findValidCacheRequest.bskey< cacheBsRecTable.minbskey) THEN
            deb(DEB_PRINT, 'bskey < cacheBsRecTable.minbskey');
            RAISE;
         END IF;
 
         IF (NOT canMixCopy(bskey => findValidCacheRequest.bskey)) THEN
            RAISE;
         END IF;
 
--
         loadBsRecCache(from_bsRec     => nullbsrec,
                        deviceType     => cacheBsRecTable.deviceType,
                        tag            => cacheBsRecTable.tag,
                        mask           => cacheBsRecTable.mask,
                        mixcopy        => TRUE#);
         lkBsRecCache(
            bskey      => findValidCacheRequest.bskey,
            icopy      => findValidCacheRequest.icopy,
            bsrec      => bsrec);
   END;
 
--
   local.deviceType := cacheBsRecTable.devicelist(bsrec.deviceindx);
   local.tag := bsrec.tag;
   local.copyNumber := bsrec.copyNumber;
   local.code := bsrec.code;
 
   IF (checkDeviceIsAllocated = TRUE#) THEN
      IF (anyDevice = FALSE# AND
          isDeviceTypeAllocated(local.deviceType) = FALSE#) THEN
         GOTO nextRow;
      END IF;
   END IF;
   validBackupSetRec := local;                  -- set OUT mode arg
   deb(DEB_PRINT,'cacheGetValidBackupSet: returning valid rec deviceType=' ||
       local.deviceType || ' tag=' || local.tag || ' copyNumber=' ||
       to_char(local.copyNumber));
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      RETURN FALSE#;
END cacheGetValidBackupSet;
 
--
--
--
 
--
PROCEDURE validateState(
   anyCursor IN varchar2)
IS
BEGIN
   deb(DEB_ENTER,'validateState');
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'database not set');
   END IF;
   IF (this_dbinc_key IS NULL) THEN
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
   IF (translation_site_key IS NULL) THEN
      raise_application_error(-20082, 'Translation site key not set');
   END IF;
   IF (anyCursor IS NOT NULL) THEN
      raise_application_error(-20203, 'Translation already started');
   END IF;
 
--
--
   IF this_db_unique_name is NOT NULL AND this_site_key is NULL AND
      NOT this_dummy_instance THEN
      select site_key into this_site_key from node
         where db_unique_name=this_db_unique_name
           and db_key = this_db_key;
      deb(DEB_PRINT,'this_site_key=' || this_site_key);
   END IF;
   deb(DEB_EXIT,'validateState');
END;
 
--
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE computeUntilSCN(
   timeStamp IN  date
  ,scn       OUT number
  ,allinc    IN  number)
IS
   mySCN     number;
BEGIN
   deb(DEB_ENTER, 'computeUntilSCN');
 
--
--
--
   SELECT nvl(max(rlh.low_scn),0)
     INTO mySCN
     FROM rlh,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE rlh.dbinc_key     = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (rlh.low_scn >= d2.reset_scn AND
            rlh.low_scn <  d2.next_reset_scn))
      AND rlh.low_time     <= timeStamp;
 
   SELECT greatest(nvl(max(al.low_scn), 0), mySCN)
     INTO mySCN
     FROM al,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE al.dbinc_key     = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (al.low_scn >= d2.reset_scn AND
            al.low_scn <  d2.next_reset_scn))
      AND al.low_time      <= timeStamp;
 
   SELECT greatest(nvl(max(bdf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM bdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE bdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (bdf.ckp_scn >= d2.reset_scn AND
            bdf.ckp_scn <  d2.next_reset_scn))
      AND bdf.ckp_time <= timeStamp;
 
   SELECT greatest(nvl(max(bcf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM bcf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE bcf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (bcf.ckp_scn >= d2.reset_scn AND
            bcf.ckp_scn <  d2.next_reset_scn))
      AND bcf.ckp_time      <= timeStamp;
 
   SELECT greatest(nvl(max(cdf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM cdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE cdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (cdf.ckp_scn >= d2.reset_scn AND
            cdf.ckp_scn <  d2.next_reset_scn))
      AND cdf.ckp_time      <= timeStamp;
 
   SELECT greatest(nvl(max(cdf.rcv_fuzzy_scn),0), mySCN)
     INTO mySCN
     FROM cdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE cdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (cdf.rcv_fuzzy_scn >= d2.reset_scn AND
            cdf.rcv_fuzzy_scn <  d2.next_reset_scn))
      AND cdf.rcv_fuzzy_time <= timeStamp;
 
   SELECT greatest(nvl(max(ccf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM ccf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE ccf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (ccf.ckp_scn >= d2.reset_scn AND
            ccf.ckp_scn <  d2.next_reset_scn))
      AND ccf.ckp_time <= timeStamp;
 
   SELECT greatest(nvl(max(xdf.ckp_scn),0), mySCN)
     INTO mySCN
     FROM xdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE xdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (xdf.ckp_scn >= d2.reset_scn AND
            xdf.ckp_scn <  d2.next_reset_scn))
      AND xdf.ckp_time <= timeStamp;
 
   SELECT greatest(nvl(max(xdf.rcv_fuzzy_scn),0), mySCN)
     INTO mySCN
     FROM xdf,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE xdf.dbinc_key      = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (xdf.rcv_fuzzy_scn >= d2.reset_scn AND
            xdf.rcv_fuzzy_scn <  d2.next_reset_scn))
      AND xdf.rcv_fuzzy_time<= timeStamp;
 
   SELECT greatest(nvl(max(df.create_scn), 0), mySCN)
     INTO mySCN
     FROM df,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE df.dbinc_key       = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (df.create_scn >= d2.reset_scn AND
            df.create_scn <  d2.next_reset_scn))
      AND df.create_time    <= timeStamp;
 
   SELECT greatest(nvl(max(df.stop_scn), 0), mySCN)
     INTO mySCN
     FROM df,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE df.dbinc_key       = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (df.stop_scn >= d2.reset_scn AND
            df.stop_scn <  d2.next_reset_scn))
      AND df.stop_time      <= timeStamp;
 
   SELECT greatest(nvl(max(offr.online_scn), 0), mySCN)
     INTO mySCN
     FROM offr,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
          WHERE allinc = TRUE#
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE offr.dbinc_key     = d2.dbinc_key
      AND (allinc = FALSE#           OR
           d2.next_reset_scn IS NULL OR
           (offr.online_scn >= d2.reset_scn AND
            offr.online_scn <  d2.next_reset_scn))
      AND offr.online_time  <= timeStamp;
 
   scn := mySCN;
   deb(DEB_EXIT, 'with '||to_char(scn));
END computeUntilSCN;
 
--
PROCEDURE computeSpfileTime(
   inSCN     IN  number
  ,outTime   OUT date
  ,allinc    IN  number
  ,estimated OUT boolean)
IS
   startTime date;
BEGIN
   deb(DEB_ENTER, 'computeSpfileTime');
 
   outTime := NULL;
 
--
   IF rpoint_set THEN
      estimated := FALSE;
      SELECT MIN(rtime) INTO outTime
      FROM (SELECT NVL(rsptime, creation_time) rtime
            FROM nrsp
            WHERE to_scn = inSCN - 1
           UNION
            SELECT NVL(rsptime, creation_time) rtime
            FROM grsp
            WHERE to_scn = inSCN - 1);
   END IF;
 
--
   IF outTime IS NULL THEN
      estimated := TRUE;
      startTime := to_date('01/01/1900','DD/MM/YYYY');
 
--
      SELECT nvl(max(bs.start_time), startTime)
      INTO outTime
      FROM bcf,bs,
           (SELECT dbinc_key,
                   reset_scn,
                   PRIOR reset_scn next_reset_scn
            FROM dbinc
            WHERE allinc = TRUE#
            START WITH dbinc_key = this_dbinc_key
            CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
            SELECT this_dbinc_key dbinc_key,
                   null           reset_scn,
                   null           next_reset_scn
              FROM dual) d2
      WHERE bcf.dbinc_key = d2.dbinc_key
        AND bs.bs_key = bcf.bs_key
        AND (allinc = FALSE#           OR
             d2.next_reset_scn IS NULL OR
             (bcf.ckp_scn >= d2.reset_scn AND
              bcf.ckp_scn <  d2.next_reset_scn))
        AND bcf.ckp_scn <= inSCN;
 
--
 
--
      SELECT greatest(nvl(max(xcf.start_time), startTime), outTime)
      INTO outTime
      FROM xcf,
           (SELECT dbinc_key,
                   reset_scn,
                   PRIOR reset_scn next_reset_scn
            FROM dbinc
            WHERE allinc = TRUE#
            START WITH dbinc_key = this_dbinc_key
            CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
            SELECT this_dbinc_key dbinc_key,
                   null           reset_scn,
                   null           next_reset_scn
              FROM dual) d2
       WHERE xcf.dbinc_key      = d2.dbinc_key
         AND (allinc = FALSE#           OR
              d2.next_reset_scn IS NULL OR
              (xcf.ckp_scn >= d2.reset_scn AND
               xcf.ckp_scn <  d2.next_reset_scn))
         AND xcf.ckp_scn <= inSCN;
 
--
      IF startTime = outTime THEN
         outTime := NULL;
      END IF;
   END IF;
 
--
--
   outTime := outTime + 1/24/60/60; -- Add one second
 
   deb(DEB_EXIT, 'with ' || to_char(outTime, 'DD-MON-YY HH24:MI:SS'));
END computeSpfileTime;
 
--
--
--
 
--
 
--
PROCEDURE findBackupSet(
   bsKey        IN     number DEFAULT NULL
  ,recid        IN     number DEFAULT NULL
  ,stamp        IN     number DEFAULT NULL
  ,bsRec        OUT    NOCOPY bsRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'findBackupSet');
   deb(DEB_IN, 'bsKey:'||nvl(bsKey, -1));
   IF (bsKey IS NOT NULL) THEN
      SELECT recid,
             stamp,
             bs_key,
             set_stamp,
             set_count,
             backup_type,
             incremental_level,
             elapsed_seconds,
             completion_time,
             status,
             pieces,
             decode (keep_options, 'LOGS'         , KEEP_LOGS
                                 , 'NOLOGS'       , KEEP_NOLOGS
                                 , 'BACKUP_LOGS'  , KEEP_CONSIST
                                                  , KEEP_NO),
             keep_until,
             substr(multi_section, 1, 1),
             0 ppl_pdb_id,
             0 ppl_cdb_dbid
        INTO bsRec
        FROM rc_backup_set
       WHERE db_key = this_db_key
         AND findBackupSet.bsKey = bs_key;
   ELSE
      SELECT recid,
             stamp,
             bs_key,
             set_stamp,
             set_count,
             backup_type,
             incremental_level,
             elapsed_seconds,
             completion_time,
             status,
             pieces,
             decode (keep_options, 'LOGS'         , KEEP_LOGS
                                 , 'NOLOGS'       , KEEP_NOLOGS
                                 , 'BACKUP_LOGS'  , KEEP_CONSIST
                                                  , KEEP_NO),
             keep_until,
             substr(multi_section, 1, 1),
             0 ppl_pdb_id,
             0 ppl_cdb_dbid
        INTO bsRec
        FROM rc_backup_set
       WHERE db_key = this_db_key
         AND findBackupSet.recid = recid
         AND findBackupSet.stamp = stamp;
   END IF;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with error 20215');
      raise_application_error(-20215, 'Backup set is missing');
END findBackupSet;
 
--
--
--
 
--
--
--
 
--
PROCEDURE findValidBackupSet(
   bsKey                IN     number
  ,pieceCount           IN     number
  ,deviceType           IN     varchar2 DEFAULT NULL
  ,tag                  IN     varchar2 DEFAULT NULL
  ,availableMask        IN     binary_integer)
IS
   bsRec rcvRec_t;
BEGIN
   IF (bsRecCacheEnabled) THEN
      bsRec.bsKey_con := bsKey;
      bsRec.pieceCount_con := pieceCount;
      cacheFindValidBackupSet(bsRec         => bsRec,
                              deviceType    => deviceType,
                              tag           => tag,
                              availableMask => availableMask);
      RETURN;
   END IF;
 
   deb(DEB_ENTER, 'findValidBackupSet');
 
   IF (pieceCount = 1) THEN
      IF (findValidBackupSet1P_c%ISOPEN) THEN
         CLOSE findValidBackupSet1P_c;
      END IF;
--
--
--
--
      deb(DEB_OPEN, 'findValidBackupSet1P_c');
      OPEN findValidBackupSet1P_c(bsKey         => bsKey,
                                  pieceCount    => pieceCount,
                                  deviceType    => deviceType,
                                  tag           => tag,
                                  mask          => availableMask);
      getValidBackupSetCursor := 'findValidBackupSet1P_c';
   ELSE           -- more than one piece exists in this set
      IF (findValidBackupSet_c%ISOPEN) THEN
         CLOSE findValidBackupSet_c;
      END IF;
      deb(DEB_OPEN, 'findValidBackupSet_c');
      OPEN findValidBackupSet_c(bsKey         => bsKey,
                                pieceCount    => pieceCount,
                                deviceType    => deviceType,
                                tag           => tag,
                                mask          => availableMask);
      getValidBackupSetCursor := 'findValidBackupSet_c';
   END IF;
 
   deb(DEB_IN, 'bsKey=' || to_char(bsKey) || ' pieceCount=' ||
          to_char(pieceCount) ||' tag=' || nvl(tag, 'NULL'));
   deb(DEB_IN, ' deviceType=' || nvl(deviceType, 'NULL') ||
          ' mask=' || to_char(availableMask));
   getValidBackupSetLast.code       := 99;      -- init for getValidBackupSet
   deb(DEB_EXIT);
END findValidBackupSet;
 
--
FUNCTION validateBackupSet(
   backupSetRec            IN     rcvRec_t
  ,tag                     IN     varchar2 DEFAULT NULL
  ,tagMatchRequired        IN     boolean  DEFAULT TRUE
  ,checkDeviceIsAllocated  IN     boolean  DEFAULT TRUE
  ,availableMask           IN     binary_integer
  ,validRec                OUT    NOCOPY validBackupSetRec_t)
RETURN binary_integer IS
   findTag      bp.tag%TYPE;
BEGIN
   deb(DEB_ENTER, 'validateBackupSet');
   IF (tagMatchRequired) THEN
      findTag := tag;
   ELSE
--
--
--
      findTag := NULL;
   END IF;
 
   deb(DEB_IN, 'calling findValidBackupSet with:');
   deb(DEB_IN, ' tag=' || nvl(tag, 'NULL') ||
                    ' findTag=' || nvl(findTag, 'NULL') ||
                    ' tagMatchRequired=' || bool2char(tagMatchRequired) ||
                    ' checkDevice=' || bool2char(checkDeviceIsAllocated) ||
                    ' availableMask=' || to_char(availableMask));
 
  
   IF (bsRecCacheEnabled) THEN
      cacheFindValidBackupSet(bsRec         => backupSetRec,
                              tag           => findTag,
                              availableMask => availableMask);
   ELSE
      findValidBackupSet(bsKey         => backupSetRec.bsKey_con,
                         pieceCount    => backupSetRec.pieceCount_con,
                         tag           => findTag,
                         availableMask => availableMask);
   END IF;
 
   deb(DEB_EXIT, 'with result from validateBackupSet0');
   RETURN validateBackupSet0(
      tag                    => tag,
      tagMatchRequired       => tagMatchRequired,
      checkDeviceIsAllocated => checkDeviceIsAllocated,
      validRec               => validRec);
END validateBackupSet;
 
--
--
--
 
--
PROCEDURE findBackupPiece(
   bpKey        IN     number          DEFAULT NULL
  ,bsKey        IN     number          DEFAULT NULL
  ,tag          IN     varchar2        DEFAULT NULL
  ,handle       IN     varchar2        DEFAULT NULL
  ,deviceType   IN     varchar2        DEFAULT NULL
  ,copyNumber   IN     number          DEFAULT NULL
  ,statusMask   IN     binary_integer  DEFAULT BSavailable
  ,startBsKey   IN     number          DEFAULT NULL
  ,pdbKey       IN     number          DEFAULT NULL
  ,guid         IN     varchar2        DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'findBackupPiece');
   deb(DEB_IN, 'bpKey:'||nvl(bpKey, -1)||
          ' and bsKey:'||nvl(bsKey, -1));
   validateState(getBackupPieceCursor);
 
   IF (bpKey IS NOT NULL) THEN
      deb(DEB_OPEN, 'findBackupPieceBpKey');
      OPEN findBackupPieceBpKey(bpKey       => bpKey,
                                tag         => tag,
                                handle      => handle,
                                deviceType  => deviceType,
                                copyNumber  => copyNumber,
                                statusMask  => statusMask);
      getBackupPieceCursor := 'findBackupPieceBpKey';
   ELSIF (bsKey IS NOT NULL) THEN
      deb(DEB_OPEN, 'findBackupPieceBsKey1');
      OPEN findBackupPieceBsKey1(bsKey       => bsKey,
                                 tag         => tag,
                                 handle      => handle,
                                 deviceType  => deviceType,
                                 copyNumber  => copyNumber,
                                 statusMask  => statusMask);
      getBackupPieceCursor := 'findBackupPieceBsKey1';
   ELSIF (startBsKey IS NOT NULL) THEN
      OPEN findBackupPieceBsKey2(startBsKey  => startBsKey,
                                 tag         => tag,
                                 statusMask  => statusMask);
      getBackupPieceCursor := 'findBackupPieceBsKey2';
   ELSE
      deb(DEB_OPEN, 'findBackupPiece_c');
      OPEN findBackupPiece_c(   tag         => tag,
                                handle      => handle,
                                deviceType  => deviceType,
                                copyNumber  => copyNumber,
                                statusMask  => statusMask,
                                pdbKey      => pdbKey,
                                guid        => guid);
      getBackupPieceCursor := 'findBackupPiece_c';
   END IF;
 
--
--
 
   getBackupPieceNoRows.error     := NULL;
   getBackupPieceDuplicates       := TRUE#;
   getBackupPieceLast.pieceNumber := NULL;
   getBackupPieceDeviceType       := deviceType;
   getBackupPieceExpectedPieces   := NULL;
   getBackupPiecePieceCount       := 0;
   getBackupPieceByHandle         := FALSE;
   getBackupPieceAvailableMask    := NULL;
   getBackupPieceSeekLast.bskey   := NULL;
   getBackupPieceCopyNumber       := NULL;
   getBackupPieceBskey            := bsKey;
   deb(DEB_EXIT);
 
END findBackupPiece;
 
--
--
--
 
--
FUNCTION addAction(                             -- add to the rcvRecStack
   actionIN      IN     rcvRec_t                -- if a backup set, we fill
--
  ,partial_rcv   IN     boolean
  ,isAncestor    IN     boolean
  ,cf_scn        IN     number  DEFAULT NULL
  ,cf_cretime    IN     date    DEFAULT NULL
  ,cf_offrrid    IN     number  DEFAULT NULL
  ,allCopies     IN     boolean DEFAULT FALSE
  ,doingRecovery IN     boolean
  ,rmanCmd       IN     binary_integer
  ,pdbId         IN     number
  ,cleanSCN      IN     number)
RETURN number IS
   dummy                rcvRec_t;
   action               rcvRec_t;
   validate_rc          number;
   cf_count             number;
   addRedo_rc           number;
   chkact_rc            number;
   tagMatchRequired     boolean;
   validationRec        validBackupSetRec_t;
   lowAction            rcvRec_t;
   canrecover           boolean;
   toSCN                number;
BEGIN
   deb(DEB_ENTER, 'addAction');
   deb(DEB_IN, ' action.type_con='|| to_char(action.type_con));
 
   action := actionIN;                  -- copy to local variable
 
--
--
--
--
--
--
--
--
 
   IF (redoNeeded(action)) THEN
--
--
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
      rcvRecGet(rcvRecStackState.lowAction, lowAction);
      addRedo_rc := addRedo(isAncestor,
                            action.toSCN_act, action.rlgSCN_act,
                            lowAction,
                            partial_rcv, doingRecovery);
 
      IF (addRedo_rc = action_OLD_REDO) THEN
--
--
--
         deb(DEB_EXIT, 'with addRedo_rc: '||to_char(addRedo_rc));
         RETURN addRedo_rc;
      ELSE
--
--
--
--
--
         NULL;
      END IF;
   ELSE                                 -- redo not needed
--
--
--
--
      NULL;
   END IF;
 
--
--
   chkact_rc := CheckRecAction(action, pdbId, cleanSCN);
 
   IF (chkact_rc = action_SKIP) THEN
      deb(DEB_EXIT, 'with action_SKIP');
      RETURN action_SKIP;
   END IF;
 
 
--
--
--
--
 
   IF (action.type_con = backupSet_con_t) THEN
      IF (computeRA_allRecords = TRUE# OR restoreTag IS NULL) THEN
         tagMatchRequired := FALSE;
      ELSE
         tagMatchRequired := TRUE;
      END IF;
 
      IF (rmanCmd = rcvCopyCmd_t) THEN
--
--
         tagMatchRequired := FALSE;
      END IF;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
      IF (rmanCmd != obsoleteCmd_t OR 
          (restoreTag IS NOT NULL AND this_baseline_cap >= 0)) THEN
         validate_rc :=
            validateBackupSet(backupSetRec           => action,
                              tag                    => restoreTag,
                              tagMatchRequired       => tagMatchRequired,
                              checkDeviceIsAllocated => TRUE,
                              availableMask          => computeRA_availableMask,
                              validRec               => validationRec);
      ELSE
--
--
         validate_rc := SUCCESS;
      END IF;
 
      IF (validate_rc = dbms_rcvman.UNAVAILABLE) THEN
         deb(DEB_EXIT, '(backup set is unavailable) with: action_FAIL');
         RETURN action_FAIL;
      ELSIF (validate_rc = dbms_rcvman.AVAILABLE) THEN
--
--
--
         deb(DEB_IN,'dont have required device type');
 
--
--
--
--
         IF (rmanCmd = rcvCopyCmd_t) THEN
            computeRA_rcvCopy_avail := TRUE;
         ELSE
            computeRA_available := TRUE;
         END IF;
         deb(DEB_EXIT, 'returning FAIL');
         RETURN action_FAIL;
      END IF;
--
--
--
   ELSIF (action.type_con = proxyCopy_con_t) THEN
--
      IF (anyDevice = FALSE# AND
          isDeviceTypeAllocated(action.deviceType_con) = FALSE#) THEN
--
--
--
         IF (rmanCmd = rcvCopyCmd_t) THEN
            computeRA_rcvCopy_avail := TRUE;
         ELSE
            computeRA_available := TRUE;
         END IF;
         deb(DEB_EXIT, '(dont have required device type for proxy)'||
             ' with: action_FAIL');
         RETURN action_FAIL;
      END IF;
   ELSIF (action.type_con = imageCopy_con_t) THEN
--
--
--
      IF (rmanCmd != rcvCopyCmd_t AND not diskDevice) THEN
--
--
         computeRA_available := TRUE;
         deb(DEB_EXIT, '(dont have required device type for imagecopy)'||
             ' with: action_FAIL');
         RETURN action_FAIL;
      END IF;
 
--
--
--
      IF (rmanCmd = rcvCopyCmd_t) THEN
         canrecover := FALSE;
         computeRA_available := computeRA_rcvCopy_avail;
         toSCN := action.toSCN_act;
         deb(DEB_IN,'rcvCopyCmd count= ' || rcvRecStack.count ||
             ' lowAction= ' || rcvRecStackState.lowAction ||
             ' toSCN= ' || toSCN);
         IF (rcvRecStack.count > 0) THEN
            FOR i IN REVERSE 1..rcvRecStackState.lowAction LOOP
               rcvRecGet(i, dummy);
--
               IF (dummy.type_act = incremental_act_t OR
                   dummy.type_con = offlineRangeRec_con_t) THEN
--
--
--
--
                  EXIT WHEN (toSCN < dummy.fromSCN_act);
 
--
                  IF (dummy.type_con = offlineRangeRec_con_t) THEN
                     toSCN := dummy.toSCN_act;
                     deb(DEB_IN,'extending toSCN= ' || toSCN);
                  ELSE -- this is incremental
                     IF (anyDevice = TRUE# OR
                         isDeviceTypeAllocated(dummy.deviceType_con)=TRUE#)
                     THEN
--
                        deb(DEB_IN,'canrecover is TRUE - 2');
                        canrecover := TRUE;
                        computeRA_available := NULL;
                        EXIT;
                     ELSE
--
--
--
                        deb(DEB_IN,'canrecover is FALSE');
                        canrecover := FALSE;
                        computeRA_available := TRUE;
                     END IF;
                  END IF;
               ELSIF (debug) THEN
                  deb(DEB_IN,'rcvCopyCmd skipping');
                  printRcvRec(dummy);
               END IF;
            END LOOP;
         END IF;
 
--
--
--
         IF not canrecover THEN
            resetrcvRecStack;
            deb(DEB_EXIT, 'no valid incrementals with: action_FAIL');
            RETURN action_FAIL;
         END IF;
      END IF;
   ELSIF (action.type_con = offlineRangeRec_con_t AND
          action.type_act = offlineRange_act_t) THEN
--
--
--
--
--
--
       IF (cf_cretime IS NULL AND rmanCmd = obsoleteCmd_t) THEN
--
--
         NULL;
       ELSIF (cf_cretime = action.cfCreationTime_con AND
              action.recid_con >= cf_offrrid AND
              cf_offrrid > 0 AND       -- contains at least 1 record
              cf_scn >= action.toSCN_act) THEN
         NULL;                         -- range is in current cf, we're cool
      ELSE
         SELECT count(*)
         INTO cf_count
         FROM ccf
         WHERE ccf.create_time = action.cfCreationTime_con AND
               ccf.min_offr_recid <= action.recid_con AND
               ccf.ckp_scn >= action.toSCN_act AND
               ((user_site_key = ccf.site_key) OR
                (user_site_key IS NULL AND
                 ((disk_backups_shared = TRUE#) OR
                  (this_site_key = nvl(ccf.site_key, this_site_key))))) AND
               ccf.min_offr_recid > 0;         -- contains at least 1 record
         IF (cf_count = 0) THEN
            deb(DEB_EXIT, '(no controlfile copy with offline range)'||
                          ' with: action_FAIL');
            RETURN action_FAIL;
         END IF;
      END IF;
   END IF;
 
--
--
   IF (addRedo_rc = action_OLD_INC_REDO) THEN
 
      rcvRecStackState.lowAction := 0;
 
      rcvRecStack.trim(rcvRecStack.last -
                       greatest(rcvRecStackState.savePoint,
                                rcvRecStackState.top));
      deb(DEB_IN,'trimming stack, rcvRecStackCount='|| rcvRecStack.count);
   END IF;
 
   <<addAnother>>
 
--
--
--
   IF (validate_rc      = SUCCESS         AND
       action.type_con  = backupSet_con_t AND
       (rmanCmd         != obsoleteCmd_t OR
        (restoreTag IS NOT NULL AND this_baseline_cap >= 0))) THEN
--
--
--
--
--
--
--
      IF (validationRec.tag = restoreTag OR
          restoreTag IS NULL) THEN
         action.tag_con := validationRec.tag;
      END IF;
      action.deviceType_con := validationRec.deviceType;
      action.copyNumber_con := validationRec.copyNumber;
   END IF;
 
   IF (debug) THEN
      printRcvRec(action);
   END IF;
 
   IF (action.type_act = full_act_t) THEN
 
      IF (thisBackupAge < rcvRecBackupAge) THEN
--
--
--
--
--
--
--
 
--
--
--
--
--
--
--
--
 
--
--
--
--
--
         deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                      thisBackupAge || ') < rcvRecBackupAge('  ||
                      rcvRecBackupAge || ')');
         thisBackupAge := thisBackupAge + 1;
         deb(DEB_EXIT, 'with: action_SKIP');
         RETURN action_SKIP;
      END IF;
 
--
      IF (rcvRecStackState.fullBackups >= computeRA_fullBackups) THEN
--
--
         IF (rmanCmd = obsoleteCmd_t AND action.keep_options = 0) THEN
            deb(DEB_IN, 'skipping action because this action has NO KEEP');
            deb(DEB_EXIT, 'with action_SKIP');
            RETURN action_SKIP;
         ELSIF (rmanCmd != obsoleteCmd_t) THEN
            deb(DEB_IN, 'skipping action because stack has enough fullBackups');
            deb(DEB_EXIT, 'with action_SKIP');
            RETURN action_SKIP;
         END IF;
      END IF;
   END IF;
 
--
   IF (rmanCmd = obsoleteCmd_t and NOT isValidAction(action)) THEN
      deb(DEB_EXIT, 'with action_SKIP');
      RETURN action_SKIP;
   END IF;
 
   rcvRecPush(action);               -- add record for this action
 
   deb(DEB_IN, ' Added action:');
 
   IF (allCopies AND action.type_con = backupSet_con_t) THEN
--
      deb(DEB_IN,'allCopies is TRUE, trying to add other copies');
      validate_rc :=
         validateBackupSet0(tag                    => restoreTag,
                            tagMatchRequired       => tagMatchRequired,
                            checkDeviceIsAllocated => TRUE,
                            validRec               => validationRec);
      IF (validate_rc <> SUCCESS) THEN
         GOTO done;
      END IF;
      GOTO addAnother;
   END IF;
 
   <<done>>
 
--
 
   IF (action.type_act = full_act_t) THEN
--
      deb(DEB_IN, ' action.type_act is range/full => setting savePoint='||
           to_char(rcvRecStack.last));
      rcvRecStackState.savePoint   := rcvRecStack.last;
 
--
--
      IF (rmanCmd != obsoleteCmd_t OR action.keep_options = KEEP_NO) THEN
         rcvRecStackState.fullBackups := rcvRecStackState.fullBackups + 1;
      END IF;
   ELSIF (rcvRecStackState.lowAction = 0) THEN
--
      rcvRecStackState.lowAction := rcvRecStack.last;
   ELSIF (action.fromSCN_act <
          rcvRecStack(rcvRecStackState.lowAction).fromSCN_act) THEN
      rcvRecStackState.lowAction := rcvRecStack.last;   -- new lowAction
   END IF;
 
   deb(DEB_EXIT, 'with: action_OK');
   RETURN action_OK;
 
END addAction;
 
--
--
--
FUNCTION computeRecoveryActions2(
   fno         IN number        -- Datafile number.
  ,crescn      IN number        -- Datafile creation SCN.
  ,cretime     IN date          -- Datafile creation time.
  ,df_rlgscn   IN number        -- Datafile resetlogs SCN.
--
--
--
  ,df_rlgtime  IN date          -- Datafile resetlogs time.
--
--
  ,df_ckpscn   IN number        -- Datafile checkpoint SCN.
--
--
  ,offlscn     IN number        -- kccfeofs (may be 0).
  ,onlscn      IN number        -- kccfeonc (0 if offlscn is 0).
  ,onltime     IN date          -- kccfeonc_time (ignored if kccfeofs is 0)
  ,cleanscn    IN number        -- kccfecps if either SOR or WCC set, else 0.
  ,clean2scn   IN number        -- CF ckpt SCN if WCC set.
--
  ,clean2time  IN date          -- cf_checkpoint_time if WCC,
--
  ,allowfuzzy  IN boolean       -- TRUE if can be fuzzy at until SCN/time,
--
  ,partial_rcv IN boolean
  ,target_scn  IN number        -- This is the SCN to which we want to recover
--
--
--
--
--
--
--
--
--
--
  ,dbinc_key   IN number        -- The key of the database incarnation to
--
--
--
  ,cf_scn      IN number
  ,cf_cretime  IN date          -- controlfile creation time.
--
  ,cf_offrrid  IN number        -- recid of oldest offline range in controlfile
--
  ,test_search IN boolean       -- if TRUE, then we have called ourself
--
--
  ,done        IN OUT boolean   -- set to TRUE if successful.  (IN mode so
--
  ,allCopies   IN boolean       -- if true, then stack all copies of
--
  ,recover     IN boolean
  ,rmanCmd     IN binary_integer
  ,foreignDbid   IN     number
  ,pluggedRonly  IN     binary_integer  -- 1 => readonly, 0 => readwrite
  ,pluginSCN     IN     number
  ,pluginRlgSCN  IN     number
  ,pluginRlgTime IN     date
  ,creation_thread IN   number
  ,creation_size   IN   number
  ,pdbId           IN   number
  ,pdbForeignDbid  IN   number)
--
--
--
--
--
--
--
 
RETURN boolean IS
 
--
--
--
 
   null_action          rcvRec_t;
   action               rcvRec_t;       -- current row
   lastAction           rcvRec_t;
   parentDbincKey       number;         -- my parent dbinc's key
 
   dbinc_rlgscn         number;         -- resetlogs scn for dbinc_key
 
   dbinc_rlgtime        date;           -- resetlogs time for dbinc_key
 
   CURSOR dbinc_cursor(db_key number, rstscn number) IS
   SELECT dbinc_key
     FROM dbinc
    WHERE dbinc.db_key = dbinc_cursor.db_key
      AND dbinc.reset_scn < dbinc_cursor.rstscn;
 
   dbinc_row            dbinc_cursor%ROWTYPE;
 
   savedrcvRecStackState rcvRecStackState_t;
 
   addAction_rc         number;         -- return code
 
   addRedo_rc           number;         -- return code
 
   isAncestor           boolean;        -- TRUE if we find an action we could
--
 
   rc                   boolean;        -- return code from recursive search
--
 
   done_flag            boolean;        -- for use in recursive calls
 
   doingRecovery        boolean;        -- doing RECOVER
   stack_df_rlgscn      number;
   savedBackupAge       number;
 
BEGIN
   deb(DEB_ENTER, 'computeRecoveryActions2');
 
   done := FALSE;
 
   doingRecovery := recover;
 
   IF (doingRecovery is null) THEN
--
--
     IF (df_rlgscn is not null) THEN                      -- doing RECOVER
        doingRecovery := TRUE;
     ELSE
        doingRecovery := FALSE;
     END IF;
   END IF;
 
   IF (doingRecovery) THEN                                 -- doing RECOVER
      deb(DEB_IN, ' Doing recovery.');
   ELSE
      deb(DEB_IN, ' Not doing recovery.');
   END IF;
 
--
   SELECT reset_scn, reset_time
     INTO dbinc_rlgscn, dbinc_rlgtime
     FROM dbinc
    WHERE dbinc.dbinc_key = computeRecoveryActions2.dbinc_key;
 
   IF (doingRecovery AND canApplyAnyRedo = FALSE# ) THEN
--
--
--
--
 
      IF (dbinc_rlgscn < df_rlgscn) THEN
         deb(DEB_IN, 'dbinc_rlgscn < df_rlgscn (' || to_char(dbinc_rlgscn) ||
             ' < ' || to_char(df_rlgscn) || ')');
         deb(DEB_EXIT,'computeRecoveryActions2 - 1 with FALSE');
         RETURN FALSE;
      ELSIF (dbinc_rlgscn = df_rlgscn AND dbinc_rlgtime <> df_rlgtime) THEN
         deb(DEB_IN, 'dbinc_rlgtime <> df_rlgtime');
         deb(DEB_EXIT,'computeRecoveryActions2 - 2 with FALSE');
         RETURN FALSE;
      END IF;
   END IF;
 
   IF (not test_search) THEN
--
--
      deb(DEB_IN, ' This is ancestor.');
      isAncestor := TRUE;
   ELSE
      isAncestor := FALSE;
   END IF;
 
   openRecoveryActionCursor( dbincKey     => dbinc_key
                            ,fno          => fno
                            ,creSCN       => crescn
                            ,dfCkpSCN     => df_ckpscn
                            ,dbincRlgSCN  => dbinc_rlgscn
                            ,dbincRlgTime => dbinc_rlgtime
                            ,offlSCN      => offlscn
                            ,onlSCN       => onlscn
                            ,onlTime      => onltime
                            ,cleanSCN     => cleanscn
                            ,clean2SCN    => clean2scn
                            ,clean2Time   => clean2time
                            ,targetSCN    => target_scn
                            ,rmanCmd      => rmanCmd
                            ,foreignDbid  => foreignDbid
                            ,pluggedRonly => pluggedRonly
                            ,pluginSCN    => pluginSCN
                            ,pluginRlgSCN => pluginRlgSCN
                            ,pluginRlgTime=> pluginRlgTime);
 
--
--
--
 
<<action_loop>>
   LOOP
      <<next_row>>
     IF (fetchRecoveryAction(  dbincKey     => dbinc_key
                              ,fno          => fno
                              ,creSCN       => crescn
                              ,dfCkpSCN     => df_ckpscn
                              ,dbincRlgSCN  => dbinc_rlgscn
                              ,dbincRlgTime => dbinc_rlgtime
                              ,offlSCN      => offlscn
                              ,onlSCN       => onlscn
                              ,onlTime      => onltime
                              ,cleanSCN     => cleanscn
                              ,clean2SCN    => clean2scn
                              ,clean2Time   => clean2time
                              ,targetSCN    => target_scn
                              ,action       => action
                              ,rmanCmd      => rmanCmd
                              ,foreignDbid  => foreignDbid
                              ,pluggedRonly => pluggedRonly
                              ,pluginSCN    => pluginSCN
                              ,pluginRlgSCN => pluginRlgSCN
                              ,pluginRlgTime=> pluginRlgTime)) THEN
         deb(DEB_PRINT, 'fetched recovery action');
         printRcvRec(action);
 
--
--
--
 
         IF (bitand(action.type_con, backupMask_con_t) > 0 AND
             action.toSCN_act = target_scn) THEN
            deb(DEB_IN, ' This is ancestor.');
            isAncestor := TRUE;
         END IF;
 
         IF (action.type_con = offlineRangeRec_con_t) THEN
--
--
--
            deb(DEB_IN, ' found an offline range' ||
                ' from=' || to_char(action.fromSCN_act) ||
                ' to=' || to_char(action.toSCN_act));
 
            IF (action.type_act = spanningRange_act_t) THEN
--
--
--
               deb(DEB_IN, ' offline range started before this resetlogs SCN');
 
--
--
--
               addAction_rc := action_OK;
            ELSE
               addAction_rc := addAction(actionIN      => action,
                                         partial_rcv   => partial_rcv,
                                         isAncestor    => isAncestor,
                                         cf_scn        => cf_scn,
                                         cf_cretime    => cf_cretime,
                                         cf_offrrid    => cf_offrrid,
                                         doingRecovery => doingRecovery,
                                         rmanCmd       => rmanCmd,
                                         pdbId         => pdbId,
                                         cleanSCN      => cleanSCN);
            END IF;
         ELSIF (action.type_con = backupSet_con_t AND
                action.type_act = incremental_act_t) THEN
--
--
--
            deb(DEB_IN, 'found an incremental backup set');
 
            addAction_rc := addAction(actionIN      => action,
                                      partial_rcv   => partial_rcv,
                                      isAncestor    => isAncestor,
                                      allCopies     => allCopies,
                                      doingRecovery => doingRecovery,
                                      rmanCmd       => rmanCmd,
                                      pdbId         => pdbId,
                                      cleanSCN      => cleanSCN);
         ELSIF (action.type_act = full_act_t) THEN
--
--
--
            deb(DEB_IN, 'found a copy/full/level0/proxy copy');
 
            IF (doingRecovery) THEN                  -- if doing a RECOVER
--
--
--
--
--
--
               IF (rmanCmd = rcvCopyCmd_t) THEN
                  addAction_rc := addAction(actionIN      => action,
                                            partial_rcv   => partial_rcv,
                                            isAncestor    => isAncestor,
                                            allCopies     => allCopies,
                                            doingRecovery => doingRecovery,
                                            rmanCmd       => rmanCmd,
                                            pdbId         => pdbId,
                                            cleanSCN      => cleanSCN);
               ELSE
                  IF (isAncestor) THEN
                     rcvRecTop(lastAction);
                     IF (not redoNeeded(action) OR
                         canAddRedo(isAncestor,
                                    action.toSCN_act, action.rlgSCN_act,
                                    lastAction, partial_rcv, doingRecovery) <>
                         action_OLD_REDO) THEN
                        computeRA_restorable := TRUE;
                     END IF;
                  END IF;
                  addAction_rc := action_SKIP;
               END IF;
            ELSE                                -- not doing a RECOVER
               addAction_rc := addAction(actionIN      => action,
                                         partial_rcv   => partial_rcv,
                                         isAncestor    => isAncestor,
                                         allCopies     => allCopies,
                                         doingRecovery => doingRecovery,
                                         rmanCmd       => rmanCmd,
                                         pdbId         => pdbId,
                                         cleanSCN      => cleanSCN);
            END IF;
         ELSE
--
--
--
            deb(DEB_IN, 'unknown container type: ' ||
                 to_char(action.type_con) ||
                ' or action type: ' || to_char(action.type_act));
 
--
--
            deb(DEB_EXIT, 'with error 20999');
            raise_application_error(-20999, 'unknown action kind');
         END IF;                                -- "switch" on ACTION.KIND
 
--
--
--
 
         deb(DEB_IN, 'addAction returned code ' || to_char(addAction_rc));
 
         IF (addAction_rc = action_OK) THEN     -- the action was added
 
--
--
--
 
            IF (action.type_act = full_act_t AND
                this_baseline_cap >= 0 AND
                (action.toSCN_act < this_baseline_cap_scn OR
                 this_baseline_cap_scn IS NULL)) THEN
               deb(DEB_IN, 'Found a backup older than baseline_cap');
               done := TRUE;
               deb(DEB_PRINT,'done set to true - 0');
               EXIT action_loop;
            END IF;
 
            IF (rcvRecStackState.savePoint > 0 AND
                computeRA_allRecords = FALSE#  AND
                rcvRecStackState.fullBackups >= computeRA_fullBackups) THEN
--
--
--
--
--
               deb(DEB_IN, 'savePoint > 0' ||
                   ' and computeRA_allRecords = FALSE#');
               done := TRUE;
               deb(DEB_PRINT,'done set to true - 1');
               EXIT action_loop;
            END IF;
 
            IF (doingRecovery) THEN                   -- if doing RECOVER
               IF (action.type_con = offlineRangeRec_con_t) THEN
--
--
                  IF (df_ckpscn = action.fromSCN_act) THEN
                     done := TRUE;
                     deb(DEB_PRINT,'done set to true - 2');
                     EXIT action_loop;
                  END IF;
               ELSE
--
--
                  IF (df_ckpscn >= action.fromSCN_act) THEN
                     done := TRUE;
                     deb(DEB_PRINT,'done set to true - 3');
                     EXIT action_loop;
                  END IF;
               END IF;
            END IF;
 
--
--
--
 
--
--
--
--
 
            IF (action.type_con = offlineRangeRec_con_t AND
                action.fromSCN_act < dbinc_rlgscn AND
                canApplyAnyRedo = FALSE#) THEN
 
               deb(DEB_IN, 'offline range spanning a resetlogs');
 
--
--
--
--
--
--
 
--
 
               SELECT parent_dbinc_key
                 INTO parentDbincKey
                 FROM dbinc
                WHERE dbinc.dbinc_key = computeRecoveryActions2.dbinc_key;
 
               IF (parentDbincKey is null) THEN -- we don't know our parent
 
--
--
--
--
--
--
                  deb(DEB_OPEN, 'dbinc_cursor');
                  OPEN dbinc_cursor(this_db_key, dbinc_rlgscn);
 
                  deb(DEB_IN,
                      'doing scan of all possible parent incarnations, top=' ||
                      to_char(rcvRecStack.last));
 
                  <<dbinc_loop>>
                  LOOP
                     FETCH dbinc_cursor
                      INTO dbinc_row;
                     EXIT WHEN dbinc_cursor%NOTFOUND;
                     deb(DEB_IN,
                         'starting test search of incarnation key=' ||
                         to_char(dbinc_row.dbinc_key));
 
                     savedrcvRecStackState := rcvRecStackState;
                     rcvRecStackState.top := rcvRecStack.last;
 
                     savedBackupAge        := thisBackupAge;
 
--
--
--
 
                     thisBackupAge         := rcvRecBackupAge;
 
                     rc := computeRecoveryActions2(fno, crescn, cretime,
                                                  df_rlgscn, df_rlgtime,
                                                  df_ckpscn,
                                                  offlscn,
                                                  onlscn, onltime,
                                                  cleanscn,
                                                  clean2scn, clean2time,
                                                  allowfuzzy, partial_rcv,
                                    rcvRecStack(rcvRecStack.count).fromSCN_act,
                                                  dbinc_row.dbinc_key,
                                                  cf_scn, cf_cretime,
                                                  cf_offrrid,
                                                  TRUE, done_flag, allCopies,
                                                  doingRecovery,
                                                  rmanCmd, foreignDbid,
                                                  pluggedRonly, pluginSCN,
                                                  pluginRlgSCN, pluginRlgTime,
                                                  creation_thread,
                                                  creation_size, pdbId,
                                                  pdbForeignDbid);
 
--
--
--
--
                     deb(DEB_IN, 'last=' || to_char(rcvRecStack.last) ||
                         ' trimming last ' ||
                         to_char(rcvRecStack.last - rcvRecStackState.top)
                        );
                     rcvRecStack.trim(rcvRecStack.last - rcvRecStackState.top);
                     rcvRecStackState      := savedrcvRecStackState;
                     deb(DEB_PRINT,'restoring rcvRecStackCount after test search'||rcvRecStack.count);
                     thisBackupAge         := savedBackupAge;
                     deb(DEB_IN, 'count is now '|| to_char(rcvRecStack.count));
 
                     IF (rc) THEN
--
--
--
--
--
--
--
--
--
--
--
--
--
                        IF (parentDbincKey is null) THEN
                           parentDbincKey := dbinc_row.dbinc_key;
                        ELSE
--
--
--
                           deb(DEB_IN,
                               'aborting search due to ambiguous ancestory');
                           CLOSE dbinc_cursor;
                           EXIT action_loop;
                        END IF;
                     END IF;
                  END LOOP;     -- dbinc_loop
               END IF;          -- if we don't know our parent
 
--
--
               IF (parentDbincKey is not null) THEN
                  deb(DEB_IN, 'starting search of parent incarnation key='||
                      to_char(parentDbincKey));
                  rc := computeRecoveryActions2(fno, crescn, cretime,
                                               df_rlgscn, df_rlgtime,
                                               df_ckpscn,
                                               offlscn,
                                               onlscn, onltime,
                                               cleanscn,
                                               clean2scn, clean2time,
                                               allowfuzzy, partial_rcv,
                                     rcvRecStack(rcvRecStack.last).fromSCN_act,
                                               parentDbincKey,
                                               cf_scn, cf_cretime,
                                               cf_offrrid,
                                               FALSE, done_flag, allCopies,
                                               doingRecovery,
                                               rmanCmd, foreignDbid,
                                               pluggedRonly, pluginSCN,
                                               pluginRlgSCN, pluginRlgTime,
                                               creation_thread,
                                               creation_size, pdbId,
                                               pdbForeignDbid);
                  IF (done_flag) THEN
                     deb(DEB_PRINT,'done set to true - 4');
                     done := TRUE;
                  END IF;
 
                  IF (action.type_act = spanningRange_act_t) THEN
--
--
--
--
--
--
                     isAncestor := rc;
                  END IF;
               END IF;          -- we know or found our parent
               EXIT action_loop;
            END IF;             -- offline range start SCN < dbinc_rlgscn
         ELSIF (addAction_rc = action_FAIL) THEN         -- FAIL
--
--
            NULL;
         ELSIF (addAction_rc = action_SKIP) THEN        -- SKIP
--
            NULL;
         ELSIF (addAction_rc = action_OLD_REDO) THEN    -- OLD_REDO
--
--
--
--
--
--
            EXIT action_loop;
         ELSE                                   -- unknown return code
            deb(DEB_EXIT, 'with error 20999');
            raise_application_error(-20999, 'unknown add action return code');
         END IF;
      ELSE                                      -- rcvRecCursor exhausted
         deb(DEB_IN, 'end of cursor reached');
         EXIT action_loop;
      END IF;                                   -- if fetchRecoveryAction
   END LOOP;
 
   IF (done) THEN
      deb(DEB_EXIT,'computeRecoveryActions2 - 3');
      RETURN isAncestor;
   END IF;
 
--
--
--
 
   IF (doingRecovery) THEN                      -- if doing RECOVER
      deb(DEB_PRINT,'computeRecoveryActions2:recovery final check');
      deb(DEB_IN, 'crescn=' || crescn ||';this_reset_scn='||this_reset_scn);
      deb(DEB_IN, 'df_rlgscn='||df_rlgscn||';df_rlgtime='||
                  to_char(df_rlgtime));
 
      IF (rmanCmd = rcvCopyCmd_t) THEN
--
--
--
         deb(DEB_PRINT,'computeRecoveryActions2: no copies stacked');
         resetrcvRecStack;
         done := FALSE;
      ELSIF (rcvRecStack.count > 0) THEN           -- if found some action
         deb(DEB_PRINT,'computeRecoveryActions2:'|| rcvRecStack.count ||
                       ' actions stacked');
--
--
--
--
         rcvRecTop(lastAction);
         stack_df_rlgscn := df_rlgscn;
         IF (df_rlgscn is NULL) THEN
            stack_df_rlgscn := this_reset_scn;
         END IF;
         addRedo_rc := addRedo(isAncestor, df_ckpscn, stack_df_rlgscn,
                               lastAction, partial_rcv, doingRecovery);
         IF (addRedo_rc = action_OK OR addRedo_rc = action_FAIL
             OR addRedo_rc = action_OLD_INC_REDO) THEN
--
--
--
--
--
--
            done := TRUE;
         END IF;
         IF (addRedo_rc = action_OLD_INC_REDO) THEN
--
            rcvRecStack.trim(rcvRecStack.count);
         END IF;
      ELSE
         deb(DEB_PRINT,'computeRecoveryActions2: no actions stacked');
--
--
         IF (df_rlgscn = this_reset_scn AND
             df_rlgtime = this_reset_time) THEN
            done := TRUE;
         ELSIF (action_OLD_INC_REDO =
                        addRedo(isAncestor, df_ckpscn, df_rlgscn,
                               null, partial_rcv, doingRecovery)) THEN
            done := TRUE;
         END IF;
--
--
--
         IF (df_rlgscn is NULL AND           -- df may be created during rcv
             cretime > cf_cretime  AND       -- df created after cf creation
             crescn >  nvl(inc_list(max_inc_idx-1).prior_resetlogs_change#,
                           inc_list(max_inc_idx-1).resetlogs_change#)) THEN
--
            done := TRUE;
         END IF;
      END IF;
   ELSE                                         -- not doing a RECOVER
--
--
--
      IF (rcvRecStackState.savePoint = 0) THEN
--
--
--
--
--
         deb(DEB_IN, 'could try create datafile');
 
         rcvRecStack.trim(rcvRecStack.count - rcvRecStackState.top);
         rcvRecStackState.lowAction := rcvRecStack.count;
         deb(DEB_IN, 'rcvRecStackState :' || rcvRecStackState.top || ' ' ||
                      rcvRecStackState.savePoint || ' ' ||
                      rcvRecStackState.lowAction);
--
 
--
--
--
--
--
--
         IF ((computeRA_available = FALSE)  AND    -- no backup found
             pluginSCN = 0                  AND    -- not a plugin file
             foreignDbid = 0                AND    -- not a foreign file
             pdbForeignDbid = 0             AND    -- not a pdb plugin file
             (creation_thread IS NULL or creation_thread > 0) AND
--
             (creation_size IS NULL or creation_size > 0) AND
--
             (cretime > cf_cretime)  AND           -- df created after cf
             (crescn >  nvl(inc_list(max_inc_idx-1).prior_resetlogs_change#,
                            inc_list(max_inc_idx-1).resetlogs_change#)) AND
--
             (bitand(createdatafile_act_t, getRA_actionMask) != 0) AND
--
             restoreTag is null) THEN              -- from tag not specified
             action          := null_action;
             action.type_con := datafile_con_t;
             action.type_act := createdatafile_act_t;
             action.dfNumber_obj := fno;
             action.dfCreationSCN_obj := crescn;
             action.fromSCN_act := 0;
             action.toSCN_act := crescn;
             action.toTime_act := cretime;
             action.pluggedRonly_obj := 0;
             action.pluginSCN_obj := 0;
             FOR inc_idx in 0..max_inc_idx-1 LOOP
                IF (crescn > inc_list(inc_idx).resetlogs_change#) THEN
                    deb(DEB_PRINT, 'data file created with resetlogs scn='||
                                    inc_list(inc_idx).resetlogs_change#);
                    action.rlgSCN_act := inc_list(inc_idx).resetlogs_change#;
                    action.rlgTime_act := inc_list(inc_idx).resetlogs_time;
                    exit;
                END IF;
             END LOOP;
             IF (action.rlgSCN_act IS NULL) THEN
                deb(DEB_IN, 'rlgSCN is null');
                addAction_rc := action_FAIL;
             ELSE
                addAction_rc := addAction(actionIN      => action,
                                          partial_rcv   => partial_rcv,
                                          isAncestor    => isAncestor,
                                          allCopies     => allCopies,
                                          doingRecovery => doingRecovery,
                                          rmanCmd       => rmanCmd,
                                          pdbId         => pdbId,
                                          cleanSCN      => cleanSCN);
             END IF;
 
             IF (addAction_rc = action_OK) THEN     -- the action was added
                done := TRUE;
                deb(DEB_IN, 'added create datafile action for '||fno);
             ELSE
                deb(DEB_IN, 'failed to add create datafile action for '||fno);
             END IF;
         END IF;
         IF computeRA_available = TRUE THEN
           deb(DEB_IN, 'need different device type channels to restore');
         END IF;
      ELSE
--
--
--
--
--
         deb(DEB_IN, 'trim all actions after savePoint='||
                to_char(greatest(rcvRecStackState.savePoint,
                                 rcvRecStackState.top)));
         rcvRecStack.trim(rcvRecStack.last -
                          greatest(rcvRecStackState.savePoint,
                                   rcvRecStackState.top));
         done := TRUE;
      END IF;
      deb(DEB_PRINT,'computeRecoveryActions2: set rcvRecStackCount='||rcvRecStack.count);
   END IF;                                      -- if doing recover
 
   IF (done) THEN
      deb(DEB_IN, 'done is TRUE');
   ELSE
      deb(DEB_IN, 'done is FALSE');
   END IF;
 
   deb(DEB_EXIT,'computeRecoveryActions2 - 4');
   RETURN isAncestor;
 
END computeRecoveryActions2;
 
--
FUNCTION getParentIncarnation(
   dbinc_key         OUT number
  ,resetlogs_change# OUT number)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'getParentIncarnation');
 
   SELECT resetlogs_change#, parent_dbinc_key
     INTO resetlogs_change#, dbinc_key
     FROM rc_database_incarnation where dbinc_key = getParentIncarnationKey;
   deb(DEB_EXIT, 'with: TRUE#');
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END getParentIncarnation;
 
--
--
--
FUNCTION getPointInTimeInc(
   toscn IN number)
RETURN NUMBER IS
   pitrlgscn  number;
BEGIN
   IF (getPointInTimeInc.toscn >= this_reset_scn) THEN
      RETURN this_reset_scn;
   END IF;
 
   SELECT dbinc.reset_scn
     INTO pitrlgscn
     FROM (SELECT reset_scn, PRIOR reset_scn next_reset_scn
             FROM dbinc
            START WITH dbinc_key = this_dbinc_key
             CONNECT BY PRIOR parent_dbinc_key = dbinc_key) dbinc
    WHERE dbinc.reset_scn <= getPointInTimeInc.toscn
      AND dbinc.next_reset_scn > getPointInTimeInc.toscn;
 
   RETURN pitrlgscn;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
END getPointInTimeInc;
 
--
--
--
--
 
FUNCTION get_cfUntilScn
RETURN number IS
  ret_scn number := untilSCN;
  max_scn number;
  max_tag bp.tag%type;
--
  CURSOR keepscn(scn NUMBER) IS
   SELECT bckscn, tag
   FROM
   (SELECT brl.next_scn bckscn, bp.tag
    FROM bs, brl, bp
    WHERE bs.bs_key = brl.bs_key
      AND bs.bs_key = bp.bs_key
      AND bs.keep_options > 0
      AND bp.status = 'A'
      AND brl.low_scn <= scn
      AND brl.next_scn > scn
      AND this_site_key = bs.site_key
      AND this_dbinc_key = dbinc_key
   UNION
    SELECT xal.next_scn bckscn, xal.tag
    FROM xal
    WHERE xal.keep_options > 0
      AND xal.status = 'A'
      AND xal.low_scn <= scn
      AND xal.next_scn > scn
      AND this_site_key = xal.site_key
      AND this_dbinc_key = dbinc_key
   UNION
    SELECT bdf.ckp_scn bckscn, bp.tag
    FROM bs, bdf, bp
    WHERE bs.bs_key = bdf.bs_key
      AND bs.bs_key = bp.bs_key
      AND bs.keep_options > 0
      AND bp.status = 'A'
      AND bdf.ckp_scn = scn+1
      AND this_site_key = bs.site_key
      AND this_dbinc_key = dbinc_key
   UNION
    SELECT xdf.ckp_scn bckscn, xdf.tag
    FROM xdf
    WHERE xdf.keep_options > 0
      AND xdf.status = 'A'
      AND xdf.ckp_scn = scn+1
      AND this_site_key = xdf.site_key
      AND this_dbinc_key = dbinc_key)
   ORDER BY bckscn DESC;
BEGIN
   IF rpoint_set THEN
--
      OPEN keepscn(untilSCN - 1);
      FETCH keepscn INTO max_scn, max_tag;
      CLOSE keepscn;
 
--
      SELECT NVL(MIN(cfscn)+1, untilSCN) INTO ret_scn
      FROM
       (SELECT bcf.ckp_scn cfscn
        FROM bcf, bs, bp
        WHERE bcf.bs_key = bs.bs_key
          AND bs.bs_key = bp.bs_key
          AND bp.status = 'A'
          AND this_site_key = bs.site_key
          AND this_dbinc_key = dbinc_key
          AND bp.tag = max_tag
          AND bcf.ckp_scn > max_scn
       UNION ALL
        SELECT ckp_scn
        FROM ccf
        WHERE this_site_key = site_key
          AND this_dbinc_key = dbinc_key
          AND status = 'A'
          AND tag = max_tag
          AND ckp_scn > max_scn
       UNION ALL
        SELECT ckp_scn
        FROM xcf
        WHERE this_site_key = site_key
          AND this_dbinc_key = dbinc_key
          AND status = 'A'
          AND tag = max_tag
          AND ckp_scn > max_scn);
   deb(DEB_PRINT, 'new scn is ' || ret_scn);
   END IF;
 
   RETURN ret_scn;
END get_cfUntilScn;
 
--
--
 
FUNCTION IsDuplicateAlName(samelog IN number, filename varchar2)
RETURN BOOLEAN IS
  duplicate number;
BEGIN
--
--
--
--
   duplicate := FALSE#;
   IF (samelog = TRUE#) THEN
       FOR log_idx in 0..max_lognames_idx-1 LOOP
          IF lognames_list(log_idx) = filename THEN
            duplicate := TRUE#;
            EXIT;
          END IF;
       END LOOP;
       lognames_list(max_lognames_idx) := filename;
       max_lognames_idx := max_lognames_idx + 1;
   ELSE
     lognames_list(0) := filename;
     max_lognames_idx := 1;
   END IF;
 
   IF duplicate = TRUE# THEN
     deb(DEB_PRINT, 'Filter duplicate log name' || filename);
     RETURN TRUE;
   ELSE
     RETURN FALSE;
   END IF;
 
END IsDuplicateAlName;
 
--
--
--
 
--
--
--
PROCEDURE getCurrentIncarnation(
   db_id          IN  number
  ,reset_scn      OUT number
  ,reset_time     OUT date) IS
BEGIN
   deb(DEB_ENTER, ' getCurrentIncarnation');
   deb(DEB_IN, ' db_id=' || to_char(db_id));
   SELECT  dbinc.reset_scn, dbinc.reset_time
      INTO reset_scn, reset_time
      FROM db, dbinc
      WHERE db_id = getCurrentIncarnation.db_id       -- should return 1 row
      AND dbinc.dbinc_key = db.curr_dbinc_key;
   deb(DEB_EXIT, 'reset_scn='||reset_scn||' reset_time='||reset_time);
 EXCEPTION
    WHEN no_data_found THEN
       deb(DEB_EXIT, 'with error 20001');
       raise_application_error(-20001, 'Database not found');
END;
 
--
--
--
FUNCTION getPrimaryDfName(
     fno IN number)
RETURN varchar2 IS
  local_fname  varchar2(513);
BEGIN
  SELECT fname INTO local_fname
  FROM site_dfatt s, df, node
  WHERE node.database_role = 'PRIMARY'
    AND node.db_key = this_db_key
    AND node.site_key = s.site_key
    AND s.df_key = df.df_key
    AND df.dbinc_key = node.dbinc_key
    AND df.file# = fno
    AND df.dbinc_key = this_dbinc_key
    AND df.drop_scn is NULL
    AND ROWNUM=1;
  RETURN local_fname;
END getPrimaryDfName;
 
--
PROCEDURE setDbincLst
IS
   CURSOR inc_record_c IS
     SELECT * from rc_database_incarnation
       WHERE db_key=this_db_key
         START WITH dbinc_key=this_dbinc_key
         CONNECT BY PRIOR parent_dbinc_key = dbinc_key
       ORDER BY resetlogs_change# DESC;
 
   CURSOR pdb_inc_record_c IS
      SELECT pdbinc.con_id con_id, pdbinc.pdbinc_key,
             pdbinc.inc_scn incscn, pdbinc.end_reset_scn erscn,
             pdbinc_status status
        FROM rci_pdbinc_this_dbinc pdbinc
       WHERE pdbinc.dbinc_key = this_dbinc_key
         AND pdbinc.con_id > 1
       ORDER BY pdbinc.con_id, pdbinc.end_reset_scn DESC;
 
   inc_rec       rc_database_incarnation%ROWTYPE;
   inc_idx       binary_integer;
   pdb_inc_set   pdb_incarnation_set_t;
   pdb_inc_rec   pdb_incarnation_t;
 
BEGIN
   deb(DEB_ENTER, 'setDbincLst');
   IF this_dbinc_key is  NULL OR this_db_key is  NULL THEN
      raise_application_error(-20999, 'internal err: setDbincLst-1');
   END IF;
 
   deb(DEB_PRINT, 'Setting incarnation records as per this_dbinc_key');
   inc_idx := 0;
   FOR inc_rec IN inc_record_c LOOP
      inc_list(inc_idx) := inc_rec;
      deb(DEB_PRINT, 'incarnation record id=' || inc_idx);
      deb(DEB_PRINT, 'icprs=' ||inc_list(inc_idx).prior_resetlogs_change# ||
                     ',icprc='|| inc_list(inc_idx).prior_resetlogs_time);
      deb(DEB_PRINT, 'icrls=' || inc_list(inc_idx).resetlogs_change# ||
                     ',icrlc='|| inc_list(inc_idx).resetlogs_time);
      deb(DEB_PRINT, 'icpinc=' || inc_list(inc_idx).parent_dbinc_key);
      deb(DEB_PRINT, 'icflg=' || inc_list(inc_idx).status);
      inc_idx := inc_idx + 1;
   END LOOP;
 
   max_inc_idx := inc_idx;
   deb(DEB_PRINT, 'number of incarnation=' || max_inc_idx);
 
--
   deb(DEB_PRINT, 'Fetching pdb sub incarnation records');
   pdb_inc_list.delete;
   FOR pdb_inc_rec in pdb_inc_record_c LOOP
      IF (NOT pdb_inc_list.exists(pdb_inc_rec.con_id)) THEN
         pdb_inc_list(pdb_inc_rec.con_id) := pdb_inc_set;
      END IF;
      inc_idx := pdb_inc_list(pdb_inc_rec.con_id).count;
      pdb_inc_list(pdb_inc_rec.con_id)(inc_idx) := pdb_inc_rec;
      deb(DEB_PRINT, 'incarnation record id=' || inc_idx);
      deb(DEB_PRINT, 'con_id='     || pdb_inc_rec.con_id ||  
                    ',pdbinc_key=' || pdb_inc_rec.pdbinc_key);
      deb(DEB_PRINT, 'incscn='     || pdb_inc_rec.incscn ||  
                    ',erscn='      || pdb_inc_rec.erscn);    
      deb(DEB_PRINT, 'status='     || pdb_inc_rec.status);
   END LOOP;
 
   deb(DEB_EXIT);
END setDbincLst;
 
--
--
--
 
--
PROCEDURE setDatabase(
   db_name        IN varchar2
  ,reset_scn      IN number
  ,reset_time     IN date
  ,db_id          IN number
  ,db_unique_name IN varchar2 default NULL
  ,site_aware     IN boolean default FALSE
  ,dummy_instance IN boolean default FALSE
  ,ors_instance   IN boolean default FALSE)
IS
   local        dbinc%rowtype;                    -- local variables
   dbnm         dbinc.db_name%TYPE;
   dbnm_in      dbinc.db_name%TYPE;
   current_inc  varchar2(3);
   rid          varchar2(18);
   ever_resynced number;
BEGIN
   deb(DEB_ENTER, 'setDatabase');
   this_db_key := NULL;                  -- clear in case exception raised
   this_dbinc_key := NULL;
   this_reset_scn := NULL;
   this_reset_time := NULL;
   this_db_unique_name := NULL;
   translation_site_key := NULL;
   this_site_key := NULL;
   dbnm_in := upper(db_name);
 
--
   BEGIN
      SELECT null
        INTO local.db_key
        FROM rcver
       WHERE version = catalogVersion;
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_EXIT, 'with error 20299');
         raise_application_error(-20299, 'Recovery catalog version mismatch');
   END;
 
--
--
--
--
 
   IF (db_id is not NULL) THEN
      deb(DEB_IN, ' db_id=' || to_char(db_id));
      IF dbms_rcvcat.registerDbPending.dbid = db_id THEN
        dbms_rcvcat.registerDatabase(
          db_id, dbnm_in, reset_scn, reset_time, db_unique_name,
          dbms_rcvcat.registerDbPending.con_id,
          dbms_rcvcat.registerDbPending.guid);
      END IF;  
      BEGIN
         SELECT db.db_key, curr_dbinc_key,
                dbinc.reset_scn, dbinc.reset_time, dbinc.db_name
           INTO local.db_key, local.dbinc_key,
                local.reset_scn, local.reset_time, local.db_name
           FROM db, dbinc
          WHERE db_id = setDatabase.db_id       -- should return 1 row
            AND dbinc.dbinc_key = db.curr_dbinc_key;
      EXCEPTION
         WHEN no_data_found THEN
            deb(DEB_EXIT, 'with error 20001');
            raise_application_error(-20001, 'Database not found');
      END;
 
--
      IF (dbnm_in is NOT NULL) THEN
--
--
--
--
         BEGIN
            SELECT decode(dbinc.dbinc_key, db.curr_dbinc_key, 'YES', 'NO'),
                   dbinc.db_name, dbinc.rowid
              INTO current_inc,
                   dbnm,
                   rid
              FROM db, dbinc
             WHERE db.db_key = dbinc.db_key
               AND db.db_id = setDatabase.db_id
               AND dbinc.reset_scn = setDatabase.reset_scn
               AND dbinc.reset_time = setDatabase.reset_time;
         EXCEPTION
            WHEN no_data_found THEN
               deb(DEB_EXIT, 'with error 20003');
               raise_application_error(-20003,
                                       'Database incarnation not found');
         END;
 
         IF (current_inc = 'NO') THEN
            deb(DEB_EXIT, 'with error 20011');
            raise_application_error(-20011,
                                    'Database incarnation not current');
         END IF;
         IF (dbnm != dbnm_in) THEN
            deb(DEB_PRINT, 'DB_NAME changed from '||dbnm||' to '|| dbnm_in);
            UPDATE dbinc
               SET dbinc.db_name = dbnm_in
             WHERE rowid = rid;
            COMMIT;
         END IF;
      END IF;
   ELSIF (dbnm_in is NOT NULL) THEN
--
      deb(DEB_IN, 'db_id is null');
      BEGIN
         SELECT db.db_key, db.curr_dbinc_key, dbinc.reset_scn, dbinc.reset_time
           INTO local.db_key, local.dbinc_key,
                local.reset_scn, local.reset_time
           FROM db, dbinc
          WHERE db.curr_dbinc_key = dbinc.dbinc_key
            AND dbinc.db_name = dbnm_in;
      EXCEPTION
         WHEN no_data_found THEN
            deb(DEB_EXIT, 'with error 20001');
            raise_application_error(-20001, 'Database not found');
         WHEN too_many_rows THEN
            deb(DEB_EXIT, 'with error 20005');
            raise_application_error(-20005, 'Database name is ambiguous');
      END;
   ELSE
      deb(DEB_EXIT, 'with error 20006');
      raise_application_error(-20006, 'Database name is missing');
   END IF;
 
--
--
   IF dummy_instance THEN
      deb(DEB_PRINT, 'dummy_instance is TRUE');
      this_dummy_instance := TRUE;
   END IF;
   this_db_unique_name := upper(db_unique_name);
   this_db_key         := local.db_key;
   this_dbinc_key      := local.dbinc_key;
   this_reset_scn      := local.reset_scn;
   this_reset_time     := local.reset_time;
 
--
--
--
   IF ors_instance THEN
      IF db_unique_name IS NULL THEN
         raise_application_error(-20999,
           'internal error:db_unique_name must be specified for ORS instance');
      END IF;
      IF db_id IS NULL THEN
         raise_application_error(-20999,
           'internal error: db_id must be specified for ORS instance');
      END IF;
      IF instr(this_db_unique_name, '$'|| db_id) = 0 THEN
         this_db_unique_name := this_db_unique_name || '$' || db_id;
      END IF;
      IF substr(this_db_unique_name, 1, 1) <> '$' THEN
         this_db_unique_name := '$' || this_db_unique_name;
      END IF;
   END IF;
 
 
   deb(DEB_PRINT, 'this_db_unique_name= ' || this_db_unique_name);
   deb(DEB_PRINT, 'this_site_key= ' || this_site_key);
   deb(DEB_PRINT, 'this_db_key='||this_db_key);
   deb(DEB_PRINT, 'this_dbinc_key='||this_dbinc_key);
 
   setDbincLst;
 
   BEGIN
      SELECT site_key into this_site_key FROM node
         where db_unique_name=upper(this_db_unique_name)
           AND db_key = this_db_key;
      deb(DEB_PRINT, 'this_site_key=' || this_site_key);
   EXCEPTION
      WHEN no_data_found THEN
        deb(DEB_PRINT, 'this_site_key is NULL');
   END;
 
   BEGIN
      IF site_aware THEN
         client_site_aware := 1;
         deb(DEB_PRINT, 'client_site_aware=' || client_site_aware);
      END IF;
 
      IF NOT ors_instance AND site_aware AND this_site_key is not NULL THEN
        translation_site_key := this_site_key;
        deb(DEB_PRINT, 'translation_site_key=' || translation_site_key);
      ELSE
        BEGIN
           SELECT site_key into translation_site_key FROM node
              WHERE database_role='PRIMARY'
                AND db_key = this_db_key;
           deb(DEB_PRINT, 'translation_site_key(primary)=' ||
                          translation_site_key);
        EXCEPTION
           WHEN no_data_found THEN
--
--
--
--
--
--
--
--
              select count(*) into ever_resynced from rci_datafile
                 where site_key = this_site_key;
              IF ever_resynced > 0 THEN
                 translation_site_key := this_site_key;
              ELSE
                 select max(site_key) into translation_site_key from node
                    where db_key=this_db_key;
              END IF;
              deb(DEB_PRINT, 'translation_site_key(no_data_found)=' ||
                          translation_site_key);
           WHEN too_many_rows THEN
--
--
--
--
              select max(site_key) into translation_site_key from node
                 where db_key=this_db_key
                   and database_role ='PRIMARY';
              deb(DEB_PRINT, 'translation_site_key(too_many_rows)=' ||
                          translation_site_key);
        END;
      END IF;
   EXCEPTION
      WHEN no_data_found THEN
        deb(DEB_PRINT, 'translation_site_key is NULL');
   END;
 
   IF site_aware AND this_site_key is NULL THEN
      this_site_key := translation_site_key;
      deb(DEB_PRINT, 'this_site_key is set to same  as translation_site_key');
   END IF;
 
   IF site_aware THEN
      setArchiveFileScopeAttributes(logs_shared => 0);
      setBackupFileScopeAttributes (disk_backups_shared => 0,
                                    tape_backups_shared => 1);
   END IF;
   deb(DEB_EXIT);
END setDatabase;
 
--
FUNCTION getDbUniqueName(
   db_id IN number)
RETURN varchar2
IS
   dbunqnm  node.db_unique_name%TYPE;
   CURSOR dbunqnm_c IS
      SELECT node.db_unique_name
        FROM node, db
       WHERE db.db_id  = getDbUniqueName.db_id
         AND db.db_key = node.db_key;
BEGIN
   SELECT node.db_unique_name
     INTO dbunqnm
     FROM node, db
    WHERE db.db_id  = getDbUniqueName.db_id
      AND db.db_key = node.db_key;
 
   RETURN dbunqnm;
EXCEPTION
   WHEN no_data_found THEN
      RETURN NULL;
END getDbUniqueName;
 
--
FUNCTION getDbKey RETURN NUMBER IS
BEGIN
   return this_db_key;
END;
 
--
FUNCTION getMinRcvStartScn RETURN NUMBER IS
   minrcvstartScn   NUMBER;
BEGIN
   SELECT NVL(min(LOW_SCN), 0)
     INTO minrcvstartScn
     FROM rrcache
    WHERE range_type = 'RA$DISK'
    AND db_key = this_db_key;
   RETURN minrcvstartScn;
END;
 
--
PROCEDURE resetDbKey IS
BEGIN 
  this_db_key := NULL;
END;
 
--
PROCEDURE setDbincKey(
   key IN number)
IS
BEGIN
   deb(DEB_ENTER, 'setDbincKey');
   IF (key is not null) THEN
      this_dbinc_key := key;
   ELSE
--
      SELECT curr_dbinc_key
        INTO this_dbinc_key
        FROM db;
   END IF;
 
   SELECT db_key, reset_scn, reset_time
     INTO this_db_key, this_reset_scn, this_reset_time
     FROM dbinc
    WHERE dbinc_key = this_dbinc_key;
 
   setDbincLst;
 
   deb(DEB_EXIT);
END setDbincKey;
 
--
FUNCTION getParentIncarnation(
   resetlogs_change# IN OUT number
  ,resetlogs_time    IN OUT date)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'getParentIncarnation');
--
--
   IF (resetlogs_change# is null) THEN
      getParentIncarnationKey := this_dbinc_key;
   END IF;
   SELECT resetlogs_change#, resetlogs_time, parent_dbinc_key
     INTO resetlogs_change#, resetlogs_time, getParentIncarnationKey
     FROM rc_database_incarnation where dbinc_key = getParentIncarnationKey;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END getParentIncarnation;
 
--
PROCEDURE getCheckpoint(
   scn OUT number
  ,seq OUT number
  ,ckp_key_1 OUT number
  ,ckp_key_2 OUT number)
 
IS
  full_row   ckp%ROWTYPE;
  either_row ckp%ROWTYPE;
BEGIN
   deb(DEB_ENTER, 'getCheckpoint');
   IF (this_dbinc_key is NULL) THEN
     deb(DEB_EXIT, 'with error 20020');
     raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
--
--
 
--
--
--
 
--
--
--
--
--
--
--
 
   FOR r IN (SELECT /*+ first_rows */ * FROM ckp
             WHERE dbinc_key = this_dbinc_key AND
                   ckp_type  = 'FULL' AND
                   site_key = this_site_key
             ORDER BY ckp_scn DESC, cf_create_time DESC, ckp_cf_seq DESC)
   LOOP
     full_row := r;
     EXIT;
   END LOOP;
 
   FOR r IN (SELECT /*+ first_rows */ * FROM ckp
             WHERE dbinc_key      = this_dbinc_key AND
                   cf_create_time = full_row.cf_create_time AND
                   site_key       = this_site_key
             ORDER BY ckp_scn DESC, ckp_cf_seq DESC, ckp_type DESC)
   LOOP
     either_row := r;
     EXIT;
   END LOOP;
 
   IF either_row.ckp_key IS NOT NULL THEN
      scn       := either_row.ckp_scn;
      seq       := either_row.ckp_cf_seq;
      ckp_key_1 := full_row.ckp_key;
      ckp_key_2 := either_row.ckp_key;
   ELSE
      scn       := 0;
      seq       := 0;
      ckp_key_1 := 0;
      ckp_key_2 := 0;
   END IF;
 
   deb(DEB_EXIT);
END getCheckpoint;
 
PROCEDURE getCheckpoint(
   scn OUT number
  ,seq OUT number)
 
IS
   ckp_key_1 number;
   ckp_key_2 number;
BEGIN
   getCheckpoint(scn, seq, ckp_key_1, ckp_key_2);
END getCheckpoint;
 
--
--
--
 
--
PROCEDURE setUntilTime(
   unttime IN date)
IS
    walk_dbinc_key  number := NULL;
    parent_dbinc_key  number := NULL;
BEGIN
   deb(DEB_ENTER, 'setUntilTime');
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   walk_dbinc_key := this_dbinc_key;
 
<<parent_inc>>
   untilSCN  := NULL;
   untilTime := unttime;
   rpoint_set := FALSE;
 
   BEGIN
      SELECT resetlogs_change#
         INTO untilSCN
         FROM rc_database_incarnation
      WHERE dbinc_key = walk_dbinc_key
         AND resetlogs_time < untilTime;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
            IF (allIncarnations = TRUE#) THEN
               SELECT parent_dbinc_key
                  INTO parent_dbinc_key
                  FROM dbinc
               WHERE dbinc.dbinc_key = walk_dbinc_key;
 
               walk_dbinc_key := parent_dbinc_key;
               IF (walk_dbinc_key IS NULL) THEN
                  deb(DEB_IN, 'parent_dbinc_key=NULL -> exiting');
                  untilSCN := 0;                         -- begining of world
               ELSE
                  deb(DEB_IN, 'parent_dbinc_key=' ||
                     to_char(parent_dbinc_key));
                  GOTO parent_inc;           -- get scn of parent incarnation
               END IF;
            ELSE
               deb(DEB_EXIT, 'with error 20207');
               raise_application_error(-20207,
                                 'until time is before resetlogs time');
            END IF;
         END;
   END;
 
   IF walk_dbinc_key != this_dbinc_key THEN
      actual_dbinc_key := walk_dbinc_key;
      deb(DEB_IN, 'actual_dbinc_key set to:  '||to_char(actual_dbinc_key));
   END IF;
 
--
--
--
--
--
   deb(DEB_IN, 'calling computeUntilSCN. untilSCN=  '||to_char(untilSCN));
   deb(DEB_IN, 'calling computeUntilSCN. untilTime= '||to_char(untilTime));
   computeUntilSCN(untilTime, untilSCN, allIncarnations);
   deb(DEB_IN, 'untilSCN= '||to_char(untilSCN));
   deb(DEB_EXIT, 'untilTime='||to_char(untilTime));
   IF (untilSCN IS NULL) THEN
      raise_application_error(-20213, 'UNTIL TIME could not be translated to 
                                       an UNTIL CHANGE');
   END IF;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with error 20207');
      raise_application_error(-20207, 'until time is before resetlogs time');
END setUntilTime;
 
--
PROCEDURE setUntilScn(
   scn     IN number
  ,rlgscn  IN number  DEFAULT NULL
  ,rlgtime IN date    DEFAULT NULL
  ,flbrp   IN boolean DEFAULT FALSE
  ,rpoint  IN boolean DEFAULT FALSE)
IS
   walk_dbinc_key    number := NULL;
   walk_dbinc_scn    number := NULL;
   walk_dbinc_time   date   := NULL;
   parent_dbinc_key  number := NULL;
BEGIN
   deb(DEB_ENTER, 'setUntilSCN');
 
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   IF (flbrp AND rlgscn IS NOT NULL AND rlgtime IS NOT NULL) THEN
--
--
      BEGIN
         SELECT dbinc_key
           INTO walk_dbinc_key
           FROM rc_database_incarnation
          WHERE resetlogs_change# = rlgscn
            AND resetlogs_time = rlgtime
            AND db_key = this_db_key;
      EXCEPTION
         WHEN no_data_found THEN
            deb(DEB_EXIT, 'with error 20212');
            raise_application_error(-20212,
                                    'until SCN is an orphan incarnation');
      END;
   ELSE
      walk_dbinc_Key := this_dbinc_key;
   END IF;
 
<<parent_inc>>
   untilSCN := scn;
   untilTime := NULL;
 
   BEGIN
      SELECT untilSCN, resetlogs_change#, resetlogs_time
         INTO untilSCN, walk_dbinc_scn, walk_dbinc_time
         FROM rc_database_incarnation
      WHERE dbinc_key = walk_dbinc_key
         AND resetlogs_change# < untilSCN;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
            IF (allIncarnations = TRUE#) THEN
               SELECT parent_dbinc_key
                  INTO parent_dbinc_key
                  FROM dbinc
               WHERE dbinc.dbinc_key = walk_dbinc_key;
 
               walk_dbinc_key := parent_dbinc_key;
               IF (walk_dbinc_key IS NULL) THEN
                  deb(DEB_EXIT, 'parent_dbinc_key=NULL, with error 20208');
                  raise_application_error(-20208,
                                    'until SCN is before resetlogs SCN');
               ELSE
                  deb(DEB_IN, 'parent_dbinc_key=' ||
                     to_char(parent_dbinc_key));
                  GOTO parent_inc;           -- get scn of parent incarnation
               END IF;
            ELSE
               deb(DEB_EXIT, 'with error 20208');
               raise_application_error(-20208,
                                 'until SCN is before resetlogs SCN');
            END IF;
         END;
   END;
 
   IF (rlgscn != walk_dbinc_scn OR rlgtime != walk_dbinc_time) THEN
      deb(DEB_EXIT, 'with error 20212');
      raise_application_error(-20212, 'until SCN is an orphan incarnation');
   END IF;
 
--
   rpoint_set := rpoint and not flbrp;
 
   IF walk_dbinc_key != this_dbinc_key THEN
      actual_dbinc_key := walk_dbinc_key;
      deb(DEB_IN, 'actual_dbinc_key set to:  '||to_char(actual_dbinc_key));
   END IF;
 
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with error 20208');
      raise_application_error(-20208,'until SCN is before resetlogs SCN');
END setUntilScn;
 
--
PROCEDURE setUntilLog(
   sequence# IN number
  ,thread#   IN number)
IS
    walk_dbinc_key  number := NULL;
    parent_dbinc_key  number := NULL;
BEGIN
   deb(DEB_ENTER, 'setUntilLog');
   rpoint_set := FALSE;
 
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   IF (sequence# is NULL) THEN
      deb(DEB_EXIT, 'with error 20205');
      raise_application_error(-20205, 'Incomplete UNTIL clause');
   END IF;
 
   walk_dbinc_Key := this_dbinc_key;
 
<<parent_inc>>
   untilTime := NULL;
   untilSCN := NULL;
 
   BEGIN
--
      SELECT first_change#
        INTO untilSCN
        FROM rc_log_history
       WHERE dbinc_key = walk_dbinc_key
         AND thread# = nvl(setUntilLog.thread#, 1)  -- default thread# is 1
         AND sequence# = setUntilLog.sequence#;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
--
--
            SELECT next_change#
              INTO untilSCN
              FROM rc_log_history
             WHERE dbinc_key = this_dbinc_key
--
               AND thread# = nvl(setUntilLog.thread#, 1)
               AND sequence# = setUntilLog.sequence# - 1;
         EXCEPTION
            WHEN no_data_found THEN
               BEGIN
                  IF (allIncarnations = TRUE#) THEN
                     SELECT parent_dbinc_key
                       INTO parent_dbinc_key
                       FROM dbinc
                      WHERE dbinc.dbinc_key = walk_dbinc_key;
 
                     walk_dbinc_key := parent_dbinc_key;
                     IF (walk_dbinc_key IS NULL) THEN
                        deb(DEB_EXIT, 'with error 20206');
                        raise_application_error(-20206,
                                               'Specified log does not exist');
                     ELSE
                        deb(DEB_IN, 'parent_dbinc_key=' ||
                                    to_char(parent_dbinc_key));
                        GOTO parent_inc;     -- get scn of parent incarnation
                     END IF;
                  ELSE
                     deb(DEB_EXIT, 'with error 20206');
                     raise_application_error(-20206,
                                             'Specified log does not exist');
                  END IF;
               END;
         END;
   END;
 
   IF walk_dbinc_key != this_dbinc_key THEN
      actual_dbinc_key := walk_dbinc_key;
      deb(DEB_IN, 'actual_dbinc_key set to:  '||to_char(actual_dbinc_key));
   END IF;
 
   deb(DEB_EXIT);
END setUntilLog;
 
--
PROCEDURE setToLog(
   sequence# IN number
  ,thread#   IN number)
IS
BEGIN
   deb(DEB_ENTER, 'setToLog');
   untilTime := NULL;
   untilSCN := NULL;
   rpoint_set := FALSE;
 
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   IF (sequence# is NULL) THEN
      deb(DEB_EXIT, 'with error 20205');
      raise_application_error(-20205, 'Incomplete TO clause');
   END IF;
 
   BEGIN
--
      SELECT (next_change# - 1)
        INTO untilSCN
        FROM rc_log_history
       WHERE dbinc_key = this_dbinc_key
         AND thread# = nvl(setToLog.thread#, 1)        -- default thread# is 1
         AND sequence# = setToLog.sequence#;
   EXCEPTION
      WHEN no_data_found THEN
         BEGIN
--
--
            SELECT (first_change# - 1)
              INTO untilSCN
              FROM rc_log_history
             WHERE dbinc_key = this_dbinc_key
--
               AND thread# = nvl(setToLog.thread#, 1)
               AND sequence# = setToLog.sequence# + 1;
         EXCEPTION
            WHEN no_data_found THEN
               deb(DEB_EXIT, 'with error 20206');
               raise_application_error(-20206, 'Specified log does not exist');
         END;
   END;
   deb(DEB_EXIT);
END setToLog;
 
--
PROCEDURE getRedoLogDeletionPolicy(
  policy  OUT varchar2)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getRedoLogDeletionPolicy;
 
--
PROCEDURE setRedoLogDeletionPolicy(
  policy  IN varchar2
 ,alldest IN number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END setRedoLogDeletionPolicy;
 
--
PROCEDURE resetAll(
  transclause IN boolean DEFAULT TRUE)
IS
BEGIN
   deb(DEB_PRINT, 'resetAll');
 
--
   setRAflags(kindMask   => allKind,
              allRecords => FALSE);
   setAllFlag(FALSE);
   setLikePattern(NULL);
   setCompletedRange(after => NULL, before => NULL);
   resetUntil;
   setFrom(NULL);
   resetDeviceType;
   setTag(NULL);                        -- restoreTag := NULL
   setStandby(NULL);
   setGuid(NULL);
   versionCounter := 1;                 -- for getPackageVersion
   getArchivedLogCursor  := NULL;
   getBackupPieceCursor  := NULL;
   getDatafileCopyCursor := NULL;
   getDatafileCursor     := NULL;
   getProxyCopyCursor    := NULL;
   localOrsSiteKey       := NULL;
 
   IF (transclause) THEN
      deb(DEB_PRINT, 'reset transclause');
      resetAlTransClause;                  -- reset AlTransClause
      resetDBTransClause;                  -- reset DBTransClause
      resetDbidTransClause;                -- reset DbidTransClause
      resetPdbIdList;                      -- reset PdbIdList
      resetPdbNameList;                    -- reset PdbNameList
      resetPdbFileList;                    -- reset PdbFileList
   END IF;
   resetBsRecCache(FALSE);              -- reset findvalid backupset cache
 
   setRcvRecBackupAge(0);               -- reset backup age variables
   setRecoveryDestFile(FALSE);          -- reset to all files
   setOrsFile(NULL, NULL);              -- reset to all files
   findSpfileBackupCursor      := FALSE;
   findControlfileBackupCursor := FALSE;
 
--
   rcvRecCursor.currc1.type_con := to_number(null);
   rcvRecCursor.reqfno := to_number(null);
   rcvRecCursor.reqcrescn := to_number(null);
   rcvRecCursor.reqpluginSCN := 0;
   rcvRecCursor.excludeAction := 0;
 
--
   resetrcvRecStack;
 
   pname_i := 0;                        -- reset debuging
 
   IF findControlfileBackup_c%ISOPEN THEN
      CLOSE findControlfileBackup_c;
   END IF;
   IF findSpfileBackup_c%ISOPEN THEN
      CLOSE findSpfileBackup_c;
   END IF;
   IF findControlFileCopyKey%ISOPEN THEN
      CLOSE findControlFileCopyKey;
   END IF;
   IF findDatafileCopyKey%ISOPEN THEN
      CLOSE findDatafileCopyKey;
   END IF;
   IF findDatafileBackup_c%ISOPEN THEN
      CLOSE findDatafileBackup_c;
   END IF;
   IF findProxyCopy%ISOPEN THEN
      CLOSE findProxyCopy;
   END IF;
   IF findProxyCopyKey%ISOPEN THEN
      CLOSE findProxyCopyKey;
   END IF;
   IF findArchivedLogCopy%ISOPEN THEN
      CLOSE findArchivedLogCopy;
   END IF;
   IF findArcLogBackup%ISOPEN THEN
      CLOSE findArcLogBackup;
   END IF;
   IF findRangeArcLogBackup%ISOPEN THEN
      CLOSE findRangeArcLogBackup;
   END IF;
   IF findValidBackupSet_c%ISOPEN THEN
      CLOSE findValidBackupSet_c;
   END IF;
   IF findValidBackupSet1P_c%ISOPEN THEN
      CLOSE findValidBackupSet1P_c;
   END IF;
   IF findBackupPiece_c%ISOPEN THEN
      CLOSE findBackupPiece_c;
   END IF;
   IF findBackupPieceBpKey%ISOPEN THEN
      CLOSE findBackupPieceBpKey;
   END IF;
   IF findBackupPieceBsKey1%ISOPEN THEN
      CLOSE findBackupPieceBsKey1;
   END IF;
   IF findBackupPieceBsKey2%ISOPEN THEN
      CLOSE findBackupPieceBsKey2;
   END IF;
   IF translateDatabase_c%ISOPEN THEN
      CLOSE translateDatabase_c;
   END IF;
   IF translateDatabaseOfPdbId_c%ISOPEN THEN
      CLOSE translateDatabaseOfPdbId_c;
   END IF;
   IF translateDatabaseOfPdbIdL_c%ISOPEN THEN
      CLOSE translateDatabaseOfPdbIdL_c;
   END IF;
   IF translateTablespace_c%ISOPEN THEN
      CLOSE translateTablespace_c;
   END IF;
   IF translateDatafileName%ISOPEN THEN
      CLOSE translateDatafileName;
   END IF;
   IF translateDatafileNumber%ISOPEN THEN
      CLOSE translateDatafileNumber;
   END IF;
   IF translateDatafileCheckpoint%ISOPEN THEN
      CLOSE translateDatafileCheckpoint;
   END IF;
   IF translateAllDf_c%ISOPEN THEN
      CLOSE translateAllDf_c;
   END IF;
   IF translateAllDfOfPdbId_c%ISOPEN THEN
      CLOSE translateAllDfOfPdbId_c;
   END IF;
   IF translateAllDfOfPdbIdL_c%ISOPEN THEN
      CLOSE translateAllDfOfPdbIdL_c;
   END IF;
   IF translateCorruptList_c%ISOPEN THEN
      CLOSE translateCorruptList_c;
   END IF;
   IF translateTempfile_c%ISOPEN THEN
      CLOSE translateTempfile_c;
   END IF;
   IF translateTempfileOfPdbId_c%ISOPEN THEN
      CLOSE translateTempfileOfPdbId_c;
   END IF;
   IF translateTempfileOfPdbIdL_c%ISOPEN THEN
      CLOSE translateTempfileOfPdbIdL_c;
   END IF;
   IF translateTempfileName_c%ISOPEN THEN
      CLOSE translateTempfileName_c;
   END IF;
   IF translateTempfileNumber_c%ISOPEN THEN
      CLOSE translateTempfileNumber_c;
   END IF;
   IF translateOnlineLogs_c%ISOPEN THEN
      CLOSE translateOnlineLogs_c;
   END IF;
   IF translateArcLogKey%ISOPEN THEN
      CLOSE translateArcLogKey;
   END IF;
   IF translateArcLogName%ISOPEN THEN
      CLOSE translateArcLogName;
   END IF;
   IF translateArcLogSeqRange%ISOPEN THEN
      CLOSE translateArcLogSeqRange;
   END IF;
   IF translateArcLogSeqRange2%ISOPEN THEN
      CLOSE translateArcLogSeqRange2;
   END IF;
   IF translateArcLogTimeRange%ISOPEN THEN
      CLOSE translateArcLogTimeRange;
   END IF;
   IF translateArcLogTimeRange2%ISOPEN THEN
      CLOSE translateArcLogTimeRange2;
   END IF;
   IF translateArcLogSCNRange%ISOPEN THEN
      CLOSE translateArcLogSCNRange;
   END IF;
   IF translateArcLogSCNRange2%ISOPEN THEN
      CLOSE translateArcLogSCNRange2;
   END IF;
   IF translateArcLogPattern%ISOPEN THEN
      CLOSE translateArcLogPattern;
   END IF;
   IF lbal2%ISOPEN THEN
      CLOSE lbal2;
   END IF;
   IF ldbi%ISOPEN THEN
      CLOSE ldbi;
   END IF;
   IF lnni%ISOPEN THEN
      CLOSE lnni;
   END IF;
   IF lrtbs%ISOPEN THEN
      CLOSE lrtbs;
   END IF;
   IF getOfflineRangeCopy_c%ISOPEN THEN
      CLOSE getOfflineRangeCopy_c;
   END IF;
   IF rddf%ISOPEN THEN
      CLOSE rddf;
   END IF;
   IF translateDatabaseCorruption_c%ISOPEN THEN
      CLOSE translateDatabaseCorruption_c;
   END IF;
   IF findConfig_c%ISOPEN THEN
      CLOSE findConfig_c;
   END IF;
   IF findBackupsetFiles%ISOPEN THEN
      CLOSE findBackupsetFiles;
   END IF;
   IF findAllBackupPiece%ISOPEN THEN
      CLOSE findAllBackupPiece;
   END IF;
   IF dfBackupHistory_c1%ISOPEN THEN
      CLOSE dfBackupHistory_c1;
   END IF;
   IF dfBackupHistory_c2%ISOPEN THEN
      CLOSE dfBackupHistory_c2;
   END IF;
   IF dcBackupHistory_c%ISOPEN THEN
      CLOSE dcBackupHistory_c;
   END IF;
   IF alBackupHistory_c1%ISOPEN THEN
      CLOSE alBackupHistory_c1;
   END IF;
   IF alBackupHistory_c2%ISOPEN THEN
      CLOSE alBackupHistory_c2;
   END IF;
   IF bsBackupHistory_c1%ISOPEN THEN
      CLOSE bsBackupHistory_c1;
   END IF;
   IF bsBackupHistory_c1%ISOPEN THEN
      CLOSE bsBackupHistory_c1;
   END IF;
   IF getCopyofDatafile_c%ISOPEN THEN
      CLOSE getCopyofDatafile_c;
   END IF;
   IF getCopyofDatafile_c2%ISOPEN THEN
      CLOSE getCopyofDatafile_c2;
   END IF;
   IF rcvRecCursor1_c%ISOPEN THEN
      CLOSE rcvRecCursor1_c;
   END IF;
   IF rcvRecCursor1Filter_c%ISOPEN THEN
      CLOSE rcvRecCursor1Filter_c;
   END IF;
   IF rcvRecCursor2_c%ISOPEN THEN
      CLOSE rcvRecCursor2_c;
   END IF;
   IF listBackup_c%ISOPEN THEN
      CLOSE listBackup_c;
   END IF;
   IF translatePdbName_c%ISOPEN THEN
      CLOSE translatePdbName_c;
   END IF;
   IF translatePdbFile_c%ISOPEN THEN
      CLOSE translatePdbFile_c;
   END IF;
   getArchivedLogLast   := NULL;             -- clear for next time
   getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
   getArchivedLogOnlyrdf := 0;
   lbacked_al_next_scn := NULL;
   standby_became_primary_scn := NULL;
   getrcvRecLast := NULL;
   this_stdby_controlfile_scn := NULL;
END resetAll;
 
--
--
--
 
--
PROCEDURE findValidBackupSet(
   backupSetRec            IN     rcvRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL)  -- for compat.
IS
BEGIN
   deb(DEB_ENTER, 'findValidBackupSet');
   IF (bsRecCacheEnabled) THEN
      cacheFindValidBackupSet(
         bsRec         => backupSetRec,
         deviceType    => deviceType,
         tag           => tag,
         availableMask => NVL(availableMask,
            computeAvailableMask(available, unavailable, deleted, expired)));
   ELSE
      findValidBackupSet(
         bsKey         => backupSetRec.bsKey_con,
         pieceCount    => backupSetRec.pieceCount_con,
         deviceType    => deviceType,
         tag           => tag,
         availableMask => NVL(availableMask,
            computeAvailableMask(available, unavailable, deleted, expired)));
   END IF;
   deb(DEB_EXIT);
END findValidBackupSet;
 
--
--
PROCEDURE findValidBackupSet(
   backupSetRec            IN     bsRec_t
  ,deviceType              IN     varchar2       DEFAULT NULL
  ,tag                     IN     varchar2       DEFAULT NULL
  ,available               IN     number         DEFAULT TRUE#  -- for compat.
  ,unavailable             IN     number         DEFAULT FALSE# -- for compat.
  ,deleted                 IN     number         DEFAULT FALSE# -- for compat.
  ,expired                 IN     number         DEFAULT FALSE# -- for compat.
  ,availableMask           IN     binary_integer DEFAULT NULL)  -- for compat.
IS
BEGIN
   deb(DEB_ENTER, 'findValidBackupSet bsRec_t');
   findValidBackupSet(bsKey         => backupSetRec.key,
                      pieceCount    => backupSetRec.pieceCount,
                      deviceType    => deviceType,
                      tag           => tag,
                      availableMask => NVL(availableMask,
                          computeAvailableMask(available, unavailable, deleted,
                                               expired)));
   deb(DEB_EXIT);
END findValidBackupSet;
 
--
 
--
PROCEDURE getDatafile(
   file#                        OUT number
  ,crescn                       OUT number
  ,creation_time                OUT date
  ,fname                        OUT varchar2
  ,ts_name                      OUT varchar2
  ,status                       OUT number
  ,blksize                      OUT number
  ,kbytes                       OUT number
  ,blocks                       OUT number
  ,unrecoverable_change#        OUT number
  ,stop_change#                 OUT number
  ,read_only                    OUT number)
IS
   dfRec        dfRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFile_2');
   getDatafile(dfRec, oldClient => TRUE);
 
   file#                 := dfRec.dfNumber;
   crescn                := dfRec.dfCreationSCN;
   creation_time         := dfRec.dfCreationTime;
   fname                 := dfRec.fileName;
   ts_name               := dfRec.tsName;
   status                := 0; -- this is kccfesta, which we don't have
   blksize               := dfRec.blockSize;
   kbytes                := dfRec.kbytes;
   blocks                := dfRec.blocks;
   unrecoverable_change# := 0; -- this is kccfeurs which isn't kept in rcvcat
   stop_change#          := dfRec.stopSCN;
   read_only             := dfRec.readOnly;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
--
      file# := NULL;
   deb(DEB_EXIT, 'with no more records');
END getDatafile;
 
--
--
--
--
--
--
--
--
 
--
PROCEDURE listTranslateProxyDFRecid(
   recid              IN number
  ,stamp              IN number
  ,xdf_key            OUT number
  ,file#              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateProxyDFRecid');
--
--
--
--
--
 
   IF (recid <> rcvRec_last.recid_con OR
       stamp <> rcvRec_last.stamp_con) THEN
  select d.xdf_key, d.file#, d.status, d.handle, d.completion_time,
         d.checkpoint_change#, d.checkpoint_time
  into xdf_key, file#, status, handle, completion_time, checkpoint_change#,
       checkpoint_time
  from   rc_proxy_datafile d
  where  db_key = this_db_key
    and ((user_site_key  = d.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(d.site_key, this_site_key)))))
    and  d.recid = listTranslateProxyDFRecid.recid
    and  d.stamp = listTranslateProxyDFRecid.stamp
  union all
  select c.xcf_key, 0, c.status, c.handle, c.completion_time,
         c.checkpoint_change#, c.checkpoint_time
  from   rc_proxy_controlfile c
  where  db_key = this_db_key
    and ((user_site_key  = c.site_key) OR
         (user_site_key IS NULL AND
          ((tape_backups_shared = TRUE#) OR
           (this_site_key = nvl(c.site_key, this_site_key)))))
    and  c.recid = listTranslateProxyDFRecid.recid
    and  c.stamp = listTranslateProxyDFRecid.stamp;
 
   ELSE
      deb(DEB_PRINT, 'listTranslateProxyDFRecid: using cached rcvRec_last');
      xdf_key            := rcvRec_last.key_con;
      file#              := rcvRec_last.dfNumber_obj;
      status             := rcvRec_last.status_con;
      handle             := rcvRec_last.fileName_con;
      completion_time    := rcvRec_last.compTime_con;
      checkpoint_change# := rcvRec_last.toSCN_act;
      checkpoint_time    := rcvRec_last.toTime_act;
   END IF;
   deb(DEB_EXIT);
END listTranslateProxyDFRecid;
 
--
--
--
 
--
--
--
--
--
--
--
--
 
--
PROCEDURE findOfflineRangeCopy(
   offr_recid   IN number
  ,offr_ckpscn  IN number
  ,cf_cretime   IN date
  ,dbinc_key    IN number)
IS
BEGIN
   deb(DEB_ENTER, 'findOfflineRangeCopy');
   validateState(null);
 
   deb(DEB_OPEN, 'getOfflineRangeCopy_c');
   OPEN getOfflineRangeCopy_c(offrRecid  => offr_recid,
                              offrCkpSCN => offr_ckpscn,
                              cfCreTime  => cf_cretime,
                              dbincKey   => dbinc_key);
   deb(DEB_EXIT);
END findOfflineRangeCopy;
 
--
PROCEDURE getOfflineRangeCopy(
   rcvRec  OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'getOfflineRangeCopy');
   IF (NOT getOfflineRangeCopy_c%ISOPEN) THEN
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   FETCH getOfflineRangeCopy_c
    INTO rcvRec;
 
   IF (getOfflineRangeCopy_c%NOTFOUND) THEN
      CLOSE getOfflineRangeCopy_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   CLOSE getOfflineRangeCopy_c;
   deb(DEB_EXIT);
END getOfflineRangeCopy;
 
--
 
--
FUNCTION getOfflineRangeCopy
RETURN varchar2 IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getOfflineRangeCopy815');
   getOfflineRangeCopy(rcvRec);
   deb(DEB_EXIT, 'with: fileName');
   RETURN rcvRec.fileName_con;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: NULL');
      RETURN NULL;
END getOfflineRangeCopy;
 
--
--
--
 
--
FUNCTION computeRecoveryActions(
fno        IN number,   -- Datafile number.
crescn     IN number,   -- Datafile creation SCN.
df_rlgscn  IN number    -- Datafile resetlogs SCN.  Null unless we are doing
   default null,        -- a RECOVER, in which case is the value in the
--
df_rlgtime IN date      -- Datafile resetlogs time.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
df_ckpscn  IN number    -- Datafile checkpoint SCN.  Null if df_rlgscn is
   default null,        -- null, else value from datafile header.
offlscn    IN number    -- kccfeofs (0 -> no offline range)
   default 0,
onlscn     IN number    -- kccfeonc (0 if offlscn is 0).
   default 0,
onltime    IN date      -- kccfonc_time
   default null,
cleanscn   IN number    -- kccfecps if either SOR or WCC set, else 0.
   default 0,
clean2scn  IN number    -- CF ckpt SCN if WCC set, infinity if SOR bit set
   default 0,           -- else 0.
clean2time IN date      -- controlfile ckpt time if WCC, SYSDATE if SOR, else
   default null,        -- this is ignored if cleanscn is 0
allowfuzzy IN boolean   -- TRUE if can be fuzzy at until SCN/time, FALSE if
  default FALSE,        -- not.  default is FALSE.
partial_rcv IN boolean  -- TRUE if can do partial recovery, FALSE if not.
  default FALSE,        -- A partial recovery would be to recover a datafile
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
cf_scn     IN number    -- controlfile ckpt SCN (NULL if none mounted)
  default NULL,
cf_cretime IN date      -- controlfile creation time (NULL if none mounted)
  default NULL,
cf_offrrid IN number    -- recid of oldest offline range in controlfile
  default NULL,         -- (NULL if none mounted)
allCopies  IN boolean
  default FALSE,
df_cretime IN DATE
  default NULL,
rmanCmd    IN binary_integer
  default unknownCmd_t,
foreignDbid   IN number
  default 0,
pluggedRonly  IN binary_integer
  default 0,
pluginSCN     IN number
  default 0,
pluginRlgSCN  IN number
  default 0,
pluginRlgTime IN date
  default NULL,
creation_thread IN number
  default NULL,
creation_size   IN number
  default NULL,
pdbId IN number
  default 1,
pdbForeignDbid IN number
  default 0)
RETURN binary_integer IS
   rc              boolean;
   last            number;
   this            number;
   succ_flag       boolean;
   thisAct         rcvRec_t;
   doingRecovery   boolean;
   lrmanCmd        binary_integer := rmanCmd;
   target_scn      number         := to_number(null);
BEGIN
   deb(DEB_ENTER, 'computeRecoveryActions');
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   deb(DEB_IN, '  fno:          '||fno);
   deb(DEB_IN, '  crescn:       '||crescn);
   deb(DEB_IN, '  df_rlgscn:    '||df_rlgscn);
   deb(DEB_IN, '  df_ckpscn:    '||to_char(df_ckpscn));
   deb(DEB_IN, '  offlscn:      '||to_char(offlscn));
   deb(DEB_IN, '  onlscn:       '||to_char(onlscn));
   deb(DEB_IN, '  cleanscn:     '||to_char(cleanscn));
   deb(DEB_IN, '  clean2scn:    '||to_char(clean2scn));
   deb(DEB_IN, '  cf_scn:       '||to_char(cf_scn));
   deb(DEB_IN, '  cf_offrrid:   '||to_char(cf_offrrid));
   deb(DEB_IN, '  foreignDbid:  '||to_char(foreignDbid));
   deb(DEB_IN, '  pluggedRonly: '||to_char(pluggedRonly));
   deb(DEB_IN, '  pluginSCN:    '||to_char(pluginSCN));
   deb(DEB_IN, '  pluginRlgSCN: '||to_char(pluginRlgSCN));
   deb(DEB_IN, '  creation_thread: '||to_char(creation_thread));
   deb(DEB_IN, '  creation_size:   '||to_char(creation_size));
   deb(DEB_IN, '  pdbid:           '||to_char(pdbId));
   deb(DEB_IN, '  pdbForeignDbid:  '||to_char(pdbForeignDbid));
 
   resetrcvRecStack;
 
   computeRA_restorable    := FALSE;
   computeRA_available     := FALSE;
   computeRA_rcvCopy_avail := FALSE;
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   IF (df_cretime is null AND  -- pre10g rman client
       lrmanCmd = unknownCmd_t AND
       df_ckpscn is not null) THEN
      deb(DEB_IN, 'rmanCmd set to recoverCmd_t for pre10g rman');
      lrmanCmd := recoverCmd_t;
   END IF;
 
   IF (lrmanCmd = rcvCopyCmd_t) THEN
      deb(DEB_PRINT, 'doing recover copy');
      doingRecovery := TRUE;
   ELSIF (lrmanCmd = recoverCmd_t) THEN
      deb(DEB_PRINT, 'doing recover');
      doingRecovery := TRUE;
   ELSIF (lrmanCmd = obsoleteCmd_t) THEN
      deb(DEB_PRINT, 'doing report obsolete');
      doingRecovery := NULL;
      IF (allCopies) THEN
--
--
--
--
         raise_application_error(-20999,
                                'internal error: computeRecoveryActions ' ||
                                'obsoleteCmd cannot be called with allCopies');
      END IF;
      IF (tc_database = FALSE#) THEN
--
--
         raise_application_error(-20999,
              'internal error: computeRecoveryActions ' ||
              'obsoleteCmd cannot be called for specific files');
      END IF;
   ELSIF (lrmanCmd = restoreCmd_t) THEN
      deb(DEB_PRINT, 'doing restore');
      doingRecovery := NULL;
   ELSIF (lrmanCmd = blkRestoreCmd_t) THEN
      deb(DEB_PRINT, 'doing block restore');
      doingRecovery := FALSE;
      target_scn := df_ckpscn;
   ELSIF (lrmanCmd = unknownCmd_t) THEN
      deb(DEB_PRINT, 'command unknown or called by pre-10i rman');
      doingRecovery := NULL;
   ELSE
      raise_application_error(-20999, 'internal error: computeRecoveryActions'
                              || ' rmanCmd='||nvl(to_char(lrmanCmd), 'NULL'));
   END IF;
 
   deb(DEB_IN, 'this_dbinc_key is:'||to_char(this_dbinc_key));
   rc := computeRecoveryActions2(fno, crescn, df_cretime,
                                df_rlgscn, df_rlgtime, df_ckpscn,
                                offlscn, onlscn, onltime,
                                cleanscn, clean2scn, clean2time,
                                allowfuzzy, partial_rcv,
                                target_scn, this_dbinc_key,
                                cf_scn, cf_cretime, cf_offrrid,
                                FALSE, succ_flag, allCopies, doingRecovery,
                                lrmanCmd, foreignDbid,
                                pluggedRonly, pluginSCN, pluginRlgSCN,
                                pluginRlgTime, creation_thread, creation_size,
                                pdbId, pdbForeignDbid);
 
   IF (succ_flag) THEN
      IF (rcvRecStack.count > 0) THEN
         IF (computeRA_allRecords = FALSE#) THEN
--
--
--
--
 
--
--
 
--
--
 
--
--
--
--
--
--
 
            last := rcvRecStack.count;
            deb(DEB_IN,'computeRecoveryActions: Top of stack='||
                       rcvRecStack.count);
            FOR this IN REVERSE 2..rcvRecStack.count - 1 LOOP
               IF ((rcvRecStack(last).toSCN_act >=
                    rcvRecStack(this-1).fromSCN_act)
                   AND NOT
--
                   (allCopies                       AND
                    ((rcvRecStack(last).key_con =
                      rcvRecStack(this).key_con   AND
                      rcvRecStack(last).type_con =
                      rcvRecStack(this).type_con) OR
                     (rcvRecStack(this-1).key_con =
                      rcvRecStack(this).key_con   AND
                      rcvRecStack(this-1).type_con =
                      rcvRecStack(this).type_con))))
                  THEN
                  deb(DEB_PRINT, 
                    'computeRecoveryActions: marking this action deleted:');
                  rcvRecGet(this, thisAct);
                  IF (debug) THEN
                     printRcvRec(thisAct);
                  END IF;
                  rcvRecStack(this).type_con :=
                     rcvRecStack(this).type_con + deleted_con_t;
               ELSE
--
                  last := this;
               END IF;
            END LOOP;
         END IF;                -- computeRA_allRecords = FALSE#
         deb(DEB_EXIT, 'with: SUCCESS');
         RETURN SUCCESS;
      ELSE
         deb(DEB_EXIT, 'with: NO_ACTION');
         RETURN NO_ACTION;      -- a recovery that can only use redo
      END IF;
   ELSIF (computeRA_available) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
      RETURN dbms_rcvman.AVAILABLE;
   ELSIF (computeRA_restorable) THEN
      deb(DEB_EXIT, 'with: RESTORABLE');
      RETURN RESTORABLE;
   ELSE
      deb(DEB_EXIT, 'with: UNAVAILABLE');
      RETURN dbms_rcvman.UNAVAILABLE;
   END IF;
 
END computeRecoveryActions;
 
--
--
--
 
--
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number
  ,key                 OUT number
  ,completion_time     OUT date)
RETURN number IS
   device_type rc_backup_piece.device_type%TYPE;
   mytype      number;
   set_stamp   number;
   set_count   number;
   pref        number;
   bsRec       bsRec_t;
   validRec    validBackupSetRec_t;
   rcvRec      rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'reportGetDFDel');
   FETCH rddf
    INTO pref, file#, mytype, checkpoint_change#, checkpoint_time,
         resetlogs_change#, resetlogs_time, incremental_change#, fuzzy_change#,
         recid, stamp, fname, set_stamp, set_count, key, completion_time,
         device_type;
   filetype := mytype;
   IF (rddf%found) THEN
      IF (mytype in (FULL_DF_BACKUP, INCREMENTAL_DF_BACKUP)) THEN
         findBackupSet(recid => recid,
                       stamp => stamp,
                       bsRec => bsRec);
--
--
         rcvRec.bsKey_con      := bsRec.key;
         rcvRec.elapseSecs_con := bsRec.elapseSecs;
         rcvRec.pieceCount_con := bsRec.pieceCount;
         restorable := validateBackupSet(
            backupSetRec           => rcvRec,
            checkDeviceIsAllocated => TRUE,
            availableMask          => dbms_rcvman.BSavailable,
            validRec               => validRec);
      ELSIF (mytype = OFFLINE_RANGE) THEN
         restorable := SUCCESS;
      ELSE
         IF (anyDevice = TRUE# OR
             isDeviceTypeAllocated(device_type) = TRUE#) THEN
            restorable := SUCCESS;
         ELSE
            restorable := dbms_rcvman.AVAILABLE;
         END IF;
      END IF;
      deb(DEB_EXIT, 'with: '||TRUE#);
      RETURN TRUE#;
   ELSE
      CLOSE rddf;
      deb(DEB_EXIT, 'with: '||FALSE#);
      RETURN FALSE#;
   END IF;
END reportGetDFDel;
 
--
--
--
 
--
FUNCTION getCloneName(
   fno    IN number
  ,crescn IN number
  ,pluscn IN number DEFAULT 0)
RETURN varchar2 IS
   fname rci_datafile.aux_name%TYPE;
BEGIN
   deb(DEB_ENTER, 'getCloneName');
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   SELECT aux_name
     INTO fname
     FROM rci_datafile_this_dbinc
    WHERE dbinc_key = this_dbinc_key
      AND (nvl(realf_site_key, translation_site_key) = site_key)
      AND file# = fno
      AND creation_change# = crescn
      AND plugin_change# = pluscn
      AND drop_change# IS NULL;
 
   deb(DEB_EXIT, 'with: '||fname);
   RETURN fname;
EXCEPTION
   WHEN no_data_found THEN
--
--
      deb(DEB_EXIT, 'with error 20218');
      raise_application_error(-20218,
                              'Datafile not found in recovery catalog');
   WHEN others THEN
      deb(DEB_EXIT, 'Just raising error');
      raise;
END getCloneName;
 
--
--
--
 
--
FUNCTION wasFileOffline(
   fno    IN number
  ,untilscn IN number)
RETURN number IS
   x     number;
BEGIN
   deb(DEB_ENTER, 'wasFileOffline');
  select 1
    into x
    from rc_offline_range ofr, rc_database_incarnation di
   where ofr.db_key = this_db_key
     and di.db_key = this_db_key
     and ofr.dbinc_key = di.dbinc_key
     and untilscn >= offline_change#
     and untilscn < online_change#
     and file# = fno;
 
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
 
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END wasFileOffline;
 
--
--
--
--
 
FUNCTION getmaxcopyno(
   bsstamp         IN    number
  ,bscount         IN    number)
RETURN number IS
   maxcopy number;
BEGIN
   select max(copy#)
      into maxcopy
      from rc_backup_piece  bp
      where bp.set_stamp = bsstamp
      and   bp.set_count = bscount
--
--
--
--
--
--
      and   bp.db_key = this_db_key;
   return maxcopy;
END getmaxcopyno;
 
--
FUNCTION getMaxDfNumber
RETURN number IS
   maxfile# number;
BEGIN
   select max(file#) into maxfile# from df;
   return maxfile#;
END getMaxDfNumber;
 
--
PROCEDURE getdropOSFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getdropOSFiles;
 
--
PROCEDURE getBackedUpFiles(
   first         IN  boolean
  ,agedFileRec   OUT NOCOPY agedFileRec_t)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getBackedUpFiles;
 
--
FUNCTION validateStandbyConfig(
   policy  IN  varchar2
  ,alldest IN  number)
RETURN NUMBER IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
   return dbms_rcvman.FALSE#;
END validateStandbyConfig;
 
--
PROCEDURE getSCNForAppliedPolicy(
   minscn    OUT  number
  ,rlgscn    OUT  number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getSCNForAppliedPolicy;
 
--
PROCEDURE getAppliedAl(
   first           IN   boolean
  ,agedFileRec     OUT  NOCOPY agedFileRec_t)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getAppliedAl;
 
--
PROCEDURE getRequiredSCN(
   reqscn   OUT  number
  ,rlgscn   OUT  number
  ,streams  IN   number DEFAULT 0
  ,alldest  IN   number DEFAULT 0)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getRequiredSCN;
 
--
PROCEDURE getAppliedSCN(
   appscn   OUT  number
  ,rlgscn   OUT  number
  ,alldest  IN   number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getAppliedSCN;
 
--
FUNCTION isBsRecCacheMatch(
   key         IN   number
  ,deviceType  IN   varchar2
  ,tag         IN   varchar2
  ,status      IN   varchar2)
RETURN NUMBER IS
  bucket      number;
  sb4_bucket  binary_integer;
BEGIN
   bucket := mod(key, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      sb4_bucket := CONST2GVAL - bucket;
   ELSE
      sb4_bucket := bucket;
   END IF;
 
   IF (NOT cacheBsRecTable.bsRec.exists(sb4_bucket)) THEN
      RETURN FALSE#;
   END IF;
 
   FOR i in 1..cacheBsRecTable.bsRec(sb4_bucket).bslist.count LOOP
      IF (cacheBsRecTable.bsRec(sb4_bucket).bslist(i).bskey = key) THEN
--
         IF (cacheBsRecTable.mask = BSavailable) THEN
            IF (status != 'A') THEN
               RETURN FALSE#;
            END IF;
         ELSIF (isStatusMatch(status, cacheBsRecTable.mask) = FALSE#) THEN
            RETURN FALSE#;
         END IF;
 
--
         IF (deviceType != cacheBsRecTable.deviceType) THEN
            RETURN FALSE#;
         END IF;
 
--
         IF (nvl(tag, '  ') != nvl(cacheBsRecTable.tag, nvl(tag, '  '))) THEN
            RETURN FALSE#;
         END IF;
 
--
         cacheBsRecTable.bsRec(sb4_bucket).bslist(i).mixcopy := TRUE;
 
         RETURN TRUE#;
      END IF;
   END LOOP;
   RETURN FALSE#;
END isBsRecCacheMatch;
 
--
PROCEDURE resetReclRecid
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END resetReclRecid;
 
--
PROCEDURE setReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number)
IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END setReclRecid;
 
--
FUNCTION IsReclRecid(
   rectype  IN  binary_integer
  ,recid    IN  number)
RETURN NUMBER IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END IsReclRecid;
 
--
FUNCTION getSpaceRecl(ceilAsm IN binary_integer default 0)
RETURN NUMBER IS
BEGIN
   raise_application_error(-20999, 'Not supported in recovery catalog');
END getSpaceRecl;
 
--
--
--
PROCEDURE getFlashbackInfo(
   fbUntilTime   OUT DATE
  ,minGrsp       OUT NUMBER)
IS
   clean_grsp   number;
   count_grsp   number;
BEGIN
   BEGIN
      SELECT nvl(oldest_flashback_time, MAXDATEVAL)
        INTO fbUntiltime
        FROM fb
       WHERE dbinc_key = this_dbinc_key
         AND db_unique_name = this_db_unique_name;
   EXCEPTION
      WHEN no_data_found THEN
         fbUntilTime := MAXDATEVAL;
   END;
 
   BEGIN
      SELECT min(to_scn),
             count(*),
             count(case when from_scn <= to_scn then 1 else 0 end)
        INTO minGrsp, count_grsp, clean_grsp
        FROM grsp, dbinc
       WHERE grsp.dbinc_key = dbinc.dbinc_key
         AND dbinc.db_key = this_db_key
         AND grsp.site_key = this_site_key
         AND grsp.guaranteed = 'YES'
         AND from_scn != 0;
 
--
--
      IF (clean_grsp = 1 AND count_grsp = 1) THEN
         minGrsp := MAXSCNVAL;
      END IF;
   EXCEPTION
      WHEN no_data_found THEN
         minGrsp := MAXSCNVAL;
   END;
 
   deb(DEB_PRINT, 'getFlashbackInfo: fbUntilTime=' || to_char(fbUntilTime) ||
                  ' minGrsp=' || minGrsp);
END getFlashbackInfo;
 
--
PROCEDURE openLbCursor(lbc  OUT NOCOPY lbCursor_t) IS
BEGIN
 
   IF (lbc%ISOPEN)
   THEN
     CLOSE lbc;
   END IF;
 
   OPEN lbc FOR
 
   SELECT
--
           bs.bs_key               list_order1,
           0                       list_order2,
           bs.bs_key               pkey,
           backupset_txt           backup_type,
           backupset_txt           file_type,
           decode(bs.keep_options,
                  0, 'NO',
                     'YES')        keep,
           bs.keep_until           keep_until,
           decode(bs.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         null)     keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bs.bs_recid             recid,
           bs.bs_stamp             stamp,
           null                    device_type,
           0                       block_size,
           bs.completion_time      completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           bs.bs_key               bs_key,
           bs.set_count            bs_count,
           bs.set_stamp            bs_stamp,
           decode(bs.bck_type,
                  'L', archivedlog_txt,
                       datafile_txt)
                                   bs_type,
           decode(bs.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(bs.bck_type, 'I', incr_txt, full_txt))
                                   bs_incr_type,
           bs.pieces               bs_pieces,
           null                    bs_copies,
           bs.completion_time      bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM  bs
    WHERE bs.db_key     = this_db_key
 
   UNION ALL
   SELECT
--
           bp.bs_key               list_order1,
           1                       list_order2,
           bp.bp_key               pkey,
           backupset_txt           backup_type,
           piece_txt               file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(bp.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           bp.handle               fname,
           bp.tag                  tag,
           bp.media                media,
           bp.bp_recid             recid,
           bp.bp_stamp             stamp,
           bp.device_type          device_type,
           0                       block_size,
           bp.completion_time      completion_time,
           bp.is_recovery_dest_file
                                   is_rdf,
           bp.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bp.bytes                bytes,
           bp.bs_key               bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           bp.piece#               bp_piece#,
           bp.copy#                bp_copy#,
           bp.vb_key               bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bp
    WHERE bp.db_key = this_db_key
      AND bp.status != 'D'
      AND ((user_site_key = bp.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE# AND bp.device_type = 'DISK') OR
             (tape_backups_shared = TRUE# AND bp.device_type <>'DISK') OR
             (this_site_key = nvl(bp.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           bdf.bs_key              list_order1,
           2                       list_order2,
           bdf.bdf_key             pkey,
           backupset_txt           backup_type,
           datafile_txt            file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bdf.bdf_recid           recid,
           bdf.bdf_stamp           stamp,
           null                    device_type,
           bdf.block_size          block_size,
           bdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bdf.block_size * bdf.blocks
                                   bytes,
           bdf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           decode(bdf.incr_level,
                  0, full_txt,
                  1, incr1_txt,
                  2, incr2_txt,
                  3, incr3_txt,
                  4, incr4_txt,
                  decode(greatest(bdf.create_scn, bdf.incr_scn),
                         bdf.create_scn, full_txt, incr_txt))
                                   bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           bdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           bdf.create_scn          df_creation_change#,
           bdf.ckp_scn             df_checkpoint_change#,
           bdf.ckp_time            df_ckp_mod_time,
           bdf.incr_scn            df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bdf.dbinc_key
 
   UNION ALL
   SELECT
--
           bcf.bs_key              list_order1,
           2                       list_order2,
           bcf.bcf_key             pkey,
           backupset_txt           backup_type,
           controlfile_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bcf.bcf_recid           recid,
           bcf.bcf_stamp           stamp,
           null                    device_type,
           bcf.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bcf.block_size * bcf.blocks
                                   bytes,
           bcf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           bcf.ckp_scn             df_checkpoint_change#,
           bcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM bcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = bcf.dbinc_key
 
   UNION ALL
   SELECT
--
           brl.bs_key              list_order1,
           2                       list_order2,
           brl.brl_key             pkey,
           backupset_txt           backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           brl.brl_recid           recid,
           brl.brl_stamp           stamp,
           null                    device_type,
           brl.block_size          block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           brl.block_size * brl.blocks
                                   bytes,
           brl.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           brl.thread#             rl_thread#,
           brl.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           brl.low_scn             rl_first_change#,
           brl.low_time            rl_first_time,
           brl.next_scn            rl_next_change#,
           brl.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM brl, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = brl.dbinc_key
 
   UNION ALL
   SELECT
--
           bsf.bs_key              list_order1,
           2                       list_order2,
           bsf.bsf_key             pkey,
           backupset_txt           backup_type,
           spfile_txt              file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           null                    status,
           null                    fname,
           null                    tag,
           null                    media,
           bsf.bsf_recid           recid,
           bsf.bsf_stamp           stamp,
           null                    device_type,
           0                       block_size,
           null                    completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           bsf.bytes               bytes,
           bsf.bs_key              bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           full_txt                bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           0                       df_resetlogs_change#,
           0                       df_creation_change#,
           0                       df_checkpoint_change#,
           bsf.modification_time   df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           db_unique_name          sf_db_unique_name,
           null                    con_id
     FROM bsf
    WHERE bsf.db_key     = this_db_key
 
   UNION ALL
   SELECT
--
           cdf.cdf_key             list_order1,
           -1                      list_order2,
           cdf.cdf_key             pkey,
           copy_txt                backup_type,
           datafile_txt            file_type,
           decode(cdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           cdf.keep_until          keep_until,
           decode(cdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(cdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           cdf.fname               fname,
           cdf.tag                 tag,
           null                    media,
           cdf.cdf_recid           recid,
           cdf.cdf_stamp           stamp,
           'DISK'                  device_type,
           cdf.block_size          block_size,
           cdf.completion_time     completion_time,
           cdf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           cdf.block_size * cdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           cdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           cdf.create_scn          df_creation_change#,
           cdf.ckp_scn             df_checkpoint_change#,
           cdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM cdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = cdf.dbinc_key
      AND ((user_site_key = cdf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(cdf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           ccf.ccf_key             list_order1,
           -1                      list_order2,
           ccf.ccf_key             pkey,
           copy_txt                backup_type,
           controlfile_txt         file_type,
           decode(ccf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           ccf.keep_until          keep_until,
           decode(ccf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(ccf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           ccf.fname               fname,
           ccf.tag                 tag,
           null                    media,
           ccf.ccf_recid           recid,
           ccf.ccf_stamp           stamp,
           'DISK'                  device_type,
           ccf.block_size          block_size,
           ccf.completion_time     completion_time,
           ccf.is_recovery_dest_file
                                   is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           ccf.ckp_scn             df_checkpoint_change#,
           ccf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM ccf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = ccf.dbinc_key
      AND ((user_site_key  = ccf.site_key) OR
           (user_site_key IS NULL AND
            ((disk_backups_shared = TRUE#) OR
             (this_site_key = nvl(ccf.site_key, this_site_key)))))
 
   UNION ALL
 
   SELECT
--
           al.al_key               list_order1,
           -1                      list_order2,
           al.al_key               pkey,
           copy_txt                backup_type,
           archivedlog_txt         file_type,
           null                    keep,
           null                    keep_until,
           null                    keep_options,
           decode(al.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           al.fname                fname,
           null                    tag,
           null                    media,
           al.al_recid             recid,
           al.al_stamp             stamp,
           'DISK'                  device_type,
           al.block_size           block_size,
           al.completion_time      completion_time,
           al.is_recovery_dest_file
                                   is_rdf,
           al.compressed           compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           al.block_size * al.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           null                    df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           null                    df_resetlogs_change#,
           null                    df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           al.thread#              rl_thread#,
           al.sequence#            rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           al.low_scn              rl_first_change#,
           al.low_time             rl_first_time,
           al.next_scn             rl_next_change#,
           al.next_time            rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM dbinc,
          al
          LEFT OUTER JOIN
          grsp
          ON al.next_scn   >= grsp.from_scn
         AND al.low_scn    <= (grsp.to_scn + 1)
         AND al.dbinc_key   = grsp.dbinc_key
         AND grsp.from_scn <= grsp.to_scn   -- filter clean grp
         AND grsp.from_scn != 0
         AND grsp.guaranteed = 'YES'
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = al.dbinc_key
      AND al.archived       = 'Y'
      AND grsp.from_scn is null
      AND ((client_site_aware = TRUE# AND
            ((user_site_key = al.site_key) OR -- interested in specific site
             (user_site_key IS NULL AND
              ((logs_shared = TRUE#) OR
               (this_site_key = nvl(al.site_key, this_site_key)))))) OR
           (client_site_aware = FALSE#))
 
   UNION ALL
 
   SELECT
--
           xdf.xdf_key             list_order1,
           -1                      list_order2,
           xdf.xdf_key             pkey,
           proxycopy_txt           backup_type,
           datafile_txt            file_type,
           decode(xdf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xdf.keep_until          keep_until,
           decode(xdf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xdf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xdf.handle              fname,
           xdf.tag                 tag,
           xdf.media               media,
           xdf.xdf_recid           recid,
           xdf.xdf_stamp           stamp,
           xdf.device_type         device_type,
           xdf.block_size          block_size,
           xdf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xdf.block_size * xdf.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           xdf.file#               df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           xdf.create_scn          df_creation_change#,
           xdf.ckp_scn             df_checkpoint_change#,
           xdf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xdf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xdf.dbinc_key
      AND ((user_site_key  = xdf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xdf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           xcf.xcf_key             list_order1,
           -1                      list_order2,
           xcf.xcf_key             pkey,
           proxycopy_txt           backup_type,
           controlfile_txt         file_type,
           decode(xcf.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xcf.keep_until          keep_until,
           decode(xcf.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xcf.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xcf.handle              fname,
           xcf.tag                 tag,
           xcf.media               media,
           xcf.xcf_recid           recid,
           xcf.xcf_stamp           stamp,
           xcf.device_type         device_type,
           xcf.block_size          block_size,
           xcf.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           null                    bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           xcf.ckp_scn             df_checkpoint_change#,
           xcf.ckp_time            df_ckp_mod_time,
           null                    df_incremental_change#,
           null                    rl_thread#,
           null                    rl_sequence#,
           null                    rl_resetlogs_change#,
           null                    rl_first_change#,
           null                    rl_first_time,
           null                    rl_next_change#,
           null                    rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xcf, dbinc
    WHERE dbinc.db_key     = this_db_key
      AND dbinc.dbinc_key  = xcf.dbinc_key
      AND ((user_site_key  = xcf.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xcf.site_key, this_site_key)))))
 
   UNION ALL
   SELECT
--
           xal.xal_key             list_order1,
           -1                      list_order2,
           xal.xal_key             pkey,
           proxycopy_txt           backup_type,
           archivedlog_txt         file_type,
           decode(xal.keep_options,
                  0, 'NO',
                     'YES')        keep,
           xal.keep_until          keep_until,
           decode(xal.keep_options,
                  256,  'LOGS',
                  512,  'NOLOGS',
                  1024, 'BACKUP_LOGS',
                         NULL)     keep_options,
           decode(xal.status,
                  'A', available_txt,
                  'U', unavailable_txt,
                  'X', expired_txt,
                       other_txt)  status,
           xal.handle              fname,
           xal.tag                 tag,
           xal.media               media,
           xal.xal_recid           recid,
           xal.xal_stamp           stamp,
           xal.device_type         device_type,
           xal.block_size          block_size,
           xal.completion_time     completion_time,
           'NO'                    is_rdf,
           null                    compressed,
           null                    obsolete,
           null                    keep_for_dbpitr,
           xal.block_size * xal.blocks
                                   bytes,
           null                    bs_key,
           null                    bs_count,
           null                    bs_stamp,
           null                    bs_type,
           null                    bs_incr_type,
           null                    bs_pieces,
           null                    bs_copies,
           null                    bs_completion_time,
           null                    bs_status,
           null                    bs_bytes,
           null                    bs_compressed,
           null                    bs_tag,
           null                    bs_device_type,
           null                    bp_piece#,
           null                    bp_copy#,
           null                    bp_vb_key,
           null                    bp_ba_access,
           null                    bp_lib_key,
           0                       df_file#,
           null                    df_ts#,
           null                    df_plugin_change#,
           null                    df_foreign_dbid,
           null                    df_tablespace,
           dbinc.reset_scn         df_resetlogs_change#,
           0                       df_creation_change#,
           null                    df_checkpoint_change#,
           null                    df_ckp_mod_time,
           null                    df_incremental_change#,
           xal.thread#             rl_thread#,
           xal.sequence#           rl_sequence#,
           dbinc.reset_scn         rl_resetlogs_change#,
           xal.low_scn             rl_first_change#,
           xal.low_time            rl_first_time,
           xal.next_scn            rl_next_change#,
           xal.next_time           rl_next_time,
           null                    sf_db_unique_name,
           null                    con_id
     FROM xal, dbinc
    WHERE dbinc.db_key      = this_db_key
      AND dbinc.dbinc_key   = xal.dbinc_key
      AND ((user_site_key   = xal.site_key) OR
           (user_site_key IS NULL AND
            ((tape_backups_shared = TRUE#) OR
             (this_site_key = nvl(xal.site_key, this_site_key)))))
 
--
--
   ORDER BY list_order1, list_order2, bp_piece#;
 
END openLbCursor;
 
--
--
FUNCTION DbUniqueNameIsStandby
    RETURN NUMBER
IS
   is_standby number;
BEGIN
   deb(DEB_ENTER, 'DbUniqueNameIsStandby');
 
   IF NOT this_dummy_instance THEN
--
--
      SELECT count(*) INTO is_standby FROM node
      WHERE node.db_key = this_db_key
        AND node.db_unique_name = this_db_unique_name
        AND node.database_role = 'STANDBY';
   END IF;
 
   IF is_standby is NULL THEN
      is_standby := 0;
   END IF;
   deb(DEB_EXIT, ' with ' || is_standby);
   return is_standby;
END DbUniqueNameIsStandby;
 
--
--
--
PROCEDURE clrSiteName
IS
BEGIN
  deb(DEB_ENTER, 'clrSiteName, user_site_key, realf_site_key set to null');
  user_site_key := NULL;
  realf_site_key := NULL;
  user_db_unique_name := NULL;
  deb(DEB_EXIT);
END clrSiteName;
 
--
FUNCTION getSiteKey(db_unique_name IN VARCHAR2)
   RETURN NUMBER
IS
   resynced     NUMBER;
   ret_site_key NUMBER;
BEGIN
--
--
   IF (this_db_key IS NULL) THEN
      raise_application_error(-20021, 'database not set');
   END IF;
 
--
   SELECT count(*) INTO resynced FROM node
      WHERE node.db_unique_name = upper(getSiteKey.db_unique_name)
        AND node.db_key = this_db_key;
 
   IF resynced = 0 THEN
      raise_application_error(-20243,
                              getSiteKey.db_unique_name ||
                              'site unknown to recovery catalog:');
   END IF;
 
   SELECT site_key into ret_site_key FROM node
      WHERE node.db_unique_name = upper(getSiteKey.db_unique_name)
        AND node.db_key = this_db_key;
 
   RETURN ret_site_key;
END getSiteKey;
 
--
FUNCTION getSiteName(site_key IN NUMBER)
   RETURN VARCHAR2
IS
   ldb_unique_name node.db_unique_name%TYPE;
BEGIN
   deb(DEB_ENTER, 'getSiteName, site_key=' || site_key);
   SELECT db_unique_name INTO ldb_unique_name FROM node
   WHERE site_key = getSiteName.site_key;
   deb(DEB_EXIT, ' with ' || ldb_unique_name);
   RETURN ldb_unique_name;
END getSiteName;
 
--
PROCEDURE setSiteName(db_unique_name IN VARCHAR2,
                      for_realfiles  IN NUMBER)
IS
BEGIN
   deb(DEB_ENTER, 'setSiteName'||db_unique_name);
   If db_unique_name IS NOT NULL THEN
      IF for_realfiles != 0 THEN
        realf_site_key := getSiteKey(db_unique_name);
      ELSE
        user_site_key := getSiteKey(db_unique_name);
        user_db_unique_name := upper(db_unique_name);
      END IF;
      deb(DEB_PRINT, 'user_site_key='|| user_site_key);
      deb(DEB_PRINT, 'realf_site_key='  || realf_site_key);
      deb(DEB_PRINT, 'user_db_unique_name='||user_db_unique_name);
   END IF;
   deb(DEB_EXIT);
END setSiteName;
 
--
--
PROCEDURE setArchiveFileScopeAttributes(logs_shared  IN NUMBER) IS
BEGIN
   deb(DEB_ENTER, 'setArchiveFileScopeAttributes');
 
   IF logs_shared > 0 THEN
      dbms_rcvman.logs_shared := TRUE#;
   ELSE
      dbms_rcvman.logs_shared := FALSE#;
   END IF;
   deb(DEB_PRINT, 'logs_shared = ' || dbms_rcvman.logs_shared);
 
   deb(DEB_EXIT);
END setArchiveFileScopeAttributes;
 
--
--
PROCEDURE setFirstFullBckScopeAttributes(baseline_cap IN NUMBER) IS
BEGIN
   deb(DEB_ENTER, 'setFirstFullBckScopeAttributes');
 
   this_baseline_cap := baseline_cap;
   this_baseline_cap_scn := NULL;
 
   deb(DEB_PRINT, 'baseline_cap = ' || this_baseline_cap);
 
   deb(DEB_EXIT);
END setFirstFullBckScopeAttributes;
 
--
--
PROCEDURE setBackupFileScopeAttributes(
                 disk_backups_shared IN NUMBER,
                 tape_backups_shared IN NUMBER) IS
   lsite_key NUMBER;
BEGIN
   deb(DEB_ENTER, 'setBackupFileScopeAttributes');
 
   IF disk_backups_shared IS NOT NULL THEN
      IF disk_backups_shared > 0 THEN
         dbms_rcvman.disk_backups_shared := TRUE#;
      ELSE
         dbms_rcvman.disk_backups_shared := FALSE#;
      END IF;
   END IF;
 
   IF tape_backups_shared IS NOT NULL THEN
      IF tape_backups_shared > 0 THEN
         dbms_rcvman.tape_backups_shared := TRUE#;
      ELSE
         dbms_rcvman.tape_backups_shared := FALSE#;
      END IF;
   END IF;
 
   deb(DEB_PRINT, 'disk_backups_shared='||dbms_rcvman.disk_backups_shared);
   deb(DEB_PRINT, 'tape_backups_shared='||dbms_rcvman.tape_backups_shared);
 
   deb(DEB_EXIT);
END setBackupFileScopeAttributes;
 
--
PROCEDURE addBackupToMKL(lbMkTab       IN OUT NOCOPY rcvRecTabII_t
                        ,rcvRec        IN rcvRec_t) IS
   nelem       number;              -- number of elements in each bucket
   key         number;              -- key to be added to table
   bucket      number;
   i           binary_integer;
   rcvRecI     rcvRecTabI_t;
BEGIN
   IF (rcvRec.type_con = backupSet_con_t) THEN
      key := rcvRec.bsKey_con;
   ELSIF (rcvRec.type_con = imageCopy_con_t OR
          rcvRec.type_con = proxyCopy_con_t) THEN
      key := rcvRec.key_con;
   ELSE
      raise_application_error(-20999, 'internal error: addBackupToMKL' ||
                              ' type=' || rcvRec.type_con);
   END IF;
 
   bucket := mod(key, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      i := CONST2GVAL - bucket;
   ELSE
      i := bucket;
   END IF;
 
   IF (NOT lbMkTab.exists(i)) THEN
      lbMkTab(i) := rcvRecI;
   END IF;
 
--
   nelem := lbMkTab(i).count;
   IF (nelem > 0) THEN
      FOR j in 0 ..nelem-1 LOOP
         IF (rcvRec.type_con = lbMkTab(i)(j).type_con) THEN
--
            IF (rcvRec.type_con = backupSet_con_t  AND
                (lbMkTab(i)(j).bsKey_con = rcvRec.bsKey_con OR
                (lbMkTab(i)(j).setStamp_con = rcvRec.setStamp_con AND
                 lbMkTab(i)(j).setCount_con = rcvRec.setCount_con))) THEN
               RETURN;
            ELSIF ((rcvRec.type_con = imageCopy_con_t    AND
                    rcvRec.type_con = proxyCopy_con_t) OR
                   lbMkTab(i)(j).recid_con = rcvRec.recid_con AND
                   lbMkTab(i)(j).stamp_con = rcvRec.stamp_con AND
                   lbMkTab(i)(j).key_con   = rcvRec.key_con) THEN
               RETURN;
            END IF;
         END IF;
      END LOOP;
   END IF;
 
   lbMkTab(i)(nelem) := rcvRec;
END addBackupToMKL;
 
--
--
FUNCTION listBackupInMKL(lbMkTab       IN rcvRecTabII_t
                        ,lbRec         IN lbRec_t)
RETURN BOOLEAN IS
   nelem       number;               -- number of elements in each bucket
   key         number;               -- key in question?
   bucket      number;
   i           binary_integer;
BEGIN
   IF (lbRec.backup_type = backupset_txt) THEN
      key := lbRec.bs_key;
   ELSIF (lbRec.backup_type = copy_txt OR
          lbRec.backup_type = proxycopy_txt) THEN
      key := lbRec.pkey;
   ELSE
      raise_application_error(-20999, 'internal error: listBackupToMKL' ||
                              ' type=' || lbRec.backup_type);
   END IF;
 
   bucket := mod(key, CONST4GVAL);
   IF (bucket >= CONST2GVAL) THEN
      i := CONST2GVAL - bucket;
   ELSE
      i := bucket;
   END IF;
 
   IF (NOT lbMkTab.exists(i)) THEN
      RETURN FALSE;
   END IF;
 
   nelem := lbMkTab(i).count;
   FOR j in 0 ..nelem-1 LOOP
--
      IF (lbMkTab(i)(j).type_con = backupSet_con_t  AND
          lbRec.backup_type = backupset_txt      AND
          (lbMkTab(i)(j).bsKey_con = lbRec.bs_key OR
           (lbMkTab(i)(j).setStamp_con = lbRec.bs_stamp AND
            lbMkTab(i)(j).setCount_con = lbRec.bs_count))) THEN
         RETURN TRUE;
      ELSIF (((lbMkTab(i)(j).type_con = imageCopy_con_t    AND
               lbRec.backup_type = copy_txt) OR
              (lbMkTab(i)(j).type_con = proxyCopy_con_t    AND
               lbRec.backup_type = proxycopy_txt))  AND
              lbMkTab(i)(j).recid_con = lbRec.recid AND
              lbMkTab(i)(j).stamp_con = lbRec.stamp AND
              lbMkTab(i)(j).key_con   = lbRec.pkey) THEN
         RETURN TRUE;
      END IF;
   END LOOP;
 
   RETURN FALSE;
END listBackupInMKL;
 
--
--
--
PROCEDURE SetGetSinceLastBackedAL(ntimes  IN number DEFAULT 1,
                                  devtype IN varchar2 DEFAULT NULL,
                                  sbpscn  IN number) IS
  last_alrec sinceLastBackedAL_c%ROWTYPE;
BEGIN
  deb(DEB_ENTER, 'SetGetSinceLastBackedAl');
 
--
  lbacked_al_next_scn        := 0;
  standby_became_primary_scn := 0;
 
  IF client_site_aware = TRUE# or sbpscn IS NULL or sbpscn = 0 THEN
    deb(DEB_IN, 'SetGetSinceLastBackedAl: lbacked_al_next_scn is 0');
  ELSE
--
--
--
--
    standby_became_primary_scn := sbpscn + 1;
 
    OPEN sinceLastBackedAL_c(devtype, ntimes);
    FETCH sinceLastBackedAL_c into last_alrec;
    IF NOT sinceLastBackedAL_c%NOTFOUND  THEN
      lbacked_al_next_scn := nvl(last_alrec.next_scn,
                                 last_alrec.low_scn);
    END IF;
    CLOSE sinceLastBackedAL_c;
  END IF;
  deb(DEB_IN, 'SetGetSinceLastBackedAl: al_next_scn=' || lbacked_al_next_scn ||
              ' sbpscn=' || standby_became_primary_scn);
  deb(DEB_EXIT, 'SetGetSinceLastBackedAl');
END SetGetSinceLastBackedAL;
 
--
FUNCTION getEncryptTSCount RETURN BINARY_INTEGER IS
   encrypt_ts_count NUMBER;
BEGIN
   SELECT  count(*) into encrypt_ts_count FROM rc_tablespace
      WHERE dbinc_key=this_dbinc_key AND
            encrypt_in_backup = 'ON';
 
   RETURN encrypt_ts_count;
END getEncryptTSCount;
 
--
--
--
--
--
FUNCTION getArchivedNextSCN
RETURN NUMBER IS
   mySCN        number;
BEGIN
   deb(DEB_ENTER, 'getArchivedNextSCN');
   SELECT nvl(max(al.next_scn),0)
     INTO mySCN
     FROM al,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE al.archived = 'Y'
      AND al.dbinc_key = d2.dbinc_key
      AND (d2.next_reset_scn IS NULL OR
           (al.low_scn >= d2.reset_scn AND
            al.low_scn < d2.next_reset_scn));
 
   SELECT greatest(nvl(max(brl.next_scn), 0), mySCN)
     INTO mySCN
     FROM brl,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE brl.dbinc_key = d2.dbinc_key
      AND (d2.next_reset_scn IS NULL OR
           (brl.low_scn >= d2.reset_scn AND
            brl.low_scn <  d2.next_reset_scn));
 
   SELECT greatest(nvl(max(xal.next_scn), 0), mySCN)
     INTO mySCN
     FROM xal,
          (SELECT dbinc_key,
                  reset_scn,
                  PRIOR reset_scn next_reset_scn
           FROM dbinc
           START WITH dbinc_key = this_dbinc_key
           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
           UNION ALL
           SELECT this_dbinc_key dbinc_key,
                  null           reset_scn,
                  null           next_reset_scn
             FROM dual) d2
    WHERE xal.dbinc_key = d2.dbinc_key
      AND (d2.next_reset_scn IS NULL OR
           (xal.low_scn  >= d2.reset_scn AND
            xal.low_scn  <  d2.next_reset_scn));
 
   deb(DEB_EXIT, 'with '||to_char(mySCN));
   RETURN mySCN;
END getArchivedNextSCN;
 
--
FUNCTION isArchivedLogMissing(fromSCN IN NUMBER, untilSCN IN NUMBER)
RETURN number IS
   thread    number;
   sequence  number;
   dbinc_key number;
BEGIN
   deb(DEB_ENTER, 'isArchivedLogMissing');
   deb(DEB_IN, 'fromSCN ='  || nvl(to_char(fromSCN), 'NULL') ||
               ' untilSCN=' || nvl(to_char(untilSCN), 'NULL'));
 
--
--
   SELECT thread#, sequence#, dbinc_key
     INTO thread, sequence, dbinc_key
     FROM (SELECT dbinc_key, thread#, sequence#, lead(sequence#, 1, sequence#+1)
             OVER (PARTITION BY thread#, dbinc_key
                       ORDER BY sequence#) nextseq
             FROM (SELECT al.thread#, al.sequence#, al.dbinc_key
                     FROM al,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                    WHERE al.dbinc_key = d2.dbinc_key
                      AND (d2.next_reset_scn IS NULL OR
                           (al.low_scn  >= d2.reset_scn AND
                            al.low_scn  <  d2.next_reset_scn))
                      AND low_scn >= fromSCN
                      AND (untilSCN IS NULL OR low_scn < untilSCN)
 
                   UNION ALL
 
                   SELECT brl.thread#, brl.sequence#, brl.dbinc_key
                     FROM brl,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                    WHERE brl.dbinc_key = d2.dbinc_key
                      AND (d2.next_reset_scn IS NULL OR
                           (brl.low_scn  >= d2.reset_scn AND
                            brl.low_scn  <  d2.next_reset_scn))
                      AND low_scn >= fromSCN
                      AND (untilSCN IS NULL OR low_scn < untilSCN)
 
                   UNION ALL
 
                   SELECT xal.thread#, xal.sequence#, xal.dbinc_key
                     FROM xal,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                    WHERE xal.dbinc_key = d2.dbinc_key
                      AND (d2.next_reset_scn IS NULL OR
                           (xal.low_scn  >= d2.reset_scn AND
                            xal.low_scn  <  d2.next_reset_scn))
                      AND low_scn >= fromSCN
                      AND (untilSCN IS NULL OR low_scn < untilSCN))
          )
   WHERE nextseq NOT IN (sequence#, sequence#+1)
     AND rownum = 1;
 
   deb(DEB_IN, 'missing sequence is (dbinc_key, thread, sequence)=('||
               to_char(dbinc_key)  || ',' ||
               to_char(thread)     || ',' ||
               to_char(sequence+1) || ')');
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE#;
END isArchivedLogMissing;
 
--
FUNCTION getMaxRedoSCN(maxScn      OUT NUMBER,
                       maxTime     OUT DATE,
                       maxDbIncKey OUT NUMBER,
                       maxRlgScn   OUT NUMBER,
                       maxRlgTime  OUT DATE,
                       isOrs       IN  NUMBER)
RETURN boolean IS
 
highScn  number;
highTime date;
dbIncKey number;
rlgscn   number;
 
BEGIN
  deb(DEB_ENTER,'getMaxRedoSCN');
 
  SELECT next_scn, next_time, dbinc_key, reset_scn
    INTO highScn, highTime, dbIncKey, rlgscn
  FROM
    (SELECT next_scn, next_time, dbinc_key, reset_scn
       FROM (SELECT (CASE 
                 WHEN al.next_scn > d2.next_reset_scn THEN d2.next_reset_scn 
                 ELSE al.next_scn END) next_scn,
                 al.next_time, al.dbinc_key, d2.reset_scn
              FROM al,
                   (SELECT dbinc_key,
                           reset_scn,
                           PRIOR reset_scn next_reset_scn
                      FROM dbinc
                      START WITH dbinc_key = this_dbinc_key
                      CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                      UNION ALL
                      SELECT this_dbinc_key dbinc_key,
                             null           reset_scn,
                             null           next_reset_scn
                        FROM dual) d2
              WHERE al.dbinc_key = d2.dbinc_key
                AND (d2.next_reset_scn IS NULL OR
                     (al.low_scn  >= d2.reset_scn AND
                      al.low_scn  <  d2.next_reset_scn))
                AND (isOrs = TRUE# OR 
                     (restoreRangeDevTyp IN ('RC$DISK', 'RC$ANY')))
                AND (localOrsSiteKey IS NULL OR localOrsSiteKey = al.site_key) 
                AND ((client_site_aware = TRUE# AND
                      ((user_site_key = al.site_key) OR
                       (user_site_key IS NULL AND
                        (logs_shared = TRUE# OR
                         this_site_key = nvl(al.site_key, this_site_key))))) OR
                     (client_site_aware = FALSE#))
 
             UNION ALL
 
             SELECT (CASE
                 WHEN brl.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                 ELSE brl.next_scn END) next_scn, 
                 brl.next_time, brl.dbinc_key, d2.reset_scn
               FROM brl, bp,
                    (SELECT dbinc_key,
                            reset_scn,
                            PRIOR reset_scn next_reset_scn
                       FROM dbinc
                       START WITH dbinc_key = this_dbinc_key
                       CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                       UNION ALL
                       SELECT this_dbinc_key dbinc_key,
                              null           reset_scn,
                              null           next_reset_scn
                         FROM dual) d2
               WHERE brl.bs_key = bp.bs_key
                 AND brl.dbinc_key = d2.dbinc_key
                 AND (d2.next_reset_scn IS NULL OR
                       (brl.low_scn  >= d2.reset_scn AND
                          brl.low_scn  <  d2.next_reset_scn))
                 AND (isOrs = TRUE# OR 
                      ((restoreRangeDevTyp = 'RC$DISK' AND 
                        bp.device_type = 'DISK') OR 
                       (restoreRangeDevTyp = 'RC$SBT' AND
                        bp.device_type = 'SBT_TAPE') OR 
                       restoreRangeDevTyp = 'RC$ANY'))
                 AND (localOrsSiteKey IS NULL OR 
                      (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
                       bp.ba_access IN ('D', 'L')) OR
                      (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
                       (bp.ba_access IN ('T', 'R') AND 
                        localOrsSiteKey = bp.site_key)))
                 AND bp.db_key = this_db_key
                 AND bp.status != 'D'
                 AND ((user_site_key = bp.site_key) OR
                      (user_site_key IS NULL AND
                       ((disk_backups_shared = TRUE# AND 
                         bp.device_type = 'DISK') OR
                        (tape_backups_shared = TRUE# AND 
                         bp.device_type <> 'DISK') OR
                        (this_site_key = nvl(bp.site_key, this_site_key)))))
 
             UNION ALL
 
             SELECT (CASE
                 WHEN xal.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                 ELSE xal.next_scn END) next_scn, 
                 xal.next_time, xal.dbinc_key, d2.reset_scn
               FROM xal,
                    (SELECT dbinc_key,
                            reset_scn,
                            PRIOR reset_scn next_reset_scn
                       FROM dbinc
                       START WITH dbinc_key = this_dbinc_key
                       CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                       UNION ALL
                       SELECT this_dbinc_key dbinc_key,
                              null           reset_scn,
                              null           next_reset_scn
                         FROM dual) d2
               WHERE xal.dbinc_key = d2.dbinc_key
                 AND (d2.next_reset_scn IS NULL OR
                       (xal.low_scn  >= d2.reset_scn AND
                          xal.low_scn  <  d2.next_reset_scn))
                 AND (isOrs = TRUE# OR 
                      (restoreRangeDevTyp IN ('RC$SBT', 'RC$ANY')))
                 AND (localOrsSiteKey IS NULL OR localOrsSiteKey = xal.site_key)
                 AND ((user_site_key  = xal.site_key) OR
                      (user_site_key IS NULL AND
                       ((tape_backups_shared = TRUE#) OR
                        (this_site_key = NVL(xal.site_key, this_site_key)))))
            ) ORDER BY next_scn DESC) 
  WHERE rownum = 1;
 
  maxScn      := highScn;
  maxTime     := highTime;
  maxDbIncKey := dbIncKey;
  maxRlgScn   := rlgscn;
  deb(DEB_IN, 'Max scn is = '||to_char(maxScn));
  deb(DEB_EXIT, 'with TRUE');
  RETURN TRUE;
EXCEPTION
  WHEN no_data_found THEN
     deb(DEB_EXIT, 'with FALSE');
     RETURN FALSE;
END getMaxRedoSCN;
 
--
FUNCTION getNextAvailableSCN(fromScn           IN   NUMBER,
                             nextAvailableSCN  OUT  NUMBER,
                             isOrs             IN   NUMBER)
RETURN boolean IS
 
lowScn number;
 
BEGIN
  deb(DEB_ENTER,'getNextAvailableSCN');
  deb(DEB_IN, 'finding next avilable scn after '
               || nvl(to_char(fromSCN), 'NULL'));
 
 
  SELECT min(low_scn) INTO lowScn
    FROM (SELECT  al.low_scn
            FROM al,
                 (SELECT dbinc_key,
                         reset_scn,
                         PRIOR reset_scn next_reset_scn
                    FROM dbinc
                    START WITH dbinc_key = this_dbinc_key
                    CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                    UNION ALL
                    SELECT this_dbinc_key dbinc_key,
                           null           reset_scn,
                           null           next_reset_scn
                      FROM dual) d2
            WHERE al.dbinc_key = d2.dbinc_key
              AND (d2.next_reset_scn IS NULL OR
                   (al.low_scn  >= d2.reset_scn AND
                    al.low_scn  <  d2.next_reset_scn))
              AND al.low_scn > fromScn
              AND (isOrs = TRUE# OR 
                   (restoreRangeDevTyp IN ('RC$DISK', 'RC$ANY')))
              AND (localOrsSiteKey IS NULL OR localOrsSiteKey = al.site_key)
              AND ((client_site_aware = TRUE# AND
                    ((user_site_key = al.site_key) OR
                     (user_site_key IS NULL AND
                      (logs_shared = TRUE# OR
                       this_site_key = nvl(al.site_key, this_site_key))))) OR
                   (client_site_aware = FALSE#))
 
          UNION ALL
 
          SELECT  brl.low_scn
            FROM brl, bp,
                 (SELECT dbinc_key,
                         reset_scn,
                         PRIOR reset_scn next_reset_scn
                    FROM dbinc
                    START WITH dbinc_key = this_dbinc_key
                    CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                    UNION ALL
                    SELECT this_dbinc_key dbinc_key,
                           null           reset_scn,
                           null           next_reset_scn
                      FROM dual) d2
            WHERE brl.bs_key = bp.bs_key
              AND brl.dbinc_key = d2.dbinc_key
              AND (d2.next_reset_scn IS NULL OR
                    (brl.low_scn  >= d2.reset_scn AND
                       brl.low_scn  <  d2.next_reset_scn))
              AND brl.low_scn > fromScn
              AND (isOrs = TRUE# OR 
                   ((restoreRangeDevTyp = 'RC$DISK' AND
                     bp.device_type = 'DISK') OR  
                    (restoreRangeDevTyp = 'RC$SBT' AND
                     bp.device_type = 'SBT_TAPE') OR
                    restoreRangeDevTyp = 'RC$ANY'))
              AND (localOrsSiteKey IS NULL OR 
                   (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND
                    bp.ba_access IN ('D', 'L')) OR
                   (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND
                    (bp.ba_access IN ('T', 'R') AND
                     localOrsSiteKey = bp.site_key)))
              AND bp.db_key = this_db_key
              AND bp.status != 'D'
              AND ((user_site_key = bp.site_key) OR
                   (user_site_key IS NULL AND
                    ((disk_backups_shared = TRUE# AND 
                      bp.device_type = 'DISK') OR
                     (tape_backups_shared = TRUE# AND 
                      bp.device_type <> 'DISK') OR
                     (this_site_key = nvl(bp.site_key, this_site_key)))))
    
          UNION ALL
 
          SELECT  xal.low_scn
            FROM xal,
                 (SELECT dbinc_key,
                         reset_scn,
                         PRIOR reset_scn next_reset_scn
                    FROM dbinc
                    START WITH dbinc_key = this_dbinc_key
                    CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                    UNION ALL
                    SELECT this_dbinc_key dbinc_key,
                           null           reset_scn,
                           null           next_reset_scn
                      FROM dual) d2
            WHERE xal.dbinc_key = d2.dbinc_key
              AND (d2.next_reset_scn IS NULL OR
                    (xal.low_scn  >= d2.reset_scn AND
                       xal.low_scn  <  d2.next_reset_scn))
              AND xal.low_scn > fromScn
              AND (isOrs = TRUE# OR 
                   (restoreRangeDevTyp IN ('RC$SBT', 'RC$ANY')))
              AND (localOrsSiteKey IS NULL OR localOrsSiteKey = xal.site_key)
              AND ((user_site_key  = xal.site_key) OR
                   (user_site_key IS NULL AND
                    ((tape_backups_shared = TRUE#) OR
                     (this_site_key = NVL(xal.site_key, this_site_key))))));
 
   nextAvailableSCN := lowScn;
   deb(DEB_IN, 'next available scn is = '||to_char(nextAvailableSCN));
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
END getNextAvailableSCN;
 
--
FUNCTION findLogBreakPoint(logBreakPointScn       OUT NUMBER,
                           logBreakPointTime      OUT DATE,
                           logBreakPointDbIncKey  OUT NUMBER,
                           logBreakPointRlgScn    OUT NUMBER,
                           logBreakPointRlgTime   OUT DATE,
                           fromSCN                IN  NUMBER,
                           untilSCN               IN  NUMBER,
                           isOrs                  IN  NUMBER)
RETURN boolean IS
   thread    number;
   sequence  number;
   dbinc_key number;
   nxtscn    number;
   nxttime   date;
   rlgscn    number;
BEGIN
   deb(DEB_ENTER, 'findLogBreakPoint');
   deb(DEB_IN, 'fromSCN ='  || nvl(to_char(fromSCN), 'NULL') ||
               ' untilSCN=' || nvl(to_char(untilSCN), 'NULL'));
 
--
--
 
   SELECT thread#, sequence#, dbinc_key, next_scn, next_time, reset_scn
     INTO thread, sequence, dbinc_key, nxtscn, nxttime, rlgscn
     FROM (SELECT dbinc_key, thread#, sequence#, next_scn, next_time,
                   reset_scn, lead(sequence#, 1, sequence#+1)
             OVER (PARTITION BY thread#, dbinc_key
                       ORDER BY sequence#) nextseq
           FROM (
                   SELECT al.thread#, al.sequence#, al.dbinc_key,       
                   (CASE
                   WHEN al.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                     ELSE al.next_scn END) next_scn,
                     al.next_time, d2.reset_scn
                     FROM al,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                     WHERE al.dbinc_key = d2.dbinc_key
                       AND (d2.next_reset_scn IS NULL OR
                            (al.low_scn  >= d2.reset_scn AND
                             al.low_scn  <  d2.next_reset_scn))
                       AND next_scn >= fromSCN
                       AND (untilSCN IS NULL OR low_scn < untilSCN)
                       AND (isOrs = TRUE# OR (restoreRangeDevTyp IN
                           ('RC$DISK', 'RC$ANY')))
                       AND (localOrsSiteKey IS NULL OR 
                            localOrsSiteKey = al.site_key)
                       AND ((client_site_aware = TRUE# AND
                             ((user_site_key = al.site_key) OR
                              (user_site_key IS NULL AND
                               (logs_shared = TRUE# OR
                                this_site_key = 
                                nvl(al.site_key, this_site_key))))) OR
                            (client_site_aware = FALSE#))
 
                 UNION ALL
 
                   SELECT brl.thread#, brl.sequence#, brl.dbinc_key,
                   (CASE
                   WHEN brl.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                     ELSE brl.next_scn END) next_scn,
                      brl.next_time, d2.reset_scn
                     FROM brl, bp,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                     WHERE brl.bs_key = bp.bs_key
                       AND brl.dbinc_key = d2.dbinc_key
                       AND (d2.next_reset_scn IS NULL OR
                            (brl.low_scn  >= d2.reset_scn AND
                             brl.low_scn  <  d2.next_reset_scn))
--
--
--
                       AND next_scn >= fromSCN
                       AND (untilSCN IS NULL OR low_scn < untilSCN)
                       AND (isOrs = TRUE# OR 
                            ((restoreRangeDevTyp = 'RC$DISK' AND
                              bp.device_type = 'DISK') OR 
                             (restoreRangeDevTyp = 'RC$SBT' AND
                              bp.device_type = 'SBT_TAPE') OR
                             restoreRangeDevTyp = 'RC$ANY'))
                       AND (localOrsSiteKey IS NULL OR 
                            (restoreRangeDevTyp IN ('RA$DISK', 'RA$ANY') AND 
                             bp.ba_access IN ('D', 'L')) OR
                            (restoreRangeDevTyp IN ('RA$SBT', 'RA$ANY') AND 
                             (bp.ba_access IN ('T', 'R') AND 
                              localOrsSiteKey = bp.site_key)))
                       AND bp.db_key = this_db_key
                       AND bp.status != 'D'
                       AND ((user_site_key = bp.site_key) OR
                            (user_site_key IS NULL AND
                             ((disk_backups_shared = TRUE# AND 
                               bp.device_type = 'DISK') OR
                              (tape_backups_shared = TRUE# AND 
                               bp.device_type <> 'DISK') OR
                              (this_site_key = 
                               nvl(bp.site_key, this_site_key)))))
 
                UNION ALL
 
                SELECT xal.thread#, xal.sequence#, xal.dbinc_key,
                   (CASE
                   WHEN xal.next_scn > d2.next_reset_scn THEN d2.next_reset_scn
                     ELSE xal.next_scn END) next_scn,
                      xal.next_time, d2.reset_scn
                     FROM xal,
                          (SELECT dbinc_key,
                                  reset_scn,
                                  PRIOR reset_scn next_reset_scn
                           FROM dbinc
                           START WITH dbinc_key = this_dbinc_key
                           CONNECT BY PRIOR parent_dbinc_key = dbinc_key
                           UNION ALL
                           SELECT this_dbinc_key dbinc_key,
                                  null           reset_scn,
                                  null           next_reset_scn
                             FROM dual) d2
                     WHERE xal.dbinc_key = d2.dbinc_key
                       AND (d2.next_reset_scn IS NULL OR
                            (xal.low_scn  >= d2.reset_scn AND
                             xal.low_scn  <  d2.next_reset_scn))
                       AND next_scn >= fromSCN
                       AND (untilSCN IS NULL OR low_scn < untilSCN)
                       AND (isOrs = TRUE# OR (restoreRangeDevTyp IN
                           ('RC$SBT', 'RC$ANY')))
                       AND (localOrsSiteKey IS NULL OR 
                           localOrsSiteKey = xal.site_key)
                       AND ((user_site_key  = xal.site_key) OR
                            (user_site_key IS NULL AND
                             ((tape_backups_shared = TRUE#) OR
                              (this_site_key = 
                               NVL(xal.site_key, this_site_key))))))
            )
     WHERE nextseq NOT IN (sequence#, sequence#+1)
       AND rownum = 1;
 
   logBreakPointScn      := nxtscn;
   logBreakPointTime     := nxttime;
   logBreakPointDbIncKey := dbinc_key;
   logBreakPointRlgScn   := rlgscn;
   deb(DEB_IN, 'missing sequence is 
               (dbinc_key, thread, sequence, nextscn)=('||
               to_char(dbinc_key)  || ',' ||
               to_char(thread)     || ',' ||
               to_char(sequence+1) || ',' ||
               to_char(nxtscn)    || ')');
   deb(DEB_EXIT, 'with TRUE');
   RETURN TRUE;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
END findLogBreakPoint;
 
--
FUNCTION getDropSCN(dfNum        IN  NUMBER,
                    creScn       IN  NUMBER,
                    creTime      IN  DATE,
                    plugScn      IN  NUMBER,
                    foreignDbId  IN  NUMBER,
                    dropScn      OUT NUMBER,
                    dropTime     OUT DATE,
                    dropDbIncKey OUT NUMBER,
                    dropRlgScn   OUT NUMBER,
                    dropRlgTime  OUT DATE)
RETURN boolean IS
BEGIN
 
  deb(DEB_ENTER, 'getDropSCN');
 
  SELECT drop_scn, drop_time, dbinc_key, reset_scn, reset_time
    INTO dropScn, dropTime, dropDbIncKey, dropRlgScn, dropRlgTime
    FROM (SELECT drop_scn, drop_time, df.dbinc_key, reset_scn, reset_time
            FROM df, dbinc
           WHERE df.dbinc_key  = dbinc.dbinc_key
             AND dbinc.db_key  = this_db_key
             AND file#         = dfNum
             AND create_scn    = creScn
             AND create_time   = creTime
             AND plugin_scn    = plugScn
             AND foreign_dbid  = foreignDbId
             AND (dbinc_status = 'PARENT' OR
                  dbinc_status = 'CURRENT')
           ORDER BY reset_scn desc)
   WHERE rownum = 1;
 
  IF (dropScn IS NULL) THEN
     deb(DEB_EXIT, 'with FALSE');
     RETURN FALSE;
  ELSE
    deb(DEB_EXIT, 'with TRUE');
    RETURN TRUE;
  END IF;
EXCEPTION
    WHEN OTHERS THEN
      deb(DEB_IN, 'found exception: ' || substr(sqlerrm, 1, 512));
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
END getDropSCN;
 
--
FUNCTION setLocalOrsSiteKey(db_id IN NUMBER)
RETURN boolean IS
  dbUnqName               node.db_unique_name%TYPE;
  l_db_id                 NUMBER;
BEGIN
 
  deb(DEB_ENTER, 'setLocalOrsSiteKey ' || db_id);
  l_db_id := db_id;
 
  localOrsSiteKey := NULL;
 
  IF (user_site_key IS NOT NULL) THEN
    deb(DEB_IN, 'user_site_key is set');
    deb(DEB_EXIT, 'with TRUE');
    return TRUE;
  END IF;
 
  BEGIN
    EXECUTE IMMEDIATE 'select rtrim(ltrim(value)) 
       from sys.v_$parameter where lower(name)=''db_unique_name'''
       into dbUnqName;
 
  EXCEPTION
    WHEN OTHERS THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
  END;
 
  deb(DEB_IN, 'ORS db_uniqune_name is ' || dbUnqName); 
 
  IF l_db_id IS NULL THEN
     SELECT db_id INTO l_db_id from db where db_key = this_db_key;
     deb(DEB_IN, 'using default db_id from setDatabase ' || l_db_id);
  END IF;
 
  BEGIN
    SELECT SITE_KEY INTO localOrsSiteKey FROM node
      WHERE UPPER(DB_UNIQUE_NAME) = 
            UPPER('$'||dbUnqName||'$'||to_char(l_db_id));
 
  EXCEPTION
    WHEN OTHERS THEN
      deb(DEB_EXIT, 'with FALSE');
      RETURN FALSE;
  END;
 
  deb(DEB_IN, 'Local Ors site key ' || to_char(localOrsSiteKey));
  deb(DEB_EXIT, 'with TRUE');
  return TRUE;
 
END setLocalOrsSiteKey;
 
--
PROCEDURE resetLocalOrsSiteKey IS
BEGIN
   deb(DEB_ENTER, 'resetLocalOrsSiteKey');
   localOrsSiteKey := NULL;
   deb(DEB_EXIT);
END resetLocalOrsSiteKey;
 
--
FUNCTION getIncarnationKey(untilSCN IN NUMBER)
RETURN number IS
   myInc number;
BEGIN
   deb(DEB_ENTER, 'getIncarnationKey');
 
   IF (untilSCN <= this_reset_scn) THEN
      SELECT dbinc.dbinc_key
        INTO myInc
        FROM (SELECT dbinc_key, reset_scn, PRIOR reset_scn next_reset_scn
                FROM dbinc
          START WITH dbinc_key = this_dbinc_key
          CONNECT BY PRIOR parent_dbinc_key = dbinc_key) dbinc
       WHERE dbinc.reset_scn < untilSCN
         AND dbinc.next_reset_scn >= untilSCN;
   ELSE
      myInc := 0;
   END IF;
 
   deb(DEB_EXIT, 'with incKey=' || to_char(myInc));
   RETURN myInc;
END getIncarnationKey;
 
 
--
FUNCTION getMaxScn
RETURN number IS
   logmaxnt  date;
BEGIN
   return getMaxScn(logmaxnt);
END;
 
FUNCTION getMaxScn(logmaxnt OUT date) return number IS
   minmaxnc  number;
   minmaxnt  date;
BEGIN
   IF (this_dbinc_key is NULL) THEN
      deb(DEB_EXIT, 'with error 20020');
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
 
   /* Bug 2377581: Find SCN from enabled threads only. */
   select min(maxnc), min(maxnt)
     into minmaxnc, minmaxnt
     from (select max(next_scn) maxnc, max(NEXT_TIME) maxnt
             from (select a.next_scn, a.next_time, a.thread# tno
                     from al a, rt t
                    where a.THREAD#            = t.THREAD#
                      and a.ARCHIVED           = 'Y'
                      and t.status             not in ('D', 'I')
                      and t.dbinc_key          = this_dbinc_key
                      and a.dbinc_key          = this_dbinc_key
                    union
                   select b.next_scn, b.next_time, b.thread# tno
                     from brl b, rt t
                    where b.THREAD#            = t.THREAD#
                      and t.status             not in ('D', 'I')
                      and t.dbinc_key          = this_dbinc_key
                      and b.dbinc_key          = this_dbinc_key)
             group by tno);
   logmaxnt := minmaxnt;
   return minmaxnc;
END getMaxScn;
 
--
FUNCTION getActualDbinc RETURN NUMBER
IS
BEGIN
   return actual_dbinc_key;
END getActualDbinc;
 
--
PROCEDURE setStdbyCtrlScn(
   ctrlSCN IN NUMBER)
IS
BEGIN
   deb(DEB_PRINT, 'Setting this_stdby_controlfile_scn' || ctrlSCN);
   this_stdby_controlfile_scn := ctrlSCN;
END setStdbyCtrlScn;
 
--
FUNCTION guidToPdbKey(guid IN VARCHAR2) RETURN NUMBER IS
   pdbKey NUMBER;
BEGIN
   IF (guid IS NULL) THEN
      RETURN NULL;
   END IF;
 
   SELECT max(pdb_key) INTO pdbKey
     FROM pdb
    WHERE pdb.guid = guidToPdbKey.guid
      AND pdb.db_key = this_db_key;
 
   RETURN pdbKey;
END guidToPdbKey;
 
--
--
--
--
--
--
--
--
--
--
--
 
--
--
--
 
--
FUNCTION dumpState(
   lineno IN number)
RETURN varchar2 IS
BEGIN
   IF    lineno =  1 THEN RETURN 'this_db_key=' || 
                                 nvl(to_char(this_db_key), 'NULL');
   ELSIF lineno =  2 THEN RETURN 'this_dbinc_key=' ||
                                 nvl(to_char(this_dbinc_key), 'NULL');
   ELSIF lineno =  3 THEN RETURN 'this_reset_scn=' ||
                                 nvl(to_char(this_reset_scn), 'NULL');
   ELSIF lineno =  4 THEN RETURN 'this_reset_time=' ||
                                 nvl(to_char(this_reset_time), 'NULL');
   ELSIF lineno =  5 THEN RETURN 'untilSCN=' ||
                                 nvl(to_char(untilSCN), 'NULL');
   ELSIF lineno =  6 THEN RETURN 'untilTime=' ||
                                 nvl(to_char(untilTime), 'NULL');
   ELSIF lineno =  7 THEN RETURN 'getRA_completedAfter=' ||
                                 nvl(to_char(getRA_completedAfter), 'NULL');
   ELSIF lineno =  8 THEN RETURN 'getRA_completedBefore=' ||
                                 nvl(to_char(getRA_completedBefore), 'NULL');
   ELSIF lineno =  9 THEN RETURN 'getRA_likePattern=' ||
                                 nvl(getRA_likePattern, 'NULL');
   ELSIF lineno = 10 THEN RETURN 'getRA_containerMask=' ||
                                 nvl(to_char(getRA_containerMask), 'NULL');
   ELSIF lineno = 11 THEN RETURN 'getRA_actionMask=' ||
                                 nvl(to_char(getRA_actionMask), 'NULL');
   ELSIF lineno = 12 THEN RETURN 'computeRA_allRecords=' ||
                                 nvl(to_char(computeRA_allRecords), 'NULL');
   ELSIF lineno = 13 THEN RETURN 'computeRA_fullBackups=' ||
                                 nvl(to_char(computeRA_fullBackups), 'NULL');
   ELSIF lineno = 14 THEN RETURN 'allIncarnations=' ||
                                 nvl(to_char(allIncarnations), 'NULL');
   ELSE RETURN NULL;
   END IF;
END dumpState;
 
--
PROCEDURE dumpPkgState(msg in varchar2 default null) IS
   line varchar2(132);
   lno number := 1;
BEGIN
   deb(DEB_ENTER, 'dumpPkgState ' || nvl(msg, ' '));
   loop
       line := dumpState(lno);
       if line is NULL then
          exit;
       else
          deb(DEB_PRINT, line);
          lno := lno + 1;
       end if;
   end loop;
   deb(DEB_EXIT);
END dumpPkgState;
 
--
PROCEDURE setDebugOn
IS
BEGIN
   if debug is null or not debug then
--
--
--
--
      dbms_output.enable(buffer_size => null);
      debug := TRUE;
   else
      deb(DEB_PRINT, 'Debug on - debug lready enabled');
   end if;
END setDebugOn;
 
--
PROCEDURE setDebugOff
IS
BEGIN
   dumpPkgState('Debug Off');
   dbms_output.disable;  -- free memory
   debug := FALSE;
END setDebugOff;
 
--
--
--
 
--
--
--
--
 
--
PROCEDURE initialize(
   rman_vsn IN number)
IS
BEGIN
   NULL;
END initialize;
 
--
PROCEDURE set_package_constants
IS
BEGIN
--
--
--
--
   NULL;
END set_package_constants;
 
--
--
--
 
--
FUNCTION stamp2date(
   stamp IN number)
RETURN date
IS
   x    number;
   dt   varchar2(19);
BEGIN
   x := stamp;
 
   dt := to_char(mod(x,60), 'FM09'); -- seconds
   x := floor(x/60);
 
   dt := to_char(mod(x,60), 'FM09') || ':' || dt; -- minutes
   x := floor(x/60);
 
   dt := to_char(mod(x,24), 'FM09') || ':' || dt; -- hours
   x := floor(x/24);
 
   dt := to_char(mod(x,31)+1, 'FM09') || ' ' || dt; -- days
   x := floor(x/31);
 
   dt := to_char(mod(x,12)+1, 'FM09') || '/' || dt; -- months
 
   dt := to_char(floor(x/12)+1988)   || '/' || dt;
 
   RETURN to_date(dt, 'YYYY/MM/DD HH24:MI:SS');
END stamp2date;
 
--
--
--
 
--
--
PROCEDURE setAllFlag(
   flag IN boolean)
IS
BEGIN
   setAllIncarnations(flag);
   IF (flag) THEN
      ignoreCreationSCN := TRUE#;
   ELSE
      ignoreCreationSCN := FALSE#;
   END IF;
END setAllFlag;
 
--
FUNCTION getUntilTime
RETURN date IS
BEGIN
   RETURN untilTime;
END getUntilTime;
 
--
FUNCTION getUntilScn
RETURN number IS
BEGIN
   RETURN untilScn;
END getUntilScn;
 
--
PROCEDURE resetUntil
IS
BEGIN
   untilSCN := NULL;
   untilTime := NULL;
   rpoint_set := FALSE;
END resetUntil;
 
--
PROCEDURE setFrom(
   restorefrom IN number DEFAULT NULL)
IS
BEGIN
   IF (restorefrom = BACKUP) THEN
      restoreSource := backupSet_con_t + proxyCopy_con_t;
   ELSIF (restorefrom = COPY) THEN
      restoreSource := imageCopy_con_t;
   ELSIF (restorefrom = NONPROXY) THEN
      restoreSource := imageCopy_con_t + backupSet_con_t;
   ELSIF (restorefrom = AVMCOPY) THEN
--
      IF (dbms_rcvcat.isAMSchema) THEN
         restoreSource := avmImageCopy_con_t;
      END IF;
--
      IF (bitand(nvl(restoreSource, 0), avmImageCopy_con_t) = 0) THEN
         raise_application_error(-20514,
            'feature requires Availability Machine recovery catalog');
      END IF;
   ELSIF (restorefrom is NULL) THEN
      restoreSource := NULL;
   ELSE
      raise_application_error(-20200, 'Invalid restore source');
   END IF;
 
END setFrom;
 
--
PROCEDURE setSparseness(
   sparseness IN number DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'setSparseness');
   deb(DEB_IN, 'restoreSparse='|| restoreSparse);
   IF (sparseness = SPARSE) THEN
      restoreSparse := BACKUP_SPARSENESS_SPARSE;
   ELSIF (sparseness = NONSPARSE) THEN
      restoreSparse := BACKUP_SPARSENESS_NONSPARSE;
   ELSE
      restoreSparse := BACKUP_SPARSENESS_UNSPECIFIED;
   END IF;
   deb(DEB_IN, 'restoreSparse='|| restoreSparse);
   deb(DEB_EXIT);
END setSparseness;
 
--
PROCEDURE setDeviceType(
   type IN varchar2)
IS
BEGIN
   IF (deviceCount >= 8) THEN
      raise_application_error(-20280, 'Too many device types');
   END IF;
   deviceCount := deviceCount + 1;
   deviceList(deviceCount) := type;
   IF (type = 'DISK') THEN
      diskDevice := TRUE;
   END IF;
END setDeviceType;
 
--
PROCEDURE setStandby(
   stby IN boolean)
IS
BEGIN
   if stby is NULL then
      onlyStandby := NULL;
   elsif stby then
      onlyStandby := TRUE#;
   else
      onlyStandby := FALSE#;
   end if;
END setStandby;
 
--
PROCEDURE setDeviceTypeAny
IS
BEGIN
   diskDevice  := TRUE;
   anyDevice   := TRUE#;
   deviceCount := 0;
END setDeviceTypeAny;
 
--
PROCEDURE resetDeviceType
IS
BEGIN
   FOR i in 1..8 LOOP
      deviceList(i) := NULL;
   END LOOP;
   deviceCount := 0;
   diskDevice  := FALSE;
   anyDevice   := FALSE#;
END resetDeviceType;
 
--
PROCEDURE setTag(
   tag IN varchar2 DEFAULT NULL)
IS
BEGIN
   restoreTag := tag;
END setTag;
 
--
PROCEDURE setRecoveryDestFile(onlyrdf IN BOOLEAN)
IS
BEGIN
  if onlyrdf then
     recoveryDestFile := TRUE;
  else
     recoveryDestFile := FALSE;
  end if;
END setRecoveryDestFile;
 
--
PROCEDURE setOrsFile(localOnly IN BOOLEAN, libKey IN NUMBER)
IS
BEGIN
  orsLocalFile := localOnly;
  orsLibKey    := libKey;
  orsAnyFile   := (NOT localOnly AND libKey IS NULL);
END setOrsFile;
 
--
--
--
 
--
FUNCTION getValidBackupSet(
   validBackupSetRec            OUT NOCOPY validBackupSetRec_t
  ,checkDeviceIsAllocated       IN  number DEFAULT FALSE#)
RETURN number IS
   lastCode     number;
   checkRc      number;
   local        validBackupSetRec_t;
BEGIN
   IF (bsRecCacheEnabled) THEN
      RETURN cacheGetValidBackupSet(
                          validBackupSetRec      => validBackupSetRec,
                          checkDeviceIsAllocated => checkDeviceIsAllocated);
   END IF;
 
   deb(DEB_ENTER, 'getValidBackupSet');
 
--
   IF (getValidBackupSetCursor = 'findValidBackupSet1P_c') THEN
      IF (NOT findValidBackupSet1P_c%ISOPEN) THEN
         RETURN FALSE#;
      END IF;
   ELSIF (getValidBackupSetCursor = 'findValidBackupSet_c') THEN
      IF (NOT findValidBackupSet_c%ISOPEN) THEN
         RETURN FALSE#;
      END IF;
   ELSE
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
<<nextRow>>
   IF (getValidBackupSetCursor = 'findValidBackupSet1P_c') THEN
      FETCH findValidBackupSet1P_c
         INTO local;
 
      IF (findValidBackupSet1P_c%NOTFOUND) THEN
         CLOSE findValidBackupSet1P_c;
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
      END IF;
   ELSIF (getValidBackupSetCursor = 'findValidBackupSet_c') THEN
      FETCH findValidBackupSet_c
         INTO local;
 
      IF (findValidBackupSet_c%NOTFOUND) THEN
         CLOSE findValidBackupSet_c;
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
      END IF;
   END IF;
 
   lastCode := getValidBackupSetLast.code;      -- save for test below
   getValidBackupSetLast := local;              -- save for next time here
 
   IF (local.code <= lastCode) THEN
--
--
--
--
--
--
--
 
--
--
--
--
 
--
--
--
--
--
 
--
--
--
--
 
      IF (checkDeviceIsAllocated = TRUE#) THEN
         IF (anyDevice = FALSE# AND
             isDeviceTypeAllocated(local.deviceType) = FALSE#) THEN
            deb(DEB_IN, 'device type not allocated: ' ||
                local.deviceType);
            GOTO nextRow;
         END IF;
      END IF;
      validBackupSetRec := local;               -- set OUT mode arg
      deb(DEB_IN, 'returning valid rec deviceType=' ||
          local.deviceType || ' tag=' || local.tag || ' copyNumber=' ||
          to_char(local.copyNumber));
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      deb(DEB_IN, ' local.code=' || to_char(local.code) ||
          ' lastCode=' || to_char(lastCode));
      GOTO nextRow;
   END IF;
   deb(DEB_EXIT);
END getValidBackupSet;
 
--
--
--
 
--
FUNCTION getRcvRec(
   funCode      IN number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,callAgain    OUT number)
RETURN number IS
   rc           number;
BEGIN
   deb(DEB_ENTER, 'getRcvRec');
   rc := 0;                                     -- init for procedures
   callAgain := TRUE#;
 
   deb(DEB_IN, ' funCode=' || to_char(funCode));
 
   IF (funCode = getCfCopy) THEN
      getControlfileCopy(rcvRec);
   ELSIF (funCode = getDfCopy) THEN
      getDatafileCopy(rcvRec);
   ELSIF (funCode = getAnyProxy) THEN
      getProxyCopy(rcvRec);
   ELSIF (funCode = getCfBackup) THEN
      rc := getControlfileBackup(rcvRec);
      IF (rc != SUCCESS OR NOT findControlfileBackupCursor) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = getSfBackup) THEN
      rc := getSpfileBackup(rcvRec => rcvRec);
      IF (rc != SUCCESS OR NOT findSpfileBackupCursor) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = listCfCopy) THEN
      listGetControlfileCopy(rcvRec);
   ELSIF (funCode = listDfCopy) THEN
      listGetDatafileCopy(rcvRec);
   ELSIF (funCode = listCfBackup) THEN
      listGetControlfileBackup(rcvRec);
   ELSIF (funCode = listSfBackup) THEN
      listGetSpfileBackup(rcvRec);
   ELSIF (funCode = listDfBackup) THEN
      listGetDatafileBackup(rcvRec);
   ELSIF (funCode = listAlBackup) THEN
      listGetArchivedLogBackup(rcvRec);
   ELSIF (funCode = listDfProxy) THEN
      listGetProxyDatafile(rcvRec);
   ELSIF (funCode = listAlProxy) THEN
      listGetProxyArchivedLog(rcvRec);
   ELSIF (funCode = getRecovAction) THEN
      callAgain := getRecoveryAction(rcvRec);
   ELSIF (funCode = getAlBackup) THEN
      rc := getArchivedLogBackup(rcvRec);
      IF (rc != SUCCESS) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = getRangeAlBackup) THEN
      rc := getRangeArchivedLogBackup(rcvRec);
      IF (rc = UNAVAILABLE) THEN
         callAgain := FALSE#;
      END IF;
   ELSIF (funCode = listAlCopy) THEN
      listGetArchivedLogCopy(rcvRec);
   ELSIF (funCode = listBSet) THEN
      listGetBackupsetFiles(rcvRec);
   ELSIF (funCode = getAllBSet) THEN
      getAllBackupSet(rcvRec);
   ELSE
      deb(DEB_EXIT, 'with error 20999');
      raise_application_error(-20999, 'getRcvRec: unknown funCode: ' ||
                              to_char(funCode));
   END IF;
 
   IF (debug) THEN
      printRcvRec(rcvRec);
      deb(DEB_EXIT, 'with rc:'||TO_CHAR(rc));
   END IF;
 
--
--
--
 
   RETURN rc;
 
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
END getRcvRec;
 
--
--
--
 
--
PROCEDURE translateDatabase(
   sinceUntilSCN IN number DEFAULT NULL)
IS
   fromSCN      number;
   toSCN        number;
BEGIN
   deb(DEB_ENTER, 'translateDatabase');
   validateState(getDatafileCursor);
 
   IF (untilSCN is NULL) THEN
--
      fromSCN := MAXSCNVAL;
      toSCN   := MAXSCNVAL;
   ELSE                                 -- an until clause is in effect
      fromSCN := untilSCN;
      IF (sinceUntilSCN = TRUE#) THEN
--
--
--
         toSCN := MAXSCNVAL;
      ELSE
--
--
--
         toSCN := fromSCN;
      END IF;
   END IF;
 
   IF (pdbIdList.count = 0) THEN
      deb(DEB_OPEN, 'translateDatabase_c');
      OPEN translateDatabase_c(fromSCN, toSCN);
      getDatafileCursor := 'translateDatabase';
      getDatafileNoRows.error := NULL;             -- error not possible
   ELSIF (pdbIdList.count = 1) THEN
      deb(DEB_OPEN, 'translateDatabaseOfPdbId_c');
      OPEN translateDatabaseOfPdbId_c
              (fromSCN, toSCN, pdbIdList.first + CONST2GVAL);
      getDatafileCursor := 'translateDatabaseOfPdbId';
   ELSE
      deb(DEB_OPEN, 'translateDatabaseOfPdbIdL_c');
      OPEN translateDatabaseOfPdbIdL_c(fromSCN, toSCN);
      getDatafileCursor := 'translateDatabaseOfPdbIdL';
   END IF;
 
   IF (untilSCN IS NOT NULL AND pdbIdList.count != 0) THEN
      getDatafileNoRows.error := -20513;
      getDatafileNoRows.msg   :=
         'UNTIL TIME or SCN is before plugggable database CREATION SCN';
   END IF;
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDBTransClause;
   deb(DEB_EXIT);
END translateDatabase;
 
--
 
--
PROCEDURE skipTableSpace(
   tsName  IN varchar2
  ,pdbId   IN number DEFAULT 0)
IS
  tsRec tablespace_t;
BEGIN
   tsRec.name    := tsName;
   tsRec.pdbId   := pdbId;
   skipTablespaceList(skipTablespaceList.count + 1) := tsRec;
END skipTableSpace;
 
--
PROCEDURE translateTablespace(
   ts_name  IN varchar2
  ,pdb_id   IN number DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateTablespace');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateTablespace_c');
   OPEN translateTablespace_c(tsName => ts_name, pdbId => pdb_id);
 
   getDatafileCursor       := 'translateTablespace';
   getDatafileNoRows.error := -20202;
   getDatafileNoRows.msg   := 'Tablespace does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   deb(DEB_EXIT);
END translateTablespace;
 
--
PROCEDURE translateDataFile(
   fname IN varchar2)
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFile_1');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateDatafileName');
   OPEN translateDatafileName(fileName => fname);
 
   IF (untilSCN is NULL and untilTime is NULL) THEN
      getDatafileNoRows.error := -20201;
      getDatafileNoRows.msg   := 'Datafile does not exist';
   ELSE
      getDatafileNoRows.error := -20222;
      getDatafileNoRows.msg   :=
         'Datafile name does not exist or is ambiguous';
   END IF;
 
   getDatafileCursor   := 'translateDatafileName';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   deb(DEB_EXIT);
END translateDatafile;
 
--
PROCEDURE translateDataFile(
   fno IN number)
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFile_2');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateDatafileNumber');
   OPEN translateDatafileNumber(fno => fno);
 
   getDatafileCursor       := 'translateDatafileNumber';
   getDatafileNoRows.error :=  -20201;
   getDatafileNoRows.msg   := 'Datafile does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDfTransClause(fno => fno);
   deb(DEB_EXIT);
END translateDatafile;
 
--
PROCEDURE translateDataFile(
   fno    IN number
  ,ckpscn IN number)
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFile_3');
   validateState(getDatafileCursor);
 
   deb(DEB_OPEN, 'translateDatafileCheckpoint');
   OPEN translateDatafileCheckpoint(fno    => fno,
                                    ckpSCN => ckpscn);
 
   getDatafileCursor       := 'translateDatafileCheckpoint';
   getDatafileNoRows.error :=  -20201;
   getDatafileNoRows.msg   := 'Datafile does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDfTransClause(fno => fno);
   deb(DEB_EXIT);
END translateDatafile;
 
--
PROCEDURE translateAllDatafile
IS
BEGIN
   deb(DEB_ENTER, 'translateAllDataFile');
   validateState(getDatafileCursor);
 
   IF (pdbIdList.count = 0) THEN
      deb(DEB_OPEN, 'translateAllDf_c');
      OPEN translateAllDf_c;
      getDatafileCursor := 'translateAllDf';
   ELSIF (pdbIdList.count = 1) THEN
      deb(DEB_OPEN, 'translateAllDfOfPdbId_c');
      OPEN translateAllDfOfPdbId_c(pdbIdList.first + CONST2GVAL);
      getDatafileCursor := 'translateAllDfOfPdbId';
   ELSE
      deb(DEB_OPEN, 'translateAllDfOfPdbIdL_c');
      OPEN translateAllDfOfPdbIdL_c;
      getDatafileCursor := 'translateAllDfOfPdbIdList';
   END IF;
 
   getDatafileNoRows.error := NULL;             -- error not possible
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
   setDBTransClause;
   deb(DEB_EXIT);
END;
 
--
PROCEDURE translateCorruptList
IS
BEGIN
   validateState(getDatafileCursor);
 
   OPEN translateCorruptList_c;
 
   getDatafileCursor       := 'translateCorruptList';
   getDatafileNoRows.error :=  -20504;
   getDatafileNoRows.msg   := 'Corruption List does not exist';
   getDatafileLast.dfNumber := NULL;            -- no last row yet
   skipTablespaceList.delete;
END translateCorruptList;
 
--
 
--
PROCEDURE getDatafile(
   dfRec     OUT NOCOPY dfRec_t
  ,oldClient IN  boolean DEFAULT FALSE)
IS
   getDatafileRowcount  number;
   local                dfRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFile_1');
<<nextRow>>
   IF (getDatafileCursor = 'translateDatabase') THEN
      FETCH translateDatabase_c
       INTO local;
 
      IF (translateDatabase_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatabase_c%ROWCOUNT;
         CLOSE translateDatabase_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatabaseOfPdbId') THEN
      FETCH translateDatabaseOfPdbId_c
       INTO local;
 
      IF (translateDatabaseOfPdbId_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatabaseOfPdbId_c%ROWCOUNT;
         CLOSE translateDatabaseOfPdbId_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatabaseOfPdbIdL') THEN
      FETCH translateDatabaseOfPdbIdL_c
       INTO local;
 
      IF (translateDatabaseOfPdbIdL_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatabaseOfPdbIdL_c%ROWCOUNT;
         CLOSE translateDatabaseOfPdbIdL_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateAllDf') THEN
      FETCH translateAllDf_c
       INTO local;
 
      IF (translateAllDf_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateAllDf_c%ROWCOUNT;
         CLOSE translateAllDf_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateAllDfOfPdbId') THEN
      FETCH translateAllDfOfPdbId_c
       INTO local;
 
      IF (translateAllDfOfPdbId_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateAllDfOfPdbId_c%ROWCOUNT;
         CLOSE translateAllDfOfPdbId_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateAllDfOfPdbIdList') THEN
      FETCH translateAllDfOfPdbIdL_c
       INTO local;
 
      IF (translateAllDfOfPdbIdL_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateAllDfOfPdbIdL_c%ROWCOUNT;
         CLOSE translateAllDfOfPdbIdL_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateTablespace') THEN
      FETCH translateTablespace_c
       INTO local;
 
      IF (translateTablespace_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateTablespace_c%ROWCOUNT;
         CLOSE translateTablespace_c;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatafileName') THEN
      FETCH translateDatafileName
       INTO local;
 
      IF (translateDatafileName%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatafileName%ROWCOUNT;
         CLOSE translateDatafileName;
      END IF;
 
      IF (oldClient) THEN
--
         IF (translateDatafileName%ISOPEN) THEN
            CLOSE translateDatafileName;
         END IF;
         getDatafileCursor := NULL;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatafileNumber') THEN
      FETCH translateDatafileNumber
       INTO local;
 
      IF (translateDatafileNumber%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatafileNumber%ROWCOUNT;
         CLOSE translateDatafileNumber;
      END IF;
 
      IF (oldClient) THEN
--
         IF (translateDatafileNumber%ISOPEN) THEN
            CLOSE translateDatafileNumber;
         END IF;
         getDatafileCursor := NULL;
      END IF;
   ELSIF (getDatafileCursor = 'translateDatafileCheckpoint') THEN
      FETCH translateDatafileCheckpoint
       INTO local;
 
      IF (translateDatafileCheckpoint%NOTFOUND) THEN
--
         getDatafileRowcount := translateDatafileCheckpoint%ROWCOUNT;
         CLOSE translateDatafileCheckpoint;
      END IF;
 
      IF (oldClient) THEN
--
         IF (translateDatafileCheckpoint%ISOPEN) THEN
            CLOSE translateDatafileCheckpoint;
         END IF;
         getDatafileCursor := NULL;
      END IF;
   ELSIF (getDatafileCursor = 'translateCorruptList') THEN
      FETCH translateCorruptList_c
       INTO local;
 
      IF (translateCorruptList_c%NOTFOUND) THEN
--
         getDatafileRowcount := translateCorruptList_c%ROWCOUNT;
         CLOSE translateCorruptList_c;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (getDatafileRowcount IS NOT NULL) THEN    -- if %NOTFOUND
      getDatafileCursor := NULL;                -- we closed it above
      IF (getDatafileRowcount = 0 AND
          getDatafileNoRows.error IS NOT NULL) THEN
--
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getDatafileNoRows.error,
                                 getDatafileNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
 
   IF (skipTablespace(local.tsName, local.pdbId)) THEN
      GOTO nextRow;
   END IF;
 
--
   IF (getDatafileLast.dfNumber = local.dfNumber) THEN
      IF (getDatafileLast.pluginSCN != 0) THEN
         IF (getDatafileLast.pluginSCN = local.pluginSCN) THEN
            deb(DEB_PRINT, 'not returning' || local.fileName);
            GOTO nextRow;
         END IF;
      ELSIF (getDatafileLast.dfCreationSCN = local.dfCreationSCN) THEN
         deb(DEB_PRINT, 'not returning' || local.fileName);
         GOTO nextRow;
      END IF;
   END IF;
 
--
--
--
   IF (local.pdbName IS NULL) THEN
      local.pdbName := translatePdb2Name(local.pdbId);
   END IF;
 
   getDatafileLast := local;
 
   setDfTransClause(fno => local.dfNumber);
 
   dfRec := local;                              -- set OUT mode arg
   deb(DEB_EXIT);
END getDatafile;
 
--
--
--
 
--
PROCEDURE translateOnlineLogs(srls IN number DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateOnlineLogs');
   IF (translateOnlineLogs_c%ISOPEN) THEN
      validateState('translateOnlineLogs_c');                -- raise the error
   END IF;
 
   deb(DEB_OPEN, 'translateOnlineLogs_c, srls='||srls);
   OPEN translateOnlineLogs_c(srls);
   deb(DEB_EXIT);
 
END translateOnlineLogs;
 
--
PROCEDURE getOnlineLog(
   fname        OUT varchar2
  ,thread#      OUT number
  ,group#       OUT number)
IS
BEGIN
   deb(DEB_ENTER, 'getOnlineLog');
   FETCH translateOnlineLogs_c
    INTO thread#, group#, fname;
   IF (translateOnlineLogs_c%NOTFOUND) THEN
      CLOSE translateOnlineLogs_c;
      deb(DEB_EXIT, 'with NULL (no archivelog found)'||fname);
      fname := NULL;                            -- indicate end-of-fetch
      RETURN;
   END IF;
   deb(DEB_EXIT, 'with archivelog:'||fname);
END getOnlineLog;
 
 
--
--
--
 
--
PROCEDURE getArchivedLog(
   alRec       OUT NOCOPY alRec_t,
   closeCursor IN  boolean DEFAULT FALSE)
IS
   getArchivedLogRowcount       number;
   local                        alRec_t;
BEGIN
   deb(DEB_ENTER, 'getArchivedLog');
 
<<nextRow>>
 
   IF (getArchivedLogCursor = 'translateArcLogKey') THEN
      FETCH translateArcLogKey
       INTO local;
      IF (translateArcLogKey%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogKey%ROWCOUNT;
         CLOSE translateArcLogKey;
      END IF;
      IF (closeCursor AND translateArcLogKey%ISOPEN) THEN
         CLOSE translateArcLogKey;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogName') THEN
      FETCH translateArcLogName
       INTO local;
      IF (translateArcLogName%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogName%ROWCOUNT;
         CLOSE translateArcLogName;
      END IF;
      IF (closeCursor AND translateArcLogName%ISOPEN) THEN
         CLOSE translateArcLogName;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange') THEN
      FETCH translateArcLogSeqRange
       INTO local;
      IF (translateArcLogSeqRange%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSeqRange%ROWCOUNT;
         CLOSE translateArcLogSeqRange;
      END IF;
      IF (closeCursor AND translateArcLogSeqRange%ISOPEN) THEN
         CLOSE translateArcLogSeqRange;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSeqRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange2') THEN
      FETCH translateArcLogSeqRange2
       INTO local;
      IF (translateArcLogSeqRange2%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSeqRange2%ROWCOUNT;
         CLOSE translateArcLogSeqRange2;
      END IF;
      IF (closeCursor AND translateArcLogSeqRange2%ISOPEN) THEN
         CLOSE translateArcLogSeqRange2;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange') THEN
      FETCH translateArcLogTimeRange
       INTO local;
      IF (translateArcLogTimeRange%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogTimeRange%ROWCOUNT;
         CLOSE translateArcLogTimeRange;
      END IF;
      IF (closeCursor AND translateArcLogTimeRange%ISOPEN) THEN
         CLOSE translateArcLogTimeRange;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogTimeRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange2') THEN
      FETCH translateArcLogTimeRange2
       INTO local;
      IF (translateArcLogTimeRange2%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogTimeRange2%ROWCOUNT;
         CLOSE translateArcLogTimeRange2;
      END IF;
      IF (closeCursor AND translateArcLogTimeRange2%ISOPEN) THEN
         CLOSE translateArcLogTimeRange2;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange') THEN
      FETCH translateArcLogSCNRange
       INTO local;
      IF (translateArcLogSCNRange%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSCNRange%ROWCOUNT;
         CLOSE translateArcLogSCNRange;
      END IF;
      IF (closeCursor AND translateArcLogSCNRange%ISOPEN) THEN
         CLOSE translateArcLogSCNRange;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSCNRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange2') THEN
      FETCH translateArcLogSCNRange2
       INTO local;
      IF (translateArcLogSCNRange2%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogSCNRange2%ROWCOUNT;
         CLOSE translateArcLogSCNRange2;
      END IF;
      IF (closeCursor AND translateArcLogSCNRange2%ISOPEN) THEN
         CLOSE translateArcLogSCNRange2;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateArcLogPattern') THEN
      FETCH translateArcLogPattern
       INTO local;
      IF (translateArcLogPattern%NOTFOUND) THEN
         getArchivedLogRowcount := translateArcLogPattern%ROWCOUNT;
         CLOSE translateArcLogPattern;
      END IF;
      IF (closeCursor AND translateArcLogPattern%ISOPEN) THEN
         CLOSE translateArcLogPattern;
      END IF;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogPattern') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor) THEN
      getArchivedLogCursor := NULL;
   END IF;
 
   IF (getArchivedLogRowcount IS NOT NULL) THEN
      getArchivedLogCursor := NULL;             -- we closed it above
      getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
      getArchivedLogOnlyrdf := 0;               -- clear for next time
      currInc := -1;
      deb(DEB_PRINT, 'getArchivedLogDoingRecovery cleared');
--
--
      IF ((getArchivedLogRowcount = 0 OR
           getArchivedLogLast.thread is NULL) AND
          getArchivedLogNoRows.error IS NOT NULL) THEN
--
         getArchivedLogLast   := NULL;          -- clear for next time
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getArchivedLogNoRows.error,
                                 getArchivedLogNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         getArchivedLogLast   := NULL;          -- clear for next time
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
 
   deb(DEB_PRINT, 'getArchivedLog - resetscn='||local.rlgSCN||
                  ' thread='||local.thread||
                  ' seq='||local.sequence||
                  ' lowscn='||local.lowSCN||
                  ' nextscn='||local.nextSCN||
                  ' terminal='||local.terminal||
                  ' site_key_order_col='||local.site_key_order_col||
                  ' isrdf='||local.isrdf||
                  ' stamp='||local.stamp);
 
--
   IF (getArchivedLogDoingRecovery = TRUE#) THEN
--
     IF (getArchivedLogLast.rlgSCN = local.rlgSCN AND
         getArchivedLogLast.rlgTime = local.rlgTime AND currInc <> -1) THEN
       deb(DEB_PRINT,
               'getArchivedLog - currInc =' || currInc);
--
       IF (currInc > 0 AND
           local.lowSCN >= inc_list(currInc-1).resetlogs_change#-1) THEN
           deb(DEB_PRINT,
               'getArchivedLog - Skip log - belongs to orphan branch');
           GOTO nextRow;
       END IF;
     ELSE
--
       currInc := -1;
       FOR inc_idx in 0..max_inc_idx-1 LOOP
 
--
--
         IF tc_fromSCN > inc_list(inc_idx).resetlogs_change# AND
            local.rlgSCN < inc_list(inc_idx).resetlogs_change#  THEN
            deb(DEB_PRINT,
                'getArchivedLog -Skip log precedes recovery SCN - '||inc_idx);
            EXIT;
         END IF;
 
--
--
--
--
         IF (local.rlgSCN = inc_list(inc_idx).resetlogs_change# AND
             local.rlgTime = inc_list(inc_idx).resetlogs_time) THEN
 
--
--
            IF inc_idx > 0 THEN
              IF local.lowSCN < inc_list(inc_idx-1).resetlogs_change# - 1 THEN
                  currInc := inc_idx;
                  deb(DEB_PRINT, 'getArchivedLog - currInc2 set to '||currInc);
               END IF;
            ELSE
               currInc := inc_idx;
               deb(DEB_PRINT, 'getArchivedLog - currIn3 set to '||currInc);
            END IF;
            EXIT;
         END IF;
       END LOOP;
       IF (currInc = -1) THEN
         deb(DEB_PRINT,'getArchivedLog - Skip log - not required by recovery');
         GOTO nextRow;
       END IF;
     END IF;
   END IF;
 
--
   IF (local.thread   = getArchivedLogLast.thread AND
       local.sequence = getArchivedLogLast.sequence AND
       local.terminal = getArchivedLogLast.terminal AND
       local.lowSCN   = getArchivedLogLast.lowSCN AND
       local.rlgSCN   = getArchivedLogLast.rlgSCN AND
       local.rlgTime  = getArchivedLogLast.rlgTime) THEN
     local.duplicate := TRUE#;
   END IF;
 
   IF (getArchivedLogDuplicates = FALSE# AND    -- if don't want duplicates
       local.duplicate = TRUE#) THEN
      deb(DEB_PRINT, 'getArchivedLog - dont want duplicates');
      GOTO nextRow;
   END IF;
 
--
--
--
--
--
--
--
--
--
--
--
   IF (getArchivedLogOnlyrdf = 1 AND
       local.duplicate = FALSE# AND
       local.isrdf = 'NO') THEN
      deb(DEB_PRINT, 'getArchiveLog - dont want non-recovery area log ');
      GOTO nextRow;
   END IF;
 
--
--
--
   IF IsDuplicateAlName(local.duplicate, local.filename) THEN
     GOTO nextRow;
   END IF;
 
--
--
   IF (local.thread   = getArchivedLogLast.thread AND
       local.sequence = getArchivedLogLast.sequence AND
       local.lowSCN   = getArchivedLogLast.lowSCN AND
       local.rlgSCN   = getArchivedLogLast.rlgSCN AND
       local.rlgTime  = getArchivedLogLast.rlgTime AND
       getArchivedLogLast.terminal = 'YES' AND
       local.terminal = 'NO') THEN
     deb(DEB_PRINT, 'getArchivedLog - Skip log - not an EOR log');
     GOTO nextRow;
   END IF;
--
 
--
   IF (getArchivedLogDoingRecovery = TRUE#) THEN
     IF (local.thread = getArchivedLogLast.thread AND
         local.lowSCN <> getArchivedLogLast.lowSCN AND
         local.sequence = getArchivedLogLast.sequence) THEN
        deb(DEB_PRINT, 'getArchivedLog - Skip log - filter bad sequence log');
        GOTO nextRow;
     END IF;
   END IF;
 
--
--
   IF (local.stamp <= 0) THEN
      local.stamp := NULL;
   END IF;
 
   IF getArchivedLogCursor IS NULL THEN
      getArchivedLogLast := NULL;               -- clear for next time
      getArchivedLogDoingRecovery := FALSE#;    -- clear for next time
      getArchivedLogOnlyrdf := 0;
      currInc := -1;
      deb(DEB_PRINT, 'getArchivedLogDoingRecovery cleared');
      deb(DEB_PRINT, 'getArchivedLogLast := NULL');
   ELSE
      getArchivedLogLast := local;
      deb(DEB_PRINT,'getArchivedLogLast('||getArchivedLogCursor||') := local');
      deb(DEB_PRINT, 'getArchivedLogLast := local');
   END IF;
   alRec := local;                              -- set OUT mode arg
   deb(DEB_EXIT);
END getArchivedLog;
 
--
PROCEDURE translateArchivedLogKey(
   alKey        IN number
  ,needstby     IN number DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogKey');
   validateState(getArchivedLogCursor);
 
   deb(DEB_OPEN, 'translateArcLogKey');
   OPEN translateArcLogKey(alKey => alKey);
 
   getArchivedLogCursor       := 'translateArcLogKey';
   getArchivedLogDuplicates   := NULL;
   getArchivedLogNoRows.error := -20240;
   getArchivedLogNoRows.msg   := 'Archived log does not exist';
   deb(DEB_EXIT);
END translateArchivedLogKey;
 
--
PROCEDURE translateArchivedLogKey(
   al_key       IN  number
  ,available    IN  number DEFAULT 1     -- ignored (for compatability)
  ,unavailable  IN  number DEFAULT 1     -- ignored (for compatability)
  ,deleted      IN  number DEFAULT 1     -- ignored (for compatability)
  ,online       IN  number DEFAULT 1     -- ignored (for compatability)
  ,recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,fname        OUT varchar2
  ,needstby     IN number DEFAULT NULL)
IS
   alRec        alRec_t;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogKey816');
   translateArchivedLogKey(alKey => al_key, needstby => needstby);
 
   getArchivedLog(alRec       => alRec,
                  closeCursor => TRUE);
 
   recid        := alRec.recid;
   stamp        := alRec.stamp;
   thread#      := alRec.thread;
   sequence#    := alRec.sequence;
   low_scn      := alRec.lowSCN;
   reset_scn    := alRec.rlgSCN;
   block_size   := alRec.blockSize;
   fname        := alRec.fileName;
   deb(DEB_EXIT);
END translateArchivedLogKey;
 
--
--
--
--
 
--
PROCEDURE translateArchivedLogName(
   fname        IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,deleted      IN number         DEFAULT NULL   -- for compatability
  ,online       IN number                        -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,needstby     IN number         DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogName');
   validateState(getArchivedLogCursor);
 
   deb(DEB_OPEN, 'translateArcLogName');
   OPEN translateArcLogName(fname       => fname,
                            online      => online,
                            statusMask  => NVL(statusMask,
                                   computeAvailableMask(available, unavailable,
                                                        deleted, 0)),
                            needstby    => needstby);
 
   getARchivedLogCursor       := 'translateArcLogName';
   getArchivedLogDuplicates   := duplicates;
   getArchivedLogNoRows.error := -20240;
   getArchivedLogNoRows.msg   := 'Archived log does not exist';
   deb(DEB_EXIT);
END translateArchivedLogName;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
 
--
PROCEDURE translateArchivedLogSeqRange(
   thread#      IN number
  ,fromseq#     IN number
  ,toseq#       IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,deleted      IN number         DEFAULT NULL   -- for compatability
  ,online       IN number                        -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL   -- for compatability
  ,needstby     IN number         DEFAULT NULL   -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0      -- for compatability
  ,incarn       IN number         DEFAULT NULL)  -- for compatibility
IS
   mask    number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
   lincarn number := incarn;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogSeqRange');
   validateState(getArchivedLogCursor);
 
   IF (thread# is NULL) THEN
      deb(DEB_EXIT, 'with error 20210');
      raise_application_error(-20210, 'Thread# is missing');
   END IF;
 
   setAlTransClause(thread     => thread#,
                    fromSeq    => fromseq#,
                    toSeq      => toseq#,
                    pattern    => pattern);
 
--
--
--
--
 
   IF (foreignal != 0) THEN
      IF (tc_dbid.count = 0) THEN
         tc_anydbid := TRUE#;
      END IF;
      deb(DEB_OPEN, 'translateFrgnArcLogSeqRange');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
         deb(DEB_OPEN, 'translateArcLogSeqRange2');
         OPEN translateArcLogSeqRange2(thread#     => thread#,
                                       incarn      => NVL(lincarn,-1),
                                       fromseq#    => fromseq#,
                                       toseq#      => toseq#,
                                       statusMask  => mask,
                                       online      => online,
                                       needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogSeqRange2';
      ELSE
         deb(DEB_OPEN, 'translateArcLogSeqRange');
         OPEN translateArcLogSeqRange(thread#     => thread#,
                                      incarn      => NVL(lincarn,-1),
                                      fromseq#    => fromseq#,
                                      toseq#      => toseq#,
                                      pattern     => pattern,
                                      statusMask  => mask,
                                      online      => online,
                                      needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogSeqRange';
      END IF;
      getArchivedLogNoRows.error := -20242;
      getArchivedLogNoRows.msg   := 'No archived logs in the range specified';
   END IF;
   getArchivedLogDuplicates   := duplicates;
   deb(DEB_EXIT);
END translateArchivedLogSeqRange;
 
--
--
--
--
--
--
--
--
PROCEDURE translateArchivedLogTimeRange(
   thread#      IN number
  ,fromTime     IN date
  ,toTime       IN date
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,deleted      IN number         DEFAULT NULL    -- for compatability
  ,online       IN number                         -- ignored
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatability
  ,needstby     IN number         DEFAULT NULL    -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0       -- for compatability
  ,incarn       IN number         DEFAULT NULL)   -- for compatibility
IS
   mask    number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
   lincarn number := incarn;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogTimeRange');
   validateState(getArchivedLogCursor);
 
   setAlTransClause(thread   => thread#,
                    fromTime => fromTime,
                    toTime   => toTime,
                    pattern  => pattern);
 
--
--
--
--
 
   IF (foreignal != 0) THEN
      IF (tc_dbid.count = 0) THEN
         tc_anydbid := TRUE#;
      END IF;
      deb(DEB_OPEN, 'translateFrgnArcLogTimeRange');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
         deb(DEB_OPEN, 'translateArcLogTimeRange2');
         OPEN translateArcLogTimeRange2(thread#     => thread#,
                                        incarn      => NVL(lincarn,0),
                                        fromTime    => fromTime,
                                        toTime      => toTime,
                                        statusMask  => mask,
                                        online      => online,
                                        needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogTimeRange2';
      ELSE
         deb(DEB_OPEN, 'translateArcLogTimeRange');
         OPEN translateArcLogTimeRange(thread#     => thread#,
                                       incarn      => NVL(lincarn,0),
                                       fromTime    => fromTime,
                                       toTime      => toTime,
                                       pattern     => pattern,
                                       statusMask  => mask,
                                       online      => online,
                                       needstby    => needstby);
         getArchivedLogCursor       := 'translateArcLogTimeRange';
      END IF;
      getArchivedLogNoRows.error := -20242;
      getArchivedLogNoRows.msg   := 'No archived logs in the range specified';
   END IF;
   getArchivedLogDuplicates   := duplicates;
   deb(DEB_EXIT);
END translateArchivedLogTimeRange;
 
--
--
--
--
--
--
--
 
--
PROCEDURE translateArchivedLogSCNRange(
   thread#      IN number
  ,fromSCN      IN number
  ,toSCN        IN number
  ,pattern      IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,deleted      IN number         DEFAULT NULL    -- for compatability
  ,online       IN number
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatability
  ,needstby     IN number         DEFAULT NULL
  ,doingRecovery IN  number DEFAULT FALSE#
  ,onlyrdf      IN binary_integer DEFAULT 0
  ,reset_scn    IN number         DEFAULT NULL    -- for compatibility
  ,reset_time   IN date           DEFAULT NULL    -- for compatibility
  ,sequence#    IN number         DEFAULT NULL    -- for compatibility
  ,foreignal    IN binary_integer DEFAULT 0       -- for compatability
  ,incarn       IN number         DEFAULT NULL)   -- for compatibility
IS
   adjusted_toSCN number;
   mask           number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
   lincarn        number := incarn;
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogSCNRange');
   validateState(getArchivedLogCursor);
 
   IF (untilTime IS NULL) THEN
--
--
--
--
      adjusted_toSCN := least(nvl(toSCN, untilSCN), nvl(untilSCN, toSCN));
   ELSE
--
--
--
--
--
--
      adjusted_toSCN := toSCN;
   END IF;
 
--
--
--
--
--
   IF (adjusted_toSCN <= fromSCN) THEN
      adjusted_toSCN := fromSCN+1;
   END IF;
 
   setAlTransClause(thread  => thread#,
                    fromSCN => fromSCN,
                    toSCN   => adjusted_toSCN,
                    pattern => pattern);
 
--
--
--
--
 
  IF (foreignal != 0) THEN
      IF (tc_dbid.count = 0) THEN
         tc_anydbid := TRUE#;
      END IF;
      deb(DEB_OPEN, 'translateFrgnArcLogSCNRange');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSE
      IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
         deb(DEB_OPEN, 'translateArcLogSCNRange2');
         OPEN translateArcLogSCNRange2(thread#     => thread#,
                                       incarn      => NVL(lincarn,0),
                                       sequence#   => sequence#,
                                       fromSCN     => fromSCN,
                                       toSCN       => adjusted_toSCN,
                                       toTime      => untilTime,
                                       statusMask  => mask,
                                       online      => online,
                                       needstby    => needstby,
                                       reset_scn   => reset_scn,
                                       reset_time  => reset_time);
         getArchivedLogCursor       := 'translateArcLogSCNRange2';
         deb(DEB_IN, ' using cursor 2 fromSCN=' ||
             to_char(fromSCN) || ' toSCN=' || to_char(adjusted_toSCN));
      ELSE
         deb(DEB_OPEN, 'translateArcLogSCNRange');
         OPEN translateArcLogSCNRange(thread#     => thread#,
                                      incarn      => NVL(lincarn,0),
                                      sequence#   => sequence#,
                                      fromSCN     => fromSCN,
                                      toSCN       => adjusted_toSCN,
                                      pattern     => pattern,
                                      statusMask  => mask,
                                      online      => online,
                                      needstby    => needstby,
                                      reset_scn   => reset_scn,
                                      reset_time  => reset_time);
         getArchivedLogCursor       := 'translateArcLogSCNRange';
      END IF;
      getArchivedLogNoRows.error := -20242;
      getArchivedLogNoRows.msg   := 'No archived logs in the range specified';
   END IF;
   getArchivedLogDuplicates   := duplicates;
   getArchivedLogDoingRecovery := DoingRecovery;
   IF (DoingRecovery = TRUE#) THEN
     deb(DEB_PRINT, 'getArchivedLogDoingRecovery set to TRUE');
   END IF;
   getArchivedLogOnlyrdf := onlyrdf;
   deb(DEB_EXIT);
END translateArchivedLogSCNRange;
 
--
--
 
--
PROCEDURE translateArchivedLogPattern(
   pattern      IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,deleted      IN number         DEFAULT NULL    -- for compatability
  ,online       IN number
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatability
  ,needstby     IN number         DEFAULT NULL    -- for compatability
  ,foreignal    IN binary_integer DEFAULT 0)      -- for compatability
IS
   mask           number := NVL(statusMask,
                     computeAvailableMask(available, unavailable, deleted, 0));
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogPattern');
   IF (bitand(mask,BSdeleted) != 0 AND pattern IS NULL) THEN
--
--
--
--
--
     translateArchivedLogSCNRange(
        thread#     => NULL,
        fromscn     => 0,
        toscn       => highscnval+1,
        pattern     => NULL,
        statusMask  => mask,
        online      => online,
        duplicates  => duplicates,
        foreignal   => foreignal);
   ELSE
     validateState(getArchivedLogCursor);
     setAlTransClause(pattern => pattern);
     IF (foreignal != 0) THEN
        IF (tc_dbid.count = 0) THEN
           tc_anydbid := TRUE#;
        END IF;
        deb(DEB_OPEN, 'translateFrgnArcLogPattern');
--
        raise_application_error(-20999, 'Not supported in recovery catalog');
--
     ELSE
        deb(DEB_OPEN, 'translateArcLogPattern');
        OPEN translateArcLogPattern(pattern     => pattern,
                                    statusMask  => mask,
                                    online      => online);
        getArchivedLogCursor       := 'translateArcLogPattern';
        getArchivedLogNoRows.error := -20242;
        getArchivedLogNoRows.msg   :=
           'No archived logs in the range specified';
     END IF;
     getArchivedLogDuplicates   := duplicates;
   END IF;
   deb(DEB_EXIT);
END translateArchivedLogPattern;
 
--
PROCEDURE translateArchivedLogCancel
IS
BEGIN
   deb(DEB_ENTER, 'translateArchivedLogCancel');
   IF (getArchivedLogCursor = 'translateArcLogKey') THEN
      CLOSE translateArcLogKey;
   ELSIF (getArchivedLogCursor = 'translateArcLogName') THEN
      CLOSE translateArcLogName;
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange') THEN
      CLOSE translateArcLogSeqRange;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSeqRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSeqRange2') THEN
      CLOSE translateArcLogSeqRange2;
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange') THEN
      CLOSE translateArcLogTimeRange;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogTimeRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogTimeRange2') THEN
      CLOSE translateArcLogTimeRange2;
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange') THEN
      CLOSE translateArcLogSCNRange;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogSCNRange') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   ELSIF (getArchivedLogCursor = 'translateArcLogSCNRange2') THEN
      CLOSE translateArcLogSCNRange2;
   ELSIF (getArchivedLogCursor = 'translateArcLogPattern') THEN
      CLOSE translateArcLogPattern;
   ELSIF (getArchivedLogCursor = 'translateFrgnArcLogPattern') THEN
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   END IF;
   getArchivedLogCursor := NULL;                -- we closed it above
   getArchivedLogLast   := NULL;                -- clear for next time
   getArchivedLogDoingRecovery := FALSE#;       -- clear for next time
   resetAlTransClause;
   deb(DEB_EXIT);
END translateArchivedLogCancel;
 
--
--
--
 
--
PROCEDURE getArchivedLog(
   recid        OUT number
  ,stamp        OUT number
  ,thread#      OUT number
  ,sequence#    OUT number
  ,low_scn      OUT number
  ,nxt_scn      OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,block_size   OUT number
  ,blocks       OUT number)
IS
   alRec alRec_t;
BEGIN
   deb(DEB_ENTER, 'getArchivedLog');
<<retry>>
   getArchivedLog(alRec);
 
--
--
--
 
--
   recid      := nvl(alRec.recid,0);    -- no null indicator before 8.1.6
   stamp      := nvl(alRec.stamp, 0);   -- no null indicator before 8.1.6
   thread#    := alRec.thread;
   sequence#  := alRec.sequence;
   low_scn    := alRec.lowSCN;
   nxt_scn    := alRec.nextSCN;
   fname      := nvl(alRec.fileName, 'null');   -- no null indicator
   reset_scn  := alRec.rlgSCN;
   block_size := alRec.blockSize;
   blocks     := alRec.blocks;
   deb(DEB_EXIT);
 
EXCEPTION
   WHEN no_data_found THEN
      recid := NULL;                    -- indicate end-of-fetch
      stamp := NULL;
      deb(DEB_EXIT, 'with no more records');
END getArchivedLog;
 
--
--
--
 
--
 
--
PROCEDURE translateControlFileCopyName(
   fname        IN varchar2
  ,available    IN number           DEFAULT NULL  -- for compatability
  ,unavailable  IN number           DEFAULT NULL  -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer   DEFAULT NULL  -- for compatability
  ,onlyone      IN number           DEFAULT 1) IS
BEGIN
   deb(DEB_ENTER, 'translateControlFileCopyName');
--
   getControlFileCopyCursor := 'findControlfileBackup_c';
   deb(DEB_OPEN, 'findControlfileBackup_c');
   OPEN findControlfileBackup_c(sourcemask         => imageCopy_con_t,
                                pattern            => fname,
                                currentIncarnation => FALSE#,
                                statusMask         => NVL(statusMask,
                                computeAvailableMask(available,unavailable,0,0)));
 
--
   IF (duplicates = FALSE# and onlyone is NOT NULL) THEN
      getControlFileCopySingleRow := TRUE;
   ELSE
      getControlFileCopySingleRow := FALSE;
   END IF;
   deb(DEB_EXIT);
END translateControlFileCopyName;
 
 
--
 
--
PROCEDURE translateControlFileCopyTag(
   cftag        IN varchar2
  ,available    IN number           DEFAULT NULL -- for compatability
  ,unavailable  IN number           DEFAULT NULL -- for compatability
  ,duplicates   IN number
  ,statusMask   IN binary_integer   DEFAULT NULL
  ,onlyone      IN number           DEFAULT 1) IS
BEGIN
   deb(DEB_ENTER, 'translateControlFileCopyTag');
--
   deb(DEB_OPEN, 'findControlfileBackup_c');
   getControlFileCopyCursor := 'findControlfileBackup_c';
   OPEN findControlfileBackup_c(
                            sourcemask         => imageCopy_con_t,
                            tag                => cftag,
                            currentIncarnation => FALSE#,
                            statusMask         => NVL(statusMask,
                            computeAvailableMask(available,unavailable,0,0)));
 
--
   IF (duplicates = FALSE# and onlyone is NOT NULL) THEN
      getControlFileCopySingleRow := TRUE;
   ELSE
      getControlFileCopySingleRow := FALSE;
   END IF;
   deb(DEB_EXIT);
END translateControlFileCopyTag;
 
 
--
 
--
PROCEDURE translateControlFileCopyKey(
   key          IN number
  ,available    IN number         DEFAULT NULL    -- for compatability
  ,unavailable  IN number         DEFAULT NULL    -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL) IS -- for compatability
BEGIN
   deb(DEB_ENTER, 'translateControlFileCopyKey');
 
--
   deb(DEB_OPEN, 'findControlFileCopyKey');
 
--
--
   getControlFileCopyCursor := 'findControlFileCopyKey';
   OPEN findControlFileCopyKey(
                            copyKey            => key,
                            statusMask         => NVL(statusMask,
                            computeAvailableMask(available,unavailable,0,0)));
 
   deb(DEB_EXIT);
 
END translateControlFileCopyKey;
 
 
--
PROCEDURE getControlFileCopy(
   rcvRec       IN OUT NOCOPY rcvRec_t)
IS
   getControlFileCopyRowcount   number;
BEGIN
   deb(DEB_ENTER, 'getControlFileCopy');
   IF (getControlFileCopyCursor = 'findControlFileCopyKey'
       AND findControlFileCopyKey%ISOPEN) THEN
      FETCH findControlFileCopyKey
       INTO rcvRec;
 
<<NextRow>>
      IF (findControlFileCopyKey%NOTFOUND) THEN
 
--
         getControlFileCopyRowcount := findControlFileCopyKey%ROWCOUNT;
         CLOSE findControlFileCopyKey;
 
         IF (getControlFileCopyRowcount = 0) THEN
            deb(DEB_EXIT, 'with error 20220');
            raise_application_error(-20220, 'Controlfile copy does not exist');
         ELSE
            deb(DEB_EXIT, 'with no more records');
            RAISE no_data_found;                   -- signal end-of-fetch
         END IF;
      END IF;
      IF (getControlFileCopySingleRow = TRUE AND
          findControlFileCopyKey%ROWCOUNT > 1) THEN
--
--
         CLOSE findControlFileCopyKey;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSIF (getControlFileCopyCursor = 'findControlfileBackup_c'
          AND findControlfileBackup_c%ISOPEN) THEN
      FETCH findControlfileBackup_c
       INTO rcvRec;
 
      IF (findControlfileBackup_c%NOTFOUND) THEN
 
--
         getControlFileCopyRowcount := findControlfileBackup_c%ROWCOUNT;
         CLOSE findControlfileBackup_c;
 
         IF (getControlFileCopyRowcount = 0) THEN
            deb(DEB_EXIT, 'with error 20220');
            raise_application_error(-20220, 'Controlfile copy does not exist');
         ELSE
            deb(DEB_EXIT, 'with no more records');
            RAISE no_data_found;                   -- signal end-of-fetch
         END IF;
      END IF;
      IF (getControlFileCopySingleRow = TRUE AND
          findControlfileBackup_c%ROWCOUNT > 1) THEN
--
--
         CLOSE findControlfileBackup_c;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started (' ||
                                       getControlFileCopyCursor || ')');
   END IF;
   deb(DEB_EXIT);
END getControlFileCopy;
 
--
 
--
PROCEDURE getControlFileCopy(
   recid        OUT number
  ,stamp        OUT number
  ,reset_scn    OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getControlFileCopy');
   getControlFileCopy(rcvRec);
 
   recid      := rcvRec.recid_con;
   stamp      := rcvRec.stamp_con;
   reset_scn  := rcvRec.rlgSCN_act;
   ckp_scn    := rcvRec.toSCN_act;
   block_size := rcvRec.blockSize_con;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with no more records');
--
      recid := NULL;                    -- signal end-of-fetch to caller
END getControlFileCopy;
 
--
--
--
 
--
PROCEDURE getDataFileCopy(
   rcvRec      OUT NOCOPY rcvRec_t
  ,closeCursor IN  boolean DEFAULT FALSE)
IS
   getDataFileCopyRowcount      number;
   local                        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFileCopy');
 
<<nextRow>>
   IF (getDatafileCopyCursor = 'findDatafileCopyKey') THEN
      FETCH findDatafileCopyKey
       INTO local;
 
      IF (findDatafileCopyKey%NOTFOUND) THEN
         getDataFileCopyRowcount := findDatafileCopyKey%ROWCOUNT;
         CLOSE findDatafileCopyKey;
      END IF;
 
      IF (closeCursor AND findDatafileCopyKey%ISOPEN) THEN
         CLOSE findDatafileCopyKey;
      END IF;
   ELSIF (getDatafileCopyCursor = 'findDatafileBackup_c') THEN
      IF (getDataFileCopySingleRow = TRUE AND
          findDatafileBackup_c%ROWCOUNT > 1) THEN
--
--
         CLOSE findDatafileBackup_c;
         getDatafileCopyCursor := NULL;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
 
      FETCH findDatafileBackup_c
       INTO local;
 
      IF (findDatafileBackup_c%NOTFOUND) THEN
         getDataFileCopyRowcount := findDatafileBackup_c%ROWCOUNT;
         CLOSE findDatafileBackup_c;
      END IF;
 
      IF (closeCursor AND findDatafileBackup_c%ISOPEN) THEN
         CLOSE findDatafileBackup_c;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor) THEN
      getDatafileCopyCursor := NULL;
   END IF;
 
   IF (getDataFileCopyRowcount IS NOT NULL) THEN
      getDatafileCopyCursor := NULL;
      IF (getDataFileCopyRowcount = 0 AND
          getDatafileCopyNoRows.error IS NOT NULL) THEN
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getDatafileCopyNoRows.error,
                                 getDatafileCopyNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
 
   IF (getDataFileCopyLatestOnly = TRUE AND
       getDataFileCopyLast.dfNumber_obj = local.dfNumber_obj) THEN
      GOTO nextRow;
   END IF;
 
   getDataFileCopyLast := local;                -- save for duplicate filtering
   rcvRec := local;                             -- set OUT mode arg
   setDfTransClause(fno => local.dfNumber_obj);
   deb(DEB_EXIT);
END getDataFileCopy;
 
--
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number         DEFAULT NULL   -- for compatability
  ,unavailable  IN number         DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFileCopyKey');
   validateState(getDatafileCopyCursor);
 
--
   deb(DEB_OPEN, 'findDataFileCopyKey');
   OPEN findDataFileCopyKey(copyKey            => cdf_key,
                            statusMask         => NVL(statusMask,
                               computeAvailableMask(available, unavailable,
                                                    0, 0)));
 
   getDatafileCopyCursor       := 'findDatafileCopyKey';
   getDataFileCopyNoRows.error := -20230;
   getDataFileCopyNoRows.msg   := 'Datafile copy does not exist';
   getDataFileCopyDuplicates   := NULL;
   getDataFileCopySingleRow    := NULL;
   deb(DEB_EXIT);
END translateDatafileCopyKey;
 
--
--
PROCEDURE translateDataFileCopyKey(
   cdf_key      IN number
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,file#        OUT number
  ,fname        OUT varchar2
  ,reset_scn    OUT number
  ,create_scn   OUT number
  ,ckp_scn      OUT number
  ,block_size   OUT number
  ,blocks       OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'translateDataFileCopyKey815');
   translateDataFileCopyKey(cdf_key     => cdf_key,
                            available   => available,
                            unavailable => unavailable);
 
   getDataFileCopy(rcvRec      => rcvRec,
                   closeCursor => TRUE);
 
   recid        := rcvRec.recid_con;
   stamp        := rcvRec.stamp_con;
   file#        := rcvRec.dfNumber_obj;
   fname        := rcvRec.fileName_con;
   reset_scn    := rcvRec.rlgSCN_act;
   create_scn   := rcvRec.dfCreationSCN_obj;
   ckp_scn      := rcvRec.toSCN_act;
   block_size   := rcvRec.blockSize_con;
   blocks       := rcvRec.blocks_con;
   deb(DEB_EXIT);
END translateDataFileCopyKey;
 
--
--
--
--
 
--
PROCEDURE translateDatafileCopyName(
   fname       IN varchar2
  ,available   IN number         DEFAULT NULL   -- for compatability
  ,unavailable IN number         DEFAULT NULL   -- for compatability
  ,duplicates  IN number
  ,statusMask  IN binary_integer DEFAULT NULL   -- for compatability
  ,onlyone     IN number         DEFAULT 1
  ,pluginSCN   IN number         DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateDatafileCopyName');
   validateState(getDatafileCopyCursor);
 
--
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(
                        sourcemask   => imageCopy_con_t,
                        pattern      => fname,
                        statusMask   => nvl(statusMask,
                                            computeAvailableMask(available,
                                                                 unavailable,
                                                                 0, 0)),
                        duplicates   => duplicates,
                        pluginSCN    => pluginSCN
                        );
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDatafileCopyNoRows.error      := -20230;
   getDatafileCopyNoRows.msg        := 'Datafile copy does not exist';
   getDatafileCopyDuplicates        := duplicates;
   getDatafileCopyLast.dfNumber_obj := NULL;
   getDatafileCopyLatestOnly        := FALSE;
   IF (duplicates = FALSE# and onlyone is NOT NULL) THEN
      getDatafileCopySingleRow := TRUE;
   ELSE
      getDatafileCopySingleRow := FALSE;
   END IF;
   deb(DEB_EXIT);
END translateDatafileCopyName;
 
--
--
--
--
--
--
--
--
 
--
PROCEDURE translateDataFileCopyTag(
   tag          IN varchar2
  ,available    IN number         DEFAULT NULL    -- for compatibility
  ,unavailable  IN number         DEFAULT NULL    -- for compatibility
  ,duplicates   IN number
  ,statusMask   IN binary_integer DEFAULT NULL    -- for compatibility
  ,pluginSCN    IN number         DEFAULT 0
  ,onlytc       IN binary_integer DEFAULT FALSE#) -- for compatibility
IS
BEGIN
   deb(DEB_ENTER, 'translateDataFileCopyTag');
   validateState(getDatafileCopyCursor);
 
--
--
--
--
   deb(DEB_OPEN, 'findDataFileBackup_c');
 
   if (onlytc != FALSE#) THEN
      deb(DEB_PRINT, 'onytc is TRUE#');
   end if;
 
   OPEN findDatafileBackup_c(
                         sourcemask   => imageCopy_con_t,
                         tag          => tag,
                         reset_scn    => this_reset_scn,
                         reset_time   => this_reset_time,
                         statusMask   => nvl(statusMask,
                                             computeAvailableMask(available,
                                                                  unavailable,
                                                                  0, 0)),
                         duplicates   => duplicates,
                         pluginSCN    => pluginSCN,
                         onlytc       => onlytc
                         );
 
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDataFileCopyNoRows.error      := -20232;
   getDataFileCopyNoRows.msg        := 'Datafile copy tag does not match';
   getDataFileCopyDuplicates        := duplicates;
   getDataFileCopyLast.dfNumber_obj := NULL;
   getDataFileCopySingleRow         := FALSE;
   getDataFileCopyLatestOnly        := FALSE;
   deb(DEB_EXIT);
END translateDataFileCopyTag;
 
--
--
--
--
 
--
PROCEDURE translateDatafileCopyFno(
   fno         IN number
  ,available   IN number         DEFAULT NULL
  ,unavailable IN number         DEFAULT NULL
  ,duplicates  IN number
  ,statusMask  IN binary_integer DEFAULT NULL
  ,pluginSCN   IN number         DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'translateDatafileCopyFno');
   validateState(getDatafileCopyCursor);
 
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(
                         duplicates   => duplicates,
                         sourcemask   => imageCopy_con_t,
                         fno          => fno,
                         statusMask   =>  NVL(statusMask,
                                              computeAvailableMask(available,
                                                                   unavailable,
                                                                   0, 0)),
                         pluginSCN    => pluginSCN
                         );
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDatafileCopyNoRows.error      := -20230;
   getDatafileCopyNoRows.msg        := 'Datafile copy does not exist';
   getDatafileCopyDuplicates        := duplicates;
   getDatafileCopyLatestOnly        := FALSE;
   getDatafileCopyLast.dfNumber_obj := NULL;
   IF (duplicates = FALSE#) THEN
      getDatafileCopySingleRow := TRUE;
   ELSE
      getDatafileCopySingleRow := FALSE;
   END IF;
   setDfTransClause(fno => fno);
   deb(DEB_EXIT);
END translateDatafileCopyFno;
 
--
--
PROCEDURE getDataFileCopy(
   recid OUT number
  ,stamp OUT number
  ,file# OUT number
  ,fname OUT varchar2
  ,reset_scn OUT number
  ,create_scn OUT number
  ,ckp_scn OUT number
  ,block_size OUT number
  ,blocks OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getDataFileCopy');
   getDataFileCopy(rcvRec);
 
   recid        := rcvRec.recid_con;
   stamp        := rcvRec.stamp_con;
   file#        := rcvRec.dfNumber_obj;
   fname        := rcvRec.fileName_con;
   reset_scn    := rcvRec.rlgSCN_act;
   create_scn   := rcvRec.dfCreationSCN_obj;
   ckp_scn      := rcvRec.toSCN_act;
   block_size   := rcvRec.blockSize_con;
   blocks       := rcvRec.blocks_con;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      recid := NULL;                    -- signal end-of-fetch to client
      deb(DEB_EXIT, 'with no more records');
END getDataFileCopy;
 
--
--
--
 
--
PROCEDURE getProxyCopy(
   rcvRec      OUT NOCOPY rcvRec_t
  ,closeCursor IN  boolean DEFAULT FALSE)
IS
   getProxyCopyRowcount number;
   dummy                rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getProxyCopy');
   IF (getProxyCopyCursor = 'findProxyCopy') THEN
      FETCH findProxyCopy
       INTO rcvRec;
 
      IF (findProxyCopy%NOTFOUND) THEN
         getProxyCopyRowcount := findProxyCopy%ROWCOUNT;
         CLOSE findProxyCopy;
      ELSE
         IF (getProxyCopyByHandle) THEN
--
            FETCH findProxyCopy
             INTO dummy;
            IF (NOT findProxyCopy%NOTFOUND) THEN
               CLOSE findProxyCopy;
               deb(DEB_EXIT, 'with error 20311');
               raise_application_error(-20311, 'Ambiguous proxy copy handle');
            END IF;
         END IF;
      END IF;
 
      IF (closeCursor AND findProxyCopy%ISOPEN) THEN
         CLOSE findProxyCopy;
      END IF;
   ELSIF (getProxyCopyCursor = 'findProxyCopyKey') THEN
      FETCH findProxyCopyKey
       INTO rcvRec;
 
      IF (findProxyCopyKey%NOTFOUND) THEN
         getProxyCopyRowcount := findProxyCopyKey%ROWCOUNT;
         CLOSE findProxyCopyKey;
      END IF;
 
      IF (closeCursor AND findProxyCopyKey%ISOPEN) THEN
         CLOSE findProxyCopyKey;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with errors 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor) THEN
      getProxyCopyCursor := NULL;
   END IF;
 
   IF (getProxyCopyRowcount IS NOT NULL) THEN
      getProxyCopyCursor := NULL;
      IF (getProxyCopyRowcount = 0 AND
          getProxyCopyNoRows.error IS NOT NULL) THEN
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getProxyCopyNoRows.error,
                                 getProxyCopyNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;                   -- signal end-of-fetch
      END IF;
   END IF;
   deb(DEB_EXIT);
 
END getProxyCopy;
 
--
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyKey');
   validateState(getProxyCopyCursor);
 
   deb(DEB_OPEN, 'findProxyCopyKey');
   OPEN findProxyCopyKey(key            => pc_key,
                         deviceType     => deviceType,
                         statusMask     => NVL(statusMask,
                  computeAvailableMask(available, unavailable, deleted,
                                       expired)));
   getProxyCopyCursor       := 'findProxyCopyKey';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'proxy copy is missing';
   getProxyCopyByHandle     := FALSE;
   deb(DEB_EXIT);
END translateProxyCopyKey;
 
--
 
--
PROCEDURE translateProxyCopyKey(
   pc_key       IN number
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyKey815');
   translateProxyCopyKey(pc_key         => pc_key,
                         deviceType     => device_type,
                         available      => available,
                         unavailable    => unavailable,
                         deleted        => deleted,
                         expired        => unavailable);
 
   getProxyCopy(rcvRec      => rcvRec,
                closeCursor => TRUE);
 
   recid  := rcvRec.recid_con;
   stamp  := rcvRec.stamp_con;
   handle := rcvRec.fileName_con;
   deb(DEB_EXIT);
END translateProxyCopyKey;
 
--
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,deviceType   IN varchar2
  ,available    IN number           DEFAULT NULL   -- for compatability
  ,unavailable  IN number           DEFAULT NULL   -- for compatability
  ,deleted      IN number           DEFAULT NULL   -- for compatability
  ,expired      IN number           DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer   DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyHandle');
   validateState(getProxyCopyCursor);
 
   deb(DEB_OPEN, 'findProxyCopy');
   OPEN findProxyCopy(handle      => handle,
                      deviceType  => deviceType,
                      statusMask  => NVL(statusMask,
                          computeAvailableMask(available, unavailable, deleted,
                                               expired)));
   getProxyCopyCursor       := 'findProxyCopy';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'proxy copy is missing';
   getProxyCopyByHandle     := TRUE;
   deb(DEB_EXIT);
END translateProxyCopyHandle;
 
--
 
--
PROCEDURE translateProxyCopyHandle(
   handle       IN varchar2
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,deleted      IN number
  ,recid        OUT number
  ,stamp        OUT number)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyHandle815');
   translateProxyCopyHandle(handle      => handle,
                            deviceType  => device_type,
                            available   => available,
                            unavailable => unavailable,
                            deleted     => deleted,
                            expired     => unavailable);
 
   getProxyCopy(rcvRec      => rcvRec,
                closeCursor => TRUE);
 
   recid  := rcvRec.recid_con;
   stamp  := rcvRec.stamp_con;
   deb(DEB_EXIT);
END translateProxyCopyHandle;
 
--
 
--
PROCEDURE translateProxyCopyTag(
   tag         IN varchar2
  ,device_type IN varchar2
  ,available   IN number           DEFAULT NULL   -- for compatability
  ,unavailable IN number           DEFAULT NULL   -- for compatability
  ,deleted     IN number           DEFAULT NULL   -- for compatability
  ,statusMask  IN binary_integer   DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyTag');
   validateState(getProxyCopyCursor);
   deb(DEB_OPEN, 'findProxyCopy');
   OPEN findProxyCopy(tag            => tag,
                      deviceType     => device_type,
                      statusMask     => NVL(statusMask,
                          computeAvailableMask(available, unavailable, deleted,
                                               unavailable/*expired*/)));
   getProxyCopyCursor       := 'findProxyCopy';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'no matching proxy copy found';
   getProxyCopyByHandle     := FALSE;
   deb(DEB_EXIT);
END translateProxyCopyTag;
 
--
PROCEDURE translateProxyCopyGuid(
   guid        IN varchar2
  ,device_type IN varchar2
  ,statusMask  IN binary_integer)
IS
   pdbKey number := NULL;
BEGIN
   deb(DEB_ENTER, 'translateProxyCopyGuid');
   validateState(getProxyCopyCursor);
   deb(DEB_OPEN, 'findProxyCopy');
 
--
   pdbKey := guidToPdbKey(guid);
--
 
   OPEN findProxyCopy(pdbKey         => pdbKey,
                      guid           => guid,
                      deviceType     => device_type,
                      statusMask     => NVL(statusMask, 0));
   getProxyCopyCursor       := 'findProxyCopy';
   getProxyCopyNoRows.error := -20310;
   getProxyCopyNoRows.msg   := 'no matching proxy copy found';
   getProxyCopyByHandle     := FALSE;
   deb(DEB_EXIT);
END translateProxyCopyGuid;
 
 
--
 
--
PROCEDURE getProxyCopy(
   recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2)
IS
   rcvRec       rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getProxyCopyHandle');
   getProxyCopy(rcvRec);
   recid  := rcvRec.recid_con;
   stamp  := rcvRec.stamp_con;
   handle := rcvRec.fileName_con;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      recid := NULL;                    -- indicate end-of-fetch
      deb(DEB_EXIT, 'with no more records');
END getProxyCopy;
 
--
--
--
 
--
PROCEDURE getBackupPiece(
   bpRec        OUT NOCOPY bpRec_t
  ,closeCursor  IN  boolean DEFAULT FALSE)
IS
   dummy        bpRec_t;
   local        bpRec_t;
   eof          boolean := FALSE;
   eob          boolean := FALSE;
   raiseError   boolean := FALSE;
BEGIN
   deb(DEB_ENTER, 'getBackupPiece');
   IF (getBackupPieceDuplicates = FALSE# AND
       getBackupPieceDeviceType IS NULL) THEN
--
--
--
      deb(DEB_EXIT, 'with error 20999');
      raise_application_error(-20999, 'deviceType must be specified');
   END IF;
 
<<nextRow>>
 
   IF (getBackupPieceCursor = 'findBackupPieceBpKey') THEN
      FETCH findBackupPieceBpKey
       INTO local;
 
      IF (findBackupPieceBpKey%NOTFOUND) THEN
         eof := TRUE;
         CLOSE findBackupPieceBpKey;
      END IF;
 
      IF (closeCursor AND findBackupPieceBpKey%ISOPEN) THEN
         CLOSE findBackupPieceBpKey;
      END IF;
   ELSIF (getBackupPieceCursor = 'findBackupPieceBsKey1') THEN
      FETCH findBackupPieceBsKey1
       INTO local;
 
      IF (findBackupPieceBsKey1%NOTFOUND) THEN
         eof := TRUE;
         CLOSE findBackupPieceBsKey1;
      END IF;
 
      IF (closeCursor AND findBackupPieceBsKey1%ISOPEN) THEN
         CLOSE findBackupPieceBsKey1;
      END IF;
   ELSIF (getBackupPieceCursor = 'findBackupPieceBsKey2') THEN
--
      local := getBackupPieceSeekLast;
      deb(DEB_PRINT, 'bskey = ' || local.bskey);
 
--
      IF (local.bskey != getBackupPieceBsKey              OR
          local.deviceType != getBackupPieceDeviceType    OR
          (getBackupPieceCopyNumber IS NOT NULL AND
           local.copyNumber != getBackupPieceCopyNumber)) THEN
         eob := TRUE;
         deb(DEB_PRINT, 'end of backupset');
      ELSE
         <<checkAgain>>
         LOOP
--
            FETCH findBackupPieceBsKey2
             INTO dummy;
 
            IF (findBackupPieceBsKey2%NOTFOUND) THEN
               CLOSE findBackupPieceBsKey2;
               dummy.bskey := 0;
            END IF;
 
            IF (dummy.bskey != getBackupPieceBsKey               OR
                dummy.deviceType != getBackupPieceDeviceType     OR
                getBackupPieceCopyNumber IS NULL                 OR
                dummy.copyNumber = getBackupPieceCopyNumber) THEN
               getBackupPieceSeekLast := dummy;
               EXIT checkAgain;
            END IF;
         END LOOP;
         deb(DEB_PRINT, 'next bskey=' || getBackupPieceSeekLast.bskey);
      END IF;
   ELSIF (getBackupPieceCursor = 'findBackupPiece_c') THEN
      FETCH findBackupPiece_c
       INTO local;
 
      IF (findBackupPiece_c%NOTFOUND) THEN
         eof := TRUE;
         CLOSE findBackupPiece_c;
      ELSE
         IF (getBackupPieceByHandle) THEN
--
            FETCH findBackupPiece_c
             INTO dummy;
            IF (NOT findBackupPiece_c%NOTFOUND) THEN
               raiseError := TRUE;
--
--
--
--
--
--
--
--
 
 
               
               IF (raiseError) THEN
                  CLOSE findBackupPiece_c;
                  deb(DEB_EXIT, 'with error 20261');
                  raise_application_error(-20261,
                                          'Ambiguous backup piece handle');
               END IF;
            END IF;
         END IF;
      END IF;
 
      IF (closeCursor AND findBackupPiece_c%ISOPEN) THEN
         CLOSE findBackupPiece_c;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (closeCursor OR eof) THEN
      getBackupPieceCursor := NULL;
   END IF;
 
   IF (eof OR eob) THEN           -- if end of fetch or end of backupset
--
--
      IF (getBackupPieceDuplicates = FALSE#) THEN
--
--
--
         IF (getBackupPieceExpectedPieces IS NOT NULL AND
             (getBackupPieceAvailableMask IS NULL  OR
              bitand(getBackupPieceAvailableMask,
                     dbms_rcvman.BSpartial_avail) = 0) AND
             getBackupPieceExpectedPieces <> getBackupPiecePieceCount) THEN
             deb(DEB_EXIT, 'with error 20216');
             raise_application_error(-20216, 'Backup piece is missing');
         END IF;
      END IF;
      IF (getBackupPiecePieceCount = 0 AND
          getBackupPieceNoRows.error IS NOT NULL) THEN
         deb(DEB_EXIT, 'with norows error');
         raise_application_error(getBackupPieceNoRows.error,
                                 getBackupPieceNoRows.msg);
      ELSE
         deb(DEB_EXIT, 'no more records');
         RAISE no_data_found;
      END IF;
   END IF;
 
   IF (getBackupPieceDuplicates = FALSE#) THEN
--
--
      IF (local.pieceNumber = getBackupPieceLast.pieceNumber) THEN
--
         GOTO nextRow;
      END IF;
   END IF;
 
   getBackupPieceLast := local;
   bpRec := local;                              -- set OUT mode arg
 
   getBackupPiecePieceCount := getBackupPiecePieceCount + 1;
   deb(DEB_EXIT);
END getBackupPiece;
 
--
PROCEDURE translateBackupPieceKey(
   key          IN number
  ,available    IN number             DEFAULT TRUE#
  ,unavailable  IN number             DEFAULT TRUE#
  ,expired      IN number             DEFAULT TRUE#
  ,statusMask   IN binary_integer     DEFAULT NULL)  -- for compatability
IS
BEGIN
--
--
--
--
--
 
   deb(DEB_ENTER, 'translateBackupPieceKey');
   findBackupPiece(bpKey       => key,
                   statusMask  => NVL(statusMask,
                computeAvailableMask(available, unavailable, 0, unavailable)));
 
   getBackupPieceNoRows.error   := -20260;
   getBackupPieceNoRows.msg     := 'Backup piece is missing';
   getBackupPieceAvailableMask  := statusMask;
   deb(DEB_EXIT);
END translateBackupPieceKey;
 
--
PROCEDURE translateBackupPieceKey(
   bp_key       IN number
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,handle       OUT varchar2
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number)
IS
   bpRec        bpRec_t;
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceKey');
--
--
--
--
--
--
--
 
   translateBackupPieceKey(key => bp_key,
                   statusMask  =>
                computeAvailableMask(available, unavailable, 0,
                                     unavailable/*expired*/));
 
   getBackupPiece(bpRec       => bpRec,
                  closeCursor => TRUE);
 
   recid     := bpRec.recid;
   stamp     := bpRec.stamp;
   handle    := bpRec.handle;
   set_stamp := bpRec.setStamp;
   set_count := bpRec.setCount;
   piece#    := bpRec.pieceNumber;
   deb(DEB_EXIT);
 
END translateBackupPieceKey;
 
--
PROCEDURE translateBackupPieceHandle(
   handle       IN varchar2
  ,deviceType   IN varchar2
  ,available    IN number             DEFAULT NULL   -- for compatability
  ,unavailable  IN number             DEFAULT NULL   -- for compatability
  ,expired      IN number             DEFAULT NULL   -- for compatability
  ,statusMask   IN binary_integer     DEFAULT NULL)  -- for compatability
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceHandle');
   findBackupPiece(handle      => handle,
                   deviceType  => deviceType,
                   statusMask  => NVL(statusMask,
                  computeAvailableMask(available, unavailable, 0, expired)));
 
   getBackupPieceNoRows.error   := -20260;
   getBackupPieceNoRows.msg     := 'Backup piece is missing';
   getBackupPieceByHandle       := TRUE;
   getBackupPieceAvailableMask  := statusMask;
   deb(DEB_EXIT);
END translateBackupPieceHandle;
 
--
PROCEDURE translateBackupPieceHandle(                     -- only used in 8.1.6
   handle       IN varchar2
  ,device_type  IN varchar2
  ,available    IN number
  ,unavailable  IN number
  ,recid        OUT number
  ,stamp        OUT number
  ,set_stamp    OUT number
  ,set_count    OUT number
  ,piece#       OUT number)
IS
   bpRec        bpRec_t;
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceHandle816');
   translateBackupPieceHandle(handle      => handle,
                              deviceType  => device_type,
                              statusMask  =>
                             computeAvailableMask(available, unavailable, 0,
                                                  unavailable/*expired*/));
 
   getBackupPiece(bpRec       => bpRec,
                  closeCursor => TRUE);
 
   recid     := bpRec.recid;
   stamp     := bpRec.stamp;
   set_stamp := bpRec.setStamp;
   set_count := bpRec.setCount;
   piece#    := bpRec.pieceNumber;
   deb(DEB_EXIT);
END translateBackupPieceHandle;
 
--
--
PROCEDURE translateBackupPieceTag(
   tag         IN varchar2
  ,available   IN number             DEFAULT NULL     -- for compatability
  ,unavailable IN number             DEFAULT NULL     -- for compatability
  ,statusMask  IN binary_integer     DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceTag');
 
   findBackupPiece(tag         => tag,
                   statusMask  => NVL(statusMask,
                  computeAvailableMask(available, unavailable, 0,
                                       /* expired = */unavailable)));
   deb(DEB_EXIT);
END translateBackupPieceTag;
 
--
--
PROCEDURE translateBackupPieceGuid(
   guid        IN varchar2
  ,statusMask  IN binary_integer)
IS
   pdbKey  number := NULL;
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceGuid');
 
--
   pdbKey := guidToPdbKey(guid);
--
 
   findBackupPiece(pdbKey      => pdbKey,
                   guid        => guid,
                   statusMask  => NVL(statusMask, 0));
   deb(DEB_EXIT);
END translateBackupPieceGuid;
 
--
PROCEDURE translateBackupPieceBSKey(
   key          IN number
  ,tag          IN varchar2        DEFAULT NULL
  ,deviceType   IN varchar2        DEFAULT NULL
  ,pieceCount   IN number
  ,duplicates   IN number          DEFAULT TRUE#
  ,copyNumber   IN number          DEFAULT NULL
  ,available    IN number          DEFAULT TRUE#
  ,unavailable  IN number          DEFAULT FALSE#
  ,deleted      IN number          DEFAULT FALSE#
  ,expired      IN number          DEFAULT FALSE#
  ,statusMask   IN binary_integer  DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupPieceBSKey');
   findBackupPiece(bsKey       => key,
                   tag         => tag,
                   deviceType  => deviceType,
                   copyNumber  => copyNumber,
                   statusMask  => NVL(statusMask,
              computeAvailableMask(available, unavailable, deleted, expired)));
 
   getBackupPieceDuplicates     := duplicates;
   getBackupPieceExpectedPieces := pieceCount;
   getBackupPieceAvailableMask  := statusMask;
   deb(DEB_EXIT);
END translateBackupPieceBSKey;
 
--
PROCEDURE translateBackupPieceBsKey(
   startBsKey   IN number
  ,tag          IN varchar2           DEFAULT NULL
  ,statusMask   IN binary_integer     DEFAULT NULL)
IS
BEGIN
   findBackupPiece(startBsKey  => startBskey,
                   tag         => tag,
                   statusMask  => NVL(statusMask,
                computeAvailableMask(TRUE#    /* available */,
                                     FALSE# /* unavailable */,
                                     FALSE#     /* deleted */,
                                     FALSE#     /* expired */)));
   getBackupPieceAvailableMask  := statusMask;
END translateBackupPieceBsKey;
 
--
PROCEDURE translateSeekBpBsKey(
   bsKey        IN number
  ,deviceType   IN varchar2
  ,pieceCount   IN number
  ,duplicates   IN number    DEFAULT TRUE#
  ,copyNumber   IN number    DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'translateSeekBpBsKey');
   deb(DEB_IN, 'bskey=' || bsKey);
 
   IF (getBackupPieceCursor IS NULL OR
       getBackupPieceCursor != 'findBackupPieceBsKey2') THEN
      raise_application_error(-20204, 'Translation not started');
   ELSIF (deviceType IS NULL) THEN
      raise_application_error(-20999, 'deviceType must be specified');
   END IF;
 
--
--
   getBackupPieceNoRows.error     := NULL;
   getBackupPieceDuplicates       := duplicates;
   getBackupPieceLast.pieceNumber := NULL;
   getBackupPieceDeviceType       := deviceType;
   getBackupPieceExpectedPieces   := pieceCount;
   getBackupPiecePieceCount       := 0;
   getBackupPieceByHandle         := FALSE;
   getBackupPieceCopyNumber       := copyNumber;
   getBackupPieceBskey            := bsKey;
 
<<checkAgain>>
   LOOP
      IF (NOT findBackupPieceBsKey2%ISOPEN) THEN      -- all done
         deb(DEB_EXIT, 'cursor not open');
         RAISE no_data_found;
      END IF;
 
      IF (getBackupPieceSeekLast.bskey > bsKey) THEN  -- gone over the key
         deb(DEB_EXIT, 'gone over key seek=' || getBackupPieceSeekLast.bskey
                       || ' key=' || bsKey);
         RAISE no_data_found;
      END IF;
 
--
      IF (getBackupPieceSeekLast.bskey = bsKey              AND
          getBackupPieceSeekLast.deviceType = deviceType    AND
          (copyNumber IS NULL OR
           getBackupPieceSeekLast.copyNumber = copyNumber)) THEN
         EXIT checkAgain;
      END IF;
 
      FETCH findBackupPieceBsKey2
       INTO getBackupPieceSeekLast;
 
      IF (findBackupPieceBsKey2%NOTFOUND) THEN       -- all done
        CLOSE findBackupPieceBsKey2;
        deb(DEB_EXIT, 'no more data');
        RAISE no_data_found;
      END IF;
   END LOOP;
   deb(DEB_EXIT, 'got key=' || bsKey);
END translateSeekBpBsKey;
 
--
PROCEDURE translateBpBsKeyCancel
IS
BEGIN
   IF (findBackupPieceBsKey1%ISOPEN) THEN
      CLOSE findBackupPieceBsKey1;
   END IF;
   IF (findBackupPieceBsKey2%ISOPEN) THEN
      CLOSE findBackupPieceBsKey2;
   END IF;
   getBackupPieceCursor := NULL;
END translateBpBsKeyCancel;
 
--
--
PROCEDURE translateBackupSetKey(
   bs_key          IN  number
  ,device_type     IN  varchar2
  ,available       IN  number
  ,unavailable     IN  number
  ,deleted         IN  number
  ,duplicates      IN  number
  ,backup_type     OUT varchar2
  ,recid           OUT number
  ,stamp           OUT number
  ,set_stamp       OUT number
  ,set_count       OUT number
  ,bslevel         OUT number
  ,completion_time OUT date)
IS
   bsRec           bsRec_t;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetKey815');
   findBackupSet(bsKey => bs_key,               -- Lookup backset by key
                 bsRec => bsRec);
 
   backup_type     := bsRec.bsType;
   recid           := bsRec.recid;
   stamp           := bsRec.stamp;
   set_stamp       := bsRec.setStamp;
   set_count       := bsRec.setCount;
   bslevel         := bsRec.level;
   completion_time := bsRec.compTime;
 
--
--
--
--
--
--
 
--
   translateBackupPieceBSKey(key         => bs_key,
                             deviceType  => device_type,
                             pieceCount  => bsRec.pieceCount,
                             available   => available,
                             unavailable => unavailable,
                             deleted     => deleted,
                             expired     => unavailable);
 
   getBackupPieceDuplicates := duplicates;
 
   IF (device_type IS NULL) THEN
--
--
--
--
--
--
--
--
--
      getBackupPieceDuplicates := TRUE#;        -- yes, we want duplicates
   END IF;
 
   IF (getBackupPieceDuplicates = FALSE#) THEN
--
--
--
      getBackupPieceExpectedPieces := bsRec.pieceCount;
   END IF;
   deb(DEB_EXIT);
END translateBackupSetKey;
 
--
--
PROCEDURE translateBackupSetKey(
   bs_key          IN  number
  ,device_type     IN  varchar2
  ,available       IN  number
  ,unavailable     IN  number
  ,deleted         IN  number
  ,duplicates      IN  number
  ,backup_type     OUT varchar2
  ,recid           OUT number
  ,stamp           OUT number)
IS
   set_stamp       number;
   set_count       number;
   bslevel         number;
   completion_time date;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetKey80');
   translateBackupSetKey(bs_key, device_type, available, unavailable, deleted,
                         duplicates, backup_type, recid, stamp, set_stamp,
                         set_count, bslevel, completion_time);
   deb(DEB_EXIT);
END translateBackupSetKey;
 
--
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2
  ,bs_key      OUT number
  ,bslevel     OUT number
  ,completed   OUT date)
IS
   bsRec                bsRec_t;
   pieceCount           number;
   validationRec        validBackupSetRec_t;
   gotRecord            number;
   duplicates_flag      number;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetRecid815');
   findBackupSet(recid => recid,
                 stamp => stamp,
                 bsRec => bsRec);
 
   bs_key    := bsRec.key;
   bslevel   := bsRec.level;
   completed := bsRec.compTime;
 
--
--
--
--
 
   findValidBackupSet(backupSetRec              => bsRec,
                      tag                       => restoreTag,
                      deviceType                => device_type,
                      available                 => TRUE#);
 
   gotRecord := getValidBackupSet(validBackupSetRec => validationRec);
 
   IF (getValidBackupSetCursor = 'findValidBackupSet_c') THEN
      CLOSE findValidBackupSet_c;
   ELSIF (getValidBackupSetCursor = 'findValidBackupSet1P_c') THEN
      CLOSE findValidBackupSet1P_c;
   END IF;
 
   IF (gotRecord = FALSE#) THEN
--
--
--
--
      validationRec.copyNumber := NULL;
   END IF;
 
   IF (device_type IS NULL) THEN
--
      duplicates_flag := TRUE#;
   ELSE
--
      duplicates_flag := FALSE#;
   END IF;
 
   translateBackupPieceBSKey(key         => bsRec.key,
                             tag         => validationRec.tag,
                             deviceType  => device_type,
                             pieceCount  => bsRec.pieceCount,
                             duplicates  => duplicates_flag,
                             copyNumber  => validationRec.copyNumber,
                             available   => TRUE#);
   deb(DEB_EXIT);
END translateBackupSetRecid;
 
--
 
--
PROCEDURE translateBackupSetRecid(
   recid       IN  number
  ,stamp       IN  number
  ,device_type IN  varchar2)
IS
   bs_key    number;
   bslevel   number;
   completed date;
BEGIN
   deb(DEB_ENTER, 'translateBackupSetRecid80');
   translateBackupSetRecid(recid, stamp, device_type, bs_key, bslevel,
                          completed);
   deb(DEB_EXIT);
END translateBackupSetRecid;
 
--
--
PROCEDURE getBackupPiece(
   recid      OUT number
  ,stamp      OUT number
  ,bpkey      OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,piece#     OUT number
  ,copy#      OUT number
  ,status     OUT varchar2
  ,completion OUT date
  ,handle     OUT varchar2)
IS
   bpRec      bpRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupPiece815');
   getBackupPiece(bpRec);
 
   recid        := bpRec.recid;
   stamp        := bpRec.stamp;
   bpkey        := bpRec.key;
   set_stamp    := bpRec.setStamp;
   set_count    := bpRec.setCount;
   piece#       := bpRec.pieceNumber;
   copy#        := bpRec.copyNumber;
   status       := bpRec.status;
   completion   := bpRec.compTime;
   handle       := bpRec.handle;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with no more records');
      bpRec.recid := NULL;              -- indicate end-of-fetch to client
END getBackupPiece;
 
--
--
PROCEDURE getBackupPiece(
   recid     OUT number
  ,stamp     OUT number
  ,set_stamp OUT number
  ,set_count OUT number
  ,piece#    OUT number
  ,handle    OUT varchar2)
IS
   bpRec     bpRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupPiece80');
   getBackupPiece(bpRec);
 
   recid        := bpRec.recid;
   stamp        := bpRec.stamp;
   set_stamp    := bpRec.setStamp;
   set_count    := bpRec.setCount;
   piece#       := bpRec.pieceNumber;
   handle       := bpRec.handle;
   deb(DEB_EXIT);
EXCEPTION
   WHEN no_data_found THEN
      bpRec.recid := NULL;              -- indicate end-of-fetch to client
      deb(DEB_EXIT, 'with no more records');
END getBackupPiece;
 
--
--
--
 
--
PROCEDURE translateBackupSetKey(
   key        IN  number
  ,bsRec      OUT NOCOPY bsRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupSetKey');
   findBackupSet(bsKey => key,
                 bsRec => bsRec);
   deb(DEB_EXIT);
END translateBackupSetKey;
 
--
--
--
 
--
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number)
RETURN number IS
   rcvRec       rcvRec_t;
   rc           number;
BEGIN
   deb(DEB_ENTER, 'findControlFileBackup804');
   rc := getControlfileBackup(rcvRec);
 
   IF (rc = SUCCESS) THEN
      IF (rcvRec.type_con = imageCopy_con_t) THEN
         type := COPY;
      ELSIF (rcvRec.type_con = backupSet_con_t) THEN
         type := BACKUP;
      ELSIF (rcvRec.type_con = proxyCopy_con_t) THEN
         type := PROXY;
      ELSE
--
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN dbms_rcvman.UNAVAILABLE;
      END IF;
 
      IF (type = BACKUP) THEN
         recid := rcvRec.bsRecid_con;
         stamp := rcvRec.bsStamp_con;
      ELSE
         recid := rcvRec.recid_con;
         stamp := rcvRec.stamp_con;
      END IF;
      fname       := rcvRec.fileName_con;
      device_type := rcvRec.deviceType_con;
      ckp_scn     := rcvRec.toSCN_act;
      deb(DEB_EXIT, 'with: SUCCESS');
      RETURN SUCCESS;
   ELSE
      deb(DEB_EXIT, 'with: '||to_char(rc));
      RETURN rc;
   END IF;
   deb(DEB_EXIT);
 
END findControlFileBackup;
 
--
--
FUNCTION findControlFileBackup(
   type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,fname        OUT varchar2
  ,device_type  OUT varchar2
  ,ckp_scn      OUT number
  ,rlg_scn      OUT number
  ,blksize      OUT number)
RETURN number IS
   rcvRec       rcvRec_t;
   rc           number;
BEGIN
   deb(DEB_ENTER, 'findControlFileBackup815');
   rc := getControlfileBackup(rcvRec);
 
   IF (rc = SUCCESS) THEN
      IF (rcvRec.type_con = imageCopy_con_t) THEN
         type := COPY;
      ELSIF (rcvRec.type_con = backupSet_con_t) THEN
         type := BACKUP;
      ELSIF (rcvRec.type_con = proxyCopy_con_t) THEN
         type := PROXY;
         rcvRec_last := rcvRec;         -- save for translateProxyDFRecid
      ELSE
--
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN dbms_rcvman.UNAVAILABLE;
      END IF;
 
      IF (type = BACKUP) THEN
         recid := rcvRec.bsRecid_con;
         stamp := rcvRec.bsStamp_con;
      ELSE
         recid := rcvRec.recid_con;
         stamp := rcvRec.stamp_con;
      END IF;
      fname       := rcvRec.fileName_con;
      device_type := rcvRec.deviceType_con;
      ckp_scn     := rcvRec.toSCN_act;
      rlg_scn     := rcvRec.rlgSCN_act;
      blksize     := rcvRec.blockSize_con;
      deb(DEB_EXIT, 'with: SUCCESS');
      RETURN SUCCESS;
   ELSE
      deb(DEB_EXIT, 'with: '||to_char(rc));
      RETURN rc;
   END IF;
END findControlFileBackup;
 
--
--
--
--
--
FUNCTION findArchivedLogBackup(
   thread#      IN number
  ,sequence#    IN number
  ,low_scn      IN number
  ,type         OUT number
  ,recid        OUT number
  ,stamp        OUT number
  ,device_type  OUT varchar2)
RETURN number IS
   rcvRec       rcvRec_t;
   RC           binary_integer;
BEGIN
   deb(DEB_ENTER, 'findArchivedLogBackup');
--
--
--
 
   findArchivedLogBackup(thread#, sequence#, low_scn);
 
   RC := getArchivedLogbackup(rcvRec);
 
   IF (RC = SUCCESS) THEN
      type        := BACKUP;
      recid       := rcvRec.bsRecid_con;
      stamp       := rcvRec.bsStamp_con;
      device_type := rcvRec.deviceType_con;
   END IF;
 
   deb(DEB_EXIT, 'with: '||to_char(RC));
   RETURN RC;
END findArchivedLogBackup;
 
--
--
--
 
--
PROCEDURE listTranslateControlfileCopy(
   tag             IN varchar2
  ,completedAfter  IN date
  ,completedBefore IN date
  ,statusMask      IN binary_integer DEFAULT
                        BSavailable+BSunavailable+BSexpired
  ,liststby        IN binary_integer DEFAULT NULL -- default for 8.1
  ,file_pattern    IN varchar2       DEFAULT NULL)
IS
  currentIncarnation number;
BEGIN
   deb(DEB_ENTER, 'listTranslateControlfileCopy');
   IF (findControlfileBackup_c%ISOPEN) THEN -- should not be open
      CLOSE findControlfileBackup_c;
   END IF;
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
--
   deb(DEB_OPEN, 'findControlfileBackup_c');
   OPEN findControlfileBackup_c(
                            sourcemask         => imageCopy_con_t,
                            currentIncarnation => currentIncarnation,
                            tag                => tag,
                            completedAfter     => completedAfter,
                            completedBefore    => completedBefore,
                            statusMask         => statusMask,
                            pattern            => file_pattern,
                            needstby           => liststby);
 
   deb(DEB_EXIT);
END listTranslateControlfileCopy;
 
--
PROCEDURE listGetControlfileCopy(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetControlfileCopy');
   FETCH findControlfileBackup_c
    INTO rcvRec;
 
   IF (findControlfileBackup_c%NOTFOUND) THEN
      CLOSE findControlfileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
--
   deb(DEB_EXIT);
END listGetControlfileCopy;
 
--
 
--
FUNCTION listGetControlfileCopy(
   bcfkey     OUT number,
   ckpscn     OUT number,
   ckptime    OUT date,
   status     OUT varchar2,
   completion OUT date,
   fname      OUT varchar2) RETURN number
IS
   rcvRec     rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetControlfileCopy');
   listGetControlfileCopy(rcvRec);
 
   bcfkey     := rcvRec.key_con;
   ckpscn     := rcvRec.toSCN_act;
   ckptime    := rcvRec.toTime_act;
   status     := rcvRec.status_con;
   completion := rcvRec.compTime_con;
   fname      := rcvRec.fileName_con;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetControlfileCopy;
 
--
PROCEDURE listTranslateDataFileCopy(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT BSavailable+BSunavailable
--
  ,pluginSCN         IN number          DEFAULT 0)
IS
   creationSCN        number;
   reset_scn          number := NULL;
   reset_time         date   := NULL;
BEGIN
   deb(DEB_ENTER, 'listTranslateDataFileCopy');
   IF (allIncarnations = TRUE#) THEN
      reset_scn  := NULL;
      reset_time := NULL;
      IF (ignoreCreationSCN = TRUE#) THEN
--
--
--
--
         creationSCN := NULL;
      ELSE
         creationSCN := creation_change#;
      END IF;
   ELSE
      reset_scn   := this_reset_scn;
      reset_time  := this_reset_time;
      creationSCN := creation_change#;
   END IF;
 
--
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(sourcemask         => imageCopy_con_t,
                             fno                => file#,
                             crescn             => creationSCN,
                             reset_scn          => reset_scn,
                             reset_time         => reset_time,
                             tag                => tag,
                             pattern            => file_name_pattern,
                             completedAfter     => completedAfter,
                             completedBefore    => completedBefore,
                             statusMask         => statusMask,
                             pluginSCN          => pluginSCN);
   deb(DEB_EXIT);
END listTranslateDataFileCopy;
 
--
PROCEDURE listGetDataFileCopy(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetDataFileCopy');
   FETCH findDatafileBackup_c
    INTO rcvRec;
 
   IF (findDatafileBackup_c%NOTFOUND) THEN
      CLOSE findDatafileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
--
   deb(DEB_EXIT);
END listGetDatafileCopy;
 
--
 
--
FUNCTION listGetDataFileCopy(
   cdf_key            OUT number
  ,status             OUT varchar2
  ,fname              OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number IS
   rcvRec             rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetDataFileCopy815');
   listGetDatafileCopy(rcvRec);
 
   cdf_key            := rcvRec.key_con;
   status             := rcvRec.status_con;
   fname              := rcvRec.fileName_con;
   completion_time    := rcvRec.compTime_con;
   checkpoint_change# := rcvRec.toSCN_act;
   checkpoint_time    := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetDataFileCopy;
 
--
PROCEDURE listTranslateArchivedLogCopy(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,file_name_pattern IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                       BSavailable+BSunavailable+BSexpired  -- 8.0/8.1 defaults
  ,needstby          IN number          DEFAULT NULL)
IS
   currentIncarnation number;
BEGIN
 
   deb(DEB_ENTER, 'listTranslateArchivedLogCopy');
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
   deb(DEB_OPEN, 'findArchivedLogCopy');
   OPEN findArchivedLogCopy(currentIncarnation => currentIncarnation,
                            thread             => thread#,
                            sequence           => sequence#,
                            lowSCN             => first_change#,
                            pattern            => file_name_pattern,
                            completedAfter     => completedAfter,
                            completedBefore    => completedBefore,
                            statusMask         => statusMask,
--
                            needstby           => NULL);
   getrcvRecLast := NULL;
   deb(DEB_EXIT);
END listTranslateArchivedLogCopy;
 
--
PROCEDURE listGetArchivedLogCopy(
   rcvRec OUT NOCOPY rcvRec_t)
IS
duplicate           number;              -- used for filtering duplicate names
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogCopy');
 
--
--
--
   IF (restoreTag is not NULL OR
       not diskDevice)            THEN
      CLOSE findArchivedLogCopy;
      deb(DEB_EXIT, 'tag specified or no diskDevice allocated');
      RAISE no_data_found;
   END IF;
 
--
   IF (guidQualifier IS NOT NULL) THEN
      IF (findArchivedLogCopy%ISOPEN) THEN
         CLOSE findArchivedLogCopy;
      END IF;
      deb(DEB_EXIT, 'guid not valid for archivelog');
      RAISE no_data_found;
   END IF;
 
<<nextRow>>
   FETCH findArchivedLogCopy
    INTO rcvRec;
 
   IF (findArchivedLogCopy%NOTFOUND) THEN
      CLOSE findArchivedLogCopy;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
--
   IF (rcvRec.logThread_obj   = getrcvRecLast.logThread_obj AND
       rcvRec.logSequence_obj = getrcvRecLast.logSequence_obj AND
       rcvRec.loglowSCN_obj   = getrcvRecLast.loglowSCN_obj AND
       rcvRec.logrlgSCN_obj   = getrcvRecLast.logrlgSCN_obj AND
       rcvRec.logrlgTime_obj  = getrcvRecLast.logrlgTime_obj ) THEN
       duplicate := TRUE#;
   ELSE
       duplicate := FALSE#;
   END IF;
 
   IF IsDuplicateAlName(duplicate, rcvRec.filename_con) THEN
     GOTO nextRow;
   END IF;
 
   getrcvRecLast := rcvRec;
--
 
   deb(DEB_EXIT);
END listGetArchivedLogCopy;
 
--
 
--
FUNCTION listGetArchivedLogCopy(
   al_key          OUT number
  ,status          OUT varchar2
  ,fname           OUT varchar2
  ,completion_time OUT date)
RETURN number IS
   rcvRec          rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogCopy');
   listGetArchivedLogCopy(rcvRec);
 
   al_key          := rcvRec.key_con;
   status          := rcvRec.status_con;
   fname           := rcvRec.fileName_con;
   completion_time := rcvRec.compTime_con;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetArchivedLogCopy;
 
--
--
--
 
--
PROCEDURE listTranslateControlfileBackup(
   tag             IN  varchar2
  ,completedAfter  IN  date
  ,completedBefore IN  date
  ,statusMask      IN  binary_integer   DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,autobackup      IN  binary_integer   DEFAULT BScfile_all
  ,liststby        IN  binary_integer   DEFAULT NULL)
IS
   currentIncarnation number;
BEGIN
   deb(DEB_ENTER, 'listTranslateControlfileBackup');
   IF (findControlfileBackup_c%ISOPEN) THEN     -- should not be open
      CLOSE findControlfileBackup_c;
   END IF;
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
--
--
   deb(DEB_OPEN, 'findControlfileBackup_c');
   OPEN findControlfileBackup_c(sourcemask         => backupSet_con_t,
                                currentIncarnation => currentIncarnation,
                                completedAfter     => completedAfter,
                                completedBefore    => completedBefore,
                                typemask           => autobackup,
                                needstby           => liststby);
 
--
--
--
--
--
 
   listGetBackupTag           := tag;
   listGetBackupAvailableMask := statusMask;
   deb(DEB_EXIT);
END listTranslateControlfileBackup;
 
--
PROCEDURE listGetControlfileBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetControlfileBackup');
   FETCH findControlfileBackup_c
    INTO rcvRec;
 
--
--
 
   IF (findControlfileBackup_c%NOTFOUND) THEN
      CLOSE findControlfileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   deb(DEB_EXIT);
END listGetControlfileBackup;
 
--
--
FUNCTION listGetControlfileBackup(
   bskey      OUT number,
   ckpscn     OUT number,
   ckptime    OUT date)
RETURN number IS
   rcvRec               rcvRec_t;
   validationRec        validBackupSetRec_t;
   validationRC         binary_integer;
BEGIN
   deb(DEB_ENTER, 'listGetControlfileBackup815');
   <<nextRow>>
   BEGIN
      listGetControlfileBackup(rcvRec);
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
   END;
 
   validationRC :=
      validateBackupSet(backupSetRec           => rcvRec,
                        tag                    => listGetBackupTag,
                        tagMatchRequired       => TRUE,
                        checkDeviceIsAllocated => TRUE,
                        availableMask          => listGetBackupAvailableMask,
                        validRec               => validationRec);
 
   IF (validationRC <> SUCCESS) THEN
      GOTO nextRow;
   END IF;
 
   bskey      := rcvRec.bsKey_con;
   ckpscn     := rcvRec.toSCN_act;
   ckptime    := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
    WHEN no_data_found THEN
       deb(DEB_EXIT, 'with: FALSE#');
       RETURN FALSE#;
END listGetControlfileBackup;
 
--
PROCEDURE listTranslateSpfileBackup(
   completedAfter  IN  date
  ,completedBefore IN  date)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateSpfileBackup');
   IF (findSpfileBackup_c%ISOPEN) THEN                   -- should not be open
      CLOSE findSpfileBackup_c;
   END IF;
 
   deb(DEB_OPEN, 'findSpfileBackup_c');
   OPEN findSpfileBackup_c(completedAfter     => completedAfter,
                           completedBefore    => completedBefore);
 
   deb(DEB_EXIT);
END listTranslateSpfileBackup;
 
--
PROCEDURE listGetSpfileBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetSpfileBackup');
   FETCH findSpfileBackup_c
    INTO rcvRec;
 
--
--
 
   IF (findSpfileBackup_c%NOTFOUND) THEN
      CLOSE findSpfileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
   deb(DEB_EXIT);
END listGetSpfileBackup;
 
--
PROCEDURE listTranslateDataFileBackup(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                      BSavailable+BSunavailable+BSexpired   -- 8.0/8.1 defaults
  ,pluginSCN         IN number          DEFAULT 0)
IS
   rlgSCN       number;
   rlgTime      date;
   crescn       number;
BEGIN
   deb(DEB_ENTER, 'listTranslateDataFileBackup');
   IF (findDatafileBackup_c%ISOPEN) THEN
      CLOSE findDatafileBackup_c;
   END IF;
 
   IF (allIncarnations = TRUE#) THEN
      IF (ignoreCreationSCN = TRUE#) THEN
--
--
--
--
--
         crescn := NULL;
      ELSE
         crescn := creation_change#;
      END IF;
   ELSE
--
--
      rlgSCN  := this_reset_scn;
      rlgTime := this_reset_time;
      crescn  := creation_change#;
   END IF;
 
--
   deb(DEB_OPEN, 'findDatafileBackup_c');
   OPEN findDatafileBackup_c(sourceMask         => backupSet_con_t,
                             fno                => file#,
                             crescn             => crescn,
                             reset_scn          => rlgSCN,
                             reset_time         => rlgTime,
                             completedAfter     => completedAfter,
                             completedBefore    => completedBefore,
                             pluginSCN          => pluginSCN);
 
--
--
--
--
--
 
   listGetBackupTag           := tag;
   listGetBackupAvailableMask := statusMask;
   deb(DEB_EXIT);
END listTranslateDataFileBackup;
 
--
PROCEDURE listGetDataFileBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetDataFileBackup');
   FETCH findDatafileBackup_c
    INTO rcvRec;
 
   IF (findDatafileBackup_c%NOTFOUND) THEN
      CLOSE findDatafileBackup_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   deb(DEB_EXIT);
END listGetDataFileBackup;
 
--
 
--
FUNCTION listGetDataFileBackup(
   bs_key             OUT number
  ,backup_type        OUT varchar2
  ,incremental_level  OUT number
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number IS
   rcvRec             rcvRec_t;
   valRC              binary_integer;
   validationRec      validBackupSetRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetDataFileBackup815');
<<nextRow>>
   BEGIN
      listGetDataFileBackup(rcvRec => rcvRec);
   EXCEPTION
      WHEN no_data_found THEN
         deb(DEB_EXIT, 'with: FALSE#');
         RETURN FALSE#;
   END;
 
   valRC :=
      validateBackupSet(backupSetRec           => rcvRec,
                        tag                    => listGetBackupTag,
                        tagMatchRequired       => TRUE,
                        checkDeviceIsAllocated => TRUE,
                        availableMask          => listGetBackupAvailableMask,
                        validRec               => validationRec);
 
   IF (valRC <> SUCCESS) THEN
      GOTO nextRow;
   END IF;
 
   bs_key             := rcvRec.bsKey_con;
   IF (rcvRec.fromSCN_act = 0) THEN
      backup_type := 'Full';
   ELSE
      backup_type := 'Incremental';
   END IF;
   incremental_level  := rcvRec.level_act;
   completion_time    := rcvRec.compTime_con;           -- somewhat bogus
   checkpoint_change# := rcvRec.toSCN_act;
   checkpoint_time    := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
END listGetDataFileBackup;
 
--
 
--
PROCEDURE translateBackupFile(
   bs_recid    IN  number
  ,bs_stamp    IN  number
  ,fno         IN  number
  ,bskey       OUT number
  ,inclevel    OUT number
  ,backup_type OUT varchar2
  ,completed   OUT date)
IS
BEGIN
   deb(DEB_ENTER, 'translateBackupFile');
--
--
--
--
--
--
--
   IF (rcvRec_last.type_con <> backupSet_con_t OR
       rcvRec_last.bsRecid_con <> bs_recid OR
       rcvRec_last.bsStamp_con <> bs_stamp) THEN
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   bskey     := rcvRec_last.bsKey_con;
   inclevel  := rcvRec_last.level_act;
   completed := rcvRec_last.compTime_con;
 
   IF (rcvRec_last.logSequence_obj IS NOT NULL) THEN
      backup_type := 'Archived Log';
   ELSE
      IF (rcvRec_last.fromSCN_act = 0) THEN
         backup_type := 'Full';
      ELSE
         backup_type := 'Incremental';
      END IF;
   END IF;
   deb(DEB_EXIT);
END translateBackupFile;
 
--
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#              IN number
  ,sequence#            IN number
  ,first_change#        IN number
  ,completedAfter       IN date           DEFAULT NULL
  ,completedBefore      IN date           DEFAULT NULL
  ,statusMask           IN binary_integer DEFAULT
                      BSavailable+BSunavailable+BSexpired)  -- 8.0/8.1 defaults
IS
   currentInc number;
BEGIN
   deb(DEB_ENTER, 'listTranslateArchivedLogBackup');
 
   IF (allIncarnations = TRUE#) THEN
      currentInc := FALSE#;                      -- don't care about dbinc_key
   ELSE
      currentInc := TRUE#;
   END IF;
 
   deb(DEB_OPEN, 'findArcLogBackup');
   OPEN findArcLogBackup(sourcemask         => backupSet_con_t,
                         currentIncarnation => currentInc,
                         thread             => thread#,
                         sequence           => sequence#,
                         lowSCN             => first_change#,
                         completedAfter     => completedAfter,
                         completedBefore    => completedBefore);
   listGetBackupAvailableMask := statusMask;
   deb(DEB_EXIT);
END listTranslateArchivedLogBackup;
 
--
PROCEDURE listGetArchivedLogBackup(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogBackup');
 
--
   IF (guidQualifier IS NOT NULL) THEN
      IF (findArcLogBackup%ISOPEN) THEN
         CLOSE findArcLogBackup;
      END IF;
      deb(DEB_EXIT, 'guid not valid for archivelog');
      RAISE no_data_found;
   END IF;
 
   FETCH findArcLogBackup
    INTO rcvRec;
 
   IF (findArcLogBackup%NOTFOUND) THEN
      CLOSE findArcLogBackup;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
   deb(DEB_EXIT);
END listGetArchivedLogBackup;
 
--
 
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,completion_time OUT date)
RETURN number IS
   rcvRec       rcvRec_t;
   validRec     validBackupSetRec_t;
   valRC        binary_integer;
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogBackup');
<<get_next>>
   listGetArchivedLogBackup(rcvRec);
 
   valRC :=
      validateBackupSet(backupSetRec           => rcvRec,
                        checkDeviceIsAllocated => TRUE,
                        availableMask          => listGetBackupAvailableMask,
                        validRec               => validRec);
   IF (valRC <> SUCCESS) THEN
      GOTO get_next;
   END IF;
 
   bs_key          := rcvRec.bsKey_con;
   completion_time := rcvRec.compTime_con;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetArchivedLogBackup;
 
--
--
--
--
PROCEDURE listTranslateArchivedLogBackup(
   thread#      IN number   DEFAULT NULL
  ,lowseq       IN number   DEFAULT NULL
  ,highseq      IN number   DEFAULT NULL
  ,lowscn       IN number   DEFAULT NULL
  ,highscn      IN number   DEFAULT NULL
  ,from_time    IN date     DEFAULT NULL
  ,until_time   IN date     DEFAULT NULL
  ,pattern      IN varchar2 DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateArchivedLogBackup815');
   if lbal2%isopen then
      close lbal2;
   end if;
   deb(DEB_OPEN, 'lbal2');
   open lbal2(thread#, lowseq, highseq, lowscn, highscn, from_time, until_time);
   deb(DEB_EXIT);
END listTranslateArchivedLogBackup;
 
--
--
FUNCTION listGetArchivedLogBackup(
   bs_key          OUT number
  ,thread#         OUT number
  ,sequence#       OUT number
  ,first_change#   OUT number
  ,next_change#    OUT number
  ,first_time      OUT date
  ,next_time       OUT date)
RETURN number IS
   rcvRec          rcvRec_t;
   validRec        validBackupSetRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetArchivedLogBackup815');
<<get_next>>
  fetch lbal2 into rcvRec;
  if lbal2%found then
    IF (debug) THEN
       deb(DEB_PRINT, 'listGetArchivedLogBackup: got a backupset:');
       printRcvRec(rcvRec);
    END IF;
 
    if validateBackupSet(backupSetRec           => rcvRec,
                         checkDeviceIsAllocated => TRUE,
                         availableMask          => dbms_rcvman.BSavailable +
                                                   dbms_rcvman.BSunavailable +
                                                   dbms_rcvman.BSexpired,
                         validRec               => validRec) <> SUCCESS then
       goto get_next;
    end if;
    bs_key          := rcvRec.bsKey_con;
    thread#         := rcvRec.logThread_obj;
    sequence#       := rcvRec.logSequence_obj;
    first_change#   := rcvRec.logLowSCN_obj;
    next_change#    := rcvRec.logNextSCN_obj;
    first_time      := rcvRec.logLowTime_obj;
    next_time       := rcvRec.logNextTime_obj;
    deb(DEB_EXIT, 'with: TRUE#');
    RETURN TRUE#;
  else
    close lbal2;
    deb(DEB_EXIT, 'with: FALSE#');
    RETURN FALSE#;
  end if;
END listGetArchivedLogBackup;
 
--
--
--
 
PROCEDURE listTranslateBackupsetFiles(
   bs_key          IN  number)
IS
BEGIN
   IF findBackupsetFiles%ISOPEN THEN
      CLOSE findBackupsetFiles;
   END IF;
   OPEN findBackupsetFiles(bs_key);
END;
 
PROCEDURE listGetBackupsetFiles(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   FETCH findBackupsetFiles
    INTO rcvRec;
 
   IF (findBackupsetFiles%NOTFOUND) THEN
      CLOSE findBackupsetFiles;
      RAISE no_data_found;
   END IF;
END;
 
--
--
--
 
PROCEDURE translateAllBackupSet(
   backupType            IN  binary_integer
  ,tag                   IN  varchar2
  ,statusMask            IN  binary_integer
  ,completedAfter        IN  date
  ,completedBefore       IN  date
  ,onlyrdf               IN  binary_integer DEFAULT 0)
IS
BEGIN
   IF findAllBackupPiece%ISOPEN THEN
      CLOSE findAllBackupPiece;
   END IF;
   OPEN findAllBackupPiece(backupType       => backupType
                           ,tag              => tag
                           ,statusMask       => statusMask
                           ,completedAfter   => completedAfter
                           ,completedBefore  => completedBefore
                           ,onlyrdf          => onlyrdf);
END;
 
PROCEDURE getAllBackupSet(
   rcvRec OUT NOCOPY rcvRec_t)
IS
BEGIN
   FETCH findAllBackupPiece
    INTO rcvRec;
 
   IF (findAllBackupPiece%NOTFOUND) THEN
      CLOSE findAllBackupPiece;
      RAISE no_data_found;
   END IF;
END;
 
--
--
--
 
--
 
--
PROCEDURE listTranslateProxyDataFile(
   file#             IN number
  ,creation_change#  IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer
                           DEFAULT BSavailable+BSunavailable+BSexpired
  ,liststby          IN binary_integer  DEFAULT NULL
  ,pluginSCN         IN number          DEFAULT 0)
IS
   currentInc   number;
   crescn       number;
   reset_scn    number := NULL;
   reset_time   date   := NULL;
BEGIN
   deb(DEB_ENTER, 'listTranslateProxyDataFile');
   validateState(null);
 
   IF (allIncarnations = TRUE#) THEN
      currentInc := FALSE#;                     -- don't care about dbinc_key
      IF (ignoreCreationSCN = TRUE#) THEN
--
--
--
--
         crescn := NULL;
      ELSE
         crescn := creation_change#;
      END IF;
   ELSE
      currentInc := TRUE#;
      crescn     := creation_change#;
   END IF;
 
   IF (currentInc = TRUE#) THEN
      reset_scn  := this_reset_scn;
      reset_time := this_reset_time;
   END IF;
 
   IF (file# = 0) THEN
      IF (findControlfileBackup_c%ISOPEN) THEN
         CLOSE findControlfileBackup_c;
      END IF;
 
--
      deb(DEB_OPEN, 'findControlfileBackup_c');
      OPEN findControlfileBackup_c( sourcemask         => proxyCopy_con_t,
                                    currentIncarnation => currentInc,
                                    tag                => tag,
                                    pattern            => handle_pattern,
                                    completedAfter     => completedAfter,
                                    completedBefore    => completedBefore,
                                    statusMask         => statusMask,
                                    needstby           => liststby);
      listGetProxyDatafileCursor := 'findControlfileBackup_c';
   ELSE
      IF (findDatafileBackup_c%ISOPEN) THEN
         CLOSE findDatafileBackup_c;
      END IF;
 
--
      OPEN findDatafileBackup_c(sourcemask         => proxyCopy_con_t,
                                fno                => file#,
                                crescn             => crescn,
                                reset_scn          => reset_scn,
                                reset_time         => reset_time,
                                tag                => tag,
                                pattern            => handle_pattern,
                                completedAfter     => completedAfter,
                                completedBefore    => completedBefore,
                                statusMask         => statusMask,
                                pluginSCN          => pluginSCN);
      listGetProxyDatafileCursor := 'findDatafileBackup_c';
   END IF;
   deb(DEB_EXIT);
END listTranslateProxyDataFile;
 
--
PROCEDURE listGetProxyDataFile(
   rcvRec OUT NOCOPY rcvRec_t)
IS
   local rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetProxyDataFile');
 
<<nextRow>>
 
   IF (listGetProxyDatafileCursor = 'findControlfileBackup_c') THEN
      FETCH findControlfileBackup_c
       INTO local;
      IF (findControlfileBackup_c%NOTFOUND) THEN
         CLOSE findControlfileBackup_c;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSIF (listGetProxyDatafileCursor = 'findDatafileBackup_c') THEN
      FETCH findDatafileBackup_c
       INTO local;
      IF (findDatafileBackup_c%NOTFOUND) THEN
         CLOSE findDatafileBackup_c;
         deb(DEB_EXIT, 'with no more records');
         RAISE no_data_found;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
--
--
   IF (anyDevice = FALSE# AND
       isDeviceTypeAllocated(local.deviceType_con) = FALSE#) THEN
      GOTO nextRow;
   END IF;
 
   rcvRec := local;                             -- set OUT mode arg
   deb(DEB_EXIT);
END listGetProxyDataFile;
 
--
 
--
FUNCTION listGetProxyDataFile(
   xdf_key            OUT number
  ,recid              OUT number
  ,stamp              OUT number
  ,status             OUT varchar2
  ,handle             OUT varchar2
  ,completion_time    OUT date
  ,checkpoint_change# OUT number
  ,checkpoint_time    OUT date)
RETURN number IS
   rcvRec             rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetProxyDataFile815');
   listGetProxyDataFile(rcvRec);
 
   xdf_key              := rcvRec.key_con;
   recid                := rcvRec.recid_con;
   stamp                := rcvRec.stamp_con;
   status               := rcvRec.status_con;
   handle               := rcvRec.fileName_con;
   completion_time      := rcvRec.compTime_con;
   checkpoint_change#   := rcvRec.toSCN_act;
   checkpoint_time      := rcvRec.toTime_act;
   deb(DEB_EXIT, 'with: TRUE#');
   RETURN TRUE#;
EXCEPTION
   WHEN no_data_found THEN
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
END listGetProxyDataFile;
 
--
PROCEDURE listTranslateProxyArchivedLog(
   thread#           IN number
  ,sequence#         IN number
  ,first_change#     IN number
  ,tag               IN varchar2        DEFAULT NULL
  ,handle_pattern    IN varchar2        DEFAULT NULL
  ,completedAfter    IN date            DEFAULT NULL
  ,completedBefore   IN date            DEFAULT NULL
  ,statusMask        IN binary_integer  DEFAULT
                                        BSavailable+BSunavailable+BSexpired)
IS
   currentIncarnation number;
BEGIN
   deb(DEB_ENTER, 'listTranslateProxyArchivedLog');
 
   IF (allIncarnations = TRUE#) THEN
      currentIncarnation := FALSE#;             -- don't care about dbinc_key
   ELSE
      currentIncarnation := TRUE#;
   END IF;
 
   deb(DEB_OPEN, 'findArcLogBackup');
   OPEN findArcLogBackup(sourcemask         => proxyCopy_con_t,
                         currentIncarnation => currentIncarnation,
                         thread             => thread#,
                         sequence           => sequence#,
                         lowSCN             => first_change#,
                         tag                => tag,
                         pattern            => handle_pattern,
                         completedAfter     => completedAfter,
                         completedBefore    => completedBefore,
                         statusMask         => statusMask);
   deb(DEB_EXIT);
END listTranslateProxyArchivedLog;
 
--
PROCEDURE listGetProxyArchivedLog(
   rcvRec OUT NOCOPY rcvRec_t)
IS
   local rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'listGetProxyArchivedLog');
 
--
   IF (guidQualifier IS NOT NULL) THEN
      IF (findArcLogBackup%ISOPEN) THEN
         CLOSE findArcLogBackup;
      END IF;
      deb(DEB_EXIT, 'guid not valid for archivelog');
      RAISE no_data_found;
   END IF;
 
<<nextRow>>
 
   FETCH findArcLogBackup
   INTO local;
   IF (findArcLogBackup%NOTFOUND) THEN
      CLOSE findArcLogBackup;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
--
--
   IF (anyDevice = FALSE# AND
       isDeviceTypeAllocated(local.deviceType_con) = FALSE#) THEN
      GOTO nextRow;
   END IF;
 
   rcvRec := local;                             -- set OUT mode arg
   deb(DEB_EXIT);
END listGetProxyArchivedLog;
 
--
--
--
 
--
PROCEDURE listTranslateDBIncarnation(
   db_name       IN varchar2 DEFAULT NULL,
   all_databases IN number DEFAULT 0)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateDBIncarnation');
   IF (ldbi%isopen) THEN
      CLOSE ldbi;
   END IF;
   deb(DEB_OPEN, 'ldbi');
   OPEN ldbi(upper(db_name), all_databases);
   deb(DEB_EXIT);
END listTranslateDBIncarnation;
 
--
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date
  ,dbinc_status      OUT varchar2)
RETURN number
IS
BEGIN
   deb(DEB_ENTER, 'listGetDBIncarnation');
   FETCH ldbi
    INTO db_key, dbinc_key, db_name, db_id, current_inc,
         resetlogs_change#, resetlogs_time, dbinc_status;
   IF (ldbi%found) THEN
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      CLOSE ldbi;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
   END IF;
   deb(DEB_EXIT);
END listGetDBIncarnation;
 
--
FUNCTION listGetDBIncarnation(
   db_key            OUT number
  ,dbinc_key         OUT number
  ,db_name           OUT varchar2
  ,db_id             OUT number
  ,current_inc       OUT varchar2
  ,resetlogs_change# OUT number
  ,resetlogs_time    OUT date)
RETURN number
IS
  dbinc_status varchar2(9);
BEGIN
  RETURN listGetDBIncarnation(db_key, dbinc_key, db_name, db_id, current_inc,
                              resetlogs_change#, resetlogs_time, dbinc_status);
END listGetDBIncarnation;
 
 
--
--
--
 
--
PROCEDURE listTranslateDBSite(
   db_name      IN varchar2 DEFAULT NULL,
   alldbs       IN binary_integer DEFAULT 1)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateDBSite');
   IF (lnni%isopen) THEN
      CLOSE lnni;
   END IF;
   deb(DEB_OPEN, 'lnni');
   OPEN lnni(db_name, alldbs);
   deb(DEB_EXIT);
END listTranslateDBSite;
 
--
FUNCTION listGetDBSite(
   db_key            OUT number
  ,db_id             OUT number
  ,db_name           OUT varchar2
  ,db_role           OUT varchar2
  ,db_unique_name    OUT varchar2)
RETURN number
IS
BEGIN
   deb(DEB_ENTER, 'listGetDBSite');
   FETCH lnni
    INTO db_key, db_id, db_name, db_role, db_unique_name;
 
   deb(DEB_PRINT, 'site name =['||db_unique_name||']');
   IF (lnni%found) THEN
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      CLOSE lnni;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
   END IF;
   deb(DEB_EXIT);
END listGetDBSite;
 
--
--
--
 
--
PROCEDURE listRollbackSegTableSpace
IS
BEGIN
   deb(DEB_ENTER, 'listRollbackSegTableSpace');
--
   IF (lrtbs%ISOPEN) THEN
      CLOSE lrtbs;
   END IF;
 
   deb(DEB_OPEN, 'lrtbs');
   OPEN lrtbs;
--
--
   deb(DEB_EXIT);
END listRollbackSegTableSpace;
 
--
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2)
RETURN number IS
  pdbname  varchar2(128);
BEGIN
  RETURN listGetTableSpace(ts#, ts_name, pdbname);
END listGetTableSpace;
 
FUNCTION listGetTableSpace(
   ts#               OUT number
  ,ts_name           OUT varchar2
  ,pdbname          OUT varchar2)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'listGetTableSpace');
--
   FETCH lrtbs
    INTO ts#, ts_name, pdbname;
 
   IF (lrtbs%FOUND) THEN
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;
   ELSE
      CLOSE lrtbs;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;
   END IF;
--
--
   deb(DEB_EXIT);
END listGetTableSpace;
 
--
--
--
 
--
PROCEDURE getIncrementalScn(
   first        IN  boolean                  -- open the cursor if this is TRUE
  ,file#        IN  number
  ,create_scn   IN  number
  ,reset_scn    IN  number
  ,reset_time   IN  date
  ,incr_level   IN  number
  ,cumulative   IN  number
  ,rcvRec       OUT NOCOPY rcvRec_t
  ,sourcemask   IN  number    DEFAULT NULL
  ,tag          IN  varchar2  DEFAULT NULL
  ,pluginSCN    IN  number    DEFAULT 0
  ,keep         IN  boolean   DEFAULT NULL)
IS
   ilevel                number;
   local                 rcvRec_t;
   validRec              validBackupSetRec_t;
   usable_incr           rcvRec_t;
   available_fromSCN_act number;
   pdbId                 number;
   cleanSCN              number;
BEGIN
   deb(DEB_ENTER, 'getIncrementalScn');
 
   IF (incr_level not in (1,2,3,4) OR incr_level is NULL) THEN
      raise_application_error(-20270, 'invalid incremental level');
   END IF;
   IF (cumulative not in (0,1) OR cumulative is NULL) THEN
      raise_application_error(-20271, 'invalid cumulative option');
   END IF;
 
--
 
--
--
--
--
--
 
--
--
--
 
   IF (cumulative = TRUE#) THEN
      ilevel := incr_level - 1;         -- Consider only higher level backups
   ELSE
      ilevel := incr_level;
   END IF;
 
--
   IF (file# IS NOT NULL) THEN
      setDfTransClause(fno => file#);
   END IF;
 
   IF first THEN
      IF (findDatafileBackup_c%ISOPEN) THEN
         CLOSE findDatafileBackup_c;
      END IF;
 
      getDatafileBackupLast.type_con := NULL; -- clear the last backup record
 
--
      cacheBsRecTable.hint := redundantHint;
 
--
      OPEN findDatafileBackup_c(
        sourcemask      => sourcemask,
        fno             => file#,
        crescn          => create_scn,
        reset_scn       => nvl(reset_scn, this_reset_scn),
        reset_time      => nvl(reset_time, this_reset_time),
        level           => ilevel,
        statusMask      => BSavailable,
        tag             => tag,
        onlytc          => TRUE#,
        pluginSCN       => pluginSCN,
        allowCumuLevelN => TRUE#);
   END IF;
 
   IF (NOT findDatafileBackup_c%ISOPEN) THEN
      raise_application_error(-20272, 'cannot take incremental backup');
   END IF;
 
   LOOP
   <<nextRow>>
      FETCH findDatafileBackup_c
       INTO local;
 
      IF (findDatafileBackup_c%NOTFOUND) THEN
         deb(DEB_PRINT, 'closing cursor');
         CLOSE findDatafileBackup_c;
         cacheBsRecTable.hint := noHint;
         IF (file# is NOT NULL) THEN
--
            deb(DEB_EXIT, 'with: cannot take incr backup');
            raise_application_error(-20272, 'cannot take incremental backup');
         ELSE
            deb(DEB_EXIT, 'with: no data found');
            raise no_data_found;        -- no more datafile backups
         END IF;
      END IF;
 
--
--
--
--
--
      IF (keep IS NOT NULL AND                       -- NULL means 10g client
          ((local.keep_options != 0 AND NOT keep) OR -- local_keep and not keep
           (local.keep_options = 0 AND keep))) THEN  -- not local_keep and keep
         deb(DEB_PRINT, 'Keep does not match for ' || local.key_con ||
                        ' completed at ' ||
                        to_char(local.compTime_con, 'DD-MON-YY HH24:MI:SS'));
         GOTO nextRow;                          -- keep attributes do not match
      END IF;
 
      IF (available_fromSCN_act IS NULL AND
          getDatafileBackupLast.type_con IS NOT NULL AND
          getDatafileBackupLast.dfNumber_obj = local.dfNumber_obj) THEN
        deb(DEB_PRINT, 'already returned incremental scn for file# ' ||
                        local.dfNumber_obj);
        GOTO nextRow;    -- this is a duplicate of what we returned earlier
      END IF;
 
--
--
--
      IF (available_fromSCN_act IS NOT NULL AND
          (usable_incr.dfNumber_obj <> local.dfNumber_obj OR
           (usable_incr.dfNumber_obj = local.dfNumber_obj AND
            usable_incr.dfCreationSCN_obj <> local.dfCreationSCN_obj))) THEN
          deb(DEB_PRINT, 'no level 0 found for this file# ' ||
                         usable_incr.dfNumber_obj || ', creation_scn '||
                         usable_incr.dfCreationSCN_obj);
          usable_incr := NULL;
          available_fromSCN_act := NULL;
      END IF;
 
      pdbId := translatePdbFile(local.dfNumber_obj, cleanSCN);
      IF (CheckRecAction(local, pdbId, cleanSCN) = action_SKIP) THEN
        deb(DEB_PRINT, 'on orphan branch');
        GOTO nextRow;    -- this action belongs to orphan branch
      END IF;
 
      IF (usable_incr.dfNumber_obj = local.dfNumber_obj AND
          usable_incr.dfCreationSCN_obj = local.dfCreationSCN_obj AND
          local.fromSCN_act > 0 AND
          available_fromSCN_act < local.fromSCN_act) THEN
          deb(DEB_PRINT, 'overlapping incremental found for file# ' ||
                         usable_incr.dfNumber_obj || ', creation_scn '||
                         usable_incr.dfCreationSCN_obj);
          GOTO nextRow;                            -- overlapping incremental
      END IF;
 
      IF (local.type_con = backupSet_con_t) THEN
--
--
         IF (validateBackupSet(backupSetRec           => local,
                               tag                    => tag,
                               tagMatchRequired       => TRUE,
                               checkDeviceIsAllocated => FALSE,
                               availableMask          => BSavailable,
                               validRec               => validRec)
                = dbms_rcvman.UNAVAILABLE) THEN
            deb(DEB_PRINT, 'incremental is unavailable');
            GOTO nextRow; -- can't create an incr based on unavail backup
         END IF;
 
--
--
--
--
--
--
--
         IF (available_fromSCN_act IS NULL OR
             (usable_incr.dfNumber_obj = local.dfNumber_obj AND
              usable_incr.dfCreationSCN_obj = local.dfCreationSCN_obj AND
              local.toSCN_act < available_fromSCN_act)) THEN
            IF (available_fromSCN_act IS NULL) THEN
               deb(DEB_PRINT, 'available_fromSCN_act set to ' ||
                              available_fromSCN_act || ' for file# ' ||
                              local.dfNumber_obj || ', creation_scn '||
                              local.dfCreationSCN_obj);
            ELSE
               deb(DEB_PRINT, 'broken chain, available_fromSCN_act set to ' ||
                              available_fromSCN_act || ' for file ' ||
                              local.dfNumber_obj || ', creation_scn '||
                              local.dfCreationSCN_obj);
            END IF;
            usable_incr := local;
            available_fromSCN_act := local.fromSCN_act;
         END IF;
      END IF;
 
--
--
--
      IF (usable_incr.dfNumber_obj = local.dfNumber_obj AND
          usable_incr.dfCreationSCN_obj = local.dfCreationSCN_obj AND
          local.toSCN_act >= available_fromSCN_act AND
          local.fromSCN_act < available_fromSCN_act) THEN
         available_fromSCN_act := local.fromSCN_act;
         deb(DEB_PRINT, 'available_fromSCN_act moved to ' ||
                        available_fromSCN_act || ' for file# ' ||
                        local.dfNumber_obj || ', creation_scn '||
                        local.dfCreationSCN_obj);
      END IF;
 
--
--
      IF (available_fromSCN_act != usable_incr.dfCreationSCN_obj AND
          available_fromSCN_act > 0) THEN
         deb(DEB_PRINT, 'need more incrementals to validate chain');
         GOTO nextRow;
      END IF;
 
 
      If (available_fromSCN_act = usable_incr.dfCreationSCN_obj OR
          available_fromSCN_act = 0) THEN
         deb(DEB_PRINT, 'validated incremental to level 0, incremental scn=' ||
                        usable_incr.toSCN_act || 'for file ' ||
                        usable_incr.dfNumber_obj);
         rcvRec := usable_incr;
      ELSE
         rcvRec := local;
         deb(DEB_PRINT, 'using level0 proxy/copy, incremental scn=' ||
                        local.toSCN_act || ' for file ' ||
                        local.dfNumber_obj);
      END IF;
 
      getDatafileBackupLast := rcvRec;   -- remember the last record returned
 
      deb(DEB_EXIT, 'with: valid record ');
      EXIT;   -- valid record. Create Incremental based on this SCN
   END LOOP;
EXCEPTION
   WHEN others THEN
      cacheBsRecTable.hint := noHint;
      deb(DEB_PRINT, 'caught an exception during getIncrementalScn');
      deb(DEB_EXIT, substr(sqlerrm, 1, 512));
      raise;
END getIncrementalScn;
 
--
FUNCTION getIncrementalScn(
   file#        IN number
  ,create_scn   IN number
  ,reset_scn    IN number
  ,reset_time   IN date
  ,incr_level   IN number
  ,cumulative   IN number
  ,sourcemask   IN number    DEFAULT NULL
  ,tag          IN varchar2  DEFAULT NULL
  ,pluginSCN    IN number    DEFAULT 0)
RETURN number IS
  rcvRec    rcvRec_t;
BEGIN
   getIncrementalScn(
      first        => TRUE
     ,file#        => file#
     ,create_scn   => create_scn
     ,reset_scn    => reset_scn
     ,reset_time   => reset_time
     ,incr_level   => incr_level
     ,cumulative   => cumulative
     ,rcvRec       => rcvRec
     ,sourcemask   => sourcemask
     ,tag          => tag
     ,pluginSCN    => pluginSCN);
 
   IF (findDatafileBackup_c%ISOPEN) THEN
      CLOSE findDatafileBackup_c; -- close the one opened in getIncrementalScn
   END IF;
 
   RETURN rcvRec.toSCN_act;
END getIncrementalScn;
 
--
--
--
 
--
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number
  ,availableMask        IN binary_integer
  ,fullBackups          IN number DEFAULT NULL)
IS
BEGIN
   deb(DEB_ENTER, 'setComputeRecoveryActionMasks');
   IF (allRecords = FALSE# AND fullBackups IS NULL) THEN
      computeRA_fullBackups := 1;
   ELSE
      computeRA_fullBackups := fullBackups;
   END IF;
   getRA_containerMask      := containerMask;
   getRA_actionMask         := actionMask;
   computeRA_allRecords     := allRecords;
   computeRA_availableMask  := availableMask;
 
--
--
--
--
   IF (restoreSource IS NULL) THEN
      restoreSource := proxyCopy_con_t + imageCopy_con_t + backupSet_con_t;
 
      IF (bitand(getRA_containerMask, proxyCopy_con_t) = 0) THEN
         restoreSource := restoreSource - proxyCopy_con_t;
      END IF;
      IF (bitand(getRA_containerMask, imageCopy_con_t) = 0) THEN
         restoreSource := restoreSource - imageCopy_con_t;
      END IF;
      IF (bitand(getRA_containerMask, backupSet_con_t) = 0) THEn
         restoreSource := restoreSource - backupSet_con_t;
      END IF;
 
      IF (restoreSource = 0) THEN
         restoreSource := NULL;
      END IF;
   END IF;
 
   deb(DEB_EXIT);
END setComputeRecoveryActionMasks;
 
--
--
PROCEDURE setComputeRecoveryActionMasks(
   containerMask        IN number
  ,actionMask           IN number
  ,allRecords           IN number)
IS
BEGIN
   deb(DEB_ENTER, 'setComputeRecoveryActionMasks816');
   setComputeRecoveryActionMasks(
      containerMask  => containerMask,
      actionMask     => actionMask,
      allRecords     => allRecords,
      availableMask  => dbms_rcvman.BSavailable,
      fullBackups    => to_number(null));
   deb(DEB_EXIT);
END setComputeRecoveryActionMasks;
 
--
--
PROCEDURE setRAflags(
   kindMask    IN number
  ,allRecords  IN boolean)
IS
   containerMask        number;
   actionMask           number;
   allRecs              number;
BEGIN
   deb(DEB_ENTER, 'setRAflags');
 
--
 
   containerMask := 0;
 
   IF (bitand(kindMask, implicitOfflRange + cleanRange + applyOfflRange) > 0)
   THEN
      containerMask := containerMask + offlineRangeRec_con_t;
   END IF;
 
   IF (bitand(kindMask, dfCopy) > 0) THEN
      containerMask := containerMask + imageCopy_con_t;
   END IF;
 
   IF (bitand(kindMask, buSet + applyIncremental) > 0) THEN
      containerMask := containerMask + backupSet_con_t;
   END IF;
 
   IF (bitand(kindMask, proxyFull) > 0) THEN
      containerMask := containerMask + proxyCopy_con_t;
   END IF;
 
--
 
   actionMask := 0;
 
   IF (bitand(kindMask, dfCopy + ProxyFull + buSet) > 0) THEN
      actionMask := actionMask + full_act_t;
   END IF;
 
   IF (bitand(kindMask, applyIncremental) > 0) THEN
      actionMask := actionMask + incremental_act_t;
   END IF;
 
   IF (bitand(kindMask, redo) > 0) THEN
      actionMask := actionMask + redo_act_t;
   END IF;
 
   IF (bitand(kindMask, implicitOfflRange) > 0) THEN
      actionMask := actionMask + implicitRange_act_t;
   END IF;
 
   IF (bitand(kindMask, cleanRange) > 0) THEN
      actionMask := actionMask + cleanRange_act_t;
   END IF;
 
   IF (bitand(kindMask, applyOfflRange) > 0) THEN
      actionMask := actionMask + offlineRange_act_t;
   END IF;
 
   IF (allRecords) THEN
      allRecs := TRUE#;
   ELSE
      allRecs := FALSE#;
   END IF;
 
   deb(DEB_PRINT, 'setRAflags kindMask=' || to_char(kindMask) ||
       ' containerMask=' || to_char(containerMask) ||
       ' actionMask=' || to_char(actionMask));
 
   setComputeRecoveryActionMasks(containerMask, actionMask, allRecs);
   deb(DEB_EXIT);
END setRAflags;
 
--
FUNCTION getRecoveryAction(
   action OUT NOCOPY rcvRec_t)
RETURN binary_integer IS
   redoAction rcvRec_t;
   local      rcvRec_t;
   top        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getRecoveryAction');
<<getNext>>
   IF (rcvRecStack.count = 0) THEN
--
--
--
--
--
--
--
--
--
--
--
      deb(DEB_EXIT, 'with no more records');
      raise no_data_found;
   END IF;
 
   rcvRecPop(local);
 
--
   IF (not isValidAction(local)) THEN
     IF (debug) THEN
       printRcvRec(local);
     END IF;
     goto getNext;
   END IF;
 
<<merge_actions>>
   IF (rcvRecStack.count > 0) THEN
--
--
--
      rcvRecTop(top);
      IF (local.type_act = redo_act_t AND
          top.type_act = redo_act_t) THEN
--
--
--
         redoAction := local;
         rcvRecPop(local);
         local.fromSCN_act := redoAction.fromSCN_act;
         GOTO merge_actions;
      END IF;
      action := local;
      rcvRec_last := local;
      deb(DEB_EXIT, 'with: TRUE#');
      RETURN TRUE#;                     -- more actions to return yet
   ELSE
      action := local;
      rcvRec_last := local;
      deb(DEB_EXIT, 'with: FALSE#');
      RETURN FALSE#;                    -- this is the last action
   END IF;
 
END getRecoveryAction;
 
--
 
--
FUNCTION getRecoveryAction(
   kind       OUT number
  ,set_stamp  OUT number
  ,set_count  OUT number
  ,recid      OUT number
  ,stamp      OUT number
  ,fname      OUT varchar2
  ,blocksize  OUT number
  ,blocks     OUT number
  ,devtype    OUT varchar2
  ,from_scn   OUT number
  ,to_scn     OUT number
  ,to_time    OUT date
  ,rlgscn     OUT number
  ,rlgtime    OUT date
  ,cfcretime  OUT date
  ,dbinc_key  OUT number)
RETURN binary_integer IS
   rcvRec     rcvRec_t;
   rc         binary_integer;
BEGIN
   deb(DEB_ENTER, 'getRecoveryAction815');
   rc := getRecoveryAction(rcvRec);
 
   IF (rcvRec.type_con = offlineRangeRec_con_t) THEN
      IF (rcvRec.type_act = offlineRange_act_t) THEN
         kind := applyOfflRange;
      ELSIF (rcvRec.type_act = cleanRange_act_t) THEN
         kind := cleanRange;
      ELSIF (rcvRec.type_act = implicitRange_act_t) THEN
         kind := implicitOfflRange;
      ELSE
         deb(DEB_PRINT, 'cannot convert type_con=' || to_char(rcvRec.type_con) ||
             ' type_act=' || to_char(rcvRec.type_act) ||
             ' to recovery action kind');
         deb(DEB_EXIT, 'with error 20999');
         raise_application_error(-20999, 'internal error: getRecoveryAction');
      END IF;
   ELSIF (rcvRec.type_con = backupSet_con_t) THEN
      IF (rcvRec.type_act = full_act_t) THEN
         kind := buSet;
      ELSE
         kind := applyIncremental;
      END IF;
   ELSIF (rcvRec.type_con = proxyCopy_con_t) THEN
      kind := proxyFull;
   ELSIF (rcvRec.type_con = imageCopy_con_t) THEN
      kind := dfCopy;
   ELSIF (rcvRec.type_con IS NULL) THEN
      IF (rcvRec.type_act = redo_act_t) THEN
         kind := redo;
      END IF;
   END IF;
 
   deb(DEB_PRINT, 'getRecoveryAction: kind=' || nvl(to_char(kind), 'null'));
   rcvRecConvert(rcvRec);                       -- get rid of nulls
   IF (debug) THEN
      printRcvRec(rcvRec);
   END IF;
 
   set_stamp := rcvRec.setStamp_con;
   set_count := rcvRec.setCount_con;
   IF (rcvRec.type_con = backupSet_con_t) THEN
      recid     := rcvRec.bsRecid_con;
      stamp     := rcvRec.bsStamp_con;
   ELSE
      recid     := rcvRec.recid_con;
      stamp     := rcvRec.stamp_con;
   END IF;
   fname     := rcvRec.fileName_con;
   blocksize := rcvRec.blockSize_con;
   blocks    := rcvRec.blocks_con;
   devtype   := rcvRec.deviceType_con;
   from_scn  := rcvRec.fromSCN_act;
   to_scn    := rcvRec.toSCN_act;
   to_time   := rcvRec.toTime_act;              -- null OK
   rlgscn    := rcvRec.rlgSCN_act;
   rlgtime   := rcvRec.rlgTime_act;
   cfcretime := rcvRec.cfCreationTime_con;      -- null OK
   dbinc_key := rcvRec.dbincKey_act;            -- null OK
 
   deb(DEB_EXIT, 'with: '||to_char(rc));
   RETURN rc;
END;
 
--
PROCEDURE printRecoveryActions
IS
   action rcvRec_t;
   rc     number;
BEGIN
   IF (not debug) THEN
      return;
   END IF;
 
   deb(DEB_PRINT, '===== ' || to_char(rcvRecStack.count) ||
       ' actions stacked =====');
 
   IF (rcvRecStack.count = 0) THEN
      return;
   END IF;
 
   LOOP
      rc := getRecoveryAction(action);
      printRcvRec(action);
      EXIT WHEN rc = FALSE#;
   END LOOP;
END printRecoveryActions;
 
--
PROCEDURE trimRecoveryActions(
   maxActions           IN number
  ,containerMask        IN number
  ,actionMask           IN number)
IS
   n                    number;
BEGIN
   deb(DEB_ENTER, 'trimRecoveryActions[procedure]');
   n := trimRecoveryActions(maxActions, containerMask, actionMask);
   deb(DEB_PRINT, 'trimRecoveryActions[procedure] returned '||n);
   deb(DEB_EXIT);
END trimRecoveryActions;
 
--
--
--
 
--
PROCEDURE reportTranslateDFDel
IS
BEGIN
   deb(DEB_ENTER, 'reportTranslateDFDel');
   IF (rddf%isopen) THEN
      CLOSE rddf;
   END IF;
   deb(DEB_OPEN, 'rddf');
   OPEN rddf;
   deb(DEB_EXIT);
END reportTranslateDFDel;
 
--
 
--
FUNCTION reportGetDFDel(
   file#               OUT number
  ,filetype            OUT number
  ,checkpoint_change#  OUT number
  ,checkpoint_time     OUT date
  ,resetlogs_change#   OUT number
  ,resetlogs_time      OUT date
  ,incremental_change# OUT number
  ,fuzzy_change#       OUT number
  ,recid               OUT number
  ,stamp               OUT number
  ,fname               OUT varchar2
  ,restorable          OUT number)
RETURN number IS
   rc              number;
   mytype          number;
   key             number;
   completion_time date;
BEGIN
   deb(DEB_ENTER, 'reportGetDFDel80');
   <<get_next>>
   rc := reportGetDFDel( file#
                        ,mytype
                        ,checkpoint_change#
                        ,checkpoint_time
                        ,resetlogs_change#
                        ,resetlogs_time
                        ,incremental_change#
                        ,fuzzy_change#
                        ,recid
                        ,stamp
                        ,fname
                        ,restorable
                        ,key
                        ,completion_time);
   IF (rc = TRUE#) THEN
      IF (mytype = PROXY) THEN
         GOTO get_next;
      END IF;
      filetype := mytype;
   END IF;
   deb(DEB_EXIT, 'with: '||to_char(rc));
   RETURN rc;
END reportGetDFDel;
 
--
--
--
--
PROCEDURE getConfig(
   conf#          OUT    number
  ,name           IN OUT varchar2
  ,value          IN OUT varchar2
  ,first          IN     boolean)
IS
   eof          boolean := FALSE;
   conf_exist   number  := 0;
   primary_db_unique_name varchar2(512); /* node.db_unique_name%TYPE */
BEGIN
 
   IF (first) THEN
      IF (findConfig_c%ISOPEN) THEN
         CLOSE findConfig_c;
      END IF;
 
      OPEN cntConfig_c;
      FETCH cntConfig_c INTO conf_exist;
      CLOSE cntConfig_c;
      IF conf_exist > 0 THEN
         IF user_db_unique_name is not null THEN
            deb(DEB_PRINT, 'getConfig: configurations exists for user site');
            OPEN findConfig_c(name, value, user_db_unique_name);
         ELSE
            deb(DEB_PRINT, 'getConfig: configurations exists for this site');
            OPEN findConfig_c(name, value, this_db_unique_name);
         END IF;
      ELSE
         OPEN getPrimarySite_c;
         FETCH getPrimarySite_c INTO primary_db_unique_name;
         IF getPrimarySite_c%NOTFOUND THEN
            deb(DEB_PRINT, 'getConfig: no/multiple primary/site conf');
            OPEN findConfig_c(name, value, NULL);
         ELSE
            deb(DEB_PRINT, 'getConfig: using primary configurations');
            OPEN findConfig_c(name, value, primary_db_unique_name);
         END IF;
         CLOSE getPrimarySite_c;
      END IF;
   END IF;
 
   FETCH findConfig_c INTO conf#, name, value;
 
   IF (findConfig_c%NOTFOUND) THEN
      eof := TRUE;
      CLOSE findConfig_c;
   END IF;
 
   IF (eof) THEN                                --- if end of fetch
     RAISE no_data_found;
   END IF;
 
END getConfig;
 
--
--
--
--
 
PROCEDURE bmrAddCorruptTable(
   dfnumber    OUT number
  ,blknumber   OUT number
  ,range       OUT number
  ,first       IN  boolean)
IS
   eof    boolean := FALSE;
BEGIN
 
   IF (first) THEN
      IF (translateDatabaseCorruption_c%ISOPEN) THEN
         CLOSE translateDatabaseCorruption_c;
      END IF;
      OPEN translateDatabaseCorruption_c(dfnumber => NULL);
   END IF;
 
   FETCH translateDatabaseCorruption_c INTO dfnumber, blknumber, range;
 
   IF (translateDatabaseCorruption_c%NOTFOUND) THEN
      eof := TRUE;
      CLOSE translateDatabaseCorruption_c;
   END IF;
 
   IF (eof) THEN                                --- if end of fetch
     RAISE no_data_found;
   END IF;
 
END bmrAddCorruptTable;
 
--
 
--
--
--
 
--
--
 
--
FUNCTION getPackageVersion
RETURN varchar2 IS
BEGIN
   deb(DEB_ENTER, 'getPackageVersion');
   IF (versionCounter > versionMaxIndex) THEN
      versionCounter := 1;
      deb(DEB_EXIT, 'with: NULL');
      RETURN NULL;
   END IF;
   versionCounter := versionCounter + 1;
   deb(DEB_EXIT, 'with: '||versionList(versionCounter - 1));
   RETURN versionList(versionCounter - 1);
END getPackageVersion;
 
FUNCTION isStatusMatch(status      IN VARCHAR2,
                       mask        IN NUMBER) RETURN NUMBER IS
BEGIN
--
--
--
--
   IF (bitand(mask, BSavailable)     != 0 AND status = 'A') OR
      (bitand(mask, BSunavailable)   != 0 AND status = 'U') OR
      (bitand(mask, BSdeleted)       != 0 AND status = 'D') OR
      (bitand(mask, BSexpired)       != 0 AND status = 'X') THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isStatusMatch;
 
--
FUNCTION isBackupTypeMatch(btype       IN VARCHAR2,
                           mask        IN binary_integer) RETURN NUMBER IS
BEGIN
   IF (bitand(mask, BSdatafile_full) !=0  AND  btype = 'D') OR
      (bitand(mask, BSdatafile_incr) !=0  AND  btype = 'I') OR
      (bitand(mask, BSarchivelog)    !=0  AND  btype = 'L') THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isBackupTypeMatch;
 
--
PROCEDURE setRcvRecBackupAge(age IN number)
IS
BEGIN
   rcvRecBackupAge := age;
   deb(DEB_PRINT, 'rcvRecBackupAge= '  || rcvRecBackupAge);
   resetthisBackupAge;
END setRcvRecBackupAge;
 
--
PROCEDURE resetthisBackupAge
IS
BEGIN
   thisBackupAge := 0;
   deb(DEB_PRINT, 'thisBackupAge= '  || thisBackupAge);
END resetthisBackupAge;
 
--
PROCEDURE printLbRec(
   lbRec IN lbRec_t)
IS
BEGIN
 
  deb(DEB_ENTER, 'printLbRec');
  deb(DEB_IN, 'fetch backup_type:  '||lbRec.backup_type);
  deb(DEB_IN, '      file_type:    '||lbRec.file_type);
  deb(DEB_IN, '      pkey:         '||lbRec.pkey);
  deb(DEB_IN, '      recid:        '||lbRec.recid);
  deb(DEB_IN, '      stamp:        '||lbRec.stamp);
  deb(DEB_IN, '      is_rdf:       '||lbRec.is_rdf);
  IF (lbRec.file_type = datafile_txt)
  THEN
    deb(DEB_IN, '      df_file#:     '||lbRec.df_file#);
    deb(DEB_IN, '      df_ts#:       '||lbRec.df_ts#);
    deb(DEB_IN, '      df_plugin_change#: '||lbRec.df_plugin_change#);
    deb(DEB_IN, '      df_foreidn_dbid:   '||lbRec.df_foreign_dbid);
    deb(DEB_IN, '      df_creation_change#:'||lbRec.df_creation_change#);
    deb(DEB_IN, '      df_checkpoint_change#:'||lbRec.df_checkpoint_change#);
    deb(DEB_IN, '      df_incremental_change#:'||
                       nvl(to_char(lbRec.df_incremental_change#), 'NULL'));
  END IF;
  IF (lbRec.file_type = archivedlog_txt)
  THEN
    deb(DEB_IN, '      rl_thread#:   '||lbRec.rl_thread#);
    deb(DEB_IN, '      rl_sequence#: '||lbRec.rl_sequence#);
    deb(DEB_IN, '      rl_next_change#:'||lbRec.rl_next_change#);
  END IF;
  IF (lbRec.backup_type = backupset_txt)
  THEN
    deb(DEB_IN, '      bs_key:       '||lbRec.bs_key);
    deb(DEB_IN, '      bs_stamp:     '||lbRec.bs_stamp);
    deb(DEB_IN, '      bs_count:     '||lbRec.bs_count);
    deb(DEB_IN, '      bs_incr_type: '||lbRec.bs_incr_type);
  END IF;
  IF (lbRec.file_type = piece_txt)
  THEN
    deb(DEB_IN, '      bp_piece#:    '||lbRec.bp_piece#);
    deb(DEB_IN, '      bp_copy#:     '||lbRec.bp_copy#);
    deb(DEB_IN, '      status:       '||lbRec.status);
    deb(DEB_IN, '      device_type:  '||lbRec.device_type);
    deb(DEB_IN, '      tag:          '||lbRec.tag);
  END IF;
  deb(DEB_EXIT, 'ok');
 
EXCEPTION
  WHEN OTHERS THEN
    deb(DEB_EXIT, 'with exception: '||substr(sqlerrm, 1, 512));
    RETURN;
END printLbRec;
 
--
--
FUNCTION listBackupInMKS(lbDfRecTabUs      IN lbDfRecTab_t
                        ,lbRec             IN lbRec_t
                        ,maxDfNumber       IN number
                        ,forIncr           IN boolean)
RETURN BOOLEAN IS
   i          number;
   min_scn    number;
   min_rlgscn number;
BEGIN
--
--
--
   i := lbRec.df_file#;
   <<loop_dfRecTab>>
   LOOP
      IF (NOT lbDfRecTabUs.exists(i)) THEN
         deb(DEB_PRINT,'Dropped datafile: df_file#=' || lbRec.df_file#);
         IF (lbRec.df_ckp_mod_time < untilTime OR
             (untilTime IS NULL AND
              lbRec.df_checkpoint_change# <= untilSCN)) THEN
            deb(DEB_PRINT,'Outside untilTime/untilSCN');
            RETURN FALSE;
         ELSE
            deb(DEB_PRINT,'Inside untilTime/untilSCN');
            RETURN TRUE;
         END IF;
      END IF;
      IF (lbDfRecTabUs(i).dfRec.dfNumber = lbRec.df_file# AND
          (lbRec.df_file# = 0 OR
           lbDfRecTabUs(i).dfRec.dfCreationSCN =
              lbRec.df_creation_change#)) THEN
         IF (forIncr) THEN
            min_scn    := lbDfRecTabUs(i).incrmin_scn;
            min_rlgscn := lbDfRecTabUs(i).incrmin_rlgscn;
         ELSE
            min_scn    := lbDfRecTabUs(i).fullmin_scn;
            min_rlgscn := lbDfRecTabUs(i).fullmin_rlgscn;
         END IF;
 
         IF (min_scn < lbRec.df_checkpoint_change# AND
             (min_rlgscn IS NULL                      OR
              min_rlgscn = lbRec.df_resetlogs_change# OR
              min_scn <= lbRec.df_resetlogs_change#)) THEN
            RETURN TRUE;
         ELSE
            RETURN FALSE;
         END IF;
      END IF;
      i := i + maxDfNumber;
   END LOOP;
 
   RETURN FALSE;
END listBackupInMKS;
 
--
PROCEDURE listBackupProcessPiece(lbRec         IN            lbRec_t
                                ,lbRecOut      OUT    NOCOPY lbRec_t
                                ,lbState       IN OUT NOCOPY lbState_t)
IS
BEGIN
  IF (debug) THEN -- protect for performance
     deb(DEB_ENTER, 'listBackupProcessPiece');
  END IF;
--
--
--
--
--
--
  IF (anyDevice = TRUE# OR isDeviceTypeAllocated(lbRec.device_type) = TRUE#)
  THEN
    IF (recoveryDestFile AND lbRec.is_rdf = 'NO')
    OR (orsAnyFile AND lbRec.bp_ba_access IN ('U','D'))
    OR ((orsLocalFile OR orsLibKey IS NOT NULL) AND
        (lbRec.bp_ba_access IN ('U','D') OR
         nvl(lbRec.bp_lib_key, 0) != nvl(orsLibKey, 0)))
    THEN
      IF (debug) THEN -- protect for performance
        deb(DEB_IN, 'file_type: ' || lbRec.file_type ||
                    ' not a recovery area or ors file pkey: ' || lbRec.pkey);
      END IF;
    ELSE
--
       IF (lbRec.bp_copy# > lbState.lbCopyCount)
       THEN
         lbState.lbCopyCount := lbRec.bp_copy#;
       END IF;
--
--
       BEGIN
         lbState.lbPieceCountTab(lbRec.bp_copy#-1) :=
                 lbState.lbPieceCountTab(lbRec.bp_copy#-1) + 1;
       EXCEPTION
         WHEN no_data_found THEN   -- lbPieceCountTab(i) uninitialized
           lbState.lbPieceCountTab(lbRec.bp_copy#-1) := 1;
--
--
           lbState.lbRecCmn.bs_copies := lbState.lbRecCmn.bs_copies + 1;
       END;
 
--
--
       IF (lbState.lbRecCmn.bs_status is NULL)
       THEN
         lbState.lbRecCmn.bs_status := lbRec.status;
       ELSIF (lbRec.status <> lbState.lbRecCmn.bs_status)
       THEN
--
--
         lbState.lbRecCmn.bs_status := other_txt;
       END IF;
 
--
--
--
--
       lbState.lbRecCmn.bs_bytes := lbState.lbRecCmn.bs_bytes +
                                    lbRec.bytes;
 
--
--
       IF (lbState.lbRecCmn.bs_device_type is NULL)
       THEN
         lbState.lbRecCmn.bs_device_type := lbRec.device_type;
       ELSIF (instr(lbState.lbRecCmn.bs_device_type, lbRec.device_type) = 0)
       THEN
         BEGIN
            lbState.lbRecCmn.bs_device_type :=
               lbState.lbRecCmn.bs_device_type||','||lbRec.device_type;
         EXCEPTION
            WHEN value_error THEN
               deb(DEB_IN, 'dev buffer overflow length=' ||
                   lengthb(lbState.lbRecCmn.bs_device_type));
         END;
       END IF;
 
--
--
       IF (lbState.lbRecCmn.bs_compressed is NULL)
       THEN
         lbState.lbRecCmn.bs_compressed := lbRec.compressed;
       ELSIF (lbState.lbRecCmn.bs_compressed != lbRec.compressed)
       THEN
          lbState.lbRecCmn.bs_compressed := '###';
       END IF;
 
--
--
       IF (lbRec.tag IS NOT NULL) THEN
         IF (lbState.lbRecCmn.bs_tag is NULL) THEN
           lbState.lbRecCmn.bs_tag := lbRec.tag;
         ELSIF (instr(lbState.lbRecCmn.bs_tag, lbRec.tag) = 0) THEN
           BEGIN
              lbState.lbRecCmn.bs_tag :=
                 lbState.lbRecCmn.bs_tag||','||lbRec.tag;
           EXCEPTION
              WHEN value_error THEN
                 deb(DEB_IN, 'tag buffer overflow length=' ||
                     lengthb(lbState.lbRecCmn.bs_tag));
           eND;
         END IF;
       END IF;
    END IF;
  ELSE
    IF (debug) THEN
      deb(DEB_IN, 'device type not allocated');
    END IF;
  END IF;
 
  IF (debug) THEN  -- protect for performance
     deb(DEB_EXIT, 'OK');
  END IF;
END listBackupProcessPiece;
 
PROCEDURE setNeedObsoleteData(NeedObsoleteData IN boolean DEFAULT TRUE) IS
BEGIN
  IF NeedObsoleteData THEN
     lb_NeedObsoleteData := TRUE#;
  ELSE
     lb_NeedObsoleteData := FALSE#;
  END IF;
END;
 
--
FUNCTION listBackup(lbRecOut      OUT    NOCOPY lbRec_t
                   ,firstCall     IN     boolean
                   ,only_obsolete IN     boolean
                   ,redundancy    IN     number
                   ,piped_call    IN     boolean  -- not called by RMAN client
                   ,lbCursor      IN OUT NOCOPY lbCursor_t
                   ,lbState       IN OUT NOCOPY lbState_t
                   ,extRlKeepSCN  IN     number DEFAULT NULL)
RETURN boolean IS
  lbRec                lbRec_t;
  null_lbRec           lbRec_t := NULL;
  i                    binary_integer;
  j                    binary_integer;
  tmp                  binary_integer;
  rc                   binary_integer;
  found                boolean;
  lbCursor_notfound    boolean := FALSE;
  numBackups           number;
  oldest_flashback_scn number;
  fullBackups          number;
  actionMask           number;
  containerMask        number;
 
--
  full_df_backup       boolean;
  incr_df_backup       boolean;
  arc_log_backup       boolean;
  keep                 varchar2(3);
  keep_until           date;
 
--
  save_dbinc_key       number;
  save_reset_scn       number;
  dfRec                dfRec_t;
  rcvRecNxt            rcvRec_t;
  rcvRec               rcvRec_t;
  rcvRecStack_count    binary_integer;
  extendMask           binary_integer;
BEGIN
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
 
  IF (debug) THEN -- protect for performance
     deb(DEB_ENTER, 'listBackup');
  END IF;
 
--
  lbRecOut := NULL;
 
  IF (firstCall)
  THEN
    IF (debug) THEN -- protect for performance
       deb(DEB_IN, 'FIRST');
    END IF;
 
--
    validateState(NULL);
 
--
    setAllIncarnations(TRUE);
 
--
--
--
--
    setCanApplyAnyRedo(TRUE);
 
    setCanHandleTransportableTbs(TRUE);
 
--
    cacheBsRecTable.hint := redundantHint;
 
--
    lbState.lbRecOutTab.delete;
    lbState.lbRecOutTab_count := 0;
 
--
    lbState.lbRecTmpTab.delete;
 
--
--
    lbState.lbDfRecTabUs.delete;
 
--
    lbState.lbDfRecTab.delete;
 
--
--
--
    lbState.lbPieceCountTab.delete;
    lbState.lbCopyCount       := 0;
 
--
    lbState.lbMkTab.delete;
 
--
    lbState.lbMkITab.delete;
 
--
--
    SELECT SYSDATE INTO lbState.lbNowTime from dual;
 
--
--
--
--
--
--
--
    dfRec.dfNumber      := 0;
    dfRec.dfCreationSCN := 0;
    dfRec.inBackup      := 1;
    dfRec.noBackupPdb   := 0;
    dfRec.foreignDbid   := 0;
    dfRec.pluggedRonly  := 0;
    dfRec.pluginSCN     := 0;
 
    lbState.lbDfRecTabUs(0).dfRec          := dfRec;
    lbState.lbDfRecTabUs(0).fullmin_scn    := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).fullmin_rlgscn := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).incrmin_scn    := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).incrmin_rlgscn := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).logmin_scn     := MAXSCNVAL;
    lbState.lbDfRecTabUs(0).logmin_rlgscn  := MAXSCNVAL;
 
    IF lb_NeedObsoleteData = TRUE# THEN
      lbState.lbNeedObsoleteData  := TRUE;
    ELSE
      lbState.lbNeedObsoleteData  := FALSE;
      deb(DEB_PRINT,'listBackup:caller not interested in Obsolete Data');
    END IF;
--
    save_dbinc_key := this_dbinc_key;
    save_reset_scn := this_reset_scn;
--
    lbState.lbMaxDfNumber := getMaxDfNumber;
    <<loop_travelinc>>
    LOOP
      translateDatabase(TRUE#);
      <<loop_genDfRecTab>>
      LOOP
        BEGIN
          getDatafile(dfRec);
        EXCEPTION
          WHEN no_data_found THEN EXIT loop_genDfRecTab;
        END;
--
--
--
--
--
        j := dfRec.dfNumber;
        <<loop_scanDfRecTab>>
        LOOP
          BEGIN
--
--
--
--
--
            IF (lbState.lbDfRecTabUs(j).dfRec.dfNumber = 0)
            THEN
              RAISE no_data_found;
            END IF;
            IF (dfRec.dfNumber =
                   lbState.lbDfRecTabUs(j).dfRec.dfNumber  AND
                dfRec.dfCreationSCN =
                   lbState.lbDfRecTabUs(j).dfRec.dfCreationSCN)
            THEN
--
              EXIT loop_scanDfRecTab;
            ELSE
--
--
              j := j + lbState.lbMaxDfNumber;
            END IF;
          EXCEPTION
            WHEN no_data_found
            THEN
              lbState.lbDfRecTabUs(j).dfRec          := dfRec;
              lbState.lbDfRecTabUs(j).fullmin_scn    := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).fullmin_rlgscn := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).logmin_scn     := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).logmin_rlgscn  := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).incrmin_scn    := MAXSCNVAL;
              lbState.lbDfRecTabUs(j).incrmin_rlgscn := MAXSCNVAL;
          END;
        END LOOP;
      END LOOP;
--
--
--
--
      IF (untilSCN IS NOT NULL AND untilSCN < this_reset_scn)
      THEN
        rc := getParentIncarnation(this_dbinc_key, this_reset_scn);
        EXIT loop_travelinc WHEN rc = FALSE#;
      ELSE
        EXIT loop_travelinc;
      END IF;
    END LOOP;
--
    this_dbinc_key := save_dbinc_key;
    this_reset_scn := save_reset_scn;
 
--
    getFlashbackInfo(lbState.lbFbUntilTime, lbState.lbMinGrsp);
    IF (debug) THEN
       deb(DEB_IN, 'lbFbUntilTime= ' || to_char(lbState.lbFbUntilTime) ||
                   ' lbMinGrsp=' || to_char(lbState.lbMinGrsp));
    END IF;
 
    lbState.lbRlKeepRlgSCN  := MAXSCNVAL;
    lbState.lbRlKeepSCN     := MAXSCNVAL;
    IF (extRlKeepSCN IS NOT NULL) THEN
       lbState.lbRlKeepSCN     := extRlKeepSCN;
       lbState.lbRlKeepRlgSCN  := getPointInTimeInc(extRlKeepSCN);
       IF (debug) THEN
           deb(DEB_IN, 'Extending lbRlKeepSCN for external keepscn to '||
               to_char(lbState.lbRlKeepSCN));
           deb(DEB_IN, 'Extending lbRlKeepRlgSCN for external keepscn to '||
               to_char(lbState.lbRlKeepRlgSCN));
       END IF;
    END IF;
 
    IF (this_baseline_cap >= 0) THEN
       this_baseline_cap_scn := untilSCN;
       deb(DEB_IN, 'baseline_cap_scn = ' || this_baseline_cap_scn);
--
--
--
       resetUntil;
--
--
       setDeviceType('SBT_TAPE');
       containerMask := backupSet_con_t +
                        imageCopy_con_t +
                        offlineRangeRec_con_t;
    ELSE
       containerMask := backupSet_con_t +
                        proxyCopy_con_t +
                        imageCopy_con_t +
                        offlineRangeRec_con_t;
    END IF;
 
--
--
--
    actionMask := full_act_t + offlineRange_act_t + implicitRange_act_t +
                  cleanRange_act_t;
    IF (untilTime IS NOT NULL OR untilSCN IS NOT NULL) THEN
       actionMask := actionMask + incremental_act_t;
    END IF;
 
--
--
--
    setComputeRecoveryActionMasks(containerMask   => containerMask,
                                  actionMask      => actionMask,
                                  allRecords      => TRUE#,
                                  availableMask   => BSavailable,
                                  fullBackups     => redundancy);
 
--
--
--
    setCraGetAllCfBackups(TRUE);
 
--
--
--
--
    IF NOT (lbState.lbNeedObsoleteData OR this_baseline_cap >= 0) THEN
      goto ObsoleteDataSkip;
    END IF;
 
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
--
    i := to_number(null);
    LOOP
      IF (i is null) THEN
         i := lbState.lbDfRecTabUs.first;
      ELSE
         i := lbState.lbDfRecTabUs.next(i);
      END IF;
      EXIT WHEN i IS NULL;
      dfRec := lbState.lbDfRecTabUs(i).dfRec;
 
      IF (this_baseline_cap >= 0) AND 
         NOT setLocalOrsSiteKey(db_id => NULL) THEN
         deb(DEB_IN, 'local ORS site_key not set, no backups yet recieved');
      ELSE
--
--
--
--
--
--
--
         rc := computeRecoveryActions(
                                   fno           => dfRec.dfNumber,
                                   crescn        => dfRec.dfCreationSCN,
                                   allowfuzzy    => FALSE,
                                   partial_rcv   => FALSE,
                                   allCopies     => FALSE,
                                   cleanscn      => dfRec.stopSCN,
                                   clean2scn     => highscnval,
                                   clean2time    => lbState.lbNowTime,
                                   onlscn        => dfRec.dfOnlineSCN,
                                   offlscn       => dfRec.dfOfflineSCN,
                                   onltime       => dfRec.dfOnlineTime,
                                   rmanCmd       => obsoleteCmd_t,
                                   foreignDbid   => dfRec.foreignDbid,
                                   pluggedRonly  => dfRec.pluggedRonly,
                                   pluginSCN     => dfRec.pluginSCN,
                                   pluginRlgSCN  => dfRec.pluginRlgSCN,
                                   pluginRlgTime => dfRec.pluginRlgTime,
                                   creation_thread  => dfRec.creation_thread,
                                   creation_size    => dfRec.creation_size,
                                   pdbId            => dfRec.pdbId,
                                   pdbForeignDbid   => dfRec.pdbForeignDbid);
      END IF;
 
      IF (this_baseline_cap >= 0) THEN
         deb(DEB_IN, 'Found a new datafile ' || dfRec.dfNumber);
         lbRec.df_file#            := dfRec.dfNumber;
         lbRec.df_ts#              := dfRec.tsNumber;
         lbRec.df_plugin_change#   := dfRec.pluginSCN;
         lbRec.df_foreign_dbid     := dfRec.foreignDbid;
         lbRec.df_tablespace       := dfRec.tsName;
         lbRec.df_creation_change# := dfRec.dfCreationSCN;
 
         lbRec.file_type             := NULL;
         lbRec.backup_type           := NULL;
         lbRec.bs_key                := NULL;
         lbRec.df_checkpoint_change# := NULL;
      END IF;
 
      numBackups := 0;
      fullBackups := getRecFullCount;
      LOOP
        EXIT WHEN (getRecStackCount = 0 OR
                   (this_baseline_cap >= 0 AND lbRec.bs_key IS NOT NULL));
--
--
        IF (this_baseline_cap >= 0) THEN
          IF getRecStackCount = 1 THEN
             rcvRecPop(rcvRec);
          ELSIF getRecStackCount > 1 THEN
             rcvRecGet(1, rcvRec);
             rcvRecGet(2, rcvRecNxt);
          END IF;
          deb(DEB_IN, 'Newest RcvRec record');
          printRcvRec(rcvRec, TRUE);
          deb(DEB_IN, 'Next to New RcvRec record');
          printRcvRec(rcvRecNxt, TRUE);
        ELSE
          rcvRecPop(rcvRec);
        END IF;
 
        IF (this_baseline_cap >= 0) THEN
          IF (rcvRec.type_act = full_act_t AND
              (rcvRec.toSCN_act > this_baseline_cap_scn OR
               this_baseline_cap_scn IS NULL)) THEN
             lbRec.bs_key := rcvRec.bsKey_con;
             lbRec.df_checkpoint_change# := rcvRec.toSCN_act;
             deb(DEB_IN, 'Found-1 newest backup within baseline_cap for ' ||
                 lbRec.df_file# || ' as ' || lbRec.bs_key);
          ELSE 
             IF (rcvRecNxt.type_act = full_act_t AND
                 ((rcvRec.type_act = offlineRange_act_t OR
                   rcvRec.type_act = cleanRange_act_t   OR
                   rcvRec.type_act = implicitRange_act_t) AND
                  (rcvRec.toSCN_act >= this_baseline_cap_scn OR
                   rcvRec.toSCN_act = MAXSCNVAL))) THEN
                  lbRec.bs_key := rcvRecNxt.bsKey_con;
                  lbRec.df_checkpoint_change# := rcvRec.toSCN_act;
                  deb(DEB_IN, 'Found-2 newest backup with baseline_cap for '
                              || lbRec.df_file# || ' as ' || lbRec.bs_key);
             END IF;
          END IF;
          EXIT;
        END IF;
 
        IF (rcvRec.type_act = full_act_t)
        THEN
          IF (rcvRec.keep_options = KEEP_NO)                  -- nokeep backup
          THEN
            addBackupToMKL(lbState.lbMkTab, rcvRec);
            extendKeepSCN(lbState.lbDfRecTabUs(i),
                          rcvRec.toSCN_act,
                          rcvRec.rlgSCN_act,
                          extendAllSCN,
                          FALSE,
                          'extendFullBackup (NoKeep)');
            numBackups := numBackups+1;          -- bump the number of backups
          ELSIF (NVL(rcvRec.keep_until,MAXDATEVAL) > lbState.lbNowTime)
--
          THEN
--
--
            IF (rcvRec.keep_options =  KEEP_LOGS)                 -- keep logs?
            THEN
              extendKeepSCN(lbState.lbDfRecTabUs(i),
                            rcvRec.toSCN_act,
                            rcvRec.rlgSCN_act,
                            extendLogSCN + extendIncrSCN,
                            FALSE,
                            'extendFullBackup (Keep)');
            END IF;
          END IF;
 
        ELSIF (rcvRec.type_act = offlineRange_act_t OR
               rcvRec.type_act = cleanRange_act_t   OR
               rcvRec.type_act = implicitRange_act_t)
        THEN
           extendMask := 0;
           IF (lbState.lbDfRecTabUs(i).fullmin_scn = rcvRec.fromSCN_act) THEN
              extendMask := extendMask + extendFullSCN;
           END IF;
 
           IF (lbState.lbDfRecTabUs(i).incrmin_scn = rcvRec.fromSCN_act) THEN
              extendMask := extendMask + extendIncrSCN;
           END IF;
 
           IF (lbState.lbDfRecTabUs(i).logmin_scn = rcvRec.fromSCN_act) THEN
              extendMask := extendMask + extendLogSCN;
           END IF;
 
           extendKeepSCN(lbState.lbDfRecTabUs(i), 
                         rcvRec.toSCN_act,
                         rcvRec.rlgSCN_act,
                         extendMask,
                         TRUE,
                         'extendMiscRange');
        ELSIF (rcvRec.type_act = incremental_act_t)
        THEN
          IF (lbState.lbDfRecTabUs(i).incrmin_scn >= rcvRec.fromSCN_act AND
              lbState.lbDfRecTabUs(i).incrmin_scn < rcvRec.toSCN_act)
          THEN
            addBackupToMKL(lbState.lbMkITab, rcvRec);
            extendKeepSCN(lbState.lbDfRecTabUs(i),
                          rcvRec.toSCN_act,
                          rcvRec.rlgSCN_act,
                          extendIncrSCN,
                          TRUE,
                          'extendIncrBackup');
          END IF;
        END IF;
      END LOOP;
 
--
--
--
--
 
--
--
--
      IF ((lbState.lbDfRecTabUs(i).fullmin_scn = MAXSCNVAL OR -- no bkp
           numBackups < redundancy) AND             -- not enough backups
          dfRec.inBackup = 1 AND                    -- file not excluded
          dfRec.noBackupPdb = 0 AND                 -- not a excluded PDB
          dfRec.pluggedRonly = 0)                   -- not a plugged readonly
 
      THEN
        extendKeepSCN(lbState.lbDfRecTabUs(i),
                      dfRec.dfCreationSCN,
                      getPointInTimeInc(dfRec.dfCreationSCN),
                      extendAllSCN,
                      TRUE,
                      'extendNoBackup');
      END IF;
 
--
--
      IF (lbState.lbRlKeepSCN > lbState.lbDfRecTabUs(i).logmin_scn)
      THEN
        lbState.lbRlKeepSCN    := lbState.lbDfRecTabUs(i).logmin_scn;
        lbState.lbRlKeepRlgSCN := lbState.lbDfRecTabUs(i).logmin_rlgscn;
        IF (debug) THEN -- protect for performance
           deb(DEB_IN, 'Extending lbRlKeepSCN to '||
               to_char(lbState.lbRlKeepSCN));
           deb(DEB_IN, 'Extending lbRlKeepRlgSCN to '||
               nvl(to_char(lbState.lbRlKeepRlgSCN), 'null'));
        END IF;
      END IF;
 
      IF (this_baseline_cap >= 0) THEN
         lbState.lbRecOutTab(lbState.lbRecOutTab_count) := lbRec;
         lbState.lbRecOutTab_count := lbState.lbRecOutTab_count + 1;
      END IF;
    END LOOP;
 
--
    LOOP
      BEGIN
--
        IF (getSpfileBackup(rcvRec     => rcvRec,
                            redundancy => redundancy,
                            rmanCmd    => obsoleteCmd_t) = SUCCESS) THEN
          addBackupToMKL(lbState.lbMkTab, rcvRec);
        ELSE
          EXIT;
        END IF;
      EXCEPTION
        WHEN no_data_found THEN EXIT;
      END;
    END LOOP;
 
<<ObsoleteDataSkip>>
 
--
--
    translateAllDatafile;
    LOOP
      BEGIN
        getDatafile(dfRec);
      EXCEPTION
        WHEN no_data_found THEN EXIT;
      END;
      lbState.lbDfRecTab(lbState.lbDfRecTab.count) := dfRec;
    END LOOP;
 
--
--
    IF (piped_call)
    THEN
      openLbCursor(lbCursor);
    ELSE
      IF (listBackup_c%ISOPEN)
      THEN
        CLOSE listBackup_c;
      END IF;
      OPEN listBackup_c;
    END IF;
 
--
--
--
--
--
--
    lbState.lbObsoleteRetention := FALSE;
    lbState.lbKeepForDbpitr     := FALSE;
 
--
--
    lbState.lbObsoleteKeep := FALSE;
--
    lbState.lbRecTmpTab.delete;
    lbState.lbCopyCount := 0;
    lbState.lbPieceCountTab.delete;
    lbState.lbRecCmn := null_lbRec;
 
    IF (debug) THEN
      deb(DEB_IN, 'Must Keep List:');
      i := lbState.lbMkTab.first;
      LOOP
        EXIT WHEN i IS NULL;
        FOR j in 0..lbState.lbMkTab(i).count-1 LOOP
          IF (lbState.lbMkTab(i)(j).type_con = backupSet_con_t) THEN
            deb(DEB_PRINT, 'Backup Set bskey=' ||
                lbState.lbMkTab(i)(j).bsKey_con || ' set_stamp=' ||
                lbState.lbMkTab(i)(j).setStamp_con || ' set_count=' ||
                lbState.lbMkTab(i)(j).setCount_con);
          ELSIF (lbState.lbMkTab(i)(j).type_con = imageCopy_con_t) THEN
            deb(DEB_PRINT, 'Datafile Copy key=' ||
                lbState.lbMkTab(i)(j).key_con || ' recid=' ||
                lbState.lbMkTab(i)(j).recid_con || ' stamp=' ||
                lbState.lbMkTab(i)(j).stamp_con);
          ELSIF (lbState.lbMkTab(i)(j).type_con = proxyCopy_con_t) THEN
            deb(DEB_PRINT, 'Proxy Backup key=' ||
                lbState.lbMkTab(i)(j).key_con || ' recid=' ||
                lbState.lbMkTab(i)(j).recid_con || ' stamp=' ||
                lbState.lbMkTab(i)(j).stamp_con);
          ELSE
            deb(DEB_PRINT, 'Unknown Type=' || lbState.lbMkTab(i)(j).type_con);
          END IF;
        END LOOP;
        i := lbState.lbMkTab.next(i);
     END LOOP;
    END IF;
 
--
--
    cacheBsRecTable.hint := noHint;
  END IF; -- first call
 
  IF (this_baseline_cap >= 0) THEN
     goto listBackup_returnRec; 
  END IF;
 
  <<main_loop>>
 
 
  WHILE (lbState.lbRecOutTab_count = 0)     -- while there is nothing to return
  LOOP
 
    IF (piped_call)
    THEN
      FETCH lbCursor INTO lbRec;
      IF (lbCursor%NOTFOUND)
      THEN
        lbCursor_notfound := TRUE;
      END IF;
    ELSE
      FETCH listBackup_c INTO lbRec;
      IF (listBackup_c%NOTFOUND)
      THEN
        lbCursor_notfound := TRUE;
      END IF;
    END IF;
 
    IF (lbCursor_notfound OR
        (lbRec.file_type = backupset_txt) OR
        (lbRec.backup_type IN (copy_txt, proxycopy_txt)) OR
        (lbRec.backup_type = backupset_txt AND
         lbRec.file_type <> backupset_txt AND
         (lbState.lbRecCmn.recid IS NULL OR
          lbState.lbRecCmn.bs_stamp <> lbRec.bs_stamp OR
          lbState.lbRecCmn.bs_count <> lbRec.bs_count)))
    THEN
--
--
--
--
--
--
--
--
      IF (lbState.lbRecTmpTab.count > 0 AND lbState.lbCopyCount > 0 AND
          (NOT only_obsolete OR lbState.lbObsoleteRetention OR
           lbState.lbObsoleteKeep))
      THEN
--
--
--
        IF lbState.lbNeedObsoleteData THEN
          IF (lbState.lbObsoleteRetention OR lbState.lbObsoleteKeep)
          THEN
            IF (debug) THEN -- protect for performance
               deb(DEB_IN, 'E: Obsolete!!!');
            END IF;
            lbState.lbRecCmn.obsolete := 'YES';
            lbState.lbRecCmn.keep_for_dbpitr := 'NO';
          ELSE
            IF (debug) THEN -- protect for performance
               deb(DEB_IN, 'E: Not obsolete!!!');
            END IF;
            lbState.lbRecCmn.obsolete := 'NO';
            IF (lbState.lbKeepForDbpitr) THEN
               lbState.lbRecCmn.keep_for_dbpitr := 'YES';
            ELSE
               lbState.lbRecCmn.keep_for_dbpitr := 'NO';
            END IF;
          END IF;
        END IF;
 
--
--
        IF (lbState.lbRecCmn.status <> other_txt)
        THEN
          <<loop_copy>>
          FOR i IN 0..lbState.lbCopyCount-1
          LOOP
            BEGIN
              IF (lbState.lbRecCmn.bs_pieces != lbState.lbPieceCountTab(i))
              THEN
                lbState.lbRecCmn.status := other_txt;
                EXIT loop_copy;
              END IF;
            EXCEPTION
              WHEN no_data_found THEN  -- lbPieceCountTab(i) uninitialized
                EXIT loop_copy;
            END;
          END LOOP;
        END IF;
 
--
        IF (debug) THEN -- protect for performance
           deb(DEB_IN, 'pipelineing backup set '||lbState.lbRecCmn.bs_key);
        END IF;
 
        FOR i IN 0..lbState.lbRecTmpTab.count-1
        LOOP
--
          IF (recoveryDestFile AND lbState.lbRecTmpTab(i).is_rdf = 'NO')
          OR (orsAnyFile     AND
              lbState.lbRecTmpTab(i).bp_ba_access IN ('U','D'))
          OR (orsLocalFile   AND
              lbState.lbRecTmpTab(i).bp_ba_access IN ('U','D','T','R'))
          OR (orsLibKey IS NOT NULL AND
              nvl(lbState.lbRecTmpTab(i).bp_lib_key, 0) != orsLibKey)
          THEN
--
             IF (debug) THEN -- protect for performance
                deb(DEB_IN, 'not a recovery area or ors file type');
             END IF;
          ELSIF (anyDevice = FALSE# AND         -- not all device is allocated
                 lbState.lbRecTmpTab(i).file_type = piece_txt AND
                 isDevicetypeAllocated(lbState.lbRecTmpTab(i).device_type) =
                   FALSE#) THEN
--
--
--
             IF (debug) THEN -- protect for performance
                deb(DEB_IN, 'device type not allocated');
             END IF;
          ELSE
--
--
--
 
             tmp := lbState.lbRecOutTab_count;
             lbState.lbRecOutTab(tmp) :=
                lbState.lbRecTmpTab(i);
             lbState.lbRecOutTab(tmp).obsolete :=
                lbState.lbRecCmn.obsolete;
             lbState.lbRecOutTab(tmp).keep_for_dbpitr :=
                lbState.lbRecCmn.keep_for_dbpitr;
             lbState.lbRecOutTab(tmp).bs_status :=
                lbState.lbRecCmn.bs_status;
             lbState.lbRecOutTab(tmp).bs_copies :=
                lbState.lbRecCmn.bs_copies;
             lbState.lbRecOutTab(tmp).bs_bytes :=
                lbState.lbRecCmn.bs_bytes / lbState.lbRecCmn.bs_copies;
             lbState.lbRecOutTab(tmp).bs_compressed :=
                lbState.lbRecCmn.bs_compressed;
             lbState.lbRecOutTab(tmp).bs_tag :=
                lbState.lbRecCmn.bs_tag;
             lbState.lbRecOutTab(tmp).bs_device_type :=
                lbState.lbRecCmn.bs_device_type;
             IF (lbState.lbRecCmn.recid IS NOT NULL) THEN
--
--
                lbState.lbRecOutTab(tmp).backup_type :=
                   lbState.lbRecCmn.backup_type;
                lbState.lbRecOutTab(tmp).keep :=
                   lbState.lbRecCmn.keep;
                lbState.lbRecOutTab(tmp).keep_options:=
                   lbState.lbRecCmn.keep_options;
                lbState.lbRecOutTab(tmp).keep_until :=
                   lbState.lbRecCmn.keep_until;
                lbState.lbRecOutTab(tmp).bs_key :=
                   lbState.lbRecCmn.bs_key;
                lbState.lbRecOutTab(tmp).bs_count :=
                   lbState.lbRecCmn.bs_count;
                lbState.lbRecOutTab(tmp).bs_stamp :=
                   lbState.lbRecCmn.bs_stamp;
                lbState.lbRecOutTab(tmp).bs_type :=
                   lbState.lbRecCmn.bs_type;
                lbState.lbRecOutTab(tmp).bs_incr_type :=
                   lbState.lbRecCmn.bs_incr_type;
                lbState.lbRecOutTab(tmp).bs_pieces :=
                   lbState.lbRecCmn.bs_pieces;
                lbState.lbRecOutTab(tmp).bs_completion_time :=
                   lbState.lbRecCmn.bs_completion_time;
             END IF;
             lbState.lbRecOutTab_count := tmp + 1;
          END IF;
        END LOOP;
      END IF;
 
--
      IF (lbCursor_notfound)
      THEN
        exit main_loop;
      END IF;
 
--
--
--
--
--
      IF (lbRec.file_type <> backupset_txt AND
          lbRec.backup_type = backupset_txt)
      THEN
        IF (debug) THEN
          deb(DEB_IN, 'setting lbObsoleteRetention to FALSE');
        END IF;
        lbState.lbObsoleteRetention := FALSE;
      ELSE
        IF (debug) THEN
          deb(DEB_IN, 'setting lbObsoleteRetention to TRUE');
        END IF;
        lbState.lbObsoleteRetention := TRUE;
      END IF;
 
--
--
      lbState.lbObsoleteKeep  := FALSE;
      lbState.lbKeepForDbpitr := FALSE;
 
--
      lbState.lbRecTmpTab.delete;
      lbState.lbCopyCount := 0;
      lbState.lbPieceCountTab.delete;
      lbState.lbRecCmn := null_lbRec;
    END IF;
 
    IF (debug) THEN  -- protect for performance
       printLbRec(lbRec);
 
--
--
       IF (lbRec.backup_type = backupset_txt AND
           lbRec.file_type <> backupset_txt) THEN
          IF ((lbState.lbRecCmn.bs_stamp = lbRec.bs_stamp AND
               lbState.lbRecCmn.bs_count = lbRec.bs_count) OR
              lbState.lbRecCmn.bs_key = lbRec.bs_key) THEN
             deb(DEB_IN, 'bs->bp->bdf/bsf/brl same bs');
          ELSE
             deb(DEB_IN, 'bs->bp->bdf/bsf/brl **no** bs (or) **not** same bs');
          END IF;
       END IF;
    END IF;
 
--
--
--
--
 
    If lbState.lbNeedObsoleteData THEN
      lbRec.obsolete := 'YES';                -- assume that backup is obsolete
      lbRec.keep_for_dbpitr := 'NO';
    END IF;
 
    IF (lbState.lbObsoleteRetention AND NOT lbState.lbObsoleteKeep AND
        lbState.lbNeedObsoleteData) THEN
--
       full_df_backup := FALSE;
       incr_df_backup := FALSE;
       arc_log_backup := FALSE;
 
       IF (lbRec.backup_type = backupset_txt) THEN
          IF (lbRec.file_type = archivedlog_txt) THEN
             arc_log_backup := TRUE;
          ELSIF (lbRec.file_type IN (spfile_txt, controlfile_txt)) THEN
             full_df_backup := TRUE;
          ELSIF (lbRec.file_type = datafile_txt) THEN
             IF (lbRec.df_incremental_change# = lbRec.df_creation_change# OR
                 lbRec.bs_incr_type = full_txt) THEN
                full_df_backup := TRUE;
             ELSIF (lbRec.bs_incr_type <> full_txt) THEN
                incr_df_backup := TRUE;
             END IF;
          END IF;
       ELSIF (lbRec.backup_type IN (copy_txt, proxycopy_txt) AND
              lbRec.file_type   IN (datafile_txt, controlfile_txt)) THEN
          full_df_backup := TRUE;
       END IF;
 
--
       keep := NVL(lbRec.keep, 'NO');
       keep_until := NVL(lbRec.keep_until, MAXDATEVAL);
       IF ((full_df_backup OR arc_log_backup OR incr_df_backup) AND
           lbRec.backup_type = backupset_txt)
       THEN
          keep := NVL(lbState.lbRecCmn.keep, 'NO');
          keep_until := NVL(lbState.lbRecCmn.keep_until, MAXDATEVAL);
       END IF;
 
--
       IF (keep = 'YES') THEN
          IF (debug) THEN -- protect for performance
             deb(DEB_IN, 'Keep backup until ' || keep_until ||
                         ' - Checking ...');
          END IF;
          IF (keep_until < lbState.lbNowtime) THEN
             IF (debug) THEN  -- protect for performance
               deb(DEB_IN, 'expired -> obsolete by keep');
             END IF;
             lbState.lbObsoleteKeep := TRUE;
          ELSE
             IF (debug) THEN  -- protect for performance
               deb(DEB_IN, 'not expired -> no obsolete');
             END IF;
             lbState.lbObsoleteRetention := FALSE;
          END IF;
       END IF;
 
--
       IF (full_df_backup) THEN
          IF (keep != 'YES') THEN                             -- nokeep backup
             IF (debug) THEN  -- protect for performance
                deb(DEB_IN, 'Full backup - Checking ...');
             END IF;
             IF ((lbRec.file_type = spfile_txt AND
                  lbRec.df_ckp_mod_time <            -- it is SPFILE outside RW
                     NVL(untilTime, MAXDATEVAL))   OR
                 (lbRec.file_type <> spfile_txt AND  -- other file outside RW
                  ((untilTime IS NULL AND untilSCN IS NULL) OR
                   lbRec.df_ckp_mod_time < untilTime        OR
                   (untilTime IS NULL AND
                    lbRec.df_checkpoint_change# <= untilSCN)))) THEN
                IF (debug) THEN  -- protect for performance
                   deb(DEB_IN, 'nokeep backup outside RW');
                END IF;
                IF (listBackupInMKL(lbState.lbMkTab, lbRec)) THEN
                   IF (debug) THEN -- protect for performance
                      deb(DEB_IN, 'inside MKL -> no obsolete');
                      deb(DEB_IN, 'keep_for_dbpitr = YES');
                   END IF;
                   lbState.lbObsoleteRetention := FALSE;
                   lbState.lbKeepForDbpitr     := TRUE;
                ELSIF (listBackupInMKS(lbState.lbDfRecTabUs, lbRec,
                                       lbState.lbMaxDfNumber, FALSE)) THEN
--
--
--
--
                   IF (debug) THEN -- protect for performance
                      deb(DEB_IN, 'inside MKS -> no obsolete');
                   END IF;
                   lbState.lbObsoleteRetention := FALSE;
                   lbState.lbKeepForDbpitr     := FALSE;
                END IF;
             ELSE                          -- inside Recovery Win, not obsolete
                IF (debug) THEN -- protect for performance
                   deb(DEB_IN, 'nokeep backup: inside RW -> no obsolete');
                END IF;
                lbState.lbObsoleteRetention := FALSE;
             END IF;
          END IF;
       ELSIF (incr_df_backup) THEN
          IF (debug) THEN -- protect for performance
             deb(DEB_IN, 'Incremental backup - Checking ...');
          END IF;
          IF (listBackupInMKL(lbState.lbMkITab, lbRec)) THEN
             IF (debug) THEN -- protect for performance
                deb(DEB_IN, 'inside MKL -> no obsolete');
                deb(DEB_IN, 'keep_for_dbpitr = YES');
             END IF;
             lbState.lbObsoleteRetention := FALSE;
             lbState.lbKeepForDbpitr     := TRUE;
          ELSIF (listBackupInMKS(lbState.lbDfRecTabUs, lbRec,
                                 lbState.lbMaxDfNumber, TRUE)) THEN
            IF (debug) THEN -- protect for performance
               deb(DEB_IN, 'inside MKS -> no obsolete');
            END IF;
            lbState.lbObsoleteRetention := FALSE;      -- need this incremental
            lbState.lbKeepForDbpitr     := FALSE;
          END IF;
       ELSIF (lbRec.file_type = archivedlog_txt) THEN              --- redo log
--
--
--
--
          IF ((lbRec.rl_next_change# >= lbState.lbMinGrsp AND
               lbRec.backup_type != copy_txt)                      OR  -- (a)
              lbRec.rl_next_time >= lbState.lbFbUntilTime          OR  -- (b)
              (lbRec.rl_next_change# >= lbState.lbRlKeepSCN AND        -- (c)
               (lbState.lbRlKeepRlgSCN IS NULL                          OR
                lbRec.rl_resetlogs_change# = lbState.lbRlKeepRlgSCN     OR
                lbRec.rl_resetlogs_change# >= lbState.lbRlKeepSCN))) THEN
             IF (debug) THEN -- protect for performance
                IF (lbRec.rl_next_time >= lbState.lbFbUntilTime) THEN
                   deb(DEB_IN, 'Redolog after lbFbUntilTime -> no obsolete');
                ELSIF (lbRec.rl_next_change# >= lbState.lbMinGrsp AND
                       lbRec.backup_type != copy_txt) THEN
                   deb(DEB_IN, 'Redolog after lbMinGrsp -> no obsolete');
                ELSE
                   deb(DEB_IN, 'Redolog after lbRlkeepSCN -> no obsolete');
                END IF;
             END IF;
             lbState.lbObsoleteRetention := FALSE;    -- this redo must be kept
          END IF;
       END IF;
    END IF;
 
    IF (NOT lbState.lbKeepForDbpitr AND lbRec.file_type = archivedlog_txt) THEN
       IF (lbRec.rl_next_change# >= lbState.lbRlKeepSCN AND
           (lbRec.rl_first_change# <= untilSCN OR
            lbRec.rl_first_time <= untilTime)           AND
           (lbState.lbRlKeepRlgSCN IS NULL                      OR
            lbRec.rl_resetlogs_change# = lbState.lbRlKeepRlgSCN OR
            lbRec.rl_resetlogs_change# >= lbState.lbRlKeepSCN)) THEN
          IF (debug) THEN
             deb(DEB_IN, 'keep_for_dbpitr = YES');
          END IF;
          lbState.lbKeepForDbpitr := TRUE;
       END IF;
    END IF;
 
--
--
    IF (NOT lbState.lbObsoleteRetention AND NOT lbState.lbObsoleteKeep AND
        lbState.lbNeedObsoleteData)
    THEN
      IF (debug) THEN
         deb(DEB_IN, 'Not obsolete');
      END IF;
      lbRec.obsolete := 'NO';
      lbState.lbRecCmn.obsolete := 'NO';
      IF (lbState.lbKeepForDbpitr) THEN
         lbState.lbRecCmn.keep_for_dbpitr := 'YES';
         lbRec.keep_for_dbpitr := 'YES';
      ELSE
         lbState.lbRecCmn.keep_for_dbpitr := 'NO';
         lbRec.keep_for_dbpitr := 'NO';
      END IF;
      IF (only_obsolete)
      THEN
        GOTO listBackup_end;
      END IF;
    END IF;
 
--
--
--
    IF (lbRec.backup_type IN (backupset_txt, copy_txt) AND
        lbRec.file_type   = datafile_txt)
    THEN
      found := FALSE;
 
--
--
      <<loop_lbDfRecTab>>
      FOR i in lbRec.df_file#-1..lbState.lbDfRecTab.count-1
      LOOP
        IF (lbState.lbDfRecTab(i).dfNumber = lbRec.df_file# AND
            lbState.lbDfRecTab(i).dfCreationSCN = lbRec.df_creation_change#)
        THEN
          IF (lbRec.backup_type = backupset_txt)
          THEN
            lbRec.fname := lbState.lbDfRecTab(i).fileName;
          END IF;
          lbRec.df_tablespace := lbState.lbDfRecTab(i).tsName;
          found := TRUE;
          EXIT loop_lbDfRecTab;
        ELSIF (lbState.lbDfRecTab(i).dfNumber > lbRec.df_file#) THEN
          EXIT loop_lbDfRecTab;
        END IF;
      END LOOP;
 
      IF (NOT found) THEN
--
        <<reverse_loop_lbDfRecTab>>
        FOR i in REVERSE 0..least(lbRec.df_file#-1, lbState.lbDfRecTab.count-1)
        LOOP
          IF (lbState.lbDfRecTab(i).dfNumber = lbRec.df_file# AND
              lbState.lbDfRecTab(i).dfCreationSCN = lbRec.df_creation_change#)
          THEN
            IF (lbRec.backup_type = backupset_txt)
            THEN
              lbRec.fname := lbState.lbDfRecTab(i).fileName;
            END IF;
            lbRec.df_tablespace := lbState.lbDfRecTab(i).tsName;
            found := TRUE;
            EXIT reverse_loop_lbDfRecTab;
          ELSIF (lbState.lbDfRecTab(i).dfNumber < lbRec.df_file#) THEN
            EXIT reverse_loop_lbDfRecTab;
          END IF;
        END LOOP;
      END IF;
    END IF;
 
--
--
--
--
--
    IF (lbRec.backup_type = backupset_txt)
    THEN
      IF (lbRec.file_type = backupset_txt)
      THEN
--
--
--
 
--
        lbState.lbRecTmpTab.delete;
        lbState.lbCopyCount := 0;
        lbState.lbPieceCountTab.delete;
 
--
--
        lbState.lbRecCmn := lbRec;
        lbState.lbRecCmn.bs_copies := 0;
        lbState.lbRecCmn.bs_bytes  := 0;
      ELSIF lbRec.file_type in (datafile_txt, controlfile_txt,
                                spfile_txt  , archivedlog_txt,
                                piece_txt)
      THEN
        IF (NOT only_obsolete OR lbRec.file_type = piece_txt)
        THEN
--
           lbState.lbRecTmpTab(lbState.lbRecTmpTab.count) := lbRec;
           IF (lbRec.file_type = piece_txt)
           THEN
              listBackupProcessPiece(lbRec, lbRecOut, lbState);
           END IF;
        END IF;
      ELSE
--
        deb(DEB_EXIT, 'with error 20999');
        raise_application_error(-20999, 'internal error: listBackup_2');
      END IF;
    ELSIF (lbRec.backup_type = copy_txt)
    THEN
--
--
 
--
--
--
--
--
      IF (diskDevice)
      THEN
        IF (recoveryDestFile AND lbRec.is_rdf = 'NO') THEN
           IF (debug) THEN  -- protect for performance
              deb(DEB_IN,
                  'copy not recovery area or ors file pkey: ' || lbRec.pkey);
           END IF;
        ELSE
           IF (debug) THEN -- protect for performance
              deb(DEB_IN, 'device allocated: pipelineing copy '||lbRec.pkey);
           END IF;
           lbState.lbRecOutTab(lbState.lbRecOutTab_count) := lbRec;
           lbState.lbRecOutTab_count := lbState.lbRecOutTab_count+1;
        END IF;
      ELSE
        IF (debug) THEN -- protect for performance
           deb(DEB_IN, 'device not allocated: skiping copy '||lbRec.pkey);
        END IF;
      END IF;
    ELSIF (lbRec.backup_type = proxycopy_txt)
      THEN
--
--
 
--
--
--
--
--
      IF (anyDevice = TRUE# OR
          isDeviceTypeAllocated(lbRec.device_type) = TRUE#)
      THEN
        IF (recoveryDestFile AND lbRec.is_rdf = 'NO') THEN
           IF (debug) THEN -- protect for performance
              deb(DEB_IN, 'proxycopy not a recovery area file pkey: ' ||
                  lbRec.pkey);
           END IF;
        ELSE
          IF (debug) THEN -- protect for performance
             deb(DEB_IN, 'device allocated: pipelineing proxycopy '||
                 lbRec.pkey);
          END IF;
          lbState.lbRecOutTab(lbState.lbRecOutTab_count) := lbRec;
          lbState.lbRecOutTab_count := lbState.lbRecOutTab_count+1;
        END IF;
      ELSE
        IF (debug) THEN  -- protect for performance
           deb(DEB_IN, 'device not allocated: skiping proxycopy '||lbRec.pkey);
        END IF;
      END IF;
    ELSE
      deb(DEB_EXIT, 'with error 20999');
      raise_application_error(-20999, 'internal error: listBackup_3');
    END IF;
  END LOOP;
 
<<listBackup_returnRec>>
--
  IF (lbState.lbRecOutTab_count > 0)
  THEN
    lbState.lbRecOutTab_count := lbState.lbRecOutTab_count - 1;
    lbRecOut := lbState.lbRecOutTab(lbState.lbRecOutTab_count);
  END IF;
 
<<listBackup_end>>
--
--
 
  IF (lbState.lbRecOutTab_count = 0)
  THEN
    IF (this_baseline_cap >= 0) THEN
      deb(DEB_EXIT, 'FALSE');
      RETURN FALSE;
    END IF;
 
    IF (piped_call)
    THEN
      IF (lbCursor%NOTFOUND)
      THEN
        CLOSE lbCursor;
        cacheBsRecTable.hint := noHint;
        IF (debug) THEN -- protect for performance
           deb(DEB_EXIT, 'FALSE');
        END IF;
        RETURN FALSE;
      END IF;
    ELSE
      IF (listBackup_c%NOTFOUND)
      THEN
        CLOSE listBackup_c;
        cacheBsRecTable.hint := noHint;
        IF (debug) THEN -- protect for performance
           deb(DEB_EXIT, 'FALSE');
        END IF;
        RETURN FALSE;
      END IF;
    END IF;
  END IF;
 
  deb(DEB_EXIT, 'TRUE');
  RETURN TRUE;
 
EXCEPTION
  WHEN OTHERS THEN
    IF (piped_call)
    THEN
      IF (lbCursor%ISOPEN) THEN
        CLOSE lbCursor;
      END IF;
    ELSE
      IF (listBackup_c%ISOPEN) THEN
        CLOSE listBackup_c;
      END IF;
    END IF;
    deb(DEB_EXIT, 'with exception: '||substr(sqlerrm, 1, 512));
    RAISE;
 
END listBackup;
 
--
FUNCTION getRestoreRangeSet(restoreRangeTab OUT restoreRangeTab_t,
                            opCode          IN  varchar2,
                            db_id           IN  number)
 
RETURN boolean IS
 
  i                       number;
  j                       number;
  ret                     boolean;
  rc                      binary_integer;
  restoreRange            restoreRange_t;
  dfRecTab                dfRecTab_t;
  dfRec                   dfRec_t;
  rcvRec                  rcvRec_t;
  maxScn                  number;
  maxRlgScn               number;
  maxRlgTime              date;
  minScn                  number;          
  fromScn                 number;
  tmpScn                  number;
  dropScn                 number;
  dropTime                date;
  dropDbIncKey            number;
  dropRlgScn              number;
  dropRlgTime             date;
  lastBkupScn             number;
  cfcrescn                number;
  cfcretime               date;
  tmpDbIncKey             number;
  tmpRlgScn               number;
  tmpRlgTime              date;
  actionMask              number;
  dfBackupFound           number;
  offlnRngFound           number;
  dfCreation              number;
  logBreakPointScn        number;
  logBreakPointTime       date;
  logBreakDbIncKey        number;
  logBreakRlgScn          number;
  logBreakRlgTime         date;
  nextAvailableScn        number;
  logMissing              boolean;
  nxtScnExist             boolean;
  maxScnExist             boolean;
  dropScnExist            boolean;
  maxTime                 date;
  maxDbIncKey             number;
  tmpTime                 date;
  nowTime                 date;
  logRangeCount           number;
  isOrs                   number;
  type isActnFoundTab is table of boolean index by binary_integer;  
  isActnFound             isActnFoundTab;
  con_id                  number;
  canCreateDf             boolean;
  dfCreateSCN             number;
BEGIN
 
  deb(DEB_ENTER, 'getRestoreRangeSet');
  deb(DEB_IN, 'backupLocation = ' || opCode);
  if (substr(opCode,  4, 3) = 'ANY') then
     restoreRangeDevTyp := substr(opCode, 1, 6);
  elsif (substr(opCode,  4, 4) = 'DISK') then
     restoreRangeDevTyp := substr(opCode, 1, 7);
  elsif (substr(opCode,  4, 3) = 'SBT') then
     restoreRangeDevTyp := substr(opCode, 1, 6);
  elsif (substr(opCode,  1, 5) = 'V$ANY') then
     restoreRangeDevTyp := substr(opCode, 3, 3);
  elsif (substr(opCode,  1, 6) = 'V$DISK') then
     restoreRangeDevTyp := substr(opCode, 3, 4);
  elsif (substr(opCode,  1, 5) = 'V$SBT') then
     restoreRangeDevTyp := substr(opCode, 3, 3);
  end if;
 
--
  IF (opCode = 'RA$ANY' OR opCode = 'RA$DISK' OR opCode = 'RA$SBT') THEN
     IF user_site_key IS NULL THEN
        ret := setLocalOrsSiteKey(db_id);
        IF ret = FALSE THEN
           resetLocalOrsSiteKey;
           deb(DEB_EXIT, 'with FALSE');
           return FALSE;
        END IF;
     END IF;
     isOrs := TRUE#;
  ELSE
     isOrs := FALSE#;
  END IF;
 
  restoreRangeTab.delete;
 
  setCraGetAllCfBackups(TRUE);
  setAllIncarnations(TRUE);
  canApplyAnyRedo := TRUE#;
 
--
  maxScnExist  := getMaxRedoSCN(maxScn, maxTime, maxDbIncKey, maxRlgScn, 
                                maxRlgTime, isOrs);
  IF (maxScnExist = FALSE) THEN
    resetLocalOrsSiteKey;
    deb(DEB_EXIT, 'with FALSE');
    return FALSE;
  END IF;
  deb(DEB_IN, 'Max scn is ' || to_char(maxScn));
 
--
  nxtScnExist := getNextAvailableSCN(0, minScn, isOrs);
  IF (nxtScnExist = FALSE) THEN
    resetLocalOrsSiteKey;
    deb(DEB_EXIT, 'with FALSE');
    return FALSE;
  END IF;
  fromScn := minScn;
 
 
--
--
--
--
--
--
--
--
--
  i := 0; 
  LOOP
    EXIT WHEN fromScn >= maxScn;
    logMissing := findLogBreakPoint(logBreakPointScn, logBreakPointTime, 
                                    logBreakDbIncKey, logBreakRlgScn, 
                                    logBreakRlgTime, fromScn, maxScn, isOrs);
--
    IF (logMissing = FALSE) THEN
      restoreRangeTab(i).startScn     := fromScn;
      restoreRangeTab(i).highScn      := maxScn;
      restoreRangeTab(i).highTime     := maxTime;
      restoreRangeTab(i).highDbIncKey := maxDbIncKey;
      restoreRangeTab(i).highRlgScn   := maxRlgScn;
      restoreRangeTab(i).highRlgTime  := maxRlgTime;
      restoreRangeTab(i).con_id       := con_id;
      EXIT;
--
--
    ELSE 
      restoreRangeTab(i).startScn     := fromScn;
      restoreRangeTab(i).highScn      := logBreakPointScn;
      restoreRangeTab(i).highTime     := logBreakPointTime;
      restoreRangeTab(i).highDbIncKey := logBreakDbIncKey;
      restoreRangeTab(i).highRlgScn   := logBreakRlgScn;
      restoreRangeTab(i).highRlgTime  := logBreakRlgTime;
      restoreRangeTab(i).con_id       := con_id;
 
--
      nxtScnExist := getNextAvailableSCN(logBreakPointScn, nextAvailableScn, 
                                         isOrs);
      IF (nxtScnExist = TRUE) THEN
        fromScn := nextAvailableScn;
      ELSE
        EXIT;
      END IF;
    END IF;
    i := i + 1;
  END LOOP;
 
--
  logRangeCount := i + 1;
 
--
  i := 0;
  WHILE i < logRangeCount LOOP
    restoreRangeTab(i).isValidRange := FALSE;
    restoreRangeTab(i).cfBkupFound  := FALSE;
    i := i + 1;
  END LOOP;
 
  deb(DEB_IN, 'Printing continuous log-ranges');
  i := 0;
  WHILE i < logRangeCount LOOP
    deb(DEB_IN, 'Range '||to_char(i+1)||' lowscn = '||
                 to_char(restoreRangeTab(i).startScn) ||' highscn = '||
                 to_char(restoreRangeTab(i).highScn));
    i := i + 1;
  END LOOP;
 
--
  dfRecTab.delete;
  translateAllDatafile;
  LOOP
    BEGIN
      getDatafile(dfRec);
    EXCEPTION
      WHEN no_data_found THEN EXIT;
    END;
      dfRecTab(dfRecTab.count) := dfRec;
  END LOOP;
 
  SELECT SYSDATE INTO nowTime from dual;
 
--
--
  actionMask := full_act_t + offlineRange_act_t + implicitRange_act_t + 
                cleanRange_act_t + incremental_act_t + createdatafile_act_t;
 
--
--
--
  setComputeRecoveryActionMasks(containerMask   => backupSet_con_t +
                                                   offlineRangeRec_con_t +
                                                   imageCopy_con_t,
                                actionMask      => actionMask,
                                allRecords      => TRUE#,
                                availableMask   => BSavailable,
                                fullBackups     => NULL);
 
--
--
  findControlfileBackup(FALSE, FALSE, TRUE, 0, 0);
 
  IF getRecStackCount <> 0 THEN
     rcvRecPop(rcvRec);
     cfcrescn := 0;
     cfcretime := rcvRec.cfCreationTime_con;
  END IF;
 
--
--
  j := to_number(null);
  LOOP
    IF (j is null) THEN
       j := dfRecTab.first;
    ELSE
       j := dfRecTab.next(j);
    END IF;
    EXIT WHEN j IS NULL;
    dfRec := dfRecTab(j);
 
--
--
    IF (dfRec.pluginSCN       = 0  AND 
        dfRec.foreignDbid     = 0  AND
        dfRec.pdbForeignDbid  = 0  AND
        dfRec.creation_thread > 0  AND
        dfRec.creation_size   > 0)   
    THEN
       canCreateDf := TRUE; 
    ELSE
       canCreateDf := FALSE;
    END IF;
    dfCreateSCN := dfRec.dfCreationSCN;
 
    dropScnExist := getDropSCN(dfRec.dfNumber, dfRec.dfCreationSCN, 
                               dfRec.dfCreationTime, dfRec.pluginSCN, 
                               dfRec.foreignDbid, dropScn, dropTime,
                               dropDbIncKey, dropRlgScn, dropRlgTime);
 
    IF (dropScnExist = TRUE) THEN
       deb(DEB_IN, 'Datafile belongs to tablespace# ' || 
                    to_char(dfRec.dfNumber) || 'which has a dropscn' ||
                    dropScn);
    END IF;
 
--
    rc := computeRecoveryActions(fno              => dfRec.dfNumber,
                                 crescn           => dfRec.dfCreationSCN,
                                 df_cretime       => dfRec.dfCreationTime,
                                 cf_scn           => cfcrescn,
                                 cf_cretime       => cfcretime,
                                 allowfuzzy       => FALSE,
                                 partial_rcv      => FALSE,
                                 allCopies        => FALSE,
                                 cleanscn         => dfRec.stopSCN,
                                 clean2scn        => highscnval,
                                 clean2time       => nowTime,
                                 onlscn           => dfRec.dfOnlineSCN,
                                 offlscn          => dfRec.dfOfflineSCN,
                                 onltime          => dfRec.dfOnlineTime,
                                 rmanCmd          => restoreCmd_t,
                                 foreignDbid      => dfRec.foreignDbid,
                                 pluggedRonly     => dfRec.pluggedRonly,
                                 pluginSCN        => dfRec.pluginSCN,
                                 pluginRlgSCN     => dfRec.pluginRlgSCN,
                                 pluginRlgTime    => dfRec.pluginRlgTime,
                                 creation_thread  => dfRec.creation_thread,
                                 creation_size    => dfRec.creation_size,
                                 pdbId            => dfRec.pdbId,
                                 pdbForeignDbid   => dfRec.pdbForeignDbid);
 
--
    deb(DEB_IN, 'Considering backups for the datafile ' 
                 ||to_char(dfRec.dfNumber));
        
--
--
--
--
    i := 0;
    WHILE i < logRangeCount LOOP
      isActnFound(i) := FALSE;
      i := i + 1;
    END LOOP;
 
--
    IF (rc = SUCCESS)
    THEN
      LOOP
          EXIT WHEN getRecStackCount = 0;
          rcvRecPop(rcvRec);
          dfBackupFound := FALSE#;
          offlnRngFound := FALSE#;
          dfCreation    := FALSE#;
--
          IF (rcvRec.type_act = full_act_t) THEN
--
             tmpScn := rcvRec.toSCN_act;
             tmpTime := rcvRec.toTime_act;
             tmpDbIncKey := rcvRec.dbincKey_act;
             tmpRlgScn   := rcvRec.rlgSCN_act;
             tmpRlgTime  := rcvRec.rlgTime_act;
             dfBackupFound := TRUE#;
--
          ELSIF (rcvRec.type_act = createdatafile_act_t) THEN
             dfCreation  := TRUE#;
             deb(DEB_IN, 'The df can be created');
--
          ELSIF (rcvRec.type_act = cleanRange_act_t) THEN
             deb(DEB_IN, 'A clean range found');
             lastBkupScn := tmpScn; 
             offlnRngFound := TRUE#; 
          END IF;
 
--
          IF (dfRec.dfNumber = 1 and dfBackupFound = TRUE#) THEN
             deb(DEB_IN, 'backup scn = ' || to_char(tmpScn));
--
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= tmpScn AND 
                    restoreRangeTab(i).highScn >= tmpScn AND 
                    isActnFound(i) = FALSE) THEN
--
--
                   restoreRangeTab(i).lowScn        := tmpScn;
                   restoreRangeTab(i).lowTime       := tmpTime;
                   restoreRangeTab(i).lowDbIncKey   := tmpDbIncKey;
                   restoreRangeTab(i).lowRlgScn     := tmpRlgScn;
                   restoreRangeTab(i).lowRlgTime    := tmpRlgTime;
                   restoreRangeTab(i).rcvStartScn   := tmpScn;
                   restoreRangeTab(i).rcvStartTime  := tmpTime;
                   isActnFound(i)          := TRUE;
                   restoreRangeTab(i).isValidRange  := TRUE;
                   deb(DEB_IN, 'backup belongs to ' || to_char(i+1) || 
                               '-th range' );
                END IF;
                i := i + 1;
             END LOOP;
 
--
--
          ELSIF (dfRec.dfNumber > 1 and dfBackupFound = TRUE#) THEN
             deb(DEB_IN, 'backup scn = ' || to_char(tmpScn));
--
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= tmpScn AND 
                    restoreRangeTab(i).highScn >= tmpScn AND 
                    restoreRangeTab(i).isValidRange = TRUE AND 
                    isActnFound(i) = FALSE) THEN
 
                   deb(DEB_IN, 'backup belongs to ' || to_char(i+1) ||
                               '-th range' );
                   isActnFound(i) := TRUE;
--
--
--
--
--
                   IF (tmpScn >= restoreRangeTab(i).lowScn AND
                       (NOT (canCreateDf    AND 
                             restoreRangeTab(i).startScn <= dfCreateSCN AND
                             restoreRangeTab(i).highScn  >= dfCreateSCN))) THEN
                      restoreRangeTab(i).lowScn := tmpScn;
                      restoreRangeTab(i).lowTime := tmpTime;
                      restoreRangeTab(i).lowDbIncKey   := tmpDbIncKey;
                      restoreRangeTab(i).lowRlgScn     := tmpRlgScn;
                      restoreRangeTab(i).lowRlgTime    := tmpRlgTime;
                      deb(DEB_IN, 'updating lowscn to ' || to_char(tmpScn));
                   ELSE
                      deb(DEB_IN, 'not updating lowscn');
                   END IF;
 
                   IF (tmpScn < restoreRangeTab(i).rcvStartScn) THEN
                      restoreRangeTab(i).rcvStartScn   := tmpScn;
                      restoreRangeTab(i).rcvStartTime  := tmpTime;
                      deb(DEB_IN, 'updating media rcv scn to ' || 
                                  to_char(tmpScn));
                   ELSE
                      deb(DEB_IN, 'not updating media rcv scn');
                   END IF;
                END IF;
               
--
--
--
--
--
--
 
                IF (canCreateDf  AND
                    restoreRangeTab(i).startScn <= dfCreateSCN AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE) THEN
                   deb(DEB_IN, 'creation scn belongs to ' || to_char(i+1) || 
                               '-th range. Marking the action to True');
                   isActnFound(i) := TRUE;
                   
                   IF (dfCreateSCN < restoreRangeTab(i).rcvStartScn AND
                       restoreRangeTab(i).highScn  >= dfCreateSCN) THEN
                      restoreRangeTab(i).rcvStartScn   := dfCreateSCN;
                      restoreRangeTab(i).rcvStartTime  := dfRec.dfCreationTime;
                      deb(DEB_IN, 'updating media rcv scn to DF createscn ' || 
                                  to_char(dfCreateSCN));
                   END IF;
                ELSIF ( NOT canCreateDf AND 
                        restoreRangeTab(i).highScn <  dfCreateSCN AND
                        restoreRangeTab(i).isValidRange = TRUE AND
                        isActnFound(i) = FALSE) THEN
                   deb(DEB_IN, 'Df non-creatable. Restore range highscn '||
                               restoreRangeTab(i).highScn || ' less than df' ||
                               'creation scn ' || dfCreateSCN || '.Marking ' ||
                               to_char(i+1) || '-th range to true');
                   isActnFound(i) := TRUE;
                END IF;
                i := i + 1;
             END LOOP;
 
--
--
          ELSIF (dfCreation = TRUE#) THEN
             tmpScn  := dfRec.dfCreationSCN;
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= tmpScn AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE) THEN
 
                   deb(DEB_IN, 'creation scn belongs to ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
 
                END IF;
                i := i + 1;
             END LOOP;
 
--
--
--
          ELSIF (dfRec.dfNumber > 1 and offlnRngFound = TRUE#) THEN
             deb(DEB_IN, 'offline range from scn = ' || 
                         to_char(rcvRec.fromSCN_act) ||
                         'to scn = ' || to_char(rcvRec.toSCN_act));
--
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn <= rcvRec.toSCN_act AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE AND
                    rcvRec.fromSCN_act <= lastBkupScn) THEN
 
                   deb(DEB_IN, 'offline range belongs to ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
 
                END IF;
                i := i + 1;
             END LOOP;
          END IF;
 
--
          IF (dropScnExist = TRUE) THEN
             i := 0;
             WHILE i < logRangeCount LOOP
                IF (restoreRangeTab(i).startScn >= dropScn AND
                    restoreRangeTab(i).isValidRange = TRUE AND
                    isActnFound(i) = FALSE) THEN
 
                   deb(DEB_IN, 'file has been dropped before ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
 
                ELSIF (restoreRangeTab(i).startScn < dropScn AND
                       restoreRangeTab(i).highScn > dropScn AND
                       restoreRangeTab(i).isValidRange = TRUE AND
                       isActnFound(i) = FALSE) THEN
                   deb(DEB_IN, 'file has been dropped in ' ||
                               to_char(i+1) || '-th range' );
                   isActnFound(i) := TRUE;
                   restoreRangeTab(i).lowScn        := dropScn; 
                   restoreRangeTab(i).lowTime       := dropTime;
                   restoreRangeTab(i).lowDbIncKey   := dropDbIncKey;
                   restoreRangeTab(i).lowRlgScn     := dropRlgScn;
                   restoreRangeTab(i).lowRlgTime    := dropRlgTime;
                   deb(DEB_IN, 'updating media low scn to ' || dropScn);
                END IF;
                i := i + 1;
             END LOOP;
          END IF;
      END LOOP;
 
--
--
      i := 0;
      WHILE i < logRangeCount 
      LOOP
         IF (isActnFound(i) = FALSE) THEN
            restoreRangeTab(i).isValidRange := FALSE;
         END IF;
         i := i + 1;
      END LOOP;
 
--
--
    ELSE
      i := 0;
      WHILE i < logRangeCount LOOP
          restoreRangeTab(i).isValidRange := FALSE;
          i := i + 1;
      END LOOP;
      EXIT;
    END IF;
--
  END LOOP;
 
--
  findControlfileBackup(FALSE, TRUE, TRUE, 0, 0);
 
  IF (getBS_status = SUCCESS) THEN
  LOOP
     EXIT WHEN getRecStackCount = 0;
     rcvRecPop(rcvRec);
       
--
     tmpScn := rcvRec.toSCN_act;
     deb(DEB_IN, 'cf backup scn = ' || to_char(tmpScn));
 
--
     i := 0;
     WHILE i < logRangeCount
     LOOP
        IF (restoreRangeTab(i).startScn <= tmpScn AND
             restoreRangeTab(i).highScn >= tmpScn AND 
               restoreRangeTab(i).cfBkupFound = FALSE AND
                restoreRangeTab(i).isValidRange = TRUE) THEN
 
            deb(DEB_IN, 'cf backup belongs to ' || to_char(i+1) ||
                        '-th range' );
            restoreRangeTab(i).cfBkupFound := TRUE;
--
--
            IF (restoreRangeTab(i).lowScn < tmpScn) THEN
                restoreRangeTab(i).lowScn := tmpScn;
                deb(DEB_IN, 'updating lowscn to ' || to_char(tmpScn));
            END IF;
--
--
        END IF;
        i := i + 1;
     END LOOP;
  END LOOP;       
  END IF;
 
--
--
  i := 0;
  WHILE i < logRangeCount
  LOOP
     IF (restoreRangeTab(i).cfBkupFound = FALSE) THEN
        restoreRangeTab(i).isValidRange := FALSE;
     END IF;
     i := i + 1;
  END LOOP;
 
  resetLocalOrsSiteKey;
  deb(DEB_EXIT, 'with TRUE');
  RETURN TRUE;
 
EXCEPTION
  WHEN OTHERS THEN
    resetLocalOrsSiteKey;
    deb(DEB_EXIT, 'with FALSE');
    RETURN FALSE;
 
END getRestoreRangeSet;
 
--
PROCEDURE sv_setSessionKey(skey IN NUMBER) IS
BEGIN
   session_key := skey;
   deb(DEB_PRINT, 'Session Key Filter='|| session_key);
END;
FUNCTION sv_getSessionKey RETURN NUMBER IS
BEGIN
   return session_key;
END;
 
--
PROCEDURE sv_setSessionTimeRange(fromTime IN DATE, untilTime IN DATE) IS
BEGIN
  session_fromTime := fromTime;
  session_untilTime := untilTime;
  deb(DEB_PRINT, 'Session Time range Filter='||
                 to_char(session_fromTime, 'MM/DD/YYYY HH24:MI:SS')  ||
                 ' To ' ||
                 to_char(session_untilTime, 'MM/DD/YYYY HH24:MI:SS'));
END;
FUNCTION sv_getSessionfromTimeRange RETURN DATE IS
BEGIN
   return session_fromtime;
END;
FUNCTION sv_getSessionUntilTimeRange RETURN DATE IS
BEGIN
   return session_untilTime;
END;
 
--
PROCEDURE getRetentionPolicy(recovery_window OUT number
                            ,redundancy      OUT number)
IS
  conf_value             varchar2(512);
  conf_name              varchar2(512) := 'RETENTION POLICY';
  conf#                  binary_integer;
  l1                     binary_integer;
  l2                     binary_integer;
  l3                     binary_integer;
BEGIN
 
  deb(DEB_ENTER, 'getRetentionPolicy');
 
  recovery_window := 0;
  redundancy      := 1;
 
  IF (findConfig_c%ISOPEN) THEN
    CLOSE findConfig_c;
  END IF;
  OPEN findConfig_c(conf_name, conf_value, null);
  FETCH findConfig_c INTO conf#, conf_name, conf_value;
  IF (NOT findConfig_c%NOTFOUND) THEN
    IF (conf_value like '%RECOVERY WINDOW%')
    THEN
      l1 := length('TO RECOVERY WINDOW OF ');
      l2 := length(' DAYS');
      l3 := length(conf_value);
      recovery_window := to_number(substr(conf_value, l1, l3-l2-l1+1));
    END IF;
    IF (conf_value like '%REDUNDANCY%')
    THEN
      l1 := length('TO REDUNDANCY ');
      l2 := length(conf_value);
      redundancy := to_number(substr(conf_value, l1, l2-l1+1));
    END IF;
    IF (conf_value like '%NONE%')
    THEN
--
--
      redundancy := 0;
      recovery_window := 0;
    END IF;
  END IF;
  CLOSE findConfig_c;
 
  deb(DEB_IN, 'recovery window = '||recovery_window);
  deb(DEB_IN, 'redundancy      = '||redundancy);
 
  deb(DEB_EXIT, 'getRetentionPolicy');
 
END getRetentionPolicy;
 
--
PROCEDURE translateDataFileCopy(
   duplicates   IN number
  ,statusMask   IN binary_integer
  ,onlyrdf      IN binary_integer
  ,pluginSCN    IN number DEFAULT 0)
IS
BEGIN
   validateState(getDatafileCopyCursor);
 
--
--
--
--
   OPEN findDatafileBackup_c(
                         sourcemask   => imageCopy_con_t,
                         reset_scn    => this_reset_scn,
                         reset_time   => this_reset_time,
                         statusMask   => statusMask,
                         duplicates   => duplicates,
                         onlyrdf      => onlyrdf,
                         pluginSCN    => pluginSCN
                         );
 
   getDatafileCopyCursor            := 'findDatafileBackup_c';
   getDataFileCopyNoRows.error      := NULL;
   getDataFileCopyNoRows.msg        := 'Datafile copy does not exists';
   getDataFileCopyDuplicates        := duplicates;
   getDataFileCopyLast.dfNumber_obj := NULL;
   getDataFileCopySingleRow         := FALSE;
END translateDataFileCopy;
 
--
--
--
PROCEDURE getDfBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,recentbackup    IN   boolean  DEFAULT FALSE
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof         boolean := FALSE;
   local       bhistoryRec_t;
   icount      number  := 0;
   locCreSCN   number;
   lastCreSCN  number;
   locRlgSCN   number;
   lastRlgSCN  number;
   locRlgTime  date;
   lastRlgTime date;
   locCkpSCN   number;
   lastCkpSCN  number;
BEGIN
   deb(DEB_ENTER, 'getDfBackupHistory');
 
   IF (first) THEN
      getLastBackupHistory.dfNumber := NULL;
      IF (dfBackupHistory_c2%ISOPEN) THEN
         CLOSE dfBackupHistory_c2;
      END IF;
      deb(DEB_OPEN, 'dfBackupHistory_c2');
      OPEN dfBackupHistory_c2(device_type => backedUpDev,
                              cmd         => doingCmd,
                              ktag        => keepTag,
                              pattern1    => startWithPattern(toDest1),
                              pattern2    => startWithPattern(toDest2),
                              pattern3    => startWithPattern(toDest3),
                              pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL AND
       (recentbackup OR
        getLastBackupHistory.ckp_scn = getLastBackupHistory.stop_scn)) THEN
--
      icount := 1;
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL) THEN
      deb(DEB_IN, 'with file# = ' || to_char(getLastBackupHistory.dfNumber) ||
                  ' icount= '     || to_char(icount) ||
                  ' ckp_scn= '    || to_char(getLastBackupHistory.ckp_scn) ||
                  ' compTime= '   || to_char(getLastBackupHistory.compTime,
                                            'DD-MON-RR HH24:MI:SS'));
   END IF;
 
   IF (NOT dfBackupHistory_c2%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
<<nextRow>>
   FETCH dfBackupHistory_c2 INTO local;
 
   IF (dfBackupHistory_c2%NOTFOUND) THEN
      CLOSE dfBackupHistory_c2;
      eof := TRUE;
   ELSE
      IF (local.pluginSCN != 0) THEN
         locCreSCN   := local.pluginSCN;
         locRlgSCN   := local.pluginRlgSCN;
         locRlgTime  := local.pluginRlgTime;
         lastCreSCN  := getLastBackupHistory.pluginSCN;
         lastRlgSCN  := getLastBackupHistory.pluginRlgSCN;
         lastRlgTime := getLastBackupHistory.pluginRlgTime;
      ELSE
         locCreSCN   := local.create_scn;
         locRlgSCN   := local.reset_scn;
         locRlgTime  := local.reset_time;
         lastCreSCN  := getLastBackupHistory.create_scn;
         lastRlgSCN  := getLastBackupHistory.reset_scn;
         lastRlgTime := getLastBackupHistory.reset_time;
      END IF;
 
      IF (local.pluggedRonly = 1) THEN
         locCkpSCN  := local.pluginSCN;
         lastCkpSCN := getLastBackupHistory.pluginSCN;
      ELSE
         locCkpSCN  := local.ckp_scn;
         lastCkpSCN := getLastBackupHistory.ckp_scn;
      END IF;
 
      IF (getLastBackupHistory.dfNumber IS NULL OR
          (getLastBackupHistory.dfNumber = local.dfNumber AND
           lastCreSCN                    = locCreSCN      AND
           lastRlgSCN                    = locRlgSCN      AND
           lastRlgTime                   = locRlgTime)) THEN
         IF (recentbackup) THEN
            IF (getLastBackupHistory.dfNumber IS NULL OR
                locCkpSCN = lastCkpSCN) THEN
--
               icount := icount + 1;
            END IF;
         ELSIF (local.ckp_scn = local.stop_scn OR local.pluggedRonly = 1) THEN
--
--
            icount := icount + 1;          -- bump the number of copies
         END IF;
 
         IF (getLastBackupHistory.dfNumber IS NULL) THEN
            getLastBackupHistory := local;     -- remember the recent backup
         END IF;
         deb(DEB_IN, 'with file# = ' || to_char(local.dfNumber) ||
                     ' icount= '     || to_char(icount) ||
                     ' ckp_scn= '    || to_char(local.ckp_scn) ||
                     ' compTime= '   || to_char(local.compTime,
                                               'DD-MON-RR HH24:MI:SS'));
         goto nextRow;
      END IF;
   END IF;
 
--
--
 
<<lastRow>>
   IF (eof AND getLastBackupHistory.dfNumber IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec             := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.dfNumber := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT, 'with file# = ' || to_char(bhistoryRec.dfNumber) ||
                 ' nbackups= '   || to_char(bhistoryRec.nbackups) ||
                 ' ckp_scn= '    || to_char(bhistoryRec.ckp_scn) ||
                 ' compTime= '   || to_char(bhistoryRec.compTime,
                                           'DD-MON-RR HH24:MI:SS'));
END getDfBackupHistory;
 
PROCEDURE getDcBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof         boolean := FALSE;
   local       bhistoryRec_t;
   icount      number  := 0;
   locCreSCN   number;
   lastCreSCN  number;
   locRlgSCN   number;
   lastRlgSCN  number;
   locRlgTime  date;
   lastRlgTime date;
   locCkpSCN   number;
   lastCkpSCN  number;
BEGIN
   deb(DEB_ENTER, 'getDcBackupHistory');
 
   IF (first) THEN
      getLastBackupHistory.dfNumber := NULL;
      IF (dcBackupHistory_c%ISOPEN) THEN
         CLOSE dcBackupHistory_c;
      END IF;
      deb(DEB_OPEN, 'dcBackupHistory_c');
      OPEN dcBackupHistory_c(device_type => backedUpDev,
                             cmd         => doingCmd,
                             ktag        => keepTag,
                             pattern1    => startWithPattern(toDest1),
                             pattern2    => startWithPattern(toDest2),
                             pattern3    => startWithPattern(toDest3),
                             pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL AND
       getLastBackupHistory.ckp_scn = getLastBackupHistory.stop_scn) THEN
      icount := 1;
   END IF;
 
   IF (NOT dcBackupHistory_c%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
   IF (getLastBackupHistory.dfNumber IS NOT NULL) THEN
      deb(DEB_IN, 'with file# = ' || to_char(getLastBackupHistory.dfNumber) ||
                  ' create_scn= ' || to_char(getLastBackupHistory.create_scn) ||
                  ' reset_scn= '  || to_char(getLastBackupHistory.reset_scn) ||
                  ' reset_time= ' || to_char(getLastBackupHistory.reset_time,
                                            'DD-MON-RR HH24:MI:SS') ||
                  ' ckp_scn= '    || to_char(getLastBackupHistory.ckp_scn) ||
                  ' stop_scn= '   || to_char(getLastBackupHistory.stop_scn) ||
                  ' nbackups= '   || to_char(getLastBackupHistory.nbackups) ||
                  ' compTime= '   || to_char(getLastBackupHistory.compTime,
                                            'DD-MON-RR HH24:MI:SS'));
   END IF;
 
<<nextRow>>
   FETCH dcBackupHistory_c INTO local;
 
   IF (dcBackupHistory_c%NOTFOUND) THEN
      CLOSE dcBackupHistory_c;
      eof := TRUE;
   ELSE
      IF (local.pluginSCN != 0) THEN
         locCreSCN   := local.pluginSCN;
         locRlgSCN   := local.pluginRlgSCN;
         locRlgTime  := local.pluginRlgTime;
         lastCreSCN  := getLastBackupHistory.pluginSCN;
         lastRlgSCN  := getLastBackupHistory.pluginRlgSCN;
         lastRlgTime := getLastBackupHistory.pluginRlgTime;
      ELSE
         locCreSCN   := local.create_scn;
         locRlgSCN   := local.reset_scn;
         locRlgTime  := local.reset_time;
         lastCreSCN  := getLastBackupHistory.create_scn;
         lastRlgSCN  := getLastBackupHistory.reset_scn;
         lastRlgTime := getLastBackupHistory.reset_time;
      END IF;
 
      IF (getLastBackupHistory.dfNumber IS NULL OR
          (getLastBackupHistory.dfNumber     = local.dfNumber     AND
           lastCreSCN                        = locCreSCN          AND
           getLastBackupHistory.ckp_scn      = local.ckp_scn      AND
           getLastBackupHistory.ckp_time     = local.ckp_time     AND
           getLastBackupHistory.pluggedRonly = local.pluggedRonly AND
           lastRlgSCN                        = locRlgSCN          AND
           lastRlgTime                       = locRlgTime)) THEN
         IF (local.ckp_scn = local.stop_scn OR local.pluggedRonly = 1) THEN
--
            icount  := icount + 1;          -- bump the number of copies
         END IF;
         getLastBackupHistory := local;     -- remember the last copy
 
         deb(DEB_IN, 'with file# = ' || to_char(local.dfNumber) ||
                     ' create_scn= ' || to_char(local.create_scn) ||
                     ' reset_scn= '  || to_char(local.reset_scn) ||
                     ' reset_time= ' || to_char(local.reset_time,
                                               'DD-MON-RR HH24:MI:SS') ||
                     ' ckp_scn= '    || to_char(local.ckp_scn) ||
                     ' stop_scn= '   || to_char(local.stop_scn) ||
                     ' nbackups= '   || to_char(local.nbackups) ||
                     ' compTime= '   || to_char(local.compTime,
                                               'DD-MON-RR HH24:MI:SS'));
         goto nextRow;
      END IF;
   END IF;
 
--
--
 
<<lastRow>>
   IF (eof AND getLastBackupHistory.dfNumber IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec             := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.dfNumber := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT, 'with file# = ' || to_char(bhistoryRec.dfNumber) ||
                 ' create_scn= ' || to_char(bhistoryRec.create_scn) ||
                 ' reset_scn= '  || to_char(bhistoryRec.reset_scn) ||
                 ' reset_time= ' || to_char(bhistoryRec.reset_time,
                                           'DD-MON-RR HH24:MI:SS') ||
                 ' ckp_scn= '    || to_char(bhistoryRec.ckp_scn) ||
                 ' stop_scn= '   || to_char(bhistoryRec.stop_scn) ||
                 ' nbackups= '   || to_char(bhistoryRec.nbackups) ||
                 ' compTime= '   || to_char(bhistoryRec.compTime,
                                           'DD-MON-RR HH24:MI:SS'));
END getDcBackupHistory;
 
PROCEDURE getAlBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof       boolean := FALSE;
   local     bhistoryRec_t;
   icount    number  := 0;
BEGIN
   deb(DEB_ENTER, 'getAlBackupHistory');
 
   IF (first) THEN
      getLastBackupHistory.logThread := NULL;
      IF (alBackupHistory_c2%ISOPEN) THEN
         CLOSE alBackupHistory_c2;
      END IF;
      deb(DEB_OPEN, 'alBackupHistory_c2');
      OPEN alBackupHistory_c2(device_type => backedUpDev,
                              cmd         => doingCmd,
                              ktag        => keepTag,
                              pattern1    => startWithPattern(toDest1),
                              pattern2    => startWithPattern(toDest2),
                              pattern3    => startWithPattern(toDest3),
                              pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.logThread IS NOT NULL) THEN
      icount := 1;
   END IF;
 
   IF (NOT alBackupHistory_c2%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
<<nextRow>>
   FETCH alBackupHistory_c2 INTO local;
 
   IF (alBackupHistory_c2%NOTFOUND) THEN
      CLOSE alBackupHistory_c2;
      eof := TRUE;
   ELSIF (getLastBackupHistory.logThread IS NULL OR
          (getLastBackupHistory.logThread = local.logThread AND
           getLastBackupHistory.logSequence = local.logSequence AND
           getLastBackupHistory.logTerminal = local.logTerminal AND
           getLastBackupHistory.next_scn = local.next_scn AND
           getLastBackupHistory.reset_scn = local.reset_scn AND
           getLastBackupHistory.reset_time = local.reset_time)) THEN
      icount  := icount + 1;             -- bump the number of copies
      getLastBackupHistory := local;     -- remember the last copy
 
      deb(DEB_IN,
            'with (reset_scn, reset_time, thread#, sequence#, terminal)=(' ||
            to_char(local.reset_scn)  || ',' ||
            to_char(local.reset_time,'DD-MON-RR HH24:MI:SS')  || ',' ||
            to_char(local.logThread)  || ',' ||
            to_char(local.logSequence) || ',' ||
            to_char(local.logTerminal) || ')' ||
            ' nbackups= ' || local.nbackups||
            ' compTime= '   || to_char(local.compTime,
                                       'DD-MON-RR HH24:MI:SS'));
      goto nextRow;
   END IF;
 
--
--
 
<<lastRow>>
   IF (eof AND getLastBackupHistory.logThread IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.logThread := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT,
            'with (reset_scn, reset_time, thread#, sequence#, terminal)=(' ||
            to_char(bhistoryRec.reset_scn)  || ',' ||
            to_char(bhistoryRec.reset_time,'DD-MON-RR HH24:MI:SS')  || ',' ||
            to_char(bhistoryRec.logThread)  || ',' ||
            to_char(bhistoryRec.logSequence) || ',' ||
            to_char(bhistoryRec.logTerminal) || ')' ||
            ' nbackups= ' || bhistoryRec.nbackups||
            ' compTime= '   || to_char(bhistoryRec.compTime, 
                                       'DD-MON-RR HH24:MI:SS'));
END getAlBackupHistory;
 
PROCEDURE getBsBackupHistory(
   backedUpDev     IN   varchar2
  ,first           IN   boolean
  ,set_stamp       IN   number  DEFAULT NULL
  ,set_count       IN   number  DEFAULT NULL
  ,bhistoryRec     OUT  NOCOPY bhistoryRec_t
  ,doingCmd        IN   varchar2 DEFAULT NULL
  ,keepTag         IN   varchar2 DEFAULT NULL
  ,toDest1         IN   varchar2 DEFAULT NULL
  ,toDest2         IN   varchar2 DEFAULT NULL
  ,toDest3         IN   varchar2 DEFAULT NULL
  ,toDest4         IN   varchar2 DEFAULT NULL)
IS
   eof       boolean := FALSE;
   local     bhistoryRec_t;
   icount    number  := 0;
   bpRec     bpRec_t;
BEGIN
   deb(DEB_ENTER, 'getBsBackupHistory');
 
   IF (set_stamp IS NOT NULL AND set_count IS NOT NULL) THEN
      IF (NOT first) THEN
         deb(DEB_EXIT, 'with: no_data_found');
         RAISE no_data_found;
      END IF;
 
      bpRec.setStamp := set_stamp;
      bpRec.setCount := set_count;
      getBackupHistory(bpRec            => bpRec,
                       backedUpDev      => backedUpDev,
                       nbackupsFlag     => 1,
                       bscompletionFlag => 1,
                       nbackups         => bhistoryRec.nbackups,
                       bscompletion     => bhistoryRec.compTime,
                       todest1          => toDest1,
                       todest2          => toDest2,
                       todest3          => todest3,
                       todest4          => todest4);
 
      IF (bhistoryRec.nbackups = 0) THEN
         deb(DEB_EXIT, 'with: no_data_found');
         RAISE no_data_found;
      END IF;
 
      bhistoryRec.setStamp := set_stamp;
      bhistoryRec.setCount := set_count;
      deb(DEB_EXIT, 'with set_stamp = ' || to_char(bhistoryRec.setStamp) ||
                    ' set_count = ' || to_char(bhistoryRec.setCount) ||
                    ' nbackups= '  || to_char(bhistoryRec.nbackups)  ||
                    ' compTime= '  || to_char(bhistoryRec.compTime,
                                              'DD-MON-RR HH24:MI:SS'));
      RETURN;
   END IF;
 
   IF (first) THEN
      getLastBackupHistory.setStamp := NULL;
      IF (bsBackupHistory_c2%ISOPEN) THEN
         CLOSE bsBackupHistory_c2;
      END IF;
      deb(DEB_OPEN, 'bsBackupHistory_c2');
      OPEN bsBackupHistory_c2(device_type => backedUpDev,
                              cmd         => doingCmd,
                              ktag        => keepTag,
                              pattern1    => startWithPattern(toDest1),
                              pattern2    => startWithPattern(toDest2),
                              pattern3    => startWithPattern(toDest3),
                              pattern4    => startWithPattern(toDest4));
   END IF;
 
   IF (getLastBackupHistory.setStamp IS NOT NULL) THEN
      icount := 1;
   END IF;
 
   IF (NOT bsBackupHistory_c2%ISOPEN) THEN
      eof := TRUE;
      goto lastRow;
   END IF;
 
<<nextRow>>
   FETCH bsBackupHistory_c2 INTO local;
 
   IF (bsBackupHistory_c2%NOTFOUND) THEN
      CLOSE bsBackupHistory_c2;
      eof := TRUE;
   ELSIF (getLastBackupHistory.setStamp IS NULL OR
          (getLastBackupHistory.setStamp = local.setStamp AND
           getLastBackupHistory.setCount = local.setCount)) THEN
      icount := icount + 1;           -- bump the number of copies
      getLastBackupHistory := local;  -- remember the last copy
      goto nextRow;
   END IF;
 
--
--
<<lastRow>>
   IF (eof AND getLastBackupHistory.setStamp IS NULL) THEN
      deb(DEB_EXIT, 'with: no_data_found');
      RAISE no_data_found;
   END IF;
 
--
--
   bhistoryRec := getLastBackupHistory;
   bhistoryRec.nbackups    := icount;
 
   IF (eof) THEN
      getLastBackupHistory.setStamp := NULL; -- for next time to raise no_data
   ELSE
--
      getLastBackupHistory := local;
   END IF;
 
   deb(DEB_EXIT, 'with set_stamp = ' || to_char(bhistoryRec.setStamp) ||
                 'set_count = ' || to_char(bhistoryRec.setCount) ||
                 ' nbackups= '  || to_char(bhistoryRec.nbackups)  ||
                 ' compTime= '  || to_char(bhistoryRec.compTime,
                                           'DD-MON-RR HH24:MI:SS'));
END getBsBackupHistory;
 
--
--
 
PROCEDURE getBackupHistory(
   dfRec            IN  dfRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date)
IS
   local bhistoryRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupHistory');
 
   nbackups := 0;
   bscompletion := NULL;
 
--
   IF ((nbackupsFlag != 1  OR backedUpDev IS NULL) AND
       bscompletionFlag != 1) THEN
      deb(DEB_EXIT, 'with not interested');
      RETURN;
   END IF;
 
   IF (dfBackupHistory_c1%ISOPEN) THEN
      CLOSE dfBackupHistory_c1;
   END IF;
 
   OPEN dfBackupHistory_c1(file#        => dfRec.dfNumber
                          ,crescn       => dfRec.dfCreationSCN
                          ,device_type  => backedUpDev);
<<nextRow>>
   FETCH dfBackupHistory_c1 INTO local;
   IF (dfBackupHistory_c1%NOTFOUND) THEN
      CLOSE dfBackupHistory_c1;
   ELSE
      IF (local.reset_scn  = this_reset_scn AND
          local.reset_time = this_reset_time AND
          local.ckp_scn = dfRec.stopSCN) THEN
         nbackups := nbackups + 1;
      END IF;
      bscompletion := local.compTime;
      goto nextRow;
   END IF;
   deb(DEB_EXIT);
END getBackupHistory;
 
--
--
 
PROCEDURE getBackupHistory(
   alRec            IN  alRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date)
IS
   local bhistoryRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupHistory');
 
   nbackups := 0;
   bscompletion := NULL;
 
--
   IF ((nbackupsFlag != 1  OR backedUpDev IS NULL) AND
       bscompletionFlag != 1) THEN
      deb(DEB_EXIT, 'with not interested');
      RETURN;
   END IF;
 
   IF (alBackupHistory_c1%ISOPEN) THEN
      CLOSE alBackupHistory_c1;
   END IF;
 
   OPEN alBackupHistory_c1(thread#      => alRec.thread
                          ,sequence#    => alRec.sequence
                          ,device_type  => backedUpDev);
<<nextRow>>
   FETCH alBackupHistory_c1 INTO local;
   IF (alBackupHistory_c1%NOTFOUND) THEN
      CLOSE alBackupHistory_c1;
   ELSE
      nbackups := nbackups + 1;
      bscompletion := local.compTime;
      goto nextRow;
   END IF;
 
   deb(DEB_EXIT);
END getBackupHistory;
 
--
PROCEDURE getBackupHistory(
   bpRec            IN  bpRec_t
  ,backedUpDev      IN  varchar2
  ,nbackupsFlag     IN  number
  ,bscompletionFlag IN  number
  ,nbackups         OUT number
  ,bscompletion     OUT date
  ,todest1          IN  varchar2 DEFAULT NULL
  ,todest2          IN  varchar2 DEFAULT NULL
  ,todest3          IN  varchar2 DEFAULT NULL
  ,todest4          IN  varchar2 DEFAULT NULL)
IS
   local bhistoryRec_t;
BEGIN
   deb(DEB_ENTER, 'getBackupHistory');
 
   nbackups := 0;
   bscompletion := NULL;
 
--
   IF ((nbackupsFlag != 1  OR backedUpDev IS NULL) AND
       bscompletionFlag != 1) THEN
      deb(DEB_EXIT, 'with not interested');
      RETURN;
   END IF;
 
   IF (bsBackupHistory_c1%ISOPEN) THEN
      CLOSE bsBackupHistory_c1;
   END IF;
 
   OPEN bsBackupHistory_c1(set_stamp    => bpRec.setStamp
                          ,set_count    => bpRec.setCount
                          ,device_type  => backedUpDev
                          ,pattern1     => startWithPattern(toDest1)
                          ,pattern2     => startWithPattern(toDest2)
                          ,pattern3     => startWithPattern(toDest3)
                          ,pattern4     => startWithPattern(toDest4));
<<nextRow>>
   FETCH bsBackupHistory_c1 INTO local;
   IF (bsBackupHistory_c1%NOTFOUND) THEN
      CLOSE bsBackupHistory_c1;
   ELSE
      nbackups := nbackups + 1;
      bscompletion := local.compTime;
      goto nextRow;
   END IF;
 
   deb(DEB_EXIT);
END getBackupHistory;
 
--
--
--
--
PROCEDURE findControlfileBackup(
   allCopies      IN boolean default FALSE,
   allBackups     IN boolean default FALSE,
   allIncarnation IN boolean default FALSE,
   fromSCN        IN number  default 0,
   pdbId          IN number  default 0)
IS
   cfrec        rcvRec_t;
   tag          varchar2(32);
   valRC        binary_integer;
   validateRec  validBackupSetRec_t;
   currentInc   number;
   cfUntilScn   number;
   cfRlgScn     number;
BEGIN
   deb(DEB_ENTER, 'findControlfileBackup');
   validateState(null);
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   IF onlyStandby IS NULL THEN
      deb(DEB_IN, 'onlyStandby is set to NULL ');
   ELSIF onlyStandby = TRUE# THEN
      deb(DEB_IN, 'onlyStandby is set to TRUE ');
   ELSE
      deb(DEB_IN, 'onlyStandby is set to FALSE ');
   END IF;
 
   cfUntilScn := get_cfUntilScn();
   deb(DEB_IN, 'cfUntilScn = ' || nvl(to_char(cfUntilScn), 'NULL'));
 
   IF (allIncarnations = TRUE#) THEN
      deb(DEB_IN, 'allIncarnations = TRUE# ');
      currentInc := FALSE#;                       -- don't care about dbinc_key
      cfRlgScn   := getPointInTimeInc(cfUntilScn);
   ELSE
      deb(DEB_IN, 'allIncarnations <> TRUE# ');
      currentInc := TRUE#;
      cfRlgScn   := this_reset_scn;
   END IF;
   deb(DEB_IN, 'cfRlgScn= ' || nvl(to_char(cfRlgScn), 'NULL'));
 
--
   OPEN findControlfileBackup_c(sourcemask         => restoreSource,
                                currentIncarnation => currentInc,
                                tag                => restoreTag,
                                untilSCN           => cfUntilScn,
                                statusMask         => BSavailable,
                                needstby           => onlyStandby,
                                fromSCN            => fromSCN);
 
--
--
--
   findControlfileBackupCursor := TRUE;
 
--
   resetthisBackupAge;
   getBS_status := NULL;
 
   resetrcvRecStack;
 
   LOOP
      valRC := NULL;
 
      FETCH findControlfileBackup_c
         INTO cfrec;
 
      EXIT WHEN findControlfileBackup_c%NOTFOUND ;
 
      IF (cfrec.type_con = imageCopy_con_t) THEN
         deb(DEB_IN, 'findControlfileBackup found a controlfilecopy:');
         IF (diskDevice) THEN
            valRC := SUCCESS;
         ELSE
            valRC := AVAILABLE;
         END IF;
      ELSIF (cfrec.type_con = backupSet_con_t) THEN
         deb(DEB_IN, 'findControlfileBackup found a controlfile backup:');
         valRC := validateBackupSet(
            backupSetRec           => cfrec,
            tag                    => restoreTag,
            tagMatchRequired       => TRUE,
            checkDeviceIsAllocated => TRUE,
            availableMask          => BSavailable,
            validRec               => validateRec);
      ELSIF (cfrec.type_con = proxyCopy_con_t) THEN
         deb(DEB_IN, 'findControlfileBackup found a controlfile proxy copy:');
         IF (restoreTag is not NULL AND cfrec.tag_con != restoreTag) THEN
--
--
--
            deb(DEB_IN, 'tag does not match');
            valRC := UNAVAILABLE;
         ELSIF (anyDevice = TRUE# OR
                isDeviceTypeAllocated(cfrec.deviceType_con) = TRUE#) THEN
            valRC := SUCCESS;
         ELSE
            valRC := AVAILABLE;
         END IF;
      END IF;
 
--
--
--
--
      IF (cfRlgScn != cfrec.rlgSCN_act AND valRC IS NOT NULL) THEN
         deb(DEB_IN, 'rlgSCN_act= ' || nvl(to_char(cfrec.rlgSCN_act), 'NULL'));
         valRC := NULL;
         IF (cfRlgScn > cfrec.rlgSCN_act AND cfRlgScn > cfrec.toSCN_act) THEN
            deb(DEB_IN, 'findControlfileBackup belongs to parent incarnation');
            EXIT;
         ELSE
            deb(DEB_IN, 'findControlfileBackup belongs to orphan incarnation');
         END IF;
      END IF;
 
--
      IF (valRC IS NOT NULL AND pdbId > 1) THEN
         IF (isPdbScnOrphan(0, cfrec.toSCN_act, 0, pdbId)) THEN
            deb(DEB_IN, 'findControlfileBackup in orphan pdb sub inc');
            valRC := NULL;
         END IF;
      END IF;
 
   <<addAnother>>
      IF (getBS_status IS NULL AND valRC = AVAILABLE) THEN
         getBS_status := valRC;
      END IF;
 
      IF (debug) THEN
         printRcvRec(cfrec);
      END IF;
 
      IF (valRC = SUCCESS) THEN
         IF (thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
            thisBackupAge  := thisBackupAge + 1;
         ELSE
            deb(DEB_IN, ' Added cfrec:');
 
            IF (cfrec.type_con = backupSet_con_t) THEN
               cfrec.tag_con        := validateRec.tag;
               cfrec.deviceType_con := validateRec.deviceType;
               cfrec.copyNumber_con := validateRec.copyNumber;
            END IF;
 
            rcvRecPush(cfrec);     -- add record for this action
 
            getBS_status := SUCCESS;
 
            IF (allCopies and cfrec.type_con = backupSet_con_t) THEN
--
--
--
               valRC := validateBackupSet0(
                                      tag                    => restoreTag,
                                      tagMatchRequired       => TRUE,
                                      checkDeviceIsAllocated => TRUE,
                                      validRec               => validateRec);
               IF (valRC = SUCCESS) THEN
                  GOTO addAnother;
               END IF;
            END IF;
            IF (allBackups = FALSE) THEN
                EXIT;
            END IF;
         END IF;
      END IF;
   END LOOP;
 
   CLOSE findControlfileBackup_c;
 
   IF (getBS_status = SUCCESS) THEN
      deb(DEB_EXIT, 'with: SUCCESS');
   ELSIF (getBS_status = AVAILABLE) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
   ELSE
      getBS_status := UNAVAILABLE;
      deb(DEB_EXIT, 'with: UNAVAILABLE');
   END IF;
END findControlfileBackup;
 
--
FUNCTION getControlfileBackup(
   rcvRec  OUT NOCOPY rcvRec_t)
RETURN number IS
   local        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getControlfileBackupBackup');
 
   IF (NOT findControlfileBackupCursor) THEN
--
      findControlfileBackup(FALSE, FALSE, FALSE);
      findControlfileBackupCursor := FALSE;
   END IF;
 
   IF (getRecStackCount = 0) THEN
      IF (getBS_status = SUCCESS) THEN
         deb(DEB_EXIT, 'with no more records');
         raise no_data_found;
      ELSIF (getBS_status = AVAILABLE) THEN
         deb(DEB_EXIT, 'with: AVAILABLE');
         RETURN AVAILABLE;
      ELSE
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN UNAVAILABLE;
      END IF;
   END IF;
 
   rcvRecPop(local);
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   deb(DEB_EXIT, 'with: SUCCESS');
   RETURN SUCCESS;
END getControlfileBackup;
 
--
--
--
--
--
--
--
--
--
--
--
PROCEDURE findRangeArchivedLogBackup(
   minthread    IN number
  ,minsequence  IN number
  ,minlowSCN    IN number
  ,maxthread    IN number
  ,maxsequence  IN number
  ,maxlowSCN    IN number
  ,allCopies    IN boolean default FALSE)
IS
   lastrec      rcvRec_t;
   brlrec       rcvRec_t;
   validateRec  validBackupSetRec_t;
   tapebkp      rcvRecTabI_t;-- stack of tape backups
   valRC        number;
   BSstatus     number;      -- status of current backup
   skipped      boolean;
   FUNCTION dupbs(bs1 in rcvRec_t, bs2 in rcvRec_t)
      RETURN BOOLEAN IS
   BEGIN
      IF (bs1.type_con != backupSet_con_t OR
          bs2.type_con != backupSet_con_t) THEN
         RETURN FALSE;
      END IF;
 
      IF (bs1.setStamp_con != bs2.setStamp_con OR
          bs1.setCount_con != bs2.setCount_con) THEN
         RETURN FALSE;
      END IF;
 
      RETURN TRUE;
   END dupbs;
 
   FUNCTION pushTapeBackup(tapebkp in rcvRecTabI_t)
      RETURN BOOLEAN IS
      found boolean := FALSE;
   BEGIN
      deb(DEB_IN, 'looking for tape backups');
      FOR i IN 1..tapebkp.count LOOP
--
         EXIT when (found AND NOT dupbs(tapebkp(i), tapebkp(i-1)));
         IF (thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
--
            IF (i = 1 OR NOT dupbs(tapebkp(i), tapebkp(i-1))) THEN
               thisBackupAge  := thisBackupAge + 1;
            END IF;
         ELSE
            deb(DEB_IN, 'Added tape backup ' || i);
            rcvRecPush(tapebkp(i));
            found := TRUE;
         END IF;
      END LOOP;
      RETURN found;
   END pushTapeBackup;
BEGIN
   deb(DEB_ENTER, 'findRangeArchivedLogBackup');
 
   validateState(null);
   lastrec.logThread_obj := 0;
 
--
--
--
   deb(DEB_OPEN, 'findRangeArcLogBackup');
   OPEN findRangeArcLogBackup(sourcemask         => to_number(null),
                              minthread          => minthread,
                              minsequence        => minsequence,
                              minlowSCN          => minlowSCN,
                              maxthread          => maxthread,
                              maxsequence        => maxsequence,
                              maxlowSCN          => maxlowSCN);
 
 
   resetrcvRecStack;
   tapebkp.delete;
   BSstatus := NULL;
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   LOOP
   <<nextbrlRec>>
      valRC := NULL;
 
      FETCH findRangeArcLogBackup
       INTO brlrec;
 
      IF (findRangeArcLogBackup%NOTFOUND) THEN
--
--
--
         IF (BSstatus IS NULL OR BSstatus != SUCCESS) THEN
            IF (pushTapeBackup(tapebkp)) THEN
               BSstatus := SUCCESS;
            END IF;
         END IF;
 
--
--
         IF (BSstatus = AVAILABLE AND lastrec.logThread_obj != 0) THEN
            deb(DEB_IN, ' Added lastlrec:');
--
--
--
            lastrec.status_con := '*';
            rcvRecPush(lastrec);
         END IF;
         EXIT;
      END IF;
 
--
--
      IF (brlrec.logSequence_obj != lastrec.logSequence_obj OR
          brlrec.logThread_obj   != lastrec.logThread_obj   OR
          brlrec.logRlgSCN_obj   != lastrec.logRlgSCN_obj   OR
          brlrec.logRlgTime_obj  != lastrec.logRlgTime_obj  OR
          brlrec.logLowSCN_obj   != lastrec.logLowSCN_obj   OR
          brlrec.logNextSCN_obj   != lastrec.logNextSCN_obj) THEN
--
--
--
         IF (BSstatus IS NULL OR BSstatus != SUCCESS) THEN
            IF (pushTapeBackup(tapebkp)) THEN
               BSstatus := SUCCESS;
            END IF;
         END IF;
 
         resetthisBackupAge;            -- init stack, age, status variables
         tapebkp.delete;
         IF (BSstatus = AVAILABLE) THEN
--
--
--
            deb(DEB_IN, ' Added lastlrec:');
            lastrec.status_con := '*';
            rcvRecPush(lastrec);
         END IF;
         BSstatus := NULL;              -- reset backup status for next record
 
--
         IF NOT isTranslatedArchivedLog(
                   thread#   => brlrec.logThread_obj
                  ,sequence# => brlrec.logSequence_obj) THEN
            deb(DEB_IN, 'skip not translated brlrec' ||
                ' thread=' || brlrec.logThread_obj ||
                ' sequence=' || brlrec.logSequence_obj);
            goto nextbrlRec;
         END IF;
 
--
--
         lastrec := brlrec;
         deb(DEB_IN, 'looking backups for' ||
             ' thread=' || brlrec.logThread_obj ||
             ' sequence=' || brlrec.logSequence_obj);
      END IF;
 
      IF (BSstatus = SUCCESS) THEN
         deb(DEB_IN, 'skip already stacked brlrec' ||
             ' thread=' || brlrec.logThread_obj ||
             ' sequence=' || brlrec.logSequence_obj);
         goto nextbrlRec;
      END IF;
 
      IF (brlrec.type_con = backupSet_con_t) THEN
         deb(DEB_IN, 'found a backupset:');
         valRC :=
           validateBackupSet(backupSetRec           => brlrec,
                             checkDeviceIsAllocated => TRUE,
                             tag                    => restoreTag,
                             tagMatchRequired       => TRUE,
                             availableMask          => BSavailable,
                             validRec               => validateRec);
      ELSIF (brlrec.type_con = proxyCopy_con_t) THEN
         deb(DEB_IN, 'found a proxy copy:');
         IF (restoreTag is not NULL AND brlrec.tag_con != restoreTag) THEN
--
--
--
            deb(DEB_EXIT, 'tag does not match');
            valRC := UNAVAILABLE;
         ELSIF (anyDevice = TRUE# OR
                isDeviceTypeAllocated(brlrec.deviceType_con) = TRUE#) THEN
            valRC := SUCCESS;
         ELSE
            valRC := AVAILABLE;
         END IF;
      END IF;
 
      skipped := FALSE;
 
   <<addAnother>>
      IF (BSstatus IS NULL AND valRC = AVAILABLE) THEN
         BSstatus := valRC;
      END IF;
 
      IF (debug) THEN
         printRcvRec(brlrec);
      END IF;
 
      IF (valRC = SUCCESS) THEN
         IF (brlrec.type_con = backupSet_con_t) THEN
            brlrec.tag_con        := validateRec.tag;
            brlrec.deviceType_con := validateRec.deviceType;
            brlrec.copyNumber_con := validateRec.copyNumber;
         END IF;
 
--
--
--
--
         IF (NOT skipped AND
             brlrec.deviceType_con = 'DISK' AND
             thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
--
--
            skipped := TRUE;
            thisBackupAge  := thisBackupAge + 1;
         ELSE
            IF (brlrec.deviceType_con = 'DISK') THEN
               IF (NOT skipped) THEN
                  deb(DEB_IN, ' Added brlrec:');
                  rcvRecPush(brlrec);     -- add record for this action
                  BSstatus := SUCCESS;
               END IF;
            ELSE
--
               deb(DEB_IN, ' Added brlrec to tapebkp stack:' ||
                           to_char(tapebkp.count+1));
               tapebkp(tapebkp.count+1) := brlrec;
            END IF;
         END IF;
 
         IF (allCopies AND brlrec.type_con = backupSet_con_t) THEN
--
--
--
            valRC := validateBackupSet0(
                                  tag                    => restoreTag,
                                  tagMatchRequired       => TRUE,
                                  checkDeviceIsAllocated => TRUE,
                                  validRec               => validateRec);
            IF (valRC = SUCCESS) THEN
               GOTO addAnother;
            END IF;
         END IF;
      END IF;
   END LOOP;
 
   CLOSE findRangeArcLogBackup;
 
   deb(DEB_EXIT);
END findRangeArchivedLogBackup;
 
--
--
PROCEDURE findArchivedLogBackup(
   thread    IN number
  ,sequence  IN number
  ,lowSCN    IN number
  ,allCopies IN boolean default FALSE)
IS
   local        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'findArchivedLogBackup');
 
--
   setArchivedLogRecord(thread#   => thread
                       ,sequence# => sequence
                       ,first     => TRUE);
 
--
--
--
   findRangeArchivedLogBackup(minthread   => thread,
                             minsequence => sequence,
                             minlowSCN   => lowSCN,
                             maxthread   => thread,
                             maxsequence => sequence,
                             maxlowSCN   => lowSCN,
                             allCopies   => allCopies);
   IF (getRecStackCount = 0) THEN
      getBS_status := NULL;
      deb(DEB_EXIT, 'with UNAVAILABLE');
   ELSE
      rcvRecTop(local);
--
--
      IF (local.status_con = '*') THEN
         getBS_status := AVAILABLE;
         resetrcvRecStack;
         deb(DEB_EXIT, 'with AVAILABLE');
      ELSE
         getBS_status := SUCCESS;
         deb(DEB_EXIT, 'with SUCCESS');
      END IF;
   END IF;
END findArchivedLogBackup;
 
--
--
FUNCTION getArchivedLogBackup(
   rcvRec  OUT NOCOPY rcvRec_t)
RETURN binary_integer IS
   local        rcvRec_t;
BEGIN
   deb(DEB_ENTER, 'getArchivedLogBackup');
 
   IF (getRecStackCount = 0) THEN
      IF (getBS_status = SUCCESS) THEN
         deb(DEB_EXIT, 'with no more records');
         raise no_data_found;
      ELSIF (getBS_status = AVAILABLE) THEN
         deb(DEB_EXIT, 'with: AVAILABLE');
         RETURN AVAILABLE;
      ELSE
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN UNAVAILABLE;
      END IF;
   END IF;
 
   rcvRecPop(local);
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   deb(DEB_EXIT, 'with: SUCCESS');
   RETURN SUCCESS;
END getArchivedLogBackup;
 
--
--
--
 
--
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE         -- duplex copies
  ,redundancy IN number  default NULL          -- number of redundant copies
  ,rmanCmd    IN number  default unknownCmd_t) -- called for what rman command?
IS
  scn_warn number;
BEGIN
  findSpfileBackup(allCopies, redundancy, rmanCmd, scn_warn);
END findSpfileBackup;
 
PROCEDURE findSpfileBackup(
   allCopies  IN boolean default FALSE         -- duplex copies
  ,redundancy IN number  default NULL          -- number of redundant copies
  ,rmanCmd    IN number  default unknownCmd_t  -- called for what rman command?
  ,scn_warn  OUT number)
IS
   bsfrec       rcvRec_t;
   tag          varchar2(32);
   valRC        binary_integer;
   validateRec  validBackupSetRec_t;
   lcopies      number;
   findtime     date;
   estimated    boolean := TRUE;
BEGIN
   deb(DEB_ENTER, 'findSpfileBackup');
   validateState(null);
 
--
   scn_warn := 0;
   IF (untilScn IS NOT NULL AND untilTime IS NULL) THEN
      computeSpfileTime(untilScn, findtime, allIncarnations, estimated);
      IF estimated THEN scn_warn := 1; END IF;
   ELSE
      findtime := untilTime;
   END IF;
 
--
   deb(DEB_OPEN, 'findSpfileBackup_c,rmanCmd=' || rmanCmd);
 
   OPEN findSpfileBackup_c(untilTime => findTime,
                           rmanCmd   => rmanCmd);
 
--
--
--
   findSpfileBackupCursor := TRUE;
 
--
   resetthisBackupAge;
   getBS_status := NULL;
 
   resetrcvRecStack;
 
   IF (allCopies) THEN
      deb(DEB_IN, 'allCopies is TRUE');
   ELSE
      deb(DEB_IN, 'allCopies is FALSE');
   END IF;
 
   lcopies := redundancy;
 
--
   IF (rmanCmd = obsoleteCmd_t AND allCopies) THEN
      raise_application_error(-20999, 'internal error: findSpfileBackup_1');
   END IF;
 
   LOOP
      valRC := NULL;
 
      FETCH findSpfileBackup_c
       INTO bsfrec;
 
      EXIT WHEN findSpfileBackup_c%NOTFOUND ;
 
      IF user_site_key is not null and user_db_unique_name is NOT NULL THEN
         user_site_key := null;
         deb(DEB_IN, 'Spfile backups are identified based on db_unique_name');
      END IF;
 
      IF (rmanCmd = obsoleteCmd_t) THEN
--
--
         valRC := SUCCESS;
      ELSE
         valRC := validateBackupSet(
               backupSetRec           => bsfrec,
               tag                    => restoreTag,
               tagMatchRequired       => TRUE,
               checkDeviceIsAllocated => TRUE,
               availableMask          => BSavailable,
               validRec               => validateRec);
      END IF;
 
   <<addAnother>>
      IF (getBS_status IS NULL AND valRC = AVAILABLE) THEN
         getBS_status := valRC;
      END IF;
 
      IF (debug) THEN
         printRcvRec(bsfRec);
      END IF;
 
      IF (valRC = SUCCESS) THEN
         IF (thisBackupAge < rcvRecBackupAge) THEN
            deb(DEB_IN, 'skipping action because thisBackupAge (' ||
                         thisBackupAge || ') < rcvRecBackupAge('  ||
                         rcvRecBackupAge || ')');
            thisBackupAge  := thisBackupAge + 1;
         ELSIF (rmanCmd = obsoleteCmd_t) THEN
            deb(DEB_IN, ' Added bsfRec:');
 
            rcvRecPush(bsfRec);     -- add record for this action
            getBS_status := SUCCESS;
            IF (lcopies > 1) THEN
               lcopies := lcopies - 1;
            ELSE
               EXIT;              -- we are done
            END IF;
         ELSE
            deb(DEB_IN, ' Added bsfRec:');
 
            bsfrec.tag_con        := validateRec.tag;
            bsfrec.deviceType_con := validateRec.deviceType;
            bsfrec.copyNumber_con := validateRec.copyNumber;
 
            rcvRecPush(bsfRec);     -- add record for this action
 
            getBS_status := SUCCESS;
 
            IF (allCopies) THEN                   -- requested duplex copies
--
--
               valRC :=
                  validateBackupSet0(tag                    => restoreTag,
                                     tagMatchRequired       => TRUE,
                                     checkDeviceIsAllocated => TRUE,
                                     validRec               => validateRec);
               IF (valRC = SUCCESS) THEN
                  GOTO addAnother;
               END IF;
            END IF;
 
            IF (lcopies > 1) THEN
               lcopies := lcopies - 1;
            ELSE
               EXIT;              -- we are done
            END IF;
         END IF;
      END IF;
   END LOOP;
 
   CLOSE findSpfileBackup_c;
 
   IF (getBS_status = AVAILABLE) THEN
      deb(DEB_EXIT, 'with: AVAILABLE');
   ELSIF (getBS_status = SUCCESS) THEN
      deb(DEB_EXIT, 'with: SUCCESS');
   ELSE
      getBS_status := UNAVAILABLE;
      deb(DEB_EXIT, 'with: UNAVAILABLE');
   END IF;
END findSpfileBackup;
 
--
FUNCTION getSpfileBackup(
   rcvRec     OUT NOCOPY rcvRec_t
  ,redundancy IN         number default NULL
  ,rmanCmd    IN         number default unknownCmd_t)
RETURN number IS
   local        rcvRec_t;
   dummy        number;
BEGIN
   deb(DEB_ENTER, 'getSpfileBackup');
 
   IF (NOT findSpfileBackupCursor) THEN
--
      findSpfileBackup(allcopies  => FALSE,
                       redundancy => redundancy,
                       rmanCmd    => rmanCmd,
                       scn_warn   => dummy);
   END IF;
 
   IF (getRecStackCount = 0) THEN
      IF (getBS_status = SUCCESS) THEN
         deb(DEB_EXIT, 'with no more records');
         raise no_data_found;
      ELSIF (getBS_status = AVAILABLE) THEN
         deb(DEB_EXIT, 'with: AVAILABLE');
         RETURN AVAILABLE;
      ELSE
         deb(DEB_EXIT, 'with: UNAVAILABLE');
         RETURN UNAVAILABLE;
      END IF;
   END IF;
 
   rcvRecPop(local);
   IF (debug) THEN
      printRcvRec(local);
   END IF;
   rcvRec := local;
 
   deb(DEB_EXIT, 'with: SUCCESS');
   RETURN SUCCESS;
END getSpfileBackup;
 
--
PROCEDURE getCopyofDatafile(
   first           IN      boolean
  ,itag            IN      varchar2
  ,fno             OUT     number
  ,crescn          OUT     number
  ,rlogscn         OUT     number
  ,rlgtime         OUT     date
  ,recid           OUT     binary_integer
  ,stamp           OUT     binary_integer
  ,name            OUT     varchar2
  ,otag            OUT     varchar2
  ,status          OUT     varchar2
  ,nblocks         OUT     binary_integer
  ,bsz             OUT     binary_integer
  ,ctime           OUT     date
  ,toscn           OUT     number
  ,totime          OUT     date
  ,pluggedRonly    OUT     binary_integer
  ,pluginSCN       OUT     number
  ,pluginRlgSCN    OUT     number
  ,pluginRlgTime   OUT     date)
IS
   inc_idx     binary_integer;
BEGIN
   deb(DEB_ENTER, 'getCopyofDatafile');
 
   IF first THEN
      IF (getCopyofDatafile_c2%ISOPEN) THEN
         CLOSE getCopyofDatafile_c2;
      END IF;
 
      deb(DEB_PRINT, 'opening cursor');
      OPEN getCopyofDatafile_c2(itag);
   END IF;
 
<<next>>
   FETCH getCopyofDatafile_c2
    INTO fno, crescn, rlogscn, rlgtime, recid, stamp, name, otag, status,
         nblocks, bsz, ctime, toscn, totime, pluggedRonly, pluginSCN,
         pluginRlgSCN, pluginRlgTime;
 
   IF getCopyofDatafile_c2%NOTFOUND THEN
      deb(DEB_PRINT, 'closing cursor');
      CLOSE getCopyofDatafile_c2;
      deb(DEB_EXIT, 'with: no data found');
      RAISE no_data_found;
   END IF;
 
   FOR inc_idx in 0..max_inc_idx-1 LOOP
      IF (rlogscn = inc_list(inc_idx).resetlogs_change#  AND
          rlgtime = inc_list(inc_idx).resetlogs_time ) THEN
         IF (inc_idx = 0 OR
             toscn <= inc_list(inc_idx-1).resetlogs_change#) THEN
            deb(DEB_PRINT, 'matches inc=' ||inc_idx);
--
--
--
--
--
--
--
--
            EXIT;
--
         ELSE
            deb(DEB_PRINT, 'inc='||inc_idx|| ',toscn='||toscn||
                           ' exceeds '||inc_list(inc_idx-1).resetlogs_change#);
            deb(DEB_PRINT, 'belongs to orphan branch of this incarnation:');
            GOTO next;
         END IF;
      END IF;
   END LOOP;
 
   deb(DEB_EXIT, 'with: file found');
END getCopyOfDatafile;
 
--
--
PROCEDURE getCopyofDatafile(
   dfnumber        IN      number
  ,itag            IN      varchar2
  ,crescn          IN  OUT number
  ,rlogscn         IN  OUT number
  ,rlgtime         IN  OUT date
  ,recid           OUT     binary_integer
  ,stamp           OUT     binary_integer
  ,name            OUT     varchar2
  ,otag            OUT     varchar2
  ,status          OUT     varchar2
  ,nblocks         OUT     binary_integer
  ,bsz             OUT     binary_integer
  ,ctime           OUT     date
  ,toscn           OUT     number
  ,totime          OUT     date
  ,pluggedRonly    OUT     binary_integer
  ,pluginSCN       IN      number)
IS
BEGIN
OPEN getCopyofDatafile_c(dfnumber, itag, crescn, rlogscn,
                         rlgtime, pluginSCN);
 
FETCH getCopyofDatafile_c
 INTO recid, stamp, name, otag, status, nblocks,
      bsz, ctime, toscn, totime, crescn,
      rlogscn, rlgtime, pluggedRonly;
 
IF getCopyofDatafile_c%NOTFOUND THEN
   CLOSE getCopyofDatafile_c;
   RAISE no_data_found;
END IF;
 
CLOSE getCopyofDatafile_c;
END getCopyOfDatafile;
 
--
PROCEDURE getCopyofDatafile(
   dfnumber        IN  number
  ,itag            IN  varchar2
  ,crescn          IN  number
  ,rlogscn         IN  number
  ,rlgtime         IN  date
  ,recid           OUT binary_integer
  ,stamp           OUT binary_integer
  ,name            OUT varchar2
  ,otag            OUT varchar2
  ,status          OUT varchar2
  ,nblocks         OUT binary_integer
  ,bsz             OUT binary_integer
  ,ctime           OUT date
  ,toscn           OUT number
  ,totime          OUT date)
IS
   loc_crescn    number := crescn;
   loc_rlogscn   number := rlogscn;
   loc_rlgtime   date   := rlgtime;
   pluggedRonly  binary_integer;
   pluginSCN     number;
BEGIN
   getCopyOfDatafile(dfnumber  => dfnumber
                    ,itag      => itag
                    ,crescn    => loc_crescn
                    ,rlogscn   => loc_rlogscn
                    ,rlgtime   => loc_rlgtime
                    ,recid     => recid
                    ,stamp     => stamp
                    ,name      => name
                    ,otag      => otag
                    ,status    => status
                    ,nblocks   => nblocks
                    ,bsz       => bsz
                    ,ctime     => ctime
                    ,toscn     => toscn
                    ,totime    => totime
                    ,pluggedRonly => pluggedRonly
                    ,pluginSCN => 0);
END getCopyOfDatafile;
 
 
--
--
--
 
--
PROCEDURE setCompletedRange(
   after  IN date
  ,before IN date)
IS
BEGIN
   getRA_completedAfter  := after;
   getRA_completedBefore := before;
END setCompletedRange;
 
--
PROCEDURE setLikePattern(
   pattern IN varchar2)
IS
BEGIN
   getRA_likePattern := pattern;
END setLikePattern;
 
--
PROCEDURE setcanApplyAnyRedo(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'canApplyAnyRedo is set to TRUE');
      canApplyAnyRedo := TRUE#;
   ELSE
      deb(DEB_PRINT, 'canApplyAnyRedo is set to FALSE');
      canApplyAnyRedo := FALSE#;
   END IF;
END setcanApplyAnyRedo;
 
--
PROCEDURE setCanConvertCf(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'canConvert_Cf is set to TRUE');
      canConvert_Cf := TRUE#;
   ELSE
      deb(DEB_PRINT, 'canConvert_Cf is set to FALSE');
      canConvert_Cf := FALSE#;
   END IF;
END setCanConvertCf;
 
--
PROCEDURE setAllIncarnations(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'allIncarnations is set to TRUE');
      allIncarnations := TRUE#;
   ELSE
      deb(DEB_PRINT, 'allIncarnations is set to FALSE');
      allIncarnations := FALSE#;
   END IF;
END setAllIncarnations;
 
--
FUNCTION isTranslatedFno(fno IN NUMBER) RETURN NUMBER IS
BEGIN
   IF (tc_database = TRUE# OR fno = 0 OR tc_fno.exists(fno)) THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isTranslatedFno;
 
--
PROCEDURE setUntilResetlogs
IS
BEGIN
   untilSCN := this_reset_scn;
   untilTime := NULL;
   rpoint_set := FALSE;
 
   IF (this_reset_scn is NULL) THEN
      raise_application_error(-20020, 'Database incarnation not set');
   END IF;
END setUntilResetlogs;
 
--
PROCEDURE setGuid(
   guid IN varchar2 DEFAULT NULL)
IS
BEGIN
   guidQualifier := guid;
--
   guid2pdbKeyQualifier := guidToPdbKey(guid);
--
END setGuid;
 
--
--
--
--
PROCEDURE translateTempfile
IS
BEGIN
   IF (translateTempfile_c%ISOPEN) THEN
      validateState('translateTempfile_c');                  -- raise the error
   END IF;
 
   IF (pdbIdList.count = 0) THEN
      OPEN translateTempfile_c;
      getTempfileCursor := 'translateTempfile_c';
   ELSIF (pdbIdList.count = 1) THEN
      OPEN translateTempfileOfPdbId_c(pdbIdList.first + CONST2GVAL);
      getTempfileCursor := 'translateTempfileOfPdbId_c';
   ELSE
      OPEN translateTempfileOfPdbIdL_c;
      getTempfileCursor := 'translateTempfileOfPdbIdL_c';
   END IF;
END translateTempfile;
 
--
PROCEDURE translateTempfile(
   fname IN varchar2)
IS
BEGIN
   IF (translateTempfileName_c%ISOPEN) THEN
      validateState('translateTempfileName_c');              -- raise the error
   END IF;
 
   OPEN translateTempfileName_c(fileName => fname);
   getTempfileCursor := 'translateTempfileName_c';
END translateTempfile;
 
--
PROCEDURE translateTempfile(
   fno IN number)
IS
BEGIN
   IF (translateTempfileNumber_c%ISOPEN) THEN
      validateState('translateTempfileNumber_c');            -- raise the error
   END IF;
 
   OPEN translateTempfileNumber_c(fno => fno);
   getTempfileCursor := 'translateTempfileNumber_c';
END translateTempfile;
 
--
PROCEDURE getTempfile(
   tfRec  OUT NOCOPY tfRec_t)
IS
   eof   boolean := FALSE;
BEGIN
   IF (getTempfileCursor = 'translateTempfile_c') THEN
      FETCH translateTempfile_c
       INTO tfRec;
      IF (translateTempfile_c%NOTFOUND) THEN
         CLOSE translateTempfile_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileOfPdbId_c') THEN
      FETCH translateTempfileOfPdbId_c
       INTO tfRec;
      IF (translateTempfileOfPdbId_c%NOTFOUND) THEN
         CLOSE translateTempfileOfPdbId_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileOfPdbIdL_c') THEN
      FETCH translateTempfileOfPdbIdL_c
       INTO tfRec;
      IF (translateTempfileOfPdbIdL_c%NOTFOUND) THEN
         CLOSE translateTempfileOfPdbIdL_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileName_c') THEN
      FETCH translateTempfileName_c
       INTO tfRec;
      IF (translateTempfileName_c%NOTFOUND) THEN
         CLOSE translateTempfileName_c;
         eof := TRUE;
      END IF;
   ELSIF (getTempfileCursor = 'translateTempfileNumber_c') THEN
      FETCH translateTempfileNumber_c
       INTO tfRec;
      IF (translateTempfileNumber_c%NOTFOUND) THEN
         CLOSE translateTempfileNumber_c;
         eof := TRUE;
      END IF;
   ELSE
      deb(DEB_EXIT, 'with error 20204');
      raise_application_error(-20204, 'Translation not started');
   END IF;
 
   IF (eof) THEN
      getTempfileCursor := NULL;
      RAISE no_data_found;                   -- signal end-of-fetch
   END IF;
 
--
--
--
   IF (tfRec.pdbName IS NULL) THEN
      tfRec.pdbName := translatePdb2Name(tfRec.pdbid);
   END IF;
END getTempfile;
 
--
PROCEDURE translateDatafileCancel IS
BEGIN
   IF (getDatafileCursor = 'translateDatafileName') THEN
      CLOSE translateDatafileName;
   ELSIF (getDatafileCursor = 'translateDatafileNumber') THEN
      CLOSE translateDatafileNumber;
   ELSIF (getDatafileCursor = 'translateDatafileCheckpoint') THEN
      CLOSE translateDatafileCheckpoint;
   END IF;
   getDatafileCursor := NULL;                   -- we closed it above
   getDatafileNoRows.error := NULL;             -- clear for next time
   getDatafileLast.dfNumber := NULL;            -- clear for next time
END translateDatafileCancel;
 
--
FUNCTION Num2DisplaySize(input_size IN NUMBER) return VARCHAR2 IS
   OneK number := 1024;
   OneM number := OneK * 1024;
   OneG number := OneM * 1024;
   OneT number := OneG * 1024;
   OneP number := OneT * 1024;
BEGIN
   IF input_size IS NULL THEN
      return NULL;
   ELSE
     IF (input_size < OneM) THEN
        return to_char(input_size/OneK,'9990.09') ||'K';
     ELSIF (input_size < OneG)  THEN
        return to_char(input_size/OneM,'9990.09') ||'M';
     ELSIF (input_size < OneT) THEN
        return to_char(input_size/OneG,'9990.09') ||'G';
     ELSIF (input_size < OneP) THEN
        return to_char(input_size/OneT,'9990.09') ||'T';
     ELSE
        return to_char(input_size/OneP,'9990.09') ||'P';
     END IF;
   END IF;
END Num2DisplaySize;
 
--
FUNCTION Sec2DisplayTime(input_secs IN NUMBER) return VARCHAR2 IS
   inputsecs number ; 
BEGIN
   IF input_secs IS NULL THEN
      return NULL;
   END IF;
   inputsecs := round(input_secs) ;
   RETURN to_char(floor(inputsecs/3600),'FM09')||':'||
            to_char(floor(mod(inputsecs,3600)/60),'FM09')||':'||
            to_char(mod(inputsecs,60),'FM09');
END Sec2DisplayTime;
 
--
PROCEDURE setArchivedLogRecord(
   thread#   IN  number
  ,sequence# IN  number
  ,first     IN  boolean)
IS
  seqTab   sequenceTab_t;
  thrbck   binary_integer;
  seqbck   binary_integer;
BEGIN
   IF first THEN
      tc_threadSeq.delete;
   END IF;
 
--
   IF (thread# >= CONST2GVAL) THEN
      thrbck := CONST2GVAL - thread#;
   ELSE
      thrbck := thread#;
   END IF;
 
--
   IF (sequence# >= CONST2GVAL) THEN
      seqbck := CONST2GVAL - sequence#;
   ELSE
      seqbck := sequence#;
   END IF;
 
   IF NOT tc_threadSeq.exists(thrbck) THEN
      tc_threadSeq(thrbck) := seqTab;
   END IF;
   tc_threadseq(thrbck)(seqbck) := TRUE;
END setArchivedLogRecord;
 
--
PROCEDURE setCanHandleTransportableTbs(
   flag IN boolean)
IS
BEGIN
   IF (flag) THEN
      deb(DEB_PRINT, 'canHandleTransportableTbs is set to TRUE');
      canHandleTransportableTbs := TRUE#;
   ELSE
      deb(DEB_PRINT, 'canHandleTransportableTbs is set to FALSE');
      canHandleTransportableTbs := FALSE#;
   END IF;
END setCanHandleTransportableTbs;
 
--
PROCEDURE getRestorePoint(
   name         IN  varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number)
IS
   clean      number;
   out_con_id number;
BEGIN
   getRestorePoint(name, rlgscn, rlgtime, scn, guaranteed,
                   0, clean, out_con_id);
END getRestorePoint;
 
PROCEDURE getRestorePoint(
   name         IN  varchar2
  ,rlgscn       OUT number
  ,rlgtime      OUT date
  ,scn          OUT number
  ,guaranteed   OUT number
  ,con_id       IN  number
  ,clean        OUT number
  ,out_con_id   OUT number)
IS
   rsp  restore_point_c%ROWTYPE;
   rsp2 restore_point_c%ROWTYPE;
BEGIN
   deb(DEB_ENTER, 'getRestorePoint');
   IF (restore_point_c%isopen) THEN
      CLOSE restore_point_c;
   END IF;
 
   OPEN restore_point_c(con_id, name);
   FETCH restore_point_c INTO rsp;
   IF restore_point_c%NOTFOUND
   THEN
      rlgscn     := NULL;
      rlgtime    := NULL;
      scn        := NULL;
      guaranteed := NULL;
      clean      := NULL;
   ELSE
      rlgscn     := rsp.reset_scn;
      rlgtime    := rsp.reset_time;
      scn        := rsp.scn;
      out_con_id := rsp.con_id;
      IF (rsp.clean = 'YES')
      THEN
         clean := 1;
      ELSE
         clean := 0;
      END IF;
      IF (rsp.guaranteed = 'YES')
      THEN
        guaranteed := 1;
      ELSE
        guaranteed := 0;
      END IF;
   END IF;
 
   FETCH restore_point_c INTO rsp2;
 
--
   IF ((NOT restore_point_c%NOTFOUND) AND (rsp.con_id = rsp2.con_id))
   THEN
      deb(DEB_EXIT, 'with error 20513');
      raise_application_error(-20513,
         'Restore point name is ambiguous, specify the SCN instead');
   END IF;
   CLOSE restore_point_c;
   deb(DEB_EXIT);
END getRestorePoint;
 
--
PROCEDURE listTranslateRestorePoint(
   name       IN  varchar2)
IS
BEGIN
   deb(DEB_ENTER, 'listTranslateRestorePoint');
 
   IF (restore_point_c%isopen) THEN
      CLOSE restore_point_c;
   END IF;
 
   deb(DEB_OPEN, 'restore_point_c');
   OPEN restore_point_c(con_id => 0, name => name);
   deb(DEB_EXIT);
END listTranslateRestorePoint;
 
--
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2)
IS
  pdbname  varchar2(128);
BEGIN
   listGetRestorePoint(name, scn, rsptime, cretime, rsptype, pdbname);
END listGetRestorePoint;
   
PROCEDURE listGetRestorePoint(
   name         OUT varchar2
  ,scn          OUT number
  ,rsptime      OUT date
  ,cretime      OUT date
  ,rsptype      OUT varchar2
  ,pdbname      OUT varchar2)
IS
   rsp restore_point_c%ROWTYPE;
BEGIN
   deb(DEB_ENTER, 'listGetRestorePoint');
 
   FETCH restore_point_c INTO rsp;
   IF (restore_point_c%NOTFOUND) THEN
      CLOSE restore_point_c;
      deb(DEB_EXIT, 'with no more records');
      RAISE no_data_found;
   END IF;
 
   name := rsp.name;
   scn := rsp.scn;
   rsptime := rsp.restore_point_time;
   cretime := rsp.creation_time;
--
   rsptype := ' ';
   IF rsp.preserved = 'YES'
   THEN
     rsptype := 'PRESERVED';
   END IF;
--
   IF rsp.guaranteed = 'YES'
   THEN
     rsptype := 'GUARANTEED';
   END IF;
   pdbname := translatePdb2Name(rsp.con_id);
   deb(DEB_EXIT);
END listGetRestorePoint;
 
--
PROCEDURE setDbidTransClause(dbid IN  number)
IS
  dbidbck  binary_integer;
BEGIN
--
   IF (dbid >= CONST2GVAL) THEN
      dbidbck := CONST2GVAL - dbid;
   ELSE
      dbidbck := dbid;
   END IF;
   tc_dbid(dbidbck) := TRUE;
END setDbidTransClause;
 
--
FUNCTION isTranslatedDbid(dbid IN NUMBER) RETURN NUMBER
IS
  dbidbck  binary_integer;
BEGIN
   IF (tc_anydbid = TRUE#) THEN
      RETURN TRUE#;
   ELSE
--
      IF (dbid >= CONST2GVAL) THEN
         dbidbck := CONST2GVAL - dbid;
      ELSE
         dbidbck := dbid;
      END IF;
      IF (tc_dbid.exists(dbidbck)) THEN
         RETURN TRUE#;
      END IF;
   END IF;
   RETURN FALSE#;
END isTranslatedDbid;
 
--
FUNCTION translatePdbName(pdbName IN VARCHAR2) RETURN NUMBER IS
BEGIN
   initPdbNameList;
 
   IF (pdbNameList.exists(pdbName)) THEN
      RETURN pdbNameList(pdbName);
   ELSE
      RETURN NULL;
   END IF;
END translatePdbName;
 
--
PROCEDURE resetPdbIdList IS
BEGIN
   pdbIdList.delete;
END resetPdbIdList;
 
--
PROCEDURE setPdbId(pdbId IN NUMBER, first IN BOOLEAN) IS
BEGIN
   IF (first) THEN
      resetPdbIdList;
   END IF;
 
   pdbIdList(pdbId - CONST2GVAL) := TRUE;
END setPdbId;
 
--
FUNCTION isTranslatedPdbId(pdbId IN NUMBER) RETURN NUMBER IS
BEGIN
   IF (pdbIdList.exists(pdbId - CONST2GVAL)) THEN
      RETURN TRUE#;
   END IF;
   
   RETURN FALSE#;
END isTranslatedPdbId;
 
--
FUNCTION isPdbScnOrphan(untilSCN IN NUMBER, pdbId IN NUMBER)
RETURN NUMBER IS
   toSCN NUMBER := untilSCN - 1;
BEGIN
   IF (isPdbScnOrphan(0, toSCN, 0, pdbId)) THEN
      RETURN TRUE#;
   ELSE
      RETURN FALSE#;
   END IF;
END isPdbScnOrphan;
 
--
FUNCTION translatePdb2Name(pdbId IN NUMBER) RETURN VARCHAR2 IS
   pdbname  VARCHAR2(128);
BEGIN
--
--
   IF (pdbId IS NULL) THEN
      RETURN NULL;
   END IF;
 
   IF (pdbId <= 1) THEN
      RETURN NULL;
   END IF;
 
   initPdbNameList;
 
   pdbname := pdbNameList.first;
   WHILE pdbname IS NOT NULL
   LOOP
      IF (pdbNameList(pdbname) = pdbId) THEN
         RETURN pdbname;
      END IF; 
      pdbname := pdbNameList.next(pdbname);
   END LOOP;
 
   RETURN NULL;
END translatePdb2Name;
 
--
PROCEDURE setRestoreRangeDevTyp(typ IN VARCHAR2)
IS
BEGIN
   deb(DEB_ENTER, 'setRestoreRangeDevTyp');
 
   restoreRangeDevTyp := typ;
   deb(DEB_EXIT);
END setRestoreRangeDevTyp;
 
--
PROCEDURE resetRestoreRangeDevTyp
IS
BEGIN
   deb(DEB_ENTER, 'resetRestoreRangeDevTyp');
 
   restoreRangeDevTyp := null;
   deb(DEB_EXIT);
END resetRestoreRangeDevTyp;
 
--
PROCEDURE translatePrePluginDf(con_id IN number)
IS
BEGIN
   deb(DEB_ENTER, 'translatePrePluginDf');
--
   raise_application_error(-20999, 'Not supported in recovery catalog');
--
 
   deb(DEB_EXIT);
END translatePrePluginDf;
 
--
FUNCTION getPrePluginDf(
   prePluginDfRec OUT NOCOPY prePluginDfRec_t)
RETURN NUMBER IS
BEGIN
   deb(DEB_ENTER, 'getPrePluginDf');
--
   raise_application_error(-20999, 'Not supported in recovery catalog');
--
 
   deb(DEB_EXIT, 'with FALSE#');
   RETURN FALSE#;
END getPrePluginDf;
 
--
PROCEDURE setBigScnAware
IS
BEGIN
   deb(DEB_PRINT, 'Database is BIGSCN aware, higscnval set to UB8MAXVAL');
   highscnval := UB8MAXVAL; 
END setBigScnAware;
 
--
FUNCTION isNoBackupPdb(pdbname IN VARCHAR2)
RETURN NUMBER IS 
   nobackup NUMBER;
BEGIN
   deb(DEB_ENTER, 'isNoBackupPdb');
   IF (translateNoBackupPdb_c%ISOPEN) THEN
      CLOSE translateNoBackupPdb_c;
   END IF;
 
   OPEN translateNoBackupPdb_c(pdbname => pdbname);
   FETCH translateNoBackupPdb_c INTO nobackup;
   IF (translateNoBackupPdb_c%NOTFOUND) THEN
      nobackup := 0;
   END IF;
   CLOSE translateNoBackupPdb_c;
   deb(DEB_EXIT, 'with '||nobackup);
   RETURN nobackup;
END isNoBackupPdb;
 
--
--
--
 
--
PROCEDURE listApplicationPdbs(
   root_con_id       IN number)
IS
BEGIN
   deb(DEB_ENTER, 'listApplicationPdbs');
--
      raise_application_error(-20999, 'Not supported in recovery catalog');
--
   deb(DEB_EXIT);
END listApplicationPdbs;
 
--
FUNCTION listGetAppPdb(
   pdb_name          OUT varchar2)
RETURN number IS
BEGIN
   deb(DEB_ENTER, 'listGetAppPdb');
   deb(DEB_EXIT);
END listGetAppPdb;
 
--
 
--
--
--
 
BEGIN
--
--
   versionList(1) := '08.00.04.00';
   versionList(2) := '08.00.05.00';
   versionList(3) := '08.01.03.00';
   versionList(4) := '08.01.05.00';
   versionList(5) := '08.01.06.00';
   versionList(6) := '08.01.07.00';
   versionList(7) := '09.00.00.00';
   versionList(8) := '09.02.00.00';
   versionList(9) := '10.01.00.00';
   versionList(10):= '10.02.00.00';
   versionList(11):= '10.02.00.01';
   versionList(12):= '11.01.00.00';
   versionList(13):= '11.01.00.01';
   versionList(14):= '11.01.00.02';
   versionList(15):= '11.01.00.03';
   versionList(16):= '11.01.00.04';
   versionList(17):= '11.01.00.05';
   versionList(18):= '11.01.00.06';
   versionList(19):= '11.01.00.07';
   versionList(20):= '11.02.00.00';
   versionList(21):= '11.02.00.01';
   versionList(22):= '11.02.00.02';
   versionList(23):= '12.01.00.00';
   versionList(24):= '12.01.00.01';
   versionList(25):= '12.01.00.02';
   versionList(26):= '12.02.00.00';
   versionList(27):= '12.02.00.01';
 
--
   versionCounter  := 1;
   versionMaxIndex := 27;               -- must match highest index used above
 
   resetAll;                              -- init package variables to defaults
END dbms_rcvman;
 
